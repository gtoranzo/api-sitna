{"version":3,"sources":["layer/Raster.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","Consts","BLANK_IMAGE","capabilitiesPromises","isWebWorkerEnabled","window","hasOwnProperty","wwPromise","Promise","resolve","reject","wwLocation","Util","isSameOrigin","ajax","url","method","responseType","then","response","data","blob","Blob","type","URL","createObjectURL","e","Error","capabilitiesError","reason","getCapabilitiesOnline","getGetCapabilitiesUrl","toolProxification","fetch","retryAttempts","capabilities","documentElement","serviceException","getElementsByTagName","error","textContent","format","layerType","WMTS","wrap","WmtsParser","WmsParser","read","Contents","layerCollection","i","len","length","curXmlLy","id","getElementByNodeName","firstChild","capLy","filter","ly","Identifier","j","TileMatrixSetLink","xmlLink","capLink","matrixId","TileMatrixSet","xmlLinks","k","kk","curLink","querySelector","TileMatrixSetLimits","tmlCollection","lim","push","TileMatrix","MinTileRow","parseInt","MinTileCol","MaxTileRow","MaxTileCol","storeCapabilities","wwUrl","worker","Worker","onmessage","state","terminate","postMessage","text","parseCapabilities","responseText","catch","dataError","loadJS","localforage","LOCALFORAGE","capKey","CAPABILITIES_STORE_KEY_PREFIX","options","setItem","getCapabilitiesPromise","err","console","log","map","loaded","_getLayerNodeIndex","treeNode","result","availableNames","indexOf","name","children","_getLayerNamePosition","counter","count","Raster","self","this","tool","Proxification","proxify","_capabilitiesPromise","apply","arguments","transparent","params","layerNames","names","split","Array","isArray","undefined","isVisible","sldBody","sld_body","parser","DOMParser","sldBodyToXml","parseFromString","message","namedLayerElm","ignorePrefixes","_capabilitiesNodes","_promise","_createOLLayer","ollyr","GROUP","createWMTSLayer","join","LAYERS","FORMAT","TRANSPARENT","VERSION","version","extend","queryParams","infoFormat","getPreferredInfoFormat","INFO_FORMAT","createWMSLayer","getGetMapUrl","_createWMSLayer","setLayer","processedCapabilities","actualUrl","cachePromise","res","rej","onlinePromise","storagePromise","getItem","value","trigger","event","LAYERERROR","_disgregatedLayerNames","setWMTSUrl","inherit","layerProto","prototype","PROTOCOL_REGEX","capabilitiesState_","PENDING","DONE","getByProxy_","getBySSL_","replace","getByUrl_","setVisibility","visible","tree","_cache","visibilityStates","call","_aggregateLayerNodeNames","layerNode","getLayerNodes","idx","firstIdx","nodeNames","elm","getName","reverse","fail","nodeName","splice","_disgregateLayerNames","ln","slice","rootNode","getRootLayerNode","concat","_disgregateLayerName","ancestorVisible","nodeVisible","compareNames","hasEmptyChildren","_extendLayerNameOptions","aggregate","lazy","_combineArray","source","add","rem","a","r","sa","_sortLayerNames","getTree","sort","b","idxa","idxb","_isNameInArray","looseComparison","getLimitedMatrixSet","layerId","matrixSet","cap","ret","tset","elto","limit","limits","matrix","combi","matrixIndex","_getLimitedMatrixSet","setLayerNames","getLayer","opts","WMS","_aggregateLayerNames","newParams","_newParams","getParams","BEFOREUPDATEPARAMS","setParams","reset","UPDATEPARAMS","addLayerNames","ln2a","getDisgregatedLayerNames","removeLayerNames","ln2r","toggleLayerNames","ln2t","currentLayerNames","l","promises","all","arrays","a1","a2","olLayer","isNative","isValidFromNames","getLayerNodeByName","isCompatible","crs","getCompatibleMatrixSets","getCompatibleCRS","includeFallback","fallbackLayer","fbLayer","getFallbackLayer","normalized","getCRSCode","code","reduce","prev","cur","getProjection","getSource","getCode","setProjection","setMatrixSet","mustReproject","isVisibleByScale","nameOrUid","currentScale","_getOgcScale","getResolution","getMetersPerUnit","tileMatrix","getTileMatrix","scaleDenominators","getScaleDenominators","layers","getAllLayerNodes","node","toString","parseFloat","some","nodeLayer","isVisibleByName","getWMTSLayer","__getLayerPath","capabilitiesNode","n","layerNodes","fastUnshift","path","_getLayerPath","getTreeNode","forceAddition","isRootNode","uid","key","getUID","child","title","Title","isBase","isDefault","thumbnail","legend","src","getVisibility","inverseTree","getLegend","hideTree","cache","_setNodeState","_result","visibility","NOT_VISIBLE","hasVisible","hasNotVisible","VISIBLE","HAS_VISIBLE","visibilityState","_sortTree","n1","n2","customLegend","setNodeVisibility","findNode","_getNames","getNodeVisibility","getNodePath","layerName","ignorePrefix","_getPath","getPath","getServiceType","getIdentifier","nodes","getChildrenLayers","_fnRecursiva","lyr","arr","lc","idx1","idx2","substr","getResolutions","setResolutions","resolutions","searchSubLayers","patternFn","t","lastPattern","lastMatches","re","RegExp","matches","ix","tcScore","tcPosition","normalizeLayerNode","trim","exec","titleIx","index","abstractIx","Abstract","abs","res2","titleA","replaceAccent","titleB","serviceUrl","encoding","WMTSEncoding","RESTFUL","suffix","suffixIdx","SERVICE","REQUEST","getParamString","match","cleanOgcUrl","infoFormats","getInfoFormats","infoFormatPreference","getLegendGraphicImage","base64LegendSrc","btoa","info","getInfo","xhr","XMLHttpRequest","dataEntries","chunks","env","open","setRequestHeader","onload","status","uInt8Array","Uint8Array","binaryString","String","fromCharCode","getResponseHeader","imageSrc","send","getUrl","getWebGLUrl","location","_src","isSecureURL","toAbsolutePath","ignoreProxification","exportable","fetchImage","cacheHost","getAction","action","getFeatureUrl","getSiblingLoadedLayer","dynamicStatement","baseLayers","workLayers","elem","isFunction","getImageLoad","image","setSRC","olImg","getImage","mustBeExportable","crossOrigin","setAttribute","_get$events","TILELOAD","tile","TILELOADERROR","statusText","z","x","y","parts","wmtsOptions","level","on3DView","BEFORETILELOAD","param","values","toLowerCase","fetchImageAsBlob","contentType","imageUrl","evt","revokeObjectURL","img","onerror","$events","getWFSCapabilitiesPromise","newUrl","basicUrl","substring","WFScapabilities","setTimeout","xmlDoc","ownerDocument","errorNode","innerHTML","WFSCapabilities","Parse","Operations","_url","GetCapabilities","DCP","HTTP","Get","DCPType","onlineResource","availableBaseLayers","Cfg","forEach","baseLayer","stealth","firstOption","esriParser","parse","dom","tagName","fiCollections","fic","getAttribute","fInfos","lenj","fields","attributes","lenk","field","getElementText","feature","ol","Feature","setId"],"mappings":"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","sourcesContent":["\r\nTC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\nTC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';\r\n\r\n(function () {\r\n\r\n    var capabilitiesPromises = {};\r\n\r\n    const isWebWorkerEnabled = window.hasOwnProperty('Worker');\r\n    const wwPromise = new Promise(function (resolve, reject) {\r\n        if (isWebWorkerEnabled) {\r\n            // Para evitar problemas con IE10 y Opera evitamos el uso de blobs cuando es evitable\r\n            var wwLocation = TC.apiLocation + 'TC/workers/tc-caps-web-worker.js';\r\n            if (TC.Util.isSameOrigin(TC.apiLocation)) {\r\n                resolve(wwLocation);\r\n            }\r\n            else {\r\n                TC.ajax({\r\n                    url: wwLocation,\r\n                    method: 'GET',\r\n                    responseType: 'text'\r\n                }).then(\r\n                    function (response) {\r\n                        const data = response.data;\r\n                        var blob = new Blob([data], { type: \"text/javascript\" });\r\n                        var url = window.URL.createObjectURL(blob);\r\n                        resolve(url);\r\n                    },\r\n                    function (e) {\r\n                        reject(Error(e));\r\n                    }\r\n                    );\r\n            }\r\n        }\r\n    });\r\n\r\n    const parseCapabilities = function (layer, data) {\r\n        var capabilities;\r\n\r\n        if (data.documentElement) {\r\n\r\n            const serviceException = data.getElementsByTagName('ServiceException')[0];\r\n            if (serviceException) {\r\n                capabilities = { error: serviceException.textContent };\r\n            }\r\n            else {\r\n                var format = (layer.type === TC.Consts.layerType.WMTS) ? new layer.wrap.WmtsParser() : new layer.wrap.WmsParser();\r\n                capabilities = format.read(data);\r\n\r\n                //parsear a manija los tileMatrixSetLimits, que openLayers no lo hace (de momento)\r\n                if (layer.type === TC.Consts.layerType.WMTS) {\r\n                    if (capabilities.Contents && capabilities.Contents.Layer) {\r\n                        const layerCollection = data.getElementsByTagName('Layer');\r\n                        for (var i = 0, len = layerCollection.length; i < len; i++) {\r\n                            const curXmlLy = layerCollection[i];\r\n                            var nd = TC.Util.getElementByNodeName(curXmlLy, \"ows:Identifier\")[0];\r\n                            var id = nd.firstChild.data;\r\n\r\n                            var capLy = capabilities.Contents.Layer.filter(function (ly) {\r\n                                return ly.Identifier == id;\r\n                            });\r\n\r\n                            if (capLy.length) {\r\n                                capLy = capLy[0];\r\n                                for (var j = 0; j < capLy.TileMatrixSetLink.length; j++) {\r\n                                    var capLink = capLy.TileMatrixSetLink[j];\r\n                                    matrixId = capLink.TileMatrixSet;\r\n\r\n                                    var xmlLink;\r\n                                    const xmlLinks = curXmlLy.getElementsByTagName('TileMatrixSetLink');\r\n                                    for (var k = 0, kk = xmlLinks.length; k < kk; k++) {\r\n                                        const curLink = xmlLinks[k];\r\n                                        if (curLink.querySelector(\"TileMatrixSet:first\").textContent == matrixId) {\r\n                                            xmlLink = curLink;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n\r\n                                    if (xmlLink) {\r\n                                        capLink.TileMatrixSetLimits = [];\r\n                                        const tmlCollection = xmlLink.getElementsByTagName('TileMatrixLimits');\r\n                                        for (var k = 0, kk = tmlCollection.length; k < kk; k++) {\r\n                                            const lim = tmlCollection[k];\r\n                                            capLink.TileMatrixSetLimits.push({\r\n                                                TileMatrix: lim.getElementsByTagName('TileMatrix')[0].textContent,\r\n                                                MinTileRow: parseInt(lim.getElementsByTagName('MinTileRow')[0].textContent),\r\n                                                MinTileCol: parseInt(lim.getElementsByTagName('MinTileCol')[0].textContent),\r\n                                                MaxTileRow: parseInt(lim.getElementsByTagName('MaxTileRow')[0].textContent),\r\n                                                MaxTileCol: parseInt(lim.getElementsByTagName('MaxTileCol')[0].textContent)\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            storeCapabilities(layer, capabilities);\r\n            return Promise.resolve(capabilities);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve, reject) {\r\n                if (isWebWorkerEnabled && typeof data === 'string') {\r\n                    wwPromise.then(function (wwUrl) {\r\n                        var worker = new Worker(wwUrl);\r\n                        worker.onmessage = function (e) {\r\n                            if (e.data.state === 'success') {\r\n                                capabilities = e.data.capabilities;\r\n\r\n                                // GLS: Sólo almacenamos si el capabilities es correcto\r\n                                storeCapabilities(layer, capabilities);\r\n                            }\r\n                            else {\r\n                                capabilities = {\r\n                                    error: 'Web worker error'\r\n                                }\r\n                                reject(capabilities.error);\r\n                            }\r\n\r\n                            resolve(capabilities);\r\n                            worker.terminate();\r\n                        };\r\n                        worker.postMessage({\r\n                            type: layer.type,\r\n                            text: data\r\n                        });\r\n                    })\r\n                }\r\n                else {\r\n                    capabilities = data;\r\n                    resolve(capabilities);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    const capabilitiesError = function (layer, reason) {\r\n        return 'No se pudo obtener el documento de capacidades del servicio ' + layer.url + ': [' + reason + ']';\r\n    };\r\n\r\n    const getCapabilitiesOnline = function (layer) {\r\n        return new Promise(function (resolve, reject) {\r\n            const url = layer.getGetCapabilitiesUrl();\r\n\r\n            layer.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {\r\n                parseCapabilities(layer, data.responseText)\r\n                    .then(function (capabilities) {\r\n                        if (capabilities.error) {\r\n                            reject(Error(capabilitiesError(layer, capabilities.error)));\r\n                            return;\r\n                        }\r\n                        resolve(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        reject(Error(error));\r\n                    });\r\n            }).catch(function (dataError) {\r\n                reject(Error(capabilitiesError(layer, dataError)));\r\n            });\r\n\r\n        });\r\n    };\r\n\r\n    const getCapabilitiesFromStorage = function (layer) {\r\n        return new Promise(function (resolve, reject) {\r\n            // Obtenemos el capabilities almacenado en caché\r\n            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {\r\n                localforage.getItem(layer.CAPABILITIES_STORE_KEY_PREFIX + layer.url)\r\n                    .then(function (value) {\r\n                        if (value) {\r\n                            resolve(value);\r\n                        }\r\n                        else {\r\n                            reject(Error('Capabilities not in storage: ' + layer.url));\r\n                        }\r\n                    })\r\n                    .catch(function () {\r\n                        reject(Error('Undefined storage error'));\r\n                    });\r\n            });\r\n        });\r\n    };\r\n\r\n    const storeCapabilities = function (layer, capabilities) {\r\n        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {\r\n\r\n            // Esperamos a que el mapa se cargue y entonces guardamos el capabilities.\r\n            // Así evitamos que la operación, que es bastante pesada, ocupe tiempo de carga \r\n            // (con el efecto secundario de que LoadingIndicator esté un tiempo largo apagado durante la carga)\r\n            var capKey = layer.CAPABILITIES_STORE_KEY_PREFIX + layer.options.url;\r\n            var setItem = function () {\r\n                // GLS: antes de guardar, validamos que es un capabilities sin error\r\n                if (capabilities.hasOwnProperty(\"error\")) {\r\n                    return;\r\n                } else {\r\n\r\n                    layer.getCapabilitiesPromise().then(function () {\r\n                        localforage.setItem(capKey, capabilities).then(function () { }).catch(function (err) {\r\n                            console.log(err);\r\n                        });\r\n                    });\r\n                }\r\n            };\r\n            if (layer.map) {\r\n                layer.map.loaded(setItem);\r\n            }\r\n            else {\r\n                setItem();\r\n            }\r\n        });\r\n    };\r\n\r\n    const _createWMSLayer = function (layer) {\r\n\r\n        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;\r\n        var format = layer.options.format;\r\n        var options = layer.options;\r\n\r\n        var params = {\r\n            LAYERS: layerNames,\r\n            FORMAT: format,\r\n            TRANSPARENT: layer.transparent,\r\n            VERSION: layer.capabilities.version || '1.3.0'\r\n        };\r\n\r\n        if (layer.params) {\r\n            TC.Util.extend(params, layer.params);\r\n        }\r\n\r\n        if (layer.queryParams) {\r\n            TC.Util.extend(params, layer.queryParams);\r\n        }\r\n\r\n        var infoFormat = layer.getPreferredInfoFormat();\r\n        if (infoFormat !== null) {\r\n            params.INFO_FORMAT = infoFormat;\r\n        }\r\n\r\n        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);\r\n    };\r\n\r\n    const _createWMTSLayer = function (layer) {\r\n        return layer.wrap.createWMTSLayer(layer.options);\r\n    };\r\n\r\n    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {\r\n\r\n        var result = layer.availableNames.indexOf(treeNode.name);\r\n        if (result === -1) {\r\n            for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n                result = _getLayerNodeIndex(layer, treeNode.children[i]);\r\n                if (result !== -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const _sortTree = function _sortTree(layer, treeNode) {\r\n        var _sortFunction = function (n1, n2) {\r\n            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);\r\n        }\r\n        treeNode.children.sort(_sortFunction);\r\n        for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n            _sortTree(layer, treeNode.children[i]);\r\n        }\r\n    };\r\n\r\n    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {\r\n        var result = false;\r\n        counter.count = counter.count + 1;\r\n        if (treeNode.name === name) {\r\n            result = true;\r\n        }\r\n        else {\r\n            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés\r\n            for (var i = treeNode.children.length - 1; i >= 0; i--) {\r\n                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Opciones de nombre de capa.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.LayerNameOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.\r\n     * @property aggregate\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n    /**\r\n     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} (valor <code>false</code>) \r\n     * o se espera a que la capa se actualice (valor <code>true</code>).\r\n     * @property lazy\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n    /**\r\n     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/availableNames:property\"}}{{/crossLink}} (valor <code>false</code>) se restablece \r\n     * al actualizar la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}}.\r\n     * @property reset\r\n     * @type boolean|undefined\r\n     */\r\n\r\n    /**\r\n     * Opciones de capa raster.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.RasterOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.WMS\r\n     */\r\n    /**\r\n     * URL del servicio OGC que define la capa.\r\n     * @property url\r\n     * @type string\r\n     */\r\n    /**\r\n     * Indica si la capa tiene transparencia.\r\n     * @property transparent\r\n     * @type boolean|undefined\r\n     */\r\n    /**\r\n     * Lista separada por comas de los nombres de capa del servicio OGC.\r\n     * @property layerNames\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.\r\n     * @property matrixSet\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo raster, como la de un WMS o un WMTS.\r\n     * @class TC.layer.Raster\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Raster = function () {\r\n        var self = this;\r\n\r\n        if (!TC.tool || !TC.tool.Proxification) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');\r\n        }\r\n\r\n        this.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        this._capabilitiesPromise = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.wrap = new TC.wrap.layer.Raster(self);\r\n\r\n        /**\r\n         * Indica si la capa tiene transparencia.\r\n         * @property transparent\r\n         * @type boolean\r\n         * @default true\r\n         */\r\n        self.transparent = (self.options.transparent === false) ? false : true;\r\n\r\n        /**\r\n         * URL del servicio al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        self.url = self.options.url;\r\n        self.capabilities = TC.capabilities[self.url];\r\n\r\n        self.params = self.options.params;\r\n        /**\r\n         * Lista de nombres de capa.\r\n         * @property names\r\n         * @type array\r\n         * @default []\r\n         */\r\n        /**\r\n         * Lista de nombres de capa disponibles inicialmente.\r\n         * @property availableNames\r\n         * @type array\r\n         * @default []\r\n         */\r\n        if (typeof self.options.layerNames === 'string') {\r\n            self.names = self.availableNames = self.options.layerNames.split(',');\r\n        }\r\n        else {\r\n            self.names = [];\r\n            self.availableNames = [];\r\n            if (Array.isArray(self.options.layerNames)) {\r\n                for (var i = 0; i < self.options.layerNames.length; i++) {\r\n                    var name = self.options.layerNames[i];\r\n                    if (typeof name === 'string') {\r\n                        self.names.push(name);\r\n                        self.availableNames.push(name);\r\n\r\n                    }\r\n                    else if (name.hasOwnProperty('name')) {\r\n                        self.availableNames.push(name.name);\r\n                        if (name.isVisible === undefined || name.isVisible) {\r\n                            self.names.push(name.name);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado\r\n                // cuando queremos instanciar una capa pasándole un SLD en la petición\r\n                var sldBody = self.options.params ? self.options.params.sld_body : null;\r\n\r\n                if (sldBody) {\r\n                    const parser = new DOMParser();\r\n                    var sldBodyToXml;\r\n                    try {\r\n                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');\r\n                    }\r\n                    catch (e) {\r\n                        TC.error(e.message);\r\n                        sldBodyToXml = null;\r\n                    }\r\n                    if (sldBodyToXml) {\r\n                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');\r\n                        if (namedLayerElm && namedLayerElm.length > 0) {\r\n                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');\r\n\r\n                            if (names && names.length > 0) {\r\n                                var name = names[0].textContent;\r\n                                self.names.push(name);\r\n                                self.availableNames.push(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;\r\n\r\n        self._capabilitiesNodes = {};\r\n\r\n        /**\r\n      * Árbol del documento de capabilities del servicio.\r\n      * @property capabilities\r\n      * @type object\r\n      */\r\n        self.wrap._promise = new Promise(function (resolve, reject) {\r\n            /*\r\n             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo\r\n             */\r\n            var _createOLLayer = function () {\r\n                var ollyr;\r\n                if (!self.wrap.layer) {\r\n                    switch (self.type) {\r\n                        case TC.Consts.layerType.GROUP:\r\n                            break;\r\n                        case TC.Consts.layerType.WMTS:\r\n                            ollyr = _createWMTSLayer(self);\r\n                            break;\r\n                        default:\r\n                            ollyr = _createWMSLayer(self);\r\n                            break;\r\n                    }\r\n                    self.wrap.setLayer(ollyr);\r\n                    if (ollyr) {\r\n                        resolve(ollyr);\r\n                    }\r\n                    else {\r\n                        reject(Error('Could not create native layer for \"' + self.id + '\"'));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const processedCapabilities = function (capabilities) {\r\n                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                self.capabilities = self.capabilities || capabilities;\r\n\r\n                var actualUrl = self.getGetMapUrl();\r\n                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;\r\n                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;\r\n\r\n                _createOLLayer();\r\n            };\r\n\r\n            if (self.capabilities) {\r\n                processedCapabilities(self.capabilities);\r\n                self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                return;\r\n            }\r\n\r\n            const cachePromise = capabilitiesPromises[self.url];\r\n            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {\r\n                const onlinePromise = getCapabilitiesOnline(self);\r\n                const storagePromise = getCapabilitiesFromStorage(self);\r\n\r\n                onlinePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        storagePromise.catch(function () {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n                storagePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function () {\r\n                        onlinePromise.catch(function (error) {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n            });\r\n\r\n            self.getCapabilitiesPromise()\r\n                .then(function (capabilities) {\r\n                    processedCapabilities(capabilities);\r\n                })\r\n                .catch(function (error) {\r\n                    if (self.map) {\r\n                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });\r\n                    }\r\n                    reject(error);\r\n                });\r\n        });\r\n\r\n        self._disgregatedLayerNames = null;\r\n\r\n        if (TC.Consts.layerType.WMTS == self.type) {\r\n            self.wrap.setWMTSUrl();\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.layer.Raster, TC.Layer);\r\n\r\n    var layerProto = TC.layer.Raster.prototype;\r\n\r\n    layerProto.PROTOCOL_REGEX = /^(f|ht)tp?:\\/\\//i;\r\n    layerProto.capabilitiesState_ = {\r\n        PENDING: 0,\r\n        DONE: 1\r\n    };\r\n\r\n    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';\r\n\r\n    layerProto.getByProxy_ = function (url) {\r\n        return TC.proxify(url);\r\n    };\r\n\r\n    layerProto.getBySSL_ = function (url) {\r\n        var self = this;\r\n\r\n        return url.replace(self.PROTOCOL_REGEX, \"https://\");\r\n    };\r\n\r\n    layerProto.getByUrl_ = function (url) {\r\n        return url;\r\n    };\r\n\r\n\r\n    layerProto.setVisibility = function (visible) {\r\n        var layer = this;\r\n        layer.tree = null;\r\n        layer._cache.visibilityStates = {\r\n        };\r\n        TC.Layer.prototype.setVisibility.call(layer, visible);\r\n    };\r\n\r\n    /*\r\n     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)\r\n     */\r\n    var _getLimitedMatrixSet = function (layer) {\r\n        var layerId = layer.layerNames;\r\n        var matrixId = layer.matrixSet;\r\n        var cap = layer.capabilities;\r\n\r\n        var ret = [];\r\n\r\n        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {\r\n            return elto.Identifier == matrixId;\r\n        });\r\n        if (tset.length) {\r\n            tset = tset[0];\r\n            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];\r\n            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {\r\n                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;\r\n                for (var i = 0; i < limits.length; i++) {\r\n                    limit = limits[i];\r\n                    var matrix = tset.TileMatrix.filter(function (elto) {\r\n                        return elto.Identifier == limit.TileMatrix\r\n                    });\r\n                    if (matrix.length) {\r\n                        var combi = TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);\r\n                        ret.push(combi);\r\n                    }\r\n                }\r\n\r\n                return ret;\r\n            }\r\n            else {\r\n                return tset.TileMatrix;\r\n            }\r\n        }\r\n        else\r\n            return null;\r\n    };\r\n\r\n\r\n    /*\r\n     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen\r\n     */\r\n    var _aggregateLayerNames = function (layer, layerNames) {\r\n        if (layer.type !== TC.Consts.layerType.WMS) {\r\n            return layerNames;\r\n        }\r\n        else {\r\n            var ln = layerNames.slice();\r\n            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());\r\n            return ln;\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.\r\n     * Se parte de un nodo del árbol de capas del capabilities\r\n     */\r\n    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {\r\n        var result = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        if (children.length) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                if (_aggregateLayerNodeNames(layer, names, children[i])) {\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            var nodeNames = children.map(function (elm) {\r\n                return layer.wrap.getName(elm);\r\n            }).reverse();\r\n            var idx, firstIdx;\r\n            var fail = false;\r\n\r\n            firstIdx = idx = names.indexOf(nodeNames[0]);\r\n            if (idx < 0) {\r\n                fail = true;\r\n            }\r\n            else {\r\n                for (var i = 1, len = nodeNames.length; i < len; i++) {\r\n                    if (nodeNames[i] != names[++idx]) {\r\n                        fail = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!fail) {\r\n                var nodeName = layer.wrap.getName(layerNode);\r\n                if (nodeName && nodeNames.length > 1) {\r\n                    names.splice(firstIdx, nodeNames.length, nodeName);\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.\r\n     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible\r\n     */\r\n    var _disgregateLayerNames = function (layer, layerNames) {\r\n        var result = [];\r\n        var ln = layerNames.slice();\r\n        var rootNode = layer.wrap.getRootLayerNode();\r\n        for (var i = 0, len = ln.length; i < len; i++) {\r\n            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {\r\n        var result = [];\r\n        var nodeName = layer.wrap.getName(layerNode);\r\n        var nodeVisible = layer.compareNames(name, nodeName);\r\n        var hasEmptyChildren = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        for (var i = 0; i < children.length; i++) {\r\n            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);\r\n            if (!names.length) {\r\n                hasEmptyChildren = true;\r\n            }\r\n            else {\r\n                result = result.concat(names);\r\n            }\r\n        }\r\n        if (!children.length || hasEmptyChildren) {\r\n            if (ancestorVisible || nodeVisible) {\r\n                result = [nodeName];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _extendLayerNameOptions = function (options) {\r\n        return TC.Util.extend({ aggregate: true, lazy: false }, options);\r\n    };\r\n\r\n    var _combineArray = function (source, add, rem) {\r\n        var result = [];\r\n        var s, a, r;\r\n        s = source ? source : [];\r\n        a = add ? add : [];\r\n        r = rem ? rem : [];\r\n        var sa = s.concat(a);\r\n        for (var i = 0; i < sa.length; i++) {\r\n            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {\r\n                result[result.length] = sa[i];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _sortLayerNames = function (layer, layerNames) {\r\n        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;\r\n        if (layer.capabilities) {\r\n            var tree = layer.getTree();\r\n            ln.sort(function (a, b) {\r\n                var idxa = {\r\n                    count: 0\r\n                };\r\n                var idxb = {\r\n                    count: 0\r\n                };\r\n                _getLayerNamePosition(tree, a, idxa);\r\n                _getLayerNamePosition(tree, b, idxb);\r\n                return idxa.count - idxb.count;\r\n            });\r\n        }\r\n        return ln;\r\n    };\r\n\r\n    var _isNameInArray = function (layer, name, names, looseComparison) {\r\n        return names.filter(function (elm) {\r\n            return layer.compareNames(name, elm, looseComparison);\r\n        }).length > 0;\r\n    };\r\n\r\n\r\n    layerProto.getLimitedMatrixSet = function () {\r\n        return _getLimitedMatrixSet(this);\r\n    };\r\n\r\n    /**\r\n     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.\r\n     * @method setLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  setLayerNames: sets the visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.setLayerNames = function (layerNames, options) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                layer.names = ln;\r\n                var opts = _extendLayerNameOptions(options);\r\n                if (opts.aggregate) {\r\n                    ln = _aggregateLayerNames(layer, ln);\r\n                }\r\n                layer._disgregatedLayerNames = null;\r\n                var newParams = {\r\n                    LAYERS: ln.join(','), TRANSPARENT: true\r\n                };\r\n                if (opts.lazy) {\r\n                    var params = layer._newParams || layer.wrap.getParams();\r\n                    layer._newParams = TC.Util.extend(params, newParams);\r\n                }\r\n                else {\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                    }\r\n                    layer.tree = null;\r\n                    layer._cache.visibilityStates = {\r\n                    };\r\n                    layer.wrap.setParams(newParams);\r\n                    if (opts.reset || !layer.map) {\r\n                        // layerNames se fija cuando se añade al mapa o cuando reset = true.\r\n                        layer.availableNames = layer.names;\r\n                    }\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                    }\r\n                }\r\n                resolve(layer.names);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Añade capas por nombre a las que ya están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.addLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2a = _disgregateLayerNames(self, ln2a);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Elimina capas por nombre de las que están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.removeLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2r = _disgregateLayerNames(self, ln2r);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.\r\n     * @method toggleLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.toggleLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var currentLayerNames = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2t = _disgregateLayerNames(self, ln2t);\r\n                    currentLayerNames = self.getDisgregatedLayerNames();\r\n                }\r\n                var ln2a = [];\r\n                var ln2r = [];\r\n                for (var i = 0; i < ln2t.length; i++) {\r\n                    var l = ln2t[i];\r\n                    if (currentLayerNames.indexOf(l) < 0) {\r\n                        ln2a[ln2a.length] = l;\r\n                    }\r\n                    else {\r\n                        ln2r[ln2r.length] = l;\r\n                    }\r\n                }\r\n                var promises = [];\r\n                if (ln2a.length > 0) {\r\n                    promises.push(self.addLayerNames(ln2a, opts));\r\n                }\r\n                if (ln2r.length > 0) {\r\n                    promises.push(self.removeLayerNames(ln2r, opts));\r\n                }\r\n                Promise.all(promises).then(function (arrays) {\r\n                    const a1 = arrays[0];\r\n                    const a2 = arrays[1];\r\n                    if (a1) {\r\n                        if (a2) {\r\n                            resolve(a1.concat(a2));\r\n                        }\r\n                        else {\r\n                            resolve(a1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n     * @method getDisgregatedLayerNames\r\n     * @return {array}\r\n     */\r\n    /*\r\n     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names\r\n     */\r\n    layerProto.getDisgregatedLayerNames = function () {\r\n        ///<summary>\r\n        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n        ///</summary>\r\n        ///<returns type=\"array\" elementType=\"string\"></returns>\r\n        var self = this;\r\n        var olLayer = self.wrap.layer;\r\n        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {\r\n            if (!self._disgregatedLayerNames) {\r\n                var layerNames = self.wrap.getParams().LAYERS;\r\n                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);\r\n            }\r\n        }\r\n        else {\r\n            self._disgregatedLayerNames = self.names;\r\n        }\r\n        return self._disgregatedLayerNames.slice();\r\n    };\r\n\r\n    layerProto.isValidFromNames = function () {\r\n        var self = this;\r\n        var result = true;\r\n        for (var i = 0, len = self.names.length; i < len; i++) {\r\n            if (!self.getLayerNodeByName(self.names[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isCompatible = function (crs) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = self.wrap.isCompatible(crs);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var result = self.wrap.getCompatibleCRS();\r\n        if (options.includeFallback && self.fallbackLayer) {\r\n            const fbLayer = self.getFallbackLayer();\r\n            if (fbLayer instanceof TC.Layer) {\r\n                result = result.concat(fbLayer.wrap.getCompatibleCRS());\r\n            }\r\n        }\r\n        if (options.normalized) {\r\n            result = result\r\n                .map(function (crs) {\r\n                    return TC.Util.getCRSCode(crs);\r\n                }) // códigos numéricos\r\n                .filter(function (code) {\r\n                    return code !== null;\r\n                })\r\n                .reduce(function (prev, cur) {\r\n                    if (prev.indexOf(cur) < 0) {\r\n                        prev[prev.length] = cur;\r\n                    }\r\n                    return prev;\r\n                }, []) // códigos numéricos sin duplicados\r\n                .map(function (code) {\r\n                    return 'EPSG:' + code;\r\n                }); // códigos normalizados\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getProjection = function () {\r\n        var self = this;\r\n\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                return self.wrap.layer.getSource().getProjection().getCode();\r\n            case TC.Consts.layerType.WMS:\r\n                return self.map.crs;\r\n        }\r\n    };\r\n\r\n    layerProto.setProjection = function (options) {\r\n        var self = this;\r\n        options = options || {};\r\n        if (options.crs) {\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];\r\n                    if (matrixSet) {\r\n                        self.matrixSet = matrixSet;\r\n                        self.wrap.setMatrixSet(matrixSet);\r\n                    }\r\n                    else {\r\n                        self.wrap.setProjection(options);\r\n                    }\r\n                    self.mustReproject = !matrixSet;\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    self.wrap.setProjection(options);\r\n                    self.mustReproject = !self.isCompatible(options.crs);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByScale: return wether the WMS layer is visible at current scale\r\n     *  Parameter: WMS layer name or UID\r\n     */\r\n    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {\r\n        var self = this;\r\n        var result;\r\n        var _getOgcScale = function () {\r\n            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel\r\n        };\r\n        var currentScale;\r\n        var i;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = false;\r\n                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);\r\n                if (tileMatrix) {\r\n                    currentScale = _getOgcScale();\r\n                    for (i = 0; i < tileMatrix.length; i++) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);\r\n                        if (scaleDenominators[0] === currentScale) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = true;\r\n                var layers = self.wrap.getAllLayerNodes();\r\n                if (layers.length > 0) {\r\n                    currentScale = _getOgcScale();\r\n                    var node;\r\n                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID\r\n                        node = self._capabilitiesNodes[nameOrUid];\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < layers.length; i++) {\r\n                            var layer = layers[i];\r\n                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {\r\n                                node = layer;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(node);\r\n                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);\r\n\r\n                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.\r\n                        if (!result) {\r\n                            if (node.Layer && node.Layer.length > 0) {\r\n                                return node.Layer.some(function (nodeLayer) {\r\n                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);\r\n                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names\r\n     *  Parameter: WMS layer name\r\n     */\r\n    layerProto.isVisibleByName = function (name, looseComparison) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                var _getLayerPath = function _getLayerPath(name) {\r\n                    return __getLayerPath(name, self.wrap.getRootLayerNode());\r\n                };\r\n\r\n                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {\r\n                    var result = null;\r\n                    var n = self.wrap.getName(capabilitiesNode);\r\n                    if (self.compareNames(n, name, looseComparison)) {\r\n                        result = [n];\r\n                    }\r\n                    else {\r\n                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                        for (var i = 0; i < layerNodes.length; i++) {\r\n                            var item = layerNodes[i];\r\n                            var r = __getLayerPath(name, item);\r\n                            if (r) {\r\n                                TC.Util.fastUnshift(r, n);\r\n                                result = r;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                var path = _getLayerPath(name);\r\n                if (path) {\r\n                    for (var i = 0; i < path.length; i++) {\r\n                        if (_isNameInArray(self, path[i], self.names)) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getTree = function () {\r\n        var self = this;\r\n        \r\n        var result = self.tree;\r\n\r\n        var addChild = function (node, child) {\r\n            if (self.options.inverseTree) {\r\n                // Versión rápida de unshift\r\n                TC.Util.fastUnshift(node.children, child);\r\n            }\r\n            else {\r\n                node.children[node.children.length] = child;\r\n            }\r\n        }\r\n\r\n        if (!result) {\r\n            var rootNode;\r\n            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {\r\n                var uid;\r\n                for (var key in self._capabilitiesNodes) {\r\n                    if (self._capabilitiesNodes[key] === capabilitiesNode) {\r\n                        uid = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!uid) {\r\n                    uid = TC.getUID();\r\n                    self._capabilitiesNodes[uid] = capabilitiesNode;\r\n                }\r\n                var r = {\r\n                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []\r\n                };\r\n                if (isRootNode) {\r\n                    rootNode = r;\r\n                }\r\n\r\n                if (_isNameInArray(self, r.name, self.availableNames)) {\r\n                    forceAddition = true;\r\n                }\r\n\r\n                if (!self.options.isBase) {\r\n                    if (r === rootNode) {\r\n                        r.isVisible = self.getVisibility();\r\n                    }\r\n                    else {\r\n                        r.isVisible = self.isVisibleByName(r.name);\r\n                    }\r\n                    var i;\r\n                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                    for (i = 0; i < layerNodes.length; i++) {\r\n                        var treeNode = getTreeNode(layerNodes[i], forceAddition);\r\n                        if (treeNode) {\r\n                            addChild(r, treeNode);\r\n                        }\r\n                    }\r\n\r\n                    r.legend = self.wrap.getLegend(capabilitiesNode);\r\n\r\n                    // No muestra ramas irrelevantes si hideTree = true\r\n                    if (!forceAddition && !isRootNode) {\r\n                        // Eliminamos la rama hasta el nodo de interés\r\n                        rootNode.children = rootNode.children.concat(r.children);\r\n                        r = null;\r\n                    }\r\n                }\r\n                else {\r\n                    r.name = self.names.join(',');\r\n                    r.title = self.title || r.title;\r\n                    r.isBase = self.isDefault;\r\n                    if (self.options.thumbnail) {\r\n                        r.legend = {\r\n                            src: self.options.thumbnail\r\n                        };\r\n                    }\r\n                }\r\n                return r;\r\n            };\r\n\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    if (self.capabilities) {\r\n                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);\r\n\r\n                        var cache = self._cache.visibilityStates;\r\n\r\n                        var _setNodeState = function _setNodeState(node) {\r\n                            var _result = TC.Consts.visibility.NOT_VISIBLE;\r\n                            if (node) {\r\n                                if (cache[node.uid] !== undefined) {\r\n                                    _result = cache[node.uid];\r\n                                }\r\n                                else {\r\n                                    if (node.children) {\r\n                                        var hasVisible = false;\r\n                                        var hasNotVisible = false;\r\n                                        for (var i = 0, len = node.children.length; i < len; i++) {\r\n                                            var r = _setNodeState(node.children[i]);\r\n                                            switch (r) {\r\n                                                case TC.Consts.visibility.VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.NOT_VISIBLE:\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.HAS_VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                default:\r\n                                                    break;\r\n                                            }\r\n                                            if (hasVisible) {\r\n                                                if (hasNotVisible) {\r\n                                                    _result = TC.Consts.visibility.HAS_VISIBLE;\r\n                                                }\r\n                                                else {\r\n                                                    _result = TC.Consts.visibility.VISIBLE;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (node.isVisible) {\r\n                                        _result = TC.Consts.visibility.VISIBLE;\r\n                                    }\r\n                                    cache[node.uid] = _result;\r\n                                }\r\n                                node.visibilityState = _result;\r\n                            }\r\n                            return _result;\r\n                        };\r\n                        _setNodeState(result);\r\n\r\n                        if (self.options.hideTree) {\r\n                            _sortTree(self, result);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!result) {\r\n                result = {\r\n                    name: self.name, title: self.title\r\n                };\r\n            }\r\n            result.title = self.title || result.title;\r\n            result.customLegend = self.customLegend || result.customLegend;\r\n            self.tree = result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.setNodeVisibility = function (id, visible) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n\r\n        var _getNames = function _getNames(node) {\r\n            var result = [];\r\n            if (node.name) {\r\n                result[0] = node.name;\r\n            }\r\n            else {\r\n                for (var i = 0; i < node.children.length; i++) {\r\n                    result = result.concat(_getNames(node.children[i]));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var node = self.findNode(id, self.tree);\r\n        if (node === self.tree) {\r\n            if (visible && self.names.length === 0) {\r\n                // Prevent pink error tile\r\n                self.addLayerNames(self.availableNames).then(function () {\r\n                    self.setVisibility(true);\r\n                });\r\n            }\r\n            else {\r\n                self.setVisibility(visible);\r\n            }\r\n        }\r\n        else {\r\n            var names = _getNames(node);\r\n            if (visible) {\r\n                self.addLayerNames(names);\r\n            }\r\n            else {\r\n                self.removeLayerNames(names);\r\n            }\r\n        }\r\n    };\r\n\r\n    layerProto.getNodeVisibility = function (id) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n        return self._cache.visibilityStates[id];\r\n    };\r\n\r\n    layerProto.getNodePath = function (layerName, ignorePrefix) {\r\n        var self = this;\r\n        var result = [];\r\n        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {\r\n            layerName = layerName || self.names[0];\r\n\r\n            var _getPath = function _getPath(node) {\r\n                var res = [];\r\n                var nodeName = self.wrap.getName(node);\r\n                if (self.compareNames(nodeName, layerName, ignorePrefix)) {\r\n                    res.push(node);\r\n                }\r\n                else {\r\n                    var children = self.wrap.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        var r = _getPath(children[i]);\r\n                        if (r.length) {\r\n                            res = r;\r\n                            TC.Util.fastUnshift(res, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            };\r\n            result = _getPath(self.wrap.getRootLayerNode());\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getPath = function (layerName, ignorePrefix) {\r\n        return this.getNodePath(layerName, ignorePrefix).map(function (node) {\r\n            return node.title || node.Title;\r\n        });\r\n    };\r\n\r\n    layerProto.getLayerNodeByName = function (name) {\r\n        var result = null;\r\n        var self = this;\r\n        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName\r\n        var nodes = self.wrap.getAllLayerNodes();\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            if (self.compareNames(getName(nodes[i]), name)) {\r\n                result = nodes[i];\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getChildrenLayers = function (layer) {\r\n        var self = this;\r\n        var result = [];\r\n        var _fnRecursiva = function (lyr, arr) {\r\n            if (lyr && lyr.Layer && lyr.Layer.length) {\r\n                for (var i = 0; i < lyr.Layer.length; i++) {\r\n                    arr[arr.length] = lyr.Layer[i];\r\n                    _fnRecursiva(lyr.Layer[i], arr)\r\n                }\r\n            }\r\n        };\r\n        _fnRecursiva(layer, result);\r\n        return result;\r\n    };\r\n\r\n    layerProto.compareNames = function (n1, n2, looseComparison) {\r\n        var result = n1 === n2;\r\n        var self = this;\r\n        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes\r\n        if (!result && lc && n1 && n2) {\r\n            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación\r\n            var idx1 = n1.indexOf(':');\r\n            var idx2 = n2.indexOf(':');\r\n            if (idx1 >= 0 && idx2 < 0) {\r\n                result = n1.substr(idx1 + 1) === n2;\r\n            }\r\n            else if (idx2 >= 0 && idx1 < 0) {\r\n                result = n1 === n2.substr(idx2 + 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCapabilitiesPromise = function () {\r\n        return this._capabilitiesPromise;\r\n    };\r\n\r\n    layerProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    layerProto.setResolutions = function (resolutions) {\r\n        this.wrap.setResolutions(resolutions);\r\n    };\r\n\r\n    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado\r\n    //case insensitive\r\n    layerProto.searchSubLayers = function (text) {\r\n        if (!this.patternFn) {\r\n            this.patternFn = function (t) {\r\n                t = t.replace(/[^a-z\\dáéíóúüñ]/gi, '\\\\' + '$&');\r\n                t = t.replace(/(a|á)/gi, \"(a|á)\");\r\n                t = t.replace(/(e|é)/gi, \"(e|é)\");\r\n                t = t.replace(/(i|í)/gi, \"(i|í)\");\r\n                t = t.replace(/(o|ó)/gi, \"(o|ó)\");\r\n                t = t.replace(/(u|ú|ü)/gi, \"(u|ú|ü)\");\r\n                t = t.replace(/n/gi, \"(n|ñ)\");\r\n                return t;\r\n            }\r\n        }\r\n        if (text && text.length && text.length >= 3) {\r\n            var self = this;\r\n            var layers = null;\r\n            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado \"cat\" y ahora busco \"cata\" porque esto escribiendo \"catastro\" ...\r\n            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */\r\n            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {\r\n                layers = this.lastMatches\r\n            }\r\n            else {\r\n                /*si se ha definido el parametro layers de esta capa en configuraci\\u00f3n filtro las capas del capability para que busque solo en las capas que est\\u00e9n en \r\n                configuraci\\u00f3n y sus hijas*/\r\n                if (self.availableNames && self.availableNames.length > 0) {\r\n                    layers = []\r\n                    for (var i = 0; i < self.availableNames.length; i++) {\r\n                        var layer = self.getLayerNodeByName(self.availableNames[i]);\r\n                        if (layer) {\r\n                            layers[layers.length] = layer;\r\n                            layers = layers.concat(self.getChildrenLayers(layer));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    layers = self.wrap.getAllLayerNodes();\r\n                }\r\n            }\r\n\r\n            var filter = this.patternFn(text);\r\n            var re = new RegExp(filter, \"i\");\r\n\r\n            var matches = layers.map(function (ly, ix) {\r\n                delete ly.tcScore;\r\n\r\n                ly.tcPosition = ix;\r\n\r\n                self.wrap.normalizeLayerNode(ly);\r\n\r\n                var title = ly.Title.trim();\r\n                var res = re.exec(title);\r\n                var titleIx = res ? res.index : -1;\r\n                var abstractIx = -1;\r\n                if (ly.Abstract) {\r\n                    var abs = ly.Abstract.trim();\r\n                    var res2 = re.exec(abs);\r\n                    abstractIx = res2 ? res2.index : -1;\r\n                }\r\n\r\n                if (res && title == res[0])\r\n                    ly.tcScore = 20;\r\n                else if (titleIx == 0)\r\n                    ly.tcScore = 15;\r\n                else if (titleIx > -1)\r\n                    ly.tcScore = 10;\r\n                else if (abstractIx == 0)\r\n                    ly.tcScore = 5;\r\n                else if (abstractIx > -1)\r\n                    ly.tcScore = 1;\r\n\r\n                if (ly.tcScore)\r\n                    return ly;\r\n                else\r\n                    return null;\r\n            })\r\n                .filter(function (elto) {\r\n                    return elto != null;\r\n                })\r\n                .sort(function (a, b) {\r\n                    if (b.tcScore === a.tcScore) {\r\n                        //si la puntuación es la misma reordenamos por título\r\n                        var titleA = TC.Util.replaceAccent(a.Title);\r\n                        var titleB = TC.Util.replaceAccent(b.Title);\r\n                        if (titleA < titleB) return -1;\r\n                        if (titleA > titleB) return 1;\r\n                        return 0;\r\n                    }\r\n                    else\r\n                        return b.tcScore - a.tcScore;\r\n                });\r\n\r\n            this.lastPattern = text;\r\n            this.lastMatches = matches;\r\n\r\n            return matches;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n\r\n    };\r\n\r\n    var cleanOgcUrl = function (url) {\r\n        var result = url;\r\n        if (url) {\r\n            var match = url.match(/\\??SERVICE=\\w+&/i);\r\n            if (match) {\r\n                result = result.replace(match[0], '');\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getGetCapabilitiesUrl = function () {\r\n        const self = this;\r\n        var url;\r\n        const serviceUrl = self.url;\r\n        const params = {};\r\n        if (self.type === TC.Consts.layerType.WMTS) {\r\n            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {\r\n                var suffix = '/1.0.0/WMTSCapabilities.xml';\r\n                const suffixIdx = serviceUrl.indexOf(suffix);\r\n                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {\r\n                    if (serviceUrl[serviceUrl.length - 1] === '/') {\r\n                        suffix = suffix.substr(1);\r\n                    }\r\n                    url = serviceUrl + suffix;\r\n                }\r\n                else {\r\n                    url = serviceUrl;\r\n                }\r\n            }\r\n            else {\r\n                url = serviceUrl;\r\n                params.SERVICE = 'WMTS';\r\n                params.VERSION = '1.0.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n            }\r\n        }\r\n        else {\r\n            url = serviceUrl;\r\n            params.SERVICE = 'WMS';\r\n            params.VERSION = '1.3.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n        }\r\n        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));\r\n        return url;\r\n    };\r\n\r\n\r\n\r\n    layerProto.getGetMapUrl = function () {\r\n        return cleanOgcUrl(this.wrap.getGetMapUrl());\r\n    };\r\n\r\n    layerProto.getPreferredInfoFormat = function () {\r\n        const layer = this;\r\n        var result = null;\r\n\r\n        const infoFormats = layer.wrap.getInfoFormats();\r\n        if (infoFormats) {\r\n            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {\r\n                var format = TC.wrap.layer.Raster.infoFormatPreference[i];\r\n                if (infoFormats.indexOf(format) >= 0) {\r\n                    result = format;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Carga la imagen de leyenda de una capa por POST.\r\n     */\r\n    layerProto.getLegendGraphicImage = function () {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta\r\n            if (self.options.params.base64LegendSrc) {\r\n                return resolve(self.options.params.base64LegendSrc);\r\n            }\r\n\r\n            if (typeof window.btoa === 'function') {\r\n                var name = self.names[0];\r\n                var info = self.wrap.getInfo(name);\r\n                var xhr = new XMLHttpRequest();\r\n                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL\r\n                var dataEntries = url[1].split(\"&\"); // Separamos clave/valor de cada parámetro\r\n                var params = self.options.params.sld_body ? \"sld_body=\" + self.options.params.sld_body : '';\r\n\r\n                for (var i = 0; i < dataEntries.length; i++) {\r\n                    var chunks = dataEntries[i].split('=');\r\n\r\n                    if (chunks && chunks.length > 1 && chunks[1]) {\r\n                        params += \"&\" + dataEntries[i];\r\n                    }\r\n                }\r\n                if (self.options.params.env) {\r\n                    params += \"&\" + self.options.params.env;\r\n                }\r\n\r\n                xhr.open('POST', url[0], true);\r\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) {\r\n                    if (this.status === 200) {\r\n                        var uInt8Array = new Uint8Array(this.response);\r\n                        var i = uInt8Array.length;\r\n                        var binaryString = new Array(i);\r\n                        while (i--) {\r\n                            binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n                        }\r\n                        var data = binaryString.join('');\r\n                        var type = xhr.getResponseHeader('content-type');\r\n                        if (type.indexOf('image') === 0) {\r\n                            var imageSrc;\r\n                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);\r\n                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta\r\n                            resolve(imageSrc);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(params);\r\n            } else {\r\n                reject(Error(\"Función window.btoa no soportada por el navegador\"));\r\n            }\r\n        });\r\n    };\r\n\r\n    layerProto.getUrl = function (src) {\r\n        var self = this;\r\n\r\n        return src;\r\n    };\r\n\r\n    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL\r\n    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; \r\n    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.\r\n\r\n    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.\r\n    layerProto.getWebGLUrl = function (src, location) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;\r\n\r\n            if (self.ignoreProxification) {\r\n                resolve(_src);\r\n            } else {\r\n                const options = {\r\n                    exportable: true,\r\n                    ignoreProxification: self.ignoreProxification\r\n                };\r\n\r\n                self.toolProxification.fetchImage(_src, options).then(function () {\r\n                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {\r\n                        if (cache && cache.action) {\r\n                            resolve(cache.action.call(self.toolProxification, _src));\r\n                        }\r\n                    });\r\n                }).catch(function (e) {\r\n                    reject(Error(e));\r\n                });\r\n            }\r\n\r\n            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más\r\n            //if (self.ignoreProxification) {\r\n            //    setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            //    return;\r\n            //}\r\n\r\n            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        \r\n        });\r\n    };\r\n\r\n    layerProto.getFeatureUrl = function (url) {\r\n        var self = this;\r\n\r\n        return self.toolProxification.fetch(url).then(function () {\r\n            return self.toolProxification.cacheHost.getAction(url)\r\n                .then(function (cache) {\r\n                    return cache.action.call(self.toolProxification, url);\r\n                })\r\n                .catch(function (error) {\r\n                    return Promise.reject(error);\r\n                })\r\n        }).catch(function (error) {\r\n            return Promise.reject(error);\r\n        });\r\n    };\r\n\r\n    // GLS:\r\n    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. \r\n    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.\r\n    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {\r\n        var self = this;\r\n\r\n        if (!self.map) {\r\n            return null;\r\n        } else {\r\n            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));\r\n\r\n            const matchingLayer = layers.filter(function (elem) {\r\n                return (elem.type === TC.Consts.layerType.WMS ||\r\n                    elem.type === TC.Consts.layerType.WMTS) &&\r\n                    (elem.capabilities === self.capabilities || elem.url === self.url) &&\r\n                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);\r\n            })[0];\r\n\r\n            return matchingLayer || null;\r\n        }\r\n    };\r\n\r\n    layerProto.getImageLoad = function (image, src, location) {\r\n        const self = this;\r\n\r\n        const setSRC = function (data) {\r\n            var olImg = image.getImage();\r\n\r\n            if (!TC.Util.isSameOrigin(data.src)) {\r\n                if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                    olImg.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : \"anonymous\";\r\n                }\r\n            }\r\n\r\n            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.\r\n            olImg.setAttribute(\"src\", data.src);\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        };\r\n\r\n        // Viene sin nombre desde el control TOC, si es así lo ignoramos.\r\n        if (self.names && self.names.length > 0) {\r\n\r\n            const error = function (error) {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            };\r\n\r\n            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404\r\n            if (self.type === TC.Consts.layerType.WMTS) {\r\n                var z, x, y;\r\n                if (self.encoding != \"KVP\") {\r\n                    var _src = src.replace('.' + self.format.split('/')[1], '');\r\n                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });\r\n                    z = parts[0];\r\n                    x = parts[1];\r\n                    y = parts[2];\r\n                } else {\r\n                    var parts = /.*TileMatrix=(\\d*)&TileCol=(\\d*)&TileRow=(\\d*)/i.exec(src);\r\n                    if (parts && parts.length == 4) {\r\n                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });\r\n                        z = parts[0];\r\n                        x = parts[2];\r\n                        y = parts[1];\r\n                    }\r\n                }\r\n\r\n                if (z && x && y) {\r\n                    var wmtsOptions = self.wrap.getWMTSLayer();\r\n                    if (wmtsOptions) {\r\n                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });\r\n                        if (matrixSet.length > 0) {\r\n\r\n                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {\r\n                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {\r\n                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))\r\n                                        return 1;\r\n                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))\r\n                                        return -1;\r\n                                    else return 0;\r\n                                });\r\n\r\n                                var level = matrixSetLimits[z];\r\n                                if (level && self.map && self.map.on3DView) {\r\n                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {\r\n                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');\r\n                                        setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });\r\n\r\n            var params = \"\";\r\n            var isPOST = self.options.method === \"POST\";\r\n            if (isPOST) {\r\n                var url = src.split('?');\r\n                params = url[1].split(\"&\").filter(function (param) {\r\n                    const values = param.split('=');\r\n                    // eliminamos los valores en blanco y el parámetro layers\r\n                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== \"layers\";\r\n                }).join('&');\r\n\r\n                self.toolProxification.fetchImageAsBlob(url[0], {\r\n                    type: \"POST\",\r\n                    data: params,\r\n                    contentType: \"application/x-www-form-urlencoded\"\r\n                }).then(function (blob) {\r\n                    const imageUrl = URL.createObjectURL(blob);\r\n                    const img = image.getImage();\r\n                    img.onload = function (evt) {\r\n                        URL.revokeObjectURL(imageUrl);\r\n                    };\r\n                    setSRC({ src: imageUrl });\r\n                }).catch(error);\r\n\r\n            } else {\r\n                if (!self.ignoreProxification) {\r\n                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {\r\n                        setSRC(img);\r\n                    }).catch(error);\r\n                } else {\r\n                    setSRC({ src: src });\r\n                    var img = image.getImage();\r\n\r\n                    if (!TC.Util.isSameOrigin(src)) {\r\n                        if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                            img.crossOrigin = \"anonymous\";\r\n                        }\r\n                    }\r\n\r\n                    img.onload = function () {\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n                    };\r\n                    img.onerror = function (error) {\r\n                        img.src = TC.Consts.BLANK_IMAGE;\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                    };\r\n\r\n                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;\r\n                }\r\n            }\r\n        } else {\r\n            setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            // lanzamos el evento para gestionar el loading\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        }\r\n    };\r\n\r\n    var _get$events = function () {\r\n        const self = this;\r\n        if (self.wrap && self.wrap.$events) {\r\n            return self.wrap.$events;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    layerProto.getWFSCapabilitiesPromise = function () {\r\n        const self = this;\r\n\r\n        if (typeof (WFSCapabilities) === \"undefined\") {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/layer/WFSCapabilitiesParser');\r\n        }        \r\n        const newUrl = this.options.url.replace(/wms/gi, \"wfs\");\r\n        const _src = !TC.Util.isSecureURL(newUrl) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(newUrl)) ? self.getBySSL_(newUrl) : newUrl;\r\n        const basicUrl = newUrl.substring(newUrl.indexOf(\"://\") < 0 ? 0 : newUrl.indexOf(\"://\") + 3);\r\n        if (TC.WFScapabilities[basicUrl]) {\r\n            if (TC.WFScapabilities[basicUrl] instanceof Promise)\r\n                return TC.WFScapabilities[basicUrl];\r\n            else\r\n                return new Promise(function (resolve, reject) {\r\n                    setTimeout(function () {\r\n                        resolve(TC.WFScapabilities[basicUrl]);\r\n                    }, 100);\r\n                });\r\n        }\r\n        TC.WFScapabilities[basicUrl] = new Promise(function (resolve, reject) {            \r\n            var params = {\r\n            }\r\n            params.SERVICE = 'WFS';\r\n            params.VERSION = '2.0.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n\r\n            var url = self.getUrl(_src + '?' + TC.Util.getParamString(params));\r\n\r\n            self.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {\r\n\r\n                var capabilities\r\n                var xmlDoc;\r\n                const documentElement = data.responseText && (data.responseText.ownerDocument || data.responseText).documentElement;\r\n                const isXMLDoc = documentElement ? documentElement.nodeName !== 'HTML' : false;\r\n                if (isXMLDoc) {\r\n                    xmlDoc = data.responseText;\r\n                }\r\n                else {\r\n                    xmlDoc = (new DOMParser()).parseFromString(data.responseText, 'text/xml');\r\n                }\r\n                //comprueba si el servidor ha devuelto una excepcion\r\n\r\n                var errorNode = xmlDoc.getElementsByTagName('ServiceException')[0];\r\n                if (!errorNode) {\r\n                    errorNode = xmlDoc.getElementsByTagName('ExceptionText')[0];\r\n                }\r\n                if (errorNode) {\r\n                    reject(Error(errorNode.innerHTML));\r\n                    return;\r\n                }\r\n                try {\r\n                    capabilities = WFSCapabilities.Parse(xmlDoc);\r\n                }\r\n                catch (err) {\r\n                    reject(err instanceof Error ? err : Error(err));\r\n                    return;\r\n                }\r\n\r\n                if (!capabilities.Operations) {\r\n                    reject(null);\r\n                    return;\r\n                }\r\n                var _url = (capabilities.Operations.GetCapabilities.DCP && capabilities.Operations.GetCapabilities.DCP.HTTP.Get[\"xlink:href\"]) || capabilities.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource\r\n                TC.WFScapabilities[_url] = capabilities;\r\n                TC.WFScapabilities[basicUrl] = capabilities;\r\n                resolve(capabilities);\r\n            }).catch(function (error) {\r\n                //reject(Error(capabilitiesError(layer, dataError)));\r\n                reject(error instanceof Error ? error : Error(error));\r\n            });\r\n        });\r\n        return TC.WFScapabilities[basicUrl];\r\n    };\r\n\r\n    layerProto.getFallbackLayer = function () {\r\n        const self = this;\r\n        if (self.fallbackLayer instanceof TC.Layer) {\r\n            return self.fallbackLayer;\r\n        }\r\n        if (self.options.fallbackLayer) {\r\n            var fbLayer = self.options.fallbackLayer;\r\n            if (typeof fbLayer === 'string') {\r\n                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n                ablCollection.forEach(function (baseLayer) {\r\n                    if (self.options.fallbackLayer === baseLayer.id) {\r\n                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));\r\n                        self.fallbackLayer.firstOption = self;\r\n                    }\r\n                });\r\n            }\r\n            else if (fbLayer instanceof TC.Layer) {\r\n                self.fallbackLayer = fbLayer;\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            else {\r\n                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {\r\n                    id: TC.getUID(),\r\n                    isBase: true,\r\n                    stealth: true,\r\n                    title: layer.title,\r\n                    map: self.map\r\n                }));\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            return self.fallbackLayer;\r\n        }\r\n        return null;\r\n    };\r\n})();\r\nvar esriParser = {\r\n    parse: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {};\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result[result.length] = feature;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"]}