{"version":3,"sources":["layer/Raster.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","Consts","BLANK_IMAGE","capabilitiesPromises","wfsLayer","getWFSLayer","url","Promise","resolve","reject","options","loadJS","Vector","type","layerType","WFS","stealth","_getLayerNodeIndex","treeNode","result","availableNames","indexOf","name","i","len","children","length","_getLayerNamePosition","counter","count","Raster","self","this","tool","Proxification","toolProxification","proxify","_capabilitiesPromise","apply","arguments","wrap","transparent","capabilities","params","layerNames","names","split","Array","isArray","push","hasOwnProperty","undefined","isVisible","sldBody","sld_body","parser","DOMParser","sldBodyToXml","parseFromString","e","error","message","namedLayerElm","Util","getElementByNodeName","textContent","ignorePrefixes","_capabilitiesNodes","_promise","_createOLLayer","ollyr","GROUP","WMTS","createWMTSLayer","join","format","LAYERS","FORMAT","TRANSPARENT","VERSION","version","extend","queryParams","infoFormat","getPreferredInfoFormat","INFO_FORMAT","createWMSLayer","getGetMapUrl","_createWMSLayer","setLayer","Error","id","processedCapabilities","actualUrl","cachePromise","res","rej","onlinePromise","getCapabilitiesOnline","storagePromise","getCapabilitiesFromStorage","then","catch","getCapabilitiesPromise","map","trigger","event","LAYERERROR","reason","_disgregatedLayerNames","setWMTSUrl","inherit","layerProto","prototype","capabilitiesState_","PENDING","DONE","CAPABILITIES_STORE_KEY_PREFIX","getByProxy_","getByUrl_","setVisibility","visible","tree","_cache","visibilityStates","call","_aggregateLayerNodeNames","layerNode","getLayerNodes","idx","firstIdx","nodeNames","elm","getName","reverse","fail","nodeName","splice","_disgregateLayerNames","ln","slice","rootNode","getRootLayerNode","concat","_disgregateLayerName","ancestorVisible","nodeVisible","compareNames","hasEmptyChildren","_extendLayerNameOptions","aggregate","lazy","_combineArray","source","add","rem","a","r","sa","_sortLayerNames","getTree","sort","b","idxa","idxb","_isNameInArray","looseComparison","filter","getLimitedMatrixSet","layerId","matrixId","matrixSet","cap","ret","tset","Contents","TileMatrixSet","elto","Identifier","ly","TileMatrixSetLink","TileMatrixSetLimits","limit","limits","matrix","TileMatrix","combi","matrixIndex","_getLimitedMatrixSet","setLayerNames","getLayer","opts","WMS","_aggregateLayerNames","newParams","_newParams","getParams","BEFOREUPDATEPARAMS","setParams","reset","UPDATEPARAMS","addLayerNames","ln2a","getDisgregatedLayerNames","removeLayerNames","ln2r","toggleLayerNames","ln2t","currentLayerNames","l","promises","all","arrays","a1","a2","olLayer","isNative","isValidFromNames","getLayerNodeByName","isCompatible","crs","getCompatibleMatrixSets","getCompatibleCRS","includeFallback","fallbackLayer","fbLayer","getFallbackLayer","normalized","getCRSCode","code","reduce","prev","cur","getProjection","getSource","getCode","setProjection","setMatrixSet","mustReproject","isVisibleByScale","nameOrUid","currentScale","_getOgcScale","getResolution","getMetersPerUnit","tileMatrix","getTileMatrix","scaleDenominators","getScaleDenominators","layers","getAllLayerNodes","node","parseInt","toString","parseFloat","some","nodeLayer","isVisibleByName","getWMTSLayer","__getLayerPath","capabilitiesNode","n","layerNodes","fastUnshift","path","_getLayerPath","getTreeNode","forceAddition","isRootNode","uid","key","getUID","child","title","Title","isBase","isDefault","thumbnail","legend","src","getVisibility","inverseTree","getLegend","hideTree","cache","_setNodeState","_result","visibility","NOT_VISIBLE","hasVisible","hasNotVisible","VISIBLE","HAS_VISIBLE","visibilityState","_sortTree","n1","n2","customLegend","setNodeVisibility","findNode","_getNames","getNodeVisibility","getNodePath","layerName","ignorePrefix","_getPath","getPath","getServiceType","getIdentifier","nodes","getChildrenLayers","_fnRecursiva","lyr","arr","lc","idx1","idx2","substr","getResolutions","setResolutions","resolutions","searchSubLayers","text","patternFn","t","replace","lastPattern","lastMatches","re","RegExp","matches","ix","tcScore","tcPosition","normalizeLayerNode","trim","exec","titleIx","index","abstractIx","Abstract","abs","res2","titleA","replaceAccent","titleB","getGetCapabilitiesUrl","serviceUrl","encoding","WMTSEncoding","RESTFUL","suffix","suffixIdx","SERVICE","REQUEST","getParamString","infoFormats","getInfoFormats","infoFormatPreference","getLegendGraphicImage","base64LegendSrc","window","btoa","info","getInfo","xhr","XMLHttpRequest","dataEntries","chunks","env","open","setRequestHeader","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","data","getResponseHeader","imageSrc","send","getUrl","getWebGLUrl","location","_src","isSecureURL","toAbsolutePath","getBySSL_","ignoreProxification","exportable","fetchImage","cacheHost","getAction","action","getFeatureUrl","fetch","getSiblingLoadedLayer","dynamicStatement","baseLayers","workLayers","elem","isFunction","getImageLoad","image","setSRC","img","getImage","isSameOrigin","mustBeExportable","crossOrigin","setAttribute","_get$events","TILELOAD","tile","onerror","TILELOADERROR","statusText","z","x","y","parts","wmtsOptions","level","on3DView","MinTileRow","MaxTileRow","MinTileCol","MaxTileCol","console","log","BEFORETILELOAD","method","param","values","toLowerCase","fetchImageAsBlob","contentType","blob","imageUrl","URL","createObjectURL","evt","revokeObjectURL","$events","getWFSCapabilities","newUrl","getDescribeFeatureTypeUrl","featureType","availableBaseLayers","Cfg","forEach","baseLayer","firstOption","describeFeatureType","refresh","reloadSource","esriParser","parse","dom","documentElement","tagName","fiCollections","getElementsByTagName","fic","getAttribute","fInfos","j","lenj","fields","attributes","k","lenk","field","getElementText","feature","ol","Feature","setId"],"mappings":"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","sourcesContent":["\r\nTC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\nTC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';\r\n\r\n(function () {\r\n\r\n    var capabilitiesPromises = {};\r\n\r\n    var wfsLayer = null;//capa WFS de respaldo\r\n\r\n    const getWFSLayer = function (url) {\r\n        return new Promise(function (resolve, reject) {\r\n            if (!wfsLayer || wfsLayer.options.url !== url) {\r\n                TC.loadJS(\r\n                    !TC.layer.Vector,\r\n                    TC.apiLocation + 'TC/layer/Vector',\r\n                    function () {\r\n                        wfsLayer = new TC.layer.Vector({\r\n                            type: TC.Consts.layerType.WFS,\r\n                            url: url,\r\n                            stealth: true\r\n                        });\r\n                        resolve(wfsLayer);\r\n                    }\r\n                );\r\n            }\r\n            else {\r\n                resolve(wfsLayer);\r\n            }\r\n        });\r\n    };\r\n    \r\n    const _createWMSLayer = function (layer) {\r\n\r\n        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;\r\n        var format = layer.options.format;\r\n        var options = layer.options;\r\n\r\n        var params = {\r\n            LAYERS: layerNames,\r\n            FORMAT: format,\r\n            TRANSPARENT: layer.transparent,\r\n            VERSION: layer.capabilities.version || '1.3.0'\r\n        };\r\n\r\n        if (layer.params) {\r\n            TC.Util.extend(params, layer.params);\r\n        }\r\n\r\n        if (layer.queryParams) {\r\n            TC.Util.extend(params, layer.queryParams);\r\n        }\r\n\r\n        var infoFormat = layer.getPreferredInfoFormat();\r\n        if (infoFormat !== null) {\r\n            params.INFO_FORMAT = infoFormat;\r\n        }\r\n\r\n        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);\r\n    };\r\n\r\n    const _createWMTSLayer = function (layer) {\r\n        return layer.wrap.createWMTSLayer(layer.options);\r\n    };\r\n\r\n    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {\r\n\r\n        var result = layer.availableNames.indexOf(treeNode.name);\r\n        if (result === -1) {\r\n            for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n                result = _getLayerNodeIndex(layer, treeNode.children[i]);\r\n                if (result !== -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const _sortTree = function _sortTree(layer, treeNode) {\r\n        var _sortFunction = function (n1, n2) {\r\n            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);\r\n        }\r\n        treeNode.children.sort(_sortFunction);\r\n        for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n            _sortTree(layer, treeNode.children[i]);\r\n        }\r\n    };\r\n\r\n    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {\r\n        var result = false;\r\n        counter.count = counter.count + 1;\r\n        if (treeNode.name === name) {\r\n            result = true;\r\n        }\r\n        else {\r\n            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés\r\n            for (var i = treeNode.children.length - 1; i >= 0; i--) {\r\n                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Opciones de nombre de capa.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.LayerNameOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.\r\n     * @property aggregate\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n    /**\r\n     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} (valor <code>false</code>) \r\n     * o se espera a que la capa se actualice (valor <code>true</code>).\r\n     * @property lazy\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n    /**\r\n     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/availableNames:property\"}}{{/crossLink}} (valor <code>false</code>) se restablece \r\n     * al actualizar la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}}.\r\n     * @property reset\r\n     * @type boolean|undefined\r\n     */\r\n\r\n    /**\r\n     * Opciones de capa raster.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.RasterOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.WMS\r\n     */\r\n    /**\r\n     * URL del servicio OGC que define la capa.\r\n     * @property url\r\n     * @type string\r\n     */\r\n    /**\r\n     * Indica si la capa tiene transparencia.\r\n     * @property transparent\r\n     * @type boolean|undefined\r\n     */\r\n    /**\r\n     * Lista separada por comas de los nombres de capa del servicio OGC.\r\n     * @property layerNames\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.\r\n     * @property matrixSet\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo raster, como la de un WMS o un WMTS.\r\n     * @class TC.layer.Raster\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Raster = function () {\r\n        var self = this;\r\n\r\n        if (!TC.tool || !TC.tool.Proxification) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');\r\n        }\r\n\r\n        this.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        this._capabilitiesPromise = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.wrap = new TC.wrap.layer.Raster(self);\r\n\r\n        /**\r\n         * Indica si la capa tiene transparencia.\r\n         * @property transparent\r\n         * @type boolean\r\n         * @default true\r\n         */\r\n        self.transparent = (self.options.transparent === false) ? false : true;\r\n\r\n        /**\r\n         * URL del servicio al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        self.url = self.options.url;\r\n        self.capabilities = TC.capabilities[self.url];\r\n\r\n        self.params = self.options.params;\r\n        /**\r\n         * Lista de nombres de capa.\r\n         * @property names\r\n         * @type array\r\n         * @default []\r\n         */\r\n        /**\r\n         * Lista de nombres de capa disponibles inicialmente.\r\n         * @property availableNames\r\n         * @type array\r\n         * @default []\r\n         */\r\n        if (typeof self.options.layerNames === 'string') {\r\n            self.names = self.availableNames = self.options.layerNames.split(',');\r\n        }\r\n        else {\r\n            self.names = [];\r\n            self.availableNames = [];\r\n            if (Array.isArray(self.options.layerNames)) {\r\n                for (var i = 0; i < self.options.layerNames.length; i++) {\r\n                    var name = self.options.layerNames[i];\r\n                    if (typeof name === 'string') {\r\n                        self.names.push(name);\r\n                        self.availableNames.push(name);\r\n\r\n                    }\r\n                    else if (name.hasOwnProperty('name')) {\r\n                        self.availableNames.push(name.name);\r\n                        if (name.isVisible === undefined || name.isVisible) {\r\n                            self.names.push(name.name);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado\r\n                // cuando queremos instanciar una capa pasándole un SLD en la petición\r\n                var sldBody = self.options.params ? self.options.params.sld_body : null;\r\n\r\n                if (sldBody) {\r\n                    const parser = new DOMParser();\r\n                    var sldBodyToXml;\r\n                    try {\r\n                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');\r\n                    }\r\n                    catch (e) {\r\n                        TC.error(e.message);\r\n                        sldBodyToXml = null;\r\n                    }\r\n                    if (sldBodyToXml) {\r\n                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');\r\n                        if (namedLayerElm && namedLayerElm.length > 0) {\r\n                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');\r\n\r\n                            if (names && names.length > 0) {\r\n                                var name = names[0].textContent;\r\n                                self.names.push(name);\r\n                                self.availableNames.push(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;\r\n\r\n        self._capabilitiesNodes = {};\r\n\r\n        /**\r\n      * Árbol del documento de capabilities del servicio.\r\n      * @property capabilities\r\n      * @type object\r\n      */\r\n        self.wrap._promise = new Promise(function (resolve, reject) {\r\n            /*\r\n             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo\r\n             */\r\n            var _createOLLayer = function () {\r\n                var ollyr;\r\n                if (!self.wrap.layer) {\r\n                    switch (self.type) {\r\n                        case TC.Consts.layerType.GROUP:\r\n                            break;\r\n                        case TC.Consts.layerType.WMTS:\r\n                            ollyr = _createWMTSLayer(self);\r\n                            break;\r\n                        default:\r\n                            ollyr = _createWMSLayer(self);\r\n                            break;\r\n                    }\r\n                    self.wrap.setLayer(ollyr);\r\n                    if (ollyr) {\r\n                        resolve(ollyr);\r\n                    }\r\n                    else {\r\n                        reject(Error('Could not create native layer for \"' + self.id + '\"'));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const processedCapabilities = function (capabilities) {\r\n                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                self.capabilities = self.capabilities || capabilities;\r\n\r\n                var actualUrl = self.getGetMapUrl();\r\n                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;\r\n                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;\r\n\r\n                _createOLLayer();\r\n            };\r\n\r\n            if (self.capabilities) {\r\n                processedCapabilities(self.capabilities);\r\n                self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                return;\r\n            }\r\n\r\n            const cachePromise = capabilitiesPromises[self.url];\r\n            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {\r\n                const onlinePromise = self.getCapabilitiesOnline();\r\n                const storagePromise = self.getCapabilitiesFromStorage();\r\n\r\n                onlinePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        storagePromise.catch(function () {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n                storagePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function () {\r\n                        onlinePromise.catch(function (error) {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n            });\r\n\r\n            self.getCapabilitiesPromise()\r\n                .then(function (capabilities) {\r\n                    processedCapabilities(capabilities);\r\n                })\r\n                .catch(function (error) {\r\n                    if (self.map) {\r\n                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });\r\n                    }\r\n                    reject(error);\r\n                });\r\n        });\r\n\r\n        self._disgregatedLayerNames = null;\r\n\r\n        if (TC.Consts.layerType.WMTS == self.type) {\r\n            self.wrap.setWMTSUrl();\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.layer.Raster, TC.Layer);\r\n\r\n    var layerProto = TC.layer.Raster.prototype;\r\n        \r\n    layerProto.capabilitiesState_ = {\r\n        PENDING: 0,\r\n        DONE: 1\r\n    };\r\n\r\n    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';\r\n\r\n    layerProto.getByProxy_ = function (url) {\r\n        return TC.proxify(url);\r\n    };\r\n    \r\n\r\n    layerProto.getByUrl_ = function (url) {\r\n        return url;\r\n    };\r\n\r\n\r\n    layerProto.setVisibility = function (visible) {\r\n        var layer = this;\r\n        layer.tree = null;\r\n        layer._cache.visibilityStates = {\r\n        };\r\n        TC.Layer.prototype.setVisibility.call(layer, visible);\r\n    };\r\n\r\n    /*\r\n     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)\r\n     */\r\n    var _getLimitedMatrixSet = function (layer) {\r\n        var layerId = layer.layerNames;\r\n        var matrixId = layer.matrixSet;\r\n        var cap = layer.capabilities;\r\n\r\n        var ret = [];\r\n\r\n        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {\r\n            return elto.Identifier == matrixId;\r\n        });\r\n        if (tset.length) {\r\n            tset = tset[0];\r\n            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];\r\n            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {\r\n                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;\r\n                for (var i = 0; i < limits.length; i++) {\r\n                    limit = limits[i];\r\n                    var matrix = tset.TileMatrix.filter(function (elto) {\r\n                        return elto.Identifier == limit.TileMatrix\r\n                    });\r\n                    if (matrix.length) {\r\n                        var combi = TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);\r\n                        ret.push(combi);\r\n                    }\r\n                }\r\n\r\n                return ret;\r\n            }\r\n            else {\r\n                return tset.TileMatrix;\r\n            }\r\n        }\r\n        else\r\n            return null;\r\n    };\r\n\r\n\r\n    /*\r\n     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen\r\n     */\r\n    var _aggregateLayerNames = function (layer, layerNames) {\r\n        if (layer.type !== TC.Consts.layerType.WMS) {\r\n            return layerNames;\r\n        }\r\n        else {\r\n            var ln = layerNames.slice();\r\n            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());\r\n            return ln;\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.\r\n     * Se parte de un nodo del árbol de capas del capabilities\r\n     */\r\n    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {\r\n        var result = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        if (children.length) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                if (_aggregateLayerNodeNames(layer, names, children[i])) {\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            var nodeNames = children.map(function (elm) {\r\n                return layer.wrap.getName(elm);\r\n            }).reverse();\r\n            var idx, firstIdx;\r\n            var fail = false;\r\n\r\n            firstIdx = idx = names.indexOf(nodeNames[0]);\r\n            if (idx < 0) {\r\n                fail = true;\r\n            }\r\n            else {\r\n                for (var i = 1, len = nodeNames.length; i < len; i++) {\r\n                    if (nodeNames[i] != names[++idx]) {\r\n                        fail = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!fail) {\r\n                var nodeName = layer.wrap.getName(layerNode);\r\n                if (nodeName && nodeNames.length > 1) {\r\n                    names.splice(firstIdx, nodeNames.length, nodeName);\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.\r\n     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible\r\n     */\r\n    var _disgregateLayerNames = function (layer, layerNames) {\r\n        var result = [];\r\n        var ln = layerNames.slice();\r\n        var rootNode = layer.wrap.getRootLayerNode();\r\n        for (var i = 0, len = ln.length; i < len; i++) {\r\n            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {\r\n        var result = [];\r\n        var nodeName = layer.wrap.getName(layerNode);\r\n        var nodeVisible = layer.compareNames(name, nodeName);\r\n        var hasEmptyChildren = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        for (var i = 0; i < children.length; i++) {\r\n            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);\r\n            if (!names.length) {\r\n                hasEmptyChildren = true;\r\n            }\r\n            else {\r\n                result = result.concat(names);\r\n            }\r\n        }\r\n        if (!children.length || hasEmptyChildren) {\r\n            if (ancestorVisible || nodeVisible) {\r\n                result = [nodeName];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _extendLayerNameOptions = function (options) {\r\n        return TC.Util.extend({ aggregate: true, lazy: false }, options);\r\n    };\r\n\r\n    var _combineArray = function (source, add, rem) {\r\n        var result = [];\r\n        var s, a, r;\r\n        s = source ? source : [];\r\n        a = add ? add : [];\r\n        r = rem ? rem : [];\r\n        var sa = s.concat(a);\r\n        for (var i = 0; i < sa.length; i++) {\r\n            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {\r\n                result[result.length] = sa[i];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _sortLayerNames = function (layer, layerNames) {\r\n        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;\r\n        if (layer.capabilities) {\r\n            var tree = layer.getTree();\r\n            ln.sort(function (a, b) {\r\n                var idxa = {\r\n                    count: 0\r\n                };\r\n                var idxb = {\r\n                    count: 0\r\n                };\r\n                _getLayerNamePosition(tree, a, idxa);\r\n                _getLayerNamePosition(tree, b, idxb);\r\n                return idxa.count - idxb.count;\r\n            });\r\n        }\r\n        return ln;\r\n    };\r\n\r\n    var _isNameInArray = function (layer, name, names, looseComparison) {\r\n        return names.filter(function (elm) {\r\n            return layer.compareNames(name, elm, looseComparison);\r\n        }).length > 0;\r\n    };\r\n\r\n\r\n    layerProto.getLimitedMatrixSet = function () {\r\n        return _getLimitedMatrixSet(this);\r\n    };\r\n\r\n    /**\r\n     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.\r\n     * @method setLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  setLayerNames: sets the visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.setLayerNames = function (layerNames, options) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                layer.names = ln;\r\n                var opts = _extendLayerNameOptions(options);\r\n                if (opts.aggregate) {\r\n                    ln = _aggregateLayerNames(layer, ln);\r\n                }\r\n                layer._disgregatedLayerNames = null;\r\n                var newParams = {\r\n                    LAYERS: ln.join(','), TRANSPARENT: true\r\n                };\r\n                if (opts.lazy) {\r\n                    var params = layer._newParams || layer.wrap.getParams();\r\n                    layer._newParams = TC.Util.extend(params, newParams);\r\n                }\r\n                else {\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                    }\r\n                    layer.tree = null;\r\n                    layer._cache.visibilityStates = {\r\n                    };\r\n                    layer.wrap.setParams(newParams);\r\n                    if (opts.reset || !layer.map) {\r\n                        // layerNames se fija cuando se añade al mapa o cuando reset = true.\r\n                        layer.availableNames = layer.names;\r\n                    }\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                    }\r\n                }\r\n                resolve(layer.names);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Añade capas por nombre a las que ya están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.addLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2a = _disgregateLayerNames(self, ln2a);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Elimina capas por nombre de las que están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.removeLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2r = _disgregateLayerNames(self, ln2r);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.\r\n     * @method toggleLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.toggleLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var currentLayerNames = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2t = _disgregateLayerNames(self, ln2t);\r\n                    currentLayerNames = self.getDisgregatedLayerNames();\r\n                }\r\n                var ln2a = [];\r\n                var ln2r = [];\r\n                for (var i = 0; i < ln2t.length; i++) {\r\n                    var l = ln2t[i];\r\n                    if (currentLayerNames.indexOf(l) < 0) {\r\n                        ln2a[ln2a.length] = l;\r\n                    }\r\n                    else {\r\n                        ln2r[ln2r.length] = l;\r\n                    }\r\n                }\r\n                var promises = [];\r\n                if (ln2a.length > 0) {\r\n                    promises.push(self.addLayerNames(ln2a, opts));\r\n                }\r\n                if (ln2r.length > 0) {\r\n                    promises.push(self.removeLayerNames(ln2r, opts));\r\n                }\r\n                Promise.all(promises).then(function (arrays) {\r\n                    const a1 = arrays[0];\r\n                    const a2 = arrays[1];\r\n                    if (a1) {\r\n                        if (a2) {\r\n                            resolve(a1.concat(a2));\r\n                        }\r\n                        else {\r\n                            resolve(a1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n     * @method getDisgregatedLayerNames\r\n     * @return {array}\r\n     */\r\n    /*\r\n     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names\r\n     */\r\n    layerProto.getDisgregatedLayerNames = function () {\r\n        ///<summary>\r\n        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n        ///</summary>\r\n        ///<returns type=\"array\" elementType=\"string\"></returns>\r\n        var self = this;\r\n        var olLayer = self.wrap.layer;\r\n        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {\r\n            if (!self._disgregatedLayerNames) {\r\n                var layerNames = self.wrap.getParams().LAYERS;\r\n                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);\r\n            }\r\n        }\r\n        else {\r\n            self._disgregatedLayerNames = self.names;\r\n        }\r\n        return self._disgregatedLayerNames.slice();\r\n    };\r\n\r\n    layerProto.isValidFromNames = function () {\r\n        var self = this;\r\n        var result = true;\r\n        for (var i = 0, len = self.names.length; i < len; i++) {\r\n            if (!self.getLayerNodeByName(self.names[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isCompatible = function (crs) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = self.wrap.isCompatible(crs);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var result = self.wrap.getCompatibleCRS();\r\n        if (options.includeFallback && self.fallbackLayer) {\r\n            const fbLayer = self.getFallbackLayer();\r\n            if (fbLayer instanceof TC.Layer) {\r\n                result = result.concat(fbLayer.wrap.getCompatibleCRS());\r\n            }\r\n        }\r\n        if (options.normalized) {\r\n            result = result\r\n                .map(function (crs) {\r\n                    return TC.Util.getCRSCode(crs);\r\n                }) // códigos numéricos\r\n                .filter(function (code) {\r\n                    return code !== null;\r\n                })\r\n                .reduce(function (prev, cur) {\r\n                    if (prev.indexOf(cur) < 0) {\r\n                        prev[prev.length] = cur;\r\n                    }\r\n                    return prev;\r\n                }, []) // códigos numéricos sin duplicados\r\n                .map(function (code) {\r\n                    return 'EPSG:' + code;\r\n                }); // códigos normalizados\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getProjection = function () {\r\n        var self = this;\r\n\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                return self.wrap.layer.getSource().getProjection().getCode();\r\n            case TC.Consts.layerType.WMS:\r\n                return self.map.crs;\r\n        }\r\n    };\r\n\r\n    layerProto.setProjection = function (options) {\r\n        var self = this;\r\n        options = options || {};\r\n        if (options.crs) {\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];\r\n                    if (matrixSet) {\r\n                        self.matrixSet = matrixSet;\r\n                        self.wrap.setMatrixSet(matrixSet);\r\n                    }\r\n                    else {\r\n                        self.wrap.setProjection(options);\r\n                    }\r\n                    self.mustReproject = !matrixSet;\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    self.wrap.setProjection(options);\r\n                    self.mustReproject = !self.isCompatible(options.crs);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByScale: return wether the WMS layer is visible at current scale\r\n     *  Parameter: WMS layer name or UID\r\n     */\r\n    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {\r\n        var self = this;\r\n        var result;\r\n        var _getOgcScale = function () {\r\n            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel\r\n        };\r\n        var currentScale;\r\n        var i;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = false;\r\n                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);\r\n                if (tileMatrix) {\r\n                    currentScale = _getOgcScale();\r\n                    for (i = 0; i < tileMatrix.length; i++) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);\r\n                        if (scaleDenominators[0] === currentScale) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = true;\r\n                var layers = self.wrap.getAllLayerNodes();\r\n                if (layers.length > 0) {\r\n                    currentScale = _getOgcScale();\r\n                    var node;\r\n                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID\r\n                        node = self._capabilitiesNodes[nameOrUid];\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < layers.length; i++) {\r\n                            var layer = layers[i];\r\n                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {\r\n                                node = layer;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(node);\r\n                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);\r\n\r\n                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.\r\n                        if (!result) {\r\n                            if (node.Layer && node.Layer.length > 0) {\r\n                                return node.Layer.some(function (nodeLayer) {\r\n                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);\r\n                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names\r\n     *  Parameter: WMS layer name\r\n     */\r\n    layerProto.isVisibleByName = function (name, looseComparison) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                var _getLayerPath = function _getLayerPath(name) {\r\n                    return __getLayerPath(name, self.wrap.getRootLayerNode());\r\n                };\r\n\r\n                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {\r\n                    var result = null;\r\n                    var n = self.wrap.getName(capabilitiesNode);\r\n                    if (self.compareNames(n, name, looseComparison)) {\r\n                        result = [n];\r\n                    }\r\n                    else {\r\n                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                        for (var i = 0; i < layerNodes.length; i++) {\r\n                            var item = layerNodes[i];\r\n                            var r = __getLayerPath(name, item);\r\n                            if (r) {\r\n                                TC.Util.fastUnshift(r, n);\r\n                                result = r;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                var path = _getLayerPath(name);\r\n                if (path) {\r\n                    for (var i = 0; i < path.length; i++) {\r\n                        if (_isNameInArray(self, path[i], self.names)) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getTree = function () {\r\n        var self = this;\r\n        \r\n        var result = self.tree;\r\n\r\n        var addChild = function (node, child) {\r\n            if (self.options.inverseTree) {\r\n                // Versión rápida de unshift\r\n                TC.Util.fastUnshift(node.children, child);\r\n            }\r\n            else {\r\n                node.children[node.children.length] = child;\r\n            }\r\n        }\r\n\r\n        if (!result) {\r\n            var rootNode;\r\n            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {\r\n                var uid;\r\n                for (var key in self._capabilitiesNodes) {\r\n                    if (self._capabilitiesNodes[key] === capabilitiesNode) {\r\n                        uid = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!uid) {\r\n                    uid = TC.getUID();\r\n                    self._capabilitiesNodes[uid] = capabilitiesNode;\r\n                }\r\n                var r = {\r\n                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []\r\n                };\r\n                if (isRootNode) {\r\n                    rootNode = r;\r\n                }\r\n\r\n                if (_isNameInArray(self, r.name, self.availableNames)) {\r\n                    forceAddition = true;\r\n                }\r\n\r\n                if (!self.options.isBase) {\r\n                    if (r === rootNode) {\r\n                        r.isVisible = self.getVisibility();\r\n                    }\r\n                    else {\r\n                        r.isVisible = self.isVisibleByName(r.name);\r\n                    }\r\n                    var i;\r\n                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                    for (i = 0; i < layerNodes.length; i++) {\r\n                        var treeNode = getTreeNode(layerNodes[i], forceAddition);\r\n                        if (treeNode) {\r\n                            addChild(r, treeNode);\r\n                        }\r\n                    }\r\n\r\n                    r.legend = self.wrap.getLegend(capabilitiesNode);\r\n\r\n                    // No muestra ramas irrelevantes si hideTree = true\r\n                    if (!forceAddition && !isRootNode) {\r\n                        // Eliminamos la rama hasta el nodo de interés\r\n                        rootNode.children = rootNode.children.concat(r.children);\r\n                        r = null;\r\n                    }\r\n                }\r\n                else {\r\n                    r.name = self.names.join(',');\r\n                    r.title = self.title || r.title;\r\n                    r.isBase = self.isDefault;\r\n                    if (self.options.thumbnail) {\r\n                        r.legend = {\r\n                            src: self.options.thumbnail\r\n                        };\r\n                    }\r\n                }\r\n                return r;\r\n            };\r\n\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    if (self.capabilities) {\r\n                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);\r\n\r\n                        var cache = self._cache.visibilityStates;\r\n\r\n                        var _setNodeState = function _setNodeState(node) {\r\n                            var _result = TC.Consts.visibility.NOT_VISIBLE;\r\n                            if (node) {\r\n                                if (cache[node.uid] !== undefined) {\r\n                                    _result = cache[node.uid];\r\n                                }\r\n                                else {\r\n                                    if (node.children) {\r\n                                        var hasVisible = false;\r\n                                        var hasNotVisible = false;\r\n                                        for (var i = 0, len = node.children.length; i < len; i++) {\r\n                                            var r = _setNodeState(node.children[i]);\r\n                                            switch (r) {\r\n                                                case TC.Consts.visibility.VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.NOT_VISIBLE:\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.HAS_VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                default:\r\n                                                    break;\r\n                                            }\r\n                                            if (hasVisible) {\r\n                                                if (hasNotVisible) {\r\n                                                    _result = TC.Consts.visibility.HAS_VISIBLE;\r\n                                                }\r\n                                                else {\r\n                                                    _result = TC.Consts.visibility.VISIBLE;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (node.isVisible) {\r\n                                        _result = TC.Consts.visibility.VISIBLE;\r\n                                    }\r\n                                    cache[node.uid] = _result;\r\n                                }\r\n                                node.visibilityState = _result;\r\n                            }\r\n                            return _result;\r\n                        };\r\n                        _setNodeState(result);\r\n\r\n                        if (self.options.hideTree) {\r\n                            _sortTree(self, result);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!result) {\r\n                result = {\r\n                    name: self.name, title: self.title\r\n                };\r\n            }\r\n            result.title = self.title || result.title;\r\n            result.customLegend = self.customLegend || result.customLegend;\r\n            self.tree = result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.setNodeVisibility = function (id, visible) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n\r\n        var _getNames = function _getNames(node) {\r\n            var result = [];\r\n            if (node.name) {\r\n                result[0] = node.name;\r\n            }\r\n            else {\r\n                for (var i = 0; i < node.children.length; i++) {\r\n                    result = result.concat(_getNames(node.children[i]));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var node = self.findNode(id, self.tree);\r\n        if (node === self.tree) {\r\n            if (visible && self.names.length === 0) {\r\n                // Prevent pink error tile\r\n                self.addLayerNames(self.availableNames).then(function () {\r\n                    self.setVisibility(true);\r\n                });\r\n            }\r\n            else {\r\n                self.setVisibility(visible);\r\n            }\r\n        }\r\n        else {\r\n            var names = _getNames(node);\r\n            if (visible) {\r\n                self.addLayerNames(names);\r\n            }\r\n            else {\r\n                self.removeLayerNames(names);\r\n            }\r\n        }\r\n    };\r\n\r\n    layerProto.getNodeVisibility = function (id) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n        return self._cache.visibilityStates[id];\r\n    };\r\n\r\n    layerProto.getNodePath = function (layerName, ignorePrefix) {\r\n        var self = this;\r\n        var result = [];\r\n        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {\r\n            layerName = layerName || self.names[0];\r\n\r\n            var _getPath = function _getPath(node) {\r\n                var res = [];\r\n                var nodeName = self.wrap.getName(node);\r\n                if (self.compareNames(nodeName, layerName, ignorePrefix)) {\r\n                    res.push(node);\r\n                }\r\n                else {\r\n                    var children = self.wrap.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        var r = _getPath(children[i]);\r\n                        if (r.length) {\r\n                            res = r;\r\n                            TC.Util.fastUnshift(res, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            };\r\n            result = _getPath(self.wrap.getRootLayerNode());\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getPath = function (layerName, ignorePrefix) {\r\n        return this.getNodePath(layerName, ignorePrefix).map(function (node) {\r\n            return node.title || node.Title;\r\n        });\r\n    };\r\n\r\n    layerProto.getLayerNodeByName = function (name) {\r\n        var result = null;\r\n        var self = this;\r\n        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName\r\n        var nodes = self.wrap.getAllLayerNodes();\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            if (self.compareNames(getName(nodes[i]), name)) {\r\n                result = nodes[i];\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getChildrenLayers = function (layer) {\r\n        var self = this;\r\n        var result = [];\r\n        var _fnRecursiva = function (lyr, arr) {\r\n            if (lyr && lyr.Layer && lyr.Layer.length) {\r\n                for (var i = 0; i < lyr.Layer.length; i++) {\r\n                    arr[arr.length] = lyr.Layer[i];\r\n                    _fnRecursiva(lyr.Layer[i], arr)\r\n                }\r\n            }\r\n        };\r\n        _fnRecursiva(layer, result);\r\n        return result;\r\n    };\r\n\r\n    layerProto.compareNames = function (n1, n2, looseComparison) {\r\n        var result = n1 === n2;\r\n        var self = this;\r\n        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes\r\n        if (!result && lc && n1 && n2) {\r\n            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación\r\n            var idx1 = n1.indexOf(':');\r\n            var idx2 = n2.indexOf(':');\r\n            if (idx1 >= 0 && idx2 < 0) {\r\n                result = n1.substr(idx1 + 1) === n2;\r\n            }\r\n            else if (idx2 >= 0 && idx1 < 0) {\r\n                result = n1 === n2.substr(idx2 + 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCapabilitiesPromise = function () {\r\n        return this._capabilitiesPromise;\r\n    };\r\n\r\n    layerProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    layerProto.setResolutions = function (resolutions) {\r\n        this.wrap.setResolutions(resolutions);\r\n    };\r\n\r\n    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado\r\n    //case insensitive\r\n    layerProto.searchSubLayers = function (text) {\r\n        if (!this.patternFn) {\r\n            this.patternFn = function (t) {\r\n                t = t.replace(/[^a-z\\dáéíóúüñ]/gi, '\\\\' + '$&');\r\n                t = t.replace(/(a|á)/gi, \"(a|á)\");\r\n                t = t.replace(/(e|é)/gi, \"(e|é)\");\r\n                t = t.replace(/(i|í)/gi, \"(i|í)\");\r\n                t = t.replace(/(o|ó)/gi, \"(o|ó)\");\r\n                t = t.replace(/(u|ú|ü)/gi, \"(u|ú|ü)\");\r\n                t = t.replace(/n/gi, \"(n|ñ)\");\r\n                return t;\r\n            }\r\n        }\r\n        if (text && text.length && text.length >= 3) {\r\n            var self = this;\r\n            var layers = null;\r\n            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado \"cat\" y ahora busco \"cata\" porque esto escribiendo \"catastro\" ...\r\n            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */\r\n            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {\r\n                layers = this.lastMatches\r\n            }\r\n            else {\r\n                /*si se ha definido el parametro layers de esta capa en configuraci\\u00f3n filtro las capas del capability para que busque solo en las capas que est\\u00e9n en \r\n                configuraci\\u00f3n y sus hijas*/\r\n                if (self.availableNames && self.availableNames.length > 0) {\r\n                    layers = []\r\n                    for (var i = 0; i < self.availableNames.length; i++) {\r\n                        var layer = self.getLayerNodeByName(self.availableNames[i]);\r\n                        if (layer) {\r\n                            layers[layers.length] = layer;\r\n                            layers = layers.concat(self.getChildrenLayers(layer));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    layers = self.wrap.getAllLayerNodes();\r\n                }\r\n            }\r\n\r\n            var filter = this.patternFn(text);\r\n            var re = new RegExp(filter, \"i\");\r\n\r\n            var matches = layers.map(function (ly, ix) {\r\n                delete ly.tcScore;\r\n\r\n                ly.tcPosition = ix;\r\n\r\n                self.wrap.normalizeLayerNode(ly);\r\n\r\n                var title = ly.Title.trim();\r\n                var res = re.exec(title);\r\n                var titleIx = res ? res.index : -1;\r\n                var abstractIx = -1;\r\n                if (ly.Abstract) {\r\n                    var abs = ly.Abstract.trim();\r\n                    var res2 = re.exec(abs);\r\n                    abstractIx = res2 ? res2.index : -1;\r\n                }\r\n\r\n                if (res && title == res[0])\r\n                    ly.tcScore = 20;\r\n                else if (titleIx == 0)\r\n                    ly.tcScore = 15;\r\n                else if (titleIx > -1)\r\n                    ly.tcScore = 10;\r\n                else if (abstractIx == 0)\r\n                    ly.tcScore = 5;\r\n                else if (abstractIx > -1)\r\n                    ly.tcScore = 1;\r\n\r\n                if (ly.tcScore)\r\n                    return ly;\r\n                else\r\n                    return null;\r\n            })\r\n                .filter(function (elto) {\r\n                    return elto != null;\r\n                })\r\n                .sort(function (a, b) {\r\n                    if (b.tcScore === a.tcScore) {\r\n                        //si la puntuación es la misma reordenamos por título\r\n                        var titleA = TC.Util.replaceAccent(a.Title);\r\n                        var titleB = TC.Util.replaceAccent(b.Title);\r\n                        if (titleA < titleB) return -1;\r\n                        if (titleA > titleB) return 1;\r\n                        return 0;\r\n                    }\r\n                    else\r\n                        return b.tcScore - a.tcScore;\r\n                });\r\n\r\n            this.lastPattern = text;\r\n            this.lastMatches = matches;\r\n\r\n            return matches;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n\r\n    };\r\n        \r\n\r\n    layerProto.getGetCapabilitiesUrl = function () {\r\n        const self = this;\r\n        var url;\r\n        const serviceUrl = self.url;\r\n        const params = {};\r\n        if (self.type === TC.Consts.layerType.WMTS) {\r\n            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {\r\n                var suffix = '/1.0.0/WMTSCapabilities.xml';\r\n                const suffixIdx = serviceUrl.indexOf(suffix);\r\n                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {\r\n                    if (serviceUrl[serviceUrl.length - 1] === '/') {\r\n                        suffix = suffix.substr(1);\r\n                    }\r\n                    url = serviceUrl + suffix;\r\n                }\r\n                else {\r\n                    url = serviceUrl;\r\n                }\r\n            }\r\n            else {\r\n                url = serviceUrl;\r\n                params.SERVICE = 'WMTS';\r\n                params.VERSION = '1.0.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n            }\r\n        }\r\n        else {\r\n            url = serviceUrl;\r\n            params.SERVICE = 'WMS';\r\n            params.VERSION = '1.3.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n        }\r\n        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));\r\n        return url;\r\n    };\r\n\r\n    layerProto.getPreferredInfoFormat = function () {\r\n        const layer = this;\r\n        var result = null;\r\n\r\n        const infoFormats = layer.wrap.getInfoFormats();\r\n        if (infoFormats) {\r\n            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {\r\n                var format = TC.wrap.layer.Raster.infoFormatPreference[i];\r\n                if (infoFormats.indexOf(format) >= 0) {\r\n                    result = format;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Carga la imagen de leyenda de una capa por POST.\r\n     */\r\n    layerProto.getLegendGraphicImage = function () {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta\r\n            if (self.options.params.base64LegendSrc) {\r\n                return resolve(self.options.params.base64LegendSrc);\r\n            }\r\n\r\n            if (typeof window.btoa === 'function') {\r\n                var name = self.names[0];\r\n                var info = self.wrap.getInfo(name);\r\n                var xhr = new XMLHttpRequest();\r\n                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL\r\n                var dataEntries = url[1].split(\"&\"); // Separamos clave/valor de cada parámetro\r\n                var params = self.options.params.sld_body ? \"sld_body=\" + self.options.params.sld_body : '';\r\n\r\n                for (var i = 0; i < dataEntries.length; i++) {\r\n                    var chunks = dataEntries[i].split('=');\r\n\r\n                    if (chunks && chunks.length > 1 && chunks[1]) {\r\n                        params += \"&\" + dataEntries[i];\r\n                    }\r\n                }\r\n                if (self.options.params.env) {\r\n                    params += \"&\" + self.options.params.env;\r\n                }\r\n\r\n                xhr.open('POST', url[0], true);\r\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) {\r\n                    if (this.status === 200) {\r\n                        var uInt8Array = new Uint8Array(this.response);\r\n                        var i = uInt8Array.length;\r\n                        var binaryString = new Array(i);\r\n                        while (i--) {\r\n                            binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n                        }\r\n                        var data = binaryString.join('');\r\n                        var type = xhr.getResponseHeader('content-type');\r\n                        if (type.indexOf('image') === 0) {\r\n                            var imageSrc;\r\n                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);\r\n                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta\r\n                            resolve(imageSrc);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(params);\r\n            } else {\r\n                reject(Error(\"Función window.btoa no soportada por el navegador\"));\r\n            }\r\n        });\r\n    };\r\n\r\n    layerProto.getUrl = function (src) {\r\n        var self = this;\r\n\r\n        return src;\r\n    };\r\n\r\n    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL\r\n    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; \r\n    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.\r\n\r\n    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.\r\n    layerProto.getWebGLUrl = function (src, location) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;\r\n\r\n            if (self.ignoreProxification) {\r\n                resolve(_src);\r\n            } else {\r\n                const options = {\r\n                    exportable: true,\r\n                    ignoreProxification: self.ignoreProxification\r\n                };\r\n\r\n                self.toolProxification.fetchImage(_src, options).then(function () {\r\n                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {\r\n                        if (cache && cache.action) {\r\n                            resolve(cache.action.call(self.toolProxification, _src));\r\n                        }\r\n                    });\r\n                }).catch(function (e) {\r\n                    reject(Error(e));\r\n                });\r\n            }\r\n\r\n            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más\r\n            //if (self.ignoreProxification) {\r\n            //    setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            //    return;\r\n            //}\r\n\r\n            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        \r\n        });\r\n    };\r\n\r\n    layerProto.getFeatureUrl = function (url) {\r\n        var self = this;\r\n\r\n        return self.toolProxification.fetch(url).then(function () {\r\n            return self.toolProxification.cacheHost.getAction(url)\r\n                .then(function (cache) {\r\n                    return cache.action.call(self.toolProxification, url);\r\n                })\r\n                .catch(function (error) {\r\n                    return Promise.reject(error);\r\n                })\r\n        }).catch(function (error) {\r\n            return Promise.reject(error);\r\n        });\r\n    };\r\n\r\n    // GLS:\r\n    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. \r\n    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.\r\n    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {\r\n        var self = this;\r\n\r\n        if (!self.map) {\r\n            return null;\r\n        } else {\r\n            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));\r\n\r\n            const matchingLayer = layers.filter(function (elem) {\r\n                return (elem.type === TC.Consts.layerType.WMS ||\r\n                    elem.type === TC.Consts.layerType.WMTS) &&\r\n                    (elem.capabilities === self.capabilities || elem.url === self.url) &&\r\n                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);\r\n            })[0];\r\n\r\n            return matchingLayer || null;\r\n        }\r\n    };\r\n\r\n    layerProto.getImageLoad = function (image, src, location) {\r\n        const self = this;\r\n\r\n        const setSRC = function (data) {\r\n            const img = image.getImage();\r\n\r\n            if (!TC.Util.isSameOrigin(data.src)) {\r\n                if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                    img.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : \"anonymous\";\r\n                }\r\n            }\r\n\r\n            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.\r\n            img.setAttribute(\"src\", data.src);\r\n            img.onload = function () {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n            };\r\n            img.onerror = function (error) {\r\n                img.setAttribute(\"src\", TC.Consts.BLANK_IMAGE);\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n            };\r\n        };\r\n\r\n        // Viene sin nombre desde el control TOC, si es así lo ignoramos.\r\n        if (self.names && self.names.length > 0) {\r\n\r\n            const error = function (error) {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            };\r\n\r\n            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404\r\n            if (self.type === TC.Consts.layerType.WMTS) {\r\n                var z, x, y;\r\n                if (self.encoding != \"KVP\") {\r\n                    var _src = src.replace('.' + self.format.split('/')[1], '');\r\n                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });\r\n                    z = parts[0];\r\n                    x = parts[1];\r\n                    y = parts[2];\r\n                } else {\r\n                    var parts = /.*TileMatrix=(\\d*)&TileCol=(\\d*)&TileRow=(\\d*)/i.exec(src);\r\n                    if (parts && parts.length == 4) {\r\n                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });\r\n                        z = parts[0];\r\n                        x = parts[2];\r\n                        y = parts[1];\r\n                    }\r\n                }\r\n\r\n                if (z && x && y) {\r\n                    var wmtsOptions = self.wrap.getWMTSLayer();\r\n                    if (wmtsOptions) {\r\n                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });\r\n                        if (matrixSet.length > 0) {\r\n\r\n                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {\r\n                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {\r\n                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))\r\n                                        return 1;\r\n                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))\r\n                                        return -1;\r\n                                    else return 0;\r\n                                });\r\n\r\n                                var level = matrixSetLimits[z];\r\n                                if (level && self.map && self.map.on3DView) {\r\n                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {\r\n                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');\r\n                                        setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });\r\n\r\n            var params = \"\";\r\n            var isPOST = self.options.method === \"POST\";\r\n            if (isPOST) {\r\n                var url = src.split('?');\r\n                params = url[1].split(\"&\").filter(function (param) {\r\n                    const values = param.split('=');\r\n                    // eliminamos los valores en blanco y el parámetro layers\r\n                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== \"layers\";\r\n                }).join('&');\r\n\r\n                self.toolProxification.fetchImageAsBlob(url[0], {\r\n                    type: \"POST\",\r\n                    data: params,\r\n                    contentType: \"application/x-www-form-urlencoded\"\r\n                }).then(function (blob) {\r\n                    const imageUrl = URL.createObjectURL(blob);\r\n                    const img = image.getImage();\r\n                    img.onload = function (evt) {\r\n                        URL.revokeObjectURL(imageUrl);\r\n                    };\r\n                    setSRC({ src: imageUrl });\r\n                }).catch(error);\r\n\r\n            } else {\r\n                if (!self.ignoreProxification) {\r\n                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {\r\n                        setSRC(img);\r\n                    }).catch(error);\r\n                } else {\r\n                    setSRC({ src: src });\r\n                    var img = image.getImage();\r\n\r\n                    if (!TC.Util.isSameOrigin(src)) {\r\n                        if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                            img.crossOrigin = \"anonymous\";\r\n                        }\r\n                    }\r\n\r\n                    img.onload = function () {\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n                    };\r\n                    img.onerror = function (error) {\r\n                        img.src = TC.Consts.BLANK_IMAGE;\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                    };\r\n\r\n                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;\r\n                }\r\n            }\r\n        } else {\r\n            setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            // lanzamos el evento para gestionar el loading\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        }\r\n    };\r\n\r\n    var _get$events = function () {\r\n        const self = this;\r\n        if (self.wrap && self.wrap.$events) {\r\n            return self.wrap.$events;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    layerProto.getWFSCapabilities = function () {\r\n        const self = this;\r\n        const newUrl = self.options.url.replace(/wms/gi, \"wfs\");\r\n\r\n        return getWFSLayer(newUrl).then(function (layer) {\r\n            return layer.getCapabilitiesPromise();\r\n        });\r\n    };\r\n\r\n    layerProto.getDescribeFeatureTypeUrl = function () {\r\n        const self = this;\r\n        const newUrl = self.options.url.replace(/wms/gi, \"wfs\");\r\n\r\n        if (!TC.layer.Vector) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/layer/Vector');\r\n        }\r\n        if (!wfsLayer || wfsLayer.options.url !== newUrl) {\r\n            wfsLayer = new TC.layer.Vector({\r\n                type: TC.Consts.layerType.WFS,\r\n                url: newUrl,\r\n                stealth: true\r\n            });\r\n        }\r\n        return wfsLayer.getDescribeFeatureTypeUrl(self.options.featureType);\r\n    };\r\n\r\n    layerProto.getFallbackLayer = function () {\r\n        const self = this;\r\n        if (self.fallbackLayer instanceof TC.Layer) {\r\n            return self.fallbackLayer;\r\n        }\r\n        if (self.options.fallbackLayer) {\r\n            var fbLayer = self.options.fallbackLayer;\r\n            if (typeof fbLayer === 'string') {\r\n                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n                ablCollection.forEach(function (baseLayer) {\r\n                    if (self.options.fallbackLayer === baseLayer.id) {\r\n                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));\r\n                        self.fallbackLayer.firstOption = self;\r\n                    }\r\n                });\r\n            }\r\n            else if (fbLayer instanceof TC.Layer) {\r\n                self.fallbackLayer = fbLayer;\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            else {\r\n                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {\r\n                    id: TC.getUID(),\r\n                    isBase: true,\r\n                    stealth: true,\r\n                    title: layer.title,\r\n                    map: self.map\r\n                }));\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            return self.fallbackLayer;\r\n        }\r\n        return null;\r\n    };\r\n    layerProto.describeFeatureType = function (layerName) {\r\n        const self = this;\r\n        const newUrl = self.options.url.replace(/wms/gi, \"wfs\");\r\n\r\n        return getWFSLayer(newUrl).then(function (layer) {\r\n            return layer.describeFeatureType(layerName || self.layerNames[0]);\r\n        });\r\n    };\r\n\r\n    layerProto.refresh = function () {\r\n        return this.wrap.reloadSource();\r\n    };\r\n\r\n})();\r\nvar esriParser = {\r\n    parse: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {};\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result[result.length] = feature;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"]}