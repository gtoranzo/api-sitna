{"version":3,"sources":["layer/Raster.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","Consts","BLANK_IMAGE","capabilitiesPromises","isWebWorkerEnabled","isLegacy","window","hasOwnProperty","wwPromise","Promise","resolve","reject","wwLocation","Util","isSameOrigin","ajax","url","method","responseType","then","data","blob","Blob","type","URL","createObjectURL","e","Error","capabilitiesError","reason","msg","error","map","trigger","event","LAYERERROR","wrap","setLayer","getCapabilitiesOnline","serviceUrl","params","layerType","WMTS","options","encoding","WMTSEncoding","RESTFUL","suffix","suffixIdx","indexOf","length","substr","SERVICE","VERSION","REQUEST","$","param","extend","queryParams","toolProxification","fetch","retryAttempts","capabilities","documentElement","serviceException","getElementsByTagName","textContent","format","WmtsParser","WmsParser","read","Contents","layerCollection","i","len","curXmlLy","id","getElementByNodeName","firstChild","capLy","filter","ly","Identifier","j","TileMatrixSetLink","capLink","matrixId","TileMatrixSet","xmlLink","each","ix","curLink","find","text","TileMatrixSetLimits","tmlCollection","k","kk","lim","push","TileMatrix","MinTileRow","parseInt","MinTileCol","MaxTileRow","MaxTileCol","storeCapabilities","wwUrl","worker","Worker","onmessage","state","terminate","postMessage","parseCapabilities","responseText","catch","dataError","loadJS","localforage","LOCALFORAGE","capKey","CAPABILITIES_STORE_KEY_PREFIX","setItem","getCapabilitiesPromise","err","console","log","loaded","_getLayerNodeIndex","treeNode","result","inArray","name","availableNames","children","_getLayerNamePosition","counter","count","Raster","self","this","tool","Proxification","proxify","_capabilitiesPromise","apply","arguments","transparent","layerNames","names","split","isArray","undefined","isVisible","sldBody","sld_body","sldBodyToXml","parseXML","namedLayerElm","ignorePrefixes","_capabilitiesNodes","_promise","_createOLLayer","ollyr","GROUP","createWMTSLayer","join","LAYERS","FORMAT","TRANSPARENT","version","infoFormat","getPreferredInfoFormat","INFO_FORMAT","createWMSLayer","getGetMapUrl","_createWMSLayer","processedCapabilities","actualUrl","cachePromise","res","rej","onlineFail","storageFail","onlinePromise","storagePromise","getItem","value","_disgregatedLayerNames","setWMTSUrl","inherit","layerProto","prototype","PROTOCOL_REGEX","capabilitiesState_","PENDING","DONE","getByProxy_","getBySSL_","replace","getByUrl_","setVisibility","visible","tree","_cache","visibilityStates","call","_aggregateLayerNodeNames","layerNode","getLayerNodes","idx","firstIdx","nodeNames","elm","getName","reverse","fail","nodeName","splice","_disgregateLayerNames","ln","slice","rootNode","getRootLayerNode","concat","_disgregateLayerName","ancestorVisible","nodeVisible","compareNames","hasEmptyChildren","_extendLayerNameOptions","aggregate","lazy","_combineArray","source","add","rem","a","r","sa","_sortLayerNames","getTree","sort","b","idxa","idxb","_isNameInArray","looseComparison","grep","getLimitedMatrixSet","layerId","matrixSet","cap","ret","tset","elto","limit","limits","matrix","combi","matrixIndex","_getLimitedMatrixSet","setLayerNames","getLayer","opts","WMS","_aggregateLayerNames","newParams","_newParams","getParams","BEFOREUPDATEPARAMS","setParams","reset","UPDATEPARAMS","addLayerNames","ln2a","getDisgregatedLayerNames","removeLayerNames","ln2r","toggleLayerNames","ln2t","currentLayerNames","l","promises","all","arrays","a1","a2","olLayer","isNative","isValidFromNames","getLayerNodeByName","isCompatible","crs","getCompatibleMatrixSets","getCompatibleCRS","includeFallback","fallbackLayer","fbLayer","getFallbackLayer","normalized","getCRSCode","code","reduce","prev","cur","getProjection","getSource","getCode","setProjection","setMatrixSet","mustReproject","isVisibleByScale","nameOrUid","currentScale","_getOgcScale","getResolution","getMetersPerUnit","tileMatrix","getTileMatrix","scaleDenominators","getScaleDenominators","layers","getAllLayerNodes","node","parseFloat","some","nodeLayer","isVisibleByName","getWMTSLayer","__getLayerPath","capabilitiesNode","n","layerNodes","fastUnshift","path","_getLayerPath","getTreeNode","forceAddition","isRootNode","uid","key","getUID","child","title","Title","isBase","isDefault","thumbnail","legend","src","getVisibility","inverseTree","getLegend","hideTree","cache","_setNodeState","_result","visibility","NOT_VISIBLE","hasVisible","hasNotVisible","VISIBLE","HAS_VISIBLE","visibilityState","_sortTree","n1","n2","customLegend","setNodeVisibility","findNode","_getNames","getNodeVisibility","getNodePath","layerName","ignorePrefix","_getPath","getPath","getServiceType","getIdentifier","nodes","getChildrenLayers","_fnRecursiva","lyr","arr","lc","idx1","idx2","getResolutions","searchSubLayers","patternFn","t","lastPattern","lastMatches","re","RegExp","matches","tcScore","tcPosition","normalizeLayerNode","trim","exec","titleIx","index","abstractIx","Abstract","abs","res2","titleA","replaceAccent","titleB","match","cleanOgcUrl","infoFormats","getInfoFormats","infoFormatPreference","getLegendGraphicImage","base64LegendSrc","btoa","info","getInfo","xhr","XMLHttpRequest","dataEntries","chunks","env","open","setRequestHeader","onload","status","uInt8Array","Uint8Array","response","binaryString","Array","String","fromCharCode","getResponseHeader","imageSrc","send","getUrl","getWebGLUrl","location","_src","isSecureURL","toAbsolutePath","ignoreProxification","exportable","fetchImage","cacheHost","getAction","action","getFeatureUrl","getSiblingLoadedLayer","dynamicStatement","baseLayers","workLayers","elem","isFunction","getImageLoad","image","setSRC","olImg","getImage","mustBeExportable","crossOrigin","setAttribute","_get$events","TILELOAD","tile","TILELOADERROR","statusText","z","x","y","parts","wmtsOptions","level","on3DView","BEFORETILELOAD","values","toLowerCase","fetchImageAsBlob","contentType","imageUrl","evt","revokeObjectURL","img","onerror","$events","getWFSCapabilitiesPromise","basicUrl","substring","WFScapabilities","setTimeout","getParamString","xmlDoc","ownerDocument","errorNode","DOMParser","parseFromString","innerHTML","WFSCapabilities","Parse","Operations","_url","GetCapabilities","DCP","HTTP","Get","DCPType","onlineResource","availableBaseLayers","Cfg","forEach","baseLayer","stealth","firstOption","esriParser","parse","dom","tagName","fiCollections","fic","getAttribute","fInfos","lenj","fields","attributes","lenk","field","getElementText","feature","ol","Feature","setId"],"mappings":"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","sourcesContent":["\r\nTC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\nTC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';\r\n\r\n(function () {\r\n\r\n    var capabilitiesPromises = {};\r\n\r\n    const isWebWorkerEnabled = !TC.isLegacy && window.hasOwnProperty('Worker');\r\n    const wwPromise = new Promise(function (resolve, reject) {\r\n        if (isWebWorkerEnabled) {\r\n            // Para evitar problemas con IE10 y Opera evitamos el uso de blobs cuando es evitable\r\n            var wwLocation = TC.apiLocation + 'TC/workers/tc-caps-web-worker.js';\r\n            if (TC.Util.isSameOrigin(TC.apiLocation)) {\r\n                resolve(wwLocation);\r\n            }\r\n            else {\r\n                TC.ajax({\r\n                    url: wwLocation,\r\n                    method: 'GET',\r\n                    responseType: 'text'\r\n                }).then(\r\n                    function (data) {\r\n                        var blob = new Blob([data], { type: \"text/javascript\" });\r\n                        var url = window.URL.createObjectURL(blob);\r\n                        resolve(url);\r\n                    },\r\n                    function (e) {\r\n                        reject(Error(e));\r\n                    }\r\n                    );\r\n            }\r\n        }\r\n    });\r\n\r\n    const parseCapabilities = function (layer, data) {\r\n        var capabilities;\r\n\r\n        if (data.documentElement) {\r\n\r\n            const serviceException = data.getElementsByTagName('ServiceException')[0];\r\n            if (serviceException) {\r\n                capabilities = { error: serviceException.textContent };\r\n            }\r\n            else {\r\n                var format = (layer.type === TC.Consts.layerType.WMTS) ? new layer.wrap.WmtsParser() : new layer.wrap.WmsParser();\r\n                capabilities = format.read(data);\r\n\r\n                //parsear a manija los tileMatrixSetLimits, que openLayers no lo hace (de momento)\r\n                if (layer.type === TC.Consts.layerType.WMTS) {\r\n                    if (capabilities.Contents && capabilities.Contents.Layer) {\r\n                        const layerCollection = data.getElementsByTagName('Layer');\r\n                        for (var i = 0, len = layerCollection.length; i < len; i++) {\r\n                            const curXmlLy = layerCollection[i];\r\n                            var nd = TC.Util.getElementByNodeName(curXmlLy, \"ows:Identifier\")[0];\r\n                            var id = nd.firstChild.data;\r\n\r\n                            var capLy = capabilities.Contents.Layer.filter(function (ly) {\r\n                                return ly.Identifier == id;\r\n                            });\r\n\r\n                            if (capLy.length) {\r\n                                capLy = capLy[0];\r\n                                for (var j = 0; j < capLy.TileMatrixSetLink.length; j++) {\r\n                                    var capLink = capLy.TileMatrixSetLink[j];\r\n                                    matrixId = capLink.TileMatrixSet;\r\n\r\n                                    xmlLink = curXmlLy.getElementsByTagName('TileMatrixSetLink').each(function (ix, curLink) {\r\n                                        return $(curLink).find(\"TileMatrixSet:first\").text() == matrixId;\r\n                                    });\r\n\r\n                                    if (xmlLink.length) {\r\n                                        xmlLink = xmlLink[0];\r\n                                        capLink.TileMatrixSetLimits = [];\r\n                                        const tmlCollection = xmlLink.getElementsByTagName('TileMatrixLimits');\r\n                                        for (var k = 0, kk = tmlCollection.length; k < kk; k++) {\r\n                                            const lim = tmlCollection[k];\r\n                                            capLink.TileMatrixSetLimits.push({\r\n                                                TileMatrix: lim.getElementsByTagName('TileMatrix')[0].textContent,\r\n                                                MinTileRow: parseInt(lim.getElementsByTagName('MinTileRow')[0].textContent),\r\n                                                MinTileCol: parseInt(lim.getElementsByTagName('MinTileCol')[0].textContent),\r\n                                                MaxTileRow: parseInt(lim.getElementsByTagName('MaxTileRow')[0].textContent),\r\n                                                MaxTileCol: parseInt(lim.getElementsByTagName('MaxTileCol')[0].textContent)\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            storeCapabilities(layer, capabilities);\r\n            return Promise.resolve(capabilities);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve, reject) {\r\n                if (isWebWorkerEnabled && typeof data === 'string') {\r\n                    wwPromise.then(function (wwUrl) {\r\n                        var worker = new Worker(wwUrl);\r\n                        worker.onmessage = function (e) {\r\n                            if (e.data.state === 'success') {\r\n                                capabilities = e.data.capabilities;\r\n\r\n                                // GLS: Sólo almacenamos si el capabilities es correcto\r\n                                storeCapabilities(layer, capabilities);\r\n                            }\r\n                            else {\r\n                                capabilities = {\r\n                                    error: 'Web worker error'\r\n                                }\r\n                                reject(capabilities.error);\r\n                            }\r\n\r\n                            resolve(capabilities);\r\n                            worker.terminate();\r\n                        };\r\n                        worker.postMessage({\r\n                            type: layer.type,\r\n                            text: data\r\n                        });\r\n                    })\r\n                }\r\n                else {\r\n                    capabilities = data;\r\n                    resolve(capabilities);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    const capabilitiesError = function (layer, reason) {\r\n        const msg = 'No se pudo obtener el documento de capacidades del servicio ' + layer.url + ': [' + reason + ']';\r\n        TC.error(msg);\r\n        if (layer.map) {\r\n            layer.map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: 'couldNotGetCapabilities' });\r\n        }\r\n        layer.wrap.setLayer(null);\r\n        return msg;\r\n    };\r\n\r\n    const getCapabilitiesOnline = function (layer) {\r\n        const serviceUrl = layer.url;\r\n        return new Promise(function (resolve, reject) {\r\n            var url;\r\n            const params = {};\r\n            if (layer.type === TC.Consts.layerType.WMTS) {\r\n                if (layer.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {\r\n                    var suffix = '/1.0.0/WMTSCapabilities.xml';\r\n                    const suffixIdx = serviceUrl.indexOf(suffix);\r\n                    if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {\r\n                        if (serviceUrl[serviceUrl.length - 1] === '/') {\r\n                            suffix = suffix.substr(1);\r\n                        }\r\n                        url = serviceUrl + suffix;\r\n                    }\r\n                    else {\r\n                        url = serviceUrl;\r\n                    }\r\n                }\r\n                else {\r\n                    url = serviceUrl;\r\n                    params.SERVICE = 'WMTS';\r\n                    params.VERSION = '1.0.0';\r\n                    params.REQUEST = 'GetCapabilities';\r\n                }\r\n            }\r\n            else {\r\n                url = serviceUrl;\r\n                params.SERVICE = 'WMS';\r\n                params.VERSION = '1.3.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n            }\r\n            url = url + '?' + $.param($.extend(params, layer.queryParams));\r\n\r\n            layer.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {\r\n                parseCapabilities(layer, data.responseText)\r\n                    .then(function (capabilities) {\r\n                        if (capabilities.error) {\r\n                            reject(Error(capabilitiesError(layer, capabilities.error)));\r\n                            return;\r\n                        }\r\n                        resolve(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        reject(Error(error));\r\n                    });\r\n            }).catch(function (dataError) {\r\n                reject(Error(capabilitiesError(layer, dataError)));\r\n            });\r\n\r\n        });\r\n    };\r\n\r\n    const getCapabilitiesFromStorage = function (layer) {\r\n        return new Promise(function (resolve, reject) {\r\n            // Obtenemos el capabilities almacenado en caché\r\n            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {\r\n                localforage.getItem(layer.CAPABILITIES_STORE_KEY_PREFIX + layer.url)\r\n                    .then(function (value) {\r\n                        if (value) {\r\n                            resolve(value);\r\n                        }\r\n                        else {\r\n                            reject('Capabilities not in storage');\r\n                        }\r\n                    })\r\n                    .catch(function () {\r\n                        reject('Undefined storage error');\r\n                    });\r\n            });\r\n        });\r\n    };\r\n\r\n    const storeCapabilities = function (layer, capabilities) {\r\n        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {\r\n\r\n            // Esperamos a que el mapa se cargue y entonces guardamos el capabilities.\r\n            // Así evitamos que la operación, que es bastante pesada, ocupe tiempo de carga \r\n            // (con el efecto secundario de que LoadingIndicator esté un tiempo largo apagado durante la carga)\r\n            var capKey = layer.CAPABILITIES_STORE_KEY_PREFIX + layer.options.url;\r\n            var setItem = function () {\r\n                // GLS: antes de guardar, validamos que es un capabilities sin error\r\n                if (capabilities.hasOwnProperty(\"error\")) {\r\n                    return;\r\n                } else {\r\n\r\n                    layer.getCapabilitiesPromise().then(function () {\r\n                        localforage.setItem(capKey, capabilities).then(function () { }).catch(function (err) {\r\n                            console.log(err);\r\n                        });\r\n                    });\r\n                }\r\n            };\r\n            if (layer.map) {\r\n                layer.map.loaded(setItem);\r\n            }\r\n            else {\r\n                setItem();\r\n            }\r\n        });\r\n    };\r\n\r\n    const _createWMSLayer = function (layer) {\r\n\r\n        var layerNames = $.isArray(layer.names) ? layer.names.join(',') : layer.names;\r\n        var format = layer.options.format;\r\n        var options = layer.options;\r\n\r\n        var params = {\r\n            LAYERS: layerNames,\r\n            FORMAT: format,\r\n            TRANSPARENT: layer.transparent,\r\n            VERSION: layer.capabilities.version || '1.3.0'\r\n        };\r\n\r\n        if (layer.params) {\r\n            $.extend(params, layer.params);\r\n        }\r\n\r\n        if (layer.queryParams) {\r\n            $.extend(params, layer.queryParams);\r\n        }\r\n\r\n        var infoFormat = layer.getPreferredInfoFormat();\r\n        if (infoFormat !== null) {\r\n            params.INFO_FORMAT = infoFormat;\r\n        }\r\n\r\n        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);\r\n    };\r\n\r\n    const _createWMTSLayer = function (layer) {\r\n        return layer.wrap.createWMTSLayer(layer.options);\r\n    };\r\n\r\n    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {\r\n\r\n        var result = $.inArray(treeNode.name, layer.availableNames);\r\n        if (result === -1) {\r\n            for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n                result = _getLayerNodeIndex(layer, treeNode.children[i]);\r\n                if (result !== -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const _sortTree = function _sortTree(layer, treeNode) {\r\n        var _sortFunction = function (n1, n2) {\r\n            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);\r\n        }\r\n        treeNode.children.sort(_sortFunction);\r\n        for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n            _sortTree(layer, treeNode.children[i]);\r\n        }\r\n    };\r\n\r\n    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {\r\n        var result = false;\r\n        counter.count = counter.count + 1;\r\n        if (treeNode.name === name) {\r\n            result = true;\r\n        }\r\n        else {\r\n            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés\r\n            for (var i = treeNode.children.length - 1; i >= 0; i--) {\r\n                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Opciones de nombre de capa.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.LayerNameOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.\r\n     * @property aggregate\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n    /**\r\n     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} (valor <code>false</code>) \r\n     * o se espera a que la capa se actualice (valor <code>true</code>).\r\n     * @property lazy\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n    /**\r\n     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/availableNames:property\"}}{{/crossLink}} (valor <code>false</code>) se restablece \r\n     * al actualizar la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}}.\r\n     * @property reset\r\n     * @type boolean|undefined\r\n     */\r\n\r\n    /**\r\n     * Opciones de capa raster.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.RasterOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.WMS\r\n     */\r\n    /**\r\n     * URL del servicio OGC que define la capa.\r\n     * @property url\r\n     * @type string\r\n     */\r\n    /**\r\n     * Indica si la capa tiene transparencia.\r\n     * @property transparent\r\n     * @type boolean|undefined\r\n     */\r\n    /**\r\n     * Lista separada por comas de los nombres de capa del servicio OGC.\r\n     * @property layerNames\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.\r\n     * @property matrixSet\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo raster, como la de un WMS o un WMTS.\r\n     * @class TC.layer.Raster\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Raster = function () {\r\n        var self = this;\r\n\r\n        if (!TC.tool || !TC.tool.Proxification) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');\r\n        }\r\n\r\n        this.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        this._capabilitiesPromise = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.wrap = new TC.wrap.layer.Raster(self);\r\n\r\n        /**\r\n         * Indica si la capa tiene transparencia.\r\n         * @property transparent\r\n         * @type boolean\r\n         * @default true\r\n         */\r\n        self.transparent = (self.options.transparent === false) ? false : true;\r\n\r\n        /**\r\n         * URL del servicio al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        self.url = self.options.url;\r\n        self.capabilities = TC.capabilities[self.url];\r\n\r\n        self.params = self.options.params;\r\n        /**\r\n         * Lista de nombres de capa.\r\n         * @property names\r\n         * @type array\r\n         * @default []\r\n         */\r\n        /**\r\n         * Lista de nombres de capa disponibles inicialmente.\r\n         * @property availableNames\r\n         * @type array\r\n         * @default []\r\n         */\r\n        if (typeof self.options.layerNames === 'string') {\r\n            self.names = self.availableNames = self.options.layerNames.split(',');\r\n        }\r\n        else {\r\n            self.names = [];\r\n            self.availableNames = [];\r\n            if ($.isArray(self.options.layerNames)) {\r\n                for (var i = 0; i < self.options.layerNames.length; i++) {\r\n                    var name = self.options.layerNames[i];\r\n                    if (typeof name === 'string') {\r\n                        self.names.push(name);\r\n                        self.availableNames.push(name);\r\n\r\n                    }\r\n                    else if (name.hasOwnProperty('name')) {\r\n                        self.availableNames.push(name.name);\r\n                        if (name.isVisible === undefined || name.isVisible) {\r\n                            self.names.push(name.name);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado\r\n                // cuando queremos instanciar una capa pasándole un SLD en la petición\r\n                var sldBody = self.options.params ? self.options.params.sld_body : null;\r\n\r\n                if (sldBody) {\r\n                    var sldBodyToXml = $.parseXML(sldBody);\r\n                    var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');\r\n                    if (namedLayerElm && namedLayerElm.length > 0) {\r\n                        var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');\r\n\r\n                        if (names && names.length > 0) {\r\n                            var name = names[0].textContent;\r\n                            self.names.push(name);\r\n                            self.availableNames.push(name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;\r\n\r\n        self._capabilitiesNodes = {};\r\n\r\n        /**\r\n      * Árbol del documento de capabilities del servicio.\r\n      * @property capabilities\r\n      * @type object\r\n      */\r\n        self.wrap._promise = new Promise(function (resolve, reject) {\r\n            /*\r\n             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo\r\n             */\r\n            var _createOLLayer = function () {\r\n                var ollyr;\r\n                if (!self.wrap.layer) {\r\n                    switch (self.type) {\r\n                        case TC.Consts.layerType.GROUP:\r\n                            break;\r\n                        case TC.Consts.layerType.WMTS:\r\n                            ollyr = _createWMTSLayer(self);\r\n                            break;\r\n                        default:\r\n                            ollyr = _createWMSLayer(self);\r\n                            break;\r\n                    }\r\n                    self.wrap.setLayer(ollyr);\r\n                    resolve(ollyr);\r\n                }\r\n            };\r\n\r\n            const processedCapabilities = function (capabilities) {\r\n                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                self.capabilities = self.capabilities || capabilities;\r\n\r\n                var actualUrl = self.getGetMapUrl();\r\n                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;\r\n                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;\r\n\r\n                _createOLLayer();\r\n            };\r\n\r\n            if (self.capabilities) {\r\n                processedCapabilities(self.capabilities);\r\n                self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                return;\r\n            }\r\n\r\n            const cachePromise = capabilitiesPromises[self.url];\r\n            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {\r\n                var onlineFail = false;\r\n                var storageFail = false;\r\n                const onlinePromise = getCapabilitiesOnline(self);\r\n                const storagePromise = getCapabilitiesFromStorage(self);\r\n\r\n                onlinePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        onlineFail = true;\r\n                        if (storageFail) {\r\n                            rej(Error(error));\r\n                        }\r\n                    });\r\n                storagePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        storageFail = true;\r\n                        if (onlineFail) {\r\n                            rej(Error(error));\r\n                        }\r\n                    });\r\n            });\r\n\r\n            self.getCapabilitiesPromise()\r\n                .then(function (capabilities) {\r\n                    processedCapabilities(capabilities);\r\n                })\r\n                .catch(function (error) {\r\n                    reject(Error(error));\r\n                });\r\n        });\r\n\r\n        self._disgregatedLayerNames = null;\r\n\r\n        if (TC.Consts.layerType.WMTS == self.type) {\r\n            self.wrap.setWMTSUrl();\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.layer.Raster, TC.Layer);\r\n\r\n    var layerProto = TC.layer.Raster.prototype;\r\n\r\n    layerProto.PROTOCOL_REGEX = /^(f|ht)tp?:\\/\\//i;\r\n    layerProto.capabilitiesState_ = {\r\n        PENDING: 0,\r\n        DONE: 1\r\n    };\r\n\r\n    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';\r\n\r\n    layerProto.getByProxy_ = function (url) {\r\n        return TC.proxify(url);\r\n    };\r\n\r\n    layerProto.getBySSL_ = function (url) {\r\n        var self = this;\r\n\r\n        return url.replace(self.PROTOCOL_REGEX, \"https://\");\r\n    };\r\n\r\n    layerProto.getByUrl_ = function (url) {\r\n        return url;\r\n    };\r\n\r\n\r\n    layerProto.setVisibility = function (visible) {\r\n        var layer = this;\r\n        layer.tree = null;\r\n        layer._cache.visibilityStates = {\r\n        };\r\n        TC.Layer.prototype.setVisibility.call(layer, visible);\r\n    };\r\n\r\n    /*\r\n     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)\r\n     */\r\n    var _getLimitedMatrixSet = function (layer) {\r\n        var layerId = layer.layerNames;\r\n        var matrixId = layer.matrixSet;\r\n        var cap = layer.capabilities;\r\n\r\n        var ret = [];\r\n\r\n        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {\r\n            return elto.Identifier == matrixId;\r\n        });\r\n        if (tset.length) {\r\n            tset = tset[0];\r\n            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];\r\n            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {\r\n                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;\r\n                for (var i = 0; i < limits.length; i++) {\r\n                    limit = limits[i];\r\n                    var matrix = tset.TileMatrix.filter(function (elto) {\r\n                        return elto.Identifier == limit.TileMatrix\r\n                    });\r\n                    if (matrix.length) {\r\n                        var combi = $.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);\r\n                        ret.push(combi);\r\n                    }\r\n                }\r\n\r\n                return ret;\r\n            }\r\n            else {\r\n                return tset.TileMatrix;\r\n            }\r\n        }\r\n        else\r\n            return null;\r\n    };\r\n\r\n\r\n    /*\r\n     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen\r\n     */\r\n    var _aggregateLayerNames = function (layer, layerNames) {\r\n        if (layer.type !== TC.Consts.layerType.WMS) {\r\n            return layerNames;\r\n        }\r\n        else {\r\n            var ln = layerNames.slice();\r\n            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());\r\n            return ln;\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.\r\n     * Se parte de un nodo del árbol de capas del capabilities\r\n     */\r\n    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {\r\n        var result = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        if (children.length) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                if (_aggregateLayerNodeNames(layer, names, children[i])) {\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            var nodeNames = $.map(children, function (elm) {\r\n                return layer.wrap.getName(elm);\r\n            }).reverse();\r\n            var idx, firstIdx;\r\n            var fail = false;\r\n\r\n            firstIdx = idx = $.inArray(nodeNames[0], names);\r\n            if (idx < 0) {\r\n                fail = true;\r\n            }\r\n            else {\r\n                for (var i = 1, len = nodeNames.length; i < len; i++) {\r\n                    if (nodeNames[i] != names[++idx]) {\r\n                        fail = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!fail) {\r\n                var nodeName = layer.wrap.getName(layerNode);\r\n                if (nodeName && nodeNames.length > 1) {\r\n                    names.splice(firstIdx, nodeNames.length, nodeName);\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.\r\n     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible\r\n     */\r\n    var _disgregateLayerNames = function (layer, layerNames) {\r\n        var result = [];\r\n        var ln = layerNames.slice();\r\n        var rootNode = layer.wrap.getRootLayerNode();\r\n        for (var i = 0, len = ln.length; i < len; i++) {\r\n            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {\r\n        var result = [];\r\n        var nodeName = layer.wrap.getName(layerNode);\r\n        var nodeVisible = layer.compareNames(name, nodeName);\r\n        var hasEmptyChildren = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        for (var i = 0; i < children.length; i++) {\r\n            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);\r\n            if (!names.length) {\r\n                hasEmptyChildren = true;\r\n            }\r\n            else {\r\n                result = result.concat(names);\r\n            }\r\n        }\r\n        if (!children.length || hasEmptyChildren) {\r\n            if (ancestorVisible || nodeVisible) {\r\n                result = [nodeName];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _extendLayerNameOptions = function (options) {\r\n        return $.extend({ aggregate: true, lazy: false }, options);\r\n    };\r\n\r\n    var _combineArray = function (source, add, rem) {\r\n        var result = [];\r\n        var s, a, r;\r\n        s = source ? source : [];\r\n        a = add ? add : [];\r\n        r = rem ? rem : [];\r\n        var sa = s.concat(a);\r\n        for (var i = 0; i < sa.length; i++) {\r\n            if ($.inArray(sa[i], sa) === i && $.inArray(sa[i], r) === -1) {\r\n                result[result.length] = sa[i];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _sortLayerNames = function (layer, layerNames) {\r\n        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;\r\n        if (layer.capabilities) {\r\n            var tree = layer.getTree();\r\n            ln.sort(function (a, b) {\r\n                var idxa = {\r\n                    count: 0\r\n                };\r\n                var idxb = {\r\n                    count: 0\r\n                };\r\n                _getLayerNamePosition(tree, a, idxa);\r\n                _getLayerNamePosition(tree, b, idxb);\r\n                return idxa.count - idxb.count;\r\n            });\r\n        }\r\n        return ln;\r\n    };\r\n\r\n    var _isNameInArray = function (layer, name, names, looseComparison) {\r\n        return $.grep(names, function (elm) {\r\n            return layer.compareNames(name, elm, looseComparison);\r\n        }).length > 0;\r\n    };\r\n\r\n\r\n    layerProto.getLimitedMatrixSet = function () {\r\n        return _getLimitedMatrixSet(this);\r\n    };\r\n\r\n    /**\r\n     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.\r\n     * @method setLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  setLayerNames: sets the visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.setLayerNames = function (layerNames, options) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var ln = $.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                layer.names = ln;\r\n                var opts = _extendLayerNameOptions(options);\r\n                if (opts.aggregate) {\r\n                    ln = _aggregateLayerNames(layer, ln);\r\n                }\r\n                layer._disgregatedLayerNames = null;\r\n                var newParams = {\r\n                    LAYERS: ln.join(','), TRANSPARENT: true\r\n                };\r\n                // Si no hay capas ocultamos la capa de servicio\r\n                if (!ln.length) {\r\n                    layer.setVisibility(false);\r\n                }\r\n                if (opts.lazy) {\r\n                    var params = layer._newParams || layer.wrap.getParams();\r\n                    layer._newParams = $.extend(params, newParams);\r\n                }\r\n                else {\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                    }\r\n                    layer.tree = null;\r\n                    layer._cache.visibilityStates = {\r\n                    };\r\n                    layer.wrap.setParams(newParams);\r\n                    if (opts.reset || !layer.map) {\r\n                        // layerNames se fija cuando se añade al mapa o cuando reset = true.\r\n                        layer.availableNames = layer.names;\r\n                    }\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                    }\r\n                }\r\n                resolve(layer.names);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Añade capas por nombre a las que ya están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.addLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2a = $.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2a = _disgregateLayerNames(self, ln2a);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Elimina capas por nombre de las que están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.removeLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2r = $.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2r = _disgregateLayerNames(self, ln2r);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.\r\n     * @method toggleLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.toggleLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2t = $.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var currentLayerNames = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2t = _disgregateLayerNames(self, ln2t);\r\n                    currentLayerNames = self.getDisgregatedLayerNames();\r\n                }\r\n                var ln2a = [];\r\n                var ln2r = [];\r\n                for (var i = 0; i < ln2t.length; i++) {\r\n                    var l = ln2t[i];\r\n                    if ($.inArray(l, currentLayerNames) < 0) {\r\n                        ln2a[ln2a.length] = l;\r\n                    }\r\n                    else {\r\n                        ln2r[ln2r.length] = l;\r\n                    }\r\n                }\r\n                var promises = [];\r\n                if (ln2a.length > 0) {\r\n                    promises.push(self.addLayerNames(ln2a, opts));\r\n                }\r\n                if (ln2r.length > 0) {\r\n                    promises.push(self.removeLayerNames(ln2r, opts));\r\n                }\r\n                Promise.all(promises).then(function (arrays) {\r\n                    const a1 = arrays[0];\r\n                    const a2 = arrays[1];\r\n                    if (a1) {\r\n                        if (a2) {\r\n                            resolve(a1.concat(a2));\r\n                        }\r\n                        else {\r\n                            resolve(a1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n     * @method getDisgregatedLayerNames\r\n     * @return {array}\r\n     */\r\n    /*\r\n     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names\r\n     */\r\n    layerProto.getDisgregatedLayerNames = function () {\r\n        ///<summary>\r\n        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n        ///</summary>\r\n        ///<returns type=\"array\" elementType=\"string\"></returns>\r\n        var self = this;\r\n        var olLayer = self.wrap.layer;\r\n        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {\r\n            if (!self._disgregatedLayerNames) {\r\n                var layerNames = self.wrap.getParams().LAYERS;\r\n                layerNames = $.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);\r\n            }\r\n        }\r\n        else {\r\n            self._disgregatedLayerNames = self.names;\r\n        }\r\n        return self._disgregatedLayerNames.slice();\r\n    };\r\n\r\n    layerProto.isValidFromNames = function () {\r\n        var self = this;\r\n        var result = true;\r\n        for (var i = 0, len = self.names.length; i < len; i++) {\r\n            if (!self.getLayerNodeByName(self.names[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isCompatible = function (crs) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = self.wrap.isCompatible(crs);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var result = self.wrap.getCompatibleCRS();\r\n        if (options.includeFallback && self.fallbackLayer) {\r\n            const fbLayer = self.getFallbackLayer();\r\n            if (fbLayer instanceof TC.Layer) {\r\n                result = result.concat(fbLayer.wrap.getCompatibleCRS());\r\n            }\r\n        }\r\n        if (options.normalized) {\r\n            result = result\r\n                .map(function (crs) {\r\n                    return TC.Util.getCRSCode(crs);\r\n                }) // códigos numéricos\r\n                .filter(function (code) {\r\n                    return code !== null;\r\n                })\r\n                .reduce(function (prev, cur) {\r\n                    if (prev.indexOf(cur) < 0) {\r\n                        prev[prev.length] = cur;\r\n                    }\r\n                    return prev;\r\n                }, []) // códigos numéricos sin duplicados\r\n                .map(function (code) {\r\n                    return 'EPSG:' + code;\r\n                }); // códigos normalizados\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getProjection = function () {\r\n        var self = this;\r\n\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                return self.wrap.layer.getSource().getProjection().getCode();\r\n            case TC.Consts.layerType.WMS:\r\n                return self.map.crs;\r\n        }\r\n    };\r\n\r\n    layerProto.setProjection = function (options) {\r\n        var self = this;\r\n        options = options || {};\r\n        if (options.crs) {\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];\r\n                    if (matrixSet) {\r\n                        self.matrixSet = matrixSet;\r\n                        self.wrap.setMatrixSet(matrixSet);\r\n                    }\r\n                    else {\r\n                        self.wrap.setProjection(options);\r\n                    }\r\n                    self.mustReproject = !matrixSet;\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    self.wrap.setProjection(options);\r\n                    self.mustReproject = !self.isCompatible(options.crs);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByScale: return wether the WMS layer is visible at current scale\r\n     *  Parameter: WMS layer name or UID\r\n     */\r\n    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {\r\n        var self = this;\r\n        var result;\r\n        var _getOgcScale = function () {\r\n            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel\r\n        };\r\n        var currentScale;\r\n        var i;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = false;\r\n                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);\r\n                if (tileMatrix) {\r\n                    currentScale = _getOgcScale();\r\n                    for (i = 0; i < tileMatrix.length; i++) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);\r\n                        if (scaleDenominators[0] === currentScale) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:                \r\n                result = true;\r\n                var layers = self.wrap.getAllLayerNodes();\r\n                if (layers.length > 0) {\r\n                    currentScale = _getOgcScale();\r\n                    var node;\r\n                    if (typeof nameOrUid === 'number') {\r\n                        node = self._capabilitiesNodes[nameOrUid];\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < layers.length; i++) {\r\n                            var layer = layers[i];\r\n                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {\r\n                                node = layer;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(node);\r\n                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);\r\n\r\n                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.\r\n                        if (!result) {\r\n                            if (node.Layer && node.Layer.length > 0) {\r\n                                return node.Layer.some(function (nodeLayer) {\r\n                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);\r\n                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names\r\n     *  Parameter: WMS layer name\r\n     */\r\n    layerProto.isVisibleByName = function (name, looseComparison) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                var _getLayerPath = function _getLayerPath(name) {\r\n                    return __getLayerPath(name, self.wrap.getRootLayerNode());\r\n                };\r\n\r\n                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {\r\n                    var result = null;\r\n                    var n = self.wrap.getName(capabilitiesNode);\r\n                    if (self.compareNames(n, name, looseComparison)) {\r\n                        result = [n];\r\n                    }\r\n                    else {\r\n                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                        for (var i = 0; i < layerNodes.length; i++) {\r\n                            var item = layerNodes[i];\r\n                            var r = __getLayerPath(name, item);\r\n                            if (r) {\r\n                                TC.Util.fastUnshift(r, n);\r\n                                result = r;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                var path = _getLayerPath(name);\r\n                if (path) {\r\n                    for (var i = 0; i < path.length; i++) {\r\n                        if (_isNameInArray(self, path[i], self.names)) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getTree = function () {\r\n        var self = this;\r\n        var result = self.tree;\r\n\r\n        var addChild = function (node, child) {\r\n            if (self.options.inverseTree) {\r\n                // Versión rápida de unshift\r\n                TC.Util.fastUnshift(node.children, child);\r\n            }\r\n            else {\r\n                node.children[node.children.length] = child;\r\n            }\r\n        }\r\n\r\n        if (!result) {\r\n            var rootNode;\r\n            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {\r\n                var uid;\r\n                for (var key in self._capabilitiesNodes) {\r\n                    if (self._capabilitiesNodes[key] === capabilitiesNode) {\r\n                        uid = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!uid) {\r\n                    uid = TC.getUID();\r\n                    self._capabilitiesNodes[uid] = capabilitiesNode;\r\n                }\r\n                var r = {\r\n                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []\r\n                };\r\n                if (isRootNode) {\r\n                    rootNode = r;\r\n                }\r\n\r\n                if (_isNameInArray(self, r.name, self.availableNames)) {\r\n                    forceAddition = true;\r\n                }\r\n\r\n                if (!self.options.isBase) {\r\n                    if (r === rootNode) {\r\n                        r.isVisible = self.getVisibility();\r\n                    }\r\n                    else {\r\n                        r.isVisible = self.isVisibleByName(r.name);\r\n                    }\r\n                    var i;\r\n                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                    for (i = 0; i < layerNodes.length; i++) {\r\n                        var treeNode = getTreeNode(layerNodes[i], forceAddition);\r\n                        if (treeNode) {\r\n                            addChild(r, treeNode);\r\n                        }\r\n                    }\r\n\r\n                    r.legend = self.wrap.getLegend(capabilitiesNode);\r\n\r\n                    // No muestra ramas irrelevantes si hideTree = true\r\n                    if (!forceAddition && !isRootNode) {\r\n                        // Eliminamos la rama hasta el nodo de interés\r\n                        rootNode.children = rootNode.children.concat(r.children);\r\n                        r = null;\r\n                    }\r\n                }\r\n                else {\r\n                    r.name = self.names.join(',');\r\n                    r.title = self.title || r.title;\r\n                    r.isBase = self.isDefault;\r\n                    if (self.options.thumbnail) {\r\n                        r.legend = {\r\n                            src: self.options.thumbnail\r\n                        };\r\n                    }\r\n                }\r\n                return r;\r\n            };\r\n\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    if (self.capabilities) {\r\n                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);\r\n\r\n                        var cache = self._cache.visibilityStates;\r\n\r\n                        var _setNodeState = function _setNodeState(node) {\r\n                            var _result = TC.Consts.visibility.NOT_VISIBLE;\r\n                            if (node) {\r\n                                if (cache[node.uid] !== undefined) {\r\n                                    _result = cache[node.uid];\r\n                                }\r\n                                else {\r\n                                    if (node.children) {\r\n                                        var hasVisible = false;\r\n                                        var hasNotVisible = false;\r\n                                        for (var i = 0, len = node.children.length; i < len; i++) {\r\n                                            var r = _setNodeState(node.children[i]);\r\n                                            switch (r) {\r\n                                                case TC.Consts.visibility.VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.NOT_VISIBLE:\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.HAS_VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                default:\r\n                                                    break;\r\n                                            }\r\n                                            if (hasVisible) {\r\n                                                if (hasNotVisible) {\r\n                                                    _result = TC.Consts.visibility.HAS_VISIBLE;\r\n                                                }\r\n                                                else {\r\n                                                    _result = TC.Consts.visibility.VISIBLE;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (node.isVisible) {\r\n                                        _result = TC.Consts.visibility.VISIBLE;\r\n                                    }\r\n                                    cache[node.uid] = _result;\r\n                                }\r\n                                node.visibilityState = _result;\r\n                            }\r\n                            return _result;\r\n                        };\r\n                        _setNodeState(result);\r\n\r\n                        if (self.options.hideTree) {\r\n                            _sortTree(self, result);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!result) {\r\n                result = {\r\n                    name: self.name, title: self.title\r\n                };\r\n            }\r\n            result.title = self.title || result.title;\r\n            result.customLegend = self.customLegend || result.customLegend;\r\n            self.tree = result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.setNodeVisibility = function (id, visible) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n\r\n        var _getNames = function _getNames(node) {\r\n            var result = [];\r\n            if (node.name) {\r\n                result[0] = node.name;\r\n            }\r\n            else {\r\n                for (var i = 0; i < node.children.length; i++) {\r\n                    result = result.concat(_getNames(node.children[i]));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var node = self.findNode(id, self.tree);\r\n        if (node === self.tree) {\r\n            if (visible && self.names.length === 0) {\r\n                // Prevent pink error tile\r\n                self.addLayerNames(self.availableNames).then(function () {\r\n                    self.setVisibility(true);\r\n                });\r\n            }\r\n            else {\r\n                self.setVisibility(visible);\r\n            }\r\n        }\r\n        else {\r\n            var names = _getNames(node);\r\n            if (visible) {\r\n                self.addLayerNames(names);\r\n            }\r\n            else {\r\n                self.removeLayerNames(names);\r\n            }\r\n        }\r\n    };\r\n\r\n    layerProto.getNodeVisibility = function (id) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n        return self._cache.visibilityStates[id];\r\n    };\r\n\r\n    layerProto.getNodePath = function (layerName, ignorePrefix) {\r\n        var self = this;\r\n        var result = [];\r\n        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {\r\n            layerName = layerName || self.names[0];\r\n\r\n            var _getPath = function _getPath(node) {\r\n                var res = [];\r\n                var nodeName = self.wrap.getName(node);\r\n                if (self.compareNames(nodeName, layerName, ignorePrefix)) {\r\n                    res.push(node);\r\n                }\r\n                else {\r\n                    var children = self.wrap.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        var r = _getPath(children[i]);\r\n                        if (r.length) {\r\n                            res = r;\r\n                            TC.Util.fastUnshift(res, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            };\r\n            result = _getPath(self.wrap.getRootLayerNode());\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getPath = function (layerName, ignorePrefix) {\r\n        return $.map(this.getNodePath(layerName, ignorePrefix), function (node) {\r\n            return node.title || node.Title;\r\n        });\r\n    };\r\n\r\n    layerProto.getLayerNodeByName = function (name) {\r\n        var result = null;\r\n        var self = this;\r\n        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName\r\n        var nodes = self.wrap.getAllLayerNodes();\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            if (self.compareNames(getName(nodes[i]), name)) {\r\n                result = nodes[i];\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getChildrenLayers = function (layer) {\r\n        var self = this;\r\n        var result = [];\r\n        var _fnRecursiva = function (lyr, arr) {\r\n            if (lyr && lyr.Layer && lyr.Layer.length) {\r\n                for (var i = 0; i < lyr.Layer.length; i++) {\r\n                    arr[arr.length] = lyr.Layer[i];\r\n                    _fnRecursiva(lyr.Layer[i], arr)\r\n                }\r\n            }\r\n        };\r\n        _fnRecursiva(layer, result);\r\n        return result;\r\n    };\r\n\r\n    layerProto.compareNames = function (n1, n2, looseComparison) {\r\n        var result = n1 === n2;\r\n        var self = this;\r\n        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes\r\n        if (!result && lc && n1 && n2) {\r\n            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación\r\n            var idx1 = n1.indexOf(':');\r\n            var idx2 = n2.indexOf(':');\r\n            if (idx1 >= 0 && idx2 < 0) {\r\n                result = n1.substr(idx1 + 1) === n2;\r\n            }\r\n            else if (idx2 >= 0 && idx1 < 0) {\r\n                result = n1 === n2.substr(idx2 + 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCapabilitiesPromise = function () {\r\n        return this._capabilitiesPromise;\r\n    };\r\n\r\n    layerProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado\r\n    //case insensitive\r\n    layerProto.searchSubLayers = function (text) {\r\n        if (!this.patternFn) {\r\n            this.patternFn = function (t) {\r\n                t = t.replace(/[^a-z\\dáéíóúüñ]/gi, '\\\\' + '$&');\r\n                t = t.replace(/(a|á)/gi, \"(a|á)\");\r\n                t = t.replace(/(e|é)/gi, \"(e|é)\");\r\n                t = t.replace(/(i|í)/gi, \"(i|í)\");\r\n                t = t.replace(/(o|ó)/gi, \"(o|ó)\");\r\n                t = t.replace(/(u|ú|ü)/gi, \"(u|ú|ü)\");\r\n                t = t.replace(/n/gi, \"(n|ñ)\");\r\n                return t;\r\n            }\r\n        }\r\n        if (text && text.length && text.length >= 3) {\r\n            var self = this;\r\n            var layers = null;\r\n            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado \"cat\" y ahora busco \"cata\" porque esto escribiendo \"catastro\" ...\r\n            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */\r\n            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {\r\n                layers = this.lastMatches\r\n            }\r\n            else {\r\n                /*si se ha definido el parametro layers de esta capa en configuraci\\u00f3n filtro las capas del capability para que busque solo en las capas que est\\u00e9n en \r\n                configuraci\\u00f3n y sus hijas*/\r\n                if (self.availableNames && self.availableNames.length > 0) {\r\n                    layers = []\r\n                    for (var i = 0; i < self.availableNames.length; i++) {\r\n                        var layer = self.getLayerNodeByName(self.availableNames[i]);\r\n                        if (layer) {\r\n                            layers[layers.length] = layer;\r\n                            layers = layers.concat(self.getChildrenLayers(layer));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    layers = self.wrap.getAllLayerNodes();\r\n                }\r\n            }\r\n\r\n            var filter = this.patternFn(text);\r\n            var re = new RegExp(filter, \"i\");\r\n\r\n            var matches = layers.map(function (ly, ix) {\r\n                delete ly.tcScore;\r\n\r\n                ly.tcPosition = ix;\r\n\r\n                self.wrap.normalizeLayerNode(ly);\r\n\r\n                var title = ly.Title.trim();\r\n                var res = re.exec(title);\r\n                var titleIx = res ? res.index : -1;\r\n                var abstractIx = -1;\r\n                if (ly.Abstract) {\r\n                    var abs = ly.Abstract.trim();\r\n                    var res2 = re.exec(abs);\r\n                    abstractIx = res2 ? res2.index : -1;\r\n                }\r\n\r\n                if (res && title == res[0])\r\n                    ly.tcScore = 20;\r\n                else if (titleIx == 0)\r\n                    ly.tcScore = 15;\r\n                else if (titleIx > -1)\r\n                    ly.tcScore = 10;\r\n                else if (abstractIx == 0)\r\n                    ly.tcScore = 5;\r\n                else if (abstractIx > -1)\r\n                    ly.tcScore = 1;\r\n\r\n                if (ly.tcScore)\r\n                    return ly;\r\n                else\r\n                    return null;\r\n            })\r\n                .filter(function (elto) {\r\n                    return elto != null;\r\n                })\r\n                .sort(function (a, b) {\r\n                    if (b.tcScore === a.tcScore) {\r\n                        //si la puntuación es la misma reordenamos por título\r\n                        var titleA = TC.Util.replaceAccent(a.Title);\r\n                        var titleB = TC.Util.replaceAccent(b.Title);\r\n                        if (titleA < titleB) return -1;\r\n                        if (titleA > titleB) return 1;\r\n                        return 0;\r\n                    }\r\n                    else\r\n                        return b.tcScore - a.tcScore;\r\n                });\r\n\r\n            this.lastPattern = text;\r\n            this.lastMatches = matches;\r\n\r\n            return matches;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n\r\n    };\r\n\r\n    var cleanOgcUrl = function (url) {\r\n        var result = url;\r\n        if (url) {\r\n            var match = url.match(/\\??SERVICE=\\w+&/i);\r\n            if (match) {\r\n                result = result.replace(match[0], '');\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getGetMapUrl = function () {\r\n        return cleanOgcUrl(this.wrap.getGetMapUrl());\r\n    };\r\n\r\n    layerProto.getPreferredInfoFormat = function () {\r\n        var layer = this;\r\n        var result = null;\r\n\r\n        var infoFormats = layer.wrap.getInfoFormats();\r\n        if (infoFormats) {\r\n            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {\r\n                var format = TC.wrap.layer.Raster.infoFormatPreference[i];\r\n                if ($.inArray(format, infoFormats) >= 0) {\r\n                    result = format;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Carga la imagen de leyenda de una capa por POST.\r\n     */\r\n    layerProto.getLegendGraphicImage = function () {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta\r\n            if (self.options.params.base64LegendSrc) {\r\n                return resolve(self.options.params.base64LegendSrc);\r\n            }\r\n\r\n            if (typeof window.btoa === 'function') {\r\n                var name = self.names[0];\r\n                var info = self.wrap.getInfo(name);\r\n                var xhr = new XMLHttpRequest();\r\n                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL\r\n                var dataEntries = url[1].split(\"&\"); // Separamos clave/valor de cada parámetro\r\n                var params = self.options.params.sld_body ? \"sld_body=\" + self.options.params.sld_body : '';\r\n\r\n                for (var i = 0; i < dataEntries.length; i++) {\r\n                    var chunks = dataEntries[i].split('=');\r\n\r\n                    if (chunks && chunks.length > 1 && chunks[1]) {\r\n                        params += \"&\" + dataEntries[i];\r\n                    }\r\n                }\r\n                if (self.options.params.env) {\r\n                    params += \"&\" + self.options.params.env;\r\n                }\r\n\r\n                xhr.open('POST', url[0], true);\r\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) {\r\n                    if (this.status === 200) {\r\n                        var uInt8Array = new Uint8Array(this.response);\r\n                        var i = uInt8Array.length;\r\n                        var binaryString = new Array(i);\r\n                        while (i--) {\r\n                            binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n                        }\r\n                        var data = binaryString.join('');\r\n                        var type = xhr.getResponseHeader('content-type');\r\n                        if (type.indexOf('image') === 0) {\r\n                            var imageSrc;\r\n                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);\r\n                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta\r\n                            resolve(imageSrc);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(params);\r\n            } else {\r\n                reject(Error(\"Función window.btoa no soportada por el navegador\"));\r\n            }\r\n        });\r\n    };\r\n\r\n    layerProto.getUrl = function (src) {\r\n        var self = this;\r\n\r\n        return src;\r\n    };\r\n\r\n    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL\r\n    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; \r\n    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.\r\n\r\n    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.\r\n    layerProto.getWebGLUrl = function (src, location) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;\r\n\r\n            if (self.ignoreProxification) {\r\n                resolve(_src);\r\n            } else {\r\n                const options = {\r\n                    exportable: true,\r\n                    ignoreProxification: self.ignoreProxification\r\n                };\r\n\r\n                self.toolProxification.fetchImage(_src, options).then(function () {\r\n                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {\r\n                        if (cache && cache.action) {\r\n                            resolve(cache.action.call(self.toolProxification, _src));\r\n                        }\r\n                    });\r\n                }).catch(function (e) {\r\n                    reject(Error(e));\r\n                });\r\n            }\r\n\r\n            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más\r\n            //if (self.ignoreProxification) {\r\n            //    setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            //    return;\r\n            //}\r\n\r\n            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        \r\n        });\r\n    };\r\n\r\n    layerProto.getFeatureUrl = function (url) {\r\n        var self = this;\r\n\r\n        return self.toolProxification.cacheHost.getAction(url).then(function (cache) {\r\n            return cache.action.call(self.toolProxification, url);\r\n        });\r\n    };\r\n\r\n    // GLS:\r\n    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. \r\n    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.\r\n    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {\r\n        var self = this;\r\n\r\n        if (!self.map) {\r\n            return null;\r\n        } else {\r\n            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));\r\n\r\n            const matchingLayer = layers.filter(function (elem) {\r\n                return (elem.type === TC.Consts.layerType.WMS ||\r\n                    elem.type === TC.Consts.layerType.WMTS) &&\r\n                    (elem.capabilities === self.capabilities || elem.url === self.url) &&\r\n                    (dynamicStatement && $.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);\r\n            })[0];\r\n\r\n            return matchingLayer || null;\r\n        }\r\n    };\r\n\r\n    layerProto.getImageLoad = function (image, src, location) {\r\n        const self = this;\r\n\r\n        // Viene sin nombre desde el control TOC, si es así lo ignoramos.\r\n        if (self.names && self.names.length > 0) {\r\n\r\n            const setSRC = function (data) {\r\n                var olImg = image.getImage();\r\n\r\n                if (!TC.Util.isSameOrigin(data.src)) {\r\n                    if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                        olImg.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : \"anonymous\";\r\n                    }\r\n                }\r\n\r\n                // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.\r\n                olImg.setAttribute(\"src\", data.src);\r\n\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n            };\r\n\r\n            const error = function (error) {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            };\r\n\r\n            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404\r\n            if (self.type === TC.Consts.layerType.WMTS) {\r\n                var z, x, y;\r\n                if (self.encoding != \"KVP\") {\r\n                    var _src = src.replace('.' + self.format.split('/')[1], '');\r\n                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });\r\n                    z = parts[0];\r\n                    x = parts[1];\r\n                    y = parts[2];\r\n                } else {\r\n                    var parts = /.*TileMatrix=(\\d*)&TileCol=(\\d*)&TileRow=(\\d*)/i.exec(src);\r\n                    if (parts && parts.length == 4) {\r\n                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });\r\n                        z = parts[0];\r\n                        x = parts[2];\r\n                        y = parts[1];\r\n                    }\r\n                }\r\n\r\n                if (z && x && y) {\r\n                    var wmtsOptions = self.wrap.getWMTSLayer();\r\n                    if (wmtsOptions) {\r\n                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });\r\n                        if (matrixSet.length > 0) {\r\n\r\n                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {\r\n                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {\r\n                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))\r\n                                        return 1;\r\n                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))\r\n                                        return -1;\r\n                                    else return 0;\r\n                                });\r\n\r\n                                var level = matrixSetLimits[z];\r\n                                if (level && self.map && self.map.on3DView) {\r\n                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {\r\n                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');\r\n                                        setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });\r\n\r\n            var params = \"\";\r\n            var isPOST = self.options.method === \"POST\";\r\n            if (isPOST) {\r\n                var url = src.split('?');\r\n                params = url[1].split(\"&\").filter(function (param) {\r\n                    const values = param.split('=');\r\n                    // eliminamos los valores en blanco y el parámetro layers\r\n                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== \"layers\";\r\n                }).join('&');\r\n\r\n                self.toolProxification.fetchImageAsBlob(url[0], {\r\n                    type: \"POST\",\r\n                    data: params,\r\n                    contentType: \"application/x-www-form-urlencoded\"\r\n                }).then(function (blob) {\r\n                    const imageUrl = URL.createObjectURL(blob);\r\n                    const img = image.getImage();\r\n                    img.onload = function (evt) {\r\n                        URL.revokeObjectURL(imageUrl);\r\n                    };\r\n                    setSRC({ src: imageUrl });\r\n                }).catch(error);\r\n\r\n            } else {\r\n                if (!self.ignoreProxification) {\r\n                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {\r\n                        setSRC(img);\r\n                    }).catch(error);\r\n                } else {\r\n                    setSRC({ src: src });\r\n                    var img = image.getImage();\r\n\r\n                    if (!TC.Util.isSameOrigin(src)) {\r\n                        if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                            img.crossOrigin = \"anonymous\";\r\n                        }\r\n                    }                    \r\n\r\n                    img.onload = function () {\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n                    };\r\n                    img.onerror = function (error) {                        \r\n                        img.src = TC.Consts.BLANK_IMAGE;\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                    };\r\n\r\n                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;\r\n                }\r\n            }\r\n        } else {\r\n            // lanzamos el evento para gestionar el loading\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        }\r\n    };\r\n\r\n    var _get$events = function () {\r\n        const self = this;\r\n        if (self.wrap && self.wrap.$events) {\r\n            return self.wrap.$events;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    layerProto.getWFSCapabilitiesPromise = function () {\r\n        const self = this;\r\n\r\n        if (typeof (WFSCapabilities) === \"undefined\") {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/layer/WFSCapabilitiesParser');\r\n        }\r\n        var url = this.options.url.replace(/service=wms/i, \"service=wfs\").replace(/\\/wms(\\/|\\?|\\b)/i, \"$'/wfs/\")\r\n        var _src = !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(url)) ? self.getBySSL_(url) : url;\r\n        var basicUrl = url.substring(url.indexOf(\"://\") < 0 ? 0 : url.indexOf(\"://\") + 3);\r\n        if (TC.WFScapabilities[basicUrl]) {\r\n            if (TC.WFScapabilities[basicUrl] instanceof Promise)\r\n                return TC.WFScapabilities[basicUrl];\r\n            else\r\n                return new Promise(function (resolve, reject) {\r\n                    setTimeout(function () {\r\n                        resolve(TC.WFScapabilities[basicUrl]);\r\n                    }, 100);\r\n                });\r\n        }\r\n        TC.WFScapabilities[basicUrl] = new Promise(function (resolve, reject) {\r\n            var params = {\r\n            }\r\n            params.SERVICE = 'WFS';\r\n            params.VERSION = '2.0.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n\r\n            var url = self.getUrl(_src + '?' + TC.Util.getParamString(params));\r\n\r\n            self.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {\r\n\r\n                var capabilities\r\n                var xmlDoc;\r\n                const documentElement = data.responseText && (data.responseText.ownerDocument || data.responseText).documentElement;\r\n                const isXMLDoc = documentElement ? documentElement.nodeName !== 'HTML' : false;\r\n                if (isXMLDoc) {\r\n                    xmlDoc = data.responseText;\r\n                }\r\n                else {\r\n                    xmlDoc = (new DOMParser()).parseFromString(data.responseText, 'text/xml');\r\n                }\r\n                //comprueba si el servidor ha devuelto una excepcion\r\n\r\n                var errorNode = xmlDoc.getElementsByTagName('ServiceException')[0];\r\n                if (!errorNode) {\r\n                    errorNode = xmlDoc.getElementsByTagName('ExceptionText')[0];\r\n                }\r\n                if (errorNode) {\r\n                    reject(Error(errorNode.innerHTML));\r\n                    return;\r\n                }\r\n                try {\r\n                    capabilities = WFSCapabilities.Parse(xmlDoc);\r\n                }\r\n                catch (err) {\r\n                    reject(err instanceof Error ? err : Error(err));\r\n                    return;\r\n                }\r\n\r\n                if (!capabilities.Operations) {\r\n                    reject(null);\r\n                    return;\r\n                }\r\n                var _url = (capabilities.Operations.GetCapabilities.DCP && capabilities.Operations.GetCapabilities.DCP.HTTP.Get[\"xlink:href\"]) || capabilities.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource\r\n                TC.WFScapabilities[_url] = capabilities;\r\n                TC.WFScapabilities[basicUrl] = capabilities;\r\n                resolve(capabilities);\r\n            }).catch(function (error) {\r\n                //reject(Error(capabilitiesError(layer, dataError)));\r\n                reject(error instanceof Error ? error : Error(error));\r\n            });\r\n        });\r\n        return TC.WFScapabilities[basicUrl];\r\n    };\r\n\r\n    layerProto.getFallbackLayer = function () {\r\n        const self = this;\r\n        if (self.fallbackLayer instanceof TC.Layer) {\r\n            return self.fallbackLayer;\r\n        }\r\n        if (self.options.fallbackLayer) {\r\n            var fbLayer = self.options.fallbackLayer;\r\n            if (typeof fbLayer === 'string') {\r\n                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n                ablCollection.forEach(function (baseLayer) {\r\n                    if (self.options.fallbackLayer === baseLayer.id) {\r\n                        self.fallbackLayer = new TC.layer.Raster($.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));\r\n                        self.fallbackLayer.firstOption = self;\r\n                    }\r\n                });\r\n            }\r\n            else if (fbLayer instanceof TC.Layer) {\r\n                self.fallbackLayer = fbLayer;\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            else {\r\n                self.fallbackLayer = new TC.layer.Raster($.extend({}, fbLayer, {\r\n                    id: TC.getUID(),\r\n                    isBase: true,\r\n                    stealth: true,\r\n                    title: layer.title,\r\n                    map: self.map\r\n                }));\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            return self.fallbackLayer;\r\n        }\r\n        return null;\r\n    };\r\n})();\r\nvar esriParser = {\r\n    parse: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {};\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result[result.length] = feature;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"],"file":"../../layer/Raster.min.js"}