{"version":3,"sources":["tool/Elevation.js"],"names":["TC","tool","Elevation","options","self","this","_servicePromises","services","forEach","srv","idx","Promise","resolve","reject","ctorName","path","apiLocation","paths","srvOptions","push","substr","toUpperCase","loadJSInOrder","toolProto","prototype","getService","getElevation","undefined","resolution","sampleNumber","onError","msg","type","loadJS","Geometry","all","then","alwaysPromises","Array","length","res","rej","request","response","resps","responses","map","r","parseResponse","filter","numPoints","elevation","reduceFnFactory","prev","cur","arr","point","result","i","fn","reduce","setGeometry","features","conditionToPromises","promises","results","error","maxCoordQuantity","acc","feat","getCoords","pointArray","feature","Polyline","Polygon","MultiPolyline","MultiPolygon","Math","floor","getLength","Error","errors","MAX_COORD_QUANTITY_EXCEEDED","getElevOptions","coords","crs","coordinates","getRingElevPromises","ring","coordPromises","polPromises","polygon","rs","rj","ringPromises","Point","coordsArray","console","log","CLASSNAME","setCoords","UNDEFINED","getElevationGain","uphill","downhill","hillDeltaThreshold","previousHeight","sectorMinHeight","sectorMaxHeight","previousUphill","c","height","min","max","delta","upHill","round","downHill"],"mappings":"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","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nTC.tool.Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        'elevationServiceIDENA',\r\n        //'elevationServiceIGNEs',\r\n        'elevationServiceIGNFr'\r\n    ];\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, reject) {\r\n            var ctorName = 'ElevationService';\r\n            var path = TC.apiLocation + 'TC/tool/ElevationService';\r\n            const paths = [];\r\n            var srvOptions = srv;\r\n            if (typeof srv === 'string') {\r\n                if (!TC.tool[ctorName]) {\r\n                    paths.push(path);\r\n                }\r\n                ctorName = srv.substr(0, 1).toUpperCase() + srv.substr(1);\r\n                path = TC.apiLocation + 'TC/tool/' + ctorName;\r\n                srvOptions = {};\r\n                paths.push(path);\r\n            }\r\n            TC.loadJSInOrder(\r\n                !TC.tool[ctorName],\r\n                paths,\r\n                function () {\r\n                    resolve(new TC.tool[ctorName](srvOptions));\r\n                }\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = TC.tool.Elevation.prototype;\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    toolProto.getElevation = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            const onError = function (msg, type) {\r\n                reject(msg, type);\r\n            };\r\n\r\n            TC.loadJS(\r\n                !TC.Geometry,\r\n                TC.apiLocation + 'TC/Geometry',\r\n                function () {\r\n                    Promise.all(self._servicePromises).then(function (services) {\r\n                        // Creamos un array de promesas que se resuelven falle o no la petici√≥n\r\n                        const alwaysPromises = new Array(services.length);\r\n                        services\r\n                            .forEach(function (srv, idx) {\r\n                                alwaysPromises[idx] = new Promise(function (res, rej) {\r\n                                    srv.request(options).then(\r\n                                        function (response) {\r\n                                            res(response);\r\n                                        },\r\n                                        function () {\r\n                                            res(null);\r\n                                        }\r\n                                    );\r\n                                });\r\n                            });\r\n                        Promise.all(alwaysPromises).then(\r\n                            function (resps) {\r\n                                const responses =\r\n                                    services\r\n                                        .map(function (srv, idx) { // Parseamos las respuestas que haya\r\n                                            const r = resps[idx];\r\n                                            if (!r) {\r\n                                                return null;\r\n                                            }\r\n                                            return srv.parseResponse(r, options);\r\n                                        })\r\n                                        .filter(function (r) { // Eliminamos los servicios sin respuesta\r\n                                            return r !== null;\r\n                                        });\r\n\r\n                                var numPoints = responses.length ? responses[0].length : 0;\r\n                                var elevation = new Array(numPoints);\r\n                                if (numPoints) {\r\n\r\n                                    const reduceFnFactory = function (idx) {\r\n                                        return function (prev, cur, arr) {\r\n                                            const point = cur[idx];\r\n                                            const result = prev;\r\n                                            if (prev[0] === null) {\r\n                                                result[0] = point[0];\r\n                                            }\r\n                                            if (prev[1] === null) {\r\n                                                result[1] = point[1];\r\n                                            }\r\n                                            if (prev[2] === null) {\r\n                                                result[2] = point[2];\r\n                                            }\r\n                                            return result;\r\n                                        };\r\n                                    };\r\n\r\n                                    for (var i = 0; i < numPoints; i++) {\r\n                                        var fn = reduceFnFactory(i);\r\n                                        elevation[i] = responses.reduce(fn, [null, null, null]);\r\n                                    }\r\n                                }\r\n                                resolve(elevation);\r\n                            }, onError\r\n                        );\r\n                    }, onError);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    toolProto.setGeometry = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            return new Promise(function (resolve, reject) {\r\n                if (options.maxCoordQuantity) {\r\n                    if (options.resolution) {\r\n                        // Validador de n√∫mero de coordenadas m√°ximo\r\n                        const numPoints = features.reduce(function (acc, feat) {\r\n                            if (feat) {\r\n                                acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                                switch (true) {\r\n                                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:\r\n                                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:\r\n                                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:\r\n                                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:\r\n                                        acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                        break;\r\n                                    default:\r\n                                        break;\r\n                                }\r\n                            }\r\n                            return acc;\r\n                        }, 0);\r\n                        if (numPoints > options.maxCoordQuantity) {\r\n                            reject(Error(TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED));\r\n                        }\r\n                    }\r\n                }\r\n                const resolution = options.resolution || 0;\r\n                const getElevOptions = function (coords) {\r\n                    return {\r\n                        crs: options.crs,\r\n                        coordinates: coords,\r\n                        resolution: resolution,\r\n                        sampleNumber: 0\r\n                    };\r\n                };\r\n                const getRingElevPromises = function (ring) {\r\n                    return self.getElevation(getElevOptions(ring));\r\n                }\r\n                const coordPromises = features.map(function (feature) {\r\n                    return new Promise(function (res, rej) {\r\n\r\n                        switch (true) {\r\n                            case !feature:\r\n                                res(null);\r\n                                break;\r\n                            case TC.feature && TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:\r\n                                const polPromises = feature\r\n                                    .getCoords()\r\n                                    .map(function (polygon) {\r\n                                        return new Promise(function (rs, rj) {\r\n                                            conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                        });\r\n                                    });\r\n                                conditionToPromises(polPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polygon && feature instanceof TC.feature.Polygon:\r\n                            case TC.feature && TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:\r\n                                const ringPromises = feature\r\n                                    .getCoords()\r\n                                    .map(getRingElevPromises);\r\n                                conditionToPromises(ringPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polyline && feature instanceof TC.feature.Polyline:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            case TC.feature && TC.feature.Point && feature instanceof TC.feature.Point:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords[0]);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            default:\r\n                                rej(Error(\"Geometry not supported\"));\r\n                                break;\r\n                        }\r\n                    });\r\n                });\r\n\r\n                Promise.all(coordPromises).then(\r\n                    function (coordsArray) {\r\n                        coordsArray.forEach(function (coords, idx) {\r\n                            const feat = features[idx];\r\n                            if (feat) {\r\n                                console.log(\"Estableciendo elevaciones a geometr√≠a de tipo \" + feat.CLASSNAME);\r\n                                features[idx].setCoords(coords);\r\n                            }\r\n                        });\r\n                        resolve(features);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n\r\n})();\r\n\r\nTC.tool.Elevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nTC.tool.Elevation.getElevationGain = function (options) {\r\n    options = options || {};\r\n    const coords = options.coords;\r\n    if (coords && coords.length > 0 && coords[0].length > 2) { // si tenemos la Z\r\n        var uphill = 0;\r\n        var downhill = 0;\r\n        const hillDeltaThreshold = options.hillDeltaThreshold || 0;\r\n\r\n        var previousHeight;\r\n        var sectorMinHeight;\r\n        var sectorMaxHeight;\r\n        var previousUphill = true;\r\n\r\n        for (var c = 0; c < coords.length; c++) {\r\n            var point = coords[c];\r\n            var height = point[2];\r\n            if (height !== null) {\r\n                if (previousHeight === undefined) //--inicializar\r\n                {\r\n                    previousHeight = height;\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n\r\n                sectorMinHeight = Math.min(sectorMinHeight, height); //--actualizar m√≠nimo y m√°ximo del sector\r\n                sectorMaxHeight = Math.max(sectorMaxHeight, height);\r\n\r\n                var delta = height - previousHeight; //--calcular desnivel del punto respecto al anterior\r\n                // hillDeltaThreshold: altura de los dientes a despreciar\r\n                if (delta > hillDeltaThreshold || (delta > 0 && c == coords.length - 1)) //--Si se sube m√°s del filtro (o se acaba el segmento subiendo)\r\n                {\r\n                    if (previousUphill) //--Si en el segmento anterior tambi√©n se sub√≠a, incrementamos el desnivel positivo acumulado\r\n                    {\r\n                        uphill += delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se bajaba, incrementamos los desniveles acumulados que no hab√≠amos contabilizado desde el √∫ltimo salto del filtro (sector) \r\n                    {\r\n                        downhill -= sectorMinHeight - previousHeight;\r\n                        uphill += height - sectorMinHeight;\r\n                        previousUphill = true; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n                else if (delta < -hillDeltaThreshold || (delta < 0 && c == coords.length - 1)) //--Si se baja m√°s del filtro (o se acaba el segmento bajando)\r\n                {\r\n                    if (!previousUphill) //--Si en el segmento anterior tambi√©n se bajaba, incrementamos el desnivel negativo acumulado\r\n                    {\r\n                        downhill -= delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se sub√≠a, incrementamos los desniveles acumulados que no hab√≠amos contabilizado desde el √∫ltimo salto del filtro (sector) \r\n                    {\r\n                        uphill += sectorMaxHeight - previousHeight;\r\n                        downhill -= height - sectorMaxHeight;\r\n                        previousUphill = false; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            upHill: Math.round(uphill),\r\n            downHill: Math.round(downhill)\r\n        };\r\n\r\n    } else { return null; }\r\n};\r\n"]}