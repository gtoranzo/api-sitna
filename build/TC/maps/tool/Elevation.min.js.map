{"version":3,"sources":["tool/Elevation.js"],"names":["TC","tool","Elevation","options","self","this","_servicePromises","serviceOptions","services","abstractServicePromise","Promise","resolve","reject","loadJS","ElevationService","apiLocation","forEach","srv","idx","serviceName","name","ctorName","substr","toUpperCase","path","srvOptions","then","toolProto","prototype","getService","mergeResponses","responses","numPoints","length","elevation","Array","reduceFnFactory","prev","cur","arr","point","result","i","fn","reduce","getElevation","undefined","resolution","sampleNumber","partialResult","partialCallback","Util","isFunction","onError","msg","type","Geometry","all","alwaysPromises","res","rej","request","response","parseResponse","filter","r","setGeometry","features","conditionToPromises","promises","results","error","maxCoordQuantity","acc","feat","getCoords","pointArray","feature","Polyline","Polygon","MultiPolyline","MultiPolygon","Math","floor","getLength","Error","errors","MAX_COORD_QUANTITY_EXCEEDED","getElevOptions","coords","crs","coordinates","getRingElevPromises","ring","coordPromises","map","polPromises","polygon","rs","rj","ringPromises","Point","coordsArray","console","log","CLASSNAME","setCoords","UNDEFINED","getElevationGain","uphill","downhill","hillDeltaThreshold","previousHeight","sectorMinHeight","sectorMaxHeight","previousUphill","c","height","min","max","delta","upHill","round","downHill"],"mappings":"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","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nTC.tool.Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        'elevationServiceIDENA',\r\n        //'elevationServiceIGNEs',\r\n        'elevationServiceIGNFr'\r\n    ];\r\n\r\n    const abstractServicePromise = new Promise(function (resolve, reject) {\r\n        TC.loadJS(\r\n            !TC.tool.ElevationService,\r\n            TC.apiLocation + 'TC/tool/ElevationService',\r\n            function () {\r\n                resolve();\r\n            }\r\n        );\r\n    });\r\n\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, reject) {\r\n            const serviceName = (typeof srv === 'string') ? srv : srv.name;\r\n            const ctorName = serviceName.substr(0, 1).toUpperCase() + serviceName.substr(1);\r\n            const path = TC.apiLocation + 'TC/tool/' + ctorName;\r\n            const srvOptions = (typeof srv === 'string') ? {} : srv;\r\n            TC.loadJS(\r\n                !TC.tool[ctorName],\r\n                path,\r\n                function () {\r\n                    abstractServicePromise.then(function () {\r\n                        resolve(new TC.tool[ctorName](srvOptions));\r\n                    });\r\n                }\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = TC.tool.Elevation.prototype;\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    const mergeResponses = function (responses) {\r\n        const numPoints = responses.length ? responses[0].length : 0;\r\n        const elevation = new Array(numPoints);\r\n        if (numPoints) {\r\n\r\n            // Función que aglutina resultados de elevación de los servicios\r\n            const reduceFnFactory = function (idx) {\r\n                return function (prev, cur, arr) {\r\n                    const point = cur[idx];\r\n                    const result = prev;\r\n                    if (prev[0] === null && point) {\r\n                        result[0] = point[0];\r\n                    }\r\n                    if (prev[1] === null && point) {\r\n                        result[1] = point[1];\r\n                    }\r\n                    if (prev[2] === null && point) {\r\n                        result[2] = point[2];\r\n                    }\r\n                    return result;\r\n                };\r\n            };\r\n\r\n            for (var i = 0; i < numPoints; i++) {\r\n                var fn = reduceFnFactory(i);\r\n                elevation[i] = responses.reduce(fn, [null, null, null]);\r\n            }\r\n        }\r\n        return elevation;\r\n    }\r\n\r\n    toolProto.getElevation = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        let partialResult;\r\n        let partialCallback;\r\n        if (TC.Util.isFunction(options.partialCallback)) {\r\n            partialCallback = options.partialCallback;\r\n        }\r\n\r\n        return new Promise(function (resolve, reject) {\r\n            const onError = function (msg, type) {\r\n                reject(msg, type);\r\n            };\r\n\r\n            TC.loadJS(\r\n                !TC.Geometry,\r\n                TC.apiLocation + 'TC/Geometry',\r\n                function () {\r\n                    Promise.all(self._servicePromises).then(function (services) {\r\n                        // Creamos un array de promesas que se resuelven falle o no la petición\r\n                        const alwaysPromises = new Array(services.length);\r\n                        services\r\n                            .forEach(function (srv, idx) {\r\n                                alwaysPromises[idx] = new Promise(function (res, rej) {\r\n                                    srv.request(options).then(\r\n                                        function (response) {\r\n                                            res(srv.parseResponse(response, options));\r\n                                        },\r\n                                        function () {\r\n                                            res(null);\r\n                                        }\r\n                                    );\r\n                                });\r\n                                if (partialCallback) {\r\n                                    alwaysPromises[idx].then(function (response) {\r\n                                        if (response !== null) {\r\n                                            if (partialResult) {\r\n                                                partialResult = mergeResponses([partialResult, response]);\r\n                                            }\r\n                                            else {\r\n                                                partialResult = response;\r\n                                            }\r\n                                            partialCallback(partialResult);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        Promise.all(alwaysPromises).then(\r\n                            function (responses) {\r\n                                // Eliminamos los servicios sin respuesta\r\n                                resolve(mergeResponses(responses.filter(r => r !== null)));\r\n                            },\r\n                            onError\r\n                        );\r\n                    }, onError);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    toolProto.setGeometry = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            return new Promise(function (resolve, reject) {\r\n                if (options.maxCoordQuantity) {\r\n                    if (options.resolution) {\r\n                        // Validador de número de coordenadas máximo\r\n                        const numPoints = features.reduce(function (acc, feat) {\r\n                            if (feat) {\r\n                                acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                                switch (true) {\r\n                                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:\r\n                                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:\r\n                                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:\r\n                                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:\r\n                                        acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                        break;\r\n                                    default:\r\n                                        break;\r\n                                }\r\n                            }\r\n                            return acc;\r\n                        }, 0);\r\n                        if (numPoints > options.maxCoordQuantity) {\r\n                            reject(Error(TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED));\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                const resolution = options.resolution || 0;\r\n                const getElevOptions = function (coords) {\r\n                    return {\r\n                        crs: options.crs,\r\n                        coordinates: coords,\r\n                        resolution: resolution,\r\n                        sampleNumber: 0\r\n                    };\r\n                };\r\n                const getRingElevPromises = function (ring) {\r\n                    return self.getElevation(getElevOptions(ring));\r\n                }\r\n                const coordPromises = features.map(function (feature) {\r\n                    return new Promise(function (res, rej) {\r\n\r\n                        switch (true) {\r\n                            case !feature:\r\n                                res(null);\r\n                                break;\r\n                            case TC.feature && TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:\r\n                                const polPromises = feature\r\n                                    .getCoords()\r\n                                    .map(function (polygon) {\r\n                                        return new Promise(function (rs, rj) {\r\n                                            conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                        });\r\n                                    });\r\n                                conditionToPromises(polPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polygon && feature instanceof TC.feature.Polygon:\r\n                            case TC.feature && TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:\r\n                                const ringPromises = feature\r\n                                    .getCoords()\r\n                                    .map(getRingElevPromises);\r\n                                conditionToPromises(ringPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polyline && feature instanceof TC.feature.Polyline:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            case TC.feature && TC.feature.Point && feature instanceof TC.feature.Point:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords[0]);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            default:\r\n                                rej(Error(\"Geometry not supported\"));\r\n                                break;\r\n                        }\r\n                    });\r\n                });\r\n\r\n                Promise.all(coordPromises).then(\r\n                    function (coordsArray) {\r\n                        coordsArray.forEach(function (coords, idx) {\r\n                            const feat = features[idx];\r\n                            if (feat) {\r\n                                console.log(\"Estableciendo elevaciones a geometría de tipo \" + feat.CLASSNAME);\r\n                                features[idx].setCoords(coords);\r\n                            }\r\n                        });\r\n                        resolve(features);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n\r\n})();\r\n\r\nTC.tool.Elevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nTC.tool.Elevation.getElevationGain = function (options) {\r\n    options = options || {};\r\n    const coords = options.coords;\r\n    if (coords && coords.length > 0 && coords[0].length > 2) { // si tenemos la Z\r\n        var uphill = 0;\r\n        var downhill = 0;\r\n        const hillDeltaThreshold = options.hillDeltaThreshold || 0;\r\n\r\n        var previousHeight;\r\n        var sectorMinHeight;\r\n        var sectorMaxHeight;\r\n        var previousUphill = true;\r\n\r\n        for (var c = 0; c < coords.length; c++) {\r\n            var point = coords[c];\r\n            var height = point[2];\r\n            if (height !== null) {\r\n                if (previousHeight === undefined) //--inicializar\r\n                {\r\n                    previousHeight = height;\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n\r\n                sectorMinHeight = Math.min(sectorMinHeight, height); //--actualizar mínimo y máximo del sector\r\n                sectorMaxHeight = Math.max(sectorMaxHeight, height);\r\n\r\n                var delta = height - previousHeight; //--calcular desnivel del punto respecto al anterior\r\n                // hillDeltaThreshold: altura de los dientes a despreciar\r\n                if (delta > hillDeltaThreshold || (delta > 0 && c == coords.length - 1)) //--Si se sube más del filtro (o se acaba el segmento subiendo)\r\n                {\r\n                    if (previousUphill) //--Si en el segmento anterior también se subía, incrementamos el desnivel positivo acumulado\r\n                    {\r\n                        uphill += delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se bajaba, incrementamos los desniveles acumulados que no habíamos contabilizado desde el último salto del filtro (sector) \r\n                    {\r\n                        downhill -= sectorMinHeight - previousHeight;\r\n                        uphill += height - sectorMinHeight;\r\n                        previousUphill = true; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n                else if (delta < -hillDeltaThreshold || (delta < 0 && c == coords.length - 1)) //--Si se baja más del filtro (o se acaba el segmento bajando)\r\n                {\r\n                    if (!previousUphill) //--Si en el segmento anterior también se bajaba, incrementamos el desnivel negativo acumulado\r\n                    {\r\n                        downhill -= delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se subía, incrementamos los desniveles acumulados que no habíamos contabilizado desde el último salto del filtro (sector) \r\n                    {\r\n                        uphill += sectorMaxHeight - previousHeight;\r\n                        downhill -= height - sectorMaxHeight;\r\n                        previousUphill = false; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            upHill: Math.round(uphill),\r\n            downHill: Math.round(downhill)\r\n        };\r\n\r\n    } else { return null; }\r\n};\r\n"]}