{"version":3,"sources":["tool/Elevation.js"],"names":["TC","tool","Elevation","options","self","this","_servicePromises","services","forEach","srv","idx","Promise","resolve","reject","ctorName","path","apiLocation","srvOptions","substr","toUpperCase","loadJS","toolProto","prototype","getService","getElevation","undefined","resolution","sampleNumber","onError","msg","type","Geometry","all","then","alwaysPromises","Array","length","res","rej","request","response","resps","responses","map","r","parseResponse","filter","numPoints","elevation","reduceFnFactory","prev","cur","arr","point","result","i","fn","reduce","setGeometry","features","conditionToPromises","promises","results","error","maxCoordQuantity","acc","feat","getCoords","pointArray","feature","Polyline","Polygon","MultiPolyline","MultiPolygon","Math","floor","getLength","errors","MAX_COORD_QUANTITY_EXCEEDED","getElevOptions","coords","crs","coordinates","getRingElevPromises","ring","coordPromises","polPromises","polygon","rs","rj","ringPromises","Error","Point","coordsArray","console","log","CLASSNAME","setCoords","UNDEFINED","getElevationGain","uphill","downhill","hillDeltaThreshold","previousHeight","sectorMinHeight","sectorMaxHeight","previousUphill","c","height","min","max","delta","upHill","round","downHill"],"mappings":"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","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nTC.tool.Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        'elevationServiceIDENA',\r\n        //'elevationServiceIGNEs',\r\n        'elevationServiceIGNFr'\r\n    ];\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, reject) {\r\n            var ctorName = 'ElevationService';\r\n            var path = TC.apiLocation + 'TC/tool/ElevationService';\r\n            var srvOptions = srv;\r\n            if (typeof srv === 'string') {\r\n                ctorName = srv.substr(0, 1).toUpperCase() + srv.substr(1);\r\n                path = TC.apiLocation + 'TC/tool/' + ctorName;\r\n                srvOptions = {};\r\n            }\r\n            TC.loadJS(\r\n                !TC.tool[ctorName],\r\n                [path],\r\n                function () {\r\n                    resolve(new TC.tool[ctorName](srvOptions));\r\n                }\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = TC.tool.Elevation.prototype;\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    toolProto.getElevation = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            const onError = function (msg, type) {\r\n                reject(msg, type);\r\n            };\r\n\r\n            TC.loadJS(\r\n                !TC.Geometry,\r\n                TC.apiLocation + 'TC/Geometry',\r\n                function () {\r\n                    Promise.all(self._servicePromises).then(function (services) {\r\n                        // Creamos un array de promesas que se resuelven falle o no la petici√≥n\r\n                        const alwaysPromises = new Array(services.length);\r\n                        services\r\n                            .forEach(function (srv, idx) {\r\n                                alwaysPromises[idx] = new Promise(function (res, rej) {\r\n                                    srv.request(options).then(\r\n                                        function (response) {\r\n                                            res(response);\r\n                                        },\r\n                                        function () {\r\n                                            res(null);\r\n                                        }\r\n                                    );\r\n                                });\r\n                            });\r\n                        Promise.all(alwaysPromises).then(\r\n                            function (resps) {\r\n                                const responses =\r\n                                    services\r\n                                        .map(function (srv, idx) { // Parseamos las respuestas que haya\r\n                                            const r = resps[idx];\r\n                                            if (!r) {\r\n                                                return null;\r\n                                            }\r\n                                            return srv.parseResponse(r, options);\r\n                                        })\r\n                                        .filter(function (r) { // Eliminamos los servicios sin respuesta\r\n                                            return r !== null;\r\n                                        });\r\n\r\n                                var numPoints = responses.length ? responses[0].length : 0;\r\n                                var elevation = new Array(numPoints);\r\n                                if (numPoints) {\r\n\r\n                                    const reduceFnFactory = function (idx) {\r\n                                        return function (prev, cur, arr) {\r\n                                            const point = cur[idx];\r\n                                            const result = prev;\r\n                                            if (prev[0] === null) {\r\n                                                result[0] = point[0];\r\n                                            }\r\n                                            if (prev[1] === null) {\r\n                                                result[1] = point[1];\r\n                                            }\r\n                                            if (prev[2] === null) {\r\n                                                result[2] = point[2];\r\n                                            }\r\n                                            return result;\r\n                                        };\r\n                                    };\r\n\r\n                                    for (var i = 0; i < numPoints; i++) {\r\n                                        var fn = reduceFnFactory(i);\r\n                                        elevation[i] = responses.reduce(fn, [null, null, null]);\r\n                                    }\r\n                                }\r\n                                resolve(elevation);\r\n                            }, onError\r\n                        );\r\n                    }, onError);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    toolProto.setGeometry = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            return new Promise(function (resolve, reject) {\r\n                if (options.maxCoordQuantity) {\r\n                    if (options.resolution) {\r\n                        const getDistance = function (p1, p2) {\r\n                            const dx = p2[0] - p1[0];\r\n                            const dy = p2[1] - p1[1];\r\n                            return Math.sqrt(dx * dx + dy * dy);\r\n                        };\r\n                        // Validador de n√∫mero de coordenadas m√°ximo\r\n                        const numPoints = features.reduce(function (acc, feat) {\r\n                            if (feat) {\r\n                                acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                                switch (true) {\r\n                                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:\r\n                                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:\r\n                                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:\r\n                                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:\r\n                                        acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                        break;\r\n                                    default:\r\n                                        break;\r\n                                }\r\n                            }\r\n                            return acc;\r\n                        }, 0);\r\n                        if (numPoints > options.maxCoordQuantity) {\r\n                            reject(TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED);\r\n                        }\r\n                    }\r\n                }\r\n                const resolution = options.resolution || 0;\r\n                const getElevOptions = function (coords) {\r\n                    return {\r\n                        crs: options.crs,\r\n                        coordinates: coords,\r\n                        resolution: resolution,\r\n                        sampleNumber: 0\r\n                    };\r\n                };\r\n                const getRingElevPromises = function (ring) {\r\n                    return self.getElevation(getElevOptions(ring));\r\n                }\r\n                const coordPromises = features.map(function (feature) {\r\n                    return new Promise(function (res, rej) {\r\n\r\n                        switch (true) {\r\n                            case !feature:\r\n                                res(null);\r\n                                break;\r\n                            case TC.feature && TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:\r\n                                const polPromises = feature\r\n                                    .getCoords()\r\n                                    .map(function (polygon) {\r\n                                        return new Promise(function (rs, rj) {\r\n                                            conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                        });\r\n                                    });\r\n                                conditionToPromises(polPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polygon && feature instanceof TC.feature.Polygon:\r\n                            case TC.feature && TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:\r\n                                const ringPromises = feature\r\n                                    .getCoords()\r\n                                    .map(getRingElevPromises);\r\n                                conditionToPromises(ringPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polyline && feature instanceof TC.feature.Polyline:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            case TC.feature && TC.feature.Point && feature instanceof TC.feature.Point:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords[0]);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            default:\r\n                                rej(Error(\"Geometry not supported\"));\r\n                                break;\r\n                        }\r\n                    });\r\n                });\r\n\r\n                Promise.all(coordPromises).then(\r\n                    function (coordsArray) {\r\n                        coordsArray.forEach(function (coords, idx) {\r\n                            const feat = features[idx];\r\n                            if (feat) {\r\n                                console.log(\"Estableciendo elevaciones a geometr√≠a de tipo \" + feat.CLASSNAME);\r\n                                features[idx].setCoords(coords);\r\n                            }\r\n                        });\r\n                        resolve(features);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n\r\n})();\r\n\r\nTC.tool.Elevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nTC.tool.Elevation.getElevationGain = function (options) {\r\n    options = options || {};\r\n    const coords = options.coords;\r\n    if (coords && coords.length > 0 && coords[0].length > 2) { // si tenemos la Z\r\n        var uphill = 0;\r\n        var downhill = 0;\r\n        const hillDeltaThreshold = options.hillDeltaThreshold || 0;\r\n\r\n        var previousHeight;\r\n        var sectorMinHeight;\r\n        var sectorMaxHeight;\r\n        var previousUphill = true;\r\n\r\n        for (var c = 0; c < coords.length; c++) {\r\n            var point = coords[c];\r\n            var height = point[2];\r\n            if (height !== null) {\r\n                if (previousHeight === undefined) //--inicializar\r\n                {\r\n                    previousHeight = height;\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n\r\n                sectorMinHeight = Math.min(sectorMinHeight, height); //--actualizar m√≠nimo y m√°ximo del sector\r\n                sectorMaxHeight = Math.max(sectorMaxHeight, height);\r\n\r\n                var delta = height - previousHeight; //--calcular desnivel del punto respecto al anterior\r\n                // hillDeltaThreshold: altura de los dientes a despreciar\r\n                if (delta > hillDeltaThreshold || (delta > 0 && c == coords.length - 1)) //--Si se sube m√°s del filtro (o se acaba el segmento subiendo)\r\n                {\r\n                    if (previousUphill) //--Si en el segmento anterior tambi√©n se sub√≠a, incrementamos el desnivel positivo acumulado\r\n                    {\r\n                        uphill += delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se bajaba, incrementamos los desniveles acumulados que no hab√≠amos contabilizado desde el √∫ltimo salto del filtro (sector) \r\n                    {\r\n                        downhill -= sectorMinHeight - previousHeight;\r\n                        uphill += height - sectorMinHeight;\r\n                        previousUphill = true; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n                else if (delta < -hillDeltaThreshold || (delta < 0 && c == coords.length - 1)) //--Si se baja m√°s del filtro (o se acaba el segmento bajando)\r\n                {\r\n                    if (!previousUphill) //--Si en el segmento anterior tambi√©n se bajaba, incrementamos el desnivel negativo acumulado\r\n                    {\r\n                        downhill -= delta;\r\n                    }\r\n                    else //--Si en el segmento anterior se sub√≠a, incrementamos los desniveles acumulados que no hab√≠amos contabilizado desde el √∫ltimo salto del filtro (sector) \r\n                    {\r\n                        uphill += sectorMaxHeight - previousHeight;\r\n                        downhill -= height - sectorMaxHeight;\r\n                        previousUphill = false; //--preparar para el paso siguiente\r\n                    }\r\n                    previousHeight = height; //--preparar para el paso siguiente\r\n                    sectorMinHeight = height;\r\n                    sectorMaxHeight = height;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            upHill: Math.round(uphill),\r\n            downHill: Math.round(downhill)\r\n        };\r\n\r\n    } else { return null; }\r\n};\r\n"],"file":"../../tool/Elevation.min.js"}