{"version":3,"sources":["tool/ElevationServiceIGNFr.js"],"names":["TC","tool","ElevationService","syncLoadJS","apiLocation","ElevationServiceIGNFr","options","apply","this","arguments","url","process","profileProcess","minimumElevation","nativeCRS","inherit","toolProto","prototype","request","self","coordinateListArray","isPolygon","Geometry","isPoint","coordinates","isRing","isRingCollection","crs","CRS","Util","reproject","flatCoordinateListArray","concat","dataInputs","lon","map","coord","join","lat","format","sampleNumber","sampling","resolution","getDistance","p1","p2","dx","dy","Math","sqrt","totalDistance","forEach","coordList","i","arr","prev","reduce","curr","length","call","parseResponse","response","elevations","elev","z"],"mappings":"AAACA,GAAGC,KAAOD,GAAGC,SAETD,GAAGC,KAAKC,kBACTF,GAAGG,WAAWH,GAAGI,YAAc,4BAGnCJ,GAAGC,KAAKI,sBAAwB,SAAUC,GAEtCN,GAAGC,KAAKC,iBAAiBK,MADZC,KACwBC,WADxBD,KAERE,IAFQF,KAEGF,QAAQI,KAAO,iDAFlBF,KAGRG,QAHQH,KAGOF,QAAQK,SAAW,kBAH1BH,KAIRI,eAJQJ,KAIcF,QAAQM,gBAAkB,sBAJxCJ,KAKRK,iBALQL,KAKgBF,QAAQO,mBAAqB,MAL7CL,KAMRM,UAAY,aAGrBd,GAAGe,QAAQf,GAAGC,KAAKI,sBAAuBL,GAAGC,KAAKC,mBAElD,WACI,MAAMc,EAAYhB,GAAGC,KAAKI,sBAAsBY,UAEhDD,EAAUE,QAAU,SAAUZ,GAC1B,MAAMa,EAAOX,KACbF,EAAUA,MACV,IAAIc,EACAC,GAAY,EAChB,QAAQ,GACJ,KAAKrB,GAAGsB,SAASC,QAAQjB,EAAQkB,aAC7BJ,IAAwBd,EAAQkB,cAChC,MACJ,KAAKxB,GAAGsB,SAASG,OAAOnB,EAAQkB,aAC5BJ,GAAuBd,EAAQkB,aAC/B,MACJ,KAAKxB,GAAGsB,SAASI,iBAAiBpB,EAAQkB,aACtCJ,EAAsBd,EAAQkB,YAC9BH,GAAY,EAKhBf,EAAQqB,KAAOrB,EAAQqB,MAAQR,EAAKS,MACpCR,EAAsBpB,GAAG6B,KAAKC,UAAUV,EAAqBd,EAAQqB,IAAKR,EAAKL,YAEnF,MAAMiB,KAA6BC,OAAOzB,SAAUa,GAC9Ca,GACFC,IAAKH,EAAwBI,IAAI,SAAUC,GACvC,OAAOA,EAAM,KACdC,KAAK,KACRC,IAAKP,EAAwBI,IAAI,SAAUC,GACvC,OAAOA,EAAM,KACdC,KAAK,KACRV,IAAK,SACLY,OAAQ,QAEZ,IAAI5B,EAAUQ,EAAKR,QACnB,GAAIL,EAAQkC,aAAc,CACtB7B,EAAUQ,EAAKP,eACfqB,EAAWQ,SAAWnC,EAAQkC,kBAE7B,GAAIlC,EAAQoC,WAAY,CACzB/B,EAAUQ,EAAKP,eACf,MAAM+B,EAAc,SAAUC,EAAIC,GAC9B,MAAMC,EAAKD,EAAG,GAAKD,EAAG,GAChBG,EAAKF,EAAG,GAAKD,EAAG,GACtB,OAAOI,KAAKC,KAAKH,EAAKA,EAAKC,EAAKA,IAEpC,IAAIG,EAAgB,EACpB9B,EAAoB+B,QAAQ,SAAUC,GAClCF,GAAiBE,EACZjB,IAAI,SAAUC,EAAOiB,EAAGC,GACrB,MAAMC,EAAOD,EAAID,EAAI,GACrB,OAAIE,EACOZ,EAAYY,EAAMnB,GAEtB,IAEVoB,OAAO,SAAUD,EAAME,GACpB,OAAOF,EAAOE,GACf,GACHpC,IACA6B,GAAiBP,EAAYS,EAAUA,EAAUM,OAAS,GAAIN,EAAU,OAIhFnB,EAAWQ,SAAWS,EAAgB5C,EAAQoC,WAElD,OAAO1C,GAAGC,KAAKC,iBAAiBe,UAAUC,QAAQyC,KAAKxC,GAAQc,WAAYA,EAAYtB,QAASA,KAGpGK,EAAU4C,cAAgB,SAAUC,EAAUvD,GAE1C,GAAIuD,EAASC,WAAY,CACrB,IAAIA,EAAaD,EAASC,WAAW3B,IAAI,SAAU4B,GAC/C,OAAQA,EAAK7B,IAAK6B,EAAKzB,IAAKyB,EAAKC,KAEjC1D,EAAQqB,KAAOrB,EAAQqB,MALpBnB,KAKiCM,YACpCgD,EAAa9D,GAAG6B,KAAKC,UAAUgC,EAN5BtD,KAM6CM,UAAWR,EAAQqB,MAEvE,OAAO3B,GAAGC,KAAKC,iBAAiBe,UAAU2C,cAAcD,KARjDnD,MAQ8DgB,YAAasC,GAAcxD,GAEpG,UAlFR","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nif (!TC.tool.ElevationService) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/tool/ElevationService');\r\n}\r\n\r\nTC.tool.ElevationServiceIGNFr = function (options) {\r\n    const self = this;\r\n    TC.tool.ElevationService.apply(self, arguments);\r\n    self.url = self.options.url || '//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/alti/wps';\r\n    self.process = self.options.process || 'gs:WPSElevation';\r\n    self.profileProcess = self.options.profileProcess || 'gs:WPSLineElevation';\r\n    self.minimumElevation = self.options.minimumElevation || -99998;\r\n    self.nativeCRS = 'EPSG:4326';\r\n};\r\n\r\nTC.inherit(TC.tool.ElevationServiceIGNFr, TC.tool.ElevationService);\r\n\r\n(function () {\r\n    const toolProto = TC.tool.ElevationServiceIGNFr.prototype;\r\n\r\n    toolProto.request = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var coordinateListArray;\r\n        var isPolygon = false;\r\n        switch (true) {\r\n            case TC.Geometry.isPoint(options.coordinates):\r\n                coordinateListArray = [[options.coordinates]];\r\n                break;\r\n            case TC.Geometry.isRing(options.coordinates):\r\n                coordinateListArray = [options.coordinates];\r\n                break;\r\n            case TC.Geometry.isRingCollection(options.coordinates):\r\n                coordinateListArray = options.coordinates;\r\n                isPolygon = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (options.crs && options.crs !== self.CRS) {\r\n            coordinateListArray = TC.Util.reproject(coordinateListArray, options.crs, self.nativeCRS);\r\n        }\r\n        const flatCoordinateListArray = [].concat.apply([], coordinateListArray);\r\n        const dataInputs = {\r\n            lon: flatCoordinateListArray.map(function (coord) {\r\n                return coord[0];\r\n            }).join('|'),\r\n            lat: flatCoordinateListArray.map(function (coord) {\r\n                return coord[1];\r\n            }).join('|'),\r\n            crs: 'crs:84',\r\n            format: 'json'\r\n        };\r\n        var process = self.process;\r\n        if (options.sampleNumber) {\r\n            process = self.profileProcess;\r\n            dataInputs.sampling = options.sampleNumber;\r\n        }\r\n        else if (options.resolution) {\r\n            process = self.profileProcess;\r\n            const getDistance = function (p1, p2) {\r\n                const dx = p2[0] - p1[0];\r\n                const dy = p2[1] - p1[1];\r\n                return Math.sqrt(dx * dx + dy * dy);\r\n            };\r\n            var totalDistance = 0;\r\n            coordinateListArray.forEach(function (coordList) {\r\n                totalDistance += coordList\r\n                    .map(function (coord, i, arr) {\r\n                        const prev = arr[i - 1];\r\n                        if (prev) {\r\n                            return getDistance(prev, coord);\r\n                        }\r\n                        return 0;\r\n                    })\r\n                    .reduce(function (prev, curr) {\r\n                        return prev + curr;\r\n                    }, 0);\r\n                if (isPolygon) {\r\n                    totalDistance += getDistance(coordList[coordList.length - 1], coordList[0]);\r\n                }\r\n            });\r\n\r\n            dataInputs.sampling = totalDistance / options.resolution;\r\n        }\r\n        return TC.tool.ElevationService.prototype.request.call(self, { dataInputs: dataInputs, process: process });\r\n    };\r\n\r\n    toolProto.parseResponse = function (response, options) {\r\n        var self = this;\r\n        if (response.elevations) {\r\n            var elevations = response.elevations.map(function (elev) {\r\n                return [elev.lon, elev.lat, elev.z];\r\n            });\r\n            if (options.crs && options.crs !== self.nativeCRS) {\r\n                elevations = TC.Util.reproject(elevations, self.nativeCRS, options.crs);\r\n            }\r\n            return TC.tool.ElevationService.prototype.parseResponse.call(self, { coordinates: elevations }, options);\r\n        }\r\n        return [];\r\n    };\r\n})();"],"file":"../../tool/ElevationServiceIGNFr.min.js"}