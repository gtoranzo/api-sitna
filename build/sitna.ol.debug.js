/*! dustjs-linkedin - v2.7.1
* http://dustjs.com/
* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */
(function (root, factory) {
  /*global define*/
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define('dust.core', [], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.dust = factory();
  }
}(this, function() {
  var dust = {
        "version": "2.7.1"
      },
      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',
      EMPTY_FUNC = function() {};

  dust.config = {
    whitespace: false,
    amd: false,
    cjs: false,
    cache: true
  };

  // Directive aliases to minify code
  dust._aliases = {
    "write": "w",
    "end": "e",
    "map": "m",
    "render": "r",
    "reference": "f",
    "section": "s",
    "exists": "x",
    "notexists": "nx",
    "block": "b",
    "partial": "p",
    "helper": "h"
  };

  (function initLogging() {
    /*global process, console*/
    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },
        consoleLog,
        log;

    if (typeof console !== 'undefined' && console.log) {
      consoleLog = console.log;
      if(typeof consoleLog === 'function') {
        log = function() {
          consoleLog.apply(console, arguments);
        };
      } else {
        log = function() {
          consoleLog(Array.prototype.slice.apply(arguments).join(' '));
        };
      }
    } else {
      log = EMPTY_FUNC;
    }

    /**
     * Filters messages based on `dust.debugLevel`.
     * This default implementation will print to the console if it exists.
     * @param {String|Error} message the message to print/throw
     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
     * @public
     */
    dust.log = function(message, type) {
      type = type || INFO;
      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
        log('[DUST:' + type + ']', message);
      }
    };

    dust.debugLevel = NONE;
    if(typeof process !== 'undefined' && process.env && /\bdust\b/.test(process.env.DEBUG)) {
      dust.debugLevel = DEBUG;
    }

  }());

  dust.helpers = {};

  dust.cache = {};

  dust.register = function(name, tmpl) {
    if (!name) {
      return;
    }
    tmpl.templateName = name;
    if (dust.config.cache !== false) {
      dust.cache[name] = tmpl;
    }
  };

  dust.render = function(nameOrTemplate, context, callback) {
    var chunk = new Stub(callback).head;
    try {
      load(nameOrTemplate, chunk, context).end();
    } catch (err) {
      chunk.setError(err);
    }
  };

  dust.stream = function(nameOrTemplate, context) {
    var stream = new Stream(),
        chunk = stream.head;
    dust.nextTick(function() {
      try {
        load(nameOrTemplate, chunk, context).end();
      } catch (err) {
        chunk.setError(err);
      }
    });
    return stream;
  };

  /**
   * Extracts a template function (body_0) from whatever is passed.
   * @param nameOrTemplate {*} Could be:
   *   - the name of a template to load from cache
   *   - a CommonJS-compiled template (a function with a `template` property)
   *   - a template function
   * @param loadFromCache {Boolean} if false, don't look in the cache
   * @return {Function} a template function, if found
   */
  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {
    if(!nameOrTemplate) {
      return;
    }
    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {
      // Sugar away CommonJS module templates
      return nameOrTemplate.template;
    }
    if(dust.isTemplateFn(nameOrTemplate)) {
      // Template functions passed directly
      return nameOrTemplate;
    }
    if(loadFromCache !== false) {
      // Try loading a template with this name from cache
      return dust.cache[nameOrTemplate];
    }
  }

  function load(nameOrTemplate, chunk, context) {
    if(!nameOrTemplate) {
      return chunk.setError(new Error('No template or template name provided to render'));
    }

    var template = getTemplate(nameOrTemplate, dust.config.cache);

    if (template) {
      return template(chunk, Context.wrap(context, template.templateName));
    } else {
      if (dust.onLoad) {
        return chunk.map(function(chunk) {
          // Alias just so it's easier to read that this would always be a name
          var name = nameOrTemplate;
          // Three possible scenarios for a successful callback:
          //   - `require(nameOrTemplate)(dust); cb()`
          //   - `src = readFile('src.dust'); cb(null, src)`
          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`
          function done(err, srcOrTemplate) {
            var template;
            if (err) {
              return chunk.setError(err);
            }
            // Prefer a template that is passed via callback over the cached version.
            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
            if (!template) {
              // It's a template string, compile it and register under `name`
              if(dust.compile) {
                template = dust.loadSource(dust.compile(srcOrTemplate, name));
              } else {
                return chunk.setError(new Error('Dust compiler not available'));
              }
            }
            template(chunk, Context.wrap(context, template.templateName)).end();
          }

          if(dust.onLoad.length === 3) {
            dust.onLoad(name, context.options, done);
          } else {
            dust.onLoad(name, done);
          }
        });
      }
      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));
    }
  }

  dust.loadSource = function(source) {
    /*jshint evil:true*/
    return eval(source);
  };

  if (Array.isArray) {
    dust.isArray = Array.isArray;
  } else {
    dust.isArray = function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
  }

  dust.nextTick = (function() {
    return function(callback) {
      setTimeout(callback, 0);
    };
  })();

  /**
   * Dust has its own rules for what is "empty"-- which is not the same as falsy.
   * Empty arrays, null, and undefined are empty
   */
  dust.isEmpty = function(value) {
    if (value === 0) {
      return false;
    }
    if (dust.isArray(value) && !value.length) {
      return true;
    }
    return !value;
  };

  dust.isEmptyObject = function(obj) {
    var key;
    if (obj === null) {
      return false;
    }
    if (obj === undefined) {
      return false;
    }
    if (obj.length > 0) {
      return false;
    }
    for (key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  dust.isTemplateFn = function(elem) {
    return typeof elem === 'function' &&
           elem.__dustBody;
  };

  /**
   * Decide somewhat-naively if something is a Thenable.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Thenable?
   */
  dust.isThenable = function(elem) {
    return elem &&
           typeof elem === 'object' &&
           typeof elem.then === 'function';
  };

  /**
   * Decide very naively if something is a Stream.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Stream?
   */
  dust.isStreamable = function(elem) {
    return elem &&
           typeof elem.on === 'function';
  };

  // apply the filter chain and return the output string
  dust.filter = function(string, auto, filters) {
    var i, len, name;
    if (filters) {
      for (i = 0, len = filters.length; i < len; i++) {
        name = filters[i];
        if (name === 's') {
          auto = null;
        }
        else if (typeof dust.filters[name] === 'function') {
          string = dust.filters[name](string);
        }
        else {
          dust.log('Invalid filter `' + name + '`', WARN);
        }
      }
    }
    // by default always apply the h filter, unless asked to unescape with |s
    if (auto) {
      string = dust.filters[auto](string);
    }
    return string;
  };

  dust.filters = {
    h: function(value) { return dust.escapeHtml(value); },
    j: function(value) { return dust.escapeJs(value); },
    u: encodeURI,
    uc: encodeURIComponent,
    js: function(value) { return dust.escapeJSON(value); },
    jp: function(value) {
      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);
        return value;
      } else {
        return JSON.parse(value);
      }
    }
  };

  function Context(stack, global, options, blocks, templateName) {
    if(stack !== undefined && !(stack instanceof Stack)) {
      stack = new Stack(stack);
    }
    this.stack = stack;
    this.global = global;
    this.options = options;
    this.blocks = blocks;
    this.templateName = templateName;
  }

  dust.makeBase = dust.context = function(global, options) {
    return new Context(undefined, global, options);
  };

  /**
   * Factory function that creates a closure scope around a Thenable-callback.
   * Returns a function that can be passed to a Thenable that will resume a
   * Context lookup once the Thenable resolves with new data, adding that new
   * data to the lookup stack.
   */
  function getWithResolvedData(ctx, cur, down) {
    return function(data) {
      return ctx.push(data)._get(cur, down);
    };
  }

  Context.wrap = function(context, name) {
    if (context instanceof Context) {
      return context;
    }
    return new Context(context, {}, {}, null, name);
  };

  /**
   * Public API for getting a value from the context.
   * @method get
   * @param {string|array} path The path to the value. Supported formats are:
   * 'key'
   * 'path.to.key'
   * '.path.to.key'
   * ['path', 'to', 'key']
   * ['key']
   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
   * current context (true), or if get should search in parent contexts as well (false).
   * @public
   * @returns {string|object}
   */
  Context.prototype.get = function(path, cur) {
    if (typeof path === 'string') {
      if (path[0] === '.') {
        cur = true;
        path = path.substr(1);
      }
      path = path.split('.');
    }
    return this._get(cur, path);
  };

  /**
   * Get a value from the context
   * @method _get
   * @param {boolean} cur Get only from the current context
   * @param {array} down An array of each step in the path
   * @private
   * @return {string | object}
   */
  Context.prototype._get = function(cur, down) {
    var ctx = this.stack || {},
        i = 1,
        value, first, len, ctxThis, fn;

    first = down[0];
    len = down.length;

    if (cur && len === 0) {
      ctxThis = ctx;
      ctx = ctx.head;
    } else {
      if (!cur) {
        // Search up the stack for the first value
        while (ctx) {
          if (ctx.isObject) {
            ctxThis = ctx.head;
            value = ctx.head[first];
            if (value !== undefined) {
              break;
            }
          }
          ctx = ctx.tail;
        }

        // Try looking in the global context if we haven't found anything yet
        if (value !== undefined) {
          ctx = value;
        } else {
          ctx = this.global && this.global[first];
        }
      } else if (ctx) {
        // if scope is limited by a leading dot, don't search up the tree
        if(ctx.head) {
          ctx = ctx.head[first];
        } else {
          // context's head is empty, value we are searching for is not defined
          ctx = undefined;
        }
      }

      while (ctx && i < len) {
        if (dust.isThenable(ctx)) {
          // Bail early by returning a Thenable for the remainder of the search tree
          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
        }
        ctxThis = ctx;
        ctx = ctx[down[i]];
        i++;
      }
    }

    if (typeof ctx === 'function') {
      fn = function() {
        try {
          return ctx.apply(ctxThis, arguments);
        } catch (err) {
          dust.log(err, ERROR);
          throw err;
        }
      };
      fn.__dustBody = !!ctx.__dustBody;
      return fn;
    } else {
      if (ctx === undefined) {
        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);
      }
      return ctx;
    }
  };

  Context.prototype.getPath = function(cur, down) {
    return this._get(cur, down);
  };

  Context.prototype.push = function(head, idx, len) {
    if(head === undefined) {
      dust.log("Not pushing an undefined variable onto the context", INFO);
      return this;
    }
    return this.rebase(new Stack(head, this.stack, idx, len));
  };

  Context.prototype.pop = function() {
    var head = this.current();
    this.stack = this.stack && this.stack.tail;
    return head;
  };

  Context.prototype.rebase = function(head) {
    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
  };

  Context.prototype.clone = function() {
    var context = this.rebase();
    context.stack = this.stack;
    return context;
  };

  Context.prototype.current = function() {
    return this.stack && this.stack.head;
  };

  Context.prototype.getBlock = function(key) {
    var blocks, len, fn;

    if (typeof key === 'function') {
      key = key(new Chunk(), this).data.join('');
    }

    blocks = this.blocks;

    if (!blocks) {
      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);
      return false;
    }

    len = blocks.length;
    while (len--) {
      fn = blocks[len][key];
      if (fn) {
        return fn;
      }
    }

    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');
    return false;
  };

  Context.prototype.shiftBlocks = function(locals) {
    var blocks = this.blocks,
        newBlocks;

    if (locals) {
      if (!blocks) {
        newBlocks = [locals];
      } else {
        newBlocks = blocks.concat([locals]);
      }
      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
    }
    return this;
  };

  Context.prototype.resolve = function(body) {
    var chunk;

    if(typeof body !== 'function') {
      return body;
    }
    chunk = new Chunk().render(body, this);
    if(chunk instanceof Chunk) {
      return chunk.data.join(''); // ie7 perf
    }
    return chunk;
  };

  Context.prototype.getTemplateName = function() {
    return this.templateName;
  };

  function Stack(head, tail, idx, len) {
    this.tail = tail;
    this.isObject = head && typeof head === 'object';
    this.head = head;
    this.index = idx;
    this.of = len;
  }

  function Stub(callback) {
    this.head = new Chunk(this);
    this.callback = callback;
    this.out = '';
  }

  Stub.prototype.flush = function() {
    var chunk = this.head;

    while (chunk) {
      if (chunk.flushable) {
        this.out += chunk.data.join(''); //ie7 perf
      } else if (chunk.error) {
        this.callback(chunk.error);
        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.callback(null, this.out);
  };

  /**
   * Creates an interface sort of like a Streams2 ReadableStream.
   */
  function Stream() {
    this.head = new Chunk(this);
  }

  Stream.prototype.flush = function() {
    var chunk = this.head;

    while(chunk) {
      if (chunk.flushable) {
        this.emit('data', chunk.data.join('')); //ie7 perf
      } else if (chunk.error) {
        this.emit('error', chunk.error);
        this.emit('end');
        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.emit('end');
  };

  /**
   * Executes listeners for `type` by passing data. Note that this is different from a
   * Node stream, which can pass an arbitrary number of arguments
   * @return `true` if event had listeners, `false` otherwise
   */
  Stream.prototype.emit = function(type, data) {
    var events = this.events || {},
        handlers = events[type] || [],
        i, l;

    if (!handlers.length) {
      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);
      return false;
    }

    handlers = handlers.slice(0);
    for (i = 0, l = handlers.length; i < l; i++) {
      handlers[i](data);
    }
    return true;
  };

  Stream.prototype.on = function(type, callback) {
    var events = this.events = this.events || {},
        handlers = events[type] = events[type] || [];

    if(typeof callback !== 'function') {
      dust.log('No callback function provided for `' + type + '` event listener', WARN);
    } else {
      handlers.push(callback);
    }
    return this;
  };

  /**
   * Pipes to a WritableStream. Note that backpressure isn't implemented,
   * so we just write as fast as we can.
   * @param stream {WritableStream}
   * @return self
   */
  Stream.prototype.pipe = function(stream) {
    if(typeof stream.write !== 'function' ||
       typeof stream.end !== 'function') {
      dust.log('Incompatible stream passed to `pipe`', WARN);
      return this;
    }

    var destEnded = false;

    if(typeof stream.emit === 'function') {
      stream.emit('pipe', this);
    }

    if(typeof stream.on === 'function') {
      stream.on('error', function() {
        destEnded = true;
      });
    }

    return this
    .on('data', function(data) {
      if(destEnded) {
        return;
      }
      try {
        stream.write(data, 'utf8');
      } catch (err) {
        dust.log(err, ERROR);
      }
    })
    .on('end', function() {
      if(destEnded) {
        return;
      }
      try {
        stream.end();
        destEnded = true;
      } catch (err) {
        dust.log(err, ERROR);
      }
    });
  };

  function Chunk(root, next, taps) {
    this.root = root;
    this.next = next;
    this.data = []; //ie7 perf
    this.flushable = false;
    this.taps = taps;
  }

  Chunk.prototype.write = function(data) {
    var taps = this.taps;

    if (taps) {
      data = taps.go(data);
    }
    this.data.push(data);
    return this;
  };

  Chunk.prototype.end = function(data) {
    if (data) {
      this.write(data);
    }
    this.flushable = true;
    this.root.flush();
    return this;
  };

  Chunk.prototype.map = function(callback) {
    var cursor = new Chunk(this.root, this.next, this.taps),
        branch = new Chunk(this.root, cursor, this.taps);

    this.next = branch;
    this.flushable = true;
    try {
      callback(branch);
    } catch(err) {
      dust.log(err, ERROR);
      branch.setError(err);
    }
    return cursor;
  };

  Chunk.prototype.tap = function(tap) {
    var taps = this.taps;

    if (taps) {
      this.taps = taps.push(tap);
    } else {
      this.taps = new Tap(tap);
    }
    return this;
  };

  Chunk.prototype.untap = function() {
    this.taps = this.taps.tail;
    return this;
  };

  Chunk.prototype.render = function(body, context) {
    return body(this, context);
  };

  Chunk.prototype.reference = function(elem, context, auto, filters) {
    if (typeof elem === 'function') {
      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
      if (elem instanceof Chunk) {
        return elem;
      } else {
        return this.reference(elem, context, auto, filters);
      }
    }
    if (dust.isThenable(elem)) {
      return this.await(elem, context, null, auto, filters);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, null, auto, filters);
    } else if (!dust.isEmpty(elem)) {
      return this.write(dust.filter(elem, auto, filters));
    } else {
      return this;
    }
  };

  Chunk.prototype.section = function(elem, context, bodies, params) {
    var body = bodies.block,
        skip = bodies['else'],
        chunk = this,
        i, len, head;

    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {
      try {
        elem = elem.apply(context.current(), [this, context, bodies, params]);
      } catch(err) {
        dust.log(err, ERROR);
        return this.setError(err);
      }
      // Functions that return chunks are assumed to have handled the chunk manually.
      // Make that chunk the current one and go to the next method in the chain.
      if (elem instanceof Chunk) {
        return elem;
      }
    }

    if (!dust.isEmptyObject(params)) {
      context = context.push(params);
    }

    /*
    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
    When elem resolves to a value or object instead of an array, Dust sets the current context to the value
    and renders the block one time.
    */
    if (dust.isArray(elem)) {
      if (body) {
        len = elem.length;
        if (len > 0) {
          head = context.stack && context.stack.head || {};
          head.$len = len;
          for (i = 0; i < len; i++) {
            head.$idx = i;
            chunk = body(chunk, context.push(elem[i], i, len));
          }
          head.$idx = undefined;
          head.$len = undefined;
          return chunk;
        } else if (skip) {
          return skip(this, context);
        }
      }
    } else if (dust.isThenable(elem)) {
      return this.await(elem, context, bodies);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, bodies);
    } else if (elem === true) {
     // true is truthy but does not change context
      if (body) {
        return body(this, context);
      }
    } else if (elem || elem === 0) {
       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
       // zero is truthy
       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
      if (body) {
        return body(this, context.push(elem));
      }
     // nonexistent, scalar false value, scalar empty string, null,
     // undefined are all falsy
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);
    return this;
  };

  Chunk.prototype.exists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (!dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.notexists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.block = function(elem, context, bodies) {
    var body = elem || bodies.block;

    if (body) {
      return body(this, context);
    }
    return this;
  };

  Chunk.prototype.partial = function(elem, context, partialContext, params) {
    var head;

    if(params === undefined) {
      // Compatibility for < 2.7.0 where `partialContext` did not exist
      params = partialContext;
      partialContext = context;
    }

    if (!dust.isEmptyObject(params)) {
      partialContext = partialContext.clone();
      head = partialContext.pop();
      partialContext = partialContext.push(params)
                                     .push(head);
    }

    if (dust.isTemplateFn(elem)) {
      // The eventual result of evaluating `elem` is a partial name
      // Load the partial after getting its name and end the async chunk
      return this.capture(elem, context, function(name, chunk) {
        partialContext.templateName = name;
        load(name, chunk, partialContext).end();
      });
    } else {
      partialContext.templateName = elem;
      return load(elem, this, partialContext);
    }
  };

  Chunk.prototype.helper = function(name, context, bodies, params) {
    var chunk = this,
        ret;
    // handle invalid helpers, similar to invalid filters
    if(dust.helpers[name]) {
      try {
        ret = dust.helpers[name](chunk, context, bodies, params);
        if (dust.isThenable(ret)) {
          return this.await(ret, context, bodies);
        }
        return ret;
      } catch(err) {
        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);
        return chunk.setError(err);
      }
    } else {
      dust.log('Helper `' + name + '` does not exist', WARN);
      return chunk;
    }
  };

  /**
   * Reserve a chunk to be evaluated once a thenable is resolved or rejected
   * @param thenable {Thenable} the target thenable to await
   * @param context {Context} context to use to render the deferred chunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      thenable.then(function(data) {
        if(body) {
          chunk.render(body, context.push(data)).end();
        } else {
          chunk.reference(data, context, auto, filters).end();
        }
      }, function(err) {
        if(errorBody) {
          chunk.render(errorBody, context.push(err)).end();
        } else {
          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`');
          chunk.end();
        }
      });
    });
  };

  /**
   * Reserve a chunk to be evaluated with the contents of a streamable.
   * Currently an error event will bomb out the stream. Once an error
   * is received, we push it to an {:error} block if one exists, and log otherwise,
   * then stop listening to the stream.
   * @param streamable {Streamable} the target streamable that will emit events
   * @param context {Context} context to use to render each thunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      var ended = false;
      stream
        .on('data', function data(thunk) {
          if(ended) {
            return;
          }
          if(body) {
            // Fork a new chunk out of the blockstream so that we can flush it independently
            chunk = chunk.map(function(chunk) {
              chunk.render(body, context.push(thunk)).end();
            });
          } else {
            // Don't fork, just write into the master async chunk
            chunk = chunk.reference(thunk, context, auto, filters);
          }
        })
        .on('error', function error(err) {
          if(ended) {
            return;
          }
          if(errorBody) {
            chunk.render(errorBody, context.push(err));
          } else {
            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`');
          }
          if(!ended) {
            ended = true;
            chunk.end();
          }
        })
        .on('end', function end() {
          if(!ended) {
            ended = true;
            chunk.end();
          }
        });
    });
  };

  Chunk.prototype.capture = function(body, context, callback) {
    return this.map(function(chunk) {
      var stub = new Stub(function(err, out) {
        if (err) {
          chunk.setError(err);
        } else {
          callback(out, chunk);
        }
      });
      body(stub.head, context).end();
    });
  };

  Chunk.prototype.setError = function(err) {
    this.error = err;
    this.root.flush();
    return this;
  };

  // Chunk aliases
  for(var f in Chunk.prototype) {
    if(dust._aliases[f]) {
      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
    }
  }

  function Tap(head, tail) {
    this.head = head;
    this.tail = tail;
  }

  Tap.prototype.push = function(tap) {
    return new Tap(tap, this);
  };

  Tap.prototype.go = function(value) {
    var tap = this;

    while(tap) {
      value = tap.head(value);
      tap = tap.tail;
    }
    return value;
  };

  var HCHARS = /[&<>"']/,
      AMP    = /&/g,
      LT     = /</g,
      GT     = />/g,
      QUOT   = /\"/g,
      SQUOT  = /\'/g;

  dust.escapeHtml = function(s) {
    if (typeof s === "string" || (s && typeof s.toString === "function")) {
      if (typeof s !== "string") {
        s = s.toString();
      }
      if (!HCHARS.test(s)) {
        return s;
      }
      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
    }
    return s;
  };

  var BS = /\\/g,
      FS = /\//g,
      CR = /\r/g,
      LS = /\u2028/g,
      PS = /\u2029/g,
      NL = /\n/g,
      LF = /\f/g,
      SQ = /'/g,
      DQ = /"/g,
      TB = /\t/g;

  dust.escapeJs = function(s) {
    if (typeof s === 'string') {
      return s
        .replace(BS, '\\\\')
        .replace(FS, '\\/')
        .replace(DQ, '\\"')
        .replace(SQ, '\\\'')
        .replace(CR, '\\r')
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(NL, '\\n')
        .replace(LF, '\\f')
        .replace(TB, '\\t');
    }
    return s;
  };

  dust.escapeJSON = function(o) {
    if (!JSON) {
      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);
      return o;
    } else {
      return JSON.stringify(o)
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(LT, '\\u003c');
    }
  };

  return dust;

}));

(function(root, factory) {
  if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define("dust.parse", ["dust.core"], function(dust) {
      return factory(dust).parse;
    });
  } else if (typeof exports === 'object') {
    // in Node, require this file if we want to use the parser as a standalone module
    module.exports = factory(require('./dust'));
    // @see server file for parser methods exposed in node
  } else {
    // in the browser, store the factory output if we want to use the parser directly
    factory(root.dust);
  }
}(this, function(dust) {
  var parser = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(p) {
            var body = ["body"].concat(p);
            return withPosition(body);
          },
        peg$c2 = { type: "other", description: "section" },
        peg$c3 = peg$FAILED,
        peg$c4 = null,
        peg$c5 = function(t, b, e, n) {
            if( (!n) || (t[1].text !== n.text) ) {
              error("Expected end tag for "+t[1].text+" but it was not found.");
            }
            return true;
          },
        peg$c6 = void 0,
        peg$c7 = function(t, b, e, n) {
            e.push(["param", ["literal", "block"], b]);
            t.push(e);
            return withPosition(t)
          },
        peg$c8 = "/",
        peg$c9 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c10 = function(t) {
            t.push(["bodies"]);
            return withPosition(t)
          },
        peg$c11 = /^[#?\^<+@%]/,
        peg$c12 = { type: "class", value: "[#?\\^<+@%]", description: "[#?\\^<+@%]" },
        peg$c13 = function(t, n, c, p) { return [t, n, c, p] },
        peg$c14 = { type: "other", description: "end tag" },
        peg$c15 = function(n) { return n },
        peg$c16 = ":",
        peg$c17 = { type: "literal", value: ":", description: "\":\"" },
        peg$c18 = function(n) {return n},
        peg$c19 = function(n) { return n ? ["context", n] : ["context"] },
        peg$c20 = { type: "other", description: "params" },
        peg$c21 = "=",
        peg$c22 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c23 = function(k, v) {return ["param", ["literal", k], v]},
        peg$c24 = function(p) { return ["params"].concat(p) },
        peg$c25 = { type: "other", description: "bodies" },
        peg$c26 = function(p) { return ["bodies"].concat(p) },
        peg$c27 = { type: "other", description: "reference" },
        peg$c28 = function(n, f) { return withPosition(["reference", n, f]) },
        peg$c29 = { type: "other", description: "partial" },
        peg$c30 = ">",
        peg$c31 = { type: "literal", value: ">", description: "\">\"" },
        peg$c32 = "+",
        peg$c33 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c34 = function(k) {return ["literal", k]},
        peg$c35 = function(s, n, c, p) {
            var key = (s === ">") ? "partial" : s;
            return withPosition([key, n, c, p])
          },
        peg$c36 = { type: "other", description: "filters" },
        peg$c37 = "|",
        peg$c38 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c39 = function(f) { return ["filters"].concat(f) },
        peg$c40 = { type: "other", description: "special" },
        peg$c41 = "~",
        peg$c42 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c43 = function(k) { return withPosition(["special", k]) },
        peg$c44 = { type: "other", description: "identifier" },
        peg$c45 = function(p) {
            var arr = ["path"].concat(p);
            arr.text = p[1].join('.').replace(/,line,\d+,col,\d+/g,'');
            return arr;
          },
        peg$c46 = function(k) {
            var arr = ["key", k];
            arr.text = k;
            return arr;
          },
        peg$c47 = { type: "other", description: "number" },
        peg$c48 = function(n) { return ['literal', n]; },
        peg$c49 = { type: "other", description: "float" },
        peg$c50 = ".",
        peg$c51 = { type: "literal", value: ".", description: "\".\"" },
        peg$c52 = function(l, r) { return parseFloat(l + "." + r); },
        peg$c53 = { type: "other", description: "unsigned_integer" },
        peg$c54 = /^[0-9]/,
        peg$c55 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c56 = function(digits) { return makeInteger(digits); },
        peg$c57 = { type: "other", description: "signed_integer" },
        peg$c58 = "-",
        peg$c59 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c60 = function(sign, n) { return n * -1; },
        peg$c61 = { type: "other", description: "integer" },
        peg$c62 = { type: "other", description: "path" },
        peg$c63 = function(k, d) {
            d = d[0];
            if (k && d) {
              d.unshift(k);
              return withPosition([false, d])
            }
            return withPosition([true, d])
          },
        peg$c64 = function(d) {
            if (d.length > 0) {
              return withPosition([true, d[0]])
            }
            return withPosition([true, []])
          },
        peg$c65 = { type: "other", description: "key" },
        peg$c66 = /^[a-zA-Z_$]/,
        peg$c67 = { type: "class", value: "[a-zA-Z_$]", description: "[a-zA-Z_$]" },
        peg$c68 = /^[0-9a-zA-Z_$\-]/,
        peg$c69 = { type: "class", value: "[0-9a-zA-Z_$\\-]", description: "[0-9a-zA-Z_$\\-]" },
        peg$c70 = function(h, t) { return h + t.join('') },
        peg$c71 = { type: "other", description: "array" },
        peg$c72 = function(n) {return n.join('')},
        peg$c73 = function(a) {return a; },
        peg$c74 = function(i, nk) { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; },
        peg$c75 = { type: "other", description: "array_part" },
        peg$c76 = function(k) {return k},
        peg$c77 = function(d, a) { if (a) { return d.concat(a); } else { return d; } },
        peg$c78 = { type: "other", description: "inline" },
        peg$c79 = "\"",
        peg$c80 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c81 = function() { return withPosition(["literal", ""]) },
        peg$c82 = function(l) { return withPosition(["literal", l]) },
        peg$c83 = function(p) { return withPosition(["body"].concat(p)) },
        peg$c84 = function(l) { return ["buffer", l] },
        peg$c85 = { type: "other", description: "buffer" },
        peg$c86 = function(e, w) { return withPosition(["format", e, w.join('')]) },
        peg$c87 = { type: "any", description: "any character" },
        peg$c88 = function(c) {return c},
        peg$c89 = function(b) { return withPosition(["buffer", b.join('')]) },
        peg$c90 = { type: "other", description: "literal" },
        peg$c91 = /^[^"]/,
        peg$c92 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c93 = function(b) { return b.join('') },
        peg$c94 = "\\\"",
        peg$c95 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c96 = function() { return '"' },
        peg$c97 = { type: "other", description: "raw" },
        peg$c98 = "{`",
        peg$c99 = { type: "literal", value: "{`", description: "\"{`\"" },
        peg$c100 = "`}",
        peg$c101 = { type: "literal", value: "`}", description: "\"`}\"" },
        peg$c102 = function(char) {return char},
        peg$c103 = function(rawText) { return withPosition(["raw", rawText.join('')]) },
        peg$c104 = { type: "other", description: "comment" },
        peg$c105 = "{!",
        peg$c106 = { type: "literal", value: "{!", description: "\"{!\"" },
        peg$c107 = "!}",
        peg$c108 = { type: "literal", value: "!}", description: "\"!}\"" },
        peg$c109 = function(c) { return withPosition(["comment", c.join('')]) },
        peg$c110 = /^[#?\^><+%:@\/~%]/,
        peg$c111 = { type: "class", value: "[#?\\^><+%:@\\/~%]", description: "[#?\\^><+%:@\\/~%]" },
        peg$c112 = "{",
        peg$c113 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c114 = "}",
        peg$c115 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c116 = "[",
        peg$c117 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c118 = "]",
        peg$c119 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c120 = "\n",
        peg$c121 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c122 = "\r\n",
        peg$c123 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c124 = "\r",
        peg$c125 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c126 = "\u2028",
        peg$c127 = { type: "literal", value: "\u2028", description: "\"\\u2028\"" },
        peg$c128 = "\u2029",
        peg$c129 = { type: "literal", value: "\u2029", description: "\"\\u2029\"" },
        peg$c130 = /^[\t\x0B\f \xA0\uFEFF]/,
        peg$c131 = { type: "class", value: "[\\t\\x0B\\f \\xA0\\uFEFF]", description: "[\\t\\x0B\\f \\xA0\\uFEFF]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsebody();

      return s0;
    }

    function peg$parsebody() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsepart();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsepart();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsepart() {
      var s0;

      s0 = peg$parseraw();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesection();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepartial();
            if (s0 === peg$FAILED) {
              s0 = peg$parsespecial();
              if (s0 === peg$FAILED) {
                s0 = peg$parsereference();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsebuffer();
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesection() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsesec_tag_start();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parserd();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsebody();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsebodies();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseend_tag();
                if (s6 === peg$FAILED) {
                  s6 = peg$c4;
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = peg$currPos;
                  s7 = peg$c5(s1, s4, s5, s6);
                  if (s7) {
                    s7 = peg$c6;
                  } else {
                    s7 = peg$c3;
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c7(s1, s4, s5, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsesec_tag_start();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsews();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsews();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c8;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c9); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parserd();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c10(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }

      return s0;
    }

    function peg$parsesec_tag_start() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecontext();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparams();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c13(s2, s4, s5, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }

      return s0;
    }

    function peg$parseend_tag() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c8;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c9); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsews();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsews();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parserd();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }

      return s0;
    }

    function peg$parsecontext() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c16;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseidentifier();
        if (s3 !== peg$FAILED) {
          peg$reportedPos = s1;
          s2 = peg$c18(s3);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c3;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c3;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c19(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseparams() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$parsews();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsews();
        }
      } else {
        s3 = peg$c3;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s5 = peg$c21;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parsenumber();
            if (s6 === peg$FAILED) {
              s6 = peg$parseidentifier();
              if (s6 === peg$FAILED) {
                s6 = peg$parseinline();
              }
            }
            if (s6 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c23(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsews();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
        } else {
          s3 = peg$c3;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsekey();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c21;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c22); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsenumber();
              if (s6 === peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 === peg$FAILED) {
                  s6 = peg$parseinline();
                }
              }
              if (s6 !== peg$FAILED) {
                peg$reportedPos = s2;
                s3 = peg$c23(s4, s6);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c24(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }

      return s0;
    }

    function peg$parsebodies() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parseld();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s4 = peg$c16;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c17); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsekey();
          if (s5 !== peg$FAILED) {
            s6 = peg$parserd();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsebody();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s2;
                s3 = peg$c23(s5, s7);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parseld();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c16;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsekey();
            if (s5 !== peg$FAILED) {
              s6 = peg$parserd();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebody();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c23(s5, s7);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }

      return s0;
    }

    function peg$parsereference() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefilters();
          if (s3 !== peg$FAILED) {
            s4 = peg$parserd();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c28(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }

      return s0;
    }

    function peg$parsepartial() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s2 = peg$c30;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s2 = peg$c32;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c33); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parsekey();
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s4;
              s5 = peg$c34(s5);
            }
            s4 = s5;
            if (s4 === peg$FAILED) {
              s4 = peg$parseinline();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecontext();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparams();
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsews();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsews();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parserd();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c35(s2, s4, s5, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c3;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c3;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }

      return s0;
    }

    function peg$parsefilters() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s3 = peg$c37;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c18(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 124) {
          s3 = peg$c37;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsekey();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s2;
            s3 = peg$c18(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }

      return s0;
    }

    function peg$parsespecial() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 126) {
          s2 = peg$c41;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsekey();
          if (s3 !== peg$FAILED) {
            s4 = peg$parserd();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsepath();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c45(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c46(s1);
        }
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsefloat();
      if (s1 === peg$FAILED) {
        s1 = peg$parseinteger();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c48(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }

      return s0;
    }

    function peg$parsefloat() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseinteger();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c50;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseunsigned_integer();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c52(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }

      return s0;
    }

    function peg$parseunsigned_integer() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c56(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }

      return s0;
    }

    function peg$parsesigned_integer() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c58;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseunsigned_integer();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c60(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$parsesigned_integer();
      if (s0 === peg$FAILED) {
        s0 = peg$parseunsigned_integer();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }

      return s0;
    }

    function peg$parsepath() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsekey();
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsearray_part();
        if (s3 === peg$FAILED) {
          s3 = peg$parsearray();
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_part();
            if (s3 === peg$FAILED) {
              s3 = peg$parsearray();
            }
          }
        } else {
          s2 = peg$c3;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c63(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c50;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_part();
          if (s3 === peg$FAILED) {
            s3 = peg$parsearray();
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_part();
            if (s3 === peg$FAILED) {
              s3 = peg$parsearray();
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }

      return s0;
    }

    function peg$parsekey() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$c66.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c68.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c69); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c70(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsearray() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parselb();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        if (peg$c54.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c54.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c55); }
            }
          }
        } else {
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s3;
          s4 = peg$c72(s4);
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          s3 = peg$parseidentifier();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parserb();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s1;
            s2 = peg$c73(s3);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c3;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c3;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearray_part();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }

      return s0;
    }

    function peg$parsearray_part() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c50;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c76(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c50;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekey();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c76(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearray();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c77(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }

      return s0;
    }

    function peg$parseinline() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c79;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c79;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c80); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c79;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c80); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseliteral();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c79;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c80); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c82(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c79;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseinline_part();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseinline_part();
              }
            } else {
              s2 = peg$c3;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c79;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c80); }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c83(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }

      return s0;
    }

    function peg$parseinline_part() {
      var s0, s1;

      s0 = peg$parsespecial();
      if (s0 === peg$FAILED) {
        s0 = peg$parsereference();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseliteral();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c84(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsebuffer() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseeol();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c86(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsetag();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseraw();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parsecomment();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = peg$c6;
            } else {
              peg$currPos = s5;
              s5 = peg$c3;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseeol();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = peg$c6;
              } else {
                peg$currPos = s6;
                s6 = peg$c3;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c87); }
                }
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c88(s7);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parsetag();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c6;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseraw();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c6;
              } else {
                peg$currPos = s4;
                s4 = peg$c3;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$currPos;
                peg$silentFails++;
                s6 = peg$parsecomment();
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = peg$c6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c3;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parseeol();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = peg$c6;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c87); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s2;
                      s3 = peg$c88(s7);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c3;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c3;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          }
        } else {
          s1 = peg$c3;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c89(s1);
        }
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }

      return s0;
    }

    function peg$parseliteral() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parsetag();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = peg$c6;
      } else {
        peg$currPos = s3;
        s3 = peg$c3;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseesc();
        if (s4 === peg$FAILED) {
          if (peg$c91.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c92); }
          }
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c88(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parsetag();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = peg$c6;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseesc();
            if (s4 === peg$FAILED) {
              if (peg$c91.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c92); }
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c88(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c93(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }

      return s0;
    }

    function peg$parseesc() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c94) {
        s1 = peg$c94;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c96();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseraw() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c98) {
        s1 = peg$c98;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c99); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c100) {
          s5 = peg$c100;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c6;
        } else {
          peg$currPos = s4;
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c102(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s5 = peg$c100;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c102(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s3 = peg$c100;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c103(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c105) {
        s1 = peg$c105;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c107) {
          s5 = peg$c107;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c108); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c6;
        } else {
          peg$currPos = s4;
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c88(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c107) {
            s5 = peg$c107;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c108); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c88(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c107) {
            s3 = peg$c107;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c108); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c109(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }

      return s0;
    }

    function peg$parsetag() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          if (peg$c110.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c111); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsews();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsews();
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parserd();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = peg$c6;
              } else {
                peg$currPos = s7;
                s7 = peg$c3;
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$parseeol();
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = peg$c6;
                } else {
                  peg$currPos = s8;
                  s8 = peg$c3;
                }
                if (s8 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c87); }
                  }
                  if (s9 !== peg$FAILED) {
                    s7 = [s7, s8, s9];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c3;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c3;
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$parserd();
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = peg$c6;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$c3;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$parseeol();
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = peg$c6;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$c3;
                    }
                    if (s8 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s9 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c87); }
                      }
                      if (s9 !== peg$FAILED) {
                        s7 = [s7, s8, s9];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c3;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c3;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                }
              } else {
                s5 = peg$c3;
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsews();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsews();
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parserd();
                  if (s7 !== peg$FAILED) {
                    s1 = [s1, s2, s3, s4, s5, s6, s7];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsereference();
      }

      return s0;
    }

    function peg$parseld() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 123) {
        s0 = peg$c112;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }

      return s0;
    }

    function peg$parserd() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 125) {
        s0 = peg$c114;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c115); }
      }

      return s0;
    }

    function peg$parselb() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 91) {
        s0 = peg$c116;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c117); }
      }

      return s0;
    }

    function peg$parserb() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 93) {
        s0 = peg$c118;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c119); }
      }

      return s0;
    }

    function peg$parseeol() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c120;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c122) {
          s0 = peg$c122;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c123); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c124;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c125); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c126;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c127); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c128;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c129); }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsews() {
      var s0;

      if (peg$c130.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c131); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseeol();
      }

      return s0;
    }


      function makeInteger(arr) {
        return parseInt(arr.join(''), 10);
      }
      function withPosition(arr) {
        return arr.concat([['line', line()], ['col', column()]]);
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

  // expose parser methods
  dust.parse = parser.parse;

  return parser;
}));

(function(root, factory) {
  if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define("dust.compile", ["dust.core", "dust.parse"], function(dust, parse) {
      return factory(parse, dust).compile;
    });
  } else if (typeof exports === 'object') {
    // in Node, require this file if we want to use the compiler as a standalone module
    module.exports = factory(require('./parser').parse, require('./dust'));
  } else {
    // in the browser, store the factory output if we want to use the compiler directly
    factory(root.dust.parse, root.dust);
  }
}(this, function(parse, dust) {
  var compiler = {},
      isArray = dust.isArray;


  compiler.compile = function(source, name) {
    // the name parameter is optional.
    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or
    // for templates that are compiled as a callable (compileFn)
    //
    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.

    try {
      var ast = filterAST(parse(source));
      return compile(ast, name);
    }
    catch (err)
    {
      if (!err.line || !err.column) {
        throw err;
      }
      throw new SyntaxError(err.message + ' At line : ' + err.line + ', column : ' + err.column);
    }
  };

  function filterAST(ast) {
    var context = {};
    return compiler.filterNode(context, ast);
  }

  compiler.filterNode = function(context, node) {
    return compiler.optimizers[node[0]](context, node);
  };

  compiler.optimizers = {
    body:      compactBuffers,
    buffer:    noop,
    special:   convertSpecial,
    format:    format,
    reference: visit,
    '#':       visit,
    '?':       visit,
    '^':       visit,
    '<':       visit,
    '+':       visit,
    '@':       visit,
    '%':       visit,
    partial:   visit,
    context:   visit,
    params:    visit,
    bodies:    visit,
    param:     visit,
    filters:   noop,
    key:       noop,
    path:      noop,
    literal:   noop,
    raw:       noop,
    comment:   nullify,
    line:      nullify,
    col:       nullify
  };

  compiler.pragmas = {
    esc: function(compiler, context, bodies) {
      var old = compiler.auto,
          out;
      if (!context) {
        context = 'h';
      }
      compiler.auto = (context === 's') ? '' : context;
      out = compileParts(compiler, bodies.block);
      compiler.auto = old;
      return out;
    }
  };

  function visit(context, node) {
    var out = [node[0]],
        i, len, res;
    for (i=1, len=node.length; i<len; i++) {
      res = compiler.filterNode(context, node[i]);
      if (res) {
        out.push(res);
      }
    }
    return out;
  }

  // Compacts consecutive buffer nodes into a single node
  function compactBuffers(context, node) {
    var out = [node[0]],
        memo, i, len, res;
    for (i=1, len=node.length; i<len; i++) {
      res = compiler.filterNode(context, node[i]);
      if (res) {
        if (res[0] === 'buffer' || res[0] === 'format') {
          if (memo) {
            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];
            memo[1] += res.slice(1, -2).join('');
          } else {
            memo = res;
            out.push(res);
          }
        } else {
          memo = null;
          out.push(res);
        }
      }
    }
    return out;
  }

  var specialChars = {
    's': ' ',
    'n': '\n',
    'r': '\r',
    'lb': '{',
    'rb': '}'
  };

  function convertSpecial(context, node) {
    return ['buffer', specialChars[node[1]], node[2], node[3]];
  }

  function noop(context, node) {
    return node;
  }

  function nullify(){}

  function format(context, node) {
    if(dust.config.whitespace) {
      // Format nodes are in the form ['format', eol, whitespace, line, col],
      // which is unlike other nodes in that there are two pieces of content
      // Join eol and whitespace together to normalize the node format
      node.splice(1, 2, node.slice(1, -2).join(''));
      return node;
    }
    return null;
  }

  function compile(ast, name) {
    var context = {
      name: name,
      bodies: [],
      blocks: {},
      index: 0,
      auto: 'h'
    },
    escapedName = dust.escapeJs(name),
    AMDName = name? '"' + escapedName + '",' : '',
    compiled = 'function(dust){',
    entry = compiler.compileNode(context, ast),
    iife;

    if(name) {
      compiled += 'dust.register("' + escapedName + '",' + entry + ');';
    }

    compiled += compileBlocks(context) +
                compileBodies(context) +
                'return ' + entry + '}';

    iife = '(' + compiled + '(dust));';

    if(dust.config.amd) {
      return 'define(' + AMDName + '["dust.core"],' + compiled + ');';
    } else if(dust.config.cjs) {
      return 'module.exports=function(dust){' +
             'var tmpl=' + iife +
             'var f=' + loaderFor().toString() + ';' +
             'f.template=tmpl;return f}';
    } else {
      return iife;
    }
  }

  function compileBlocks(context) {
    var out = [],
        blocks = context.blocks,
        name;

    for (name in blocks) {
      out.push('"' + name + '":' + blocks[name]);
    }
    if (out.length) {
      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';
      return 'var blocks={' + out.join(',') + '};';
    } else {
      context.blocks = '';
    }
    return context.blocks;
  }

  function compileBodies(context) {
    var out = [],
        bodies = context.bodies,
        blx = context.blocks,
        i, len;

    for (i=0, len=bodies.length; i<len; i++) {
      out[i] = 'function body_' + i + '(chk,ctx){' +
          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';
    }
    return out.join('');
  }

  function compileParts(context, body) {
    var parts = '',
        i, len;
    for (i=1, len=body.length; i<len; i++) {
      parts += compiler.compileNode(context, body[i]);
    }
    return parts;
  }

  compiler.compileNode = function(context, node) {
    return compiler.nodes[node[0]](context, node);
  };

  compiler.nodes = {
    body: function(context, node) {
      var id = context.index++,
          name = 'body_' + id;
      context.bodies[id] = compileParts(context, node);
      return name;
    },

    buffer: function(context, node) {
      return '.w(' + escape(node[1]) + ')';
    },

    format: function(context, node) {
      return '.w(' + escape(node[1]) + ')';
    },

    reference: function(context, node) {
      return '.f(' + compiler.compileNode(context, node[1]) +
        ',ctx,' + compiler.compileNode(context, node[2]) + ')';
    },

    '#': function(context, node) {
      return compileSection(context, node, 'section');
    },

    '?': function(context, node) {
      return compileSection(context, node, 'exists');
    },

    '^': function(context, node) {
      return compileSection(context, node, 'notexists');
    },

    '<': function(context, node) {
      var bodies = node[4];
      for (var i=1, len=bodies.length; i<len; i++) {
        var param = bodies[i],
            type = param[1][1];
        if (type === 'block') {
          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);
          return '';
        }
      }
      return '';
    },

    '+': function(context, node) {
      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){
        return '.b(ctx.getBlock(' +
              compiler.compileNode(context, node[1]) +
              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +
              compiler.compileNode(context, node[3]) +
              ')';
      } else {
        return '.b(ctx.getBlock(' +
            escape(node[1].text) +
            '),' + compiler.compileNode(context, node[2]) + ',' +
            compiler.compileNode(context, node[4]) + ',' +
            compiler.compileNode(context, node[3]) +
            ')';
      }
    },

    '@': function(context, node) {
      return '.h(' +
        escape(node[1].text) +
        ',' + compiler.compileNode(context, node[2]) + ',' +
        compiler.compileNode(context, node[4]) + ',' +
        compiler.compileNode(context, node[3]) +
        ')';
    },

    '%': function(context, node) {
      // TODO: Move these hacks into pragma precompiler
      var name = node[1][1],
          rawBodies,
          bodies,
          rawParams,
          params,
          ctx, b, p, i, len;
      if (!compiler.pragmas[name]) {
        return '';
      }

      rawBodies = node[4];
      bodies = {};
      for (i=1, len=rawBodies.length; i<len; i++) {
        b = rawBodies[i];
        bodies[b[1][1]] = b[2];
      }

      rawParams = node[3];
      params = {};
      for (i=1, len=rawParams.length; i<len; i++) {
        p = rawParams[i];
        params[p[1][1]] = p[2][1];
      }

      ctx = node[2][1] ? node[2][1].text : null;

      return compiler.pragmas[name](context, ctx, bodies, params);
    },

    partial: function(context, node) {
      return '.p(' +
          compiler.compileNode(context, node[1]) +
          ',ctx,' + compiler.compileNode(context, node[2]) +
          ',' + compiler.compileNode(context, node[3]) + ')';
    },

    context: function(context, node) {
      if (node[1]) {
        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';
      }
      return 'ctx';
    },

    params: function(context, node) {
      var out = [];
      for (var i=1, len=node.length; i<len; i++) {
        out.push(compiler.compileNode(context, node[i]));
      }
      if (out.length) {
        return '{' + out.join(',') + '}';
      }
      return '{}';
    },

    bodies: function(context, node) {
      var out = [];
      for (var i=1, len=node.length; i<len; i++) {
        out.push(compiler.compileNode(context, node[i]));
      }
      return '{' + out.join(',') + '}';
    },

    param: function(context, node) {
      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);
    },

    filters: function(context, node) {
      var list = [];
      for (var i=1, len=node.length; i<len; i++) {
        var filter = node[i];
        list.push('"' + filter + '"');
      }
      return '"' + context.auto + '"' +
        (list.length ? ',[' + list.join(',') + ']' : '');
    },

    key: function(context, node) {
      return 'ctx.get(["' + node[1] + '"], false)';
    },

    path: function(context, node) {
      var current = node[1],
          keys = node[2],
          list = [];

      for (var i=0,len=keys.length; i<len; i++) {
        if (isArray(keys[i])) {
          list.push(compiler.compileNode(context, keys[i]));
        } else {
          list.push('"' + keys[i] + '"');
        }
      }
      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';
    },

    literal: function(context, node) {
      return escape(node[1]);
    },
    raw: function(context, node) {
      return ".w(" + escape(node[1]) + ")";
    }
  };

  function compileSection(context, node, cmd) {
    return '.' + (dust._aliases[cmd] || cmd) + '(' +
      compiler.compileNode(context, node[1]) +
      ',' + compiler.compileNode(context, node[2]) + ',' +
      compiler.compileNode(context, node[4]) + ',' +
      compiler.compileNode(context, node[3]) +
      ')';
  }

  var BS = /\\/g,
      DQ = /"/g,
      LF = /\f/g,
      NL = /\n/g,
      CR = /\r/g,
      TB = /\t/g;
  function escapeToJsSafeString(str) {
    return str.replace(BS, '\\\\')
              .replace(DQ, '\\"')
              .replace(LF, '\\f')
              .replace(NL, '\\n')
              .replace(CR, '\\r')
              .replace(TB, '\\t');
  }

  var escape = (typeof JSON === 'undefined') ?
                  function(str) { return '"' + escapeToJsSafeString(str) + '"';} :
                  JSON.stringify;

  function renderSource(source, context, callback) {
    var tmpl = dust.loadSource(dust.compile(source));
    return loaderFor(tmpl)(context, callback);
  }

  function compileFn(source, name) {
    var tmpl = dust.loadSource(dust.compile(source, name));
    return loaderFor(tmpl);
  }

  function loaderFor(tmpl) {
    return function load(ctx, cb) {
      var fn = cb ? 'render' : 'stream';
      return dust[fn](tmpl, ctx, cb);
    };
  }

  // expose compiler methods
  dust.compiler = compiler;
  dust.compile = dust.compiler.compile;
  dust.renderSource = renderSource;
  dust.compileFn = compileFn;

  // DEPRECATED legacy names. Removed in 2.8.0
  dust.filterNode = compiler.filterNode;
  dust.optimizers = compiler.optimizers;
  dust.pragmas = compiler.pragmas;
  dust.compileNode = compiler.compileNode;
  dust.nodes = compiler.nodes;

  return compiler;

}));

if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define(["require", "dust.core", "dust.compile"], function(require, dust) {
        dust.onLoad = function(name, cb) {
            require([name], function() {
                cb();
            });
        };
        return dust;
    });
}

/*! dustjs-helpers - v1.7.3
* http://dustjs.com/
* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */
(function (root, factory) {
    if (typeof define === 'function' && define.amd && define.amd.dust === true) {
        define(['dust.core'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('dustjs-linkedin'));
    } else {
        factory(root.dust);
    }
}(this, function (dust) {

    function log(helper, msg, level) {
        level = level || "INFO";
        helper = helper ? '{@' + helper + '}: ' : '';
        dust.log(helper + msg, level);
    }

    var _deprecatedCache = {};
    function _deprecated(target) {
        if (_deprecatedCache[target]) { return; }
        log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
        log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
        _deprecatedCache[target] = true;
    }

    function isSelect(context) {
        return context.stack.tail &&
               context.stack.tail.head &&
               typeof context.stack.tail.head.__select__ !== "undefined";
    }

    function getSelectState(context) {
        return isSelect(context) && context.get('__select__');
    }

    /**
     * Adds a special __select__ key behind the head of the context stack. Used to maintain the state
     * of {@select} blocks
     * @param context {Context} add state to this Context
     * @param opts {Object} add these properties to the state (`key` and `type`)
     */
    function addSelectState(context, opts) {
        var head = context.stack.head,
            newContext = context.rebase(),
            key;

        if (context.stack && context.stack.tail) {
            newContext.stack = context.stack.tail;
        }

        var state = {
            isPending: false,
            isResolved: false,
            isDeferredComplete: false,
            deferreds: []
        };

        for (key in opts) {
            state[key] = opts[key];
        }

        return newContext
        .push({ "__select__": state })
        .push(head, context.stack.index, context.stack.of);
    }

    /**
     * After a {@select} or {@math} block is complete, they invoke this function
     */
    function resolveSelectDeferreds(state) {
        var x, len;
        state.isDeferredPending = true;
        if (state.deferreds.length) {
            state.isDeferredComplete = true;
            for (x = 0, len = state.deferreds.length; x < len; x++) {
                state.deferreds[x]();
            }
        }
        state.isDeferredPending = false;
    }

    /**
     * Used by {@contextDump}
     */
    function jsonFilter(key, value) {
        if (typeof value === "function") {
            return value.toString()
              .replace(/(^\s+|\s+$)/mg, '')
              .replace(/\n/mg, '')
              .replace(/,\s*/mg, ', ')
              .replace(/\)\{/mg, ') {');
        }
        return value;
    }

    /**
     * Generate a truth test helper
     */
    function truthTest(name, test) {
        return function (chunk, context, bodies, params) {
            return filter(chunk, context, bodies, params, name, test);
        };
    }

    /**
     * This function is invoked by truth test helpers
     */
    function filter(chunk, context, bodies, params, helperName, test) {
        var body = bodies.block,
            skip = bodies['else'],
            selectState = getSelectState(context) || {},
            willResolve, key, value, type;

        // Once one truth test in a select passes, short-circuit the rest of the tests
        if (selectState.isResolved && !selectState.isDeferredPending) {
            return chunk;
        }

        // First check for a key on the helper itself, then look for a key on the {@select}
        if (params.hasOwnProperty('key')) {
            key = params.key;
        } else if (selectState.hasOwnProperty('key')) {
            key = selectState.key;
        } else {
            log(helperName, "No key specified", "WARN");
            return chunk;
        }

        type = params.type || selectState.type;

        key = coerce(context.resolve(key), type);
        value = coerce(context.resolve(params.value), type);

        if (test(key, value)) {
            // Once a truth test passes, put the select into "pending" state. Now we can render the body of
            // the truth test (which may contain truth tests) without altering the state of the select.
            if (!selectState.isPending) {
                willResolve = true;
                selectState.isPending = true;
            }
            if (body) {
                chunk = chunk.render(body, context);
            }
            if (willResolve) {
                selectState.isResolved = true;
            }
        } else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    }

    function coerce(value, type) {
        if (type) {
            type = type.toLowerCase();
        }
        switch (type) {
            case 'number': return +value;
            case 'string': return String(value);
            case 'boolean':
                value = (value === 'false' ? false : value);
                return Boolean(value);
            case 'date': return new Date(value);
        }

        return value;
    }

    var helpers = {

        // Utility helping to resolve dust references in the given chunk
        // uses native Dust Context#resolve (available since Dust 2.6.2)
        "tap": function (input, chunk, context) {
            // deprecated for removal in 1.8
            _deprecated("tap");
            return context.resolve(input);
        },

        "sep": function (chunk, context, bodies) {
            var body = bodies.block;
            if (context.stack.index === context.stack.of - 1) {
                return chunk;
            }
            if (body) {
                return body(chunk, context);
            } else {
                return chunk;
            }
        },

        "first": function (chunk, context, bodies) {
            if (context.stack.index === 0) {
                return bodies.block(chunk, context);
            }
            return chunk;
        },

        "last": function (chunk, context, bodies) {
            if (context.stack.index === context.stack.of - 1) {
                return bodies.block(chunk, context);
            }
            return chunk;
        },

        /**
         * {@contextDump}
         * @param key {String} set to "full" to the full context stack, otherwise the current context is dumped
         * @param to {String} set to "console" to log to console, otherwise outputs to the chunk
         */
        "contextDump": function (chunk, context, bodies, params) {
            var to = context.resolve(params.to),
                key = context.resolve(params.key),
                target, output;
            switch (key) {
                case 'full':
                    target = context.stack;
                    break;
                default:
                    target = context.stack.head;
            }
            output = JSON.stringify(target, jsonFilter, 2);
            switch (to) {
                case 'console':
                    log('contextDump', output);
                    break;
                default:
                    output = output.replace(/</g, '\\u003c');
                    chunk = chunk.write(output);
            }
            return chunk;
        },

        /**
         * {@math}
         * @param key first value
         * @param method {String} operation to perform
         * @param operand second value (not required for operations like `abs`)
         * @param round if truthy, round() the result
         */
        "math": function (chunk, context, bodies, params) {
            var key = params.key,
                method = params.method,
                operand = params.operand,
                round = params.round,
                output, state, x, len;

            if (!params.hasOwnProperty('key') || !params.method) {
                log("math", "`key` or `method` was not provided", "ERROR");
                return chunk;
            }

            key = parseFloat(context.resolve(key));
            operand = parseFloat(context.resolve(operand));

            switch (method) {
                case "mod":
                    if (operand === 0) {
                        log("math", "Division by 0", "ERROR");
                    }
                    output = key % operand;
                    break;
                case "add":
                    output = key + operand;
                    break;
                case "subtract":
                    output = key - operand;
                    break;
                case "multiply":
                    output = key * operand;
                    break;
                case "divide":
                    if (operand === 0) {
                        log("math", "Division by 0", "ERROR");
                    }
                    output = key / operand;
                    break;
                case "ceil":
                case "floor":
                case "round":
                case "abs":
                    output = Math[method](key);
                    break;
                case "toint":
                    output = parseInt(key, 10);
                    break;
                default:
                    log("math", "Method `" + method + "` is not supported", "ERROR");
            }

            if (typeof output !== 'undefined') {
                if (round) {
                    output = Math.round(output);
                }
                if (bodies && bodies.block) {
                    context = addSelectState(context, { key: output });
                    chunk = chunk.render(bodies.block, context);
                    resolveSelectDeferreds(getSelectState(context));
                } else {
                    chunk = chunk.write(output);
                }
            }

            return chunk;
        },

        /**
         * {@select}
         * Groups a set of truth tests and outputs the first one that passes.
         * Also contains {@any} and {@none} blocks.
         * @param key a value or reference to use as the left-hand side of comparisons
         * @param type coerce all truth test keys without an explicit type to this type
         */
        "select": function (chunk, context, bodies, params) {
            var body = bodies.block,
                state = {};

            if (params.hasOwnProperty('key')) {
                state.key = context.resolve(params.key);
            }
            if (params.hasOwnProperty('type')) {
                state.type = params.type;
            }

            if (body) {
                context = addSelectState(context, state);
                chunk = chunk.render(body, context);
                resolveSelectDeferreds(getSelectState(context));
            } else {
                log("select", "Missing body block", "WARN");
            }
            return chunk;
        },

        /**
         * Truth test helpers
         * @param key a value or reference to use as the left-hand side of comparisons
         * @param value a value or reference to use as the right-hand side of comparisons
         * @param type if specified, `key` and `value` will be forcibly cast to this type
         */
        "eq": truthTest('eq', function (left, right) {
            return left === right;
        }),
        "ne": truthTest('ne', function (left, right) {
            return left !== right;
        }),
        "lt": truthTest('lt', function (left, right) {
            return left < right;
        }),
        "lte": truthTest('lte', function (left, right) {
            return left <= right;
        }),
        "gt": truthTest('gt', function (left, right) {
            return left > right;
        }),
        "gte": truthTest('gte', function (left, right) {
            return left >= right;
        }),

        /**
         * {@any}
         * Outputs as long as at least one truth test inside a {@select} has passed.
         * Must be contained inside a {@select} block.
         * The passing truth test can be before or after the {@any} block.
         */
        "any": function (chunk, context, bodies, params) {
            var selectState = getSelectState(context);

            if (!selectState) {
                log("any", "Must be used inside a {@select} block", "ERROR");
            } else {
                if (selectState.isDeferredComplete) {
                    log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
                } else {
                    chunk = chunk.map(function (chunk) {
                        selectState.deferreds.push(function () {
                            if (selectState.isResolved) {
                                chunk = chunk.render(bodies.block, context);
                            }
                            chunk.end();
                        });
                    });
                }
            }
            return chunk;
        },

        /**
         * {@none}
         * Outputs if no truth tests inside a {@select} pass.
         * Must be contained inside a {@select} block.
         * The position of the helper does not matter.
         */
        "none": function (chunk, context, bodies, params) {
            var selectState = getSelectState(context);

            if (!selectState) {
                log("none", "Must be used inside a {@select} block", "ERROR");
            } else {
                if (selectState.isDeferredComplete) {
                    log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
                } else {
                    chunk = chunk.map(function (chunk) {
                        selectState.deferreds.push(function () {
                            if (!selectState.isResolved) {
                                chunk = chunk.render(bodies.block, context);
                            }
                            chunk.end();
                        });
                    });
                }
            }
            return chunk;
        },

        /**
        * {@size}
        * Write the size of the target to the chunk
        * Falsy values and true have size 0
        * Numbers are returned as-is
        * Arrays and Strings have size equal to their length
        * Objects have size equal to the number of keys they contain
        * Dust bodies are evaluated and the length of the string is returned
        * Functions are evaluated and the length of their return value is evaluated
        * @param key find the size of this value or reference
        */
        "size": function (chunk, context, bodies, params) {
            var key = params.key,
                value, k;

            key = context.resolve(params.key);
            if (!key || key === true) {
                value = 0;
            } else if (dust.isArray(key)) {
                value = key.length;
            } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
                value = key;
            } else if (typeof key === "object") {
                value = 0;
                for (k in key) {
                    if (key.hasOwnProperty(k)) {
                        value++;
                    }
                }
            } else {
                value = (key + '').length;
            }
            return chunk.write(value);
        }

    };

    for (var key in helpers) {
        dust.helpers[key] = helpers[key];
    }

    return dust;

}));
/*! dustjs-i18n - v0.0.2 - 2015-03-31
* https://bitbucket.org/manolakis/dustjs-i18n
* Copyright (c) 2015 Manuel Martin; Licensed MIT */
(function (root, factory) { /* istanbul ignore if  */
	if (typeof define === "function" && define.amd) {
		// AMD. Register as an anonymous module.
		define(["dustjs-linkedin"], function (dust) {
			return factory(dust, root);
		}); /* istanbul ignore else */
	} else if (typeof module === "object" && module.exports) {
		// Node, or CommonJS-Like environments
		module.exports = factory(require("dustjs-linkedin"), this);
	} else {
		// Browser globals
		root.dust = factory(root.dust, root);
	}
}(this, function (dust, global, undefined) {
	'use strict';

		/* Utility functions */
	var toString = Object.prototype.toString,
		_console = (typeof console !== undefined) ? console : {
			log: function(){ /* a noop */}
		},
		_ = {
			isArray : Array.isArray || function(obj) {
				return toString.call(obj) === '[object Array]';
			},
			isAvailable : function(language) {
				return i18nLanguages[language] !== undefined;
			},
			log: _console.log
		},
		i18nContext = {
			selected: undefined,
			languages: {},
			filters: {}
		},
		i18nLanguages = i18nContext.languages;

	// set String trim if undefined
	if (typeof String.prototype.trim === undefined) {
		String.prototype.trim = function(){
			return this.replace(/^\s+|\s+$/g, '');
		};	
	}

	dust.i18n = {
		/* Clears all config and loaded keys */
		resetContext: function() {
			i18nContext.selected = undefined;
			Object.keys(i18nLanguages).forEach(function(language){
				delete i18nLanguages[language];
			});
		},

		/* Set the current language. Selected language must be setted previously with setLanguages  */
		setLanguage: function(language) {
			if (_.isAvailable(language)) {
				i18nContext.selected = language;
			} else {
				throw new Error("language '" + language + "' not available!");
			}
		},

		/* Set the available languages */
		setLanguages: function(languages) {
			if (_.isArray(languages)) {
				languages.forEach(function(language){
					if (!_.isAvailable(language)) {
						i18nLanguages[language] = {};
					}
					if (i18nContext.selected === undefined) {
						i18nContext.selected = language;
					}
				});
			}
		},

		/* Be careful. If language is not setted as available then it fails silently */
		add: function(language, context) {
			if (_.isAvailable(language)){
				var languageItems = i18nLanguages[language];
				Object.keys(context).forEach(function(key){
					languageItems[key] = context[key];
				});
			}
		},

		/* Add a new filter. If name exists it won't override it */
		addFilter: function(name, filter) {
			if (!(name in i18nContext.filters)) {
				i18nContext.filters[name] = filter;
			}
		}
	};

	dust.helpers.i18n = function(chunk, context, bodies, params){
		if (params && params.$key !== undefined) {
			var selected = i18nContext.selected,
				languageItems = i18nLanguages[selected],
				pattern = /\{(\s*[\w]+\s*)\}/g,
				paramsArray, param, paramName,
				$key, $data;

			
			$key = dust.helpers.tap(params.$key, chunk, context).split('|');
            var keyName = dust.helpers.tap($key.shift(), chunk, context);
            if (languageItems !== undefined &&  languageItems[keyName] !== undefined) {
                $data = languageItems[keyName];
            }
            else {
                $data = null;
            }

			while ((paramsArray = pattern.exec($data)) !== null) {
				paramName = paramsArray[1].trim();

				if (paramName === '$key') {
					param = '';
					_.log( "$key can't be used as a parameter" );
				} else {
					param = dust.helpers.tap(params[paramsArray[1].trim()], chunk, context);	
				}
				
				$data = $data.replace(paramsArray[0], param);
			}

			$key.forEach(function(filterName){
				if (filterName in i18nContext.filters) {
					$data = i18nContext.filters[filterName]($data);
				}
			});

			chunk.write($data);
		} else {
			_.log( "No key given in the i18n helper" );
		}

		return chunk;
	};

	return dust;
}));

(function () {

    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (stringBuscada, posicion) {
            posicion = posicion || 0;
            return this.indexOf(stringBuscada, posicion) === posicion;
        };
    }

    dust.helpers.iterate = function (chunk, context, bodies, params) {
        params = params || {};
        var obj = params['on'] || context.current();
        var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;

        for (var k in obj) {
            if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                chunk = chunk.render(bodies.block, context.push({ key: k, value: obj[k] }));
            }
        }
        return chunk;
    }
    dust.helpers.startsWith = function (chunk, context, bodies, params) {
        var body = bodies.block, skip = bodies['else'], key = params["key"], value = params["value"];
        if (typeof (key) === "string" && key.toLowerCase().indexOf(value.toLowerCase()) === 0) {
            chunk = chunk.render(body, context);
        }
        else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    };
})();

var __extends=this.__extends||function(b,d){function n(){this.constructor=b}for(var f in d)d.hasOwnProperty(f)&&(b[f]=d[f]);n.prototype=d.prototype;b.prototype=new n};
function JL(b){if(!b)return JL.__;Array.prototype.reduce||(Array.prototype.reduce=function(b,d){for(var l=d,g=0;g<this.length;g++)l=b(l,this[g],g,this);return l});var d="";return("."+b).split(".").reduce(function(b,f,l,g){d=d?d+("."+f):f;f=b["__"+d];void 0===f&&(JL.Logger.prototype=b,f=new JL.Logger(d),b["__"+d]=f);return f},JL.__)}
(function(b){function d(a,c,h){void 0!==c[a]&&(null===c[a]?delete h[a]:h[a]=c[a])}function n(a){if(null!=b.enabled&&!b.enabled||null!=b.maxMessages&&1>b.maxMessages)return!1;try{if(a.userAgentRegex&&!RegExp(a.userAgentRegex).test(navigator.userAgent))return!1}catch(c){}try{if(a.ipRegex&&b.clientIP&&!RegExp(a.ipRegex).test(b.clientIP))return!1}catch(h){}return!0}function f(a,c){try{if(a.disallow&&RegExp(a.disallow).test(c))return!1}catch(h){}return!0}function l(a){return"function"==typeof a?a instanceof
RegExp?a.toString():a():a}function g(a){a=l(a);switch(typeof a){case "string":return new m(a,null,a);case "number":return a=a.toString(),new m(a,null,a);case "boolean":return a=a.toString(),new m(a,null,a);case "undefined":return new m("undefined",null,"undefined");case "object":return a instanceof RegExp||a instanceof String||a instanceof Number||a instanceof Boolean?(a=a.toString(),new m(a,null,a)):new m(null,a,JSON.stringify(a));default:return new m("unknown",null,"unknown")}}b.enabled;b.maxMessages;
b.defaultAjaxUrl;b.clientIP;b.defaultBeforeSend;b.requestId="";var m=function(){return function(a,c,h){this.msg=a;this.meta=c;this.finalString=h}}();b.setOptions=function(a){d("enabled",a,this);d("maxMessages",a,this);d("defaultAjaxUrl",a,this);d("clientIP",a,this);d("requestId",a,this);d("defaultBeforeSend",a,this);return this};b.getAllLevel=function(){return-2147483648};b.getTraceLevel=function(){return 1E3};b.getDebugLevel=function(){return 2E3};b.getInfoLevel=function(){return 3E3};b.getWarnLevel=
function(){return 4E3};b.getErrorLevel=function(){return 5E3};b.getFatalLevel=function(){return 6E3};b.getOffLevel=function(){return 2147483647};var e=function(){return function(a,c){this.inner=c;this.name="JL.Exception";this.message=g(a).finalString}}();b.Exception=e;e.prototype=Error();var r=function(){return function(a,c,h,b){this.l=a;this.m=c;this.n=h;this.t=b}}();b.LogItem=r;e=function(){function a(c,a){this.appenderName=c;this.sendLogItems=a;this.level=b.getTraceLevel();this.sendWithBufferLevel=
2147483647;this.storeInBufferLevel=-2147483648;this.bufferSize=0;this.batchSize=1;this.buffer=[];this.batchBuffer=[]}a.prototype.setOptions=function(c){d("level",c,this);d("ipRegex",c,this);d("userAgentRegex",c,this);d("disallow",c,this);d("sendWithBufferLevel",c,this);d("storeInBufferLevel",c,this);d("bufferSize",c,this);d("batchSize",c,this);this.bufferSize<this.buffer.length&&(this.buffer.length=this.bufferSize);return this};a.prototype.log=function(c,a,b,d,k,e,g){!n(this)||!f(this,e)||k<this.storeInBufferLevel||
(c=new r(k,e,g,(new Date).getTime()),k<this.level?0<this.bufferSize&&(this.buffer.push(c),this.buffer.length>this.bufferSize&&this.buffer.shift()):(k<this.sendWithBufferLevel||!this.buffer.length||(this.batchBuffer=this.batchBuffer.concat(this.buffer),this.buffer.length=0),this.batchBuffer.push(c),this.batchBuffer.length>=this.batchSize&&this.sendBatch()))};a.prototype.sendBatch=function(){0==this.batchBuffer.length||null!=b.maxMessages&&1>b.maxMessages||(null!=b.maxMessages&&(b.maxMessages-=this.batchBuffer.length),
this.sendLogItems(this.batchBuffer),this.batchBuffer.length=0)};return a}();b.Appender=e;var p=function(a){function c(b){a.call(this,b,c.prototype.sendLogItemsAjax)}__extends(c,a);c.prototype.setOptions=function(c){d("url",c,this);d("beforeSend",c,this);a.prototype.setOptions.call(this,c);return this};c.prototype.sendLogItemsAjax=function(c){try{var a="/jsnlog.logger";null!=b.defaultAjaxUrl&&(a=b.defaultAjaxUrl);this.url&&(a=this.url);var d=JSON.stringify({r:b.requestId,lg:c}),k=this.getXhr(a);"function"===
typeof this.beforeSend?this.beforeSend.call(this,k):"function"===typeof b.defaultBeforeSend&&b.defaultBeforeSend.call(this,k);k.send(d)}catch(f){}};c.prototype.getXhr=function(c){var a=new XMLHttpRequest;if(!("withCredentials"in a)&&"undefined"!=typeof XDomainRequest)return a=new XDomainRequest,a.open("POST",c),a;a.open("POST",c);a.setRequestHeader("Content-Type","application/json");a.setRequestHeader("JSNLog-RequestId",b.requestId);return a};return c}(e);b.AjaxAppender=p;var q=function(a){function c(b){a.call(this,
b,c.prototype.sendLogItemsConsole)}__extends(c,a);c.prototype.clog=function(a){console.log(a)};c.prototype.cerror=function(a){console.error?console.error(a):this.clog(a)};c.prototype.cwarn=function(a){console.warn?console.warn(a):this.clog(a)};c.prototype.cinfo=function(a){console.info?console.info(a):this.clog(a)};c.prototype.cdebug=function(a){console.debug?console.debug(a):this.cinfo(a)};c.prototype.sendLogItemsConsole=function(a){try{if(console){var c;for(c=0;c<a.length;++c){var d=a[c],f=d.n+
": "+d.m;"undefined"===typeof window&&(f=new Date(d.t)+" | "+f);d.l<=b.getDebugLevel()?this.cdebug(f):d.l<=b.getInfoLevel()?this.cinfo(f):d.l<=b.getWarnLevel()?this.cwarn(f):this.cerror(f)}}}catch(e){}};return c}(e);b.ConsoleAppender=q;e=function(){function a(a){this.loggerName=a;this.seenRegexes=[]}a.prototype.setOptions=function(a){d("level",a,this);d("userAgentRegex",a,this);d("disallow",a,this);d("ipRegex",a,this);d("appenders",a,this);d("onceOnly",a,this);this.seenRegexes=[];return this};a.prototype.buildExceptionObject=
function(a){var b={};a.stack?b.stack=a.stack:b.e=a;a.message&&(b.message=a.message);a.name&&(b.name=a.name);a.data&&(b.data=a.data);a.inner&&(b.inner=this.buildExceptionObject(a.inner));return b};a.prototype.log=function(a,b,d){var e=0;if(!this.appenders)return this;if(a>=this.level&&n(this)&&(d?(e=this.buildExceptionObject(d),e.logData=l(b)):e=b,b=g(e),f(this,b.finalString))){if(this.onceOnly)for(e=this.onceOnly.length-1;0<=e;){if(RegExp(this.onceOnly[e]).test(b.finalString)){if(this.seenRegexes[e])return this;
this.seenRegexes[e]=!0}e--}b.meta=b.meta||{};b.meta.loggerName=this.loggerName;for(e=this.appenders.length-1;0<=e;)this.appenders[e].log(1E3>=a?"trace":2E3>=a?"debug":3E3>=a?"info":4E3>=a?"warn":5E3>=a?"error":"fatal",b.msg,b.meta,function(){},a,b.finalString,this.loggerName),e--}return this};a.prototype.trace=function(a){return this.log(1E3,a)};a.prototype.debug=function(a){return this.log(2E3,a)};a.prototype.info=function(a){return this.log(3E3,a)};a.prototype.warn=function(a){return this.log(4E3,
a)};a.prototype.error=function(a){return this.log(5E3,a)};a.prototype.fatal=function(a){return this.log(6E3,a)};a.prototype.fatalException=function(a,b){return this.log(6E3,a,b)};return a}();b.Logger=e;b.createAjaxAppender=function(a){return new p(a)};b.createConsoleAppender=function(a){return new q(a)};e=new p("");"undefined"===typeof window&&(e=new q(""));b.__=new b.Logger("");b.__.setOptions({level:b.getDebugLevel(),appenders:[e]})})(JL||(JL={}));var exports;
"undefined"!==typeof exports&&(exports.JL=JL);var define;"function"==typeof define&&define.amd&&define("jsnlog",[],function(){return JL});"function"==typeof __jsnlog_configure&&__jsnlog_configure(JL);

var ol=function(t){var e={};function i(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(r,n,function(e){return t[e]}.bind(null,n));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=5)}([function(t,e,i){"use strict";t.exports=n,t.exports.default=n;var r=i(4);function n(t,e){if(!(this instanceof n))return new n(t,e);this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&this._initFormat(e),this.clear()}function o(t,e,i){if(!i)return e.indexOf(t);for(var r=0;r<e.length;r++)if(i(t,e[r]))return r;return-1}function s(t,e){a(t,0,t.children.length,e,t)}function a(t,e,i,r,n){n||(n=g(null)),n.minX=1/0,n.minY=1/0,n.maxX=-1/0,n.maxY=-1/0;for(var o,s=e;s<i;s++)o=t.children[s],h(n,t.leaf?r(o):o);return n}function h(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function l(t,e){return t.minX-e.minX}function u(t,e){return t.minY-e.minY}function p(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function c(t){return t.maxX-t.minX+(t.maxY-t.minY)}function d(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function f(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function g(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function _(t,e,i,n,o){for(var s,a=[e,i];a.length;)(i=a.pop())-(e=a.pop())<=n||(s=e+Math.ceil((i-e)/n/2)*n,r(t,s,e,i,o),a.push(e,s,s,i))}n.prototype={all:function(){return this._all(this.data,[])},search:function(t){var e=this.data,i=[],r=this.toBBox;if(!f(t,e))return i;for(var n,o,s,a,h=[];e;){for(n=0,o=e.children.length;n<o;n++)s=e.children[n],f(t,a=e.leaf?r(s):s)&&(e.leaf?i.push(s):d(t,a)?this._all(s,i):h.push(s));e=h.pop()}return i},collides:function(t){var e=this.data,i=this.toBBox;if(!f(t,e))return!1;for(var r,n,o,s,a=[];e;){for(r=0,n=e.children.length;r<n;r++)if(o=e.children[r],f(t,s=e.leaf?i(o):o)){if(e.leaf||d(t,s))return!0;a.push(o)}e=a.pop()}return!1},load:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var e=0,i=t.length;e<i;e++)this.insert(t[e]);return this}var r=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===r.height)this._splitRoot(this.data,r);else{if(this.data.height<r.height){var n=this.data;this.data=r,r=n}this._insert(r,this.data.height-r.height-1,!0)}else this.data=r;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=g([]),this},remove:function(t,e){if(!t)return this;for(var i,r,n,s,a=this.data,h=this.toBBox(t),l=[],u=[];a||l.length;){if(a||(a=l.pop(),r=l[l.length-1],i=u.pop(),s=!0),a.leaf&&-1!==(n=o(t,a.children,e)))return a.children.splice(n,1),l.push(a),this._condense(l),this;s||a.leaf||!d(a,h)?r?(i++,a=r.children[i],s=!1):a=null:(l.push(a),u.push(i),i=0,r=a,a=a.children[0])}return this},toBBox:function(t){return t},compareMinX:l,compareMinY:u,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,e){for(var i=[];t;)t.leaf?e.push.apply(e,t.children):i.push.apply(i,t.children),t=i.pop();return e},_build:function(t,e,i,r){var n,o=i-e+1,a=this._maxEntries;if(o<=a)return s(n=g(t.slice(e,i+1)),this.toBBox),n;r||(r=Math.ceil(Math.log(o)/Math.log(a)),a=Math.ceil(o/Math.pow(a,r-1))),(n=g([])).leaf=!1,n.height=r;var h,l,u,p,c=Math.ceil(o/a),d=c*Math.ceil(Math.sqrt(a));for(_(t,e,i,d,this.compareMinX),h=e;h<=i;h+=d)for(_(t,h,u=Math.min(h+d-1,i),c,this.compareMinY),l=h;l<=u;l+=c)p=Math.min(l+c-1,u),n.children.push(this._build(t,l,p,r-1));return s(n,this.toBBox),n},_chooseSubtree:function(t,e,i,r){for(var n,o,s,a,h,l,u,c,d,f;r.push(e),!e.leaf&&r.length-1!==i;){for(u=c=1/0,n=0,o=e.children.length;n<o;n++)h=p(s=e.children[n]),d=t,f=s,(l=(Math.max(f.maxX,d.maxX)-Math.min(f.minX,d.minX))*(Math.max(f.maxY,d.maxY)-Math.min(f.minY,d.minY))-h)<c?(c=l,u=h<u?h:u,a=s):l===c&&h<u&&(u=h,a=s);e=a||e.children[0]}return e},_insert:function(t,e,i){var r=this.toBBox,n=i?t:r(t),o=[],s=this._chooseSubtree(n,this.data,e,o);for(s.children.push(t),h(s,n);e>=0&&o[e].children.length>this._maxEntries;)this._split(o,e),e--;this._adjustParentBBoxes(n,o,e)},_split:function(t,e){var i=t[e],r=i.children.length,n=this._minEntries;this._chooseSplitAxis(i,n,r);var o=this._chooseSplitIndex(i,n,r),a=g(i.children.splice(o,i.children.length-o));a.height=i.height,a.leaf=i.leaf,s(i,this.toBBox),s(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)},_splitRoot:function(t,e){this.data=g([t,e]),this.data.height=t.height+1,this.data.leaf=!1,s(this.data,this.toBBox)},_chooseSplitIndex:function(t,e,i){var r,n,o,s,h,l,u,c,d,f,g,_,y,v;for(l=u=1/0,r=e;r<=i-e;r++)n=a(t,0,r,this.toBBox),o=a(t,r,i,this.toBBox),d=n,f=o,g=void 0,_=void 0,y=void 0,v=void 0,g=Math.max(d.minX,f.minX),_=Math.max(d.minY,f.minY),y=Math.min(d.maxX,f.maxX),v=Math.min(d.maxY,f.maxY),s=Math.max(0,y-g)*Math.max(0,v-_),h=p(n)+p(o),s<l?(l=s,c=r,u=h<u?h:u):s===l&&h<u&&(u=h,c=r);return c},_chooseSplitAxis:function(t,e,i){var r=t.leaf?this.compareMinX:l,n=t.leaf?this.compareMinY:u;this._allDistMargin(t,e,i,r)<this._allDistMargin(t,e,i,n)&&t.children.sort(r)},_allDistMargin:function(t,e,i,r){t.children.sort(r);var n,o,s=this.toBBox,l=a(t,0,e,s),u=a(t,i-e,i,s),p=c(l)+c(u);for(n=e;n<i-e;n++)o=t.children[n],h(l,t.leaf?s(o):o),p+=c(l);for(n=i-e-1;n>=e;n--)o=t.children[n],h(u,t.leaf?s(o):o),p+=c(u);return p},_adjustParentBBoxes:function(t,e,i){for(var r=i;r>=0;r--)h(e[r],t)},_condense:function(t){for(var e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children).splice(e.indexOf(t[i]),1):this.clear():s(t[i],this.toBBox)},_initFormat:function(t){var e=["return a"," - b",";"];this.compareMinX=new Function("a","b",e.join(t[0])),this.compareMinY=new Function("a","b",e.join(t[1])),this.toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}}},,,,function(t,e,i){t.exports=function(){"use strict";function t(t,e,i){var r=t[e];t[e]=t[i],t[i]=r}function e(t,e){return t<e?-1:t>e?1:0}return function(i,r,n,o,s){!function e(i,r,n,o,s){for(;o>n;){if(o-n>600){var a=o-n+1,h=r-n+1,l=Math.log(a),u=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*u*(a-u)/a)*(h-a/2<0?-1:1),c=Math.max(n,Math.floor(r-h*u/a+p)),d=Math.min(o,Math.floor(r+(a-h)*u/a+p));e(i,r,c,d,s)}var f=i[r],g=n,_=o;for(t(i,n,r),s(i[o],f)>0&&t(i,n,o);g<_;){for(t(i,g,_),g++,_--;s(i[g],f)<0;)g++;for(;s(i[_],f)>0;)_--}0===s(i[n],f)?t(i,n,_):t(i,++_,o),_<=r&&(n=_+1),r<=_&&(o=_-1)}}(i,r,n||0,o||i.length-1,s||e)}}()},function(t,e,i){"use strict";function r(){return function(){throw new Error("Unimplemented abstract method.")}()}i.r(e);var n=0;function o(t){return t.ol_uid||(t.ol_uid=String(++n))}var s="5.3.3",a=function(t){function e(e){var i="Assertion failed. See https://openlayers.org/en/"+("latest"===s?s:"v"+s.split("-")[0])+"/doc/errors/#"+e+" for details.";t.call(this,i),this.code=e,this.name="AssertionError",this.message=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),h={ADD:"add",REMOVE:"remove"},l="propertychange",u="function"==typeof Object.assign?Object.assign:function(t,e){var i=arguments;if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var r=Object(t),n=1,o=arguments.length;n<o;++n){var s=i[n];if(null!=s)for(var a in s)s.hasOwnProperty(a)&&(r[a]=s[a])}return r};function p(t){for(var e in t)delete t[e]}function c(t){var e=[];for(var i in t)e.push(t[i]);return e}function d(t){var e;for(e in t)return!1;return!e}function f(t,e,i,r){for(var n,o=0,s=t.length;o<s;++o)if((n=t[o]).listener===e&&n.bindTo===i)return r&&(n.deleteIndex=o),n}function g(t,e){var i=_(t);return i?i[e]:void 0}function _(t,e){var i=t.ol_lm;return!i&&e&&(i=t.ol_lm={}),i}function y(t,e){var i=g(t,e);if(i){for(var r=0,n=i.length;r<n;++r)t.removeEventListener(e,i[r].boundListener),p(i[r]);i.length=0;var o=_(t);o&&(delete o[e],0===Object.keys(o).length&&function(t){delete t.ol_lm}(t))}}function v(t,e,i,r,n){var o=_(t,!0),s=o[e];s||(s=o[e]=[]);var a=f(s,i,r,!1);return a?n||(a.callOnce=!1):(a={bindTo:r,callOnce:!!n,listener:i,target:t,type:e},t.addEventListener(e,function(t){var e=function(e){var i=t.listener,r=t.bindTo||t.target;return t.callOnce&&S(t),i.call(r,e)};return t.boundListener=e,e}(a)),s.push(a)),a}function m(t,e,i,r){return v(t,e,i,r,!0)}function E(t,e,i,r){var n=g(t,e);if(n){var o=f(n,i,r,!0);o&&S(o)}}function S(t){if(t&&t.target){t.target.removeEventListener(t.type,t.boundListener);var e=g(t.target,t.type);if(e){var i="deleteIndex"in t?t.deleteIndex:e.indexOf(t);-1!==i&&e.splice(i,1),0===e.length&&y(t.target,t.type)}p(t)}}var T=function(){this.disposed_=!1};T.prototype.dispose=function(){this.disposed_||(this.disposed_=!0,this.disposeInternal())},T.prototype.disposeInternal=function(){};var C=T;function R(){return!0}function x(){return!1}function w(){}var I=function(t){this.propagationStopped,this.type=t,this.target=null};function O(t){t.stopPropagation()}I.prototype.preventDefault=function(){this.propagationStopped=!0},I.prototype.stopPropagation=function(){this.propagationStopped=!0};var L=I,P=function(t){function e(){t.call(this),this.pendingRemovals_={},this.dispatching_={},this.listeners_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addEventListener=function(t,e){var i=this.listeners_[t];i||(i=this.listeners_[t]=[]),-1===i.indexOf(e)&&i.push(e)},e.prototype.dispatchEvent=function(t){var e="string"==typeof t?new L(t):t,i=e.type;e.target=this;var r,n=this.listeners_[i];if(n){i in this.dispatching_||(this.dispatching_[i]=0,this.pendingRemovals_[i]=0),++this.dispatching_[i];for(var o=0,s=n.length;o<s;++o)if(!1===n[o].call(this,e)||e.propagationStopped){r=!1;break}if(--this.dispatching_[i],0===this.dispatching_[i]){var a=this.pendingRemovals_[i];for(delete this.pendingRemovals_[i];a--;)this.removeEventListener(i,w);delete this.dispatching_[i]}return r}},e.prototype.disposeInternal=function(){!function(t){var e=_(t);if(e)for(var i in e)y(t,i)}(this)},e.prototype.getListeners=function(t){return this.listeners_[t]},e.prototype.hasListener=function(t){return t?t in this.listeners_:Object.keys(this.listeners_).length>0},e.prototype.removeEventListener=function(t,e){var i=this.listeners_[t];if(i){var r=i.indexOf(e);t in this.pendingRemovals_?(i[r]=w,++this.pendingRemovals_[t]):(i.splice(r,1),0===i.length&&delete this.listeners_[t])}},e}(C),M={CHANGE:"change",CLEAR:"clear",CONTEXTMENU:"contextmenu",CLICK:"click",DBLCLICK:"dblclick",DRAGENTER:"dragenter",DRAGOVER:"dragover",DROP:"drop",ERROR:"error",KEYDOWN:"keydown",KEYPRESS:"keypress",LOAD:"load",MOUSEDOWN:"mousedown",MOUSEMOVE:"mousemove",MOUSEOUT:"mouseout",MOUSEUP:"mouseup",MOUSEWHEEL:"mousewheel",MSPOINTERDOWN:"MSPointerDown",RESIZE:"resize",TOUCHSTART:"touchstart",TOUCHMOVE:"touchmove",TOUCHEND:"touchend",WHEEL:"wheel"};var F=function(t){function e(){t.call(this),this.revision_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){++this.revision_,this.dispatchEvent(M.CHANGE)},e.prototype.getRevision=function(){return this.revision_},e.prototype.on=function(t,e){if(Array.isArray(t)){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=v(this,t[n],e);return r}return v(this,t,e)},e.prototype.once=function(t,e){if(Array.isArray(t)){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=m(this,t[n],e);return r}return m(this,t,e)},e.prototype.un=function(t,e){if(Array.isArray(t))for(var i=0,r=t.length;i<r;++i)E(this,t[i],e);else E(this,t,e)},e}(P),b=function(t){function e(e,i,r){t.call(this,e),this.key=i,this.oldValue=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),N={};function A(t){return N.hasOwnProperty(t)?N[t]:N[t]="change:"+t}var G=function(t){function e(e){t.call(this),o(this),this.values_={},void 0!==e&&this.setProperties(e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){var e;return this.values_.hasOwnProperty(t)&&(e=this.values_[t]),e},e.prototype.getKeys=function(){return Object.keys(this.values_)},e.prototype.getProperties=function(){return u({},this.values_)},e.prototype.notify=function(t,e){var i;i=A(t),this.dispatchEvent(new b(i,t,e)),i=l,this.dispatchEvent(new b(i,t,e))},e.prototype.set=function(t,e,i){if(i)this.values_[t]=e;else{var r=this.values_[t];this.values_[t]=e,r!==e&&this.notify(t,r)}},e.prototype.setProperties=function(t,e){for(var i in t)this.set(i,t[i],e)},e.prototype.unset=function(t,e){if(t in this.values_){var i=this.values_[t];delete this.values_[t],e||this.notify(t,i)}},e}(F),D="length",k=function(t){function e(e,i){t.call(this,e),this.element=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),Y=function(t){function e(e,i){t.call(this);var r=i||{};if(this.unique_=!!r.unique,this.array_=e||[],this.unique_)for(var n=0,o=this.array_.length;n<o;++n)this.assertUnique_(this.array_[n],n);this.updateLength_()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clear=function(){for(;this.getLength()>0;)this.pop()},e.prototype.extend=function(t){for(var e=0,i=t.length;e<i;++e)this.push(t[e]);return this},e.prototype.forEach=function(t){for(var e=this.array_,i=0,r=e.length;i<r;++i)t(e[i],i,e)},e.prototype.getArray=function(){return this.array_},e.prototype.item=function(t){return this.array_[t]},e.prototype.getLength=function(){return this.get(D)},e.prototype.insertAt=function(t,e){this.unique_&&this.assertUnique_(e),this.array_.splice(t,0,e),this.updateLength_(),this.dispatchEvent(new k(h.ADD,e))},e.prototype.pop=function(){return this.removeAt(this.getLength()-1)},e.prototype.push=function(t){this.unique_&&this.assertUnique_(t);var e=this.getLength();return this.insertAt(e,t),this.getLength()},e.prototype.remove=function(t){for(var e=this.array_,i=0,r=e.length;i<r;++i)if(e[i]===t)return this.removeAt(i)},e.prototype.removeAt=function(t){var e=this.array_[t];return this.array_.splice(t,1),this.updateLength_(),this.dispatchEvent(new k(h.REMOVE,e)),e},e.prototype.setAt=function(t,e){var i=this.getLength();if(t<i){this.unique_&&this.assertUnique_(e,t);var r=this.array_[t];this.array_[t]=e,this.dispatchEvent(new k(h.REMOVE,r)),this.dispatchEvent(new k(h.ADD,e))}else{for(var n=i;n<t;++n)this.insertAt(n,void 0);this.insertAt(t,e)}},e.prototype.updateLength_=function(){this.set(D,this.array_.length)},e.prototype.assertUnique_=function(t,e){for(var i=0,r=this.array_.length;i<r;++i)if(this.array_[i]===t&&i!==e)throw new a(58)},e}(G),U=function(t){function e(e,i,r){t.call(this,e),this.map=i,this.frameState=void 0!==r?r:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),j=function(t){function e(e,i,r,n,o){t.call(this,e,i,o),this.originalEvent=r,this.pixel=i.getEventPixel(r),this.coordinate=i.getCoordinateFromPixel(this.pixel),this.dragging=void 0!==n&&n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.preventDefault=function(){t.prototype.preventDefault.call(this),this.originalEvent.preventDefault()},e.prototype.stopPropagation=function(){t.prototype.stopPropagation.call(this),this.originalEvent.stopPropagation()},e}(U),X="undefined"!=typeof navigator?navigator.userAgent.toLowerCase():"",B=-1!==X.indexOf("firefox"),V=-1!==X.indexOf("safari")&&-1==X.indexOf("chrom"),W=-1!==X.indexOf("webkit")&&-1==X.indexOf("edge"),K=-1!==X.indexOf("macintosh"),z=window.devicePixelRatio||1,Z=function(){var t=!1;try{t=!!document.createElement("canvas").getContext("2d").setLineDash}catch(t){}return t}(),H=(navigator,"ontouchstart"in window),q="PointerEvent"in window,J=!!navigator.msPointerEnabled,Q={SINGLECLICK:"singleclick",CLICK:M.CLICK,DBLCLICK:M.DBLCLICK,POINTERDRAG:"pointerdrag",POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"},$=function(t){function e(e,i,r,n,o){t.call(this,e,i,r.originalEvent,n,o),this.pointerEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(j),tt={POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"},et=function(t,e){this.dispatcher=t,this.mapping_=e};et.prototype.getEvents=function(){return Object.keys(this.mapping_)},et.prototype.getHandlerForEvent=function(t){return this.mapping_[t]};var it=et,rt=1,nt="mouse";function ot(t){if(!this.isEventSimulatedFromTouch_(t)){rt.toString()in this.pointerMap&&this.cancel(t);var e=ut(t,this.dispatcher);this.pointerMap[rt.toString()]=t,this.dispatcher.down(e,t)}}function st(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.move(e,t)}}function at(t){if(!this.isEventSimulatedFromTouch_(t)){var e=this.pointerMap[rt.toString()];if(e&&e.button===t.button){var i=ut(t,this.dispatcher);this.dispatcher.up(i,t),this.cleanupMouse()}}}function ht(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.enterOver(e,t)}}function lt(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.leaveOut(e,t)}}function ut(t,e){var i=e.cloneEvent(t,t),r=i.preventDefault;return i.preventDefault=function(){t.preventDefault(),r()},i.pointerId=rt,i.isPrimary=!0,i.pointerType=nt,i}var pt=function(t){function e(e){var i={mousedown:ot,mousemove:st,mouseup:at,mouseover:ht,mouseout:lt};t.call(this,e,i),this.pointerMap=e.pointerMap,this.lastTouches=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isEventSimulatedFromTouch_=function(t){for(var e=this.lastTouches,i=t.clientX,r=t.clientY,n=0,o=e.length,s=void 0;n<o&&(s=e[n]);n++){var a=Math.abs(i-s[0]),h=Math.abs(r-s[1]);if(a<=25&&h<=25)return!0}return!1},e.prototype.cancel=function(t){var e=ut(t,this.dispatcher);this.dispatcher.cancel(e,t),this.cleanupMouse()},e.prototype.cleanupMouse=function(){delete this.pointerMap[rt.toString()]},e}(it),ct=["","unavailable","touch","pen","mouse"];function dt(t){this.pointerMap[t.pointerId.toString()]=t;var e=this.prepareEvent_(t);this.dispatcher.down(e,t)}function ft(t){var e=this.prepareEvent_(t);this.dispatcher.move(e,t)}function gt(t){var e=this.prepareEvent_(t);this.dispatcher.up(e,t),this.cleanup(t.pointerId)}function _t(t){var e=this.prepareEvent_(t);this.dispatcher.leaveOut(e,t)}function yt(t){var e=this.prepareEvent_(t);this.dispatcher.enterOver(e,t)}function vt(t){var e=this.prepareEvent_(t);this.dispatcher.cancel(e,t),this.cleanup(t.pointerId)}function mt(t){var e=this.dispatcher.makeEvent("lostpointercapture",t,t);this.dispatcher.dispatchEvent(e)}function Et(t){var e=this.dispatcher.makeEvent("gotpointercapture",t,t);this.dispatcher.dispatchEvent(e)}var St=function(t){function e(e){var i={MSPointerDown:dt,MSPointerMove:ft,MSPointerUp:gt,MSPointerOut:_t,MSPointerOver:yt,MSPointerCancel:vt,MSGotPointerCapture:Et,MSLostPointerCapture:mt};t.call(this,e,i),this.pointerMap=e.pointerMap}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.prepareEvent_=function(t){var e=t;return"number"==typeof t.pointerType&&((e=this.dispatcher.cloneEvent(t,t)).pointerType=ct[t.pointerType]),e},e.prototype.cleanup=function(t){delete this.pointerMap[t.toString()]},e}(it);function Tt(t){this.dispatcher.fireNativeEvent(t)}function Ct(t){this.dispatcher.fireNativeEvent(t)}function Rt(t){this.dispatcher.fireNativeEvent(t)}function xt(t){this.dispatcher.fireNativeEvent(t)}function wt(t){this.dispatcher.fireNativeEvent(t)}function It(t){this.dispatcher.fireNativeEvent(t)}function Ot(t){this.dispatcher.fireNativeEvent(t)}function Lt(t){this.dispatcher.fireNativeEvent(t)}var Pt=function(t){function e(e){var i={pointerdown:Tt,pointermove:Ct,pointerup:Rt,pointerout:xt,pointerover:wt,pointercancel:It,gotpointercapture:Lt,lostpointercapture:Ot};t.call(this,e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(it),Mt=!1,Ft=function(t){function e(e,i,r){t.call(this,e),this.originalEvent=i;var n=r||{};this.buttons=function(t){var e;if(t.buttons||Mt)e=t.buttons;else switch(t.which){case 1:e=1;break;case 2:e=4;break;case 3:e=2;break;default:e=0}return e}(n),this.pressure=function(t,e){var i=0;i=t.pressure?t.pressure:e?.5:0;return i}(n,this.buttons),this.bubbles="bubbles"in n&&n.bubbles,this.cancelable="cancelable"in n&&n.cancelable,this.view="view"in n?n.view:null,this.detail="detail"in n?n.detail:null,this.screenX="screenX"in n?n.screenX:0,this.screenY="screenY"in n?n.screenY:0,this.clientX="clientX"in n?n.clientX:0,this.clientY="clientY"in n?n.clientY:0,this.ctrlKey="ctrlKey"in n&&n.ctrlKey,this.altKey="altKey"in n&&n.altKey,this.shiftKey="shiftKey"in n&&n.shiftKey,this.metaKey="metaKey"in n&&n.metaKey,this.button="button"in n?n.button:0,this.relatedTarget="relatedTarget"in n?n.relatedTarget:null,this.pointerId="pointerId"in n?n.pointerId:0,this.width="width"in n?n.width:0,this.height="height"in n?n.height:0,this.tiltX="tiltX"in n?n.tiltX:0,this.tiltY="tiltY"in n?n.tiltY:0,this.pointerType="pointerType"in n?n.pointerType:"",this.hwTimestamp="hwTimestamp"in n?n.hwTimestamp:0,this.isPrimary="isPrimary"in n&&n.isPrimary,i.preventDefault&&(this.preventDefault=function(){i.preventDefault()})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);!function(){try{var t=new MouseEvent("click",{buttons:1});Mt=1===t.buttons}catch(t){}}();var bt=Ft;function Nt(t,e){return t>e?1:t<e?-1:0}function At(t,e){return t.indexOf(e)>=0}function Gt(t,e,i){var r,n=t.length;if(t[0]<=e)return 0;if(e<=t[n-1])return n-1;if(i>0){for(r=1;r<n;++r)if(t[r]<e)return r-1}else if(i<0){for(r=1;r<n;++r)if(t[r]<=e)return r}else for(r=1;r<n;++r){if(t[r]==e)return r;if(t[r]<e)return t[r-1]-e<e-t[r]?r-1:r}return n-1}function Dt(t,e,i){for(;e<i;){var r=t[e];t[e]=t[i],t[i]=r,++e,--i}}function kt(t,e){for(var i=Array.isArray(e)?e:[e],r=i.length,n=0;n<r;n++)t[t.length]=i[n]}function Yt(t,e){for(var i,r=t.length>>>0,n=0;n<r;n++)if(e(i=t[n],n,t))return i;return null}function Ut(t,e){var i=t.length;if(i!==e.length)return!1;for(var r=0;r<i;r++)if(t[r]!==e[r])return!1;return!0}function jt(t,e){var i;return!t.every(function(r,n){return i=n,!e(r,n,t)})?i:-1}function Xt(t){this.vacuumTouches_(t),this.setPrimaryTouch_(t.changedTouches[0]),this.dedupSynthMouse_(t),this.clickCount_++,this.processTouches_(t,this.overDown_)}function Bt(t){this.processTouches_(t,this.moveOverOut_)}function Vt(t){this.dedupSynthMouse_(t),this.processTouches_(t,this.upOut_)}function Wt(t){this.processTouches_(t,this.cancelOut_)}var Kt=function(t){function e(e,i){var r={touchstart:Xt,touchmove:Bt,touchend:Vt,touchcancel:Wt};t.call(this,e,r),this.pointerMap=e.pointerMap,this.mouseSource=i,this.firstTouchId_=void 0,this.clickCount_=0,this.resetId_,this.dedupTimeout_=2500}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isPrimaryTouch_=function(t){return this.firstTouchId_===t.identifier},e.prototype.setPrimaryTouch_=function(t){var e=Object.keys(this.pointerMap).length;(0===e||1===e&&rt.toString()in this.pointerMap)&&(this.firstTouchId_=t.identifier,this.cancelResetClickCount_())},e.prototype.removePrimaryPointer_=function(t){t.isPrimary&&(this.firstTouchId_=void 0,this.resetClickCount_())},e.prototype.resetClickCount_=function(){this.resetId_=setTimeout(this.resetClickCountHandler_.bind(this),200)},e.prototype.resetClickCountHandler_=function(){this.clickCount_=0,this.resetId_=void 0},e.prototype.cancelResetClickCount_=function(){void 0!==this.resetId_&&clearTimeout(this.resetId_)},e.prototype.touchToPointer_=function(t,e){var i=this.dispatcher.cloneEvent(t,e);return i.pointerId=e.identifier+2,i.bubbles=!0,i.cancelable=!0,i.detail=this.clickCount_,i.button=0,i.buttons=1,i.width=e.radiusX||0,i.height=e.radiusY||0,i.pressure=e.force||.5,i.isPrimary=this.isPrimaryTouch_(e),i.pointerType="touch",i.clientX=e.clientX,i.clientY=e.clientY,i.screenX=e.screenX,i.screenY=e.screenY,i},e.prototype.processTouches_=function(t,e){var i=Array.prototype.slice.call(t.changedTouches),r=i.length;function n(){t.preventDefault()}for(var o=0;o<r;++o){var s=this.touchToPointer_(t,i[o]);s.preventDefault=n,e.call(this,t,s)}},e.prototype.findTouch_=function(t,e){for(var i=t.length,r=0;r<i;r++){if(t[r].identifier===e)return!0}return!1},e.prototype.vacuumTouches_=function(t){var e=t.touches,i=Object.keys(this.pointerMap),r=i.length;if(r>=e.length){for(var n=[],o=0;o<r;++o){var s=Number(i[o]),a=this.pointerMap[s];s==rt||this.findTouch_(e,s-2)||n.push(a.out)}for(var h=0;h<n.length;++h)this.cancelOut_(t,n[h])}},e.prototype.overDown_=function(t,e){this.pointerMap[e.pointerId]={target:e.target,out:e,outTarget:e.target},this.dispatcher.over(e,t),this.dispatcher.enter(e,t),this.dispatcher.down(e,t)},e.prototype.moveOverOut_=function(t,e){var i=e,r=this.pointerMap[i.pointerId];if(r){var n=r.out,o=r.outTarget;this.dispatcher.move(i,t),n&&o!==i.target&&(n.relatedTarget=i.target,i.relatedTarget=o,n.target=o,i.target?(this.dispatcher.leaveOut(n,t),this.dispatcher.enterOver(i,t)):(i.target=o,i.relatedTarget=null,this.cancelOut_(t,i))),r.out=i,r.outTarget=i.target}},e.prototype.upOut_=function(t,e){this.dispatcher.up(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},e.prototype.cancelOut_=function(t,e){this.dispatcher.cancel(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},e.prototype.cleanUpPointer_=function(t){delete this.pointerMap[t.pointerId],this.removePrimaryPointer_(t)},e.prototype.dedupSynthMouse_=function(t){var e=this.mouseSource.lastTouches,i=t.changedTouches[0];if(this.isPrimaryTouch_(i)){var r=[i.clientX,i.clientY];e.push(r),setTimeout(function(){var t,i,n;i=r,n=(t=e).indexOf(i),n>-1&&t.splice(n,1)},this.dedupTimeout_)}},e}(it),zt=[["bubbles",!1],["cancelable",!1],["view",null],["detail",null],["screenX",0],["screenY",0],["clientX",0],["clientY",0],["ctrlKey",!1],["altKey",!1],["shiftKey",!1],["metaKey",!1],["button",0],["relatedTarget",null],["buttons",0],["pointerId",0],["width",0],["height",0],["pressure",0],["tiltX",0],["tiltY",0],["pointerType",""],["hwTimestamp",0],["isPrimary",!1],["type",""],["target",null],["currentTarget",null],["which",0]],Zt=function(t){function e(e){t.call(this),this.element_=e,this.pointerMap={},this.eventMap_={},this.eventSourceList_=[],this.registerSources()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.registerSources=function(){if(q)this.registerSource("native",new Pt(this));else if(J)this.registerSource("ms",new St(this));else{var t=new pt(this);this.registerSource("mouse",t),H&&this.registerSource("touch",new Kt(this,t))}this.register_()},e.prototype.registerSource=function(t,e){var i=e,r=i.getEvents();r&&(r.forEach(function(t){var e=i.getHandlerForEvent(t);e&&(this.eventMap_[t]=e.bind(i))}.bind(this)),this.eventSourceList_.push(i))},e.prototype.register_=function(){for(var t=this.eventSourceList_.length,e=0;e<t;e++){var i=this.eventSourceList_[e];this.addEvents_(i.getEvents())}},e.prototype.unregister_=function(){for(var t=this.eventSourceList_.length,e=0;e<t;e++){var i=this.eventSourceList_[e];this.removeEvents_(i.getEvents())}},e.prototype.eventHandler_=function(t){var e=t.type,i=this.eventMap_[e];i&&i(t)},e.prototype.addEvents_=function(t){t.forEach(function(t){v(this.element_,t,this.eventHandler_,this)}.bind(this))},e.prototype.removeEvents_=function(t){t.forEach(function(t){E(this.element_,t,this.eventHandler_,this)}.bind(this))},e.prototype.cloneEvent=function(t,e){for(var i={},r=0,n=zt.length;r<n;r++){var o=zt[r][0];i[o]=t[o]||e[o]||zt[r][1]}return i},e.prototype.down=function(t,e){this.fireEvent(tt.POINTERDOWN,t,e)},e.prototype.move=function(t,e){this.fireEvent(tt.POINTERMOVE,t,e)},e.prototype.up=function(t,e){this.fireEvent(tt.POINTERUP,t,e)},e.prototype.enter=function(t,e){t.bubbles=!1,this.fireEvent(tt.POINTERENTER,t,e)},e.prototype.leave=function(t,e){t.bubbles=!1,this.fireEvent(tt.POINTERLEAVE,t,e)},e.prototype.over=function(t,e){t.bubbles=!0,this.fireEvent(tt.POINTEROVER,t,e)},e.prototype.out=function(t,e){t.bubbles=!0,this.fireEvent(tt.POINTEROUT,t,e)},e.prototype.cancel=function(t,e){this.fireEvent(tt.POINTERCANCEL,t,e)},e.prototype.leaveOut=function(t,e){this.out(t,e),this.contains_(t.target,t.relatedTarget)||this.leave(t,e)},e.prototype.enterOver=function(t,e){this.over(t,e),this.contains_(t.target,t.relatedTarget)||this.enter(t,e)},e.prototype.contains_=function(t,e){return!(!t||!e)&&t.contains(e)},e.prototype.makeEvent=function(t,e,i){return new bt(t,i,e)},e.prototype.fireEvent=function(t,e,i){var r=this.makeEvent(t,e,i);this.dispatchEvent(r)},e.prototype.fireNativeEvent=function(t){var e=this.makeEvent(t.type,t,t);this.dispatchEvent(e)},e.prototype.wrapMouseEvent=function(t,e){return this.makeEvent(t,ut(e,this),e)},e.prototype.disposeInternal=function(){this.unregister_(),t.prototype.disposeInternal.call(this)},e}(P),Ht=function(t){function e(e,i){t.call(this),this.map_=e,this.clickTimeoutId_,this.dragging_=!1,this.dragListenerKeys_=[],this.moveTolerance_=i?i*z:z,this.down_=null;var r=this.map_.getViewport();this.activePointers_=0,this.trackedTouches_={},this.pointerEventHandler_=new Zt(r),this.documentPointerEventHandler_=null,this.pointerdownListenerKey_=v(this.pointerEventHandler_,tt.POINTERDOWN,this.handlePointerDown_,this),this.relayedListenerKey_=v(this.pointerEventHandler_,tt.POINTERMOVE,this.relayEvent_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.emulateClick_=function(t){var e=new $(Q.CLICK,this.map_,t);this.dispatchEvent(e),void 0!==this.clickTimeoutId_?(clearTimeout(this.clickTimeoutId_),this.clickTimeoutId_=void 0,e=new $(Q.DBLCLICK,this.map_,t),this.dispatchEvent(e)):this.clickTimeoutId_=setTimeout(function(){this.clickTimeoutId_=void 0;var e=new $(Q.SINGLECLICK,this.map_,t);this.dispatchEvent(e)}.bind(this),250)},e.prototype.updateActivePointers_=function(t){var e=t;e.type==Q.POINTERUP||e.type==Q.POINTERCANCEL?delete this.trackedTouches_[e.pointerId]:e.type==Q.POINTERDOWN&&(this.trackedTouches_[e.pointerId]=!0),this.activePointers_=Object.keys(this.trackedTouches_).length},e.prototype.handlePointerUp_=function(t){this.updateActivePointers_(t);var e=new $(Q.POINTERUP,this.map_,t);this.dispatchEvent(e),e.propagationStopped||this.dragging_||!this.isMouseActionButton_(t)||this.emulateClick_(this.down_),0===this.activePointers_&&(this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.dragging_=!1,this.down_=null,this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null)},e.prototype.isMouseActionButton_=function(t){return 0===t.button},e.prototype.handlePointerDown_=function(t){this.updateActivePointers_(t);var e=new $(Q.POINTERDOWN,this.map_,t);this.dispatchEvent(e),this.down_=t,0===this.dragListenerKeys_.length&&(this.documentPointerEventHandler_=new Zt(document),this.dragListenerKeys_.push(v(this.documentPointerEventHandler_,Q.POINTERMOVE,this.handlePointerMove_,this),v(this.documentPointerEventHandler_,Q.POINTERUP,this.handlePointerUp_,this),v(this.pointerEventHandler_,Q.POINTERCANCEL,this.handlePointerUp_,this)))},e.prototype.handlePointerMove_=function(t){if(this.isMoving_(t)){this.dragging_=!0;var e=new $(Q.POINTERDRAG,this.map_,t,this.dragging_);this.dispatchEvent(e)}t.preventDefault()},e.prototype.relayEvent_=function(t){var e=!(!this.down_||!this.isMoving_(t));this.dispatchEvent(new $(t.type,this.map_,t,e))},e.prototype.isMoving_=function(t){return this.dragging_||Math.abs(t.clientX-this.down_.clientX)>this.moveTolerance_||Math.abs(t.clientY-this.down_.clientY)>this.moveTolerance_},e.prototype.disposeInternal=function(){this.relayedListenerKey_&&(S(this.relayedListenerKey_),this.relayedListenerKey_=null),this.pointerdownListenerKey_&&(S(this.pointerdownListenerKey_),this.pointerdownListenerKey_=null),this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.documentPointerEventHandler_&&(this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null),this.pointerEventHandler_&&(this.pointerEventHandler_.dispose(),this.pointerEventHandler_=null),t.prototype.disposeInternal.call(this)},e}(P),qt={POSTRENDER:"postrender",MOVESTART:"movestart",MOVEEND:"moveend"},Jt={LAYERGROUP:"layergroup",SIZE:"size",TARGET:"target",VIEW:"view"},Qt={POSTCOMPOSE:"postcompose",PRECOMPOSE:"precompose",RENDER:"render",RENDERCOMPLETE:"rendercomplete"},$t={IDLE:0,LOADING:1,LOADED:2,ERROR:3,EMPTY:4,ABORT:5};function te(t,e){if(!t)throw new a(e)}var ee=function(t,e){this.priorityFunction_=t,this.keyFunction_=e,this.elements_=[],this.priorities_=[],this.queuedElements_={}};ee.prototype.clear=function(){this.elements_.length=0,this.priorities_.length=0,p(this.queuedElements_)},ee.prototype.dequeue=function(){var t=this.elements_,e=this.priorities_,i=t[0];1==t.length?(t.length=0,e.length=0):(t[0]=t.pop(),e[0]=e.pop(),this.siftUp_(0));var r=this.keyFunction_(i);return delete this.queuedElements_[r],i},ee.prototype.enqueue=function(t){te(!(this.keyFunction_(t)in this.queuedElements_),31);var e=this.priorityFunction_(t);return e!=1/0&&(this.elements_.push(t),this.priorities_.push(e),this.queuedElements_[this.keyFunction_(t)]=!0,this.siftDown_(0,this.elements_.length-1),!0)},ee.prototype.getCount=function(){return this.elements_.length},ee.prototype.getLeftChildIndex_=function(t){return 2*t+1},ee.prototype.getRightChildIndex_=function(t){return 2*t+2},ee.prototype.getParentIndex_=function(t){return t-1>>1},ee.prototype.heapify_=function(){var t;for(t=(this.elements_.length>>1)-1;t>=0;t--)this.siftUp_(t)},ee.prototype.isEmpty=function(){return 0===this.elements_.length},ee.prototype.isKeyQueued=function(t){return t in this.queuedElements_},ee.prototype.isQueued=function(t){return this.isKeyQueued(this.keyFunction_(t))},ee.prototype.siftUp_=function(t){for(var e=this.elements_,i=this.priorities_,r=e.length,n=e[t],o=i[t],s=t;t<r>>1;){var a=this.getLeftChildIndex_(t),h=this.getRightChildIndex_(t),l=h<r&&i[h]<i[a]?h:a;e[t]=e[l],i[t]=i[l],t=l}e[t]=n,i[t]=o,this.siftDown_(s,t)},ee.prototype.siftDown_=function(t,e){for(var i=this.elements_,r=this.priorities_,n=i[e],o=r[e];e>t;){var s=this.getParentIndex_(e);if(!(r[s]>o))break;i[e]=i[s],r[e]=r[s],e=s}i[e]=n,r[e]=o},ee.prototype.reprioritize=function(){var t,e,i,r=this.priorityFunction_,n=this.elements_,o=this.priorities_,s=0,a=n.length;for(e=0;e<a;++e)(i=r(t=n[e]))==1/0?delete this.queuedElements_[this.keyFunction_(t)]:(o[s]=i,n[s++]=t);n.length=s,o.length=s,this.heapify_()};var ie=function(t){function e(e,i){t.call(this,function(t){return e.apply(null,t)},function(t){return t[0].getKey()}),this.tileChangeCallback_=i,this.tilesLoading_=0,this.tilesLoadingKeys_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.enqueue=function(e){var i=t.prototype.enqueue.call(this,e);i&&v(e[0],M.CHANGE,this.handleTileChange,this);return i},e.prototype.getTilesLoading=function(){return this.tilesLoading_},e.prototype.handleTileChange=function(t){var e=t.target,i=e.getState();if(i===$t.LOADED||i===$t.ERROR||i===$t.EMPTY||i===$t.ABORT){E(e,M.CHANGE,this.handleTileChange,this);var r=e.getKey();r in this.tilesLoadingKeys_&&(delete this.tilesLoadingKeys_[r],--this.tilesLoading_),this.tileChangeCallback_()}},e.prototype.loadMoreTiles=function(t,e){for(var i,r,n,o=0,s=!1;this.tilesLoading_<t&&o<e&&this.getCount()>0;)n=(r=this.dequeue()[0]).getKey(),(i=r.getState())===$t.ABORT?s=!0:i!==$t.IDLE||n in this.tilesLoadingKeys_||(this.tilesLoadingKeys_[n]=!0,++this.tilesLoading_,++o,r.load());0===o&&s&&this.tileChangeCallback_()},e}(ee),re=42,ne=256;function oe(t,e,i){return Math.min(Math.max(t,e),i)}var se="cosh"in Math?Math.cosh:function(t){var e=Math.exp(t);return(e+1/e)/2};function ae(t,e,i,r,n,o){var s=n-i,a=o-r;if(0!==s||0!==a){var h=((t-i)*s+(e-r)*a)/(s*s+a*a);h>1?(i=n,r=o):h>0&&(i+=s*h,r+=a*h)}return he(t,e,i,r)}function he(t,e,i,r){var n=i-t,o=r-e;return n*n+o*o}function le(t){return t*Math.PI/180}function ue(t,e){var i=t%e;return i*e<0?i+e:i}function pe(t,e,i){return t+i*(e-t)}function ce(t){return t}function de(t,e){return void 0!==t?0:void 0}function fe(t,e){return void 0!==t?t+e:void 0}var ge=0,_e=1,ye="center",ve="resolution",me="rotation";function Ee(t,e,i){var r=void 0!==i?t.toFixed(i):""+t,n=r.indexOf(".");return(n=-1===n?r.length:n)>e?r:new Array(1+e-n).join("0")+r}function Se(t,e){return t[0]+=e[0],t[1]+=e[1],t}function Te(t,e){var i,r,n=t[0],o=t[1],s=e[0],a=e[1],h=s[0],l=s[1],u=a[0],p=a[1],c=u-h,d=p-l,f=0===c&&0===d?0:(c*(n-h)+d*(o-l))/(c*c+d*d||0);return f<=0?(i=h,r=l):f>=1?(i=u,r=p):(i=h+f*c,r=l+f*d),[i,r]}function Ce(t,e){for(var i=!0,r=t.length-1;r>=0;--r)if(t[r]!=e[r]){i=!1;break}return i}function Re(t,e){var i=Math.cos(e),r=Math.sin(e),n=t[0]*i-t[1]*r,o=t[1]*i+t[0]*r;return t[0]=n,t[1]=o,t}function xe(t,e){return t[0]*=e,t[1]*=e,t}function we(t,e){var i=t[0]-e[0],r=t[1]-e[1];return i*i+r*r}function Ie(t,e){return Math.sqrt(we(t,e))}function Oe(t,e){return we(t,Te(t,e))}function Le(t){return Math.pow(t,3)}function Pe(t){return 1-Le(1-t)}function Me(t){return 3*t*t-2*t*t*t}function Fe(t){return t}var be={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"},Ne={UNKNOWN:0,INTERSECTING:1,ABOVE:2,RIGHT:4,BELOW:8,LEFT:16};function Ae(t){for(var e=Be(),i=0,r=t.length;i<r;++i)qe(e,t[i]);return e}function Ge(t,e,i){return i?(i[0]=t[0]-e,i[1]=t[1]-e,i[2]=t[2]+e,i[3]=t[3]+e,i):[t[0]-e,t[1]-e,t[2]+e,t[3]+e]}function De(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t.slice()}function ke(t,e,i){var r,n;return(r=e<t[0]?t[0]-e:t[2]<e?e-t[2]:0)*r+(n=i<t[1]?t[1]-i:t[3]<i?i-t[3]:0)*n}function Ye(t,e){return je(t,e[0],e[1])}function Ue(t,e){return t[0]<=e[0]&&e[2]<=t[2]&&t[1]<=e[1]&&e[3]<=t[3]}function je(t,e,i){return t[0]<=e&&e<=t[2]&&t[1]<=i&&i<=t[3]}function Xe(t,e){var i=t[0],r=t[1],n=t[2],o=t[3],s=e[0],a=e[1],h=Ne.UNKNOWN;return s<i?h|=Ne.LEFT:s>n&&(h|=Ne.RIGHT),a<r?h|=Ne.BELOW:a>o&&(h|=Ne.ABOVE),h===Ne.UNKNOWN&&(h=Ne.INTERSECTING),h}function Be(){return[1/0,1/0,-1/0,-1/0]}function Ve(t,e,i,r,n){return n?(n[0]=t,n[1]=e,n[2]=i,n[3]=r,n):[t,e,i,r]}function We(t){return Ve(1/0,1/0,-1/0,-1/0,t)}function Ke(t,e){var i=t[0],r=t[1];return Ve(i,r,i,r,e)}function ze(t,e,i,r,n){return Qe(We(n),t,e,i,r)}function Ze(t,e){return t[0]==e[0]&&t[2]==e[2]&&t[1]==e[1]&&t[3]==e[3]}function He(t,e){return e[0]<t[0]&&(t[0]=e[0]),e[2]>t[2]&&(t[2]=e[2]),e[1]<t[1]&&(t[1]=e[1]),e[3]>t[3]&&(t[3]=e[3]),t}function qe(t,e){e[0]<t[0]&&(t[0]=e[0]),e[0]>t[2]&&(t[2]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>t[3]&&(t[3]=e[1])}function Je(t,e){for(var i=0,r=e.length;i<r;++i)qe(t,e[i]);return t}function Qe(t,e,i,r,n){for(;i<r;i+=n)$e(t,e[i],e[i+1]);return t}function $e(t,e,i){t[0]=Math.min(t[0],e),t[1]=Math.min(t[1],i),t[2]=Math.max(t[2],e),t[3]=Math.max(t[3],i)}function ti(t,e,i){var r;return(r=e.call(i,ii(t)))?r:(r=e.call(i,ri(t)))?r:(r=e.call(i,ui(t)))?r:(r=e.call(i,li(t)))||!1}function ei(t){var e=0;return di(t)||(e=pi(t)*ai(t)),e}function ii(t){return[t[0],t[1]]}function ri(t){return[t[2],t[1]]}function ni(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]}function oi(t,e){var i;return e===be.BOTTOM_LEFT?i=ii(t):e===be.BOTTOM_RIGHT?i=ri(t):e===be.TOP_LEFT?i=li(t):e===be.TOP_RIGHT?i=ui(t):te(!1,13),i}function si(t,e,i,r,n){var o=e*r[0]/2,s=e*r[1]/2,a=Math.cos(i),h=Math.sin(i),l=o*a,u=o*h,p=s*a,c=s*h,d=t[0],f=t[1],g=d-l+c,_=d-l-c,y=d+l-c,v=d+l+c,m=f-u-p,E=f-u+p,S=f+u+p,T=f+u-p;return Ve(Math.min(g,_,y,v),Math.min(m,E,S,T),Math.max(g,_,y,v),Math.max(m,E,S,T),n)}function ai(t){return t[3]-t[1]}function hi(t,e,i){var r=i||[1/0,1/0,-1/0,-1/0];return ci(t,e)?(t[0]>e[0]?r[0]=t[0]:r[0]=e[0],t[1]>e[1]?r[1]=t[1]:r[1]=e[1],t[2]<e[2]?r[2]=t[2]:r[2]=e[2],t[3]<e[3]?r[3]=t[3]:r[3]=e[3]):We(r),r}function li(t){return[t[0],t[3]]}function ui(t){return[t[2],t[3]]}function pi(t){return t[2]-t[0]}function ci(t,e){return t[0]<=e[2]&&t[2]>=e[0]&&t[1]<=e[3]&&t[3]>=e[1]}function di(t){return t[2]<t[0]||t[3]<t[1]}function fi(t,e){var i=(t[2]-t[0])/2*(e-1),r=(t[3]-t[1])/2*(e-1);t[0]-=i,t[2]+=i,t[1]-=r,t[3]+=r}function gi(t,e,i){var r=[t[0],t[1],t[0],t[3],t[2],t[1],t[2],t[3]];return e(r,r,2),function(t,e,i){return Ve(Math.min.apply(null,t),Math.min.apply(null,e),Math.max.apply(null,t),Math.max.apply(null,e),i)}([r[0],r[2],r[4],r[6]],[r[1],r[3],r[5],r[7]],i)}var _i={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},yi={XY:"XY",XYZ:"XYZ",XYM:"XYM",XYZM:"XYZM"};function vi(t,e,i,r,n,o){for(var s=o||[],a=0,h=e;h<i;h+=r){var l=t[h],u=t[h+1];s[a++]=n[0]*l+n[2]*u+n[4],s[a++]=n[1]*l+n[3]*u+n[5]}return o&&s.length!=a&&(s.length=a),s}
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */
var mi=6371008.8;function Ei(t,e,i){var r=i||mi,n=le(t[1]),o=le(e[1]),s=(o-n)/2,a=le(e[0]-t[0])/2,h=Math.sin(s)*Math.sin(s)+Math.sin(a)*Math.sin(a)*Math.cos(n)*Math.cos(o);return 2*r*Math.atan2(Math.sqrt(h),Math.sqrt(1-h))}var Si={DEGREES:"degrees",FEET:"ft",METERS:"m",PIXELS:"pixels",TILE_PIXELS:"tile-pixels",USFEET:"us-ft"},Ti={};Ti[Si.DEGREES]=2*Math.PI*6370997/360,Ti[Si.FEET]=.3048,Ti[Si.METERS]=1,Ti[Si.USFEET]=1200/3937;var Ci=Si,Ri=function(t){this.code_=t.code,this.units_=t.units,this.extent_=void 0!==t.extent?t.extent:null,this.worldExtent_=void 0!==t.worldExtent?t.worldExtent:null,this.axisOrientation_=void 0!==t.axisOrientation?t.axisOrientation:"enu",this.global_=void 0!==t.global&&t.global,this.canWrapX_=!(!this.global_||!this.extent_),this.getPointResolutionFunc_=t.getPointResolution,this.defaultTileGrid_=null,this.metersPerUnit_=t.metersPerUnit};Ri.prototype.canWrapX=function(){return this.canWrapX_},Ri.prototype.getCode=function(){return this.code_},Ri.prototype.getExtent=function(){return this.extent_},Ri.prototype.getUnits=function(){return this.units_},Ri.prototype.getMetersPerUnit=function(){return this.metersPerUnit_||Ti[this.units_]},Ri.prototype.getWorldExtent=function(){return this.worldExtent_},Ri.prototype.getAxisOrientation=function(){return this.axisOrientation_},Ri.prototype.isGlobal=function(){return this.global_},Ri.prototype.setGlobal=function(t){this.global_=t,this.canWrapX_=!(!t||!this.extent_)},Ri.prototype.getDefaultTileGrid=function(){return this.defaultTileGrid_},Ri.prototype.setDefaultTileGrid=function(t){this.defaultTileGrid_=t},Ri.prototype.setExtent=function(t){this.extent_=t,this.canWrapX_=!(!this.global_||!t)},Ri.prototype.setWorldExtent=function(t){this.worldExtent_=t},Ri.prototype.setGetPointResolution=function(t){this.getPointResolutionFunc_=t},Ri.prototype.getPointResolutionFunc=function(){return this.getPointResolutionFunc_};var xi=Ri,wi=6378137,Ii=Math.PI*wi,Oi=[-Ii,-Ii,Ii,Ii],Li=[-180,-85,180,85],Pi=function(t){function e(e){t.call(this,{code:e,units:Ci.METERS,extent:Oi,global:!0,worldExtent:Li,getPointResolution:function(t,e){return t/se(e[1]/wi)}})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(xi),Mi=[new Pi("EPSG:3857"),new Pi("EPSG:102100"),new Pi("EPSG:102113"),new Pi("EPSG:900913"),new Pi("urn:ogc:def:crs:EPSG:6.18:3:3857"),new Pi("urn:ogc:def:crs:EPSG::3857"),new Pi("http://www.opengis.net/gml/srs/epsg.xml#3857")];function Fi(t,e,i){var r=t.length,n=i>1?i:2,o=e;void 0===o&&(o=n>2?t.slice():new Array(r));for(var s=Ii,a=0;a<r;a+=n){o[a]=s*t[a]/180;var h=wi*Math.log(Math.tan(Math.PI*(t[a+1]+90)/360));h>s?h=s:h<-s&&(h=-s),o[a+1]=h}return o}function bi(t,e,i){var r=t.length,n=i>1?i:2,o=e;void 0===o&&(o=n>2?t.slice():new Array(r));for(var s=0;s<r;s+=n)o[s]=180*t[s]/Ii,o[s+1]=360*Math.atan(Math.exp(t[s+1]/wi))/Math.PI-90;return o}var Ni=[-180,-90,180,90],Ai=6378137*Math.PI/180,Gi=function(t){function e(e,i){t.call(this,{code:e,units:Ci.DEGREES,extent:Ni,axisOrientation:i,global:!0,metersPerUnit:Ai,worldExtent:Ni})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(xi),Di=[new Gi("CRS:84"),new Gi("EPSG:4326","neu"),new Gi("urn:ogc:def:crs:EPSG::4326","neu"),new Gi("urn:ogc:def:crs:EPSG:6.6:4326","neu"),new Gi("urn:ogc:def:crs:OGC:1.3:CRS84"),new Gi("urn:ogc:def:crs:OGC:2:84"),new Gi("http://www.opengis.net/gml/srs/epsg.xml#4326","neu"),new Gi("urn:x-ogc:def:crs:EPSG:4326","neu")],ki={};var Yi,Ui,ji,Xi={};function Bi(t,e,i){var r=t.getCode(),n=e.getCode();r in Xi||(Xi[r]={}),Xi[r][n]=i}function Vi(t,e){var i;return t in Xi&&e in Xi[t]&&(i=Xi[t][e]),i}function Wi(t,e,i){var r;if(void 0!==e){for(var n=0,o=t.length;n<o;++n)e[n]=t[n];r=e}else r=t.slice();return r}function Ki(t,e,i){if(void 0!==e&&t!==e){for(var r=0,n=t.length;r<n;++r)e[r]=t[r];t=e}return t}function zi(t){!function(t,e){ki[t]=e}(t.getCode(),t),Bi(t,t,Wi)}function Zi(t){return"string"==typeof t?ki[t]||null:t||null}function Hi(t,e,i,r){var n,o=(t=Zi(t)).getPointResolutionFunc();if(o)n=o(e,i);else if(t.getUnits()==Ci.DEGREES&&!r||r==Ci.DEGREES)n=e;else{var s=tr(t,Zi("EPSG:4326")),a=[i[0]-e/2,i[1],i[0]+e/2,i[1],i[0],i[1]-e/2,i[0],i[1]+e/2];n=(Ei((a=s(a,a,2)).slice(0,2),a.slice(2,4))+Ei(a.slice(4,6),a.slice(6,8)))/2;var h=r?Ti[r]:t.getMetersPerUnit();void 0!==h&&(n/=h)}return n}function qi(t){!function(t){t.forEach(zi)}(t),t.forEach(function(e){t.forEach(function(t){e!==t&&Bi(e,t,Wi)})})}function Ji(t,e){return t?"string"==typeof t?Zi(t):t:Zi(e)}function Qi(t){return function(e,i,r){for(var n=e.length,o=void 0!==r?r:2,s=void 0!==i?i:new Array(n),a=0;a<n;a+=o){var h=t([e[a],e[a+1]]);s[a]=h[0],s[a+1]=h[1];for(var l=o-1;l>=2;--l)s[a+l]=e[a+l]}return s}}function $i(t,e){if(t===e)return!0;var i=t.getUnits()===e.getUnits();return t.getCode()===e.getCode()?i:tr(t,e)===Wi&&i}function tr(t,e){var i=Vi(t.getCode(),e.getCode());return i||(i=Ki),i}function er(t,e){return tr(Zi(t),Zi(e))}function ir(t,e,i){return er(e,i)(t,void 0,t.length)}function rr(t,e,i){return gi(t,er(e,i))}qi(Mi),qi(Di),Yi=Mi,Ui=Fi,ji=bi,Di.forEach(function(t){Yi.forEach(function(e){Bi(t,e,Ui),Bi(e,t,ji)})});var nr=new Array(6);function or(t){return ar(t,1,0,0,1,0,0)}function sr(t,e){var i=t[0],r=t[1],n=t[2],o=t[3],s=t[4],a=t[5],h=e[0],l=e[1],u=e[2],p=e[3],c=e[4],d=e[5];return t[0]=i*h+n*l,t[1]=r*h+o*l,t[2]=i*u+n*p,t[3]=r*u+o*p,t[4]=i*c+n*d+s,t[5]=r*c+o*d+a,t}function ar(t,e,i,r,n,o,s){return t[0]=e,t[1]=i,t[2]=r,t[3]=n,t[4]=o,t[5]=s,t}function hr(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function lr(t,e){var i=e[0],r=e[1];return e[0]=t[0]*i+t[2]*r+t[4],e[1]=t[1]*i+t[3]*r+t[5],e}function ur(t,e,i){return sr(t,ar(nr,e,0,0,i,0,0))}function pr(t,e,i){return sr(t,ar(nr,1,0,0,1,e,i))}function cr(t,e,i,r,n,o,s,a){var h=Math.sin(o),l=Math.cos(o);return t[0]=r*l,t[1]=n*h,t[2]=-r*h,t[3]=n*l,t[4]=s*r*l-a*r*h+e,t[5]=s*n*h+a*n*l+i,t}var dr=[1,0,0,1,0,0],fr=function(t){function e(){t.call(this),this.extent_=[1/0,1/0,-1/0,-1/0],this.extentRevision_=-1,this.simplifiedGeometryCache={},this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return r()},e.prototype.closestPointXY=function(t,e,i,n){return r()},e.prototype.containsXY=function(t,e){return!1},e.prototype.getClosestPoint=function(t,e){var i=e||[NaN,NaN];return this.closestPointXY(t[0],t[1],i,1/0),i},e.prototype.intersectsCoordinate=function(t){return this.containsXY(t[0],t[1])},e.prototype.computeExtent=function(t){return r()},e.prototype.getExtent=function(t){return this.extentRevision_!=this.getRevision()&&(this.extent_=this.computeExtent(this.extent_),this.extentRevision_=this.getRevision()),function(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t}(this.extent_,t)},e.prototype.rotate=function(t,e){r()},e.prototype.scale=function(t,e,i){r()},e.prototype.simplify=function(t){return this.getSimplifiedGeometry(t*t)},e.prototype.getSimplifiedGeometry=function(t){return r()},e.prototype.getType=function(){return r()},e.prototype.applyTransform=function(t){r()},e.prototype.intersectsExtent=function(t){return r()},e.prototype.translate=function(t,e){r()},e.prototype.transform=function(t,e){var i=Zi(t),r=i.getUnits()==Ci.TILE_PIXELS?function(t,r,n){var o=i.getExtent(),s=i.getWorldExtent(),a=ai(s)/ai(o);return cr(dr,s[0],s[3],a,-a,0,0,0),vi(t,0,t.length,n,dr,r),er(i,e)(t,r,n)}:er(i,e);return this.applyTransform(r),this},e}(G);function gr(t){var e;return t==yi.XY?e=2:t==yi.XYZ||t==yi.XYM?e=3:t==yi.XYZM&&(e=4),e}var _r=function(t){function e(){t.call(this),this.layout=yi.XY,this.stride=2,this.flatCoordinates=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.computeExtent=function(t){return ze(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.getCoordinates=function(){return r()},e.prototype.getFirstCoordinate=function(){return this.flatCoordinates.slice(0,this.stride)},e.prototype.getFlatCoordinates=function(){return this.flatCoordinates},e.prototype.getLastCoordinate=function(){return this.flatCoordinates.slice(this.flatCoordinates.length-this.stride)},e.prototype.getLayout=function(){return this.layout},e.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(p(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<=this.simplifiedGeometryMaxMinSquaredTolerance)return this;var e=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(e))return this.simplifiedGeometryCache[e];var i=this.getSimplifiedGeometryInternal(t);return i.getFlatCoordinates().length<this.flatCoordinates.length?(this.simplifiedGeometryCache[e]=i,i):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)},e.prototype.getSimplifiedGeometryInternal=function(t){return this},e.prototype.getStride=function(){return this.stride},e.prototype.setFlatCoordinates=function(t,e){this.stride=gr(t),this.layout=t,this.flatCoordinates=e},e.prototype.setCoordinates=function(t,e){r()},e.prototype.setLayout=function(t,e,i){var r;if(t)r=gr(t);else{for(var n=0;n<i;++n){if(0===e.length)return this.layout=yi.XY,void(this.stride=2);e=e[0]}t=function(t){var e;2==t?e=yi.XY:3==t?e=yi.XYZ:4==t&&(e=yi.XYZM);return e}(r=e.length)}this.layout=t,this.stride=r},e.prototype.applyTransform=function(t){this.flatCoordinates&&(t(this.flatCoordinates,this.flatCoordinates,this.stride),this.changed())},e.prototype.rotate=function(t,e){var i=this.getFlatCoordinates();if(i){var r=this.getStride();!function(t,e,i,r,n,o,s){for(var a=s||[],h=Math.cos(n),l=Math.sin(n),u=o[0],p=o[1],c=0,d=e;d<i;d+=r){var f=t[d]-u,g=t[d+1]-p;a[c++]=u+f*h-g*l,a[c++]=p+f*l+g*h;for(var _=d+2;_<d+r;++_)a[c++]=t[_]}s&&a.length!=c&&(a.length=c)}(i,0,i.length,r,t,e,i),this.changed()}},e.prototype.scale=function(t,e,i){var r=e;void 0===r&&(r=t);var n=i;n||(n=ni(this.getExtent()));var o=this.getFlatCoordinates();if(o){var s=this.getStride();!function(t,e,i,r,n,o,s,a){for(var h=a||[],l=s[0],u=s[1],p=0,c=e;c<i;c+=r){var d=t[c]-l,f=t[c+1]-u;h[p++]=l+n*d,h[p++]=u+o*f;for(var g=c+2;g<c+r;++g)h[p++]=t[g]}a&&h.length!=p&&(h.length=p)}(o,0,o.length,s,t,r,n,o),this.changed()}},e.prototype.translate=function(t,e){var i=this.getFlatCoordinates();if(i){var r=this.getStride();!function(t,e,i,r,n,o,s){for(var a=s||[],h=0,l=e;l<i;l+=r){a[h++]=t[l]+n,a[h++]=t[l+1]+o;for(var u=l+2;u<l+r;++u)a[h++]=t[u]}s&&a.length!=h&&(a.length=h)}(i,0,i.length,r,t,e,i),this.changed()}},e}(fr);function yr(t,e,i,r){for(var n=0,o=t[i-r],s=t[i-r+1];e<i;e+=r){var a=t[e],h=t[e+1];n+=s*a-o*h,o=a,s=h}return n/2}function vr(t,e,i,r){for(var n=0,o=0,s=i.length;o<s;++o){var a=i[o];n+=yr(t,e,a,r),e=a}return n}function mr(t,e,i,r,n,o,s){var a,h=t[e],l=t[e+1],u=t[i]-h,p=t[i+1]-l;if(0===u&&0===p)a=e;else{var c=((n-h)*u+(o-l)*p)/(u*u+p*p);if(c>1)a=i;else{if(c>0){for(var d=0;d<r;++d)s[d]=pe(t[e+d],t[i+d],c);return void(s.length=r)}a=e}}for(var f=0;f<r;++f)s[f]=t[a+f];s.length=r}function Er(t,e,i,r,n){var o=t[e],s=t[e+1];for(e+=r;e<i;e+=r){var a=t[e],h=t[e+1],l=he(o,s,a,h);l>n&&(n=l),o=a,s=h}return n}function Sr(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];n=Er(t,e,a,r,n),e=a}return n}function Tr(t,e,i,r,n,o,s,a,h,l,u){if(e==i)return l;var p,c;if(0===n){if((c=he(s,a,t[e],t[e+1]))<l){for(p=0;p<r;++p)h[p]=t[e+p];return h.length=r,c}return l}for(var d=u||[NaN,NaN],f=e+r;f<i;)if(mr(t,f-r,f,r,s,a,d),(c=he(s,a,d[0],d[1]))<l){for(l=c,p=0;p<r;++p)h[p]=d[p];h.length=r,f+=r}else f+=r*Math.max((Math.sqrt(c)-Math.sqrt(l))/n|0,1);if(o&&(mr(t,i-r,e,r,s,a,d),(c=he(s,a,d[0],d[1]))<l)){for(l=c,p=0;p<r;++p)h[p]=d[p];h.length=r}return l}function Cr(t,e,i,r,n,o,s,a,h,l,u){for(var p=u||[NaN,NaN],c=0,d=i.length;c<d;++c){var f=i[c];l=Tr(t,e,f,r,n,o,s,a,h,l,p),e=f}return l}function Rr(t,e,i,r){for(var n=0,o=i.length;n<o;++n)t[e++]=i[n];return e}function xr(t,e,i,r){for(var n=0,o=i.length;n<o;++n)for(var s=i[n],a=0;a<r;++a)t[e++]=s[a];return e}function wr(t,e,i,r,n){for(var o=n||[],s=0,a=0,h=i.length;a<h;++a){var l=xr(t,e,i[a],r);o[s++]=l,e=l}return o.length=s,o}function Ir(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=e;a<i;a+=r)o[s++]=t.slice(a,a+r);return o.length=s,o}function Or(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=0,h=i.length;a<h;++a){var l=i[a];o[s++]=Ir(t,e,l,r,o[s]),e=l}return o.length=s,o}function Lr(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=0,h=i.length;a<h;++a){var l=i[a];o[s++]=Or(t,e,l,r,o[s]),e=l[l.length-1]}return o.length=s,o}function Pr(t,e,i,r,n,o,s){var a=(i-e)/r;if(a<3){for(;e<i;e+=r)o[s++]=t[e],o[s++]=t[e+1];return s}var h=new Array(a);h[0]=1,h[a-1]=1;for(var l=[e,i-r],u=0;l.length>0;){for(var p=l.pop(),c=l.pop(),d=0,f=t[c],g=t[c+1],_=t[p],y=t[p+1],v=c+r;v<p;v+=r){var m=ae(t[v],t[v+1],f,g,_,y);m>d&&(u=v,d=m)}d>n&&(h[(u-e)/r]=1,c+r<u&&l.push(c,u),u+r<p&&l.push(u,p))}for(var E=0;E<a;++E)h[E]&&(o[s++]=t[e+E*r],o[s++]=t[e+E*r+1]);return s}function Mr(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h];s=Pr(t,e,u,r,n,o,s),a.push(s),e=u}return s}function Fr(t,e){return e*Math.round(t/e)}function br(t,e,i,r,n,o,s){if(e==i)return s;var a,h,l=Fr(t[e],n),u=Fr(t[e+1],n);e+=r,o[s++]=l,o[s++]=u;do{if(a=Fr(t[e],n),h=Fr(t[e+1],n),(e+=r)==i)return o[s++]=a,o[s++]=h,s}while(a==l&&h==u);for(;e<i;){var p=Fr(t[e],n),c=Fr(t[e+1],n);if(e+=r,p!=a||c!=h){var d=a-l,f=h-u,g=p-l,_=c-u;d*_==f*g&&(d<0&&g<d||d==g||d>0&&g>d)&&(f<0&&_<f||f==_||f>0&&_>f)?(a=p,h=c):(o[s++]=a,o[s++]=h,l=a,u=h,a=p,h=c)}}return o[s++]=a,o[s++]=h,s}function Nr(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h];s=br(t,e,u,r,n,o,s),a.push(s),e=u}return s}var Ar=function(t){function e(e,i){t.call(this),this.maxDelta_=-1,this.maxDeltaRevision_=-1,void 0===i||Array.isArray(e[0])?this.setCoordinates(e,i):this.setFlatCoordinates(i,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Er(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Tr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.getArea=function(){return yr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[];return i.length=Pr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i,0),new e(i,yi.XY)},e.prototype.getType=function(){return _i.LINEAR_RING},e.prototype.intersectsExtent=function(t){return!1},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r),Gr=function(t){function e(e,i){t.call(this),this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){var n=this.flatCoordinates,o=he(t,e,n[0],n[1]);if(o<r){for(var s=this.stride,a=0;a<s;++a)i[a]=n[a];return i.length=s,o}return r},e.prototype.getCoordinates=function(){return this.flatCoordinates?this.flatCoordinates.slice():[]},e.prototype.computeExtent=function(t){return Ke(this.flatCoordinates,t)},e.prototype.getType=function(){return _i.POINT},e.prototype.intersectsExtent=function(t){return je(t,this.flatCoordinates[0],this.flatCoordinates[1])},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,0),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=Rr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r);function Dr(t,e,i,r,n){return!ti(n,function(n){return!kr(t,e,i,r,n[0],n[1])})}function kr(t,e,i,r,n,o){for(var s=0,a=t[i-r],h=t[i-r+1];e<i;e+=r){var l=t[e],u=t[e+1];h<=o?u>o&&(l-a)*(o-h)-(n-a)*(u-h)>0&&s++:u<=o&&(l-a)*(o-h)-(n-a)*(u-h)<0&&s--,a=l,h=u}return 0!==s}function Yr(t,e,i,r,n,o){if(0===i.length)return!1;if(!kr(t,e,i[0],r,n,o))return!1;for(var s=1,a=i.length;s<a;++s)if(kr(t,i[s-1],i[s],r,n,o))return!1;return!0}function Ur(t,e,i,r,n,o,s){for(var a,h,l,u,p,c,d,f=n[o+1],g=[],_=0,y=i.length;_<y;++_){var v=i[_];for(u=t[v-r],c=t[v-r+1],a=e;a<v;a+=r)p=t[a],d=t[a+1],(f<=c&&d<=f||c<=f&&f<=d)&&(l=(f-c)/(d-c)*(p-u)+u,g.push(l)),u=p,c=d}var m=NaN,E=-1/0;for(g.sort(Nt),u=g[0],a=1,h=g.length;a<h;++a){p=g[a];var S=Math.abs(p-u);S>E&&Yr(t,e,i,r,l=(u+p)/2,f)&&(m=l,E=S),u=p}return isNaN(m)&&(m=n[o]),s?(s.push(m,f,E),s):[m,f,E]}function jr(t,e,i,r,n,o){for(var s,a=[t[e],t[e+1]],h=[];e+r<i;e+=r){if(h[0]=t[e+r],h[1]=t[e+r+1],s=n.call(o,a,h))return s;a[0]=h[0],a[1]=h[1]}return!1}function Xr(t,e,i,r,n){var o=Qe([1/0,1/0,-1/0,-1/0],t,e,i,r);return!!ci(n,o)&&(!!Ue(n,o)||(o[0]>=n[0]&&o[2]<=n[2]||(o[1]>=n[1]&&o[3]<=n[3]||jr(t,e,i,r,function(t,e){return function(t,e,i){var r=!1,n=Xe(t,e),o=Xe(t,i);if(n===Ne.INTERSECTING||o===Ne.INTERSECTING)r=!0;else{var s,a,h=t[0],l=t[1],u=t[2],p=t[3],c=e[0],d=e[1],f=i[0],g=i[1],_=(g-d)/(f-c);o&Ne.ABOVE&&!(n&Ne.ABOVE)&&(r=(s=f-(g-p)/_)>=h&&s<=u),r||!(o&Ne.RIGHT)||n&Ne.RIGHT||(r=(a=g-(f-u)*_)>=l&&a<=p),r||!(o&Ne.BELOW)||n&Ne.BELOW||(r=(s=f-(g-l)/_)>=h&&s<=u),r||!(o&Ne.LEFT)||n&Ne.LEFT||(r=(a=g-(f-h)*_)>=l&&a<=p)}return r}(n,t,e)}))))}function Br(t,e,i,r,n){if(!function(t,e,i,r,n){return!!(Xr(t,e,i,r,n)||kr(t,e,i,r,n[0],n[1])||kr(t,e,i,r,n[0],n[3])||kr(t,e,i,r,n[2],n[1])||kr(t,e,i,r,n[2],n[3]))}(t,e,i[0],r,n))return!1;if(1===i.length)return!0;for(var o=1,s=i.length;o<s;++o)if(Dr(t,i[o-1],i[o],r,n)&&!Xr(t,i[o-1],i[o],r,n))return!1;return!0}function Vr(t,e,i,r){for(;e<i-r;){for(var n=0;n<r;++n){var o=t[e+n];t[e+n]=t[i-r+n],t[i-r+n]=o}e+=r,i-=r}}function Wr(t,e,i,r){for(var n=0,o=t[i-r],s=t[i-r+1];e<i;e+=r){var a=t[e],h=t[e+1];n+=(a-o)*(h+s),o=a,s=h}return n>0}function Kr(t,e,i,r,n){for(var o=void 0!==n&&n,s=0,a=i.length;s<a;++s){var h=i[s],l=Wr(t,e,h,r);if(0===s){if(o&&l||!o&&!l)return!1}else if(o&&!l||!o&&l)return!1;e=h}return!0}function zr(t,e,i,r,n){for(var o=void 0!==n&&n,s=0,a=i.length;s<a;++s){var h=i[s],l=Wr(t,e,h,r);(0===s?o&&l||!o&&!l:o&&!l||!o&&l)&&Vr(t,e,h,r),e=h}return e}function Zr(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o)e=zr(t,e,i[o],r,n);return e}var Hr=function(t){function e(e,i,r){t.call(this),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,void 0!==i&&r?(this.setFlatCoordinates(i,e),this.ends_=r):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendLinearRing=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout,this.ends_.slice())},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Sr(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Cr(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.containsXY=function(t,e){return Yr(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)},e.prototype.getArea=function(){return vr(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)},e.prototype.getCoordinates=function(t){var e;return void 0!==t?zr(e=this.getOrientedFlatCoordinates().slice(),0,this.ends_,this.stride,t):e=this.flatCoordinates,Or(e,0,this.ends_,this.stride)},e.prototype.getEnds=function(){return this.ends_},e.prototype.getFlatInteriorPoint=function(){if(this.flatInteriorPointRevision_!=this.getRevision()){var t=ni(this.getExtent());this.flatInteriorPoint_=Ur(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()}return this.flatInteriorPoint_},e.prototype.getInteriorPoint=function(){return new Gr(this.getFlatInteriorPoint(),yi.XYM)},e.prototype.getLinearRingCount=function(){return this.ends_.length},e.prototype.getLinearRing=function(t){return t<0||this.ends_.length<=t?null:new Ar(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)},e.prototype.getLinearRings=function(){for(var t=this.layout,e=this.flatCoordinates,i=this.ends_,r=[],n=0,o=0,s=i.length;o<s;++o){var a=i[o],h=new Ar(e.slice(n,a),t);r.push(h),n=a}return r},e.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var t=this.flatCoordinates;Kr(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=zr(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=Nr(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),i,0,r),new e(i,yi.XY,r)},e.prototype.getType=function(){return _i.POLYGON},e.prototype.intersectsExtent=function(t){return Br(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);var i=wr(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()},e}(_r),qr=Hr;function Jr(t){var e=t[0],i=t[1],r=t[2],n=t[3],o=[e,i,e,n,r,n,r,i,e,i];return new Hr(o,yi.XY,[o.length])}function Qr(t,e,i){for(var r=e||32,n=t.getStride(),o=t.getLayout(),s=t.getCenter(),a=n*(r+1),h=new Array(a),l=0;l<a;l+=n){h[l]=0,h[l+1]=0;for(var u=2;u<n;u++)h[l+u]=s[u]}var p=[h.length],c=new Hr(h,o,p);return $r(c,s,t.getRadius(),i),c}function $r(t,e,i,r){for(var n=t.getFlatCoordinates(),o=t.getStride(),s=n.length/o-1,a=r||0,h=0;h<=s;++h){var l=h*o,u=a+2*ue(h,s)*Math.PI/s;n[l]=e[0]+i*Math.cos(u),n[l+1]=e[1]+i*Math.sin(u)}t.changed()}var tn=0;function en(t,e){setTimeout(function(){t(e)},0)}function rn(t){return!(t.sourceCenter&&t.targetCenter&&!Ce(t.sourceCenter,t.targetCenter))&&(t.sourceResolution===t.targetResolution&&t.sourceRotation===t.targetRotation)}var nn=function(t){function e(e){t.call(this);var i=u({},e);this.hints_=[0,0],this.animations_=[],this.updateAnimationKey_,this.updateAnimations_=this.updateAnimations_.bind(this),this.projection_=Ji(i.projection,"EPSG:3857"),this.applyOptions_(i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.applyOptions_=function(t){var e={};e[ye]=void 0!==t.center?t.center:null;var i=function(t){var e,i,r,n=void 0!==t.minZoom?t.minZoom:tn,o=void 0!==t.maxZoom?t.maxZoom:28,s=void 0!==t.zoomFactor?t.zoomFactor:2;if(void 0!==t.resolutions){var a=t.resolutions;i=a[n],r=void 0!==a[o]?a[o]:a[a.length-1],e=function(t){return function(e,i,r){if(void 0!==e){var n=Gt(t,e,r);n=oe(n+i,0,t.length-1);var o=Math.floor(n);if(n!=o&&o<t.length-1){var s=t[o]/t[o+1];return t[o]/Math.pow(s,n-o)}return t[o]}}}(a)}else{var h=Ji(t.projection,"EPSG:3857"),l=h.getExtent(),u=l?Math.max(pi(l),ai(l)):360*Ti[Ci.DEGREES]/h.getMetersPerUnit(),p=u/ne/Math.pow(2,tn),c=p/Math.pow(2,28-tn);void 0!==(i=t.maxResolution)?n=0:i=p/Math.pow(s,n),void 0===(r=t.minResolution)&&(r=void 0!==t.maxZoom?void 0!==t.maxResolution?i/Math.pow(s,o):p/Math.pow(s,o):c),o=n+Math.floor(Math.log(i/r)/Math.log(s)),r=i/Math.pow(s,o-n),e=function(t,e,i){return function(r,n,o){if(void 0!==r){var s=-o/2+.5,a=Math.floor(Math.log(e/r)/Math.log(t)+s),h=Math.max(a+n,0);return void 0!==i&&(h=Math.min(h,i)),e/Math.pow(t,h)}}}(s,i,o-n)}return{constraint:e,maxResolution:i,minResolution:r,minZoom:n,zoomFactor:s}}(t);this.maxResolution_=i.maxResolution,this.minResolution_=i.minResolution,this.zoomFactor_=i.zoomFactor,this.resolutions_=t.resolutions,this.minZoom_=i.minZoom;var r=function(t){return void 0!==t.extent?(e=t.extent,function(t){return t?[oe(t[0],e[0],e[2]),oe(t[1],e[1],e[3])]:void 0}):ce;var e}(t),n=i.constraint,o=function(t){if(void 0===t.enableRotation||t.enableRotation){var e=t.constrainRotation;return void 0===e||!0===e?(o=n||le(5),function(t,e){return void 0!==t?Math.abs(t+e)<=o?0:t+e:void 0}):!1===e?fe:"number"==typeof e?(i=e,r=2*Math.PI/i,function(t,e){return void 0!==t?t=Math.floor((t+e)/r+.5)*r:void 0}):fe}return de;var i,r;var n,o}(t);this.constraints_={center:r,resolution:n,rotation:o},void 0!==t.resolution?e[ve]=t.resolution:void 0!==t.zoom&&(e[ve]=this.constrainResolution(this.maxResolution_,t.zoom-this.minZoom_),this.resolutions_&&(e[ve]=oe(Number(this.getResolution()||e[ve]),this.minResolution_,this.maxResolution_))),e[me]=void 0!==t.rotation?t.rotation:0,this.setProperties(e),this.options_=t},e.prototype.getUpdatedOptions_=function(t){var e=u({},this.options_);return void 0!==e.resolution?e.resolution=this.getResolution():e.zoom=this.getZoom(),e.center=this.getCenter(),e.rotation=this.getRotation(),u({},e,t)},e.prototype.animate=function(t){var e,i=arguments,r=arguments.length;if(r>1&&"function"==typeof arguments[r-1]&&(e=arguments[r-1],--r),!this.isDef()){var n=arguments[r-1];return n.center&&this.setCenter(n.center),void 0!==n.zoom&&this.setZoom(n.zoom),void 0!==n.rotation&&this.setRotation(n.rotation),void(e&&en(e,!0))}for(var o=Date.now(),s=this.getCenter().slice(),a=this.getResolution(),h=this.getRotation(),l=[],u=0;u<r;++u){var p=i[u],c={start:o,complete:!1,anchor:p.anchor,duration:void 0!==p.duration?p.duration:1e3,easing:p.easing||Me};if(p.center&&(c.sourceCenter=s,c.targetCenter=p.center,s=c.targetCenter),void 0!==p.zoom?(c.sourceResolution=a,c.targetResolution=this.constrainResolution(this.maxResolution_,p.zoom-this.minZoom_,0),a=c.targetResolution):p.resolution&&(c.sourceResolution=a,c.targetResolution=p.resolution,a=c.targetResolution),void 0!==p.rotation){c.sourceRotation=h;var d=ue(p.rotation-h+Math.PI,2*Math.PI)-Math.PI;c.targetRotation=h+d,h=c.targetRotation}c.callback=e,rn(c)?c.complete=!0:o+=c.duration,l.push(c)}this.animations_.push(l),this.setHint(ge,1),this.updateAnimations_()},e.prototype.getAnimating=function(){return this.hints_[ge]>0},e.prototype.getInteracting=function(){return this.hints_[_e]>0},e.prototype.cancelAnimations=function(){this.setHint(ge,-this.hints_[ge]);for(var t=0,e=this.animations_.length;t<e;++t){var i=this.animations_[t];i[0].callback&&en(i[0].callback,!1)}this.animations_.length=0},e.prototype.updateAnimations_=function(){if(void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0),this.getAnimating()){for(var t=Date.now(),e=!1,i=this.animations_.length-1;i>=0;--i){for(var r=this.animations_[i],n=!0,o=0,s=r.length;o<s;++o){var a=r[o];if(!a.complete){var h=t-a.start,l=a.duration>0?h/a.duration:1;l>=1?(a.complete=!0,l=1):n=!1;var u=a.easing(l);if(a.sourceCenter){var p=a.sourceCenter[0],c=a.sourceCenter[1],d=p+u*(a.targetCenter[0]-p),f=c+u*(a.targetCenter[1]-c);this.set(ye,[d,f])}if(a.sourceResolution&&a.targetResolution){var g=1===u?a.targetResolution:a.sourceResolution+u*(a.targetResolution-a.sourceResolution);a.anchor&&this.set(ye,this.calculateCenterZoom(g,a.anchor)),this.set(ve,g)}if(void 0!==a.sourceRotation&&void 0!==a.targetRotation){var _=1===u?ue(a.targetRotation+Math.PI,2*Math.PI)-Math.PI:a.sourceRotation+u*(a.targetRotation-a.sourceRotation);a.anchor&&this.set(ye,this.calculateCenterRotate(_,a.anchor)),this.set(me,_)}if(e=!0,!a.complete)break}}if(n){this.animations_[i]=null,this.setHint(ge,-1);var y=r[0].callback;y&&en(y,!0)}}this.animations_=this.animations_.filter(Boolean),e&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_))}},e.prototype.calculateCenterRotate=function(t,e){var i,r=this.getCenter();return void 0!==r&&(Re(i=[r[0]-e[0],r[1]-e[1]],t-this.getRotation()),Se(i,e)),i},e.prototype.calculateCenterZoom=function(t,e){var i,r=this.getCenter(),n=this.getResolution();void 0!==r&&void 0!==n&&(i=[e[0]-t*(e[0]-r[0])/n,e[1]-t*(e[1]-r[1])/n]);return i},e.prototype.getSizeFromViewport_=function(){var t=[100,100],e='.ol-viewport[data-view="'+o(this)+'"]',i=document.querySelector(e);if(i){var r=getComputedStyle(i);t[0]=parseInt(r.width,10),t[1]=parseInt(r.height,10)}return t},e.prototype.constrainCenter=function(t){return this.constraints_.center(t)},e.prototype.constrainResolution=function(t,e,i){var r=e||0,n=i||0;return this.constraints_.resolution(t,r,n)},e.prototype.constrainRotation=function(t,e){var i=e||0;return this.constraints_.rotation(t,i)},e.prototype.getCenter=function(){return this.get(ye)},e.prototype.getConstraints=function(){return this.constraints_},e.prototype.getHints=function(t){return void 0!==t?(t[0]=this.hints_[0],t[1]=this.hints_[1],t):this.hints_.slice()},e.prototype.calculateExtent=function(t){var e=t||this.getSizeFromViewport_(),i=this.getCenter();te(i,1);var r=this.getResolution();te(void 0!==r,2);var n=this.getRotation();return te(void 0!==n,3),si(i,r,n,e)},e.prototype.getMaxResolution=function(){return this.maxResolution_},e.prototype.getMinResolution=function(){return this.minResolution_},e.prototype.getMaxZoom=function(){return this.getZoomForResolution(this.minResolution_)},e.prototype.setMaxZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({maxZoom:t}))},e.prototype.getMinZoom=function(){return this.getZoomForResolution(this.maxResolution_)},e.prototype.setMinZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({minZoom:t}))},e.prototype.getProjection=function(){return this.projection_},e.prototype.getResolution=function(){return this.get(ve)},e.prototype.getResolutions=function(){return this.resolutions_},e.prototype.getResolutionForExtent=function(t,e){var i=e||this.getSizeFromViewport_(),r=pi(t)/i[0],n=ai(t)/i[1];return Math.max(r,n)},e.prototype.getResolutionForValueFunction=function(t){var e=t||2,i=this.maxResolution_,r=this.minResolution_,n=Math.log(i/r)/Math.log(e);return function(t){return i/Math.pow(e,t*n)}},e.prototype.getRotation=function(){return this.get(me)},e.prototype.getValueForResolutionFunction=function(t){var e=t||2,i=this.maxResolution_,r=this.minResolution_,n=Math.log(i/r)/Math.log(e);return function(t){return Math.log(i/t)/Math.log(e)/n}},e.prototype.getState=function(t){var e=this.getCenter(),i=this.getProjection(),r=this.getResolution(),n=r/t,o=this.getRotation();return{center:[Math.round(e[0]/n)*n,Math.round(e[1]/n)*n],projection:void 0!==i?i:null,resolution:r,rotation:o,zoom:this.getZoom()}},e.prototype.getZoom=function(){var t,e=this.getResolution();return void 0!==e&&(t=this.getZoomForResolution(e)),t},e.prototype.getZoomForResolution=function(t){var e,i,r=this.minZoom_||0;if(this.resolutions_){var n=Gt(this.resolutions_,t,1);r=n,e=this.resolutions_[n],i=n==this.resolutions_.length-1?2:e/this.resolutions_[n+1]}else e=this.maxResolution_,i=this.zoomFactor_;return r+Math.log(e/t)/Math.log(i)},e.prototype.getResolutionForZoom=function(t){return this.constrainResolution(this.maxResolution_,t-this.minZoom_,0)},e.prototype.fit=function(t,e){var i,r=e||{},n=r.size;n||(n=this.getSizeFromViewport_()),te(Array.isArray(t)||"function"==typeof t.getSimplifiedGeometry,24),Array.isArray(t)?(te(!di(t),25),i=Jr(t)):t.getType()===_i.CIRCLE?(i=Jr(t=t.getExtent())).rotate(this.getRotation(),ni(t)):i=t;var o,s=void 0!==r.padding?r.padding:[0,0,0,0],a=void 0===r.constrainResolution||r.constrainResolution,h=void 0!==r.nearest&&r.nearest;o=void 0!==r.minResolution?r.minResolution:void 0!==r.maxZoom?this.constrainResolution(this.maxResolution_,r.maxZoom-this.minZoom_,0):0;for(var l=i.getFlatCoordinates(),u=this.getRotation(),p=Math.cos(-u),c=Math.sin(-u),d=1/0,f=1/0,g=-1/0,_=-1/0,y=i.getStride(),v=0,m=l.length;v<m;v+=y){var E=l[v]*p-l[v+1]*c,S=l[v]*c+l[v+1]*p;d=Math.min(d,E),f=Math.min(f,S),g=Math.max(g,E),_=Math.max(_,S)}var T=this.getResolutionForExtent([d,f,g,_],[n[0]-s[1]-s[3],n[1]-s[0]-s[2]]);if(T=isNaN(T)?o:Math.max(T,o),a){var C=this.constrainResolution(T,0,0);!h&&C<T&&(C=this.constrainResolution(C,-1,0)),T=C}c=-c;var R=(d+g)/2,x=(f+_)/2,I=[(R+=(s[1]-s[3])/2*T)*p-(x+=(s[0]-s[2])/2*T)*c,x*p+R*c],O=r.callback?r.callback:w;void 0!==r.duration?this.animate({resolution:T,center:I,duration:r.duration,easing:r.easing},O):(this.setResolution(T),this.setCenter(I),en(O,!0))},e.prototype.centerOn=function(t,e,i){var r=this.getRotation(),n=Math.cos(-r),o=Math.sin(-r),s=t[0]*n-t[1]*o,a=t[1]*n+t[0]*o,h=this.getResolution(),l=(s+=(e[0]/2-i[0])*h)*n-(a+=(i[1]-e[1]/2)*h)*(o=-o),u=a*n+s*o;this.setCenter([l,u])},e.prototype.isDef=function(){return!!this.getCenter()&&void 0!==this.getResolution()},e.prototype.rotate=function(t,e){if(void 0!==e){var i=this.calculateCenterRotate(t,e);this.setCenter(i)}this.setRotation(t)},e.prototype.setCenter=function(t){this.set(ye,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setHint=function(t,e){return this.hints_[t]+=e,this.changed(),this.hints_[t]},e.prototype.setResolution=function(t){this.set(ve,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setRotation=function(t){this.set(me,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setZoom=function(t){this.setResolution(this.getResolutionForZoom(t))},e}(G);function on(t,e){var i=document.createElement("canvas");return t&&(i.width=t),e&&(i.height=e),i.getContext("2d")}function sn(t){var e=t.offsetWidth,i=getComputedStyle(t);return e+=parseInt(i.marginLeft,10)+parseInt(i.marginRight,10)}function an(t){var e=t.offsetHeight,i=getComputedStyle(t);return e+=parseInt(i.marginTop,10)+parseInt(i.marginBottom,10)}function hn(t,e){var i=e.parentNode;i&&i.replaceChild(t,e)}function ln(t){return t&&t.parentNode?t.parentNode.removeChild(t):null}function un(t){for(;t.lastChild;)t.removeChild(t.lastChild)}var pn={OPACITY:"opacity",VISIBLE:"visible",EXTENT:"extent",Z_INDEX:"zIndex",MAX_RESOLUTION:"maxResolution",MIN_RESOLUTION:"minResolution",SOURCE:"source"},cn=function(t){function e(e){t.call(this);var i=u({},e);i[pn.OPACITY]=void 0!==e.opacity?e.opacity:1,i[pn.VISIBLE]=void 0===e.visible||e.visible,i[pn.Z_INDEX]=e.zIndex,i[pn.MAX_RESOLUTION]=void 0!==e.maxResolution?e.maxResolution:1/0,i[pn.MIN_RESOLUTION]=void 0!==e.minResolution?e.minResolution:0,this.setProperties(i),this.state_=null,this.type}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return this.type},e.prototype.getLayerState=function(){var t=this.state_||{layer:this,managed:!0};return t.opacity=oe(this.getOpacity(),0,1),t.sourceState=this.getSourceState(),t.visible=this.getVisible(),t.extent=this.getExtent(),t.zIndex=this.getZIndex()||0,t.maxResolution=this.getMaxResolution(),t.minResolution=Math.max(this.getMinResolution(),0),this.state_=t,t},e.prototype.getLayersArray=function(t){return r()},e.prototype.getLayerStatesArray=function(t){return r()},e.prototype.getExtent=function(){return this.get(pn.EXTENT)},e.prototype.getMaxResolution=function(){return this.get(pn.MAX_RESOLUTION)},e.prototype.getMinResolution=function(){return this.get(pn.MIN_RESOLUTION)},e.prototype.getOpacity=function(){return this.get(pn.OPACITY)},e.prototype.getSourceState=function(){return r()},e.prototype.getVisible=function(){return this.get(pn.VISIBLE)},e.prototype.getZIndex=function(){return this.get(pn.Z_INDEX)},e.prototype.setExtent=function(t){this.set(pn.EXTENT,t)},e.prototype.setMaxResolution=function(t){this.set(pn.MAX_RESOLUTION,t)},e.prototype.setMinResolution=function(t){this.set(pn.MIN_RESOLUTION,t)},e.prototype.setOpacity=function(t){this.set(pn.OPACITY,t)},e.prototype.setVisible=function(t){this.set(pn.VISIBLE,t)},e.prototype.setZIndex=function(t){this.set(pn.Z_INDEX,t)},e}(G),dn={UNDEFINED:"undefined",LOADING:"loading",READY:"ready",ERROR:"error"},fn={LAYERS:"layers"},gn=function(t){function e(e){var i=e||{},r=u({},i);delete r.layers;var n=i.layers;t.call(this,r),this.layersListenerKeys_=[],this.listenerKeys_={},v(this,A(fn.LAYERS),this.handleLayersChanged_,this),n?Array.isArray(n)?n=new Y(n.slice(),{unique:!0}):te("function"==typeof n.getArray,43):n=new Y(void 0,{unique:!0}),this.setLayers(n)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleLayerChange_=function(){this.changed()},e.prototype.handleLayersChanged_=function(){this.layersListenerKeys_.forEach(S),this.layersListenerKeys_.length=0;var t=this.getLayers();for(var e in this.layersListenerKeys_.push(v(t,h.ADD,this.handleLayersAdd_,this),v(t,h.REMOVE,this.handleLayersRemove_,this)),this.listenerKeys_)this.listenerKeys_[e].forEach(S);p(this.listenerKeys_);for(var i=t.getArray(),r=0,n=i.length;r<n;r++){var s=i[r];this.listenerKeys_[o(s)]=[v(s,l,this.handleLayerChange_,this),v(s,M.CHANGE,this.handleLayerChange_,this)]}this.changed()},e.prototype.handleLayersAdd_=function(t){var e=t.element;this.listenerKeys_[o(e)]=[v(e,l,this.handleLayerChange_,this),v(e,M.CHANGE,this.handleLayerChange_,this)],this.changed()},e.prototype.handleLayersRemove_=function(t){var e=o(t.element);this.listenerKeys_[e].forEach(S),delete this.listenerKeys_[e],this.changed()},e.prototype.getLayers=function(){return this.get(fn.LAYERS)},e.prototype.setLayers=function(t){this.set(fn.LAYERS,t)},e.prototype.getLayersArray=function(t){var e=void 0!==t?t:[];return this.getLayers().forEach(function(t){t.getLayersArray(e)}),e},e.prototype.getLayerStatesArray=function(t){var e=void 0!==t?t:[],i=e.length;this.getLayers().forEach(function(t){t.getLayerStatesArray(e)});for(var r=this.getLayerState(),n=i,o=e.length;n<o;n++){var s=e[n];s.opacity*=r.opacity,s.visible=s.visible&&r.visible,s.maxResolution=Math.min(s.maxResolution,r.maxResolution),s.minResolution=Math.max(s.minResolution,r.minResolution),void 0!==r.extent&&(void 0!==s.extent?s.extent=hi(s.extent,r.extent):s.extent=r.extent)}return e},e.prototype.getSourceState=function(){return dn.READY},e}(cn);function _n(t,e){return Array.isArray(t)?t:(void 0===e?e=[t,t]:e[0]=e[1]=t,e)}var yn=function(t){function e(e){t.call(this);var i=function(t){var e=null;void 0!==t.keyboardEventTarget&&(e="string"==typeof t.keyboardEventTarget?document.getElementById(t.keyboardEventTarget):t.keyboardEventTarget);var i,r,n,o={},s=t.layers&&"function"==typeof t.layers.getLayers?t.layers:new gn({layers:t.layers});o[Jt.LAYERGROUP]=s,o[Jt.TARGET]=t.target,o[Jt.VIEW]=void 0!==t.view?t.view:new nn,void 0!==t.controls&&(Array.isArray(t.controls)?i=new Y(t.controls.slice()):(te("function"==typeof t.controls.getArray,47),i=t.controls));void 0!==t.interactions&&(Array.isArray(t.interactions)?r=new Y(t.interactions.slice()):(te("function"==typeof t.interactions.getArray,48),r=t.interactions));void 0!==t.overlays?Array.isArray(t.overlays)?n=new Y(t.overlays.slice()):(te("function"==typeof t.overlays.getArray,49),n=t.overlays):n=new Y;return{controls:i,interactions:r,keyboardEventTarget:e,overlays:n,values:o}}(e);this.maxTilesLoading_=void 0!==e.maxTilesLoading?e.maxTilesLoading:16,this.loadTilesWhileAnimating_=void 0!==e.loadTilesWhileAnimating&&e.loadTilesWhileAnimating,this.loadTilesWhileInteracting_=void 0!==e.loadTilesWhileInteracting&&e.loadTilesWhileInteracting,this.pixelRatio_=void 0!==e.pixelRatio?e.pixelRatio:z,this.animationDelayKey_,this.animationDelay_=function(){this.animationDelayKey_=void 0,this.renderFrame_.call(this,Date.now())}.bind(this),this.coordinateToPixelTransform_=[1,0,0,1,0,0],this.pixelToCoordinateTransform_=[1,0,0,1,0,0],this.frameIndex_=0,this.frameState_=null,this.previousExtent_=null,this.viewPropertyListenerKey_=null,this.viewChangeListenerKey_=null,this.layerGroupPropertyListenerKeys_=null,this.viewport_=document.createElement("div"),this.viewport_.className="ol-viewport"+(H?" ol-touch":""),this.viewport_.style.position="relative",this.viewport_.style.overflow="hidden",this.viewport_.style.width="100%",this.viewport_.style.height="100%",this.viewport_.style.msTouchAction="none",this.viewport_.style.touchAction="none",this.overlayContainer_=document.createElement("div"),this.overlayContainer_.className="ol-overlaycontainer",this.viewport_.appendChild(this.overlayContainer_),this.overlayContainerStopEvent_=document.createElement("div"),this.overlayContainerStopEvent_.className="ol-overlaycontainer-stopevent";for(var r=[M.CLICK,M.DBLCLICK,M.MOUSEDOWN,M.TOUCHSTART,M.MSPOINTERDOWN,Q.POINTERDOWN,M.MOUSEWHEEL,M.WHEEL],n=0,o=r.length;n<o;++n)v(this.overlayContainerStopEvent_,r[n],O);for(var s in this.viewport_.appendChild(this.overlayContainerStopEvent_),this.mapBrowserEventHandler_=new Ht(this,e.moveTolerance),Q)v(this.mapBrowserEventHandler_,Q[s],this.handleMapBrowserEvent,this);this.keyboardEventTarget_=i.keyboardEventTarget,this.keyHandlerKeys_=null,v(this.viewport_,M.CONTEXTMENU,this.handleBrowserEvent,this),v(this.viewport_,M.WHEEL,this.handleBrowserEvent,this),v(this.viewport_,M.MOUSEWHEEL,this.handleBrowserEvent,this),this.controls=i.controls||new Y,this.interactions=i.interactions||new Y,this.overlays_=i.overlays,this.overlayIdIndex_={},this.renderer_=this.createRenderer(),this.handleResize_,this.focus_=null,this.postRenderFunctions_=[],this.tileQueue_=new ie(this.getTilePriority.bind(this),this.handleTileChange_.bind(this)),this.skippedFeatureUids_={},v(this,A(Jt.LAYERGROUP),this.handleLayerGroupChanged_,this),v(this,A(Jt.VIEW),this.handleViewChanged_,this),v(this,A(Jt.SIZE),this.handleSizeChanged_,this),v(this,A(Jt.TARGET),this.handleTargetChanged_,this),this.setProperties(i.values),this.controls.forEach(function(t){t.setMap(this)}.bind(this)),v(this.controls,h.ADD,function(t){t.element.setMap(this)},this),v(this.controls,h.REMOVE,function(t){t.element.setMap(null)},this),this.interactions.forEach(function(t){t.setMap(this)}.bind(this)),v(this.interactions,h.ADD,function(t){t.element.setMap(this)},this),v(this.interactions,h.REMOVE,function(t){t.element.setMap(null)},this),this.overlays_.forEach(this.addOverlayInternal_.bind(this)),v(this.overlays_,h.ADD,function(t){this.addOverlayInternal_(t.element)},this),v(this.overlays_,h.REMOVE,function(t){var e=t.element.getId();void 0!==e&&delete this.overlayIdIndex_[e.toString()],t.element.setMap(null)},this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createRenderer=function(){throw new Error("Use a map type that has a createRenderer method")},e.prototype.addControl=function(t){this.getControls().push(t)},e.prototype.addInteraction=function(t){this.getInteractions().push(t)},e.prototype.addLayer=function(t){this.getLayerGroup().getLayers().push(t)},e.prototype.addOverlay=function(t){this.getOverlays().push(t)},e.prototype.addOverlayInternal_=function(t){var e=t.getId();void 0!==e&&(this.overlayIdIndex_[e.toString()]=t),t.setMap(this)},e.prototype.disposeInternal=function(){this.mapBrowserEventHandler_.dispose(),E(this.viewport_,M.CONTEXTMENU,this.handleBrowserEvent,this),E(this.viewport_,M.WHEEL,this.handleBrowserEvent,this),E(this.viewport_,M.MOUSEWHEEL,this.handleBrowserEvent,this),void 0!==this.handleResize_&&(removeEventListener(M.RESIZE,this.handleResize_,!1),this.handleResize_=void 0),this.animationDelayKey_&&(cancelAnimationFrame(this.animationDelayKey_),this.animationDelayKey_=void 0),this.setTarget(null),t.prototype.disposeInternal.call(this)},e.prototype.forEachFeatureAtPixel=function(t,e,i){if(this.frameState_){var r=this.getCoordinateFromPixel(t),n=void 0!==(i=void 0!==i?i:{}).hitTolerance?i.hitTolerance*this.frameState_.pixelRatio:0,o=void 0!==i.layerFilter?i.layerFilter:R;return this.renderer_.forEachFeatureAtCoordinate(r,this.frameState_,n,e,null,o,null)}},e.prototype.getFeaturesAtPixel=function(t,e){var i=null;return this.forEachFeatureAtPixel(t,function(t){i||(i=[]),i.push(t)},e),i},e.prototype.forEachLayerAtPixel=function(t,e,i){if(this.frameState_){var r=i||{},n=void 0!==r.hitTolerance?i.hitTolerance*this.frameState_.pixelRatio:0,o=r.layerFilter||R;return this.renderer_.forEachLayerAtPixel(t,this.frameState_,n,e,null,o,null)}},e.prototype.hasFeatureAtPixel=function(t,e){if(!this.frameState_)return!1;var i=this.getCoordinateFromPixel(t),r=void 0!==(e=void 0!==e?e:{}).layerFilter?e.layerFilter:R,n=void 0!==e.hitTolerance?e.hitTolerance*this.frameState_.pixelRatio:0;return this.renderer_.hasFeatureAtCoordinate(i,this.frameState_,n,r,null)},e.prototype.getEventCoordinate=function(t){return this.getCoordinateFromPixel(this.getEventPixel(t))},e.prototype.getEventPixel=function(t){var e=this.viewport_.getBoundingClientRect(),i="changedTouches"in t?t.changedTouches[0]:t;return[i.clientX-e.left,i.clientY-e.top]},e.prototype.getTarget=function(){return this.get(Jt.TARGET)},e.prototype.getTargetElement=function(){var t=this.getTarget();return void 0!==t?"string"==typeof t?document.getElementById(t):t:null},e.prototype.getCoordinateFromPixel=function(t){var e=this.frameState_;return e?lr(e.pixelToCoordinateTransform,t.slice()):null},e.prototype.getControls=function(){return this.controls},e.prototype.getOverlays=function(){return this.overlays_},e.prototype.getOverlayById=function(t){var e=this.overlayIdIndex_[t.toString()];return void 0!==e?e:null},e.prototype.getInteractions=function(){return this.interactions},e.prototype.getLayerGroup=function(){return this.get(Jt.LAYERGROUP)},e.prototype.getLayers=function(){return this.getLayerGroup().getLayers()},e.prototype.getPixelFromCoordinate=function(t){var e=this.frameState_;return e?lr(e.coordinateToPixelTransform,t.slice(0,2)):null},e.prototype.getRenderer=function(){return this.renderer_},e.prototype.getSize=function(){return this.get(Jt.SIZE)},e.prototype.getView=function(){return this.get(Jt.VIEW)},e.prototype.getViewport=function(){return this.viewport_},e.prototype.getOverlayContainer=function(){return this.overlayContainer_},e.prototype.getOverlayContainerStopEvent=function(){return this.overlayContainerStopEvent_},e.prototype.getTilePriority=function(t,e,i,r){var n=this.frameState_;if(!(n&&e in n.wantedTiles))return 1/0;if(!n.wantedTiles[e][t.getKey()])return 1/0;var o=i[0]-n.focus[0],s=i[1]-n.focus[1];return 65536*Math.log(r)+Math.sqrt(o*o+s*s)/r},e.prototype.handleBrowserEvent=function(t,e){var i=e||t.type,r=new j(i,this,t);this.handleMapBrowserEvent(r)},e.prototype.handleMapBrowserEvent=function(t){if(this.frameState_){this.focus_=t.coordinate,t.frameState=this.frameState_;var e=this.getInteractions().getArray();if(!1!==this.dispatchEvent(t))for(var i=e.length-1;i>=0;i--){var r=e[i];if(r.getActive())if(!r.handleEvent(t))break}}},e.prototype.handlePostRender=function(){var t=this.frameState_,e=this.tileQueue_;if(!e.isEmpty()){var i=this.maxTilesLoading_,r=i;if(t){var n=t.viewHints;n[ge]&&(i=this.loadTilesWhileAnimating_?8:0,r=2),n[_e]&&(i=this.loadTilesWhileInteracting_?8:0,r=2)}e.getTilesLoading()<i&&(e.reprioritize(),e.loadMoreTiles(i,r))}!t||!this.hasListener(Qt.RENDERCOMPLETE)||t.animate||this.tileQueue_.getTilesLoading()||function t(e){for(var i=0,r=e.length;i<r;++i){var n=e[i];if("function"==typeof n.getLayers)return t(n.getLayers().getArray());var o=n.getSource();if(o&&o.loading)return!0}return!1}(this.getLayers().getArray())||this.renderer_.dispatchRenderEvent(Qt.RENDERCOMPLETE,t);for(var o=this.postRenderFunctions_,s=0,a=o.length;s<a;++s)o[s](this,t);o.length=0},e.prototype.handleSizeChanged_=function(){this.render()},e.prototype.handleTargetChanged_=function(){var t;if(this.getTarget()&&(t=this.getTargetElement()),this.keyHandlerKeys_){for(var e=0,i=this.keyHandlerKeys_.length;e<i;++e)S(this.keyHandlerKeys_[e]);this.keyHandlerKeys_=null}if(t){t.appendChild(this.viewport_);var r=this.keyboardEventTarget_?this.keyboardEventTarget_:t;this.keyHandlerKeys_=[v(r,M.KEYDOWN,this.handleBrowserEvent,this),v(r,M.KEYPRESS,this.handleBrowserEvent,this)],this.handleResize_||(this.handleResize_=this.updateSize.bind(this),window.addEventListener(M.RESIZE,this.handleResize_,!1))}else this.renderer_.removeLayerRenderers(),ln(this.viewport_),void 0!==this.handleResize_&&(removeEventListener(M.RESIZE,this.handleResize_,!1),this.handleResize_=void 0);this.updateSize()},e.prototype.handleTileChange_=function(){this.render()},e.prototype.handleViewPropertyChanged_=function(){this.render()},e.prototype.handleViewChanged_=function(){this.viewPropertyListenerKey_&&(S(this.viewPropertyListenerKey_),this.viewPropertyListenerKey_=null),this.viewChangeListenerKey_&&(S(this.viewChangeListenerKey_),this.viewChangeListenerKey_=null);var t=this.getView();t&&(this.viewport_.setAttribute("data-view",o(t)),this.viewPropertyListenerKey_=v(t,l,this.handleViewPropertyChanged_,this),this.viewChangeListenerKey_=v(t,M.CHANGE,this.handleViewPropertyChanged_,this)),this.render()},e.prototype.handleLayerGroupChanged_=function(){this.layerGroupPropertyListenerKeys_&&(this.layerGroupPropertyListenerKeys_.forEach(S),this.layerGroupPropertyListenerKeys_=null);var t=this.getLayerGroup();t&&(this.layerGroupPropertyListenerKeys_=[v(t,l,this.render,this),v(t,M.CHANGE,this.render,this)]),this.render()},e.prototype.isRendered=function(){return!!this.frameState_},e.prototype.renderSync=function(){this.animationDelayKey_&&cancelAnimationFrame(this.animationDelayKey_),this.animationDelay_()},e.prototype.render=function(){void 0===this.animationDelayKey_&&(this.animationDelayKey_=requestAnimationFrame(this.animationDelay_))},e.prototype.removeControl=function(t){return this.getControls().remove(t)},e.prototype.removeInteraction=function(t){return this.getInteractions().remove(t)},e.prototype.removeLayer=function(t){return this.getLayerGroup().getLayers().remove(t)},e.prototype.removeOverlay=function(t){return this.getOverlays().remove(t)},e.prototype.renderFrame_=function(t){var e,i=this.getSize(),r=this.getView(),n=[1/0,1/0,-1/0,-1/0],s=this.frameState_,a=null;if(void 0!==i&&function(t){return t[0]>0&&t[1]>0}(i)&&r&&r.isDef()){for(var h=r.getHints(this.frameState_?this.frameState_.viewHints:void 0),l=this.getLayerGroup().getLayerStatesArray(),u={},p=0,c=l.length;p<c;++p)u[o(l[p].layer)]=l[p];e=r.getState(this.pixelRatio_),a={animate:!1,coordinateToPixelTransform:this.coordinateToPixelTransform_,extent:n,focus:this.focus_?this.focus_:e.center,index:this.frameIndex_++,layerStates:u,layerStatesArray:l,pixelRatio:this.pixelRatio_,pixelToCoordinateTransform:this.pixelToCoordinateTransform_,postRenderFunctions:[],size:i,skippedFeatureUids:this.skippedFeatureUids_,tileQueue:this.tileQueue_,time:t,usedTiles:{},viewState:e,viewHints:h,wantedTiles:{}}}if(a&&(a.extent=si(e.center,e.resolution,e.rotation,a.size,n)),this.frameState_=a,this.renderer_.renderFrame(a),a){if(a.animate&&this.render(),Array.prototype.push.apply(this.postRenderFunctions_,a.postRenderFunctions),s)(!this.previousExtent_||!di(this.previousExtent_)&&!Ze(a.extent,this.previousExtent_))&&(this.dispatchEvent(new U(qt.MOVESTART,this,s)),this.previousExtent_=We(this.previousExtent_));this.previousExtent_&&!a.viewHints[ge]&&!a.viewHints[_e]&&!Ze(a.extent,this.previousExtent_)&&(this.dispatchEvent(new U(qt.MOVEEND,this,a)),De(a.extent,this.previousExtent_))}this.dispatchEvent(new U(qt.POSTRENDER,this,a)),setTimeout(this.handlePostRender.bind(this),0)},e.prototype.setLayerGroup=function(t){this.set(Jt.LAYERGROUP,t)},e.prototype.setSize=function(t){this.set(Jt.SIZE,t)},e.prototype.setTarget=function(t){this.set(Jt.TARGET,t)},e.prototype.setView=function(t){this.set(Jt.VIEW,t)},e.prototype.skipFeature=function(t){this.skippedFeatureUids_[o(t)]=!0,this.render()},e.prototype.updateSize=function(){var t=this.getTargetElement();if(t){var e=getComputedStyle(t);this.setSize([t.offsetWidth-parseFloat(e.borderLeftWidth)-parseFloat(e.paddingLeft)-parseFloat(e.paddingRight)-parseFloat(e.borderRightWidth),t.offsetHeight-parseFloat(e.borderTopWidth)-parseFloat(e.paddingTop)-parseFloat(e.paddingBottom)-parseFloat(e.borderBottomWidth)])}else this.setSize(void 0)},e.prototype.unskipFeature=function(t){delete this.skippedFeatureUids_[o(t)],this.render()},e}(G);var vn,mn,En=function(t){function e(e){t.call(this),this.element=e.element?e.element:null,this.target_=null,this.map_=null,this.listenerKeys=[],this.render=e.render?e.render:w,e.target&&this.setTarget(e.target)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){ln(this.element),t.prototype.disposeInternal.call(this)},e.prototype.getMap=function(){return this.map_},e.prototype.setMap=function(t){this.map_&&ln(this.element);for(var e=0,i=this.listenerKeys.length;e<i;++e)S(this.listenerKeys[e]);(this.listenerKeys.length=0,this.map_=t,this.map_)&&((this.target_?this.target_:t.getOverlayContainerStopEvent()).appendChild(this.element),this.render!==w&&this.listenerKeys.push(v(t,qt.POSTRENDER,this.render,this)),t.render())},e.prototype.setTarget=function(t){this.target_="string"==typeof t?document.getElementById(t):t},e}(G),Sn="ol-hidden",Tn="ol-selectable",Cn="ol-unselectable",Rn="ol-control",xn="ol-collapsed",wn=(mn={},function(t){if(vn||(vn=document.createElement("div").style),!(t in mn)){vn.font=t;var e=vn.fontFamily;if(vn.font="",!e)return null;mn[t]=e.split(/,\s?/)}return mn[t]});function In(t,e){return t.visible&&e>=t.minResolution&&e<t.maxResolution}var On=function(t){function e(e){var i=u({},e);delete i.source,t.call(this,i),this.mapPrecomposeKey_=null,this.mapRenderKey_=null,this.sourceChangeKey_=null,e.map&&this.setMap(e.map),v(this,A(pn.SOURCE),this.handleSourcePropertyChange_,this);var r=e.source?e.source:null;this.setSource(r)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getLayersArray=function(t){var e=t||[];return e.push(this),e},e.prototype.getLayerStatesArray=function(t){var e=t||[];return e.push(this.getLayerState()),e},e.prototype.getSource=function(){return this.get(pn.SOURCE)||null},e.prototype.getSourceState=function(){var t=this.getSource();return t?t.getState():dn.UNDEFINED},e.prototype.handleSourceChange_=function(){this.changed()},e.prototype.handleSourcePropertyChange_=function(){this.sourceChangeKey_&&(S(this.sourceChangeKey_),this.sourceChangeKey_=null);var t=this.getSource();t&&(this.sourceChangeKey_=v(t,M.CHANGE,this.handleSourceChange_,this)),this.changed()},e.prototype.setMap=function(t){this.mapPrecomposeKey_&&(S(this.mapPrecomposeKey_),this.mapPrecomposeKey_=null),t||this.changed(),this.mapRenderKey_&&(S(this.mapRenderKey_),this.mapRenderKey_=null),t&&(this.mapPrecomposeKey_=v(t,Qt.PRECOMPOSE,function(t){var e=t,i=this.getLayerState();i.managed=!1,void 0===this.getZIndex()&&(i.zIndex=1/0),e.frameState.layerStatesArray.push(i),e.frameState.layerStates[o(this)]=i},this),this.mapRenderKey_=v(this,M.CHANGE,t.render,t),this.changed())},e.prototype.setSource=function(t){this.set(pn.SOURCE,t)},e}(cn);function Ln(t){this.updateElement_(t.frameState)}var Pn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Ln,target:i.target}),this.ulElement_=document.createElement("ul"),this.collapsed_=void 0===i.collapsed||i.collapsed,this.overrideCollapsible_=void 0!==i.collapsible,this.collapsible_=void 0===i.collapsible||i.collapsible,this.collapsible_||(this.collapsed_=!1);var r=void 0!==i.className?i.className:"ol-attribution",n=void 0!==i.tipLabel?i.tipLabel:"Attributions",o=void 0!==i.collapseLabel?i.collapseLabel:"»";"string"==typeof o?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=o):this.collapseLabel_=o;var s=void 0!==i.label?i.label:"i";"string"==typeof s?(this.label_=document.createElement("span"),this.label_.textContent=s):this.label_=s;var a=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_,h=document.createElement("button");h.setAttribute("type","button"),h.title=n,h.appendChild(a),v(h,M.CLICK,this.handleClick_,this);var l=r+" "+Cn+" "+Rn+(this.collapsed_&&this.collapsible_?" "+xn:"")+(this.collapsible_?"":" ol-uncollapsible"),u=this.element;u.className=l,u.appendChild(this.ulElement_),u.appendChild(h),this.renderedAttributions_=[],this.renderedVisible_=!0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.collectSourceAttributions_=function(t){for(var e={},i=[],r=t.layerStatesArray,n=t.viewState.resolution,o=0,s=r.length;o<s;++o){var a=r[o];if(In(a,n)){var h=a.layer.getSource();if(h){var l=h.getAttributions();if(l){var u=l(t);if(u)if(this.overrideCollapsible_||!1!==h.getAttributionsCollapsible()||this.setCollapsible(!1),Array.isArray(u))for(var p=0,c=u.length;p<c;++p)u[p]in e||(i.push(u[p]),e[u[p]]=!0);else u in e||(i.push(u),e[u]=!0)}}}}return i},e.prototype.updateElement_=function(t){if(t){var e=this.collectSourceAttributions_(t),i=e.length>0;if(this.renderedVisible_!=i&&(this.element.style.display=i?"":"none",this.renderedVisible_=i),!Ut(e,this.renderedAttributions_)){un(this.ulElement_);for(var r=0,n=e.length;r<n;++r){var o=document.createElement("li");o.innerHTML=e[r],this.ulElement_.appendChild(o)}this.renderedAttributions_=e}}else this.renderedVisible_&&(this.element.style.display="none",this.renderedVisible_=!1)},e.prototype.handleClick_=function(t){t.preventDefault(),this.handleToggle_()},e.prototype.handleToggle_=function(){this.element.classList.toggle(xn),this.collapsed_?hn(this.collapseLabel_,this.label_):hn(this.label_,this.collapseLabel_),this.collapsed_=!this.collapsed_},e.prototype.getCollapsible=function(){return this.collapsible_},e.prototype.setCollapsible=function(t){this.collapsible_!==t&&(this.collapsible_=t,this.element.classList.toggle("ol-uncollapsible"),!t&&this.collapsed_&&this.handleToggle_())},e.prototype.setCollapsed=function(t){this.collapsible_&&this.collapsed_!==t&&this.handleToggle_()},e.prototype.getCollapsed=function(){return this.collapsed_},e}(En);function Mn(t){var e=t.frameState;if(e){var i=e.viewState.rotation;if(i!=this.rotation_){var r="rotate("+i+"rad)";if(this.autoHide_){var n=this.element.classList.contains(Sn);n||0!==i?n&&0!==i&&this.element.classList.remove(Sn):this.element.classList.add(Sn)}this.label_.style.msTransform=r,this.label_.style.webkitTransform=r,this.label_.style.transform=r}this.rotation_=i}}var Fn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Mn,target:i.target});var r=void 0!==i.className?i.className:"ol-rotate",n=void 0!==i.label?i.label:"⇧";this.label_=null,"string"==typeof n?(this.label_=document.createElement("span"),this.label_.className="ol-compass",this.label_.textContent=n):(this.label_=n,this.label_.classList.add("ol-compass"));var o=i.tipLabel?i.tipLabel:"Reset rotation",s=document.createElement("button");s.className=r+"-reset",s.setAttribute("type","button"),s.title=o,s.appendChild(this.label_),v(s,M.CLICK,this.handleClick_,this);var a=r+" "+Cn+" "+Rn,h=this.element;h.className=a,h.appendChild(s),this.callResetNorth_=i.resetNorth?i.resetNorth:void 0,this.duration_=void 0!==i.duration?i.duration:250,this.autoHide_=void 0===i.autoHide||i.autoHide,this.rotation_=void 0,this.autoHide_&&this.element.classList.add(Sn)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t){t.preventDefault(),void 0!==this.callResetNorth_?this.callResetNorth_():this.resetNorth_()},e.prototype.resetNorth_=function(){var t=this.getMap().getView();t&&void 0!==t.getRotation()&&(this.duration_>0?t.animate({rotation:0,duration:this.duration_,easing:Pe}):t.setRotation(0))},e}(En),bn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),target:i.target});var r=void 0!==i.className?i.className:"ol-zoom",n=void 0!==i.delta?i.delta:1,o=void 0!==i.zoomInLabel?i.zoomInLabel:"+",s=void 0!==i.zoomOutLabel?i.zoomOutLabel:"−",a=void 0!==i.zoomInTipLabel?i.zoomInTipLabel:"Zoom in",h=void 0!==i.zoomOutTipLabel?i.zoomOutTipLabel:"Zoom out",l=document.createElement("button");l.className=r+"-in",l.setAttribute("type","button"),l.title=a,l.appendChild("string"==typeof o?document.createTextNode(o):o),v(l,M.CLICK,this.handleClick_.bind(this,n));var u=document.createElement("button");u.className=r+"-out",u.setAttribute("type","button"),u.title=h,u.appendChild("string"==typeof s?document.createTextNode(s):s),v(u,M.CLICK,this.handleClick_.bind(this,-n));var p=r+" "+Cn+" "+Rn,c=this.element;c.className=p,c.appendChild(l),c.appendChild(u),this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t,e){e.preventDefault(),this.zoomByDelta_(t)},e.prototype.zoomByDelta_=function(t){var e=this.getMap().getView();if(e){var i=e.getResolution();if(i){var r=e.constrainResolution(i,t);this.duration_>0?(e.getAnimating()&&e.cancelAnimations(),e.animate({resolution:r,duration:this.duration_,easing:Pe})):e.setResolution(r)}}},e}(En);var Nn=function(t,e,i){this.decay_=t,this.minVelocity_=e,this.delay_=i,this.points_=[],this.angle_=0,this.initialVelocity_=0};Nn.prototype.begin=function(){this.points_.length=0,this.angle_=0,this.initialVelocity_=0},Nn.prototype.update=function(t,e){this.points_.push(t,e,Date.now())},Nn.prototype.end=function(){if(this.points_.length<6)return!1;var t=Date.now()-this.delay_,e=this.points_.length-3;if(this.points_[e+2]<t)return!1;for(var i=e-3;i>0&&this.points_[i+2]>t;)i-=3;var r=this.points_[e+2]-this.points_[i+2];if(r<1e3/60)return!1;var n=this.points_[e]-this.points_[i],o=this.points_[e+1]-this.points_[i+1];return this.angle_=Math.atan2(o,n),this.initialVelocity_=Math.sqrt(n*n+o*o)/r,this.initialVelocity_>this.minVelocity_},Nn.prototype.getDistance=function(){return(this.minVelocity_-this.initialVelocity_)/this.decay_},Nn.prototype.getAngle=function(){return this.angle_};var An=Nn,Gn={ACTIVE:"active"};function Dn(t,e,i,r){e=t.constrainRotation(e,0),kn(t,e,i,r)}function kn(t,e,i,r){if(void 0!==e){var n=t.getRotation(),o=t.getCenter();void 0!==n&&o&&r>0?t.animate({rotation:e,anchor:i,duration:r,easing:Pe}):t.rotate(e,i)}}function Yn(t,e,i,r){var n=t.getResolution(),o=t.constrainResolution(n,e,0);if(void 0!==o){var s=t.getResolutions();o=oe(o,t.getMinResolution()||s[s.length-1],t.getMaxResolution()||s[0])}if(i&&void 0!==o&&o!==n){var a=t.getCenter(),h=t.calculateCenterZoom(o,i);h=t.constrainCenter(h),i=[(o*a[0]-n*h[0])/(o-n),(o*a[1]-n*h[1])/(o-n)]}Un(t,o,i,r)}function Un(t,e,i,r){if(e){var n=t.getResolution(),o=t.getCenter();if(void 0!==n&&o&&e!==n&&r)t.animate({resolution:e,anchor:i,duration:r,easing:Pe});else{if(i){var s=t.calculateCenterZoom(e,i);t.setCenter(s)}t.setResolution(e)}}}var jn=function(t){function e(e){t.call(this),e.handleEvent&&(this.handleEvent=e.handleEvent),this.map_=null,this.setActive(!0)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getActive=function(){return this.get(Gn.ACTIVE)},e.prototype.getMap=function(){return this.map_},e.prototype.handleEvent=function(t){return!0},e.prototype.setActive=function(t){this.set(Gn.ACTIVE,t)},e.prototype.setMap=function(t){this.map_=t},e}(G);function Xn(t){var e=!1;if(t.type==Q.DBLCLICK){var i=t.originalEvent,r=t.map,n=t.coordinate,o=i.shiftKey?-this.delta_:this.delta_;Yn(r.getView(),o,n,this.duration_),t.preventDefault(),e=!0}return!e}var Bn=function(t){function e(e){t.call(this,{handleEvent:Xn});var i=e||{};this.delta_=i.delta?i.delta:1,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn),Vn=function(t){var e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey},Wn=function(t){var e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},Kn=function(t){return t.target.getTargetElement()===document.activeElement},zn=R,Zn=function(t){var e=t.originalEvent;return 0==e.button&&!(W&&K&&e.ctrlKey)},Hn=x,qn=function(t){return"pointermove"==t.type},Jn=function(t){return t.type==Q.SINGLECLICK},Qn=function(t){var e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey},$n=function(t){var e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},to=function(t){var e=t.originalEvent.target.tagName;return"INPUT"!==e&&"SELECT"!==e&&"TEXTAREA"!==e},eo=function(t){var e=t.pointerEvent;return te(void 0!==e,56),"mouse"==e.pointerType},io=function(t){var e=t.pointerEvent;return te(void 0!==e,56),e.isPrimary&&0===e.button};function ro(t){for(var e=t.length,i=0,r=0,n=0;n<e;n++)i+=t[n].clientX,r+=t[n].clientY;return[i/e,r/e]}var no=function(t){function e(e){var i=e||{};t.call(this,i),i.handleDownEvent&&(this.handleDownEvent=i.handleDownEvent),i.handleDragEvent&&(this.handleDragEvent=i.handleDragEvent),i.handleMoveEvent&&(this.handleMoveEvent=i.handleMoveEvent),i.handleUpEvent&&(this.handleUpEvent=i.handleUpEvent),i.stopDown&&(this.stopDown=i.stopDown),this.handlingDownUpSequence=!1,this.trackedPointers_={},this.targetPointers=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDownEvent=function(t){return!1},e.prototype.handleDragEvent=function(t){},e.prototype.handleEvent=function(t){if(!t.pointerEvent)return!0;var e=!1;if(this.updateTrackedPointers_(t),this.handlingDownUpSequence){if(t.type==Q.POINTERDRAG)this.handleDragEvent(t);else if(t.type==Q.POINTERUP){var i=this.handleUpEvent(t);this.handlingDownUpSequence=i&&this.targetPointers.length>0}}else if(t.type==Q.POINTERDOWN){var r=this.handleDownEvent(t);r&&t.preventDefault(),this.handlingDownUpSequence=r,e=this.stopDown(r)}else t.type==Q.POINTERMOVE&&this.handleMoveEvent(t);return!e},e.prototype.handleMoveEvent=function(t){},e.prototype.handleUpEvent=function(t){return!1},e.prototype.stopDown=function(t){return t},e.prototype.updateTrackedPointers_=function(t){if(function(t){var e=t.type;return e===Q.POINTERDOWN||e===Q.POINTERDRAG||e===Q.POINTERUP}(t)){var e=t.pointerEvent,i=e.pointerId.toString();t.type==Q.POINTERUP?delete this.trackedPointers_[i]:t.type==Q.POINTERDOWN?this.trackedPointers_[i]=e:i in this.trackedPointers_&&(this.trackedPointers_[i]=e),this.targetPointers=c(this.trackedPointers_)}},e}(jn),oo=function(t){function e(e){t.call(this,{stopDown:x});var i=e||{};this.kinetic_=i.kinetic,this.lastCentroid=null,this.lastPointersCount_,this.panning_=!1,this.condition_=i.condition?i.condition:Qn,this.noKinetic_=!1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){this.panning_||(this.panning_=!0,this.getMap().getView().setHint(_e,1));var e=this.targetPointers,i=ro(e);if(e.length==this.lastPointersCount_){if(this.kinetic_&&this.kinetic_.update(i[0],i[1]),this.lastCentroid){var r=this.lastCentroid[0]-i[0],n=i[1]-this.lastCentroid[1],o=t.map.getView(),s=[r,n];xe(s,o.getResolution()),Re(s,o.getRotation()),Se(s,o.getCenter()),s=o.constrainCenter(s),o.setCenter(s)}}else this.kinetic_&&this.kinetic_.begin();this.lastCentroid=i,this.lastPointersCount_=e.length},e.prototype.handleUpEvent=function(t){var e=t.map,i=e.getView();if(0===this.targetPointers.length){if(!this.noKinetic_&&this.kinetic_&&this.kinetic_.end()){var r=this.kinetic_.getDistance(),n=this.kinetic_.getAngle(),o=i.getCenter(),s=e.getPixelFromCoordinate(o),a=e.getCoordinateFromPixel([s[0]-r*Math.cos(n),s[1]-r*Math.sin(n)]);i.animate({center:i.constrainCenter(a),duration:500,easing:Pe})}return this.panning_&&(this.panning_=!1,i.setHint(_e,-1)),!1}return this.kinetic_&&this.kinetic_.begin(),this.lastCentroid=null,!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>0&&this.condition_(t)){var e=t.map.getView();return this.lastCentroid=null,e.getAnimating()&&e.setCenter(t.frameState.viewState.center),this.kinetic_&&this.kinetic_.begin(),this.noKinetic_=this.targetPointers.length>1,!0}return!1},e}(no),so=function(t){function e(e){var i=e||{};t.call(this,{stopDown:x}),this.condition_=i.condition?i.condition:Wn,this.lastAngle_=void 0,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){if(eo(t)){var e=t.map,i=e.getView();if(i.getConstraints().rotation!==de){var r=e.getSize(),n=t.pixel,o=Math.atan2(r[1]/2-n[1],n[0]-r[0]/2);if(void 0!==this.lastAngle_){var s=o-this.lastAngle_,a=i.getRotation();kn(i,a-s)}this.lastAngle_=o}}},e.prototype.handleUpEvent=function(t){if(!eo(t))return!0;var e=t.map.getView();e.setHint(_e,-1);var i=e.getRotation();return Dn(e,i,void 0,this.duration_),!1},e.prototype.handleDownEvent=function(t){return!!eo(t)&&(!(!Zn(t)||!this.condition_(t))&&(t.map.getView().setHint(_e,1),this.lastAngle_=void 0,!0))},e}(no),ao=function(t){function e(e){t.call(this),this.geometry_=null,this.element_=document.createElement("div"),this.element_.style.position="absolute",this.element_.className="ol-box "+e,this.map_=null,this.startPixel_=null,this.endPixel_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.setMap(null)},e.prototype.render_=function(){var t=this.startPixel_,e=this.endPixel_,i=this.element_.style;i.left=Math.min(t[0],e[0])+"px",i.top=Math.min(t[1],e[1])+"px",i.width=Math.abs(e[0]-t[0])+"px",i.height=Math.abs(e[1]-t[1])+"px"},e.prototype.setMap=function(t){if(this.map_){this.map_.getOverlayContainer().removeChild(this.element_);var e=this.element_.style;e.left=e.top=e.width=e.height="inherit"}this.map_=t,this.map_&&this.map_.getOverlayContainer().appendChild(this.element_)},e.prototype.setPixels=function(t,e){this.startPixel_=t,this.endPixel_=e,this.createOrUpdateGeometry(),this.render_()},e.prototype.createOrUpdateGeometry=function(){var t=this.startPixel_,e=this.endPixel_,i=[t,[t[0],e[1]],e,[e[0],t[1]]].map(this.map_.getCoordinateFromPixel,this.map_);i[4]=i[0].slice(),this.geometry_?this.geometry_.setCoordinates([i]):this.geometry_=new qr([i])},e.prototype.getGeometry=function(){return this.geometry_},e}(C),ho="boxstart",lo="boxdrag",uo="boxend",po=function(t){function e(e,i,r){t.call(this,e),this.coordinate=i,this.mapBrowserEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function co(){var t,e,i=this.getMap(),r=i.getView(),n=i.getSize(),o=this.getGeometry().getExtent();if(this.out_){var s=r.calculateExtent(n),a=(t=[i.getPixelFromCoordinate(ii(o)),i.getPixelFromCoordinate(ui(o))],Je(We(e),t));fi(s,1/r.getResolutionForExtent(a,n)),o=s}var h=r.constrainResolution(r.getResolutionForExtent(o,n)),l=ni(o);l=r.constrainCenter(l),r.animate({resolution:h,center:l,duration:this.duration_,easing:Pe})}var fo=function(t){function e(e){var i=e||{},r=i.condition?i.condition:$n;t.call(this,{condition:r,className:i.className||"ol-dragzoom",onBoxEnd:co}),this.duration_=void 0!==i.duration?i.duration:200,this.out_=void 0!==i.out&&i.out}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(function(t){function e(e){t.call(this);var i=e||{};this.box_=new ao(i.className||"ol-dragbox"),this.minArea_=void 0!==i.minArea?i.minArea:64,this.onBoxEnd_=i.onBoxEnd?i.onBoxEnd:w,this.startPixel_=null,this.condition_=i.condition?i.condition:zn,this.boxEndCondition_=i.boxEndCondition?i.boxEndCondition:this.defaultBoxEndCondition}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.defaultBoxEndCondition=function(t,e,i){var r=i[0]-e[0],n=i[1]-e[1];return r*r+n*n>=this.minArea_},e.prototype.getGeometry=function(){return this.box_.getGeometry()},e.prototype.handleDragEvent=function(t){eo(t)&&(this.box_.setPixels(this.startPixel_,t.pixel),this.dispatchEvent(new po(lo,t.coordinate,t)))},e.prototype.handleUpEvent=function(t){return!eo(t)||(this.box_.setMap(null),this.boxEndCondition_(t,this.startPixel_,t.pixel)&&(this.onBoxEnd_(t),this.dispatchEvent(new po(uo,t.coordinate,t))),!1)},e.prototype.handleDownEvent=function(t){return!!eo(t)&&(!(!Zn(t)||!this.condition_(t))&&(this.startPixel_=t.pixel,this.box_.setMap(t.map),this.box_.setPixels(this.startPixel_,this.startPixel_),this.dispatchEvent(new po(ho,t.coordinate,t)),!0))},e}(no)),go={LEFT:37,UP:38,RIGHT:39,DOWN:40};function _o(t){var e=!1;if(t.type==M.KEYDOWN){var i=t.originalEvent.keyCode;if(this.condition_(t)&&(i==go.DOWN||i==go.LEFT||i==go.RIGHT||i==go.UP)){var r=t.map.getView(),n=r.getResolution()*this.pixelDelta_,o=0,s=0;i==go.DOWN?s=-n:i==go.LEFT?o=-n:i==go.RIGHT?o=n:s=n;var a=[o,s];Re(a,r.getRotation()),function(t,e,i){var r=t.getCenter();if(r){var n=t.constrainCenter([r[0]+e[0],r[1]+e[1]]);i?t.animate({duration:i,easing:Fe,center:n}):t.setCenter(n)}}(r,a,this.duration_),t.preventDefault(),e=!0}}return!e}var yo=function(t){function e(e){t.call(this,{handleEvent:_o});var i=e||{};this.defaultCondition_=function(t){return Qn(t)&&to(t)},this.condition_=void 0!==i.condition?i.condition:this.defaultCondition_,this.duration_=void 0!==i.duration?i.duration:100,this.pixelDelta_=void 0!==i.pixelDelta?i.pixelDelta:128}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn);function vo(t){var e=!1;if(t.type==M.KEYDOWN||t.type==M.KEYPRESS){var i=t.originalEvent.charCode;if(this.condition_(t)&&(i=="+".charCodeAt(0)||i=="-".charCodeAt(0))){var r=t.map,n=i=="+".charCodeAt(0)?this.delta_:-this.delta_;Yn(r.getView(),n,void 0,this.duration_),t.preventDefault(),e=!0}}return!e}var mo=function(t){function e(e){t.call(this,{handleEvent:vo});var i=e||{};this.condition_=i.condition?i.condition:to,this.delta_=i.delta?i.delta:1,this.duration_=void 0!==i.duration?i.duration:100}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn),Eo="trackpad",So="wheel",To=function(t){function e(e){var i=e||{};t.call(this,i),this.delta_=0,this.duration_=void 0!==i.duration?i.duration:250,this.timeout_=void 0!==i.timeout?i.timeout:80,this.useAnchor_=void 0===i.useAnchor||i.useAnchor,this.constrainResolution_=i.constrainResolution||!1,this.condition_=i.condition?i.condition:zn,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_,this.mode_=void 0,this.trackpadEventGap_=400,this.trackpadTimeoutId_,this.trackpadDeltaPerZoom_=300,this.trackpadZoomBuffer_=1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.decrementInteractingHint_=function(){this.trackpadTimeoutId_=void 0,this.getMap().getView().setHint(_e,-1)},e.prototype.handleEvent=function(t){if(!this.condition_(t))return!0;var e=t.type;if(e!==M.WHEEL&&e!==M.MOUSEWHEEL)return!0;t.preventDefault();var i,r=t.map,n=t.originalEvent;if(this.useAnchor_&&(this.lastAnchor_=t.coordinate),t.type==M.WHEEL?(i=n.deltaY,B&&n.deltaMode===WheelEvent.DOM_DELTA_PIXEL&&(i/=z),n.deltaMode===WheelEvent.DOM_DELTA_LINE&&(i*=40)):t.type==M.MOUSEWHEEL&&(i=-n.wheelDeltaY,V&&(i/=3)),0===i)return!1;var o=Date.now();if(void 0===this.startTime_&&(this.startTime_=o),(!this.mode_||o-this.startTime_>this.trackpadEventGap_)&&(this.mode_=Math.abs(i)<4?Eo:So),this.mode_===Eo){var s=r.getView();this.trackpadTimeoutId_?clearTimeout(this.trackpadTimeoutId_):s.setHint(_e,1),this.trackpadTimeoutId_=setTimeout(this.decrementInteractingHint_.bind(this),this.trackpadEventGap_);var a=s.getResolution()*Math.pow(2,i/this.trackpadDeltaPerZoom_),h=s.getMinResolution(),l=s.getMaxResolution(),u=0;if(a<h?(a=Math.max(a,h/this.trackpadZoomBuffer_),u=1):a>l&&(a=Math.min(a,l*this.trackpadZoomBuffer_),u=-1),this.lastAnchor_){var p=s.calculateCenterZoom(a,this.lastAnchor_);s.setCenter(s.constrainCenter(p))}return s.setResolution(a),0===u&&this.constrainResolution_&&s.animate({resolution:s.constrainResolution(a,i>0?-1:1),easing:Pe,anchor:this.lastAnchor_,duration:this.duration_}),u>0?s.animate({resolution:h,easing:Pe,anchor:this.lastAnchor_,duration:500}):u<0&&s.animate({resolution:l,easing:Pe,anchor:this.lastAnchor_,duration:500}),this.startTime_=o,!1}this.delta_+=i;var c=Math.max(this.timeout_-(o-this.startTime_),0);return clearTimeout(this.timeoutId_),this.timeoutId_=setTimeout(this.handleWheelZoom_.bind(this,r),c),!1},e.prototype.handleWheelZoom_=function(t){var e=t.getView();e.getAnimating()&&e.cancelAnimations();Yn(e,-oe(this.delta_,-1,1),this.lastAnchor_,this.duration_),this.mode_=void 0,this.delta_=0,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_=void 0},e.prototype.setMouseAnchor=function(t){this.useAnchor_=t,t||(this.lastAnchor_=null)},e}(jn),Co=function(t){function e(e){var i=e||{},r=i;r.stopDown||(r.stopDown=x),t.call(this,r),this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.threshold_=void 0!==i.threshold?i.threshold:.3,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){var e=0,i=this.targetPointers[0],r=this.targetPointers[1],n=Math.atan2(r.clientY-i.clientY,r.clientX-i.clientX);if(void 0!==this.lastAngle_){var o=n-this.lastAngle_;this.rotationDelta_+=o,!this.rotating_&&Math.abs(this.rotationDelta_)>this.threshold_&&(this.rotating_=!0),e=o}this.lastAngle_=n;var s=t.map,a=s.getView();if(a.getConstraints().rotation!==de){var h=s.getViewport().getBoundingClientRect(),l=ro(this.targetPointers);if(l[0]-=h.left,l[1]-=h.top,this.anchor_=s.getCoordinateFromPixel(l),this.rotating_){var u=a.getRotation();s.render(),kn(a,u+e,this.anchor_)}}},e.prototype.handleUpEvent=function(t){if(this.targetPointers.length<2){var e=t.map.getView();if(e.setHint(_e,-1),this.rotating_){var i=e.getRotation();Dn(e,i,this.anchor_,this.duration_)}return!1}return!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>=2){var e=t.map;return this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.handlingDownUpSequence||e.getView().setHint(_e,1),!0}return!1},e}(no),Ro=function(t){function e(e){var i=e||{},r=i;r.stopDown||(r.stopDown=x),t.call(this,r),this.constrainResolution_=i.constrainResolution||!1,this.anchor_=null,this.duration_=void 0!==i.duration?i.duration:400,this.lastDistance_=void 0,this.lastScaleDelta_=1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){var e=1,i=this.targetPointers[0],r=this.targetPointers[1],n=i.clientX-r.clientX,o=i.clientY-r.clientY,s=Math.sqrt(n*n+o*o);void 0!==this.lastDistance_&&(e=this.lastDistance_/s),this.lastDistance_=s;var a=t.map,h=a.getView(),l=h.getResolution(),u=h.getMaxResolution(),p=h.getMinResolution(),c=l*e;c>u?(e=u/l,c=u):c<p&&(e=p/l,c=p),1!=e&&(this.lastScaleDelta_=e);var d=a.getViewport().getBoundingClientRect(),f=ro(this.targetPointers);f[0]-=d.left,f[1]-=d.top,this.anchor_=a.getCoordinateFromPixel(f),a.render(),Un(h,c,this.anchor_)},e.prototype.handleUpEvent=function(t){if(this.targetPointers.length<2){var e=t.map.getView();e.setHint(_e,-1);var i=e.getResolution();if(this.constrainResolution_||i<e.getMinResolution()||i>e.getMaxResolution()){var r=this.lastScaleDelta_-1;!function(t,e,i,r,n){e=t.constrainResolution(e,0,n),Un(t,e,i,r)}(e,i,this.anchor_,this.duration_,r)}return!1}return!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>=2){var e=t.map;return this.anchor_=null,this.lastDistance_=void 0,this.lastScaleDelta_=1,this.handlingDownUpSequence||e.getView().setHint(_e,1),!0}return!1},e}(no);function xo(t){var e=t||{},i=new Y,r=new An(-.005,.05,100);return(void 0===e.altShiftDragRotate||e.altShiftDragRotate)&&i.push(new so),(void 0===e.doubleClickZoom||e.doubleClickZoom)&&i.push(new Bn({delta:e.zoomDelta,duration:e.zoomDuration})),(void 0===e.dragPan||e.dragPan)&&i.push(new oo({condition:e.onFocusOnly?Kn:void 0,kinetic:r})),(void 0===e.pinchRotate||e.pinchRotate)&&i.push(new Co),(void 0===e.pinchZoom||e.pinchZoom)&&i.push(new Ro({constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.keyboard||e.keyboard)&&(i.push(new yo),i.push(new mo({delta:e.zoomDelta,duration:e.zoomDuration}))),(void 0===e.mouseWheelZoom||e.mouseWheelZoom)&&i.push(new To({condition:e.onFocusOnly?Kn:void 0,constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.shiftDragZoom||e.shiftDragZoom)&&i.push(new fo({duration:e.zoomDuration})),i}var wo=.5,Io=function(t){function e(e,i,r,n){t.call(this),this.extent=e,this.pixelRatio_=r,this.resolution=i,this.state=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){this.dispatchEvent(M.CHANGE)},e.prototype.getExtent=function(){return this.extent},e.prototype.getImage=function(){return r()},e.prototype.getPixelRatio=function(){return this.pixelRatio_},e.prototype.getResolution=function(){return this.resolution},e.prototype.getState=function(){return this.state},e.prototype.load=function(){r()},e}(P),Oo={IDLE:0,LOADING:1,LOADED:2,ERROR:3},Lo=function(t){function e(e,i,r,n,o){var s=void 0!==o?Oo.IDLE:Oo.LOADED;t.call(this,e,i,r,s),this.loader_=void 0!==o?o:null,this.canvas_=n,this.error_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getError=function(){return this.error_},e.prototype.handleLoad_=function(t){t?(this.error_=t,this.state=Oo.ERROR):this.state=Oo.LOADED,this.changed()},e.prototype.load=function(){this.state==Oo.IDLE&&(this.state=Oo.LOADING,this.changed(),this.loader_(this.handleLoad_.bind(this)))},e.prototype.getImage=function(){return this.canvas_},e}(Io),Po={IMAGE:"IMAGE",TILE:"TILE",VECTOR_TILE:"VECTOR_TILE",VECTOR:"VECTOR"},Mo={IMAGE:"image",VECTOR:"vector"},Fo=function(t){function e(e,i,r,n,o){t.call(this,e),this.vectorContext=i,this.frameState=r,this.context=n,this.glContext=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),bo=function(t){function e(e){t.call(this),this.highWaterMark=void 0!==e?e:2048,this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){return this.getCount()>this.highWaterMark},e.prototype.clear=function(){this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null,this.dispatchEvent(M.CLEAR)},e.prototype.containsKey=function(t){return this.entries_.hasOwnProperty(t)},e.prototype.forEach=function(t,e){for(var i=this.oldest_;i;)t.call(e,i.value_,i.key_,this),i=i.newer},e.prototype.get=function(t){var e=this.entries_[t];return te(void 0!==e,15),e===this.newest_?e.value_:(e===this.oldest_?(this.oldest_=this.oldest_.newer,this.oldest_.older=null):(e.newer.older=e.older,e.older.newer=e.newer),e.newer=null,e.older=this.newest_,this.newest_.newer=e,this.newest_=e,e.value_)},e.prototype.remove=function(t){var e=this.entries_[t];return te(void 0!==e,15),e===this.newest_?(this.newest_=e.older,this.newest_&&(this.newest_.newer=null)):e===this.oldest_?(this.oldest_=e.newer,this.oldest_&&(this.oldest_.older=null)):(e.newer.older=e.older,e.older.newer=e.newer),delete this.entries_[t],--this.count_,e.value_},e.prototype.getCount=function(){return this.count_},e.prototype.getKeys=function(){var t,e=new Array(this.count_),i=0;for(t=this.newest_;t;t=t.older)e[i++]=t.key_;return e},e.prototype.getValues=function(){var t,e=new Array(this.count_),i=0;for(t=this.newest_;t;t=t.older)e[i++]=t.value_;return e},e.prototype.peekLast=function(){return this.oldest_.value_},e.prototype.peekLastKey=function(){return this.oldest_.key_},e.prototype.peekFirstKey=function(){return this.newest_.key_},e.prototype.pop=function(){var t=this.oldest_;return delete this.entries_[t.key_],t.newer&&(t.newer.older=null),this.oldest_=t.newer,this.oldest_||(this.newest_=null),--this.count_,t.value_},e.prototype.replace=function(t,e){this.get(t),this.entries_[t].value_=e},e.prototype.set=function(t,e){te(!(t in this.entries_),16);var i={key_:t,newer:null,older:this.newest_,value_:e};this.newest_?this.newest_.newer=i:this.oldest_=i,this.newest_=i,this.entries_[t]=i,++this.count_},e.prototype.setSize=function(t){this.highWaterMark=t},e.prototype.prune=function(){for(;this.canExpireCache();)this.pop()},e}(P),No=[0,0,0,1],Ao=[],Go=[0,0,0,1],Do=[0,0,0,0],ko=new bo,Yo={},Uo=null,jo={},Xo=function(){var t,e,i=60,r=Yo,n="32px ",o=["monospace","serif"],s=o.length,a="wmytzilWMYTZIL@#/&?$%10";function h(t){for(var i=Bo(),r=100;r<=700;r+=300){for(var h=r+" ",l=!0,u=0;u<s;++u){var p=o[u];if(i.font=h+n+p,e=i.measureText(a).width,t!=p){i.font=h+n+t+","+p;var c=i.measureText(a).width;l=l&&c!=e}}if(l)return!0}return!1}function l(){var e=!0;for(var n in r)r[n]<i&&(h(n)?(r[n]=i,p(jo),Uo=null,ko.clear()):(++r[n],e=!1));e&&(clearInterval(t),t=void 0)}return function(e){var n=wn(e);if(n)for(var o=0,s=n.length;o<s;++o){var a=n[o];a in r||(r[a]=i,h(a)||(r[a]=0,void 0===t&&(t=setInterval(l,32))))}}}();function Bo(){return Uo||(Uo=on(1,1)),Uo}var Vo,Wo,Ko=(Wo=jo,function(t){var e=Wo[t];return null==e&&(Vo||((Vo=document.createElement("span")).textContent="M",Vo.style.margin=Vo.style.padding="0 !important",Vo.style.position="absolute !important",Vo.style.left="-99999px !important"),Vo.style.font=t,document.body.appendChild(Vo),e=Wo[t]=Vo.offsetHeight,document.body.removeChild(Vo)),e});function zo(t,e){var i=Bo();return t!=i.font&&(i.font=t),i.measureText(e).width}function Zo(t,e,i,r){0!==e&&(t.translate(i,r),t.rotate(e),t.translate(-i,-r))}var Ho=[1,0,0,1,0,0];function qo(t,e,i,r,n,o,s,a,h,l,u){var p;1!=i&&(p=t.globalAlpha,t.globalAlpha=p*i),e&&t.setTransform.apply(t,e),t.drawImage(r,n,o,s,a,h,l,s*u,a*u),p&&(t.globalAlpha=p),e&&t.setTransform.apply(t,Ho)}var Jo=/^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i,Qo=/^([a-z]*)$/i;function $o(t){return"string"==typeof t?t:rs(t)}var ts=function(){var t={},e=0;return function(i){var r;if(t.hasOwnProperty(i))r=t[i];else{if(e>=1024){var n=0;for(var o in t)0==(3&n++)&&(delete t[o],--e)}r=function(t){var e,i,r,n,o;Qo.exec(t)&&(t=function(t){var e=document.createElement("div");if(e.style.color=t,""!==e.style.color){document.body.appendChild(e);var i=getComputedStyle(e).color;return document.body.removeChild(e),i}return""}(t));if(Jo.exec(t)){var s,a=t.length-1;s=a<=4?1:2;var h=4===a||8===a;e=parseInt(t.substr(1+0*s,s),16),i=parseInt(t.substr(1+1*s,s),16),r=parseInt(t.substr(1+2*s,s),16),n=h?parseInt(t.substr(1+3*s,s),16):255,1==s&&(e=(e<<4)+e,i=(i<<4)+i,r=(r<<4)+r,h&&(n=(n<<4)+n)),o=[e,i,r,n/255]}else 0==t.indexOf("rgba(")?is(o=t.slice(5,-1).split(",").map(Number)):0==t.indexOf("rgb(")?((o=t.slice(4,-1).split(",").map(Number)).push(1),is(o)):te(!1,14);return o}(i),t[i]=r,++e}return r}}();function es(t){return Array.isArray(t)?t:ts(t)}function is(t){return t[0]=oe(t[0]+.5|0,0,255),t[1]=oe(t[1]+.5|0,0,255),t[2]=oe(t[2]+.5|0,0,255),t[3]=oe(t[3],0,1),t}function rs(t){var e=t[0];e!=(0|e)&&(e=e+.5|0);var i=t[1];i!=(0|i)&&(i=i+.5|0);var r=t[2];return r!=(0|r)&&(r=r+.5|0),"rgba("+e+","+i+","+r+","+(void 0===t[3]?1:t[3])+")"}function ns(t){return Array.isArray(t)?rs(t):t}var os=function(){};os.prototype.drawCustom=function(t,e,i){},os.prototype.drawGeometry=function(t){},os.prototype.setStyle=function(t){},os.prototype.drawCircle=function(t,e){},os.prototype.drawFeature=function(t,e){},os.prototype.drawGeometryCollection=function(t,e){},os.prototype.drawLineString=function(t,e){},os.prototype.drawMultiLineString=function(t,e){},os.prototype.drawMultiPoint=function(t,e){},os.prototype.drawMultiPolygon=function(t,e){},os.prototype.drawPoint=function(t,e){},os.prototype.drawPolygon=function(t,e){},os.prototype.drawText=function(t,e){},os.prototype.setFillStrokeStyle=function(t,e){},os.prototype.setImageStyle=function(t,e){},os.prototype.setTextStyle=function(t,e){};var ss=os,as=function(t){function e(e,i,r,n,o){t.call(this),this.context_=e,this.pixelRatio_=i,this.extent_=r,this.transform_=n,this.viewRotation_=o,this.contextFillState_=null,this.contextStrokeState_=null,this.contextTextState_=null,this.fillState_=null,this.strokeState_=null,this.image_=null,this.imageAnchorX_=0,this.imageAnchorY_=0,this.imageHeight_=0,this.imageOpacity_=0,this.imageOriginX_=0,this.imageOriginY_=0,this.imageRotateWithView_=!1,this.imageRotation_=0,this.imageScale_=0,this.imageWidth_=0,this.text_="",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=!1,this.textRotation_=0,this.textScale_=0,this.textFillState_=null,this.textStrokeState_=null,this.textState_=null,this.pixelCoordinates_=[],this.tmpLocalTransform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawImages_=function(t,e,i,r){if(this.image_){var n=vi(t,e,i,2,this.transform_,this.pixelCoordinates_),o=this.context_,s=this.tmpLocalTransform_,a=o.globalAlpha;1!=this.imageOpacity_&&(o.globalAlpha=a*this.imageOpacity_);var h=this.imageRotation_;this.imageRotateWithView_&&(h+=this.viewRotation_);for(var l=0,u=n.length;l<u;l+=2){var p=n[l]-this.imageAnchorX_,c=n[l+1]-this.imageAnchorY_;if(0!==h||1!=this.imageScale_){var d=p+this.imageAnchorX_,f=c+this.imageAnchorY_;cr(s,d,f,this.imageScale_,this.imageScale_,h,-d,-f),o.setTransform.apply(o,s)}o.drawImage(this.image_,this.imageOriginX_,this.imageOriginY_,this.imageWidth_,this.imageHeight_,p,c,this.imageWidth_,this.imageHeight_)}0===h&&1==this.imageScale_||o.setTransform(1,0,0,1,0,0),1!=this.imageOpacity_&&(o.globalAlpha=a)}},e.prototype.drawText_=function(t,e,i,r){if(this.textState_&&""!==this.text_){this.textFillState_&&this.setContextFillState_(this.textFillState_),this.textStrokeState_&&this.setContextStrokeState_(this.textStrokeState_),this.setContextTextState_(this.textState_);var n=vi(t,e,i,r,this.transform_,this.pixelCoordinates_),o=this.context_,s=this.textRotation_;for(this.textRotateWithView_&&(s+=this.viewRotation_);e<i;e+=r){var a=n[e]+this.textOffsetX_,h=n[e+1]+this.textOffsetY_;if(0!==s||1!=this.textScale_){var l=cr(this.tmpLocalTransform_,a,h,this.textScale_,this.textScale_,s,-a,-h);o.setTransform.apply(o,l)}this.textStrokeState_&&o.strokeText(this.text_,a,h),this.textFillState_&&o.fillText(this.text_,a,h)}0===s&&1==this.textScale_||o.setTransform(1,0,0,1,0,0)}},e.prototype.moveToLineTo_=function(t,e,i,r,n){var o=this.context_,s=vi(t,e,i,r,this.transform_,this.pixelCoordinates_);o.moveTo(s[0],s[1]);var a=s.length;n&&(a-=2);for(var h=2;h<a;h+=2)o.lineTo(s[h],s[h+1]);return n&&o.closePath(),i},e.prototype.drawRings_=function(t,e,i,r){for(var n=0,o=i.length;n<o;++n)e=this.moveToLineTo_(t,e,i[n],r,!0);return e},e.prototype.drawCircle=function(t){if(ci(this.extent_,t.getExtent())){if(this.fillState_||this.strokeState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=function(t,e,i){var r=t.getFlatCoordinates();if(r){var n=t.getStride();return vi(r,0,r.length,n,e,i)}return null}(t,this.transform_,this.pixelCoordinates_),i=e[2]-e[0],r=e[3]-e[1],n=Math.sqrt(i*i+r*r),o=this.context_;o.beginPath(),o.arc(e[0],e[1],n,0,2*Math.PI),this.fillState_&&o.fill(),this.strokeState_&&o.stroke()}""!==this.text_&&this.drawText_(t.getCenter(),0,2,2)}},e.prototype.setStyle=function(t){this.setFillStrokeStyle(t.getFill(),t.getStroke()),this.setImageStyle(t.getImage()),this.setTextStyle(t.getText())},e.prototype.drawGeometry=function(t){switch(t.getType()){case _i.POINT:this.drawPoint(t);break;case _i.LINE_STRING:this.drawLineString(t);break;case _i.POLYGON:this.drawPolygon(t);break;case _i.MULTI_POINT:this.drawMultiPoint(t);break;case _i.MULTI_LINE_STRING:this.drawMultiLineString(t);break;case _i.MULTI_POLYGON:this.drawMultiPolygon(t);break;case _i.GEOMETRY_COLLECTION:this.drawGeometryCollection(t);break;case _i.CIRCLE:this.drawCircle(t)}},e.prototype.drawFeature=function(t,e){var i=e.getGeometryFunction()(t);i&&ci(this.extent_,i.getExtent())&&(this.setStyle(e),this.drawGeometry(i))},e.prototype.drawGeometryCollection=function(t){for(var e=t.getGeometriesArray(),i=0,r=e.length;i<r;++i)this.drawGeometry(e[i])},e.prototype.drawPoint=function(t){var e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),""!==this.text_&&this.drawText_(e,0,e.length,i)},e.prototype.drawMultiPoint=function(t){var e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),""!==this.text_&&this.drawText_(e,0,e.length,i)},e.prototype.drawLineString=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var e=this.context_,i=t.getFlatCoordinates();e.beginPath(),this.moveToLineTo_(i,0,i.length,t.getStride(),!1),e.stroke()}if(""!==this.text_){var r=t.getFlatMidpoint();this.drawText_(r,0,2,2)}}},e.prototype.drawMultiLineString=function(t){var e=t.getExtent();if(ci(this.extent_,e)){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var i=this.context_,r=t.getFlatCoordinates(),n=0,o=t.getEnds(),s=t.getStride();i.beginPath();for(var a=0,h=o.length;a<h;++a)n=this.moveToLineTo_(r,n,o[a],s,!1);i.stroke()}if(""!==this.text_){var l=t.getFlatMidpoints();this.drawText_(l,0,l.length,2)}}},e.prototype.drawPolygon=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=this.context_;e.beginPath(),this.drawRings_(t.getOrientedFlatCoordinates(),0,t.getEnds(),t.getStride()),this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(""!==this.text_){var i=t.getFlatInteriorPoint();this.drawText_(i,0,2,2)}}},e.prototype.drawMultiPolygon=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=this.context_,i=t.getOrientedFlatCoordinates(),r=0,n=t.getEndss(),o=t.getStride();e.beginPath();for(var s=0,a=n.length;s<a;++s){var h=n[s];r=this.drawRings_(i,r,h,o)}this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(""!==this.text_){var l=t.getFlatInteriorPoints();this.drawText_(l,0,l.length,2)}}},e.prototype.setContextFillState_=function(t){var e=this.context_,i=this.contextFillState_;i?i.fillStyle!=t.fillStyle&&(i.fillStyle=e.fillStyle=t.fillStyle):(e.fillStyle=t.fillStyle,this.contextFillState_={fillStyle:t.fillStyle})},e.prototype.setContextStrokeState_=function(t){var e=this.context_,i=this.contextStrokeState_;i?(i.lineCap!=t.lineCap&&(i.lineCap=e.lineCap=t.lineCap),Z&&(Ut(i.lineDash,t.lineDash)||e.setLineDash(i.lineDash=t.lineDash),i.lineDashOffset!=t.lineDashOffset&&(i.lineDashOffset=e.lineDashOffset=t.lineDashOffset)),i.lineJoin!=t.lineJoin&&(i.lineJoin=e.lineJoin=t.lineJoin),i.lineWidth!=t.lineWidth&&(i.lineWidth=e.lineWidth=t.lineWidth),i.miterLimit!=t.miterLimit&&(i.miterLimit=e.miterLimit=t.miterLimit),i.strokeStyle!=t.strokeStyle&&(i.strokeStyle=e.strokeStyle=t.strokeStyle)):(e.lineCap=t.lineCap,Z&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineJoin=t.lineJoin,e.lineWidth=t.lineWidth,e.miterLimit=t.miterLimit,e.strokeStyle=t.strokeStyle,this.contextStrokeState_={lineCap:t.lineCap,lineDash:t.lineDash,lineDashOffset:t.lineDashOffset,lineJoin:t.lineJoin,lineWidth:t.lineWidth,miterLimit:t.miterLimit,strokeStyle:t.strokeStyle})},e.prototype.setContextTextState_=function(t){var e=this.context_,i=this.contextTextState_,r=t.textAlign?t.textAlign:"center";i?(i.font!=t.font&&(i.font=e.font=t.font),i.textAlign!=r&&(i.textAlign=e.textAlign=r),i.textBaseline!=t.textBaseline&&(i.textBaseline=e.textBaseline=t.textBaseline)):(e.font=t.font,e.textAlign=r,e.textBaseline=t.textBaseline,this.contextTextState_={font:t.font,textAlign:r,textBaseline:t.textBaseline})},e.prototype.setFillStrokeStyle=function(t,e){if(t){var i=t.getColor();this.fillState_={fillStyle:ns(i||No)}}else this.fillState_=null;if(e){var r=e.getColor(),n=e.getLineCap(),o=e.getLineDash(),s=e.getLineDashOffset(),a=e.getLineJoin(),h=e.getWidth(),l=e.getMiterLimit();this.strokeState_={lineCap:void 0!==n?n:"round",lineDash:o||Ao,lineDashOffset:s||0,lineJoin:void 0!==a?a:"round",lineWidth:this.pixelRatio_*(void 0!==h?h:1),miterLimit:void 0!==l?l:10,strokeStyle:ns(r||Go)}}else this.strokeState_=null},e.prototype.setImageStyle=function(t){if(t){var e=t.getAnchor(),i=t.getImage(1),r=t.getOrigin(),n=t.getSize();this.imageAnchorX_=e[0],this.imageAnchorY_=e[1],this.imageHeight_=n[1],this.image_=i,this.imageOpacity_=t.getOpacity(),this.imageOriginX_=r[0],this.imageOriginY_=r[1],this.imageRotateWithView_=t.getRotateWithView(),this.imageRotation_=t.getRotation(),this.imageScale_=t.getScale()*this.pixelRatio_,this.imageWidth_=n[0]}else this.image_=null},e.prototype.setTextStyle=function(t){if(t){var e=t.getFill();if(e){var i=e.getColor();this.textFillState_={fillStyle:ns(i||No)}}else this.textFillState_=null;var r=t.getStroke();if(r){var n=r.getColor(),o=r.getLineCap(),s=r.getLineDash(),a=r.getLineDashOffset(),h=r.getLineJoin(),l=r.getWidth(),u=r.getMiterLimit();this.textStrokeState_={lineCap:void 0!==o?o:"round",lineDash:s||Ao,lineDashOffset:a||0,lineJoin:void 0!==h?h:"round",lineWidth:void 0!==l?l:1,miterLimit:void 0!==u?u:10,strokeStyle:ns(n||Go)}}else this.textStrokeState_=null;var p=t.getFont(),c=t.getOffsetX(),d=t.getOffsetY(),f=t.getRotateWithView(),g=t.getRotation(),_=t.getScale(),y=t.getText(),v=t.getTextAlign(),m=t.getTextBaseline();this.textState_={font:void 0!==p?p:"10px sans-serif",textAlign:void 0!==v?v:"center",textBaseline:void 0!==m?m:"middle"},this.text_=void 0!==y?y:"",this.textOffsetX_=void 0!==c?this.pixelRatio_*c:0,this.textOffsetY_=void 0!==d?this.pixelRatio_*d:0,this.textRotateWithView_=void 0!==f&&f,this.textRotation_=void 0!==g?g:0,this.textScale_=this.pixelRatio_*(void 0!==_?_:1)}else this.text_=""},e}(ss),hs=function(){this.cache_={},this.cacheSize_=0,this.maxCacheSize_=32};function ls(t,e,i){return e+":"+t+":"+(i?$o(i):"null")}hs.prototype.clear=function(){this.cache_={},this.cacheSize_=0},hs.prototype.expire=function(){if(this.cacheSize_>this.maxCacheSize_){var t=0;for(var e in this.cache_){var i=this.cache_[e];0!=(3&t++)||i.hasListener()||(delete this.cache_[e],--this.cacheSize_)}}},hs.prototype.get=function(t,e,i){var r=ls(t,e,i);return r in this.cache_?this.cache_[r]:null},hs.prototype.set=function(t,e,i,r){var n=ls(t,e,i);this.cache_[n]=r,++this.cacheSize_},hs.prototype.setSize=function(t){this.maxCacheSize_=t,this.expire()};var us=new hs;function ps(t,e){us.expire()}function cs(t,e){return t.zIndex-e.zIndex}var ds=[],fs=function(t){function e(e){t.call(this,e);var i=e.getViewport();this.context_=on(),this.canvas_=this.context_.canvas,this.canvas_.style.width="100%",this.canvas_.style.height="100%",this.canvas_.style.display="block",this.canvas_.className=Cn,i.insertBefore(this.canvas_,i.childNodes[0]||null),this.renderedVisible_=!0,this.transform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.dispatchRenderEvent=function(t,e){var i=this.getMap(),r=this.context_;if(i.hasListener(t)){var n=e.extent,o=e.pixelRatio,s=e.viewState.rotation,a=this.getTransform(e),h=new as(r,o,n,a,s),l=new Fo(t,h,e,r,null);i.dispatchEvent(l)}},e.prototype.getTransform=function(t){var e=t.viewState,i=this.canvas_.width/2,r=this.canvas_.height/2,n=t.pixelRatio/e.resolution,o=-n,s=-e.rotation,a=-e.center[0],h=-e.center[1];return cr(this.transform_,i,r,n,o,s,a,h)},e.prototype.renderFrame=function(t){if(t){var e=this.context_,i=t.pixelRatio,r=Math.round(t.size[0]*i),n=Math.round(t.size[1]*i);this.canvas_.width!=r||this.canvas_.height!=n?(this.canvas_.width=r,this.canvas_.height=n):e.clearRect(0,0,r,n);var o=t.viewState.rotation;this.calculateMatrices2D(t),this.dispatchRenderEvent(Qt.PRECOMPOSE,t);var s=t.layerStatesArray;!function(t,e){var i,r=t.length,n=Array(t.length);for(i=0;i<r;i++)n[i]={index:i,value:t[i]};for(n.sort(function(t,i){return e(t.value,i.value)||t.index-i.index}),i=0;i<t.length;i++)t[i]=n[i].value}(s,cs),o&&(e.save(),Zo(e,o,r/2,n/2));var a,h,l=t.viewState.resolution;for(a=0,h=s.length;a<h;++a){var u=s[a],p=u.layer,c=this.getLayerRenderer(p);In(u,l)&&u.sourceState==dn.READY&&(c.prepareFrame(t,u)&&c.composeFrame(t,u,e))}o&&e.restore(),this.dispatchRenderEvent(Qt.POSTCOMPOSE,t),this.renderedVisible_||(this.canvas_.style.display="",this.renderedVisible_=!0),this.scheduleRemoveUnusedLayerRenderers(t),this.scheduleExpireIconCache(t)}else this.renderedVisible_&&(this.canvas_.style.display="none",this.renderedVisible_=!1)},e.prototype.forEachLayerAtPixel=function(t,e,i,r,n,o,s){var a,h,l=e.viewState.resolution,u=e.layerStatesArray,p=u.length,c=lr(e.pixelToCoordinateTransform,t.slice());for(h=p-1;h>=0;--h){var d=u[h],f=d.layer;if(In(d,l)&&o.call(s,f))if(a=this.getLayerRenderer(f).forEachLayerAtCoordinate(c,e,i,r,n))return a}},e.prototype.registerLayerRenderers=function(e){t.prototype.registerLayerRenderers.call(this,e);for(var i=0,r=e.length;i<r;++i){var n=e[i];At(ds,n)||ds.push(n)}},e}(function(t){function e(e){t.call(this),this.map_=e,this.layerRenderers_={},this.layerRendererListeners_={},this.layerRendererConstructors_=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.dispatchRenderEvent=function(t,e){r()},e.prototype.registerLayerRenderers=function(t){this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_,t)},e.prototype.calculateMatrices2D=function(t){var e=t.viewState,i=t.coordinateToPixelTransform,r=t.pixelToCoordinateTransform;cr(i,t.size[0]/2,t.size[1]/2,1/e.resolution,-1/e.resolution,-e.rotation,-e.center[0],-e.center[1]),function(t){var e,i=(e=t)[0]*e[3]-e[1]*e[2];te(0!==i,32);var r=t[0],n=t[1],o=t[2],s=t[3],a=t[4],h=t[5];t[0]=s/i,t[1]=-n/i,t[2]=-o/i,t[3]=r/i,t[4]=(o*h-s*a)/i,t[5]=-(r*h-n*a)/i}(hr(r,i))},e.prototype.removeLayerRenderers=function(){for(var t in this.layerRenderers_)this.removeLayerRendererByKey_(t).dispose()},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n,s,a){var h,l=e.viewState,u=l.resolution;function p(t,i){var s=e.layerStates[o(i)].managed;if(!(o(t)in e.skippedFeatureUids)||s)return r.call(n,t,s?i:null)}var c=l.projection,d=t;if(c.canWrapX()){var f=c.getExtent(),g=pi(f),_=t[0];if(_<f[0]||_>f[2])d=[_+g*Math.ceil((f[0]-_)/g),t[1]]}var y,v=e.layerStatesArray;for(y=v.length-1;y>=0;--y){var m=v[y],E=m.layer;if(In(m,u)&&s.call(a,E)){var S=this.getLayerRenderer(E),T=E.getSource();if(T&&(h=S.forEachFeatureAtCoordinate(T.getWrapX()?d:t,e,i,p)),h)return h}}},e.prototype.forEachLayerAtPixel=function(t,e,i,n,o,s,a){return r()},e.prototype.hasFeatureAtCoordinate=function(t,e,i,r,n){return void 0!==this.forEachFeatureAtCoordinate(t,e,i,R,this,r,n)},e.prototype.getLayerRenderer=function(t){var e=o(t);if(e in this.layerRenderers_)return this.layerRenderers_[e];for(var i,r=0,n=this.layerRendererConstructors_.length;r<n;++r){var s=this.layerRendererConstructors_[r];if(s.handles(t)){i=s.create(this,t);break}}if(!i)throw new Error("Unable to create renderer for layer: "+t.getType());return this.layerRenderers_[e]=i,this.layerRendererListeners_[e]=v(i,M.CHANGE,this.handleLayerRendererChange_,this),i},e.prototype.getLayerRendererByKey=function(t){return this.layerRenderers_[t]},e.prototype.getLayerRenderers=function(){return this.layerRenderers_},e.prototype.getMap=function(){return this.map_},e.prototype.handleLayerRendererChange_=function(){this.map_.render()},e.prototype.removeLayerRendererByKey_=function(t){var e=this.layerRenderers_[t];return delete this.layerRenderers_[t],S(this.layerRendererListeners_[t]),delete this.layerRendererListeners_[t],e},e.prototype.removeUnusedLayerRenderers_=function(t,e){for(var i in this.layerRenderers_)e&&i in e.layerStates||this.removeLayerRendererByKey_(i).dispose()},e.prototype.renderFrame=function(t){r()},e.prototype.scheduleExpireIconCache=function(t){t.postRenderFunctions.push(ps)},e.prototype.scheduleRemoveUnusedLayerRenderers=function(t){for(var e in this.layerRenderers_)if(!(e in t.layerStates))return void t.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this))},e}(C)),gs=function(t){function e(e){t.call(this,e),this.renderedResolution,this.transform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clip=function(t,e,i){var r=e.pixelRatio,n=e.size[0]*r,o=e.size[1]*r,s=e.viewState.rotation,a=li(i),h=ui(i),l=ri(i),u=ii(i);lr(e.coordinateToPixelTransform,a),lr(e.coordinateToPixelTransform,h),lr(e.coordinateToPixelTransform,l),lr(e.coordinateToPixelTransform,u),t.save(),Zo(t,-s,n/2,o/2),t.beginPath(),t.moveTo(a[0]*r,a[1]*r),t.lineTo(h[0]*r,h[1]*r),t.lineTo(l[0]*r,l[1]*r),t.lineTo(u[0]*r,u[1]*r),t.clip(),Zo(t,s,n/2,o/2)},e.prototype.dispatchComposeEvent_=function(t,e,i,r){var n=this.getLayer();if(n.hasListener(t)){var o=i.size[0]*i.pixelRatio,s=i.size[1]*i.pixelRatio,a=i.viewState.rotation;Zo(e,-a,o/2,s/2);var h=void 0!==r?r:this.getTransform(i,0),l=new as(e,i.pixelRatio,i.extent,h,i.viewState.rotation),u=new Fo(t,l,i,e,null);n.dispatchEvent(u),Zo(e,a,o/2,s/2)}},e.prototype.forEachLayerAtCoordinate=function(t,e,i,r,n){return this.forEachFeatureAtCoordinate(t,e,i,R)?r.call(n,this.getLayer(),null):void 0},e.prototype.postCompose=function(t,e,i,r){this.dispatchComposeEvent_(Qt.POSTCOMPOSE,t,e,r)},e.prototype.preCompose=function(t,e,i){this.dispatchComposeEvent_(Qt.PRECOMPOSE,t,e,i)},e.prototype.dispatchRenderEvent=function(t,e,i){this.dispatchComposeEvent_(Qt.RENDER,t,e,i)},e.prototype.getTransform=function(t,e){var i=t.viewState,r=t.pixelRatio,n=r*t.size[0]/2,o=r*t.size[1]/2,s=r/i.resolution,a=-s,h=-i.rotation,l=-i.center[0]+e,u=-i.center[1];return cr(this.transform_,n,o,s,a,h,l,u)},e.prototype.composeFrame=function(t,e,i){r()},e.prototype.prepareFrame=function(t,e){return r()},e}(function(t){function e(e){t.call(this),this.layer_=e}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createLoadedTileFinder=function(t,e,i){return function(r,n){return t.forEachLoadedTile(e,r,n,function(t){i[r]||(i[r]={}),i[r][t.tileCoord.toString()]=t})}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r){},e.prototype.getLayer=function(){return this.layer_},e.prototype.handleImageChange_=function(t){t.target.getState()===Oo.LOADED&&this.renderIfReadyAndVisible()},e.prototype.hasFeatureAtCoordinate=function(t,e){return!1},e.prototype.loadImage=function(t){var e=t.getState();return e!=Oo.LOADED&&e!=Oo.ERROR&&v(t,M.CHANGE,this.handleImageChange_,this),e==Oo.IDLE&&(t.load(),e=t.getState()),e==Oo.LOADED},e.prototype.renderIfReadyAndVisible=function(){var t=this.getLayer();t.getVisible()&&t.getSourceState()==dn.READY&&this.changed()},e.prototype.scheduleExpireCache=function(t,e){if(e.canExpireCache()){var i=function(t,e,i){var r=o(t);r in i.usedTiles&&t.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,e);t.postRenderFunctions.push(i)}},e.prototype.updateUsedTiles=function(t,e,i,r){var n=o(e),s=i.toString();n in t?s in t[n]?t[n][s].extend(r):t[n][s]=r:(t[n]={},t[n][s]=r)},e.prototype.manageTilePyramid=function(t,e,i,r,n,s,a,h,l,u){var p=o(e);p in t.wantedTiles||(t.wantedTiles[p]={});var c,d,f,g,_,y,v=t.wantedTiles[p],m=t.tileQueue;for(y=i.getMinZoom();y<=a;++y)for(d=i.getTileRangeForExtentAndZ(s,y,d),f=i.getResolution(y),g=d.minX;g<=d.maxX;++g)for(_=d.minY;_<=d.maxY;++_)a-y<=h?((c=e.getTile(y,g,_,r,n)).getState()==$t.IDLE&&(v[c.getKey()]=!0,m.isKeyQueued(c.getKey())||m.enqueue([c,p,i.getTileCoordCenter(c.tileCoord),f])),void 0!==l&&l.call(u,c)):e.useTile(y,g,_,n)},e}(F)),_s=function(t){function e(e){t.call(this,e),this.coordinateToCanvasPixelTransform=[1,0,0,1,0,0],this.hitCanvasContext_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.composeFrame=function(t,e,i){this.preCompose(i,t);var r=this.getImage();if(r){var n=e.extent,o=void 0!==n&&!Ue(n,t.extent)&&ci(n,t.extent);o&&this.clip(i,t,n);var s=this.getImageTransform(),a=i.globalAlpha;i.globalAlpha=e.opacity;var h=s[4],l=s[5],u=r.width*s[0],p=r.height*s[3];u>=.5&&p>=.5&&i.drawImage(r,0,0,+r.width,+r.height,Math.round(h),Math.round(l),Math.round(u),Math.round(p)),i.globalAlpha=a,o&&i.restore()}this.postCompose(i,t,e)},e.prototype.getImage=function(){return r()},e.prototype.getImageTransform=function(){return r()},e.prototype.forEachLayerAtCoordinate=function(t,e,i,r,n){if(this.getImage()){var o=lr(this.coordinateToCanvasPixelTransform,t.slice());xe(o,e.viewState.resolution/this.renderedResolution),this.hitCanvasContext_||(this.hitCanvasContext_=on(1,1)),this.hitCanvasContext_.clearRect(0,0,1,1),this.hitCanvasContext_.drawImage(this.getImage(),o[0],o[1],1,1,0,0,1,1);var s=this.hitCanvasContext_.getImageData(0,0,1,1).data;return s[3]>0?r.call(n,this.getLayer(),s):void 0}},e}(gs),ys=function(t){function e(i){if(t.call(this,i),this.image_=null,this.imageTransform_=[1,0,0,1,0,0],this.skippedFeatures_=[],this.vectorRenderer_=null,i.getType()===Po.VECTOR)for(var r=0,n=ds.length;r<n;++r){var o=ds[r];if(o!==e&&o.handles(i)){this.vectorRenderer_=new o(i);break}}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.vectorRenderer_&&this.vectorRenderer_.dispose(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.image_?this.image_.getImage():null},e.prototype.getImageTransform=function(){return this.imageTransform_},e.prototype.prepareFrame=function(t,e){var i,r=t.pixelRatio,n=t.size,o=t.viewState,s=o.center,a=o.resolution,h=this.getLayer().getSource(),l=t.viewHints,p=this.vectorRenderer_,c=t.extent;if(p||void 0===e.extent||(c=hi(c,e.extent)),!l[ge]&&!l[_e]&&!di(c)){var d=o.projection,f=this.skippedFeatures_;if(p){var g=p.context,_=u({},t,{size:[pi(c)/a,ai(c)/a],viewState:u({},t.viewState,{rotation:0})}),y=Object.keys(_.skippedFeatureUids).sort();i=new Lo(c,a,r,g.canvas,function(t){!p.prepareFrame(_,e)||!p.replayGroupChanged&&Ut(f,y)||(g.canvas.width=_.size[0]*r,g.canvas.height=_.size[1]*r,p.compose(g,_,e),f=y,t())})}else i=h.getImage(c,a,r,d);i&&this.loadImage(i)&&(this.image_=i,this.skippedFeatures_=f)}if(this.image_){var v=(i=this.image_).getExtent(),m=i.getResolution(),E=i.getPixelRatio(),S=r*m/(a*E),T=cr(this.imageTransform_,r*n[0]/2,r*n[1]/2,S,S,0,E*(v[0]-s[0])/m,E*(s[1]-v[3])/m);cr(this.coordinateToCanvasPixelTransform,r*n[0]/2-T[4],r*n[1]/2-T[5],r/a,-r/a,0,-s[0],-s[1]),this.renderedResolution=m*r/E}return!!this.image_},e.prototype.forEachFeatureAtCoordinate=function(e,i,r,n){return this.vectorRenderer_?this.vectorRenderer_.forEachFeatureAtCoordinate(e,i,r,n):t.prototype.forEachFeatureAtCoordinate.call(this,e,i,r,n)},e}(_s);ys.handles=function(t){return t.getType()===Po.IMAGE||t.getType()===Po.VECTOR&&t.getRenderMode()===Mo.IMAGE},ys.create=function(t,e){return new ys(e)};var vs=ys,ms=function(t,e,i,r){this.minX=t,this.maxX=e,this.minY=i,this.maxY=r};function Es(t,e,i,r,n){return void 0!==n?(n.minX=t,n.maxX=e,n.minY=i,n.maxY=r,n):new ms(t,e,i,r)}ms.prototype.contains=function(t){return this.containsXY(t[1],t[2])},ms.prototype.containsTileRange=function(t){return this.minX<=t.minX&&t.maxX<=this.maxX&&this.minY<=t.minY&&t.maxY<=this.maxY},ms.prototype.containsXY=function(t,e){return this.minX<=t&&t<=this.maxX&&this.minY<=e&&e<=this.maxY},ms.prototype.equals=function(t){return this.minX==t.minX&&this.minY==t.minY&&this.maxX==t.maxX&&this.maxY==t.maxY},ms.prototype.extend=function(t){t.minX<this.minX&&(this.minX=t.minX),t.maxX>this.maxX&&(this.maxX=t.maxX),t.minY<this.minY&&(this.minY=t.minY),t.maxY>this.maxY&&(this.maxY=t.maxY)},ms.prototype.getHeight=function(){return this.maxY-this.minY+1},ms.prototype.getSize=function(){return[this.getWidth(),this.getHeight()]},ms.prototype.getWidth=function(){return this.maxX-this.minX+1},ms.prototype.intersects=function(t){return this.minX<=t.maxX&&this.maxX>=t.minX&&this.minY<=t.maxY&&this.maxY>=t.minY};var Ss=ms,Ts=function(t){function e(e,i){t.call(this,e),this.context=i?null:on(),this.oversampling_,this.renderedExtent_=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=[1/0,1/0,-1/0,-1/0],this.tmpTileRange_=new Ss(0,0,0,0),this.imageTransform_=[1,0,0,1,0,0],this.zDirection=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isDrawableTile_=function(t){var e=this.getLayer(),i=t.getState(),r=e.getUseInterimTilesOnError();return i==$t.LOADED||i==$t.EMPTY||i==$t.ERROR&&!r},e.prototype.getTile=function(t,e,i,r,n){var o=this.getLayer(),s=o.getSource().getTile(t,e,i,r,n);return s.getState()==$t.ERROR&&(o.getUseInterimTilesOnError()?o.getPreload()>0&&(this.newTiles_=!0):s.setState($t.LOADED)),this.isDrawableTile_(s)||(s=s.getInterimTile()),s},e.prototype.prepareFrame=function(t,e){var i=t.pixelRatio,r=t.size,n=t.viewState,s=n.projection,a=n.resolution,h=n.center,l=this.getLayer(),u=l.getSource(),p=u.getRevision(),c=u.getTileGridForProjection(s),d=c.getZForResolution(a,this.zDirection),f=c.getResolution(d),g=Math.round(a/f)||1,_=t.extent;if(void 0!==e.extent&&(_=hi(_,e.extent)),di(_))return!1;var y=c.getTileRangeForExtentAndZ(_,d),v=c.getTileRangeExtent(d,y),m=u.getTilePixelRatio(i),E={};E[d]={};var S,T,C,R=this.createLoadedTileFinder(u,s,E),x=t.viewHints,w=x[ge]||x[_e],I=this.tmpExtent,O=this.tmpTileRange_;for(this.newTiles_=!1,T=y.minX;T<=y.maxX;++T)for(C=y.minY;C<=y.maxY;++C)if(!(Date.now()-t.time>16&&w)){if(S=this.getTile(d,T,C,i,s),this.isDrawableTile_(S)){var L=o(this);if(S.getState()==$t.LOADED){E[d][S.tileCoord.toString()]=S;var P=S.inTransition(L);this.newTiles_||!P&&-1!==this.renderedTiles.indexOf(S)||(this.newTiles_=!0)}if(1===S.getAlpha(L,t.time))continue}var M=c.getTileCoordChildTileRange(S.tileCoord,O,I),F=!1;M&&(F=R(d+1,M)),F||c.forEachTileCoordParentTileRange(S.tileCoord,R,null,O,I)}var b=f*i/m*g;if(!(this.renderedResolution&&Date.now()-t.time>16&&w)&&(this.newTiles_||!this.renderedExtent_||!Ue(this.renderedExtent_,_)||this.renderedRevision!=p||g!=this.oversampling_||!w&&b!=this.renderedResolution)){var N=this.context;if(N){var A=u.getTilePixelSize(d,i,s),G=Math.round(y.getWidth()*A[0]/g),D=Math.round(y.getHeight()*A[1]/g),k=N.canvas;k.width!=G||k.height!=D?(this.oversampling_=g,k.width=G,k.height=D):((this.renderedExtent_&&!Ze(v,this.renderedExtent_)||this.renderedRevision!=p)&&N.clearRect(0,0,G,D),g=this.oversampling_)}this.renderedTiles.length=0;var Y,U,j,X,B,V,W,K,z,Z,H=Object.keys(E).map(Number);for(H.sort(function(t,e){return t===d?1:e===d?-1:t>e?1:t<e?-1:0}),X=0,B=H.length;X<B;++X)for(var q in j=H[X],U=u.getTilePixelSize(j,i,s),Y=c.getResolution(j)/f,W=m*u.getGutterForProjection(s),K=E[j])S=K[q],T=((V=c.getTileCoordExtent(S.getTileCoord(),I))[0]-v[0])/f*m/g,C=(v[3]-V[3])/f*m/g,z=U[0]*Y/g,Z=U[1]*Y/g,this.drawTileImage(S,t,e,T,C,z,Z,W,d===j),this.renderedTiles.push(S);this.renderedRevision=p,this.renderedResolution=f*i/m*g,this.renderedExtent_=v}var J=this.renderedResolution/a,Q=cr(this.imageTransform_,i*r[0]/2,i*r[1]/2,J,J,0,(this.renderedExtent_[0]-h[0])/this.renderedResolution*i,(h[1]-this.renderedExtent_[3])/this.renderedResolution*i);return cr(this.coordinateToCanvasPixelTransform,i*r[0]/2-Q[4],i*r[1]/2-Q[5],i/a,-i/a,0,-h[0],-h[1]),this.updateUsedTiles(t.usedTiles,u,d,y),this.manageTilePyramid(t,u,c,i,s,_,d,l.getPreload()),this.scheduleExpireCache(t,u),this.renderedTiles.length>0},e.prototype.drawTileImage=function(t,e,i,r,n,s,a,h,l){var u=this.getTileImage(t);if(u){var p=o(this),c=l?t.getAlpha(p,e.time):1,d=this.getLayer().getSource();1!==c||d.getOpaque(e.viewState.projection)||this.context.clearRect(r,n,s,a);var f=c!==this.context.globalAlpha;f&&(this.context.save(),this.context.globalAlpha=c),this.context.drawImage(u,h,h,u.width-2*h,u.height-2*h,r,n,s,a),f&&this.context.restore(),1!==c?e.animate=!0:l&&t.endTransition(p)}},e.prototype.getImage=function(){var t=this.context;return t?t.canvas:null},e.prototype.getImageTransform=function(){return this.imageTransform_},e.prototype.getTileImage=function(t){return t.getImage()},e}(_s);Ts.handles=function(t){return t.getType()===Po.TILE},Ts.create=function(t,e){return new Ts(e)},Ts.prototype.getLayer;var Cs=Ts,Rs=i(0),xs=i.n(Rs),ws=function(){};ws.prototype.getReplay=function(t,e){return r()},ws.prototype.isEmpty=function(){return r()},ws.prototype.addDeclutter=function(t){return r()};var Is=ws,Os={CIRCLE:"Circle",DEFAULT:"Default",IMAGE:"Image",LINE_STRING:"LineString",POLYGON:"Polygon",TEXT:"Text"};function Ls(t,e,i,r){for(var n=t[e],o=t[e+1],s=0,a=e+r;a<i;a+=r){var h=t[a],l=t[a+1];s+=Math.sqrt((h-n)*(h-n)+(l-o)*(l-o)),n=h,o=l}return s}function Ps(t,e,i,r,n,o,s,a){for(var h,l,u,p=[],c=t[e]>t[i-r],d=n.length,f=t[e],g=t[e+1],_=t[e+=r],y=t[e+1],v=0,m=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2)),E="",S=0,T=0;T<d;++T){l=c?d-T-1:T;var C=n.charAt(l),R=o(E=c?C+E:E+C)-S;S+=R;for(var x=s+R/2;e<i-r&&v+m<x;)f=_,g=y,_=t[e+=r],y=t[e+1],v+=m,m=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2));var w=x-v,I=Math.atan2(y-g,_-f);if(c&&(I+=I>0?-Math.PI:Math.PI),void 0!==u){var O=I-u;if(O+=O>Math.PI?-2*Math.PI:O<-Math.PI?2*Math.PI:0,Math.abs(O)>a)return null}var L=w/m,P=pe(f,_,L),M=pe(g,y,L);u==I?(c&&(h[0]=P,h[1]=M,h[2]=R/2),h[4]=E):(S=R,h=[P,M,R/2,I,E=C],c?p.unshift(h):p.push(h),u=I),s+=R}return p}var Ms={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_CHARS:5,DRAW_IMAGE:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,STROKE:12},Fs=[Ms.FILL],bs=[Ms.STROKE],Ns=[Ms.BEGIN_PATH],As=[Ms.CLOSE_PATH],Gs=Ms,Ds=[Os.POLYGON,Os.CIRCLE,Os.LINE_STRING,Os.IMAGE,Os.TEXT,Os.DEFAULT],ks={left:0,end:0,center:.5,right:1,start:1,top:0,middle:.5,hanging:.2,alphabetic:.8,ideographic:.8,bottom:1},Ys=[1/0,1/0,-1/0,-1/0],Us=[1,0,0,1,0,0],js=function(t){function e(e,i,r,n,o,s){t.call(this),this.declutterTree=s,this.tolerance=e,this.maxExtent=i,this.overlaps=o,this.pixelRatio=n,this.maxLineWidth=0,this.resolution=r,this.alignFill_,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_=null,this.bufferedMaxExtent_=null,this.instructions=[],this.coordinates=[],this.coordinateCache_={},this.renderedTransform_=[1,0,0,1,0,0],this.hitDetectionInstructions=[],this.pixelCoordinates_=null,this.state={},this.viewRotation_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.replayTextBackground_=function(t,e,i,r,n,o,s){t.beginPath(),t.moveTo.apply(t,e),t.lineTo.apply(t,i),t.lineTo.apply(t,r),t.lineTo.apply(t,n),t.lineTo.apply(t,e),o&&(this.alignFill_=o[2],this.fill_(t)),s&&(this.setStrokeStyle_(t,s),t.stroke())},e.prototype.replayImage_=function(t,e,i,r,n,o,s,a,h,l,u,p,c,d,f,g,_,y){var v=_||y;e-=n*=c,i-=o*=c;var m,E,S,T,C=f+l>r.width?r.width-l:f,R=a+u>r.height?r.height-u:a,x=g[3]+C*c+g[1],w=g[0]+R*c+g[2],I=e-g[3],O=i-g[0];(v||0!==p)&&(m=[I,O],E=[I+x,O],S=[I+x,O+w],T=[I,O+w]);var L=null;if(0!==p){var P=e+n,M=i+o;L=cr(Us,P,M,1,1,p,-P,-M),We(Ys),qe(Ys,lr(Us,m)),qe(Ys,lr(Us,E)),qe(Ys,lr(Us,S)),qe(Ys,lr(Us,T))}else Ve(I,O,I+x,O+w,Ys);var F=t.canvas,b=y?y[2]*c/2:0,N=Ys[0]-b<=F.width&&Ys[2]+b>=0&&Ys[1]-b<=F.height&&Ys[3]+b>=0;if(d&&(e=Math.round(e),i=Math.round(i)),s){if(!N&&1==s[4])return;He(s,Ys);var A=N?[t,L?L.slice(0):null,h,r,l,u,C,R,e,i,c]:null;A&&v&&A.push(_,y,m,E,S,T),s.push(A)}else N&&(v&&this.replayTextBackground_(t,m,E,S,T,_,y),qo(t,L,h,r,l,u,C,R,e,i,c))},e.prototype.applyPixelRatio=function(t){var e=this.pixelRatio;return 1==e?t:t.map(function(t){return t*e})},e.prototype.appendFlatCoordinates=function(t,e,i,r,n,o){var s=this.coordinates.length,a=this.getBufferedMaxExtent();o&&(e+=r);var h,l,u,p=[t[e],t[e+1]],c=[NaN,NaN],d=!0;for(h=e+r;h<i;h+=r)c[0]=t[h],c[1]=t[h+1],(u=Xe(a,c))!==l?(d&&(this.coordinates[s++]=p[0],this.coordinates[s++]=p[1]),this.coordinates[s++]=c[0],this.coordinates[s++]=c[1],d=!1):u===Ne.INTERSECTING?(this.coordinates[s++]=c[0],this.coordinates[s++]=c[1],d=!1):d=!0,p[0]=c[0],p[1]=c[1],l=u;return(n&&d||h===e+r)&&(this.coordinates[s++]=p[0],this.coordinates[s++]=p[1]),s},e.prototype.drawCustomCoordinates_=function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o],h=this.appendFlatCoordinates(t,e,a,r,!1,!1);n.push(h),e=a}return e},e.prototype.drawCustom=function(t,e,i){this.beginGeometry(t,e);var r,n,o,s,a,h=t.getType(),l=t.getStride(),u=this.coordinates.length;if(h==_i.MULTI_POLYGON){r=(t=t).getOrientedFlatCoordinates(),s=[];var p=t.getEndss();a=0;for(var c=0,d=p.length;c<d;++c){var f=[];a=this.drawCustomCoordinates_(r,a,p[c],l,f),s.push(f)}this.instructions.push([Gs.CUSTOM,u,s,t,i,Lr])}else h==_i.POLYGON||h==_i.MULTI_LINE_STRING?(o=[],r=h==_i.POLYGON?t.getOrientedFlatCoordinates():t.getFlatCoordinates(),a=this.drawCustomCoordinates_(r,0,t.getEnds(),l,o),this.instructions.push([Gs.CUSTOM,u,o,t,i,Or])):h==_i.LINE_STRING||h==_i.MULTI_POINT?(r=t.getFlatCoordinates(),n=this.appendFlatCoordinates(r,0,r.length,l,!1,!1),this.instructions.push([Gs.CUSTOM,u,n,t,i,Ir])):h==_i.POINT&&(r=t.getFlatCoordinates(),this.coordinates.push(r[0],r[1]),n=this.coordinates.length,this.instructions.push([Gs.CUSTOM,u,n,t,i]));this.endGeometry(t,e)},e.prototype.beginGeometry=function(t,e){this.beginGeometryInstruction1_=[Gs.BEGIN_GEOMETRY,e,0],this.instructions.push(this.beginGeometryInstruction1_),this.beginGeometryInstruction2_=[Gs.BEGIN_GEOMETRY,e,0],this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)},e.prototype.finish=function(){},e.prototype.fill_=function(t){if(this.alignFill_){var e=lr(this.renderedTransform_,[0,0]),i=512*this.pixelRatio;t.translate(e[0]%i,e[1]%i),t.rotate(this.viewRotation_)}t.fill(),this.alignFill_&&t.setTransform.apply(t,Ho)},e.prototype.setStrokeStyle_=function(t,e){t.strokeStyle=e[1],t.lineWidth=e[2],t.lineCap=e[3],t.lineJoin=e[4],t.miterLimit=e[5],Z&&(t.lineDashOffset=e[7],t.setLineDash(e[6]))},e.prototype.renderDeclutter_=function(t,e){if(t&&t.length>5){var i=t[4];if(1==i||i==t.length-5){var r={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};if(!this.declutterTree.collides(r)){this.declutterTree.insert(r);for(var n=5,o=t.length;n<o;++n){var s=t[n];s&&(s.length>11&&this.replayTextBackground_(s[0],s[13],s[14],s[15],s[16],s[11],s[12]),qo.apply(void 0,s))}}t.length=5,We(t)}}},e.prototype.replay_=function(t,e,i,r,n,s,a){var h;this.pixelCoordinates_&&Ut(e,this.renderedTransform_)?h=this.pixelCoordinates_:(this.pixelCoordinates_||(this.pixelCoordinates_=[]),h=vi(this.coordinates,0,this.coordinates.length,2,e,this.pixelCoordinates_),hr(this.renderedTransform_,e));for(var l,u,p,c,f,g,_,y,v,m,E,S,T=!d(i),C=0,R=r.length,x=0,w=0,I=0,O=null,L=null,P=this.coordinateCache_,M=this.viewRotation_,F={context:t,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:M},b=this.instructions!=r||this.overlaps?0:200;C<R;){var N=r[C];switch(N[0]){case Gs.BEGIN_GEOMETRY:m=N[1],T&&i[o(m)]||!m.getGeometry()?C=N[2]:void 0===a||ci(a,m.getGeometry().getExtent())?++C:C=N[2]+1;break;case Gs.BEGIN_PATH:w>b&&(this.fill_(t),w=0),I>b&&(t.stroke(),I=0),w||I||(t.beginPath(),c=f=NaN),++C;break;case Gs.CIRCLE:var A=h[x=N[1]],G=h[x+1],D=h[x+2]-A,k=h[x+3]-G,Y=Math.sqrt(D*D+k*k);t.moveTo(A+Y,G),t.arc(A,G,Y,0,2*Math.PI,!0),++C;break;case Gs.CLOSE_PATH:t.closePath(),++C;break;case Gs.CUSTOM:x=N[1],l=N[2];var U=N[3],j=N[4],X=6==N.length?N[5]:void 0;F.geometry=U,F.feature=m,C in P||(P[C]=[]);var B=P[C];X?X(h,x,l,2,B):(B[0]=h[x],B[1]=h[x+1],B.length=2),j(B,F),++C;break;case Gs.DRAW_IMAGE:x=N[1],l=N[2],v=N[3],u=N[4],p=N[5],y=s?null:N[6];var V=N[7],W=N[8],K=N[9],z=N[10],Z=N[11],H=N[12],q=N[13],J=N[14],Q=void 0,$=void 0,tt=void 0;for(N.length>16?(Q=N[15],$=N[16],tt=N[17]):(Q=Do,$=tt=!1),Z&&(H+=M);x<l;x+=2)this.replayImage_(t,h[x],h[x+1],v,u,p,y,V,W,K,z,H,q,n,J,Q,$?O:null,tt?L:null);this.renderDeclutter_(y,m),++C;break;case Gs.DRAW_CHARS:var et=N[1],it=N[2],rt=N[3];y=s?null:N[4];var nt=N[5],ot=N[6],st=N[7],at=N[8],ht=N[9],lt=N[10],ut=N[11],pt=N[12],ct=N[13],dt=N[14],ft=Ls(h,et,it,2),gt=at(pt);if(nt||gt<=ft){var _t=this.textStates[ct].textAlign,yt=Ps(h,et,it,2,pt,at,(ft-gt)*ks[_t],st);if(yt){var vt=void 0,mt=void 0,Et=void 0,St=void 0,Tt=void 0;if(lt)for(vt=0,mt=yt.length;vt<mt;++vt)Et=(Tt=yt[vt])[4],St=this.getImage(Et,ct,"",lt),u=Tt[2]+ut,p=rt*St.height+2*(.5-rt)*ut-ht,this.replayImage_(t,Tt[0],Tt[1],St,u,p,y,St.height,1,0,0,Tt[3],dt,!1,St.width,Do,null,null);if(ot)for(vt=0,mt=yt.length;vt<mt;++vt)Et=(Tt=yt[vt])[4],St=this.getImage(Et,ct,ot,""),u=Tt[2],p=rt*St.height-ht,this.replayImage_(t,Tt[0],Tt[1],St,u,p,y,St.height,1,0,0,Tt[3],dt,!1,St.width,Do,null,null)}}this.renderDeclutter_(y,m),++C;break;case Gs.END_GEOMETRY:if(void 0!==s){var Ct=s(m=N[1]);if(Ct)return Ct}++C;break;case Gs.FILL:b?w++:this.fill_(t),++C;break;case Gs.MOVE_TO_LINE_TO:for(x=N[1],l=N[2],E=h[x],_=(S=h[x+1])+.5|0,(g=E+.5|0)===c&&_===f||(t.moveTo(E,S),c=g,f=_),x+=2;x<l;x+=2)g=(E=h[x])+.5|0,_=(S=h[x+1])+.5|0,x!=l-2&&g===c&&_===f||(t.lineTo(E,S),c=g,f=_);++C;break;case Gs.SET_FILL_STYLE:O=N,this.alignFill_=N[2],w&&(this.fill_(t),w=0,I&&(t.stroke(),I=0)),t.fillStyle=N[1],++C;break;case Gs.SET_STROKE_STYLE:L=N,I&&(t.stroke(),I=0),this.setStrokeStyle_(t,N),++C;break;case Gs.STROKE:b?I++:t.stroke(),++C;break;default:++C}}w&&this.fill_(t),I&&t.stroke()},e.prototype.replay=function(t,e,i,r,n){this.viewRotation_=i,this.replay_(t,e,r,this.instructions,n,void 0,void 0)},e.prototype.replayHitDetection=function(t,e,i,r,n,o){return this.viewRotation_=i,this.replay_(t,e,r,this.hitDetectionInstructions,!0,n,o)},e.prototype.reverseHitDetectionInstructions=function(){var t,e=this.hitDetectionInstructions;e.reverse();var i,r,n=e.length,o=-1;for(t=0;t<n;++t)(r=(i=e[t])[0])==Gs.END_GEOMETRY?o=t:r==Gs.BEGIN_GEOMETRY&&(i[2]=t,Dt(this.hitDetectionInstructions,o,t),o=-1)},e.prototype.setFillStrokeStyle=function(t,e){var i=this.state;if(t){var r=t.getColor();i.fillStyle=ns(r||No)}else i.fillStyle=void 0;if(e){var n=e.getColor();i.strokeStyle=ns(n||Go);var o=e.getLineCap();i.lineCap=void 0!==o?o:"round";var s=e.getLineDash();i.lineDash=s?s.slice():Ao;var a=e.getLineDashOffset();i.lineDashOffset=a||0;var h=e.getLineJoin();i.lineJoin=void 0!==h?h:"round";var l=e.getWidth();i.lineWidth=void 0!==l?l:1;var u=e.getMiterLimit();i.miterLimit=void 0!==u?u:10,i.lineWidth>this.maxLineWidth&&(this.maxLineWidth=i.lineWidth,this.bufferedMaxExtent_=null)}else i.strokeStyle=void 0,i.lineCap=void 0,i.lineDash=null,i.lineDashOffset=void 0,i.lineJoin=void 0,i.lineWidth=void 0,i.miterLimit=void 0},e.prototype.createFill=function(t,e){var i=t.fillStyle,r=[Gs.SET_FILL_STYLE,i];return"string"!=typeof i&&r.push(!0),r},e.prototype.applyStroke=function(t){this.instructions.push(this.createStroke(t))},e.prototype.createStroke=function(t){return[Gs.SET_STROKE_STYLE,t.strokeStyle,t.lineWidth*this.pixelRatio,t.lineCap,t.lineJoin,t.miterLimit,this.applyPixelRatio(t.lineDash),t.lineDashOffset*this.pixelRatio]},e.prototype.updateFillStyle=function(t,e,i){var r=t.fillStyle;"string"==typeof r&&t.currentFillStyle==r||(void 0!==r&&this.instructions.push(e.call(this,t,i)),t.currentFillStyle=r)},e.prototype.updateStrokeStyle=function(t,e){var i=t.strokeStyle,r=t.lineCap,n=t.lineDash,o=t.lineDashOffset,s=t.lineJoin,a=t.lineWidth,h=t.miterLimit;(t.currentStrokeStyle!=i||t.currentLineCap!=r||n!=t.currentLineDash&&!Ut(t.currentLineDash,n)||t.currentLineDashOffset!=o||t.currentLineJoin!=s||t.currentLineWidth!=a||t.currentMiterLimit!=h)&&(void 0!==i&&e.call(this,t),t.currentStrokeStyle=i,t.currentLineCap=r,t.currentLineDash=n,t.currentLineDashOffset=o,t.currentLineJoin=s,t.currentLineWidth=a,t.currentMiterLimit=h)},e.prototype.endGeometry=function(t,e){this.beginGeometryInstruction1_[2]=this.instructions.length,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length,this.beginGeometryInstruction2_=null;var i=[Gs.END_GEOMETRY,e];this.instructions.push(i),this.hitDetectionInstructions.push(i)},e.prototype.getBufferedMaxExtent=function(){if(!this.bufferedMaxExtent_&&(this.bufferedMaxExtent_=De(this.maxExtent),this.maxLineWidth>0)){var t=this.resolution*(this.maxLineWidth+1)/2;Ge(this.bufferedMaxExtent_,t,this.bufferedMaxExtent_)}return this.bufferedMaxExtent_},e}(ss),Xs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s),this.declutterGroup_=null,this.hitDetectionImage_=null,this.image_=null,this.anchorX_=void 0,this.anchorY_=void 0,this.height_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.scale_=void 0,this.width_=void 0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawCoordinates_=function(t,e,i,r){return this.appendFlatCoordinates(t,e,i,r,!1,!1)},e.prototype.drawPoint=function(t,e){if(this.image_){this.beginGeometry(t,e);var i=t.getFlatCoordinates(),r=t.getStride(),n=this.coordinates.length,o=this.drawCoordinates_(i,0,i.length,r);this.instructions.push([Gs.DRAW_IMAGE,n,o,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.width_]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_]),this.endGeometry(t,e)}},e.prototype.drawMultiPoint=function(t,e){if(this.image_){this.beginGeometry(t,e);var i=t.getFlatCoordinates(),r=t.getStride(),n=this.coordinates.length,o=this.drawCoordinates_(i,0,i.length,r);this.instructions.push([Gs.DRAW_IMAGE,n,o,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.width_]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_]),this.endGeometry(t,e)}},e.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.anchorX_=void 0,this.anchorY_=void 0,this.hitDetectionImage_=null,this.image_=null,this.height_=void 0,this.scale_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.width_=void 0},e.prototype.setImageStyle=function(t,e){var i=t.getAnchor(),r=t.getSize(),n=t.getHitDetectionImage(1),o=t.getImage(1),s=t.getOrigin();this.anchorX_=i[0],this.anchorY_=i[1],this.declutterGroup_=e,this.hitDetectionImage_=n,this.image_=o,this.height_=r[1],this.opacity_=t.getOpacity(),this.originX_=s[0],this.originY_=s[1],this.rotateWithView_=t.getRotateWithView(),this.rotation_=t.getRotation(),this.scale_=t.getScale(),this.width_=r[0]},e}(js),Bs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawFlatCoordinates_=function(t,e,i,r){var n=this.coordinates.length,o=this.appendFlatCoordinates(t,e,i,r,!1,!1),s=[Gs.MOVE_TO_LINE_TO,n,o];return this.instructions.push(s),this.hitDetectionInstructions.push(s),i},e.prototype.drawLineString=function(t,e){var i=this.state,r=i.strokeStyle,n=i.lineWidth;if(void 0!==r&&void 0!==n){this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Ns);var o=t.getFlatCoordinates(),s=t.getStride();this.drawFlatCoordinates_(o,0,o.length,s),this.hitDetectionInstructions.push(bs),this.endGeometry(t,e)}},e.prototype.drawMultiLineString=function(t,e){var i=this.state,r=i.strokeStyle,n=i.lineWidth;if(void 0!==r&&void 0!==n){this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Ns);for(var o=t.getEnds(),s=t.getFlatCoordinates(),a=t.getStride(),h=0,l=0,u=o.length;l<u;++l)h=this.drawFlatCoordinates_(s,h,o[l],a);this.hitDetectionInstructions.push(bs),this.endGeometry(t,e)}},e.prototype.finish=function(){var t=this.state;null!=t.lastStroke&&t.lastStroke!=this.coordinates.length&&this.instructions.push(bs),this.reverseHitDetectionInstructions(),this.state=null},e.prototype.applyStroke=function(e){null!=e.lastStroke&&e.lastStroke!=this.coordinates.length&&(this.instructions.push(bs),e.lastStroke=this.coordinates.length),e.lastStroke=0,t.prototype.applyStroke.call(this,e),this.instructions.push(Ns)},e}(js),Vs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawFlatCoordinatess_=function(t,e,i,r){var n=this.state,o=void 0!==n.fillStyle,s=null!=n.strokeStyle,a=i.length;this.instructions.push(Ns),this.hitDetectionInstructions.push(Ns);for(var h=0;h<a;++h){var l=i[h],u=this.coordinates.length,p=this.appendFlatCoordinates(t,e,l,r,!0,!s),c=[Gs.MOVE_TO_LINE_TO,u,p];this.instructions.push(c),this.hitDetectionInstructions.push(c),s&&(this.instructions.push(As),this.hitDetectionInstructions.push(As)),e=l}return o&&(this.instructions.push(Fs),this.hitDetectionInstructions.push(Fs)),s&&(this.instructions.push(bs),this.hitDetectionInstructions.push(bs)),e},e.prototype.drawCircle=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);var o=t.getFlatCoordinates(),s=t.getStride(),a=this.coordinates.length;this.appendFlatCoordinates(o,0,o.length,s,!1,!1);var h=[Gs.CIRCLE,a];this.instructions.push(Ns,h),this.hitDetectionInstructions.push(Ns,h),this.hitDetectionInstructions.push(Fs),void 0!==i.fillStyle&&this.instructions.push(Fs),void 0!==i.strokeStyle&&(this.instructions.push(bs),this.hitDetectionInstructions.push(bs)),this.endGeometry(t,e)}},e.prototype.drawPolygon=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);var o=t.getEnds(),s=t.getOrientedFlatCoordinates(),a=t.getStride();this.drawFlatCoordinatess_(s,0,o,a),this.endGeometry(t,e)}},e.prototype.drawMultiPolygon=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);for(var o=t.getEndss(),s=t.getOrientedFlatCoordinates(),a=t.getStride(),h=0,l=0,u=o.length;l<u;++l)h=this.drawFlatCoordinatess_(s,h,o[l],a);this.endGeometry(t,e)}},e.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.state=null;var t=this.tolerance;if(0!==t)for(var e=this.coordinates,i=0,r=e.length;i<r;++i)e[i]=Fr(e[i],t)},e.prototype.setFillStrokeStyles_=function(t){var e=this.state;void 0!==e.fillStyle&&this.updateFillStyle(e,this.createFill,t),void 0!==e.strokeStyle&&this.updateStrokeStyle(e,this.applyStroke)},e}(js);function Ws(t,e,i,r,n){var o,s,a,h,l,u,p,c,d,f=i,g=i,_=0,y=0,v=i;for(o=i;o<r;o+=n){var m=e[o],E=e[o+1];void 0!==h&&(c=m-h,d=E-l,a=Math.sqrt(c*c+d*d),void 0!==u&&(y+=s,Math.acos((u*c+p*d)/(s*a))>t&&(y>_&&(_=y,f=v,g=o),y=0,v=o-n)),s=a,u=c,p=d),h=m,l=E}return(y+=a)>_?[v,o]:[f,g]}var Ks="point",zs="line";var Zs={Circle:Vs,Default:js,Image:Xs,LineString:Bs,Polygon:Vs,Text:function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s),this.declutterGroup_,this.labels_=null,this.text_="",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=void 0,this.textRotation_=0,this.textFillState_=null,this.fillStates={},this.textStrokeState_=null,this.strokeStates={},this.textState_={},this.textStates={},this.textKey_="",this.fillKey_="",this.strokeKey_="",this.widths_={},ko.prune()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawText=function(t,e){var i=this.textFillState_,r=this.textStrokeState_,n=this.textState_;if(""!==this.text_&&n&&(i||r)){var o,s,a=this.coordinates.length,h=t.getType(),l=null,u=2,p=2;if(n.placement===zs){if(!ci(this.getBufferedMaxExtent(),t.getExtent()))return;var c;if(l=t.getFlatCoordinates(),p=t.getStride(),h==_i.LINE_STRING)c=[l.length];else if(h==_i.MULTI_LINE_STRING)c=t.getEnds();else if(h==_i.POLYGON)c=t.getEnds().slice(0,1);else if(h==_i.MULTI_POLYGON){var d=t.getEndss();for(c=[],o=0,s=d.length;o<s;++o)c.push(d[o][0])}this.beginGeometry(t,e);for(var f,g=n.textAlign,_=0,y=0,v=c.length;y<v;++y){if(null==g){var m=Ws(n.maxAngle,l,_,c[y],p);_=m[0],f=m[1]}else f=c[y];for(o=_;o<f;o+=p)this.coordinates.push(l[o],l[o+1]);u=this.coordinates.length,_=c[y],this.drawChars_(a,u,this.declutterGroup_),a=u}this.endGeometry(t,e)}else{var E=this.getImage(this.text_,this.textKey_,this.fillKey_,this.strokeKey_),S=E.width/this.pixelRatio;switch(h){case _i.POINT:case _i.MULTI_POINT:u=(l=t.getFlatCoordinates()).length;break;case _i.LINE_STRING:l=t.getFlatMidpoint();break;case _i.CIRCLE:l=t.getCenter();break;case _i.MULTI_LINE_STRING:u=(l=t.getFlatMidpoints()).length;break;case _i.POLYGON:if(l=t.getFlatInteriorPoint(),!n.overflow&&l[2]/this.resolution<S)return;p=3;break;case _i.MULTI_POLYGON:var T=t.getFlatInteriorPoints();for(l=[],o=0,s=T.length;o<s;o+=3)(n.overflow||T[o+2]/this.resolution>=S)&&l.push(T[o],T[o+1]);if(0==(u=l.length))return}u=this.appendFlatCoordinates(l,0,u,p,!1,!1),(n.backgroundFill||n.backgroundStroke)&&(this.setFillStrokeStyle(n.backgroundFill,n.backgroundStroke),n.backgroundFill&&(this.updateFillStyle(this.state,this.createFill,t),this.hitDetectionInstructions.push(this.createFill(this.state,t))),n.backgroundStroke&&(this.updateStrokeStyle(this.state,this.applyStroke),this.hitDetectionInstructions.push(this.createStroke(this.state)))),this.beginGeometry(t,e),this.drawTextImage_(E,a,u),this.endGeometry(t,e)}}},e.prototype.getImage=function(t,e,i,r){var n,o=r+e+t+i+this.pixelRatio;if(!ko.containsKey(o)){var s=r?this.strokeStates[r]||this.textStrokeState_:null,a=i?this.fillStates[i]||this.textFillState_:null,h=this.textStates[e]||this.textState_,l=this.pixelRatio,u=h.scale*l,p=ks[h.textAlign||"center"],c=r&&s.lineWidth?s.lineWidth:0,d=t.split("\n"),f=d.length,g=[],_=function(t,e,i){for(var r=e.length,n=0,o=0;o<r;++o){var s=zo(t,e[o]);n=Math.max(n,s),i.push(s)}return n}(h.font,d,g),y=Ko(h.font),v=y*f,m=_+c,E=on(Math.ceil(m*u),Math.ceil((v+c)*u));n=E.canvas,ko.set(o,n),1!=u&&E.scale(u,u),E.font=h.font,r&&(E.strokeStyle=s.strokeStyle,E.lineWidth=c,E.lineCap=s.lineCap,E.lineJoin=s.lineJoin,E.miterLimit=s.miterLimit,Z&&s.lineDash.length&&(E.setLineDash(s.lineDash),E.lineDashOffset=s.lineDashOffset)),i&&(E.fillStyle=a.fillStyle),E.textBaseline="middle",E.textAlign="center";var S,T=.5-p,C=p*n.width/u+T*c;if(r)for(S=0;S<f;++S)E.strokeText(d[S],C+T*g[S],.5*(c+y)+S*y);if(i)for(S=0;S<f;++S)E.fillText(d[S],C+T*g[S],.5*(c+y)+S*y)}return ko.get(o)},e.prototype.drawTextImage_=function(t,e,i){var r=this.textState_,n=this.textStrokeState_,o=this.pixelRatio,s=ks[r.textAlign||"center"],a=ks[r.textBaseline],h=n&&n.lineWidth?n.lineWidth:0,l=s*t.width/o+2*(.5-s)*h,u=a*t.height/o+2*(.5-a)*h;this.instructions.push([Gs.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*o,(u-this.textOffsetY_)*o,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1,t.width,r.padding==Do?Do:r.padding.map(function(t){return t*o}),!!r.backgroundFill,!!r.backgroundStroke]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*o,(u-this.textOffsetY_)*o,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1/o,t.width,r.padding,!!r.backgroundFill,!!r.backgroundStroke])},e.prototype.drawChars_=function(t,e,i){var r=this.textStrokeState_,n=this.textState_,o=this.textFillState_,s=this.strokeKey_;r&&(s in this.strokeStates||(this.strokeStates[s]={strokeStyle:r.strokeStyle,lineCap:r.lineCap,lineDashOffset:r.lineDashOffset,lineWidth:r.lineWidth,lineJoin:r.lineJoin,miterLimit:r.miterLimit,lineDash:r.lineDash}));var a=this.textKey_;this.textKey_ in this.textStates||(this.textStates[this.textKey_]={font:n.font,textAlign:n.textAlign||"center",scale:n.scale});var h=this.fillKey_;o&&(h in this.fillStates||(this.fillStates[h]={fillStyle:o.fillStyle}));var l=this.pixelRatio,u=ks[n.textBaseline],p=this.textOffsetY_*l,c=this.text_,d=n.font,f=n.scale,g=r?r.lineWidth*f/2:0,_=this.widths_[d];_||(this.widths_[d]=_={}),this.instructions.push([Gs.DRAW_CHARS,t,e,u,i,n.overflow,h,n.maxAngle,function(t){var e=_[t];return e||(e=_[t]=zo(d,t)),e*f*l},p,s,g*l,c,a,1]),this.hitDetectionInstructions.push([Gs.DRAW_CHARS,t,e,u,i,n.overflow,h,n.maxAngle,function(t){var e=_[t];return e||(e=_[t]=zo(d,t)),e*f},p,s,g,c,a,1/l])},e.prototype.setTextStyle=function(t,e){var i,r,n;if(t){this.declutterGroup_=e;var s=t.getFill();s?((r=this.textFillState_)||(r=this.textFillState_={}),r.fillStyle=ns(s.getColor()||No)):r=this.textFillState_=null;var a=t.getStroke();if(a){(n=this.textStrokeState_)||(n=this.textStrokeState_={});var h=a.getLineDash(),l=a.getLineDashOffset(),u=a.getWidth(),p=a.getMiterLimit();n.lineCap=a.getLineCap()||"round",n.lineDash=h?h.slice():Ao,n.lineDashOffset=void 0===l?0:l,n.lineJoin=a.getLineJoin()||"round",n.lineWidth=void 0===u?1:u,n.miterLimit=void 0===p?10:p,n.strokeStyle=ns(a.getColor()||Go)}else n=this.textStrokeState_=null;i=this.textState_;var c=t.getFont()||"10px sans-serif";Xo(c);var d=t.getScale();i.overflow=t.getOverflow(),i.font=c,i.maxAngle=t.getMaxAngle(),i.placement=t.getPlacement(),i.textAlign=t.getTextAlign(),i.textBaseline=t.getTextBaseline()||"middle",i.backgroundFill=t.getBackgroundFill(),i.backgroundStroke=t.getBackgroundStroke(),i.padding=t.getPadding()||Do,i.scale=void 0===d?1:d;var f=t.getOffsetX(),g=t.getOffsetY(),_=t.getRotateWithView(),y=t.getRotation();this.text_=t.getText()||"",this.textOffsetX_=void 0===f?0:f,this.textOffsetY_=void 0===g?0:g,this.textRotateWithView_=void 0!==_&&_,this.textRotation_=void 0===y?0:y,this.strokeKey_=n?("string"==typeof n.strokeStyle?n.strokeStyle:o(n.strokeStyle))+n.lineCap+n.lineDashOffset+"|"+n.lineWidth+n.lineJoin+n.miterLimit+"["+n.lineDash.join()+"]":"",this.textKey_=i.font+i.scale+(i.textAlign||"?"),this.fillKey_=r?"string"==typeof r.fillStyle?r.fillStyle:"|"+o(r.fillStyle):""}else this.text_=""},e}(js)},Hs=function(t){function e(e,i,r,n,o,s,a){t.call(this),this.declutterTree_=s,this.declutterGroup_=null,this.tolerance_=e,this.maxExtent_=i,this.overlaps_=o,this.pixelRatio_=n,this.resolution_=r,this.renderBuffer_=a,this.replaysByZIndex_={},this.hitDetectionContext_=on(1,1),this.hitDetectionTransform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addDeclutter=function(t){var e=null;return this.declutterTree_&&(t?(e=this.declutterGroup_)[4]++:(e=this.declutterGroup_=[1/0,1/0,-1/0,-1/0]).push(1)),e},e.prototype.clip=function(t,e){var i=this.getClipCoords(e);t.beginPath(),t.moveTo(i[0],i[1]),t.lineTo(i[2],i[3]),t.lineTo(i[4],i[5]),t.lineTo(i[6],i[7]),t.clip()},e.prototype.hasReplays=function(t){for(var e in this.replaysByZIndex_)for(var i=this.replaysByZIndex_[e],r=0,n=t.length;r<n;++r)if(t[r]in i)return!0;return!1},e.prototype.finish=function(){for(var t in this.replaysByZIndex_){var e=this.replaysByZIndex_[t];for(var i in e)e[i].finish()}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n,o,s){var a,h=2*(r=Math.round(r))+1,l=cr(this.hitDetectionTransform_,r+.5,r+.5,1/e,-1/e,-i,-t[0],-t[1]),u=this.hitDetectionContext_;u.canvas.width!==h||u.canvas.height!==h?(u.canvas.width=h,u.canvas.height=h):u.clearRect(0,0,h,h),void 0!==this.renderBuffer_&&(qe(a=[1/0,1/0,-1/0,-1/0],t),Ge(a,e*(this.renderBuffer_+r),a));var p,c,d=function(t){if(void 0!==qs[t])return qs[t];for(var e=2*t+1,i=new Array(e),r=0;r<e;r++)i[r]=new Array(e);var n=t,o=0,s=0;for(;n>=o;)Js(i,t+n,t+o),Js(i,t+o,t+n),Js(i,t-o,t+n),Js(i,t-n,t+o),Js(i,t-n,t-o),Js(i,t-o,t-n),Js(i,t+o,t-n),Js(i,t+n,t-o),2*((s+=1+2*++o)-n)+1>0&&(s+=1-2*(n-=1));return qs[t]=i,i}(r);function f(t){for(var e=u.getImageData(0,0,h,h).data,i=0;i<h;i++)for(var r=0;r<h;r++)if(d[i][r]&&e[4*(r*h+i)+3]>0){var n=void 0;return(!p||c!=Os.IMAGE&&c!=Os.TEXT||-1!==p.indexOf(t))&&(n=o(t)),n||void u.clearRect(0,0,h,h)}}this.declutterTree_&&(p=this.declutterTree_.all().map(function(t){return t.value}));var g,_,y,v,m,E=Object.keys(this.replaysByZIndex_).map(Number);for(E.sort(Nt),g=E.length-1;g>=0;--g){var S=E[g].toString();for(y=this.replaysByZIndex_[S],_=Ds.length-1;_>=0;--_)if(void 0!==(v=y[c=Ds[_]]))if(!s||c!=Os.IMAGE&&c!=Os.TEXT){if(m=v.replayHitDetection(u,l,i,n,f,a))return m}else{var T=s[S];T?T.push(v,l.slice(0)):s[S]=[v,l.slice(0)]}}},e.prototype.getClipCoords=function(t){var e=this.maxExtent_,i=e[0],r=e[1],n=e[2],o=e[3],s=[i,r,i,o,n,o,n,r];return vi(s,0,8,2,t,s),s},e.prototype.getReplay=function(t,e){var i=void 0!==t?t.toString():"0",r=this.replaysByZIndex_[i];void 0===r&&(r={},this.replaysByZIndex_[i]=r);var n=r[e];void 0===n&&(n=new(0,Zs[e])(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_,this.overlaps_,this.declutterTree_),r[e]=n);return n},e.prototype.getReplays=function(){return this.replaysByZIndex_},e.prototype.isEmpty=function(){return d(this.replaysByZIndex_)},e.prototype.replay=function(t,e,i,r,n,o,s){var a=Object.keys(this.replaysByZIndex_).map(Number);a.sort(Nt),t.save(),this.clip(t,e);var h,l,u,p,c,d,f=o||Ds;for(h=0,l=a.length;h<l;++h){var g=a[h].toString();for(c=this.replaysByZIndex_[g],u=0,p=f.length;u<p;++u){var _=f[u];if(d=c[_],void 0!==d)if(!s||_!=Os.IMAGE&&_!=Os.TEXT)d.replay(t,e,i,r,n);else{var y=s[g];y?y.push(d,e.slice(0)):s[g]=[d,e.slice(0)]}}}t.restore()},e}(Is),qs={0:[[!0]]};function Js(t,e,i){var r,n=Math.floor(t.length/2);if(e>=n)for(r=n;r<e;r++)t[r][i]=!0;else if(e<n)for(r=e+1;r<n;r++)t[r][i]=!0}var Qs=Hs,$s=.5,ta={Point:function(t,e,i,r){var n=i.getImage();if(n){if(n.getImageState()!=Oo.LOADED)return;var o=t.getReplay(i.getZIndex(),Os.IMAGE);o.setImageStyle(n,t.addDeclutter(!1)),o.drawPoint(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!!n)),a.drawText(e,r)}},LineString:function(t,e,i,r){var n=i.getStroke();if(n){var o=t.getReplay(i.getZIndex(),Os.LINE_STRING);o.setFillStrokeStyle(null,n),o.drawLineString(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!1)),a.drawText(e,r)}},Polygon:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(n||o){var s=t.getReplay(i.getZIndex(),Os.POLYGON);s.setFillStrokeStyle(n,o),s.drawPolygon(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}},MultiPoint:function(t,e,i,r){var n=i.getImage();if(n){if(n.getImageState()!=Oo.LOADED)return;var o=t.getReplay(i.getZIndex(),Os.IMAGE);o.setImageStyle(n,t.addDeclutter(!1)),o.drawMultiPoint(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!!n)),a.drawText(e,r)}},MultiLineString:function(t,e,i,r){var n=i.getStroke();if(n){var o=t.getReplay(i.getZIndex(),Os.LINE_STRING);o.setFillStrokeStyle(null,n),o.drawMultiLineString(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!1)),a.drawText(e,r)}},MultiPolygon:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(o||n){var s=t.getReplay(i.getZIndex(),Os.POLYGON);s.setFillStrokeStyle(n,o),s.drawMultiPolygon(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}},GeometryCollection:function(t,e,i,r){var n,o,s=e.getGeometriesArray();for(n=0,o=s.length;n<o;++n){var a=ta[s[n].getType()];a(t,s[n],i,r)}},Circle:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(n||o){var s=t.getReplay(i.getZIndex(),Os.CIRCLE);s.setFillStrokeStyle(n,o),s.drawCircle(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}}};function ea(t,e){return parseInt(o(t),10)-parseInt(o(e),10)}function ia(t,e){var i=ra(t,e);return i*i}function ra(t,e){return $s*t/e}function na(t,e,i,r,n,o){var s=!1,a=i.getImage();if(a){var h=a.getImageState();h==Oo.LOADED||h==Oo.ERROR?a.unlistenImageChange(n,o):(h==Oo.IDLE&&a.load(),h=a.getImageState(),a.listenImageChange(n,o),s=!0)}return function(t,e,i,r){var n=i.getGeometryFunction()(e);if(!n)return;var o=n.getSimplifiedGeometry(r);if(i.getRenderer())!function t(e,i,r,n){if(i.getType()==_i.GEOMETRY_COLLECTION){for(var o=i.getGeometries(),s=0,a=o.length;s<a;++s)t(e,o[s],r,n);return}var h=e.getReplay(r.getZIndex(),Os.DEFAULT);h.drawCustom(i,n,r.getRenderer())}(t,o,i,e);else{var s=ta[o.getType()];s(t,o,i,e)}}(t,e,i,r),s}var oa=function(t){function e(e){t.call(this,e),this.declutterTree_=e.getDeclutter()?xs()(9,void 0):null,this.dirty_=!1,this.renderedRevision_=-1,this.renderedResolution_=NaN,this.renderedExtent_=[1/0,1/0,-1/0,-1/0],this.renderedRenderOrder_=null,this.replayGroup_=null,this.replayGroupChanged=!0,this.context=on(),v(ko,M.CLEAR,this.handleFontsChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){E(ko,M.CLEAR,this.handleFontsChanged_,this),t.prototype.disposeInternal.call(this)},e.prototype.compose=function(t,e,i){var r=e.extent,n=e.pixelRatio,o=i.managed?e.skippedFeatureUids:{},s=e.viewState,a=s.projection,h=s.rotation,l=a.getExtent(),u=this.getLayer().getSource(),p=this.getTransform(e,0),c=i.extent,d=void 0!==c;d&&this.clip(t,e,c);var f=this.replayGroup_;if(f&&!f.isEmpty()){this.declutterTree_&&this.declutterTree_.clear();var g,_=this.getLayer(),y=0,v=0,m=1!==i.opacity,E=_.hasListener(Qt.RENDER);if(m||E){var S=t.canvas.width,T=t.canvas.height;if(h){var C=Math.round(Math.sqrt(S*S+T*T));y=(C-S)/2,v=(C-T)/2,S=T=C}this.context.canvas.width=S,this.context.canvas.height=T,g=this.context}else g=t;var R=g.globalAlpha;m||(g.globalAlpha=i.opacity),g!=t&&g.translate(y,v);var x=e.viewHints,w=!(x[ge]||x[_e]),I=e.size[0]*n,O=e.size[1]*n;if(Zo(g,-h,I/2,O/2),f.replay(g,p,h,o,w),u.getWrapX()&&a.canWrapX()&&!Ue(l,r)){for(var L,P=r[0],M=pi(l),F=0;P<l[0];)L=M*--F,p=this.getTransform(e,L),f.replay(g,p,h,o,w),P+=M;for(F=0,P=r[2];P>l[2];)L=M*++F,p=this.getTransform(e,L),f.replay(g,p,h,o,w),P-=M}if(Zo(g,h,I/2,O/2),E&&this.dispatchRenderEvent(g,e,p),g!=t){if(m){var b=t.globalAlpha;t.globalAlpha=i.opacity,t.drawImage(g.canvas,-y,-v),t.globalAlpha=b}else t.drawImage(g.canvas,-y,-v);g.translate(-y,-v)}m||(g.globalAlpha=R)}d&&t.restore()},e.prototype.composeFrame=function(t,e,i){var r=this.getTransform(t,0);this.preCompose(i,t,r),this.compose(i,t,e),this.postCompose(i,t,e,r)},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n){if(this.replayGroup_){var s=e.viewState.resolution,a=e.viewState.rotation,h=this.getLayer(),l={};return this.replayGroup_.forEachFeatureAtCoordinate(t,s,a,i,{},function(t){var e=o(t);if(!(e in l))return l[e]=!0,r.call(n,t,h)},null)}},e.prototype.handleFontsChanged_=function(t){var e=this.getLayer();e.getVisible()&&this.replayGroup_&&e.changed()},e.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},e.prototype.prepareFrame=function(t,e){var i=this.getLayer(),r=i.getSource(),n=t.viewHints[ge],o=t.viewHints[_e],s=i.getUpdateWhileAnimating(),a=i.getUpdateWhileInteracting();if(!this.dirty_&&!s&&n||!a&&o)return!0;var h=t.extent,l=t.viewState,u=l.projection,p=l.resolution,c=t.pixelRatio,d=i.getRevision(),f=i.getRenderBuffer(),g=i.getRenderOrder();void 0===g&&(g=ea);var _=Ge(h,f*p),y=l.projection.getExtent();if(r.getWrapX()&&l.projection.canWrapX()&&!Ue(y,t.extent)){var v=pi(y),m=Math.max(pi(_)/2,v);_[0]=y[0]-m,_[2]=y[2]+m}if(!this.dirty_&&this.renderedResolution_==p&&this.renderedRevision_==d&&this.renderedRenderOrder_==g&&Ue(this.renderedExtent_,_))return this.replayGroupChanged=!1,!0;this.replayGroup_=null,this.dirty_=!1;var E=new Qs(ra(p,c),_,p,c,r.getOverlaps(),this.declutterTree_,i.getRenderBuffer());r.loadFeatures(_,p,u);var S=function(t){var e,r=t.getStyleFunction()||i.getStyleFunction();if(r&&(e=r(t,p)),e){var n=this.renderFeature(t,p,c,e,E);this.dirty_=this.dirty_||n}}.bind(this);if(g){var T=[];r.forEachFeatureInExtent(_,function(t){T.push(t)}),T.sort(g);for(var C=0,R=T.length;C<R;++C)S(T[C])}else r.forEachFeatureInExtent(_,S);return E.finish(),this.renderedResolution_=p,this.renderedRevision_=d,this.renderedRenderOrder_=g,this.renderedExtent_=_,this.replayGroup_=E,this.replayGroupChanged=!0,!0},e.prototype.renderFeature=function(t,e,i,r,n){if(!r)return!1;var o=!1;if(Array.isArray(r))for(var s=0,a=r.length;s<a;++s)o=na(n,t,r[s],ia(e,i),this.handleStyleImageChange_,this)||o;else o=na(n,t,r,ia(e,i),this.handleStyleImageChange_,this);return o},e}(gs);oa.handles=function(t){return t.getType()===Po.VECTOR},oa.create=function(t,e){return new oa(e)};var sa=oa,aa={IMAGE:"image",HYBRID:"hybrid",VECTOR:"vector"},ha={image:[Os.POLYGON,Os.CIRCLE,Os.LINE_STRING,Os.IMAGE,Os.TEXT],hybrid:[Os.POLYGON,Os.LINE_STRING]},la={image:[Os.DEFAULT],hybrid:[Os.IMAGE,Os.TEXT,Os.DEFAULT],vector:Ds},ua=function(t){function e(e){t.call(this,e,!0),this.declutterTree_=e.getDeclutter()?xs()(9,void 0):null,this.dirty_=!1,this.renderedLayerRevision_,this.tmpTransform_=[1,0,0,1,0,0];var i=e.getRenderMode();this.zDirection=i===aa.VECTOR?1:0,i!==aa.VECTOR&&(this.context=on()),v(ko,M.CLEAR,this.handleFontsChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){E(ko,M.CLEAR,this.handleFontsChanged_,this),t.prototype.disposeInternal.call(this)},e.prototype.getTile=function(e,i,r,n,o){var s=t.prototype.getTile.call(this,e,i,r,n,o);return s.getState()===$t.LOADED&&(this.createReplayGroup_(s,n,o),this.context&&this.renderTileImage_(s,n,o)),s},e.prototype.getTileImage=function(t){var e=this.getLayer();return t.getImage(e)},e.prototype.prepareFrame=function(e,i){var r=this.getLayer().getRevision();return this.renderedLayerRevision_!=r&&(this.renderedTiles.length=0),this.renderedLayerRevision_=r,t.prototype.prepareFrame.call(this,e,i)},e.prototype.createReplayGroup_=function(t,e,i){var r=this,n=this.getLayer(),o=n.getRevision(),s=n.getRenderOrder()||null,a=t.getReplayState(n);if(a.dirty||a.renderedRevision!=o||a.renderedRenderOrder!=s){for(var h=n.getSource(),l=h.getTileGrid(),u=h.getTileGridForProjection(i).getResolution(t.tileCoord[0]),p=t.extent,c=function(o,c){var d=t.getTile(t.tileKeys[o]);if(d.getState()==$t.LOADED){var f=d.tileCoord,g=l.getTileCoordExtent(f),_=hi(p,g),y=Ze(g,_)?null:Ge(_,n.getRenderBuffer()*u,r.tmpExtent),v=d.getProjection(),m=!1;$i(i,v)||(m=!0,d.setProjection(i)),a.dirty=!1;var E=new Qs(0,_,u,e,h.getOverlaps(),r.declutterTree_,n.getRenderBuffer()),S=ia(u,e),T=function(t){var e,i=t.getStyleFunction()||n.getStyleFunction();if(i&&(e=i(t,u)),e){var r=this.renderFeature(t,S,e,E);this.dirty_=this.dirty_||r,a.dirty=a.dirty||r}},C=d.getFeatures();s&&s!==a.renderedRenderOrder&&C.sort(s);for(var R=0,x=C.length;R<x;++R){var w=C[R];m&&(v.getUnits()==Ci.TILE_PIXELS&&(v.setWorldExtent(g),v.setExtent(d.getExtent())),w.getGeometry().transform(v,i)),y&&!ci(y,w.getGeometry().getExtent())||T.call(r,w)}E.finish(),d.setReplayGroup(n,t.tileCoord.toString(),E)}},d=0,f=t.tileKeys.length;d<f;++d)c(d);a.renderedRevision=o,a.renderedRenderOrder=s}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n){var s=e.viewState.resolution,a=e.viewState.rotation;i=null==i?0:i;var h,l,u,p,c=this.getLayer(),d={},f=this.renderedTiles;for(u=0,p=f.length;u<p;++u){var g=f[u];if(Ye(h=Ge(g.extent,i*s,h),t))for(var _=0,y=g.tileKeys.length;_<y;++_){var v=g.getTile(g.tileKeys[_]);if(v.getState()==$t.LOADED){var m=v.getReplayGroup(c,g.tileCoord.toString());l=l||m.forEachFeatureAtCoordinate(t,s,a,i,{},function(t){var e=o(t);if(!(e in d))return d[e]=!0,r.call(n,t,c)},null)}}}return l},e.prototype.getReplayTransform_=function(t,e){var i=this.getLayer().getSource().getTileGrid(),r=t.tileCoord,n=i.getResolution(r[0]),o=e.viewState,s=e.pixelRatio,a=o.resolution/s,h=i.getTileCoordExtent(r,this.tmpExtent),l=o.center,u=li(h),p=e.size,c=Math.round(s*p[0]/2),d=Math.round(s*p[1]/2);return cr(this.tmpTransform_,c,d,n/a,n/a,o.rotation,(u[0]-l[0])/n,(l[1]-u[1])/n)},e.prototype.handleFontsChanged_=function(t){var e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()},e.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},e.prototype.postCompose=function(e,i,r){var n=this.getLayer(),o=n.getRenderMode();if(o!=aa.IMAGE){var s,a,h=n.getDeclutter()?{}:null,l=n.getSource(),u=la[o],p=i.pixelRatio,c=i.viewState.rotation,d=i.size;c&&Zo(e,-c,s=Math.round(p*d[0]/2),a=Math.round(p*d[1]/2)),h&&this.declutterTree_.clear();for(var f=i.viewHints,g=!(f[ge]||f[_e]),_=this.renderedTiles,y=l.getTileGridForProjection(i.viewState.projection),v=[],m=[],E=_.length-1;E>=0;--E){var S=_[E];if(S.getState()!=$t.ABORT)for(var T=S.tileCoord,C=y.getTileCoordExtent(T,this.tmpExtent)[0]-S.extent[0],R=void 0,x=0,w=S.tileKeys.length;x<w;++x){var I=S.getTile(S.tileKeys[x]);if(I.getState()==$t.LOADED){var O=I.getReplayGroup(n,T.toString());if(O&&O.hasReplays(u)){R||(R=this.getTransform(i,C));var L=I.tileCoord[0],P=O.getClipCoords(R);e.save(),e.globalAlpha=r.opacity;for(var M=0,F=v.length;M<F;++M){var b=v[M];L<m[M]&&(e.beginPath(),e.moveTo(P[0],P[1]),e.lineTo(P[2],P[3]),e.lineTo(P[4],P[5]),e.lineTo(P[6],P[7]),e.moveTo(b[6],b[7]),e.lineTo(b[4],b[5]),e.lineTo(b[2],b[3]),e.lineTo(b[0],b[1]),e.clip())}O.replay(e,R,c,{},g,u,h),e.restore(),v.push(P),m.push(L)}}}}h&&function(t,e,i,r){for(var n=Object.keys(t).map(Number).sort(Nt),o={},s=0,a=n.length;s<a;++s)for(var h=t[n[s].toString()],l=0,u=h.length;l<u;){var p=h[l++],c=h[l++];p.replay(e,c,i,o,r)}}(h,e,c,g),c&&Zo(e,c,s,a)}t.prototype.postCompose.call(this,e,i,r)},e.prototype.renderFeature=function(t,e,i,r){if(!i)return!1;var n=!1;if(Array.isArray(i))for(var o=0,s=i.length;o<s;++o)n=na(r,t,i[o],e,this.handleStyleImageChange_,this)||n;else n=na(r,t,i,e,this.handleStyleImageChange_,this);return n},e.prototype.renderTileImage_=function(t,e,i){var r=this.getLayer(),n=t.getReplayState(r),o=r.getRevision(),s=ha[r.getRenderMode()];if(s&&n.renderedTileRevision!==o){n.renderedTileRevision=o;var a=t.wrappedTileCoord,h=a[0],l=r.getSource(),u=l.getTileGridForProjection(i),p=u.getResolution(h),c=t.getContext(r),d=l.getTilePixelSize(h,e,i);c.canvas.width=d[0],c.canvas.height=d[1];for(var f=u.getTileCoordExtent(a,this.tmpExtent),g=0,_=t.tileKeys.length;g<_;++g){var y=t.getTile(t.tileKeys[g]);if(y.getState()==$t.LOADED){var v=e/p,m=or(this.tmpTransform_);ur(m,v,-v),pr(m,-f[0],-f[3]),y.getReplayGroup(r,t.tileCoord.toString()).replay(c,m,0,{},!0,s)}}}},e}(Cs);ua.handles=function(t){return t.getType()===Po.VECTOR_TILE},ua.create=function(t,e){return new ua(e)};var pa=ua,ca=function(t){function e(e){(e=u({},e)).controls||(e.controls=function(t){var e=t||{},i=new Y;return(void 0===e.zoom||e.zoom)&&i.push(new bn(e.zoomOptions)),(void 0===e.rotate||e.rotate)&&i.push(new Fn(e.rotateOptions)),(void 0===e.attribution||e.attribution)&&i.push(new Pn(e.attributionOptions)),i}()),e.interactions||(e.interactions=xo()),t.call(this,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createRenderer=function(){var t=new fs(this);return t.registerLayerRenderers([vs,Cs,sa,pa]),t},e}(yn),da={BOTTOM_LEFT:"bottom-left",BOTTOM_CENTER:"bottom-center",BOTTOM_RIGHT:"bottom-right",CENTER_LEFT:"center-left",CENTER_CENTER:"center-center",CENTER_RIGHT:"center-right",TOP_LEFT:"top-left",TOP_CENTER:"top-center",TOP_RIGHT:"top-right"},fa={ELEMENT:"element",MAP:"map",OFFSET:"offset",POSITION:"position",POSITIONING:"positioning"},ga=function(t){function e(e){t.call(this),this.options=e,this.id=e.id,this.insertFirst=void 0===e.insertFirst||e.insertFirst,this.stopEvent=void 0===e.stopEvent||e.stopEvent,this.element=document.createElement("div"),this.element.className=void 0!==e.className?e.className:"ol-overlay-container "+Tn,this.element.style.position="absolute",this.autoPan=void 0!==e.autoPan&&e.autoPan,this.autoPanAnimation=e.autoPanAnimation||{},this.autoPanMargin=void 0!==e.autoPanMargin?e.autoPanMargin:20,this.rendered={bottom_:"",left_:"",right_:"",top_:"",visible:!0},this.mapPostrenderListenerKey=null,v(this,A(fa.ELEMENT),this.handleElementChanged,this),v(this,A(fa.MAP),this.handleMapChanged,this),v(this,A(fa.OFFSET),this.handleOffsetChanged,this),v(this,A(fa.POSITION),this.handlePositionChanged,this),v(this,A(fa.POSITIONING),this.handlePositioningChanged,this),void 0!==e.element&&this.setElement(e.element),this.setOffset(void 0!==e.offset?e.offset:[0,0]),this.setPositioning(void 0!==e.positioning?e.positioning:da.TOP_LEFT),void 0!==e.position&&this.setPosition(e.position)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getElement=function(){return this.get(fa.ELEMENT)},e.prototype.getId=function(){return this.id},e.prototype.getMap=function(){return this.get(fa.MAP)},e.prototype.getOffset=function(){return this.get(fa.OFFSET)},e.prototype.getPosition=function(){return this.get(fa.POSITION)},e.prototype.getPositioning=function(){return this.get(fa.POSITIONING)},e.prototype.handleElementChanged=function(){un(this.element);var t=this.getElement();t&&this.element.appendChild(t)},e.prototype.handleMapChanged=function(){this.mapPostrenderListenerKey&&(ln(this.element),S(this.mapPostrenderListenerKey),this.mapPostrenderListenerKey=null);var t=this.getMap();if(t){this.mapPostrenderListenerKey=v(t,qt.POSTRENDER,this.render,this),this.updatePixelPosition();var e=this.stopEvent?t.getOverlayContainerStopEvent():t.getOverlayContainer();this.insertFirst?e.insertBefore(this.element,e.childNodes[0]||null):e.appendChild(this.element)}},e.prototype.render=function(){this.updatePixelPosition()},e.prototype.handleOffsetChanged=function(){this.updatePixelPosition()},e.prototype.handlePositionChanged=function(){this.updatePixelPosition(),this.get(fa.POSITION)&&this.autoPan&&this.panIntoView()},e.prototype.handlePositioningChanged=function(){this.updatePixelPosition()},e.prototype.setElement=function(t){this.set(fa.ELEMENT,t)},e.prototype.setMap=function(t){this.set(fa.MAP,t)},e.prototype.setOffset=function(t){this.set(fa.OFFSET,t)},e.prototype.setPosition=function(t){this.set(fa.POSITION,t)},e.prototype.panIntoView=function(){var t=this.getMap();if(t&&t.getTargetElement()){var e=this.getRect(t.getTargetElement(),t.getSize()),i=this.getElement(),r=this.getRect(i,[sn(i),an(i)]),n=this.autoPanMargin;if(!Ue(e,r)){var o=r[0]-e[0],s=e[2]-r[2],a=r[1]-e[1],h=e[3]-r[3],l=[0,0];if(o<0?l[0]=o-n:s<0&&(l[0]=Math.abs(s)+n),a<0?l[1]=a-n:h<0&&(l[1]=Math.abs(h)+n),0!==l[0]||0!==l[1]){var u=t.getView().getCenter(),p=t.getPixelFromCoordinate(u),c=[p[0]+l[0],p[1]+l[1]];t.getView().animate({center:t.getCoordinateFromPixel(c),duration:this.autoPanAnimation.duration,easing:this.autoPanAnimation.easing})}}}},e.prototype.getRect=function(t,e){var i=t.getBoundingClientRect(),r=i.left+window.pageXOffset,n=i.top+window.pageYOffset;return[r,n,r+e[0],n+e[1]]},e.prototype.setPositioning=function(t){this.set(fa.POSITIONING,t)},e.prototype.setVisible=function(t){this.rendered.visible!==t&&(this.element.style.display=t?"":"none",this.rendered.visible=t)},e.prototype.updatePixelPosition=function(){var t=this.getMap(),e=this.getPosition();if(t&&t.isRendered()&&e){var i=t.getPixelFromCoordinate(e),r=t.getSize();this.updateRenderedPosition(i,r)}else this.setVisible(!1)},e.prototype.updateRenderedPosition=function(t,e){var i=this.element.style,r=this.getOffset(),n=this.getPositioning();this.setVisible(!0);var o=r[0],s=r[1];if(n==da.BOTTOM_RIGHT||n==da.CENTER_RIGHT||n==da.TOP_RIGHT){""!==this.rendered.left_&&(this.rendered.left_=i.left="");var a=Math.round(e[0]-t[0]-o)+"px";this.rendered.right_!=a&&(this.rendered.right_=i.right=a)}else{""!==this.rendered.right_&&(this.rendered.right_=i.right=""),n!=da.BOTTOM_CENTER&&n!=da.CENTER_CENTER&&n!=da.TOP_CENTER||(o-=this.element.offsetWidth/2);var h=Math.round(t[0]+o)+"px";this.rendered.left_!=h&&(this.rendered.left_=i.left=h)}if(n==da.BOTTOM_LEFT||n==da.BOTTOM_CENTER||n==da.BOTTOM_RIGHT){""!==this.rendered.top_&&(this.rendered.top_=i.top="");var l=Math.round(e[1]-t[1]-s)+"px";this.rendered.bottom_!=l&&(this.rendered.bottom_=i.bottom=l)}else{""!==this.rendered.bottom_&&(this.rendered.bottom_=i.bottom=""),n!=da.CENTER_LEFT&&n!=da.CENTER_CENTER&&n!=da.CENTER_RIGHT||(s-=this.element.offsetHeight/2);var u=Math.round(t[1]+s)+"px";this.rendered.top_!=u&&(this.rendered.top_=i.top=u)}},e.prototype.getOptions=function(){return this.options},e}(G);function _a(t){this.validateExtent_(),this.updateBox_()}var ya=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||_a,target:i.target}),this.collapsed_=void 0===i.collapsed||i.collapsed,this.collapsible_=void 0===i.collapsible||i.collapsible,this.collapsible_||(this.collapsed_=!1);var r=void 0!==i.className?i.className:"ol-overviewmap",n=void 0!==i.tipLabel?i.tipLabel:"Overview map",o=void 0!==i.collapseLabel?i.collapseLabel:"«";"string"==typeof o?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=o):this.collapseLabel_=o;var s=void 0!==i.label?i.label:"»";"string"==typeof s?(this.label_=document.createElement("span"),this.label_.textContent=s):this.label_=s;var a=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_,h=document.createElement("button");h.setAttribute("type","button"),h.title=n,h.appendChild(a),v(h,M.CLICK,this.handleClick_,this),this.ovmapDiv_=document.createElement("div"),this.ovmapDiv_.className="ol-overviewmap-map",this.ovmap_=new ca({controls:new Y,interactions:new Y,view:i.view});var l=this.ovmap_;i.layers&&i.layers.forEach(function(t){l.addLayer(t)}.bind(this));var u=document.createElement("div");u.className="ol-overviewmap-box",u.style.boxSizing="border-box",this.boxOverlay_=new ga({position:[0,0],positioning:da.BOTTOM_LEFT,element:u}),this.ovmap_.addOverlay(this.boxOverlay_);var p=r+" "+Cn+" "+Rn+(this.collapsed_&&this.collapsible_?" "+xn:"")+(this.collapsible_?"":" ol-uncollapsible"),c=this.element;c.className=p,c.appendChild(this.ovmapDiv_),c.appendChild(h);var d=this,f=this.boxOverlay_,g=this.boxOverlay_.getElement(),_=function(t){var e,i={clientX:(e=t).clientX-g.offsetWidth/2,clientY:e.clientY+g.offsetHeight/2},r=l.getEventCoordinate(i);f.setPosition(r)},y=function(t){var e=l.getEventCoordinate(t);d.getMap().getView().setCenter(e),window.removeEventListener("mousemove",_),window.removeEventListener("mouseup",y)};g.addEventListener("mousedown",function(){window.addEventListener("mousemove",_),window.addEventListener("mouseup",y)})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setMap=function(e){var i=this.getMap();if(e!==i){if(i){var r=i.getView();r&&this.unbindView_(r),this.ovmap_.setTarget(null)}if(t.prototype.setMap.call(this,e),e){this.ovmap_.setTarget(this.ovmapDiv_),this.listenerKeys.push(v(e,l,this.handleMapPropertyChange_,this)),0===this.ovmap_.getLayers().getLength()&&this.ovmap_.setLayerGroup(e.getLayerGroup());var n=e.getView();n&&(this.bindView_(n),n.isDef()&&(this.ovmap_.updateSize(),this.resetExtent_()))}}},e.prototype.handleMapPropertyChange_=function(t){if(t.key===Jt.VIEW){var e=t.oldValue;e&&this.unbindView_(e);var i=this.getMap().getView();this.bindView_(i)}},e.prototype.bindView_=function(t){v(t,A(me),this.handleRotationChanged_,this)},e.prototype.unbindView_=function(t){E(t,A(me),this.handleRotationChanged_,this)},e.prototype.handleRotationChanged_=function(){this.ovmap_.getView().setRotation(this.getMap().getView().getRotation())},e.prototype.validateExtent_=function(){var t=this.getMap(),e=this.ovmap_;if(t.isRendered()&&e.isRendered()){var i=t.getSize(),r=t.getView().calculateExtent(i),n=e.getSize(),o=e.getView().calculateExtent(n),s=e.getPixelFromCoordinate(li(r)),a=e.getPixelFromCoordinate(ri(r)),h=Math.abs(s[0]-a[0]),l=Math.abs(s[1]-a[1]),u=n[0],p=n[1];h<.1*u||l<.1*p||h>.75*u||l>.75*p?this.resetExtent_():Ue(o,r)||this.recenter_()}},e.prototype.resetExtent_=function(){var t=this.getMap(),e=this.ovmap_,i=t.getSize(),r=t.getView().calculateExtent(i),n=e.getView(),o=Math.log(7.5)/Math.LN2;fi(r,1/(.1*Math.pow(2,o/2))),n.fit(r)},e.prototype.recenter_=function(){var t=this.getMap(),e=this.ovmap_,i=t.getView();e.getView().setCenter(i.getCenter())},e.prototype.updateBox_=function(){var t=this.getMap(),e=this.ovmap_;if(t.isRendered()&&e.isRendered()){var i=t.getSize(),r=t.getView(),n=e.getView(),o=r.getRotation(),s=this.boxOverlay_,a=this.boxOverlay_.getElement(),h=r.calculateExtent(i),l=n.getResolution(),u=ii(h),p=ui(h),c=this.calculateCoordinateRotate_(o,u);s.setPosition(c),a&&(a.style.width=Math.abs((u[0]-p[0])/l)+"px",a.style.height=Math.abs((p[1]-u[1])/l)+"px")}},e.prototype.calculateCoordinateRotate_=function(t,e){var i,r=this.getMap().getView().getCenter();return r&&(Re(i=[e[0]-r[0],e[1]-r[1]],t),Se(i,r)),i},e.prototype.handleClick_=function(t){t.preventDefault(),this.handleToggle_()},e.prototype.handleToggle_=function(){this.element.classList.toggle(xn),this.collapsed_?hn(this.collapseLabel_,this.label_):hn(this.label_,this.collapseLabel_),this.collapsed_=!this.collapsed_;var t=this.ovmap_;this.collapsed_||t.isRendered()||(t.updateSize(),this.resetExtent_(),m(t,qt.POSTRENDER,function(t){this.updateBox_()},this))},e.prototype.getCollapsible=function(){return this.collapsible_},e.prototype.setCollapsible=function(t){this.collapsible_!==t&&(this.collapsible_=t,this.element.classList.toggle("ol-uncollapsible"),!t&&this.collapsed_&&this.handleToggle_())},e.prototype.setCollapsed=function(t){this.collapsible_&&this.collapsed_!==t&&this.handleToggle_()},e.prototype.getCollapsed=function(){return this.collapsed_},e.prototype.getOverviewMap=function(){return this.ovmap_},e}(En),va="units",ma={DEGREES:"degrees",IMPERIAL:"imperial",NAUTICAL:"nautical",METRIC:"metric",US:"us"},Ea=[1,2,5];function Sa(t){var e=t.frameState;this.viewState_=e?e.viewState:null,this.updateElement_()}var Ta=function(t){function e(e){var i=e||{},r=void 0!==i.className?i.className:"ol-scale-line";t.call(this,{element:document.createElement("div"),render:i.render||Sa,target:i.target}),this.innerElement_=document.createElement("div"),this.innerElement_.className=r+"-inner",this.element.className=r+" "+Cn,this.element.appendChild(this.innerElement_),this.viewState_=null,this.minWidth_=void 0!==i.minWidth?i.minWidth:64,this.renderedVisible_=!1,this.renderedWidth_=void 0,this.renderedHTML_="",v(this,A(va),this.handleUnitsChanged_,this),this.setUnits(i.units||ma.METRIC)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getUnits=function(){return this.get(va)},e.prototype.handleUnitsChanged_=function(){this.updateElement_()},e.prototype.setUnits=function(t){this.set(va,t)},e.prototype.updateElement_=function(){var t=this.viewState_;if(t){var e=t.center,i=t.projection,r=this.getUnits(),n=r==ma.DEGREES?Ci.DEGREES:Ci.METERS,o=Hi(i,t.resolution,e,n);i.getUnits()!=Ci.DEGREES&&i.getMetersPerUnit()&&n==Ci.METERS&&(o*=i.getMetersPerUnit());var s=this.minWidth_*o,a="";if(r==ma.DEGREES){var h=Ti[Ci.DEGREES];i.getUnits()==Ci.DEGREES?s*=h:o/=h,s<h/60?(a="″",o*=3600):s<h?(a="′",o*=60):a="°"}else r==ma.IMPERIAL?s<.9144?(a="in",o/=.0254):s<1609.344?(a="ft",o/=.3048):(a="mi",o/=1609.344):r==ma.NAUTICAL?(o/=1852,a="nm"):r==ma.METRIC?s<.001?(a="μm",o*=1e6):s<1?(a="mm",o*=1e3):s<1e3?a="m":(a="km",o/=1e3):r==ma.US?s<.9144?(a="in",o*=39.37):s<1609.344?(a="ft",o/=.30480061):(a="mi",o/=1609.3472):te(!1,33);for(var l,u,p=3*Math.floor(Math.log(this.minWidth_*o)/Math.log(10));;){if(l=Ea[(p%3+3)%3]*Math.pow(10,Math.floor(p/3)),u=Math.round(l/o),isNaN(u))return this.element.style.display="none",void(this.renderedVisible_=!1);if(u>=this.minWidth_)break;++p}var c=l+" "+a;this.renderedHTML_!=c&&(this.innerElement_.innerHTML=c,this.renderedHTML_=c),this.renderedWidth_!=u&&(this.innerElement_.style.width=u+"px",this.renderedWidth_=u),this.renderedVisible_||(this.element.style.display="",this.renderedVisible_=!0)}else this.renderedVisible_&&(this.element.style.display="none",this.renderedVisible_=!1)},e}(En),Ca={VERTICAL:0,HORIZONTAL:1};function Ra(t){if(t.frameState){this.sliderInitialized_||this.initSlider_();var e=t.frameState.viewState.resolution;e!==this.currentResolution_&&(this.currentResolution_=e,this.setThumbPosition_(e))}}var xa=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Ra}),this.dragListenerKeys_=[],this.currentResolution_=void 0,this.direction_=Ca.VERTICAL,this.dragging_,this.heightLimit_=0,this.widthLimit_=0,this.previousX_,this.previousY_,this.thumbSize_=null,this.sliderInitialized_=!1,this.duration_=void 0!==i.duration?i.duration:200;var r=void 0!==i.className?i.className:"ol-zoomslider",n=document.createElement("button");n.setAttribute("type","button"),n.className=r+"-thumb "+Cn;var o=this.element;o.className=r+" "+Cn+" "+Rn,o.appendChild(n),this.dragger_=new Zt(o),v(this.dragger_,tt.POINTERDOWN,this.handleDraggerStart_,this),v(this.dragger_,tt.POINTERMOVE,this.handleDraggerDrag_,this),v(this.dragger_,tt.POINTERUP,this.handleDraggerEnd_,this),v(o,M.CLICK,this.handleContainerClick_,this),v(n,M.CLICK,O)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.dragger_.dispose(),t.prototype.disposeInternal.call(this)},e.prototype.setMap=function(e){t.prototype.setMap.call(this,e),e&&e.render()},e.prototype.initSlider_=function(){var t=this.element,e=t.offsetWidth,i=t.offsetHeight,r=t.firstElementChild,n=getComputedStyle(r),o=r.offsetWidth+parseFloat(n.marginRight)+parseFloat(n.marginLeft),s=r.offsetHeight+parseFloat(n.marginTop)+parseFloat(n.marginBottom);this.thumbSize_=[o,s],e>i?(this.direction_=Ca.HORIZONTAL,this.widthLimit_=e-o):(this.direction_=Ca.VERTICAL,this.heightLimit_=i-s),this.sliderInitialized_=!0},e.prototype.handleContainerClick_=function(t){var e=this.getMap().getView(),i=this.getRelativePosition_(t.offsetX-this.thumbSize_[0]/2,t.offsetY-this.thumbSize_[1]/2),r=this.getResolutionForPosition_(i);e.animate({resolution:e.constrainResolution(r),duration:this.duration_,easing:Pe})},e.prototype.handleDraggerStart_=function(t){if(!this.dragging_&&t.originalEvent.target===this.element.firstElementChild&&(this.getMap().getView().setHint(_e,1),this.previousX_=t.clientX,this.previousY_=t.clientY,this.dragging_=!0,0===this.dragListenerKeys_.length)){var e=this.handleDraggerDrag_,i=this.handleDraggerEnd_;this.dragListenerKeys_.push(v(document,M.MOUSEMOVE,e,this),v(document,tt.POINTERMOVE,e,this),v(document,M.MOUSEUP,i,this),v(document,tt.POINTERUP,i,this))}},e.prototype.handleDraggerDrag_=function(t){if(this.dragging_){var e=this.element.firstElementChild,i=t.clientX-this.previousX_+parseFloat(e.style.left),r=t.clientY-this.previousY_+parseFloat(e.style.top),n=this.getRelativePosition_(i,r);this.currentResolution_=this.getResolutionForPosition_(n),this.getMap().getView().setResolution(this.currentResolution_),this.setThumbPosition_(this.currentResolution_),this.previousX_=t.clientX,this.previousY_=t.clientY}},e.prototype.handleDraggerEnd_=function(t){if(this.dragging_){var e=this.getMap().getView();e.setHint(_e,-1),e.animate({resolution:e.constrainResolution(this.currentResolution_),duration:this.duration_,easing:Pe}),this.dragging_=!1,this.previousX_=void 0,this.previousY_=void 0,this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0}},e.prototype.setThumbPosition_=function(t){var e=this.getPositionForResolution_(t),i=this.element.firstElementChild;this.direction_==Ca.HORIZONTAL?i.style.left=this.widthLimit_*e+"px":i.style.top=this.heightLimit_*e+"px"},e.prototype.getRelativePosition_=function(t,e){return oe(this.direction_===Ca.HORIZONTAL?t/this.widthLimit_:e/this.heightLimit_,0,1)},e.prototype.getResolutionForPosition_=function(t){return this.getMap().getView().getResolutionForValueFunction()(1-t)},e.prototype.getPositionForResolution_=function(t){return 1-this.getMap().getView().getValueForResolutionFunction()(t)},e}(En),wa=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),target:i.target}),this.extent=i.extent?i.extent:null;var r=void 0!==i.className?i.className:"ol-zoom-extent",n=void 0!==i.label?i.label:"E",o=void 0!==i.tipLabel?i.tipLabel:"Fit to extent",s=document.createElement("button");s.setAttribute("type","button"),s.title=o,s.appendChild("string"==typeof n?document.createTextNode(n):n),v(s,M.CLICK,this.handleClick_,this);var a=r+" "+Cn+" "+Rn,h=this.element;h.className=a,h.appendChild(s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t){t.preventDefault(),this.handleZoomToExtent()},e.prototype.handleZoomToExtent=function(){var t=this.getMap().getView(),e=this.extent?this.extent:t.getProjection().getExtent();t.fit(e)},e}(En);function Ia(t){return"function"==typeof t?t:(Array.isArray(t)?e=t:(te("function"==typeof t.getZIndex,41),e=[t]),function(){return e});var e}var Oa=function(t){function e(e){if(t.call(this),this.id_=void 0,this.geometryName_="geometry",this.style_=null,this.styleFunction_=void 0,this.geometryChangeKey_=null,v(this,A(this.geometryName_),this.handleGeometryChanged_,this),e)if("function"==typeof e.getSimplifiedGeometry){var i=e;this.setGeometry(i)}else{var r=e;this.setProperties(r)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e(this.getProperties());t.setGeometryName(this.getGeometryName());var i=this.getGeometry();i&&t.setGeometry(i.clone());var r=this.getStyle();return r&&t.setStyle(r),t},e.prototype.getGeometry=function(){return this.get(this.geometryName_)},e.prototype.getId=function(){return this.id_},e.prototype.getGeometryName=function(){return this.geometryName_},e.prototype.getStyle=function(){return this.style_},e.prototype.getStyleFunction=function(){return this.styleFunction_},e.prototype.handleGeometryChange_=function(){this.changed()},e.prototype.handleGeometryChanged_=function(){this.geometryChangeKey_&&(S(this.geometryChangeKey_),this.geometryChangeKey_=null);var t=this.getGeometry();t&&(this.geometryChangeKey_=v(t,M.CHANGE,this.handleGeometryChange_,this)),this.changed()},e.prototype.setGeometry=function(t){this.set(this.geometryName_,t)},e.prototype.setStyle=function(t){this.style_=t,this.styleFunction_=t?Ia(t):void 0,this.changed()},e.prototype.setId=function(t){this.id_=t,this.changed()},e.prototype.setGeometryName=function(t){E(this,A(this.geometryName_),this.handleGeometryChanged_,this),this.geometryName_=t,v(this,A(this.geometryName_),this.handleGeometryChanged_,this),this.handleGeometryChanged_()},e}(G),La=function(t){function e(e,i){t.call(this),i&&!Array.isArray(e[0])?this.setFlatCoordinates(i,e):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendPoint=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){if(r<ke(this.getExtent(),t,e))return r;for(var n=this.flatCoordinates,o=this.stride,s=0,a=n.length;s<a;s+=o){var h=he(t,e,n[s],n[s+1]);if(h<r){r=h;for(var l=0;l<o;++l)i[l]=n[s+l];i.length=o}}return r},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getPoint=function(t){var e=this.flatCoordinates?this.flatCoordinates.length/this.stride:0;return t<0||e<=t?null:new Gr(this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride),this.layout)},e.prototype.getPoints=function(){for(var t=this.flatCoordinates,e=this.layout,i=this.stride,r=[],n=0,o=t.length;n<o;n+=i){var s=new Gr(t.slice(n,n+i),e);r.push(s)}return r},e.prototype.getType=function(){return _i.MULTI_POINT},e.prototype.intersectsExtent=function(t){for(var e=this.flatCoordinates,i=this.stride,r=0,n=e.length;r<n;r+=i){if(je(t,e[r],e[r+1]))return!0}return!1},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r);function Pa(t,e,i,r,n,o){var s=NaN,a=NaN,h=(i-e)/r;if(1===h)s=t[e],a=t[e+1];else if(2==h)s=(1-n)*t[e]+n*t[e+r],a=(1-n)*t[e+1]+n*t[e+r+1];else if(0!==h){for(var l=t[e],u=t[e+1],p=0,c=[0],d=e+r;d<i;d+=r){var f=t[d],g=t[d+1];p+=Math.sqrt((f-l)*(f-l)+(g-u)*(g-u)),c.push(p),l=f,u=g}var _=n*p,y=function(t,e,i){for(var r,n,o=i||Nt,s=0,a=t.length,h=!1;s<a;)(n=+o(t[r=s+(a-s>>1)],e))<0?s=r+1:(a=r,h=!n);return h?s:~s}(c,_);if(y<0){var v=(_-c[-y-2])/(c[-y-1]-c[-y-2]),m=e+(-y-2)*r;s=pe(t[m],t[m+r],v),a=pe(t[m+1],t[m+r+1],v)}else s=t[e+y*r],a=t[e+y*r+1]}return o?(o[0]=s,o[1]=a,o):[s,a]}function Ma(t,e,i,r,n,o){if(i==e)return null;var s;if(n<t[e+r-1])return o?((s=t.slice(e,e+r))[r-1]=n,s):null;if(t[i-1]<n)return o?((s=t.slice(i-r,i))[r-1]=n,s):null;if(n==t[e+r-1])return t.slice(e,e+r);for(var a=e/r,h=i/r;a<h;){var l=a+h>>1;n<t[(l+1)*r-1]?h=l:a=l+1}var u=t[a*r-1];if(n==u)return t.slice((a-1)*r,(a-1)*r+r);var p=(n-u)/(t[(a+1)*r-1]-u);s=[];for(var c=0;c<r-1;++c)s.push(pe(t[(a-1)*r+c],t[a*r+c],p));return s.push(n),s}var Fa=function(t){function e(e,i){t.call(this),this.flatMidpoint_=null,this.flatMidpointRevision_=-1,this.maxDelta_=-1,this.maxDeltaRevision_=-1,void 0===i||Array.isArray(e[0])?this.setCoordinates(e,i):this.setFlatCoordinates(i,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendCoordinate=function(t){this.flatCoordinates?kt(this.flatCoordinates,t):this.flatCoordinates=t.slice(),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Er(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Tr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,t,e,i,r))},e.prototype.forEachSegment=function(t){return jr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.getCoordinateAtM=function(t,e){if(this.layout!=yi.XYM&&this.layout!=yi.XYZM)return null;var i=void 0!==e&&e;return Ma(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i)},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getCoordinateAt=function(t,e){return Pa(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,e)},e.prototype.getLength=function(){return Ls(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getFlatMidpoint=function(){return this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_),this.flatMidpointRevision_=this.getRevision()),this.flatMidpoint_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[];return i.length=Pr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i,0),new e(i,yi.XY)},e.prototype.getType=function(){return _i.LINE_STRING},e.prototype.intersectsExtent=function(t){return Xr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r),ba=function(t){function e(e,i,r){if(t.call(this),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(e[0]))this.setCoordinates(e,i);else if(void 0!==i&&r)this.setFlatCoordinates(i,e),this.ends_=r;else{for(var n=this.getLayout(),o=e,s=[],a=[],h=0,l=o.length;h<l;++h){var u=o[h];0===h&&(n=u.getLayout()),kt(s,u.getFlatCoordinates()),a.push(s.length)}this.setFlatCoordinates(n,s),this.ends_=a}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendLineString=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates().slice()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout,this.ends_.slice())},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Sr(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Cr(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,r))},e.prototype.getCoordinateAtM=function(t,e,i){if(this.layout!=yi.XYM&&this.layout!=yi.XYZM||0===this.flatCoordinates.length)return null;var r=void 0!==e&&e,n=void 0!==i&&i;return function(t,e,i,r,n,o,s){if(s)return Ma(t,e,i[i.length-1],r,n,o);var a;if(n<t[r-1])return o?((a=t.slice(0,r))[r-1]=n,a):null;if(t[t.length-1]<n)return o?((a=t.slice(t.length-r))[r-1]=n,a):null;for(var h=0,l=i.length;h<l;++h){var u=i[h];if(e!=u){if(n<t[e+r-1])return null;if(n<=t[u-1])return Ma(t,e,u,r,n,!1);e=u}}return null}(this.flatCoordinates,0,this.ends_,this.stride,t,r,n)},e.prototype.getCoordinates=function(){return Or(this.flatCoordinates,0,this.ends_,this.stride)},e.prototype.getEnds=function(){return this.ends_},e.prototype.getLineString=function(t){return t<0||this.ends_.length<=t?null:new Fa(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)},e.prototype.getLineStrings=function(){for(var t=this.flatCoordinates,e=this.ends_,i=this.layout,r=[],n=0,o=0,s=e.length;o<s;++o){var a=e[o],h=new Fa(t.slice(n,a),i);r.push(h),n=a}return r},e.prototype.getFlatMidpoints=function(){for(var t=[],e=this.flatCoordinates,i=0,r=this.ends_,n=this.stride,o=0,s=r.length;o<s;++o){var a=r[o];kt(t,Pa(e,i,a,n,.5)),i=a}return t},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=Mr(this.flatCoordinates,0,this.ends_,this.stride,t,i,0,r),new e(i,yi.XY,r)},e.prototype.getType=function(){return _i.MULTI_LINE_STRING},e.prototype.intersectsExtent=function(t){return function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){if(Xr(t,e,i[o],r,n))return!0;e=i[o]}return!1}(this.flatCoordinates,0,this.ends_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);var i=wr(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()},e}(_r);var Na=function(t){function e(e,i,r){if(t.call(this),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!r&&!Array.isArray(e[0])){for(var n=this.getLayout(),o=e,s=[],a=[],h=0,l=o.length;h<l;++h){var u=o[h];0===h&&(n=u.getLayout());for(var p=s.length,c=u.getEnds(),d=0,f=c.length;d<f;++d)c[d]+=p;kt(s,u.getFlatCoordinates()),a.push(c)}i=n,e=s,r=a}void 0!==i&&r?(this.setFlatCoordinates(i,e),this.endss_=r):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendPolygon=function(t){var e;if(this.flatCoordinates){var i=this.flatCoordinates.length;kt(this.flatCoordinates,t.getFlatCoordinates());for(var r=0,n=(e=t.getEnds().slice()).length;r<n;++r)e[r]+=i}else this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();this.endss_.push(e),this.changed()},e.prototype.clone=function(){for(var t=this.endss_.length,i=new Array(t),r=0;r<t;++r)i[r]=this.endss_[r].slice();return new e(this.flatCoordinates.slice(),this.layout,i)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];n=Sr(t,e,a,r,n),e=a[a.length-1]}return n}(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),function(t,e,i,r,n,o,s,a,h,l,u){for(var p=u||[NaN,NaN],c=0,d=i.length;c<d;++c){var f=i[c];l=Cr(t,e,f,r,n,o,s,a,h,l,p),e=f[f.length-1]}return l}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.containsXY=function(t,e){return function(t,e,i,r,n,o){if(0===i.length)return!1;for(var s=0,a=i.length;s<a;++s){var h=i[s];if(Yr(t,e,h,r,n,o))return!0;e=h[h.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)},e.prototype.getArea=function(){return function(t,e,i,r){for(var n=0,o=0,s=i.length;o<s;++o){var a=i[o];n+=vr(t,e,a,r),e=a[a.length-1]}return n}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)},e.prototype.getCoordinates=function(t){var e;return void 0!==t?Zr(e=this.getOrientedFlatCoordinates().slice(),0,this.endss_,this.stride,t):e=this.flatCoordinates,Lr(e,0,this.endss_,this.stride)},e.prototype.getEndss=function(){return this.endss_},e.prototype.getFlatInteriorPoints=function(){if(this.flatInteriorPointsRevision_!=this.getRevision()){var t=function(t,e,i,r){for(var n=[],o=[1/0,1/0,-1/0,-1/0],s=0,a=i.length;s<a;++s){var h=i[s];o=ze(t,e,h[0],r),n.push((o[0]+o[2])/2,(o[1]+o[3])/2),e=h[h.length-1]}return n}(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=function(t,e,i,r,n){for(var o=[],s=0,a=i.length;s<a;++s){var h=i[s];o=Ur(t,e,h,r,n,2*s,o),e=h[h.length-1]}return o}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_},e.prototype.getInteriorPoints=function(){return new La(this.getFlatInteriorPoints().slice(),yi.XYM)},e.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var t=this.flatCoordinates;!function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o)if(!Kr(t,e,i[o],r,n))return!1;return!0}(t,0,this.endss_,this.stride)?(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=Zr(this.orientedFlatCoordinates_,0,this.endss_,this.stride)):this.orientedFlatCoordinates_=t,this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=function(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h],p=[];s=Nr(t,e,u,r,n,o,s,p),a.push(p),e=u[u.length-1]}return s}(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),i,0,r),new e(i,yi.XY,r)},e.prototype.getPolygon=function(t){if(t<0||this.endss_.length<=t)return null;var e;if(0===t)e=0;else{var i=this.endss_[t-1];e=i[i.length-1]}var r=this.endss_[t].slice(),n=r[r.length-1];if(0!==e)for(var o=0,s=r.length;o<s;++o)r[o]-=e;return new qr(this.flatCoordinates.slice(e,n),this.layout,r)},e.prototype.getPolygons=function(){for(var t=this.layout,e=this.flatCoordinates,i=this.endss_,r=[],n=0,o=0,s=i.length;o<s;++o){var a=i[o].slice(),h=a[a.length-1];if(0!==n)for(var l=0,u=a.length;l<u;++l)a[l]-=n;var p=new qr(e.slice(n,h),t,a);r.push(p),n=h}return r},e.prototype.getType=function(){return _i.MULTI_POLYGON},e.prototype.intersectsExtent=function(t){return function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];if(Br(t,e,a,r,n))return!0;e=a[a.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);var i=function(t,e,i,r,n){for(var o=n||[],s=0,a=0,h=i.length;a<h;++a){var l=wr(t,e,i[a],r,o[s]);o[s++]=l,e=l[l.length-1]}return o.length=s,o}(this.flatCoordinates,0,t,this.stride,this.endss_);if(0===i.length)this.flatCoordinates.length=0;else{var r=i[i.length-1];this.flatCoordinates.length=0===r.length?0:r[r.length-1]}this.changed()},e}(_r),Aa=function(t){function e(e,i,r){if(t.call(this),void 0!==r&&void 0===i)this.setFlatCoordinates(r,e);else{var n=i||0;this.setCenterAndRadius(e,n,r)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),void 0,this.layout)},e.prototype.closestPointXY=function(t,e,i,r){var n=this.flatCoordinates,o=t-n[0],s=e-n[1],a=o*o+s*s;if(a<r){if(0===a)for(var h=0;h<this.stride;++h)i[h]=n[h];else{var l=this.getRadius()/Math.sqrt(a);i[0]=n[0]+l*o,i[1]=n[1]+l*s;for(var u=2;u<this.stride;++u)i[u]=n[u]}return i.length=this.stride,a}return r},e.prototype.containsXY=function(t,e){var i=this.flatCoordinates,r=t-i[0],n=e-i[1];return r*r+n*n<=this.getRadiusSquared_()},e.prototype.getCenter=function(){return this.flatCoordinates.slice(0,this.stride)},e.prototype.computeExtent=function(t){var e=this.flatCoordinates,i=e[this.stride]-e[0];return Ve(e[0]-i,e[1]-i,e[0]+i,e[1]+i,t)},e.prototype.getRadius=function(){return Math.sqrt(this.getRadiusSquared_())},e.prototype.getRadiusSquared_=function(){var t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e},e.prototype.getType=function(){return _i.CIRCLE},e.prototype.intersectsExtent=function(t){if(ci(t,this.getExtent())){var e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||(t[1]<=e[1]&&t[3]>=e[1]||ti(t,this.intersectsCoordinate,this))}return!1},e.prototype.setCenter=function(t){var e=this.stride,i=this.flatCoordinates[e]-this.flatCoordinates[0],r=t.slice();r[e]=r[0]+i;for(var n=1;n<e;++n)r[e+n]=t[n];this.setFlatCoordinates(this.layout,r),this.changed()},e.prototype.setCenterAndRadius=function(t,e,i){this.setLayout(i,t,0),this.flatCoordinates||(this.flatCoordinates=[]);var r=this.flatCoordinates,n=Rr(r,0,t,this.stride);r[n++]=r[0]+e;for(var o=1,s=this.stride;o<s;++o)r[n++]=r[o];r.length=n,this.changed()},e.prototype.getCoordinates=function(){return null},e.prototype.setCoordinates=function(t,e){},e.prototype.setRadius=function(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()},e}(_r);Aa.prototype.transform;var Ga=Aa;function Da(t){for(var e=[],i=0,r=t.length;i<r;++i)e.push(t[i].clone());return e}var ka=function(t){function e(e){t.call(this),this.geometries_=e||null,this.listenGeometriesChange_()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.unlistenGeometriesChange_=function(){if(this.geometries_)for(var t=0,e=this.geometries_.length;t<e;++t)E(this.geometries_[t],M.CHANGE,this.changed,this)},e.prototype.listenGeometriesChange_=function(){if(this.geometries_)for(var t=0,e=this.geometries_.length;t<e;++t)v(this.geometries_[t],M.CHANGE,this.changed,this)},e.prototype.clone=function(){var t=new e(null);return t.setGeometries(this.geometries_),t},e.prototype.closestPointXY=function(t,e,i,r){if(r<ke(this.getExtent(),t,e))return r;for(var n=this.geometries_,o=0,s=n.length;o<s;++o)r=n[o].closestPointXY(t,e,i,r);return r},e.prototype.containsXY=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)if(i[r].containsXY(t,e))return!0;return!1},e.prototype.computeExtent=function(t){We(t);for(var e=this.geometries_,i=0,r=e.length;i<r;++i)He(t,e[i].getExtent());return t},e.prototype.getGeometries=function(){return Da(this.geometries_)},e.prototype.getGeometriesArray=function(){return this.geometries_},e.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(p(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;var i=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(i))return this.simplifiedGeometryCache[i];for(var r=[],n=this.geometries_,o=!1,s=0,a=n.length;s<a;++s){var h=n[s],l=h.getSimplifiedGeometry(t);r.push(l),l!==h&&(o=!0)}if(o){var u=new e(null);return u.setGeometriesArray(r),this.simplifiedGeometryCache[i]=u,u}return this.simplifiedGeometryMaxMinSquaredTolerance=t,this},e.prototype.getType=function(){return _i.GEOMETRY_COLLECTION},e.prototype.intersectsExtent=function(t){for(var e=this.geometries_,i=0,r=e.length;i<r;++i)if(e[i].intersectsExtent(t))return!0;return!1},e.prototype.isEmpty=function(){return 0===this.geometries_.length},e.prototype.rotate=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)i[r].rotate(t,e);this.changed()},e.prototype.scale=function(t,e,i){var r=i;r||(r=ni(this.getExtent()));for(var n=this.geometries_,o=0,s=n.length;o<s;++o)n[o].scale(t,e,r);this.changed()},e.prototype.setGeometries=function(t){this.setGeometriesArray(Da(t))},e.prototype.setGeometriesArray=function(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()},e.prototype.applyTransform=function(t){for(var e=this.geometries_,i=0,r=e.length;i<r;++i)e[i].applyTransform(t);this.changed()},e.prototype.translate=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)i[r].translate(t,e);this.changed()},e.prototype.disposeInternal=function(){this.unlistenGeometriesChange_(),t.prototype.disposeInternal.call(this)},e}(fr),Ya={ARRAY_BUFFER:"arraybuffer",JSON:"json",TEXT:"text",XML:"xml"};function Ua(t,e){return function(t,e,i,r){return function(n,o,s){var a=new XMLHttpRequest;a.open("GET","function"==typeof t?t(n,o,s):t,!0),e.getType()==Ya.ARRAY_BUFFER&&(a.responseType="arraybuffer"),a.onload=function(t){if(!a.status||a.status>=200&&a.status<300){var n,o=e.getType();o==Ya.JSON||o==Ya.TEXT?n=a.responseText:o==Ya.XML?(n=a.responseXML)||(n=(new DOMParser).parseFromString(a.responseText,"application/xml")):o==Ya.ARRAY_BUFFER&&(n=a.response),n?i.call(this,e.readFeatures(n,{featureProjection:s}),e.readProjection(n),e.getLastExtent()):r.call(this)}else r.call(this)}.bind(this),a.onerror=function(){r.call(this)}.bind(this),a.send()}}(t,e,function(t,e){"function"==typeof this.addFeatures&&this.addFeatures(t)},w)}var ja=function(){this.dataProjection=null,this.defaultFeatureProjection=null};ja.prototype.getReadOptions=function(t,e){var i;return e&&(i={dataProjection:e.dataProjection?e.dataProjection:this.readProjection(t),featureProjection:e.featureProjection}),this.adaptOptions(i)},ja.prototype.adaptOptions=function(t){return u({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection},t)},ja.prototype.getLastExtent=function(){return null},ja.prototype.getType=function(){return r()},ja.prototype.readFeature=function(t,e){return r()},ja.prototype.readFeatures=function(t,e){return r()},ja.prototype.readGeometry=function(t,e){return r()},ja.prototype.readProjection=function(t){return r()},ja.prototype.writeFeature=function(t,e){return r()},ja.prototype.writeFeatures=function(t,e){return r()},ja.prototype.writeGeometry=function(t,e){return r()};var Xa=ja;function Ba(t,e,i){var r,n=i?Zi(i.featureProjection):null,o=i?Zi(i.dataProjection):null;if(r=n&&o&&!$i(n,o)?Array.isArray(t)?rr(t,o,n):(e?t.clone():t).transform(e?n:o,e?o:n):t,e&&i&&void 0!==i.decimals&&!Array.isArray(r)){var s=Math.pow(10,i.decimals);r===t&&(r=t.clone()),r.applyTransform(function(t){for(var e=0,i=t.length;e<i;++e)t[e]=Math.round(t[e]*s)/s;return t})}return r}function Va(t){if("string"==typeof t){var e=JSON.parse(t);return e||null}return null!==t?t:null}var Wa=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.JSON},e.prototype.readFeature=function(t,e){return this.readFeatureFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readFeatures=function(t,e){return this.readFeaturesFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readFeatureFromObject=function(t,e){return r()},e.prototype.readFeaturesFromObject=function(t,e){return r()},e.prototype.readGeometry=function(t,e){return this.readGeometryFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readGeometryFromObject=function(t,e){return r()},e.prototype.readProjection=function(t){return this.readProjectionFromObject(Va(t))},e.prototype.readProjectionFromObject=function(t){return r()},e.prototype.writeFeature=function(t,e){return JSON.stringify(this.writeFeatureObject(t,e))},e.prototype.writeFeatureObject=function(t,e){return r()},e.prototype.writeFeatures=function(t,e){return JSON.stringify(this.writeFeaturesObject(t,e))},e.prototype.writeFeaturesObject=function(t,e){return r()},e.prototype.writeGeometry=function(t,e){return JSON.stringify(this.writeGeometryObject(t,e))},e.prototype.writeGeometryObject=function(t,e){return r()},e}(Xa);function Ka(t,e){if(!t)return null;var i;switch(t.type){case _i.POINT:i=function(t){return new Gr(t.coordinates)}(t);break;case _i.LINE_STRING:i=function(t){return new Fa(t.coordinates)}(t);break;case _i.POLYGON:i=function(t){return new qr(t.coordinates)}(t);break;case _i.MULTI_POINT:i=function(t){return new La(t.coordinates)}(t);break;case _i.MULTI_LINE_STRING:i=function(t){return new ba(t.coordinates)}(t);break;case _i.MULTI_POLYGON:i=function(t){return new Na(t.coordinates)}(t);break;case _i.GEOMETRY_COLLECTION:i=function(t,e){var i=t.geometries.map(function(t){return Ka(t,e)});return new ka(i)}(t);break;default:throw new Error("Unsupported GeoJSON type: "+t.type)}return Ba(i,!1,e)}function za(t,e){var i,r=(t=Ba(t,!0,e)).getType();switch(r){case _i.POINT:i=function(t,e){return{type:"Point",coordinates:t.getCoordinates()}}(t);break;case _i.LINE_STRING:i=function(t,e){return{type:"LineString",coordinates:t.getCoordinates()}}(t);break;case _i.POLYGON:i=function(t,e){var i;e&&(i=e.rightHanded);return{type:"Polygon",coordinates:t.getCoordinates(i)}}(t,e);break;case _i.MULTI_POINT:i=function(t,e){return{type:"MultiPoint",coordinates:t.getCoordinates()}}(t);break;case _i.MULTI_LINE_STRING:i=function(t,e){return{type:"MultiLineString",coordinates:t.getCoordinates()}}(t);break;case _i.MULTI_POLYGON:i=function(t,e){var i;e&&(i=e.rightHanded);return{type:"MultiPolygon",coordinates:t.getCoordinates(i)}}(t,e);break;case _i.GEOMETRY_COLLECTION:i=function(t,e){return{type:"GeometryCollection",geometries:t.getGeometriesArray().map(function(t){var i=u({},e);return delete i.featureProjection,za(t,i)})}}(t,e);break;case _i.CIRCLE:i={type:"GeometryCollection",geometries:[]};break;default:throw new Error("Unsupported geometry type: "+r)}return i}var Za=function(t){function e(e){var i=e||{};t.call(this),this.dataProjection=Zi(i.dataProjection?i.dataProjection:"EPSG:4326"),i.featureProjection&&(this.defaultFeatureProjection=Zi(i.featureProjection)),this.geometryName_=i.geometryName,this.extractGeometryName_=i.extractGeometryName}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeatureFromObject=function(t,e){var i=null,r=Ka((i="Feature"===t.type?t:{type:"Feature",geometry:t,properties:null}).geometry,e),n=new Oa;return this.geometryName_?n.setGeometryName(this.geometryName_):this.extractGeometryName_&&"geometry_name"in i!==void 0&&n.setGeometryName(i.geometry_name),n.setGeometry(r),"id"in i&&n.setId(i.id),i.properties&&n.setProperties(i.properties),n},e.prototype.readFeaturesFromObject=function(t,e){var i=null;if("FeatureCollection"===t.type){i=[];for(var r=t.features,n=0,o=r.length;n<o;++n)i.push(this.readFeatureFromObject(r[n],e))}else i=[this.readFeatureFromObject(t,e)];return i},e.prototype.readGeometryFromObject=function(t,e){return Ka(t,e)},e.prototype.readProjectionFromObject=function(t){var e,i=t.crs;return i?"name"==i.type?e=Zi(i.properties.name):te(!1,36):e=this.dataProjection,e},e.prototype.writeFeatureObject=function(t,e){e=this.adaptOptions(e);var i={type:"Feature",geometry:null,properties:null},r=t.getId();void 0!==r&&(i.id=r);var n=t.getGeometry();n&&(i.geometry=za(n,e));var o=t.getProperties();return delete o[t.getGeometryName()],d(o)||(i.properties=o),i},e.prototype.writeFeaturesObject=function(t,e){e=this.adaptOptions(e);for(var i=[],r=0,n=t.length;r<n;++r)i.push(this.writeFeatureObject(t[r],e));return{type:"FeatureCollection",features:i}},e.prototype.writeGeometryObject=function(t,e){return za(t,this.adaptOptions(e))},e}(Wa),Ha=document.implementation.createDocument("","",null),qa="http://www.w3.org/2001/XMLSchema-instance";function Ja(t,e){return Ha.createElementNS(t,e)}function Qa(t,e){return function t(e,i,r){if(e.nodeType==Node.CDATA_SECTION_NODE||e.nodeType==Node.TEXT_NODE)i?r.push(String(e.nodeValue).replace(/(\r\n|\r|\n)/g,"")):r.push(e.nodeValue);else{var n;for(n=e.firstChild;n;n=n.nextSibling)t(n,i,r)}return r}(t,e,[]).join("")}function $a(t){return"documentElement"in t}function th(t){return(new DOMParser).parseFromString(t,"application/xml")}function eh(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&kt(r[r.length-1],n)}}function ih(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&r[r.length-1].push(n)}}function rh(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&(r[r.length-1]=n)}}function nh(t,e,i){return function(r,n){var o=t.call(void 0!==i?i:this,r,n);if(void 0!==o){var s=n[n.length-1],a=void 0!==e?e:r.localName;(a in s?s[a]:s[a]=[]).push(o)}}}function oh(t,e,i){return function(r,n){var o=t.call(void 0!==i?i:this,r,n);void 0!==o&&(n[n.length-1][void 0!==e?e:r.localName]=o)}}function sh(t,e){return function(i,r,n){t.call(void 0!==e?e:this,i,r,n),n[n.length-1].node.appendChild(i)}}function ah(t,e){var i,r;return function(e,n,o){if(void 0===i){i={};var s={};s[e.localName]=t,i[e.namespaceURI]=s,r=hh(e.localName)}fh(i,r,n,o)}}function hh(t,e){var i=t;return function(t,r,n){var o=r[r.length-1].node,s=i;return void 0===s&&(s=n),Ja(void 0!==e?e:o.namespaceURI,s)}}var lh=hh();function uh(t,e){for(var i=e.length,r=new Array(i),n=0;n<i;++n)r[n]=t[e[n]];return r}function ph(t,e,i){var r,n,o=void 0!==i?i:{};for(r=0,n=t.length;r<n;++r)o[t[r]]=e;return o}function ch(t,e,i,r){var n;for(n=e.firstElementChild;n;n=n.nextElementSibling){var o=t[n.namespaceURI];if(void 0!==o){var s=o[n.localName];void 0!==s&&s.call(r,n,i)}}}function dh(t,e,i,r,n){return r.push(t),ch(e,i,r,n),r.pop()}function fh(t,e,i,r,n,o){for(var s,a,h=(void 0!==n?n:i).length,l=0;l<h;++l)void 0!==(s=i[l])&&void 0!==(a=e.call(void 0!==o?o:this,s,r,void 0!==n?n[l]:void 0))&&t[a.namespaceURI][a.localName].call(o,a,s,r)}function gh(t,e,i,r,n,o,s){return n.push(t),fh(e,i,r,n,o,s),n.pop()}var _h=function(t){function e(){t.call(this),this.xmlSerializer_=new XMLSerializer}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.XML},e.prototype.readFeature=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readFeatureFromDocument(i,e)}return $a(t)?this.readFeatureFromDocument(t,e):this.readFeatureFromNode(t,e)}return null},e.prototype.readFeatureFromDocument=function(t,e){var i=this.readFeaturesFromDocument(t,e);return i.length>0?i[0]:null},e.prototype.readFeatureFromNode=function(t,e){return null},e.prototype.readFeatures=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readFeaturesFromDocument(i,e)}return $a(t)?this.readFeaturesFromDocument(t,e):this.readFeaturesFromNode(t,e)}return[]},e.prototype.readFeaturesFromDocument=function(t,e){for(var i=[],r=t.firstChild;r;r=r.nextSibling)r.nodeType==Node.ELEMENT_NODE&&kt(i,this.readFeaturesFromNode(r,e));return i},e.prototype.readFeaturesFromNode=function(t,e){return r()},e.prototype.readGeometry=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readGeometryFromDocument(i,e)}return $a(t)?this.readGeometryFromDocument(t,e):this.readGeometryFromNode(t,e)}return null},e.prototype.readGeometryFromDocument=function(t,e){return null},e.prototype.readGeometryFromNode=function(t,e){return null},e.prototype.readProjection=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readProjectionFromDocument(e)}return $a(t)?this.readProjectionFromDocument(t):this.readProjectionFromNode(t)}return null},e.prototype.readProjectionFromDocument=function(t){return this.dataProjection},e.prototype.readProjectionFromNode=function(t){return this.dataProjection},e.prototype.writeFeature=function(t,e){var i=this.writeFeatureNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeFeatureNode=function(t,e){return null},e.prototype.writeFeatures=function(t,e){var i=this.writeFeaturesNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeFeaturesNode=function(t,e){return null},e.prototype.writeGeometry=function(t,e){var i=this.writeGeometryNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeGeometryNode=function(t,e){return null},e}(Xa),yh="http://www.opengis.net/gml",vh=/^[\s\xa0]*$/,mh=function(t){function e(e){t.call(this);var i=e||{};this.featureType=i.featureType,this.featureNS=i.featureNS,this.srsName=i.srsName,this.schemaLocation="",this.FEATURE_COLLECTION_PARSERS={},this.FEATURE_COLLECTION_PARSERS[this.namespace]={featureMember:ih(this.readFeaturesInternal),featureMembers:rh(this.readFeaturesInternal)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeaturesInternal=function(t,e){var i=t.localName,r=null;if("FeatureCollection"==i)r=dh([],this.FEATURE_COLLECTION_PARSERS,t,e,this);else if("featureMembers"==i||"featureMember"==i){var n=e[0],o=n.featureType,s=n.featureNS;if(!o&&t.childNodes){o=[],s={};for(var a=0,h=t.childNodes.length;a<h;++a){var l=t.childNodes[a];if(1===l.nodeType){var u=l.nodeName.split(":").pop();if(-1===o.indexOf(u)){var p="",c=0,d=l.namespaceURI;for(var f in s){if(s[f]===d){p=f;break}++c}p||(s[p="p"+c]=d),o.push(p+":"+u)}}}"featureMember"!=i&&(n.featureType=o,n.featureNS=s)}if("string"==typeof s){var g=s;(s={}).p0=g}var _={},y=Array.isArray(o)?o:[o];for(var v in s){for(var m={},E=0,S=y.length;E<S;++E){(-1===y[E].indexOf(":")?"p0":y[E].split(":")[0])===v&&(m[y[E].split(":").pop()]="featureMembers"==i?ih(this.readFeatureElement,this):rh(this.readFeatureElement,this))}_[s[v]]=m}r=dh("featureMember"==i?void 0:[],_,t,e)}return null===r&&(r=[]),r},e.prototype.readGeometryElement=function(t,e){var i=e[0];i.srsName=t.firstElementChild.getAttribute("srsName"),i.srsDimension=t.firstElementChild.getAttribute("srsDimension");var r=dh(null,this.GEOMETRY_PARSERS,t,e,this);return r?Ba(r,!1,i):void 0},e.prototype.readFeatureElementInternal=function(t,e,i){for(var r,n={},o=t.firstElementChild;o;o=o.nextElementSibling){var s=void 0,a=o.localName;0===o.childNodes.length||1===o.childNodes.length&&(3===o.firstChild.nodeType||4===o.firstChild.nodeType)?(s=Qa(o,!1),vh.test(s)&&(s=void 0)):(i&&(s=this.readGeometryElement(o,e)),s?"boundedBy"!==a&&(r=a):s=this.readFeatureElementInternal(o,e,!1)),n[a]?(n[a]instanceof Array||(n[a]=[n[a]]),n[a].push(s)):n[a]=s;var h=o.attributes.length;if(h>0){n[a]={_content_:n[a]};for(var l=0;l<h;l++){var u=o.attributes[l].name;n[a][u]=o.attributes[l].value}}}if(i){var p=new Oa(n);r&&p.setGeometryName(r);var c=t.getAttribute("fid")||function(t,e,i){return t.getAttributeNS(e,i)||""}(t,this.namespace,"id");return c&&p.setId(c),p}return n},e.prototype.readFeatureElement=function(t,e){return this.readFeatureElementInternal(t,e,!0)},e.prototype.readPoint=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);if(i)return new Gr(i,yi.XYZ)},e.prototype.readMultiPoint=function(t,e){var i=dh([],this.MULTIPOINT_PARSERS_,t,e,this);return i?new La(i):void 0},e.prototype.readMultiLineString=function(t,e){var i=dh([],this.MULTILINESTRING_PARSERS_,t,e,this);if(i)return new ba(i)},e.prototype.readMultiPolygon=function(t,e){var i=dh([],this.MULTIPOLYGON_PARSERS_,t,e,this);if(i)return new Na(i)},e.prototype.pointMemberParser_=function(t,e){ch(this.POINTMEMBER_PARSERS_,t,e,this)},e.prototype.lineStringMemberParser_=function(t,e){ch(this.LINESTRINGMEMBER_PARSERS_,t,e,this)},e.prototype.polygonMemberParser_=function(t,e){ch(this.POLYGONMEMBER_PARSERS_,t,e,this)},e.prototype.readLineString=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);return i?new Fa(i,yi.XYZ):void 0},e.prototype.readFlatLinearRing_=function(t,e){var i=dh(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this);return i||void 0},e.prototype.readLinearRing=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);if(i)return new Ar(i,yi.XYZ)},e.prototype.readPolygon=function(t,e){var i=dh([null],this.FLAT_LINEAR_RINGS_PARSERS,t,e,this);if(i&&i[0]){var r,n,o=i[0],s=[o.length];for(r=1,n=i.length;r<n;++r)kt(o,i[r]),s.push(o.length);return new qr(o,yi.XYZ,s)}},e.prototype.readFlatCoordinatesFromNode_=function(t,e){return dh(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this)},e.prototype.readGeometryFromNode=function(t,e){var i=this.readGeometryElement(t,[this.getReadOptions(t,e||{})]);return i||null},e.prototype.readFeaturesFromNode=function(t,e){var i={featureType:this.featureType,featureNS:this.featureNS};return e&&u(i,this.getReadOptions(t,e)),this.readFeaturesInternal(t,[i])||[]},e.prototype.readProjectionFromNode=function(t){return Zi(this.srsName?this.srsName:t.firstElementChild.getAttribute("srsName"))},e}(_h);mh.prototype.namespace=yh,mh.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.MULTIPOINT_PARSERS_={"http://www.opengis.net/gml":{pointMember:ih(mh.prototype.pointMemberParser_),pointMembers:ih(mh.prototype.pointMemberParser_)}},mh.prototype.MULTILINESTRING_PARSERS_={"http://www.opengis.net/gml":{lineStringMember:ih(mh.prototype.lineStringMemberParser_),lineStringMembers:ih(mh.prototype.lineStringMemberParser_)}},mh.prototype.MULTIPOLYGON_PARSERS_={"http://www.opengis.net/gml":{polygonMember:ih(mh.prototype.polygonMemberParser_),polygonMembers:ih(mh.prototype.polygonMemberParser_)}},mh.prototype.POINTMEMBER_PARSERS_={"http://www.opengis.net/gml":{Point:ih(mh.prototype.readFlatCoordinatesFromNode_)}},mh.prototype.LINESTRINGMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ih(mh.prototype.readLineString)}},mh.prototype.POLYGONMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ih(mh.prototype.readPolygon)}},mh.prototype.RING_PARSERS={"http://www.opengis.net/gml":{LinearRing:rh(mh.prototype.readFlatLinearRing_)}};var Eh=mh;function Sh(t){return Th(Qa(t,!1))}function Th(t){var e=/^\s*(true|1)|(false|0)\s*$/.exec(t);return e?void 0!==e[1]||!1:void 0}function Ch(t){var e=Qa(t,!1),i=Date.parse(e);return isNaN(i)?void 0:i/1e3}function Rh(t){return xh(Qa(t,!1))}function xh(t){var e=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);return e?parseFloat(e[1]):void 0}function wh(t){return Ih(Qa(t,!1))}function Ih(t){var e=/^\s*(\d+)\s*$/.exec(t);return e?parseInt(e[1],10):void 0}function Oh(t){return Qa(t,!1).trim()}function Lh(t,e){bh(t,e?"1":"0")}function Ph(t,e){t.appendChild(Ha.createCDATASection(e))}function Mh(t,e){var i=e.toPrecision();t.appendChild(Ha.createTextNode(i))}function Fh(t,e){var i=e.toString();t.appendChild(Ha.createTextNode(i))}function bh(t,e){t.appendChild(Ha.createTextNode(e))}var Nh=yh+" http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",Ah={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"},Gh=function(t){function e(e){var i=e||{};t.call(this,i),this.surface_=void 0!==i.surface&&i.surface,this.curve_=void 0!==i.curve&&i.curve,this.multiCurve_=void 0===i.multiCurve||i.multiCurve,this.multiSurface_=void 0===i.multiSurface||i.multiSurface,this.schemaLocation=i.schemaLocation?i.schemaLocation:Nh,this.hasZ=void 0!==i.hasZ&&i.hasZ}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readMultiCurve_=function(t,e){var i=dh([],this.MULTICURVE_PARSERS_,t,e,this);return i?new ba(i):void 0},e.prototype.readMultiSurface_=function(t,e){var i=dh([],this.MULTISURFACE_PARSERS_,t,e,this);if(i)return new Na(i)},e.prototype.curveMemberParser_=function(t,e){ch(this.CURVEMEMBER_PARSERS_,t,e,this)},e.prototype.surfaceMemberParser_=function(t,e){ch(this.SURFACEMEMBER_PARSERS_,t,e,this)},e.prototype.readPatch_=function(t,e){return dh([null],this.PATCHES_PARSERS_,t,e,this)},e.prototype.readSegment_=function(t,e){return dh([null],this.SEGMENTS_PARSERS_,t,e,this)},e.prototype.readPolygonPatch_=function(t,e){return dh([null],this.FLAT_LINEAR_RINGS_PARSERS,t,e,this)},e.prototype.readLineStringSegment_=function(t,e){return dh([null],this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this)},e.prototype.interiorParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&e[e.length-1].push(i)},e.prototype.exteriorParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&(e[e.length-1][0]=i)},e.prototype.readSurface_=function(t,e){var i=dh([null],this.SURFACE_PARSERS_,t,e,this);if(i&&i[0]){var r,n,o=i[0],s=[o.length];for(r=1,n=i.length;r<n;++r)kt(o,i[r]),s.push(o.length);return new qr(o,yi.XYZ,s)}},e.prototype.readCurve_=function(t,e){var i=dh([null],this.CURVE_PARSERS_,t,e,this);return i?new Fa(i,yi.XYZ):void 0},e.prototype.readEnvelope_=function(t,e){var i=dh([null],this.ENVELOPE_PARSERS_,t,e,this);return Ve(i[1][0],i[1][1],i[2][0],i[2][1])},e.prototype.readFlatPos_=function(t,e){for(var i,r=Qa(t,!1),n=/^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/,o=[];i=n.exec(r);)o.push(parseFloat(i[1])),r=r.substr(i[0].length);if(""===r){var s,a,h=e[0].srsName,l="enu";if(h)l=Zi(h).getAxisOrientation();if("neu"===l)for(s=0,a=o.length;s<a;s+=3){var u=o[s],p=o[s+1];o[s]=p,o[s+1]=u}var c=o.length;if(2==c&&o.push(0),0!==c)return o}},e.prototype.readFlatPosList_=function(t,e){var i=Qa(t,!1).replace(/^\s*|\s*$/g,""),r=e[0],n=r.srsName,o=r.srsDimension,s="enu";n&&(s=Zi(n).getAxisOrientation());var a,h,l,u=i.split(/\s+/),p=2;t.getAttribute("srsDimension")?p=Ih(t.getAttribute("srsDimension")):t.getAttribute("dimension")?p=Ih(t.getAttribute("dimension")):t.parentNode.getAttribute("srsDimension")?p=Ih(t.parentNode.getAttribute("srsDimension")):o&&(p=Ih(o));for(var c=[],d=0,f=u.length;d<f;d+=p)a=parseFloat(u[d]),h=parseFloat(u[d+1]),l=3===p?parseFloat(u[d+2]):0,"en"===s.substr(0,2)?c.push(a,h,l):c.push(h,a,l);return c},e.prototype.writePos_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=n?"3":"2";t.setAttribute("srsDimension",o);var s=r.srsName,a="enu";s&&(a=Zi(s).getAxisOrientation());var h,l=e.getCoordinates();(h="en"===a.substr(0,2)?l[0]+" "+l[1]:l[1]+" "+l[0],n)&&(h+=" "+(l[2]||0));bh(t,h)},e.prototype.getCoords_=function(t,e,i){var r="enu";e&&(r=Zi(e).getAxisOrientation());var n="en"===r.substr(0,2)?t[0]+" "+t[1]:t[1]+" "+t[0];i&&(n+=" "+(t[2]||0));return n},e.prototype.writePosList_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=n?"3":"2";t.setAttribute("srsDimension",o);for(var s,a=r.srsName,h=e.getCoordinates(),l=h.length,u=new Array(l),p=0;p<l;++p)s=h[p],u[p]=this.getCoords_(s,a,n);bh(t,u.join(" "))},e.prototype.writePoint_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=Ja(t.namespaceURI,"pos");t.appendChild(n),this.writePos_(n,e,i)},e.prototype.writeEnvelope=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=[e[0]+" "+e[1],e[2]+" "+e[3]];gh({node:t},this.ENVELOPE_SERIALIZERS_,lh,n,i,["lowerCorner","upperCorner"],this)},e.prototype.writeLinearRing_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=Ja(t.namespaceURI,"posList");t.appendChild(n),this.writePosList_(n,e,i)},e.prototype.RING_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1],n=r.node,o=r.exteriorWritten;return void 0===o&&(r.exteriorWritten=!0),Ja(n.namespaceURI,void 0!==o?"interior":"exterior")},e.prototype.writeSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;if("PolygonPatch"!==t.nodeName&&o&&t.setAttribute("srsName",o),"Polygon"===t.nodeName||"PolygonPatch"===t.nodeName){var s=e.getLinearRings();gh({node:t,hasZ:n,srsName:o},this.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,s,i,void 0,this)}else if("Surface"===t.nodeName){var a=Ja(t.namespaceURI,"patches");t.appendChild(a),this.writeSurfacePatches_(a,e,i)}},e.prototype.writeCurveOrLineString_=function(t,e,i){var r=i[i.length-1].srsName;if("LineStringSegment"!==t.nodeName&&r&&t.setAttribute("srsName",r),"LineString"===t.nodeName||"LineStringSegment"===t.nodeName){var n=Ja(t.namespaceURI,"posList");t.appendChild(n),this.writePosList_(n,e,i)}else if("Curve"===t.nodeName){var o=Ja(t.namespaceURI,"segments");t.appendChild(o),this.writeCurveSegments_(o,e,i)}},e.prototype.writeMultiSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.surface;o&&t.setAttribute("srsName",o);var a=e.getPolygons();gh({node:t,hasZ:n,srsName:o,surface:s},this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeMultiPoint_=function(t,e,i){var r=i[i.length-1],n=r.srsName,o=r.hasZ;n&&t.setAttribute("srsName",n);var s=e.getPoints();gh({node:t,hasZ:o,srsName:n},this.POINTMEMBER_SERIALIZERS_,hh("pointMember"),s,i,void 0,this)},e.prototype.writeMultiCurveOrLineString_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.curve;o&&t.setAttribute("srsName",o);var a=e.getLineStrings();gh({node:t,hasZ:n,srsName:o,curve:s},this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeRing_=function(t,e,i){var r=Ja(t.namespaceURI,"LinearRing");t.appendChild(r),this.writeLinearRing_(r,e,i)},e.prototype.writeSurfaceOrPolygonMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i))},e.prototype.writePointMember_=function(t,e,i){var r=Ja(t.namespaceURI,"Point");t.appendChild(r),this.writePoint_(r,e,i)},e.prototype.writeLineStringOrCurveMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeCurveOrLineString_(r,e,i))},e.prototype.writeSurfacePatches_=function(t,e,i){var r=Ja(t.namespaceURI,"PolygonPatch");t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i)},e.prototype.writeCurveSegments_=function(t,e,i){var r=Ja(t.namespaceURI,"LineStringSegment");t.appendChild(r),this.writeCurveOrLineString_(r,e,i)},e.prototype.writeGeometryElement=function(t,e,i){var r,n=i[i.length-1],o=u({},n);o.node=t,r=Array.isArray(e)?n.dataProjection?rr(e,n.featureProjection,n.dataProjection):e:Ba(e,!0,n),gh(o,this.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[r],i,void 0,this)},e.prototype.writeFeatureElement=function(t,e,i){var r=e.getId();r&&t.setAttribute("fid",r);var n=i[i.length-1],o=n.featureNS,s=e.getGeometryName();n.serializers||(n.serializers={},n.serializers[o]={});var a=e.getProperties(),h=[],l=[];for(var p in a){var c=a[p];null!==c&&(h.push(p),l.push(c),p==s||"function"==typeof c.getSimplifiedGeometry?p in n.serializers[o]||(n.serializers[o][p]=sh(this.writeGeometryElement,this)):p in n.serializers[o]||(n.serializers[o][p]=sh(bh)))}var d=u({},n);d.node=t,gh(d,n.serializers,hh(void 0,o),l,i,h)},e.prototype.writeFeatureMembers_=function(t,e,i){var r=i[i.length-1],n=r.featureType,o=r.featureNS,s={};s[o]={},s[o][n]=sh(this.writeFeatureElement,this);var a=u({},r);a.node=t,gh(a,s,hh(n,o),e,i)},e.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1].node;return Ja(this.namespace,Ah[r.nodeName])},e.prototype.GEOMETRY_NODE_FACTORY_=function(t,e,i){var r,n=e[e.length-1],o=n.multiSurface,s=n.surface,a=n.curve,h=n.multiCurve;return Array.isArray(t)?r="Envelope":"MultiPolygon"===(r=t.getType())&&!0===o?r="MultiSurface":"Polygon"===r&&!0===s?r="Surface":"LineString"===r&&!0===a?r="Curve":"MultiLineString"===r&&!0===h&&(r="MultiCurve"),Ja(this.namespace,r)},e.prototype.writeGeometryNode=function(t,e){e=this.adaptOptions(e);var i=Ja(this.namespace,"geom"),r={node:i,hasZ:this.hasZ,srsName:this.srsName,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_};return e&&u(r,e),this.writeGeometryElement(i,t,[r]),i},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja(this.namespace,"featureMembers");i.setAttributeNS(qa,"xsi:schemaLocation",this.schemaLocation);var r={srsName:this.srsName,hasZ:this.hasZ,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_,featureNS:this.featureNS,featureType:this.featureType};return e&&u(r,e),this.writeFeatureMembers_(i,t,[r]),i},e}(Eh);Gh.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{pos:rh(Gh.prototype.readFlatPos_),posList:rh(Gh.prototype.readFlatPosList_)}},Gh.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{interior:Gh.prototype.interiorParser_,exterior:Gh.prototype.exteriorParser_}},Gh.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{Point:rh(Eh.prototype.readPoint),MultiPoint:rh(Eh.prototype.readMultiPoint),LineString:rh(Eh.prototype.readLineString),MultiLineString:rh(Eh.prototype.readMultiLineString),LinearRing:rh(Eh.prototype.readLinearRing),Polygon:rh(Eh.prototype.readPolygon),MultiPolygon:rh(Eh.prototype.readMultiPolygon),Surface:rh(Gh.prototype.readSurface_),MultiSurface:rh(Gh.prototype.readMultiSurface_),Curve:rh(Gh.prototype.readCurve_),MultiCurve:rh(Gh.prototype.readMultiCurve_),Envelope:rh(Gh.prototype.readEnvelope_)}},Gh.prototype.MULTICURVE_PARSERS_={"http://www.opengis.net/gml":{curveMember:ih(Gh.prototype.curveMemberParser_),curveMembers:ih(Gh.prototype.curveMemberParser_)}},Gh.prototype.MULTISURFACE_PARSERS_={"http://www.opengis.net/gml":{surfaceMember:ih(Gh.prototype.surfaceMemberParser_),surfaceMembers:ih(Gh.prototype.surfaceMemberParser_)}},Gh.prototype.CURVEMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ih(Eh.prototype.readLineString),Curve:ih(Gh.prototype.readCurve_)}},Gh.prototype.SURFACEMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ih(Eh.prototype.readPolygon),Surface:ih(Gh.prototype.readSurface_)}},Gh.prototype.SURFACE_PARSERS_={"http://www.opengis.net/gml":{patches:rh(Gh.prototype.readPatch_)}},Gh.prototype.CURVE_PARSERS_={"http://www.opengis.net/gml":{segments:rh(Gh.prototype.readSegment_)}},Gh.prototype.ENVELOPE_PARSERS_={"http://www.opengis.net/gml":{lowerCorner:ih(Gh.prototype.readFlatPosList_),upperCorner:ih(Gh.prototype.readFlatPosList_)}},Gh.prototype.PATCHES_PARSERS_={"http://www.opengis.net/gml":{PolygonPatch:rh(Gh.prototype.readPolygonPatch_)}},Gh.prototype.SEGMENTS_PARSERS_={"http://www.opengis.net/gml":{LineStringSegment:rh(Gh.prototype.readLineStringSegment_)}},Gh.prototype.writeFeatures,Gh.prototype.RING_SERIALIZERS_={"http://www.opengis.net/gml":{exterior:sh(Gh.prototype.writeRing_),interior:sh(Gh.prototype.writeRing_)}},Gh.prototype.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:sh(bh),upperCorner:sh(bh)}},Gh.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:sh(Gh.prototype.writeSurfaceOrPolygonMember_),polygonMember:sh(Gh.prototype.writeSurfaceOrPolygonMember_)}},Gh.prototype.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:sh(Gh.prototype.writePointMember_)}},Gh.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:sh(Gh.prototype.writeLineStringOrCurveMember_),curveMember:sh(Gh.prototype.writeLineStringOrCurveMember_)}},Gh.prototype.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:sh(Gh.prototype.writeCurveOrLineString_),MultiCurve:sh(Gh.prototype.writeMultiCurveOrLineString_),Point:sh(Gh.prototype.writePoint_),MultiPoint:sh(Gh.prototype.writeMultiPoint_),LineString:sh(Gh.prototype.writeCurveOrLineString_),MultiLineString:sh(Gh.prototype.writeMultiCurveOrLineString_),LinearRing:sh(Gh.prototype.writeLinearRing_),Polygon:sh(Gh.prototype.writeSurfaceOrPolygon_),MultiPolygon:sh(Gh.prototype.writeMultiSurfaceOrPolygon_),Surface:sh(Gh.prototype.writeSurfaceOrPolygon_),MultiSurface:sh(Gh.prototype.writeMultiSurfaceOrPolygon_),Envelope:sh(Gh.prototype.writeEnvelope)}};var Dh=Gh,kh=Dh;kh.prototype.writeFeatures,kh.prototype.writeFeaturesNode;var Yh=kh,Uh=[null,"http://www.topografix.com/GPX/1/0","http://www.topografix.com/GPX/1/1"],jh={rte:gl,trk:_l,wpt:yl},Xh=ph(Uh,{rte:ih(gl),trk:ih(_l),wpt:ih(yl)}),Bh=ph(Uh,{text:oh(Oh,"linkText"),type:oh(Oh,"linkType")}),Vh=ph(Uh,{rte:sh(function(t,e,i){var r=i[0],n=e.getProperties(),o={node:t};o.properties=n;var s=e.getGeometry();if(s.getType()==_i.LINE_STRING){var a=Ba(s,!0,r);o.geometryLayout=a.getLayout(),n.rtept=a.getCoordinates()}var h=i[i.length-1].node,l=tl[h.namespaceURI],u=uh(n,l);gh(o,el,lh,u,i,l)}),trk:sh(function(t,e,i){var r=i[0],n=e.getProperties(),o={node:t};o.properties=n;var s=e.getGeometry();if(s.getType()==_i.MULTI_LINE_STRING){var a=Ba(s,!0,r);n.trkseg=a.getLineStrings()}var h=i[i.length-1].node,l=rl[h.namespaceURI],u=uh(n,l);gh(o,nl,lh,u,i,l)}),wpt:sh(function(t,e,i){var r=i[0],n=i[i.length-1];n.properties=e.getProperties();var o=e.getGeometry();if(o.getType()==_i.POINT){var s=Ba(o,!0,r);n.geometryLayout=s.getLayout(),ml(t,s.getCoordinates(),i)}})}),Wh=function(t){function e(e){t.call(this);var i=e||{};this.dataProjection=Zi("EPSG:4326"),this.readExtensions_=i.readExtensions}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleReadExtensions_=function(t){t||(t=[]);for(var e=0,i=t.length;e<i;++e){var r=t[e];if(this.readExtensions_){var n=r.get("extensionsNode_")||null;this.readExtensions_(r,n)}r.set("extensionsNode_",void 0)}},e.prototype.readFeatureFromNode=function(t,e){if(!At(Uh,t.namespaceURI))return null;var i=jh[t.localName];if(!i)return null;var r=i(t,[this.getReadOptions(t,e)]);return r?(this.handleReadExtensions_([r]),r):null},e.prototype.readFeaturesFromNode=function(t,e){if(!At(Uh,t.namespaceURI))return[];if("gpx"==t.localName){var i=dh([],Xh,t,[this.getReadOptions(t,e)]);return i?(this.handleReadExtensions_(i),i):[]}return[]},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja("http://www.topografix.com/GPX/1/1","gpx");return i.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xsi",qa),i.setAttributeNS(qa,"xsi:schemaLocation","http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"),i.setAttribute("version","1.1"),i.setAttribute("creator","OpenLayers"),gh({node:i},Vh,ul,t,[e]),i},e}(_h),Kh=ph(Uh,{name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,number:oh(wh),extensions:fl,type:oh(Oh),rtept:function(t,e){var i=dh({},zh,t,e);if(i){var r=e[e.length-1],n=r.flatCoordinates,o=r.layoutOptions;pl(n,o,t,i)}}}),zh=ph(Uh,{ele:oh(Rh),time:oh(Ch)}),Zh=ph(Uh,{name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,number:oh(wh),type:oh(Oh),extensions:fl,trkseg:function(t,e){var i=e[e.length-1];ch(Hh,t,e);var r=i.flatCoordinates;i.ends.push(r.length)}}),Hh=ph(Uh,{trkpt:function(t,e){var i=dh({},qh,t,e);if(i){var r=e[e.length-1],n=r.flatCoordinates,o=r.layoutOptions;pl(n,o,t,i)}}}),qh=ph(Uh,{ele:oh(Rh),time:oh(Ch)}),Jh=ph(Uh,{ele:oh(Rh),time:oh(Ch),magvar:oh(Rh),geoidheight:oh(Rh),name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,sym:oh(Oh),type:oh(Oh),fix:oh(Oh),sat:oh(wh),hdop:oh(Rh),vdop:oh(Rh),pdop:oh(Rh),ageofdgpsdata:oh(Rh),dgpsid:oh(wh),extensions:fl}),Qh=["text","type"],$h=ph(Uh,{text:sh(bh),type:sh(bh)}),tl=ph(Uh,["name","cmt","desc","src","link","number","type","rtept"]),el=ph(Uh,{name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),number:sh(Fh),type:sh(bh),rtept:ah(sh(ml))}),il=ph(Uh,["ele","time"]),rl=ph(Uh,["name","cmt","desc","src","link","number","type","trkseg"]),nl=ph(Uh,{name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),number:sh(Fh),type:sh(bh),trkseg:ah(sh(function(t,e,i){var r={node:t};r.geometryLayout=e.getLayout(),r.properties={},gh(r,sl,ol,e.getCoordinates(),i)}))}),ol=hh("trkpt"),sl=ph(Uh,{trkpt:sh(ml)}),al=ph(Uh,["ele","time","magvar","geoidheight","name","cmt","desc","src","link","sym","type","fix","sat","hdop","vdop","pdop","ageofdgpsdata","dgpsid"]),hl=ph(Uh,{ele:sh(Mh),time:sh(function(t,e){var i=new Date(1e3*e),r=i.getUTCFullYear()+"-"+Ee(i.getUTCMonth()+1,2)+"-"+Ee(i.getUTCDate(),2)+"T"+Ee(i.getUTCHours(),2)+":"+Ee(i.getUTCMinutes(),2)+":"+Ee(i.getUTCSeconds(),2)+"Z";t.appendChild(Ha.createTextNode(r))}),magvar:sh(Mh),geoidheight:sh(Mh),name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),sym:sh(bh),type:sh(bh),fix:sh(bh),sat:sh(Fh),hdop:sh(Mh),vdop:sh(Mh),pdop:sh(Mh),ageofdgpsdata:sh(Mh),dgpsid:sh(Fh)}),ll={Point:"wpt",LineString:"rte",MultiLineString:"trk"};function ul(t,e,i){var r=t.getGeometry();if(r){var n=ll[r.getType()];if(n)return Ja(e[e.length-1].node.namespaceURI,n)}}function pl(t,e,i,r){return t.push(parseFloat(i.getAttribute("lon")),parseFloat(i.getAttribute("lat"))),"ele"in r?(t.push(r.ele),delete r.ele,e.hasZ=!0):t.push(0),"time"in r?(t.push(r.time),delete r.time,e.hasM=!0):t.push(0),t}function cl(t,e,i){var r=yi.XY,n=2;if(t.hasZ&&t.hasM?(r=yi.XYZM,n=4):t.hasZ?(r=yi.XYZ,n=3):t.hasM&&(r=yi.XYM,n=3),4!==n){for(var o=0,s=e.length/4;o<s;o++)e[o*n]=e[4*o],e[o*n+1]=e[4*o+1],t.hasZ&&(e[o*n+2]=e[4*o+2]),t.hasM&&(e[o*n+2]=e[4*o+3]);if(e.length=e.length/4*n,i)for(var a=0,h=i.length;a<h;a++)i[a]=i[a]/4*n}return r}function dl(t,e){var i=e[e.length-1],r=t.getAttribute("href");null!==r&&(i.link=r),ch(Bh,t,e)}function fl(t,e){e[e.length-1].extensionsNode_=t}function gl(t,e){var i=e[0],r=dh({flatCoordinates:[],layoutOptions:{}},Kh,t,e);if(r){var n=r.flatCoordinates;delete r.flatCoordinates;var o=r.layoutOptions;delete r.layoutOptions;var s=cl(o,n),a=new Fa(n,s);Ba(a,!1,i);var h=new Oa(a);return h.setProperties(r),h}}function _l(t,e){var i=e[0],r=dh({flatCoordinates:[],ends:[],layoutOptions:{}},Zh,t,e);if(r){var n=r.flatCoordinates;delete r.flatCoordinates;var o=r.ends;delete r.ends;var s=r.layoutOptions;delete r.layoutOptions;var a=cl(s,n,o),h=new ba(n,a,o);Ba(h,!1,i);var l=new Oa(h);return l.setProperties(r),l}}function yl(t,e){var i=e[0],r=dh({},Jh,t,e);if(r){var n={},o=pl([],n,t,r),s=cl(n,o),a=new Gr(o,s);Ba(a,!1,i);var h=new Oa(a);return h.setProperties(r),h}}function vl(t,e,i){t.setAttribute("href",e);var r=i[i.length-1].properties,n=[r.linkText,r.linkType];gh({node:t},$h,lh,n,i,Qh)}function ml(t,e,i){var r=i[i.length-1],n=r.node.namespaceURI,o=r.properties;switch(t.setAttributeNS(null,"lat",String(e[1])),t.setAttributeNS(null,"lon",String(e[0])),r.geometryLayout){case yi.XYZM:0!==e[3]&&(o.time=e[3]);case yi.XYZ:0!==e[2]&&(o.ele=e[2]);break;case yi.XYM:0!==e[2]&&(o.time=e[2])}var s="rtept"==t.nodeName?il[n]:al[n],a=uh(o,s);gh({node:t,properties:o},hl,lh,a,i,s)}var El=Wh,Sl=function(t){var e=t||{};this.color_=void 0!==e.color?e.color:null,this.checksum_=void 0};Sl.prototype.clone=function(){var t=this.getColor();return new Sl({color:Array.isArray(t)?t.slice():t||void 0})},Sl.prototype.getColor=function(){return this.color_},Sl.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},Sl.prototype.getChecksum=function(){if(void 0===this.checksum_){var t=this.color_;t?Array.isArray(t)||"string"==typeof t?this.checksum_="f"+$o(t):this.checksum_=o(this.color_):this.checksum_="f-"}return this.checksum_};var Tl=Sl,Cl={FRACTION:"fraction",PIXELS:"pixels"},Rl=function(t){function e(e,i,r,n,o,s){t.call(this),this.hitDetectionImage_=null,this.image_=e||new Image,null!==n&&(this.image_.crossOrigin=n),this.canvas_=s?document.createElement("canvas"):null,this.color_=s,this.imageListenerKeys_=null,this.imageState_=o,this.size_=r,this.src_=i,this.tainted_}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isTainted_=function(){if(void 0===this.tainted_&&this.imageState_===Oo.LOADED){this.tainted_=!1;var t=on(1,1);try{t.drawImage(this.image_,0,0),t.getImageData(0,0,1,1)}catch(t){this.tainted_=!0}}return!0===this.tainted_},e.prototype.dispatchChangeEvent_=function(){this.dispatchEvent(M.CHANGE)},e.prototype.handleImageError_=function(){this.imageState_=Oo.ERROR,this.unlistenImage_(),this.dispatchChangeEvent_()},e.prototype.handleImageLoad_=function(){this.imageState_=Oo.LOADED,this.size_&&(this.image_.width=this.size_[0],this.image_.height=this.size_[1]),this.size_=[this.image_.width,this.image_.height],this.unlistenImage_(),this.replaceColor_(),this.dispatchChangeEvent_()},e.prototype.getImage=function(t){return this.canvas_?this.canvas_:this.image_},e.prototype.getImageState=function(){return this.imageState_},e.prototype.getHitDetectionImage=function(t){if(!this.hitDetectionImage_)if(this.isTainted_()){var e=this.size_[0],i=this.size_[1],r=on(e,i);r.fillRect(0,0,e,i),this.hitDetectionImage_=r.canvas}else this.hitDetectionImage_=this.image_;return this.hitDetectionImage_},e.prototype.getSize=function(){return this.size_},e.prototype.getSrc=function(){return this.src_},e.prototype.load=function(){if(this.imageState_==Oo.IDLE){this.imageState_=Oo.LOADING,this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)];try{this.image_.src=this.src_}catch(t){this.handleImageError_()}}},e.prototype.replaceColor_=function(){if(this.color_&&!this.isTainted_()){this.canvas_.width=this.image_.width,this.canvas_.height=this.image_.height;var t=this.canvas_.getContext("2d");t.drawImage(this.image_,0,0);for(var e=t.getImageData(0,0,this.image_.width,this.image_.height),i=e.data,r=this.color_[0]/255,n=this.color_[1]/255,o=this.color_[2]/255,s=0,a=i.length;s<a;s+=4)i[s]*=r,i[s+1]*=n,i[s+2]*=o;t.putImageData(e,0,0)}},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(P);var xl={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"},wl=function(t){this.opacity_=t.opacity,this.rotateWithView_=t.rotateWithView,this.rotation_=t.rotation,this.scale_=t.scale};wl.prototype.clone=function(){return new wl({opacity:this.getOpacity(),scale:this.getScale(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})},wl.prototype.getOpacity=function(){return this.opacity_},wl.prototype.getRotateWithView=function(){return this.rotateWithView_},wl.prototype.getRotation=function(){return this.rotation_},wl.prototype.getScale=function(){return this.scale_},wl.prototype.getSnapToPixel=function(){return!1},wl.prototype.getAnchor=function(){return r()},wl.prototype.getImage=function(t){return r()},wl.prototype.getHitDetectionImage=function(t){return r()},wl.prototype.getImageState=function(){return r()},wl.prototype.getImageSize=function(){return r()},wl.prototype.getHitDetectionImageSize=function(){return r()},wl.prototype.getOrigin=function(){return r()},wl.prototype.getSize=function(){return r()},wl.prototype.setOpacity=function(t){this.opacity_=t},wl.prototype.setRotateWithView=function(t){this.rotateWithView_=t},wl.prototype.setRotation=function(t){this.rotation_=t},wl.prototype.setScale=function(t){this.scale_=t},wl.prototype.setSnapToPixel=function(t){},wl.prototype.listenImageChange=function(t,e){return r()},wl.prototype.load=function(){r()},wl.prototype.unlistenImageChange=function(t,e){r()};var Il=wl,Ol=function(t){function e(e){var i=e||{},r=void 0!==i.opacity?i.opacity:1,n=void 0!==i.rotation?i.rotation:0,s=void 0!==i.scale?i.scale:1,a=void 0!==i.rotateWithView&&i.rotateWithView;t.call(this,{opacity:r,rotation:n,scale:s,rotateWithView:a}),this.anchor_=void 0!==i.anchor?i.anchor:[.5,.5],this.normalizedAnchor_=null,this.anchorOrigin_=void 0!==i.anchorOrigin?i.anchorOrigin:xl.TOP_LEFT,this.anchorXUnits_=void 0!==i.anchorXUnits?i.anchorXUnits:Cl.FRACTION,this.anchorYUnits_=void 0!==i.anchorYUnits?i.anchorYUnits:Cl.FRACTION,this.crossOrigin_=void 0!==i.crossOrigin?i.crossOrigin:null;var h=void 0!==i.img?i.img:null,l=void 0!==i.imgSize?i.imgSize:null,u=i.src;te(!(void 0!==u&&h),4),te(!h||h&&l,5),void 0!==u&&0!==u.length||!h||(u=h.src||o(h)),te(void 0!==u&&u.length>0,6);var p=void 0!==i.src?Oo.IDLE:Oo.LOADED;this.color_=void 0!==i.color?es(i.color):null,this.iconImage_=function(t,e,i,r,n,o){var s=us.get(e,r,o);return s||(s=new Rl(t,e,i,r,n,o),us.set(e,r,o,s)),s}(h,u,l,this.crossOrigin_,p,this.color_),this.offset_=void 0!==i.offset?i.offset:[0,0],this.offsetOrigin_=void 0!==i.offsetOrigin?i.offsetOrigin:xl.TOP_LEFT,this.origin_=null,this.size_=void 0!==i.size?i.size:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e({anchor:this.anchor_.slice(),anchorOrigin:this.anchorOrigin_,anchorXUnits:this.anchorXUnits_,anchorYUnits:this.anchorYUnits_,crossOrigin:this.crossOrigin_,color:this.color_&&this.color_.slice?this.color_.slice():this.color_||void 0,src:this.getSrc(),offset:this.offset_.slice(),offsetOrigin:this.offsetOrigin_,size:null!==this.size_?this.size_.slice():void 0,opacity:this.getOpacity(),scale:this.getScale(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})},e.prototype.getAnchor=function(){if(this.normalizedAnchor_)return this.normalizedAnchor_;var t=this.anchor_,e=this.getSize();if(this.anchorXUnits_==Cl.FRACTION||this.anchorYUnits_==Cl.FRACTION){if(!e)return null;t=this.anchor_.slice(),this.anchorXUnits_==Cl.FRACTION&&(t[0]*=e[0]),this.anchorYUnits_==Cl.FRACTION&&(t[1]*=e[1])}if(this.anchorOrigin_!=xl.TOP_LEFT){if(!e)return null;t===this.anchor_&&(t=this.anchor_.slice()),this.anchorOrigin_!=xl.TOP_RIGHT&&this.anchorOrigin_!=xl.BOTTOM_RIGHT||(t[0]=-t[0]+e[0]),this.anchorOrigin_!=xl.BOTTOM_LEFT&&this.anchorOrigin_!=xl.BOTTOM_RIGHT||(t[1]=-t[1]+e[1])}return this.normalizedAnchor_=t,this.normalizedAnchor_},e.prototype.setAnchor=function(t){this.anchor_=t,this.normalizedAnchor_=null},e.prototype.getColor=function(){return this.color_},e.prototype.getImage=function(t){return this.iconImage_.getImage(t)},e.prototype.getImageSize=function(){return this.iconImage_.getSize()},e.prototype.getHitDetectionImageSize=function(){return this.getImageSize()},e.prototype.getImageState=function(){return this.iconImage_.getImageState()},e.prototype.getHitDetectionImage=function(t){return this.iconImage_.getHitDetectionImage(t)},e.prototype.getOrigin=function(){if(this.origin_)return this.origin_;var t=this.offset_;if(this.offsetOrigin_!=xl.TOP_LEFT){var e=this.getSize(),i=this.iconImage_.getSize();if(!e||!i)return null;t=t.slice(),this.offsetOrigin_!=xl.TOP_RIGHT&&this.offsetOrigin_!=xl.BOTTOM_RIGHT||(t[0]=i[0]-e[0]-t[0]),this.offsetOrigin_!=xl.BOTTOM_LEFT&&this.offsetOrigin_!=xl.BOTTOM_RIGHT||(t[1]=i[1]-e[1]-t[1])}return this.origin_=t,this.origin_},e.prototype.getSrc=function(){return this.iconImage_.getSrc()},e.prototype.getSize=function(){return this.size_?this.size_:this.iconImage_.getSize()},e.prototype.listenImageChange=function(t,e){return v(this.iconImage_,M.CHANGE,t,e)},e.prototype.load=function(){this.iconImage_.load()},e.prototype.unlistenImageChange=function(t,e){E(this.iconImage_,M.CHANGE,t,e)},e}(Il),Ll=function(t){var e=t||{};this.color_=void 0!==e.color?e.color:null,this.lineCap_=e.lineCap,this.lineDash_=void 0!==e.lineDash?e.lineDash:null,this.lineDashOffset_=e.lineDashOffset,this.lineJoin_=e.lineJoin,this.miterLimit_=e.miterLimit,this.width_=e.width,this.checksum_=void 0};Ll.prototype.clone=function(){var t=this.getColor();return new Ll({color:Array.isArray(t)?t.slice():t||void 0,lineCap:this.getLineCap(),lineDash:this.getLineDash()?this.getLineDash().slice():void 0,lineDashOffset:this.getLineDashOffset(),lineJoin:this.getLineJoin(),miterLimit:this.getMiterLimit(),width:this.getWidth()})},Ll.prototype.getColor=function(){return this.color_},Ll.prototype.getLineCap=function(){return this.lineCap_},Ll.prototype.getLineDash=function(){return this.lineDash_},Ll.prototype.getLineDashOffset=function(){return this.lineDashOffset_},Ll.prototype.getLineJoin=function(){return this.lineJoin_},Ll.prototype.getMiterLimit=function(){return this.miterLimit_},Ll.prototype.getWidth=function(){return this.width_},Ll.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},Ll.prototype.setLineCap=function(t){this.lineCap_=t,this.checksum_=void 0},Ll.prototype.setLineDash=function(t){this.lineDash_=t,this.checksum_=void 0},Ll.prototype.setLineDashOffset=function(t){this.lineDashOffset_=t,this.checksum_=void 0},Ll.prototype.setLineJoin=function(t){this.lineJoin_=t,this.checksum_=void 0},Ll.prototype.setMiterLimit=function(t){this.miterLimit_=t,this.checksum_=void 0},Ll.prototype.setWidth=function(t){this.width_=t,this.checksum_=void 0},Ll.prototype.getChecksum=function(){return void 0===this.checksum_&&(this.checksum_="s",this.color_?"string"==typeof this.color_?this.checksum_+=this.color_:this.checksum_+=o(this.color_):this.checksum_+="-",this.checksum_+=","+(void 0!==this.lineCap_?this.lineCap_.toString():"-")+","+(this.lineDash_?this.lineDash_.toString():"-")+","+(void 0!==this.lineDashOffset_?this.lineDashOffset_:"-")+","+(void 0!==this.lineJoin_?this.lineJoin_:"-")+","+(void 0!==this.miterLimit_?this.miterLimit_.toString():"-")+","+(void 0!==this.width_?this.width_.toString():"-")),this.checksum_};var Pl=Ll,Ml=function(t){function e(e){var i=void 0!==e.rotateWithView&&e.rotateWithView;t.call(this,{opacity:1,rotateWithView:i,rotation:void 0!==e.rotation?e.rotation:0,scale:1}),this.checksums_=null,this.canvas_=null,this.hitDetectionCanvas_=null,this.fill_=void 0!==e.fill?e.fill:null,this.origin_=[0,0],this.points_=e.points,this.radius_=void 0!==e.radius?e.radius:e.radius1,this.radius2_=e.radius2,this.angle_=void 0!==e.angle?e.angle:0,this.stroke_=void 0!==e.stroke?e.stroke:null,this.anchor_=null,this.size_=null,this.imageSize_=null,this.hitDetectionImageSize_=null,this.atlasManager_=e.atlasManager,this.render_(this.atlasManager_)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e({fill:this.getFill()?this.getFill().clone():void 0,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),stroke:this.getStroke()?this.getStroke().clone():void 0,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},e.prototype.getAnchor=function(){return this.anchor_},e.prototype.getAngle=function(){return this.angle_},e.prototype.getFill=function(){return this.fill_},e.prototype.getHitDetectionImage=function(t){return this.hitDetectionCanvas_},e.prototype.getImage=function(t){return this.canvas_},e.prototype.getImageSize=function(){return this.imageSize_},e.prototype.getHitDetectionImageSize=function(){return this.hitDetectionImageSize_},e.prototype.getImageState=function(){return Oo.LOADED},e.prototype.getOrigin=function(){return this.origin_},e.prototype.getPoints=function(){return this.points_},e.prototype.getRadius=function(){return this.radius_},e.prototype.getRadius2=function(){return this.radius2_},e.prototype.getSize=function(){return this.size_},e.prototype.getStroke=function(){return this.stroke_},e.prototype.listenImageChange=function(t,e){},e.prototype.load=function(){},e.prototype.unlistenImageChange=function(t,e){},e.prototype.render_=function(t){var e,i,r="",n="",o=0,s=null,a=0,h=0;this.stroke_&&(null===(i=this.stroke_.getColor())&&(i=Go),i=ns(i),void 0===(h=this.stroke_.getWidth())&&(h=1),s=this.stroke_.getLineDash(),a=this.stroke_.getLineDashOffset(),Z||(s=null,a=0),void 0===(n=this.stroke_.getLineJoin())&&(n="round"),void 0===(r=this.stroke_.getLineCap())&&(r="round"),void 0===(o=this.stroke_.getMiterLimit())&&(o=10));var l=2*(this.radius_+h)+1,u={strokeStyle:i,strokeWidth:h,size:l,lineCap:r,lineDash:s,lineDashOffset:a,lineJoin:n,miterLimit:o};if(void 0===t){var p=on(l,l);this.canvas_=p.canvas,e=l=this.canvas_.width,this.draw_(u,p,0,0),this.createHitDetectionCanvas_(u)}else{l=Math.round(l);var c,d=!this.fill_;d&&(c=this.drawHitDetectionCanvas_.bind(this,u));var f=this.getChecksum(),g=t.add(f,l,l,this.draw_.bind(this,u),c);this.canvas_=g.image,this.origin_=[g.offsetX,g.offsetY],e=g.image.width,d?(this.hitDetectionCanvas_=g.hitImage,this.hitDetectionImageSize_=[g.hitImage.width,g.hitImage.height]):(this.hitDetectionCanvas_=this.canvas_,this.hitDetectionImageSize_=[e,e])}this.anchor_=[l/2,l/2],this.size_=[l,l],this.imageSize_=[e,e]},e.prototype.draw_=function(t,e,i,r){var n,o,s;e.setTransform(1,0,0,1,0,0),e.translate(i,r),e.beginPath();var a=this.points_;if(a===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{var h=void 0!==this.radius2_?this.radius2_:this.radius_;for(h!==this.radius_&&(a*=2),n=0;n<=a;n++)o=2*n*Math.PI/a-Math.PI/2+this.angle_,s=n%2==0?this.radius_:h,e.lineTo(t.size/2+s*Math.cos(o),t.size/2+s*Math.sin(o))}if(this.fill_){var l=this.fill_.getColor();null===l&&(l=No),e.fillStyle=ns(l),e.fill()}this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineCap=t.lineCap,e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.stroke()),e.closePath()},e.prototype.createHitDetectionCanvas_=function(t){if(this.hitDetectionImageSize_=[t.size,t.size],this.fill_)this.hitDetectionCanvas_=this.canvas_;else{var e=on(t.size,t.size);this.hitDetectionCanvas_=e.canvas,this.drawHitDetectionCanvas_(t,e,0,0)}},e.prototype.drawHitDetectionCanvas_=function(t,e,i,r){e.setTransform(1,0,0,1,0,0),e.translate(i,r),e.beginPath();var n=this.points_;if(n===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{var o,s,a,h=void 0!==this.radius2_?this.radius2_:this.radius_;for(h!==this.radius_&&(n*=2),o=0;o<=n;o++)a=2*o*Math.PI/n-Math.PI/2+this.angle_,s=o%2==0?this.radius_:h,e.lineTo(t.size/2+s*Math.cos(a),t.size/2+s*Math.sin(a))}e.fillStyle=$o(No),e.fill(),this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.stroke()),e.closePath()},e.prototype.getChecksum=function(){var t=this.stroke_?this.stroke_.getChecksum():"-",e=this.fill_?this.fill_.getChecksum():"-";if(!this.checksums_||t!=this.checksums_[1]||e!=this.checksums_[2]||this.radius_!=this.checksums_[3]||this.radius2_!=this.checksums_[4]||this.angle_!=this.checksums_[5]||this.points_!=this.checksums_[6]){var i="r"+t+e+(void 0!==this.radius_?this.radius_.toString():"-")+(void 0!==this.radius2_?this.radius2_.toString():"-")+(void 0!==this.angle_?this.angle_.toString():"-")+(void 0!==this.points_?this.points_.toString():"-");this.checksums_=[i,t,e,this.radius_,this.radius2_,this.angle_,this.points_]}return this.checksums_[0]},e}(Il),Fl=function(t){function e(e){var i=e||{};t.call(this,{points:1/0,fill:i.fill,radius:i.radius,stroke:i.stroke,atlasManager:i.atlasManager})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e({fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,radius:this.getRadius(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},e.prototype.setRadius=function(t){this.radius_=t,this.render_(this.atlasManager_)},e}(Ml),bl=function(t){var e=t||{};this.geometry_=null,this.geometryFunction_=Dl,void 0!==e.geometry&&this.setGeometry(e.geometry),this.fill_=void 0!==e.fill?e.fill:null,this.image_=void 0!==e.image?e.image:null,this.renderer_=void 0!==e.renderer?e.renderer:null,this.stroke_=void 0!==e.stroke?e.stroke:null,this.text_=void 0!==e.text?e.text:null,this.zIndex_=e.zIndex};bl.prototype.clone=function(){var t=this.getGeometry();return t&&"object"==typeof t&&(t=t.clone()),new bl({geometry:t,fill:this.getFill()?this.getFill().clone():void 0,image:this.getImage()?this.getImage().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,text:this.getText()?this.getText().clone():void 0,zIndex:this.getZIndex()})},bl.prototype.getRenderer=function(){return this.renderer_},bl.prototype.setRenderer=function(t){this.renderer_=t},bl.prototype.getGeometry=function(){return this.geometry_},bl.prototype.getGeometryFunction=function(){return this.geometryFunction_},bl.prototype.getFill=function(){return this.fill_},bl.prototype.setFill=function(t){this.fill_=t},bl.prototype.getImage=function(){return this.image_},bl.prototype.setImage=function(t){this.image_=t},bl.prototype.getStroke=function(){return this.stroke_},bl.prototype.setStroke=function(t){this.stroke_=t},bl.prototype.getText=function(){return this.text_},bl.prototype.setText=function(t){this.text_=t},bl.prototype.getZIndex=function(){return this.zIndex_},bl.prototype.setGeometry=function(t){"function"==typeof t?this.geometryFunction_=t:"string"==typeof t?this.geometryFunction_=function(e){return e.get(t)}:t?void 0!==t&&(this.geometryFunction_=function(){return t}):this.geometryFunction_=Dl,this.geometry_=t},bl.prototype.setZIndex=function(t){this.zIndex_=t};var Nl=null;function Al(t,e){if(!Nl){var i=new Tl({color:"rgba(255,255,255,0.4)"}),r=new Pl({color:"#3399CC",width:1.25});Nl=[new bl({image:new Fl({fill:i,stroke:r,radius:5}),fill:i,stroke:r})]}return Nl}function Gl(){var t={},e=[255,255,255,1],i=[0,153,255,1];return t[_i.POLYGON]=[new bl({fill:new Tl({color:[255,255,255,.5]})})],t[_i.MULTI_POLYGON]=t[_i.POLYGON],t[_i.LINE_STRING]=[new bl({stroke:new Pl({color:e,width:5})}),new bl({stroke:new Pl({color:i,width:3})})],t[_i.MULTI_LINE_STRING]=t[_i.LINE_STRING],t[_i.CIRCLE]=t[_i.POLYGON].concat(t[_i.LINE_STRING]),t[_i.POINT]=[new bl({image:new Fl({radius:6,fill:new Tl({color:i}),stroke:new Pl({color:e,width:1.5})}),zIndex:1/0})],t[_i.MULTI_POINT]=t[_i.POINT],t[_i.GEOMETRY_COLLECTION]=t[_i.POLYGON].concat(t[_i.LINE_STRING],t[_i.POINT]),t}function Dl(t){return t.getGeometry()}var kl=bl,Yl=function(t){var e=t||{};this.font_=e.font,this.rotation_=e.rotation,this.rotateWithView_=e.rotateWithView,this.scale_=e.scale,this.text_=e.text,this.textAlign_=e.textAlign,this.textBaseline_=e.textBaseline,this.fill_=void 0!==e.fill?e.fill:new Tl({color:"#333"}),this.maxAngle_=void 0!==e.maxAngle?e.maxAngle:Math.PI/4,this.placement_=void 0!==e.placement?e.placement:Ks,this.overflow_=!!e.overflow,this.stroke_=void 0!==e.stroke?e.stroke:null,this.offsetX_=void 0!==e.offsetX?e.offsetX:0,this.offsetY_=void 0!==e.offsetY?e.offsetY:0,this.backgroundFill_=e.backgroundFill?e.backgroundFill:null,this.backgroundStroke_=e.backgroundStroke?e.backgroundStroke:null,this.padding_=void 0===e.padding?null:e.padding};Yl.prototype.clone=function(){return new Yl({font:this.getFont(),placement:this.getPlacement(),maxAngle:this.getMaxAngle(),overflow:this.getOverflow(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),scale:this.getScale(),text:this.getText(),textAlign:this.getTextAlign(),textBaseline:this.getTextBaseline(),fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,offsetX:this.getOffsetX(),offsetY:this.getOffsetY(),backgroundFill:this.getBackgroundFill()?this.getBackgroundFill().clone():void 0,backgroundStroke:this.getBackgroundStroke()?this.getBackgroundStroke().clone():void 0})},Yl.prototype.getOverflow=function(){return this.overflow_},Yl.prototype.getFont=function(){return this.font_},Yl.prototype.getMaxAngle=function(){return this.maxAngle_},Yl.prototype.getPlacement=function(){return this.placement_},Yl.prototype.getOffsetX=function(){return this.offsetX_},Yl.prototype.getOffsetY=function(){return this.offsetY_},Yl.prototype.getFill=function(){return this.fill_},Yl.prototype.getRotateWithView=function(){return this.rotateWithView_},Yl.prototype.getRotation=function(){return this.rotation_},Yl.prototype.getScale=function(){return this.scale_},Yl.prototype.getStroke=function(){return this.stroke_},Yl.prototype.getText=function(){return this.text_},Yl.prototype.getTextAlign=function(){return this.textAlign_},Yl.prototype.getTextBaseline=function(){return this.textBaseline_},Yl.prototype.getBackgroundFill=function(){return this.backgroundFill_},Yl.prototype.getBackgroundStroke=function(){return this.backgroundStroke_},Yl.prototype.getPadding=function(){return this.padding_},Yl.prototype.setOverflow=function(t){this.overflow_=t},Yl.prototype.setFont=function(t){this.font_=t},Yl.prototype.setMaxAngle=function(t){this.maxAngle_=t},Yl.prototype.setOffsetX=function(t){this.offsetX_=t},Yl.prototype.setOffsetY=function(t){this.offsetY_=t},Yl.prototype.setPlacement=function(t){this.placement_=t},Yl.prototype.setFill=function(t){this.fill_=t},Yl.prototype.setRotation=function(t){this.rotation_=t},Yl.prototype.setScale=function(t){this.scale_=t},Yl.prototype.setStroke=function(t){this.stroke_=t},Yl.prototype.setText=function(t){this.text_=t},Yl.prototype.setTextAlign=function(t){this.textAlign_=t},Yl.prototype.setTextBaseline=function(t){this.textBaseline_=t},Yl.prototype.setBackgroundFill=function(t){this.backgroundFill_=t},Yl.prototype.setBackgroundStroke=function(t){this.backgroundStroke_=t},Yl.prototype.setPadding=function(t){this.padding_=t};var Ul,jl,Xl,Bl,Vl,Wl,Kl,zl=Yl,Zl=["http://www.google.com/kml/ext/2.2"],Hl=[null,"http://earth.google.com/kml/2.0","http://earth.google.com/kml/2.1","http://earth.google.com/kml/2.2","http://www.opengis.net/kml/2.2"],ql={fraction:Cl.FRACTION,pixels:Cl.PIXELS,insetPixels:Cl.PIXELS},Jl=ph(Hl,{ExtendedData:Vu,Region:Wu,MultiGeometry:oh(Au,"geometry"),LineString:oh(Fu,"geometry"),LinearRing:oh(bu,"geometry"),Point:oh(Gu,"geometry"),Polygon:oh(ku,"geometry"),Style:oh(Uu),StyleMap:function(t,e){var i=vu(t,e);if(!i)return;var r=e[e.length-1];Array.isArray(i)?r.Style=i:"string"==typeof i?r.styleUrl=i:te(!1,38)},address:oh(Oh),description:oh(Oh),name:oh(Oh),open:oh(Sh),phoneNumber:oh(Oh),styleUrl:oh(gu),visibility:oh(Sh)},ph(Zl,{MultiTrack:oh(function(t,e){var i=dh([],xu,t,e);if(!i)return;return new ba(i)},"geometry"),Track:oh(Iu,"geometry")})),Ql=ph(Hl,{ExtendedData:Vu,Region:Wu,Link:function(t,e){ch($l,t,e)},address:oh(Oh),description:oh(Oh),name:oh(Oh),open:oh(Sh),phoneNumber:oh(Oh),visibility:oh(Sh)}),$l=ph(Hl,{href:oh(gu)}),tu=ph(Hl,{LatLonAltBox:function(t,e){var i=dh({},Zu,t,e);if(!i)return;var r=e[e.length-1],n=[parseFloat(i.west),parseFloat(i.south),parseFloat(i.east),parseFloat(i.north)];r.extent=n,r.altitudeMode=i.altitudeMode,r.minAltitude=parseFloat(i.minAltitude),r.maxAltitude=parseFloat(i.maxAltitude)},Lod:function(t,e){var i=dh({},Hu,t,e);if(!i)return;var r=e[e.length-1];r.minLodPixels=parseFloat(i.minLodPixels),r.maxLodPixels=parseFloat(i.maxLodPixels),r.minFadeExtent=parseFloat(i.minFadeExtent),r.maxFadeExtent=parseFloat(i.maxFadeExtent)}}),eu=ph(Hl,["Document","Placemark"]),iu=ph(Hl,{Document:sh(function(t,e,i){gh({node:t},tp,ep,e,i,void 0,this)}),Placemark:sh(xp)}),ru=null;var nu,ou=null;var su,au=null;var hu=null;var lu=null;var uu=null;var pu=function(t){function e(e){t.call(this);var i=e||{};uu||(ru=new Tl({color:Ul=[255,255,255,1]}),jl=[20,2],Xl=Cl.PIXELS,Bl=Cl.PIXELS,Vl=[64,64],Wl="https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png",Kl=.5,ou=new Ol({anchor:jl,anchorOrigin:xl.BOTTOM_LEFT,anchorXUnits:Xl,anchorYUnits:Bl,crossOrigin:"anonymous",rotation:0,scale:Kl,size:Vl,src:Wl}),nu="NO_IMAGE",au=new Pl({color:Ul,width:1}),su=new Pl({color:[51,51,51,1],width:2}),hu=new zl({font:"bold 16px Helvetica",fill:ru,stroke:su,scale:.8}),lu=new kl({fill:ru,image:ou,text:hu,stroke:au,zIndex:0}),uu=[lu]),this.dataProjection=Zi("EPSG:4326"),this.defaultStyle_=i.defaultStyle?i.defaultStyle:uu,this.extractStyles_=void 0===i.extractStyles||i.extractStyles,this.writeStyles_=void 0===i.writeStyles||i.writeStyles,this.sharedStyles_={},this.showPointNames_=void 0===i.showPointNames||i.showPointNames}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readDocumentOrFolder_=function(t,e){var i=dh([],ph(Hl,{Document:eh(this.readDocumentOrFolder_,this),Folder:eh(this.readDocumentOrFolder_,this),Placemark:ih(this.readPlacemark_,this),Style:this.readSharedStyle_.bind(this),StyleMap:this.readSharedStyleMap_.bind(this)}),t,e,this);return i||void 0},e.prototype.readPlacemark_=function(t,e){var i=dh({geometry:null},Jl,t,e);if(i){var r=new Oa,n=t.getAttribute("id");null!==n&&r.setId(n);var o=e[0],s=i.geometry;if(s&&Ba(s,!1,o),r.setGeometry(s),delete i.geometry,this.extractStyles_){var a=function(t,e,i,r,n){return function(o,s){var a,h=n,l="";if(h){var u=o.getGeometry();u&&(h=u.getType()===_i.POINT)}if(h&&(l=o.get("name"),h=h&&!!l),t)return h?(a=cu(t[0],l),t.concat(a)):t;if(e){var p=function t(e,i,r){return Array.isArray(e)?e:"string"==typeof e?(!(e in r)&&"#"+e in r&&(e="#"+e),t(r[e],i,r)):i}(e,i,r);return h?(a=cu(p[0],l),p.concat(a)):p}return h?(a=cu(i[0],l),i.concat(a)):i}}(i.Style,i.styleUrl,this.defaultStyle_,this.sharedStyles_,this.showPointNames_);r.setStyle(a)}return delete i.Style,r.setProperties(i),r}},e.prototype.readSharedStyle_=function(t,e){var i=t.getAttribute("id");if(null!==i){var r=Uu(t,e);if(r){var n,o=t.baseURI;if(o&&"about:blank"!=o||(o=window.location.href),o)n=new URL("#"+i,o).href;else n="#"+i;this.sharedStyles_[n]=r}}},e.prototype.readSharedStyleMap_=function(t,e){var i=t.getAttribute("id");if(null!==i){var r=vu(t,e);if(r){var n,o=t.baseURI;if(o&&"about:blank"!=o||(o=window.location.href),o)n=new URL("#"+i,o).href;else n="#"+i;this.sharedStyles_[n]=r}}},e.prototype.readFeatureFromNode=function(t,e){if(!At(Hl,t.namespaceURI))return null;var i=this.readPlacemark_(t,[this.getReadOptions(t,e)]);return i||null},e.prototype.readFeaturesFromNode=function(t,e){if(!At(Hl,t.namespaceURI))return[];var i,r=t.localName;if("Document"==r||"Folder"==r)return(i=this.readDocumentOrFolder_(t,[this.getReadOptions(t,e)]))||[];if("Placemark"==r){var n=this.readPlacemark_(t,[this.getReadOptions(t,e)]);return n?[n]:[]}if("kml"==r){i=[];for(var o=t.firstElementChild;o;o=o.nextElementSibling){var s=this.readFeaturesFromNode(o,e);s&&kt(i,s)}return i}return[]},e.prototype.readName=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readNameFromDocument(e)}return $a(t)?this.readNameFromDocument(t):this.readNameFromNode(t)}},e.prototype.readNameFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE){var i=this.readNameFromNode(e);if(i)return i}},e.prototype.readNameFromNode=function(t){for(var e=t.firstElementChild;e;e=e.nextElementSibling)if(At(Hl,e.namespaceURI)&&"name"==e.localName)return Oh(e);for(var i=t.firstElementChild;i;i=i.nextElementSibling){var r=i.localName;if(At(Hl,i.namespaceURI)&&("Document"==r||"Folder"==r||"Placemark"==r||"kml"==r)){var n=this.readNameFromNode(i);if(n)return n}}},e.prototype.readNetworkLinks=function(t){var e=[];if("string"==typeof t){var i=th(t);kt(e,this.readNetworkLinksFromDocument(i))}else $a(t)?kt(e,this.readNetworkLinksFromDocument(t)):kt(e,this.readNetworkLinksFromNode(t));return e},e.prototype.readNetworkLinksFromDocument=function(t){for(var e=[],i=t.firstChild;i;i=i.nextSibling)i.nodeType==Node.ELEMENT_NODE&&kt(e,this.readNetworkLinksFromNode(i));return e},e.prototype.readNetworkLinksFromNode=function(t){for(var e=[],i=t.firstElementChild;i;i=i.nextElementSibling)if(At(Hl,i.namespaceURI)&&"NetworkLink"==i.localName){var r=dh({},Ql,i,[]);e.push(r)}for(var n=t.firstElementChild;n;n=n.nextElementSibling){var o=n.localName;!At(Hl,n.namespaceURI)||"Document"!=o&&"Folder"!=o&&"kml"!=o||kt(e,this.readNetworkLinksFromNode(n))}return e},e.prototype.readRegion=function(t){var e=[];if("string"==typeof t){var i=th(t);kt(e,this.readRegionFromDocument(i))}else $a(t)?kt(e,this.readRegionFromDocument(t)):kt(e,this.readRegionFromNode(t));return e},e.prototype.readRegionFromDocument=function(t){for(var e=[],i=t.firstChild;i;i=i.nextSibling)i.nodeType==Node.ELEMENT_NODE&&kt(e,this.readRegionFromNode(i));return e},e.prototype.readRegionFromNode=function(t){for(var e=[],i=t.firstElementChild;i;i=i.nextElementSibling)if(At(Hl,i.namespaceURI)&&"Region"==i.localName){var r=dh({},tu,i,[]);e.push(r)}for(var n=t.firstElementChild;n;n=n.nextElementSibling){var o=n.localName;!At(Hl,n.namespaceURI)||"Document"!=o&&"Folder"!=o&&"kml"!=o||kt(e,this.readRegionFromNode(n))}return e},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja(Hl[4],"kml"),r="http://www.w3.org/2000/xmlns/";i.setAttributeNS(r,"xmlns:gx",Zl[0]),i.setAttributeNS(r,"xmlns:xsi",qa),i.setAttributeNS(qa,"xsi:schemaLocation","http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd");var n={node:i},o={};t.length>1?o.Document=t:1==t.length&&(o.Placemark=t[0]);var s=eu[i.namespaceURI],a=uh(o,s);return gh(n,iu,lh,a,[e],s,this),i},e}(_h);function cu(t,e){var i=null,r=[0,0],n="start";if(t.getImage()){var o=t.getImage().getImageSize();if(null===o&&(o=Vl),2==o.length){var s=t.getImage().getScale();r[0]=s*o[0]/2,r[1]=-s*o[1]/2,n="left"}}if(null!==t.getText()){var a=t.getText();(i=a.clone()).setFont(a.getFont()||hu.getFont()),i.setScale(a.getScale()||hu.getScale()),i.setFill(a.getFill()||hu.getFill()),i.setStroke(a.getStroke()||su)}else i=hu.clone();return i.setText(e),i.setOffsetX(r[0]),i.setOffsetY(r[1]),i.setTextAlign(n),new kl({text:i})}function du(t){var e=Qa(t,!1),i=/^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);if(i){var r=i[1];return[parseInt(r.substr(6,2),16),parseInt(r.substr(4,2),16),parseInt(r.substr(2,2),16),parseInt(r.substr(0,2),16)/255]}}function fu(t){for(var e,i=Qa(t,!1),r=[],n=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;e=n.exec(i);){var o=parseFloat(e[1]),s=parseFloat(e[2]),a=e[3]?parseFloat(e[3]):0;r.push(o,s,a),i=i.substr(e[0].length)}if(""===i)return r}function gu(t){var e=Qa(t,!1).trim(),i=t.baseURI;return i&&"about:blank"!=i||(i=window.location.href),i?new URL(e,i).href:e}function _u(t){return Rh(t)}var yu=ph(Hl,{Pair:function(t,e){var i=dh({},Ku,t,e);if(!i)return;var r=i.key;if(r&&"normal"==r){var n=i.styleUrl;n&&(e[e.length-1]=n);var o=i.Style;o&&(e[e.length-1]=o)}}});function vu(t,e){return dh(void 0,yu,t,e)}var mu=ph(Hl,{Icon:oh(function(t,e){var i=dh({},Ou,t,e);return i||null}),heading:oh(Rh),hotSpot:oh(function(t){var e,i=t.getAttribute("xunits"),r=t.getAttribute("yunits");return e="insetPixels"!==i?"insetPixels"!==r?xl.BOTTOM_LEFT:xl.TOP_LEFT:"insetPixels"!==r?xl.BOTTOM_RIGHT:xl.TOP_RIGHT,{x:parseFloat(t.getAttribute("x")),xunits:ql[i],y:parseFloat(t.getAttribute("y")),yunits:ql[r],origin:e}}),scale:oh(_u)});var Eu=ph(Hl,{color:oh(du),scale:oh(_u)});var Su=ph(Hl,{color:oh(du),width:oh(Rh)});var Tu=ph(Hl,{color:oh(du),fill:oh(Sh),outline:oh(Sh)});var Cu=ph(Hl,{coordinates:rh(fu)});function Ru(t,e){return dh(null,Cu,t,e)}var xu=ph(Zl,{Track:ih(Iu)});var wu=ph(Hl,{when:function(t,e){var i=e[e.length-1].whens,r=Qa(t,!1),n=Date.parse(r);i.push(isNaN(n)?0:n)}},ph(Zl,{coord:function(t,e){var i=e[e.length-1].flatCoordinates,r=Qa(t,!1),n=/^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);if(n){var o=parseFloat(n[1]),s=parseFloat(n[2]),a=parseFloat(n[3]);i.push(o,s,a,0)}else i.push(0,0,0,0)}}));function Iu(t,e){var i=dh({flatCoordinates:[],whens:[]},wu,t,e);if(i){for(var r=i.flatCoordinates,n=i.whens,o=0,s=Math.min(r.length,n.length);o<s;++o)r[4*o+3]=n[o];return new Fa(r,yi.XYZM)}}var Ou=ph(Hl,{href:oh(gu)},ph(Zl,{x:oh(Rh),y:oh(Rh),w:oh(Rh),h:oh(Rh)}));var Lu=ph(Hl,{coordinates:rh(fu)});function Pu(t,e){return dh(null,Lu,t,e)}var Mu=ph(Hl,{extrude:oh(Sh),tessellate:oh(Sh),altitudeMode:oh(Oh)});function Fu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new Fa(r,yi.XYZ);return n.setProperties(i),n}}function bu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new qr(r,yi.XYZ,[r.length]);return n.setProperties(i),n}}var Nu=ph(Hl,{LineString:ih(Fu),LinearRing:ih(bu),MultiGeometry:ih(Au),Point:ih(Gu),Polygon:ih(ku)});function Au(t,e){var i,r=dh([],Nu,t,e);if(!r)return null;if(0===r.length)return new ka(r);for(var n,o,s=!0,a=r[0].getType(),h=1,l=r.length;h<l;++h)if(r[h].getType()!=a){s=!1;break}if(s)if(a==_i.POINT){var u=r[0];n=u.getLayout(),o=u.getFlatCoordinates();for(var p=1,c=r.length;p<c;++p)kt(o,r[p].getFlatCoordinates());ju(i=new La(o,n),r)}else a==_i.LINE_STRING?ju(i=new ba(r),r):a==_i.POLYGON?ju(i=new Na(r),r):a==_i.GEOMETRY_COLLECTION?i=new ka(r):te(!1,37);else i=new ka(r);return i}function Gu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new Gr(r,yi.XYZ);return n.setProperties(i),n}}var Du=ph(Hl,{innerBoundaryIs:function(t,e){var i=dh(void 0,qu,t,e);if(i){var r=e[e.length-1];r.push(i)}},outerBoundaryIs:function(t,e){var i=dh(void 0,Ju,t,e);if(i){var r=e[e.length-1];r[0]=i}}});function ku(t,e){var i=dh({},Mu,t,e),r=dh([null],Du,t,e);if(r&&r[0]){for(var n=r[0],o=[n.length],s=1,a=r.length;s<a;++s)kt(n,r[s]),o.push(n.length);var h=new qr(n,yi.XYZ,o);return h.setProperties(i),h}}var Yu=ph(Hl,{IconStyle:function(t,e){var i=dh({},mu,t,e);if(i){var r,n,o,s,a=e[e.length-1],h="Icon"in i?i.Icon:{},l=!("Icon"in i)||Object.keys(h).length>0,u=h.href;u?r=u:l&&(r=Wl);var p,c=xl.BOTTOM_LEFT,d=i.hotSpot;d?(n=[d.x,d.y],o=d.xunits,s=d.yunits,c=d.origin):r===Wl?(n=jl,o=Xl,s=Bl):/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(r)&&(n=[.5,0],o=Cl.FRACTION,s=Cl.FRACTION);var f,g=h.x,_=h.y;void 0!==g&&void 0!==_&&(p=[g,_]);var y,v=h.w,m=h.h;void 0!==v&&void 0!==m&&(f=[v,m]);var E=i.heading;void 0!==E&&(y=le(E));var S=i.scale;if(l){r==Wl&&(f=Vl,void 0===S&&(S=Kl));var T=new Ol({anchor:n,anchorOrigin:c,anchorXUnits:o,anchorYUnits:s,crossOrigin:"anonymous",offset:p,offsetOrigin:xl.BOTTOM_LEFT,rotation:y,scale:S,size:f,src:r});a.imageStyle=T}else a.imageStyle=nu}},LabelStyle:function(t,e){var i=dh({},Eu,t,e);if(i){var r=e[e.length-1],n=new zl({fill:new Tl({color:"color"in i?i.color:Ul}),scale:i.scale});r.textStyle=n}},LineStyle:function(t,e){var i=dh({},Su,t,e);if(i){var r=e[e.length-1],n=new Pl({color:"color"in i?i.color:Ul,width:"width"in i?i.width:1});r.strokeStyle=n}},PolyStyle:function(t,e){var i=dh({},Tu,t,e);if(i){var r=e[e.length-1],n=new Tl({color:"color"in i?i.color:Ul});r.fillStyle=n;var o=i.fill;void 0!==o&&(r.fill=o);var s=i.outline;void 0!==s&&(r.outline=s)}}});function Uu(t,e){var i=dh({},Yu,t,e);if(!i)return null;var r,n="fillStyle"in i?i.fillStyle:ru,o=i.fill;void 0===o||o||(n=null),"imageStyle"in i?i.imageStyle!=nu&&(r=i.imageStyle):r=ou;var s="textStyle"in i?i.textStyle:hu,a="strokeStyle"in i?i.strokeStyle:au,h=i.outline;return void 0===h||h||(a=null),[new kl({fill:n,image:r,stroke:a,text:s,zIndex:void 0})]}function ju(t,e){var i,r,n,o=e.length,s=new Array(e.length),a=new Array(e.length),h=new Array(e.length);i=r=n=!1;for(var l=0;l<o;++l){var u=e[l];s[l]=u.get("extrude"),a[l]=u.get("tessellate"),h[l]=u.get("altitudeMode"),i=i||void 0!==s[l],r=r||void 0!==a[l],n=n||h[l]}i&&t.set("extrude",s),r&&t.set("tessellate",a),n&&t.set("altitudeMode",h)}var Xu=ph(Hl,{displayName:oh(Oh),value:oh(Oh)});var Bu=ph(Hl,{Data:function(t,e){var i=t.getAttribute("name");ch(Xu,t,e);var r=e[e.length-1];null!==i?r[i]=r.value:null!==r.displayName&&(r[r.displayName]=r.value),delete r.value},SchemaData:function(t,e){ch(zu,t,e)}});function Vu(t,e){ch(Bu,t,e)}function Wu(t,e){ch(tu,t,e)}var Ku=ph(Hl,{Style:oh(Uu),key:oh(Oh),styleUrl:oh(gu)});var zu=ph(Hl,{SimpleData:function(t,e){var i=t.getAttribute("name");if(null!==i){var r=Oh(t),n=e[e.length-1];n[i]=r}}});var Zu=ph(Hl,{altitudeMode:oh(Oh),minAltitude:oh(Rh),maxAltitude:oh(Rh),north:oh(Rh),south:oh(Rh),east:oh(Rh),west:oh(Rh)});var Hu=ph(Hl,{minLodPixels:oh(Rh),maxLodPixels:oh(Rh),minFadeExtent:oh(Rh),maxFadeExtent:oh(Rh)});var qu=ph(Hl,{LinearRing:rh(Ru)});var Ju=ph(Hl,{LinearRing:rh(Ru)});function Qu(t,e){for(var i=es(e),r=[255*(4==i.length?i[3]:1),i[2],i[1],i[0]],n=0;n<4;++n){var o=Math.floor(r[n]).toString(16);r[n]=1==o.length?"0"+o:o}bh(t,r.join(""))}var $u=ph(Hl,{Data:sh(function(t,e,i){t.setAttribute("name",e.name);var r={node:t},n=e.value;"object"==typeof n?(null!==n&&n.displayName&&gh(r,$u,lh,[n.displayName],i,["displayName"]),null!==n&&n.value&&gh(r,$u,lh,[n.value],i,["value"])):gh(r,$u,lh,[n],i,["value"])}),value:sh(function(t,e){bh(t,e)}),displayName:sh(function(t,e){Ph(t,e)})});var tp=ph(Hl,{Placemark:sh(xp)}),ep=function(t,e,i){return Ja(e[e.length-1].node.namespaceURI,"Placemark")};var ip=hh("Data");var rp=ph(Hl,["href"],ph(Zl,["x","y","w","h"])),np=ph(Hl,{href:sh(bh)},ph(Zl,{x:sh(Mh),y:sh(Mh),w:sh(Mh),h:sh(Mh)})),op=function(t,e,i){return Ja(Zl[0],"gx:"+i)};var sp=ph(Hl,["scale","heading","Icon","hotSpot"]),ap=ph(Hl,{Icon:sh(function(t,e,i){var r={node:t},n=i[i.length-1].node,o=rp[n.namespaceURI],s=uh(e,o);gh(r,np,lh,s,i,o),s=uh(e,o=rp[Zl[0]]),gh(r,np,op,s,i,o)}),heading:sh(Mh),hotSpot:sh(function(t,e){t.setAttribute("x",String(e.x)),t.setAttribute("y",String(e.y)),t.setAttribute("xunits",e.xunits),t.setAttribute("yunits",e.yunits)}),scale:sh(Ap)});var hp=ph(Hl,["color","scale"]),lp=ph(Hl,{color:sh(Qu),scale:sh(Ap)});var up=ph(Hl,["color","width"]),pp=ph(Hl,{color:sh(Qu),width:sh(Mh)});var cp={Point:"Point",LineString:"LineString",LinearRing:"LinearRing",Polygon:"Polygon",MultiPoint:"MultiGeometry",MultiLineString:"MultiGeometry",MultiPolygon:"MultiGeometry",GeometryCollection:"MultiGeometry"},dp=function(t,e,i){if(t)return Ja(e[e.length-1].node.namespaceURI,cp[t.getType()])},fp=hh("Point"),gp=hh("LineString"),_p=hh("LinearRing"),yp=hh("Polygon"),vp=ph(Hl,{LineString:sh(Op),Point:sh(Op),Polygon:sh(Fp),GeometryCollection:sh(mp)});function mp(t,e,i){var r,n,o={node:t},s=e.getType();s==_i.GEOMETRY_COLLECTION?(r=e.getGeometries(),n=dp):s==_i.MULTI_POINT?(r=e.getPoints(),n=fp):s==_i.MULTI_LINE_STRING?(r=e.getLineStrings(),n=gp):s==_i.MULTI_POLYGON?(r=e.getPolygons(),n=yp):te(!1,39),gh(o,vp,n,r,i)}var Ep=ph(Hl,{LinearRing:sh(Op)});function Sp(t,e,i){gh({node:t},Ep,_p,[e],i)}var Tp=ph(Hl,{ExtendedData:sh(function(t,e,i){for(var r={node:t},n=e.names,o=e.values,s=n.length,a=0;a<s;a++)gh(r,$u,ip,[{name:n[a],value:o[a]}],i)}),MultiGeometry:sh(mp),LineString:sh(Op),LinearRing:sh(Op),Point:sh(Op),Polygon:sh(Fp),Style:sh(function(t,e,i){var r={node:t},n={},o=e.getFill(),s=e.getStroke(),a=e.getImage(),h=e.getText();a&&"function"==typeof a.getSrc&&(n.IconStyle=a);h&&(n.LabelStyle=h);s&&(n.LineStyle=s);o&&(n.PolyStyle=o);var l=i[i.length-1].node,u=Gp[l.namespaceURI],p=uh(n,u);gh(r,Dp,lh,p,i,u)}),address:sh(bh),description:sh(bh),name:sh(bh),open:sh(Lh),phoneNumber:sh(bh),styleUrl:sh(bh),visibility:sh(Lh)}),Cp=ph(Hl,["name","open","visibility","address","phoneNumber","description","styleUrl","Style"]),Rp=hh("ExtendedData");function xp(t,e,i){var r={node:t};e.getId()&&t.setAttribute("id",e.getId());var n=e.getProperties(),o={address:1,description:1,name:1,open:1,phoneNumber:1,styleUrl:1,visibility:1};o[e.getGeometryName()]=1;var s=Object.keys(n||{}).sort().filter(function(t){return!o[t]});if(s.length>0){var a=uh(n,s);gh(r,Tp,Rp,[{names:s,values:a}],i)}var h=e.getStyleFunction();if(h){var l=h(e,0);if(l){var u=Array.isArray(l)?l[0]:l;this.writeStyles_&&(n.Style=u);var p=u.getText();p&&(n.name=p.getText())}}var c=i[i.length-1].node,d=Cp[c.namespaceURI],f=uh(n,d);gh(r,Tp,lh,f,i,d);var g=i[0],_=e.getGeometry();_&&(_=Ba(_,!0,g)),gh(r,Tp,dp,[_],i)}var wp=ph(Hl,["extrude","tessellate","altitudeMode","coordinates"]),Ip=ph(Hl,{extrude:sh(Lh),tessellate:sh(Lh),altitudeMode:sh(bh),coordinates:sh(function(t,e,i){var r,n=i[i.length-1],o=n.layout,s=n.stride;o==yi.XY||o==yi.XYM?r=2:o==yi.XYZ||o==yi.XYZM?r=3:te(!1,34);var a=e.length,h="";if(a>0){h+=e[0];for(var l=1;l<r;++l)h+=","+e[l];for(var u=s;u<a;u+=s){h+=" "+e[u];for(var p=1;p<r;++p)h+=","+e[u+p]}}bh(t,h)})});function Op(t,e,i){var r=e.getFlatCoordinates(),n={node:t};n.layout=e.getLayout(),n.stride=e.getStride();var o=e.getProperties();o.coordinates=r;var s=i[i.length-1].node,a=wp[s.namespaceURI],h=uh(o,a);gh(n,Ip,lh,h,i,a)}var Lp=ph(Hl,{outerBoundaryIs:sh(Sp),innerBoundaryIs:sh(Sp)}),Pp=hh("innerBoundaryIs"),Mp=hh("outerBoundaryIs");function Fp(t,e,i){var r=e.getLinearRings(),n=r.shift(),o={node:t};gh(o,Lp,Pp,r,i),gh(o,Lp,Mp,[n],i)}var bp=ph(Hl,{color:sh(Qu)}),Np=hh("color");function Ap(t,e){Mh(t,Math.round(1e6*e)/1e6)}var Gp=ph(Hl,["IconStyle","LabelStyle","LineStyle","PolyStyle"]),Dp=ph(Hl,{IconStyle:sh(function(t,e,i){var r={node:t},n={},o=e.getSrc(),s=e.getSize(),a=e.getImageSize(),h={href:o};if(s){h.w=s[0],h.h=s[1];var l=e.getAnchor(),u=e.getOrigin();if(u&&a&&0!==u[0]&&u[1]!==s[1]&&(h.x=u[0],h.y=a[1]-(u[1]+s[1])),l&&(l[0]!==s[0]/2||l[1]!==s[1]/2)){var p={x:l[0],xunits:Cl.PIXELS,y:s[1]-l[1],yunits:Cl.PIXELS};n.hotSpot=p}}n.Icon=h;var c=e.getScale();1!==c&&(n.scale=c);var d=e.getRotation();0!==d&&(n.heading=d);var f=i[i.length-1].node,g=sp[f.namespaceURI],_=uh(n,g);gh(r,ap,lh,_,i,g)}),LabelStyle:sh(function(t,e,i){var r={node:t},n={},o=e.getFill();o&&(n.color=o.getColor());var s=e.getScale();s&&1!==s&&(n.scale=s);var a=i[i.length-1].node,h=hp[a.namespaceURI],l=uh(n,h);gh(r,lp,lh,l,i,h)}),LineStyle:sh(function(t,e,i){var r={node:t},n={color:e.getColor(),width:e.getWidth()},o=i[i.length-1].node,s=up[o.namespaceURI],a=uh(n,s);gh(r,pp,lh,a,i,s)}),PolyStyle:sh(function(t,e,i){gh({node:t},bp,Np,[e.getColor()],i)})});var kp=pu,Yp=yh+" http://schemas.opengis.net/gml/2.1.2/feature.xsd",Up={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"},jp=function(t){function e(e){var i=e||{};t.call(this,i),this.FEATURE_COLLECTION_PARSERS[yh].featureMember=ih(this.readFeaturesInternal),this.schemaLocation=i.schemaLocation?i.schemaLocation:Yp}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFlatCoordinates_=function(t,e){var i=Qa(t,!1).replace(/^\s*|\s*$/g,""),r=e[0].srsName,n="enu";if(r){var o=Zi(r);o&&(n=o.getAxisOrientation())}for(var s=i.trim().split(/\s+/),a=[],h=0,l=s.length;h<l;h++){var u=s[h].split(/,+/),p=parseFloat(u[0]),c=parseFloat(u[1]),d=3===u.length?parseFloat(u[2]):0;"en"===n.substr(0,2)?a.push(p,c,d):a.push(c,p,d)}return a},e.prototype.readBox_=function(t,e){var i=dh([null],this.BOX_PARSERS_,t,e,this);return Ve(i[1][0],i[1][1],i[1][3],i[1][4])},e.prototype.innerBoundaryIsParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&e[e.length-1].push(i)},e.prototype.outerBoundaryIsParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&(e[e.length-1][0]=i)},e.prototype.GEOMETRY_NODE_FACTORY_=function(t,e,i){var r,n=e[e.length-1],o=n.multiSurface,s=n.surface,a=n.multiCurve;return Array.isArray(t)?r="Envelope":"MultiPolygon"===(r=t.getType())&&!0===o?r="MultiSurface":"Polygon"===r&&!0===s?r="Surface":"MultiLineString"===r&&!0===a&&(r="MultiCurve"),Ja("http://www.opengis.net/gml",r)},e.prototype.writeFeatureElement=function(t,e,i){var r=e.getId();r&&t.setAttribute("fid",r);var n=i[i.length-1],o=n.featureNS,s=e.getGeometryName();n.serializers||(n.serializers={},n.serializers[o]={});var a=e.getProperties(),h=[],l=[];for(var p in a){var c=a[p];null!==c&&(h.push(p),l.push(c),p==s||"function"==typeof c.getSimplifiedGeometry?p in n.serializers[o]||(n.serializers[o][p]=sh(this.writeGeometryElement,this)):p in n.serializers[o]||(n.serializers[o][p]=sh(bh)))}var d=u({},n);d.node=t,gh(d,n.serializers,hh(void 0,o),l,i,h)},e.prototype.writeCurveOrLineString_=function(t,e,i){var r=i[i.length-1].srsName;if("LineStringSegment"!==t.nodeName&&r&&t.setAttribute("srsName",r),"LineString"===t.nodeName||"LineStringSegment"===t.nodeName){var n=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(n),this.writeCoordinates_(n,e,i)}else if("Curve"===t.nodeName){var o=Ja(t.namespaceURI,"segments");t.appendChild(o),this.writeCurveSegments_(o,e,i)}},e.prototype.writeLineStringOrCurveMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeCurveOrLineString_(r,e,i))},e.prototype.writeMultiCurveOrLineString_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.curve;o&&t.setAttribute("srsName",o);var a=e.getLineStrings();gh({node:t,hasZ:n,srsName:o,curve:s},this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeGeometryElement=function(t,e,i){var r,n=i[i.length-1],o=u({},n);o.node=t,r=Array.isArray(e)?n.dataProjection?rr(e,n.featureProjection,n.dataProjection):e:Ba(e,!0,n),gh(o,this.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[r],i,void 0,this)},e.prototype.createCoordinatesNode_=function(t){var e=Ja(t,"coordinates");return e.setAttribute("decimal","."),e.setAttribute("cs",","),e.setAttribute("ts"," "),e},e.prototype.writeCoordinates_=function(t,e,i){for(var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=e.getCoordinates(),a=s.length,h=new Array(a),l=0;l<a;++l){var u=s[l];h[l]=this.getCoords_(u,o,n)}bh(t,h.join(" "))},e.prototype.writeCurveSegments_=function(t,e,i){var r=Ja(t.namespaceURI,"LineStringSegment");t.appendChild(r),this.writeCurveOrLineString_(r,e,i)},e.prototype.writeSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;if("PolygonPatch"!==t.nodeName&&o&&t.setAttribute("srsName",o),"Polygon"===t.nodeName||"PolygonPatch"===t.nodeName){var s=e.getLinearRings();gh({node:t,hasZ:n,srsName:o},this.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,s,i,void 0,this)}else if("Surface"===t.nodeName){var a=Ja(t.namespaceURI,"patches");t.appendChild(a),this.writeSurfacePatches_(a,e,i)}},e.prototype.RING_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1],n=r.node,o=r.exteriorWritten;return void 0===o&&(r.exteriorWritten=!0),Ja(n.namespaceURI,void 0!==o?"innerBoundaryIs":"outerBoundaryIs")},e.prototype.writeSurfacePatches_=function(t,e,i){var r=Ja(t.namespaceURI,"PolygonPatch");t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i)},e.prototype.writeRing_=function(t,e,i){var r=Ja(t.namespaceURI,"LinearRing");t.appendChild(r),this.writeLinearRing_(r,e,i)},e.prototype.getCoords_=function(t,e,i){var r="enu";e&&(r=Zi(e).getAxisOrientation());var n="en"===r.substr(0,2)?t[0]+","+t[1]:t[1]+","+t[0];i&&(n+=","+(t[2]||0));return n},e.prototype.writePoint_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;o&&t.setAttribute("srsName",o);var s=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(s);var a=e.getCoordinates();bh(s,this.getCoords_(a,o,n))},e.prototype.writeMultiPoint_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;o&&t.setAttribute("srsName",o);var s=e.getPoints();gh({node:t,hasZ:n,srsName:o},this.POINTMEMBER_SERIALIZERS_,hh("pointMember"),s,i,void 0,this)},e.prototype.writePointMember_=function(t,e,i){var r=Ja(t.namespaceURI,"Point");t.appendChild(r),this.writePoint_(r,e,i)},e.prototype.writeLinearRing_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(n),this.writeCoordinates_(n,e,i)},e.prototype.writeMultiSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.surface;o&&t.setAttribute("srsName",o);var a=e.getPolygons();gh({node:t,hasZ:n,srsName:o,surface:s},this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeSurfaceOrPolygonMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i))},e.prototype.writeEnvelope=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=[e[0]+" "+e[1],e[2]+" "+e[3]];gh({node:t},this.ENVELOPE_SERIALIZERS_,lh,n,i,["lowerCorner","upperCorner"],this)},e.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1].node;return Ja("http://www.opengis.net/gml",Up[r.nodeName])},e}(Eh);jp.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{coordinates:rh(jp.prototype.readFlatCoordinates_)}},jp.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{innerBoundaryIs:jp.prototype.innerBoundaryIsParser_,outerBoundaryIs:jp.prototype.outerBoundaryIsParser_}},jp.prototype.BOX_PARSERS_={"http://www.opengis.net/gml":{coordinates:ih(jp.prototype.readFlatCoordinates_)}},jp.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{Point:rh(Eh.prototype.readPoint),MultiPoint:rh(Eh.prototype.readMultiPoint),LineString:rh(Eh.prototype.readLineString),MultiLineString:rh(Eh.prototype.readMultiLineString),LinearRing:rh(Eh.prototype.readLinearRing),Polygon:rh(Eh.prototype.readPolygon),MultiPolygon:rh(Eh.prototype.readMultiPolygon),Box:rh(jp.prototype.readBox_)}},jp.prototype.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:sh(jp.prototype.writeCurveOrLineString_),MultiCurve:sh(jp.prototype.writeMultiCurveOrLineString_),Point:sh(jp.prototype.writePoint_),MultiPoint:sh(jp.prototype.writeMultiPoint_),LineString:sh(jp.prototype.writeCurveOrLineString_),MultiLineString:sh(jp.prototype.writeMultiCurveOrLineString_),LinearRing:sh(jp.prototype.writeLinearRing_),Polygon:sh(jp.prototype.writeSurfaceOrPolygon_),MultiPolygon:sh(jp.prototype.writeMultiSurfaceOrPolygon_),Surface:sh(jp.prototype.writeSurfaceOrPolygon_),MultiSurface:sh(jp.prototype.writeMultiSurfaceOrPolygon_),Envelope:sh(jp.prototype.writeEnvelope)}},jp.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:sh(jp.prototype.writeLineStringOrCurveMember_),curveMember:sh(jp.prototype.writeLineStringOrCurveMember_)}},jp.prototype.RING_SERIALIZERS_={"http://www.opengis.net/gml":{outerBoundaryIs:sh(jp.prototype.writeRing_),innerBoundaryIs:sh(jp.prototype.writeRing_)}},jp.prototype.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:sh(jp.prototype.writePointMember_)}},jp.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:sh(jp.prototype.writeSurfaceOrPolygonMember_),polygonMember:sh(jp.prototype.writeSurfaceOrPolygonMember_)}},jp.prototype.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:sh(bh),upperCorner:sh(bh)}};var Xp=jp,Bp=function(t){this.tagName_=t};Bp.prototype.getTagName=function(){return this.tagName_};var Vp=Bp,Wp=function(t){function e(e,i){t.call(this,e),this.conditions=i,te(this.conditions.length>=2,57)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Vp),Kp=function(t){function e(e){t.call(this,"And",Array.prototype.slice.call(arguments))}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Wp),zp=function(t){function e(e,i,r){t.call(this,"BBOX"),this.geometryName=e,this.extent=i,this.srsName=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Vp);var Zp={"http://www.opengis.net/gml":{boundedBy:oh(Eh.prototype.readGeometryElement,"bounds")}},Hp={"http://www.opengis.net/wfs":{totalInserted:oh(wh),totalUpdated:oh(wh),totalDeleted:oh(wh)}},qp={"http://www.opengis.net/wfs":{TransactionSummary:oh(function(t,e){return dh({},Hp,t,e)},"transactionSummary"),InsertResults:oh(function(t,e){return dh([],hc,t,e)},"insertIds")}},Jp={"http://www.opengis.net/wfs":{PropertyName:sh(bh)}},Qp={"http://www.opengis.net/wfs":{Insert:sh(function(t,e,i){var r=i[i.length-1],n=r.featureType,o=r.featureNS,s=r.gmlVersion,a=Ja(o,n);t.appendChild(a),2===s?Xp.prototype.writeFeatureElement(a,e,i):Dh.prototype.writeFeatureElement(a,e,i)}),Update:sh(function(t,e,i){var r=i[i.length-1];te(void 0!==e.getId(),27);var n=r.featureType,o=r.featurePrefix,s=r.featureNS,a=uc(o,n),h=e.getGeometryName();t.setAttribute("typeName",a),t.setAttributeNS(tc,"xmlns:"+o,s);var l=e.getId();if(void 0!==l){for(var u=e.getKeys(),p=[],c=0,d=u.length;c<d;c++){var f=e.get(u[c]);if(void 0!==f){var g=u[c];f&&"function"==typeof f.getSimplifiedGeometry&&(g=h),p.push({name:g,value:f})}}gh({gmlVersion:r.gmlVersion,node:t,hasZ:r.hasZ,srsName:r.srsName},Qp,hh("Property"),p,i),lc(t,l,i)}}),Delete:sh(function(t,e,i){var r=i[i.length-1];te(void 0!==e.getId(),26);var n=r.featureType,o=r.featurePrefix,s=r.featureNS,a=uc(o,n);t.setAttribute("typeName",a),t.setAttributeNS(tc,"xmlns:"+o,s);var h=e.getId();void 0!==h&&lc(t,h,i)}),Property:sh(function(t,e,i){var r=Ja(ic,"Name"),n=i[i.length-1].gmlVersion;if(t.appendChild(r),bh(r,e.name),void 0!==e.value&&null!==e.value){var o=Ja(ic,"Value");t.appendChild(o),e.value&&"function"==typeof e.value.getSimplifiedGeometry?2===n?Xp.prototype.writeGeometryElement(o,e.value,i):Dh.prototype.writeGeometryElement(o,e.value,i):bh(o,e.value)}}),Native:sh(function(t,e,i){e.vendorId&&t.setAttribute("vendorId",e.vendorId);void 0!==e.safeToIgnore&&t.setAttribute("safeToIgnore",String(e.safeToIgnore));void 0!==e.value&&bh(t,e.value)})}},$p="feature",tc="http://www.w3.org/2000/xmlns/",ec="http://www.opengis.net/ogc",ic="http://www.opengis.net/wfs",rc="http://www.opengis.net/fes",nc={"1.1.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd","1.0.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"},oc="1.1.0",sc=function(t){function e(e){t.call(this);var i=e||{};this.featureType_=i.featureType,this.featureNS_=i.featureNS,this.gmlFormat_=i.gmlFormat?i.gmlFormat:new Dh,this.schemaLocation_=i.schemaLocation?i.schemaLocation:nc[oc]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getFeatureType=function(){return this.featureType_},e.prototype.setFeatureType=function(t){this.featureType_=t},e.prototype.readFeaturesFromNode=function(t,e){var i={node:t};u(i,{featureType:this.featureType_,featureNS:this.featureNS_}),u(i,this.getReadOptions(t,e||{}));var r=[i];this.gmlFormat_.FEATURE_COLLECTION_PARSERS[yh].featureMember=ih(Eh.prototype.readFeaturesInternal);var n=dh([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,t,r,this.gmlFormat_);return n||(n=[]),n},e.prototype.readTransactionResponse=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readTransactionResponseFromDocument(e)}return $a(t)?this.readTransactionResponseFromDocument(t):this.readTransactionResponseFromNode(t)}},e.prototype.readFeatureCollectionMetadata=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readFeatureCollectionMetadataFromDocument(e)}return $a(t)?this.readFeatureCollectionMetadataFromDocument(t):this.readFeatureCollectionMetadataFromNode(t)}},e.prototype.readFeatureCollectionMetadataFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFeatureCollectionMetadataFromNode(e)},e.prototype.readFeatureCollectionMetadataFromNode=function(t){var e={},i=Ih(t.getAttribute("numberOfFeatures"));return e.numberOfFeatures=i,dh(e,Zp,t,[],this.gmlFormat_)},e.prototype.readTransactionResponseFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readTransactionResponseFromNode(e)},e.prototype.readTransactionResponseFromNode=function(t){return dh({},qp,t,[])},e.prototype.writeGetFeature=function(t){var e,i,r,n,o=Ja(ic,"GetFeature");if(o.setAttribute("service","WFS"),o.setAttribute("version","1.1.0"),t&&(t.handle&&o.setAttribute("handle",t.handle),t.outputFormat&&o.setAttribute("outputFormat",t.outputFormat),void 0!==t.maxFeatures&&o.setAttribute("maxFeatures",String(t.maxFeatures)),t.resultType&&o.setAttribute("resultType",t.resultType),void 0!==t.startIndex&&o.setAttribute("startIndex",String(t.startIndex)),void 0!==t.count&&o.setAttribute("count",String(t.count)),void 0!==t.viewParams&&o.setAttribute("viewParams ",t.viewParams),e=t.filter,t.bbox)){te(t.geometryName,12);var s=(i=t.geometryName,r=t.bbox,n=t.srsName,new zp(i,r,n));e=e?function(t){var e=[null].concat(Array.prototype.slice.call(arguments));return new(Function.prototype.bind.apply(Kp,e))}(e,s):s}o.setAttributeNS(qa,"xsi:schemaLocation",this.schemaLocation_);var a={node:o};return u(a,{srsName:t.srsName,featureNS:t.featureNS?t.featureNS:this.featureNS_,featurePrefix:t.featurePrefix,geometryName:t.geometryName,filter:e,propertyNames:t.propertyNames?t.propertyNames:[]}),te(Array.isArray(t.featureTypes),11),function(t,e,i){var r=i[i.length-1],n=u({},r);n.node=t,gh(n,pc,hh("Query"),e,i)}(o,t.featureTypes,[a]),o},e.prototype.writeTransaction=function(t,e,i,r){var n,o,s=[],a=Ja(ic,"Transaction"),h=r.version?r.version:oc,l="1.0.0"===h?2:3;a.setAttribute("service","WFS"),a.setAttribute("version",h),r&&(n=r.gmlOptions?r.gmlOptions:{},r.handle&&a.setAttribute("handle",r.handle));var p=nc[h];a.setAttributeNS(qa,"xsi:schemaLocation",p);var c=r.featurePrefix?r.featurePrefix:$p;return t&&(o=u({node:a},{featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,hasZ:r.hasZ,srsName:r.srsName}),u(o,n),gh(o,Qp,hh("Insert"),t,s)),e&&(o=u({node:a},{featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,hasZ:r.hasZ,srsName:r.srsName}),u(o,n),gh(o,Qp,hh("Update"),e,s)),i&&gh({node:a,featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,srsName:r.srsName},Qp,hh("Delete"),i,s),r.nativeElements&&gh({node:a,featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,srsName:r.srsName},Qp,hh("Native"),r.nativeElements,s),a},e.prototype.readProjectionFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readProjectionFromNode(e);return null},e.prototype.readProjectionFromNode=function(t){if(t.firstElementChild&&t.firstElementChild.firstElementChild)for(var e=(t=t.firstElementChild.firstElementChild).firstElementChild;e;e=e.nextElementSibling)if(0!==e.childNodes.length&&(1!==e.childNodes.length||3!==e.firstChild.nodeType)){var i=[{}];return this.gmlFormat_.readGeometryElement(e,i),Zi(i.pop().srsName)}return null},e}(_h);var ac={"http://www.opengis.net/ogc":{FeatureId:ih(function(t,e){return t.getAttribute("fid")})}};var hc={"http://www.opengis.net/wfs":{Feature:function(t,e){ch(ac,t,e)}}};function lc(t,e,i){var r=Ja(ec,"Filter"),n=Ja(ec,"FeatureId");r.appendChild(n),n.setAttribute("fid",e),t.appendChild(r)}function uc(t,e){var i=(t=t||$p)+":";return 0===e.indexOf(i)?e:i+e}var pc={"http://www.opengis.net/wfs":{Query:sh(function(t,e,i){var r,n=i[i.length-1],o=n.featurePrefix,s=n.featureNS,a=n.propertyNames,h=n.srsName;r=o?uc(o,e):e;t.setAttribute("typeName",r),h&&t.setAttribute("srsName",h);s&&t.setAttributeNS(tc,"xmlns:"+o,s);var l=u({},n);l.node=t,gh(l,Jp,hh("PropertyName"),a,i);var p=n.filter;if(p){var c=Ja(ec,"Filter");t.appendChild(c),cc(c,p,i)}})},"http://www.opengis.net/ogc":{During:sh(function(t,e,i){var r=Ja(rc,"ValueReference");bh(r,e.propertyName),t.appendChild(r);var n=Ja(yh,"TimePeriod");t.appendChild(n);var o=Ja(yh,"begin");n.appendChild(o),vc(o,e.begin);var s=Ja(yh,"end");n.appendChild(s),vc(s,e.end)}),And:sh(dc),Or:sh(dc),Not:sh(function(t,e,i){var r={node:t},n=e.condition;gh(r,pc,hh(n.getTagName()),[n],i)}),BBOX:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.extent,i)}),Contains:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),Intersects:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),Within:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),PropertyIsEqualTo:sh(fc),PropertyIsNotEqualTo:sh(fc),PropertyIsLessThan:sh(fc),PropertyIsLessThanOrEqualTo:sh(fc),PropertyIsGreaterThan:sh(fc),PropertyIsGreaterThanOrEqualTo:sh(fc),PropertyIsNull:sh(function(t,e,i){_c(t,e.propertyName)}),PropertyIsBetween:sh(function(t,e,i){_c(t,e.propertyName);var r=Ja(ec,"LowerBoundary");t.appendChild(r),yc(r,""+e.lowerBoundary);var n=Ja(ec,"UpperBoundary");t.appendChild(n),yc(n,""+e.upperBoundary)}),PropertyIsLike:sh(function(t,e,i){t.setAttribute("wildCard",e.wildCard),t.setAttribute("singleChar",e.singleChar),t.setAttribute("escapeChar",e.escapeChar),void 0!==e.matchCase&&t.setAttribute("matchCase",e.matchCase.toString());_c(t,e.propertyName),yc(t,""+e.pattern)})}};function cc(t,e,i){gh({node:t},pc,hh(e.getTagName()),[e],i)}function dc(t,e,i){for(var r={node:t},n=e.conditions,o=0,s=n.length;o<s;++o){var a=n[o];gh(r,pc,hh(a.getTagName()),[a],i)}}function fc(t,e,i){void 0!==e.matchCase&&t.setAttribute("matchCase",e.matchCase.toString()),_c(t,e.propertyName),yc(t,""+e.expression)}function gc(t,e,i){var r=Ja(ec,t);bh(r,i),e.appendChild(r)}function _c(t,e){gc("PropertyName",t,e)}function yc(t,e){gc("Literal",t,e)}function vc(t,e){var i=Ja(yh,"TimeInstant");t.appendChild(i);var r=Ja(yh,"timePosition");i.appendChild(r),bh(r,e)}var mc=sc;function Ec(t){return"string"==typeof t?t:""}var Sc=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.TEXT},e.prototype.readFeature=function(t,e){return this.readFeatureFromText(Ec(t),this.adaptOptions(e))},e.prototype.readFeatureFromText=function(t,e){return r()},e.prototype.readFeatures=function(t,e){return this.readFeaturesFromText(Ec(t),this.adaptOptions(e))},e.prototype.readFeaturesFromText=function(t,e){return r()},e.prototype.readGeometry=function(t,e){return this.readGeometryFromText(Ec(t),this.adaptOptions(e))},e.prototype.readGeometryFromText=function(t,e){return r()},e.prototype.readProjection=function(t){return this.readProjectionFromText(Ec(t))},e.prototype.readProjectionFromText=function(t){return this.dataProjection},e.prototype.writeFeature=function(t,e){return this.writeFeatureText(t,this.adaptOptions(e))},e.prototype.writeFeatureText=function(t,e){return r()},e.prototype.writeFeatures=function(t,e){return this.writeFeaturesText(t,this.adaptOptions(e))},e.prototype.writeFeaturesText=function(t,e){return r()},e.prototype.writeGeometry=function(t,e){return this.writeGeometryText(t,this.adaptOptions(e))},e.prototype.writeGeometryText=function(t,e){return r()},e}(Xa),Tc={POINT:Gr,LINESTRING:Fa,POLYGON:qr,MULTIPOINT:La,MULTILINESTRING:ba,MULTIPOLYGON:Na},Cc="EMPTY",Rc="Z",xc="M",wc=1,Ic=2,Oc=3,Lc=4,Pc=5,Mc=6,Fc={};for(var bc in _i)Fc[bc]=_i[bc].toUpperCase();var Nc=function(t){this.wkt=t,this.index_=-1};Nc.prototype.isAlpha_=function(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"},Nc.prototype.isNumeric_=function(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)},Nc.prototype.isWhiteSpace_=function(t){return" "==t||"\t"==t||"\r"==t||"\n"==t},Nc.prototype.nextChar_=function(){return this.wkt.charAt(++this.index_)},Nc.prototype.nextToken=function(){var t,e=this.nextChar_(),i=this.index_,r=e;if("("==e)t=Ic;else if(","==e)t=Pc;else if(")"==e)t=Oc;else if(this.isNumeric_(e)||"-"==e)t=Lc,r=this.readNumber_();else if(this.isAlpha_(e))t=wc,r=this.readText_();else{if(this.isWhiteSpace_(e))return this.nextToken();if(""!==e)throw new Error("Unexpected character: "+e);t=Mc}return{position:i,value:r,type:t}},Nc.prototype.readNumber_=function(){var t,e=this.index_,i=!1,r=!1;do{"."==t?i=!0:"e"!=t&&"E"!=t||(r=!0),t=this.nextChar_()}while(this.isNumeric_(t,i)||!r&&("e"==t||"E"==t)||r&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))},Nc.prototype.readText_=function(){var t,e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()};var Ac=function(t){this.lexer_=t,this.token_,this.layout_=yi.XY};function Gc(t){var e=t.getCoordinates();return 0===e.length?"":e.join(" ")}function Dc(t){for(var e=t.getCoordinates(),i=[],r=0,n=e.length;r<n;++r)i.push(e[r].join(" "));return i.join(",")}function kc(t){for(var e=[],i=t.getLinearRings(),r=0,n=i.length;r<n;++r)e.push("("+Dc(i[r])+")");return e.join(",")}Ac.prototype.consume_=function(){this.token_=this.lexer_.nextToken()},Ac.prototype.isTokenType=function(t){return this.token_.type==t},Ac.prototype.match=function(t){var e=this.isTokenType(t);return e&&this.consume_(),e},Ac.prototype.parse=function(){return this.consume_(),this.parseGeometry_()},Ac.prototype.parseGeometryLayout_=function(){var t=yi.XY,e=this.token_;if(this.isTokenType(wc)){var i=e.value;i===Rc?t=yi.XYZ:i===xc?t=yi.XYM:"ZM"===i&&(t=yi.XYZM),t!==yi.XY&&this.consume_()}return t},Ac.prototype.parseGeometryCollectionText_=function(){if(this.match(Ic)){var t=[];do{t.push(this.parseGeometry_())}while(this.match(Pc));if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePointText_=function(){if(this.match(Ic)){var t=this.parsePoint_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())},Ac.prototype.parseLineStringText_=function(){if(this.match(Ic)){var t=this.parsePointList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePolygonText_=function(){if(this.match(Ic)){var t=this.parseLineStringTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiPointText_=function(){var t;if(this.match(Ic)){if(t=this.token_.type==Ic?this.parsePointTextList_():this.parsePointList_(),this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiLineStringText_=function(){if(this.match(Ic)){var t=this.parseLineStringTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiPolygonText_=function(){if(this.match(Ic)){var t=this.parsePolygonTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePoint_=function(){for(var t=[],e=this.layout_.length,i=0;i<e;++i){var r=this.token_;if(!this.match(Lc))break;t.push(r.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePointList_=function(){for(var t=[this.parsePoint_()];this.match(Pc);)t.push(this.parsePoint_());return t},Ac.prototype.parsePointTextList_=function(){for(var t=[this.parsePointText_()];this.match(Pc);)t.push(this.parsePointText_());return t},Ac.prototype.parseLineStringTextList_=function(){for(var t=[this.parseLineStringText_()];this.match(Pc);)t.push(this.parseLineStringText_());return t},Ac.prototype.parsePolygonTextList_=function(){for(var t=[this.parsePolygonText_()];this.match(Pc);)t.push(this.parsePolygonText_());return t},Ac.prototype.isEmptyGeometry_=function(){var t=this.isTokenType(wc)&&this.token_.value==Cc;return t&&this.consume_(),t},Ac.prototype.formatErrorMessage_=function(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"},Ac.prototype.parseGeometry_=function(){var t=this.token_;if(this.match(wc)){var e=t.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==e){var i=this.parseGeometryCollectionText_();return new ka(i)}var r,n=Tc[e];if(!n)throw new Error("Invalid geometry type: "+e);switch(e){case"POINT":r=this.parsePointText_();break;case"LINESTRING":r=this.parseLineStringText_();break;case"POLYGON":r=this.parsePolygonText_();break;case"MULTIPOINT":r=this.parseMultiPointText_();break;case"MULTILINESTRING":r=this.parseMultiLineStringText_();break;case"MULTIPOLYGON":r=this.parseMultiPolygonText_();break;default:throw new Error("Invalid geometry type: "+e)}return r||(r=n===Tc.POINT?[NaN,NaN]:[]),new n(r,this.layout_)}throw new Error(this.formatErrorMessage_())};var Yc={Point:Gc,LineString:Dc,Polygon:kc,MultiPoint:function(t){for(var e=[],i=t.getPoints(),r=0,n=i.length;r<n;++r)e.push("("+Gc(i[r])+")");return e.join(",")},MultiLineString:function(t){for(var e=[],i=t.getLineStrings(),r=0,n=i.length;r<n;++r)e.push("("+Dc(i[r])+")");return e.join(",")},MultiPolygon:function(t){for(var e=[],i=t.getPolygons(),r=0,n=i.length;r<n;++r)e.push("("+kc(i[r])+")");return e.join(",")},GeometryCollection:function(t){for(var e=[],i=t.getGeometries(),r=0,n=i.length;r<n;++r)e.push(Uc(i[r]));return e.join(",")}};function Uc(t){var e=t.getType(),i=(0,Yc[e])(t);if(e=e.toUpperCase(),"function"==typeof t.getFlatCoordinates){var r=function(t){var e=t.getLayout(),i="";return e!==yi.XYZ&&e!==yi.XYZM||(i+=Rc),e!==yi.XYM&&e!==yi.XYZM||(i+=xc),i}(t);r.length>0&&(e+=" "+r)}return 0===i.length?e+" "+Cc:e+"("+i+")"}var jc=function(t){function e(e){t.call(this);var i=e||{};this.splitCollection_=void 0!==i.splitCollection&&i.splitCollection}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.parse_=function(t){var e=new Nc(t);return new Ac(e).parse()},e.prototype.readFeatureFromText=function(t,e){var i=this.readGeometryFromText(t,e);if(i){var r=new Oa;return r.setGeometry(i),r}return null},e.prototype.readFeaturesFromText=function(t,e){for(var i=[],r=this.readGeometryFromText(t,e),n=[],o=0,s=(i=this.splitCollection_&&r.getType()==_i.GEOMETRY_COLLECTION?r.getGeometriesArray():[r]).length;o<s;++o){var a=new Oa;a.setGeometry(i[o]),n.push(a)}return n},e.prototype.readGeometryFromText=function(t,e){var i=this.parse_(t);return i?Ba(i,!1,e):null},e.prototype.writeFeatureText=function(t,e){var i=t.getGeometry();return i?this.writeGeometryText(i,e):""},e.prototype.writeFeaturesText=function(t,e){if(1==t.length)return this.writeFeatureText(t[0],e);for(var i=[],r=0,n=t.length;r<n;++r)i.push(t[r].getGeometry());var o=new ka(i);return this.writeGeometryText(o,e)},e.prototype.writeGeometryText=function(t,e){return Uc(Ba(t,!0,e))},e}(Sc),Xc="http://www.w3.org/1999/xlink";function Bc(t){return t.getAttributeNS(Xc,"href")}var Vc=function(){};Vc.prototype.read=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readFromDocument(e)}return $a(t)?this.readFromDocument(t):this.readFromNode(t)}return null},Vc.prototype.readFromDocument=function(t){},Vc.prototype.readFromNode=function(t){};var Wc=Vc,Kc=[null,"http://www.opengis.net/wms"],zc=ph(Kc,{Service:oh(function(t,e){return dh({},qc,t,e)}),Capability:oh(function(t,e){return dh({},Zc,t,e)})}),Zc=ph(Kc,{Request:oh(function(t,e){return dh({},nd,t,e)}),Exception:oh(function(t,e){return dh([],td,t,e)}),Layer:oh(function(t,e){return dh({},ed,t,e)})}),Hc=function(t){function e(){t.call(this),this.version=void 0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){this.version=t.getAttribute("version").trim();var e=dh({version:this.version},zc,t,[]);return e||null},e}(Wc),qc=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),KeywordList:oh(fd),OnlineResource:oh(Bc),ContactInformation:oh(function(t,e){return dh({},Jc,t,e)}),Fees:oh(Oh),AccessConstraints:oh(Oh),LayerLimit:oh(wh),MaxWidth:oh(wh),MaxHeight:oh(wh)}),Jc=ph(Kc,{ContactPersonPrimary:oh(function(t,e){return dh({},Qc,t,e)}),ContactPosition:oh(Oh),ContactAddress:oh(function(t,e){return dh({},$c,t,e)}),ContactVoiceTelephone:oh(Oh),ContactFacsimileTelephone:oh(Oh),ContactElectronicMailAddress:oh(Oh)}),Qc=ph(Kc,{ContactPerson:oh(Oh),ContactOrganization:oh(Oh)}),$c=ph(Kc,{AddressType:oh(Oh),Address:oh(Oh),City:oh(Oh),StateOrProvince:oh(Oh),PostCode:oh(Oh),Country:oh(Oh)}),td=ph(Kc,{Format:ih(Oh)}),ed=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),KeywordList:oh(fd),CRS:nh(Oh),EX_GeographicBoundingBox:oh(function(t,e){var i=dh({},rd,t,e);if(!i)return;var r=i.westBoundLongitude,n=i.southBoundLatitude,o=i.eastBoundLongitude,s=i.northBoundLatitude;if(void 0===r||void 0===n||void 0===o||void 0===s)return;return[r,n,o,s]}),BoundingBox:nh(function(t,e){var i=[xh(t.getAttribute("minx")),xh(t.getAttribute("miny")),xh(t.getAttribute("maxx")),xh(t.getAttribute("maxy"))],r=[xh(t.getAttribute("resx")),xh(t.getAttribute("resy"))];return{crs:t.getAttribute("CRS"),extent:i,res:r}}),Dimension:nh(function(t,e){return{name:t.getAttribute("name"),units:t.getAttribute("units"),unitSymbol:t.getAttribute("unitSymbol"),default:t.getAttribute("default"),multipleValues:Th(t.getAttribute("multipleValues")),nearestValue:Th(t.getAttribute("nearestValue")),current:Th(t.getAttribute("current")),values:Oh(t)}}),Attribution:oh(function(t,e){return dh({},id,t,e)}),AuthorityURL:nh(function(t,e){var i=pd(t,e);if(i)return i.name=t.getAttribute("name"),i;return}),Identifier:nh(Oh),MetadataURL:nh(function(t,e){var i=pd(t,e);if(i)return i.type=t.getAttribute("type"),i;return}),DataURL:nh(pd),FeatureListURL:nh(pd),Style:nh(function(t,e){return dh({},hd,t,e)}),MinScaleDenominator:oh(Rh),MaxScaleDenominator:oh(Rh),Layer:nh(function(t,e){var i=e[e.length-1],r=dh({},ed,t,e);if(!r)return;var n=Th(t.getAttribute("queryable"));void 0===n&&(n=i.queryable);r.queryable=void 0!==n&&n;var o=Ih(t.getAttribute("cascaded"));void 0===o&&(o=i.cascaded);r.cascaded=o;var s=Th(t.getAttribute("opaque"));void 0===s&&(s=i.opaque);r.opaque=void 0!==s&&s;var a=Th(t.getAttribute("noSubsets"));void 0===a&&(a=i.noSubsets);r.noSubsets=void 0!==a&&a;var h=xh(t.getAttribute("fixedWidth"));h||(h=i.fixedWidth);r.fixedWidth=h;var l=xh(t.getAttribute("fixedHeight"));l||(l=i.fixedHeight);r.fixedHeight=l,["Style","CRS","AuthorityURL"].forEach(function(t){if(t in i){var e=r[t]||[];r[t]=e.concat(i[t])}});return["EX_GeographicBoundingBox","BoundingBox","Dimension","Attribution","MinScaleDenominator","MaxScaleDenominator"].forEach(function(t){if(!(t in r)){var e=i[t];r[t]=e}}),r})}),id=ph(Kc,{Title:oh(Oh),OnlineResource:oh(Bc),LogoURL:oh(dd)}),rd=ph(Kc,{westBoundLongitude:oh(Rh),eastBoundLongitude:oh(Rh),southBoundLatitude:oh(Rh),northBoundLatitude:oh(Rh)}),nd=ph(Kc,{GetCapabilities:oh(cd),GetMap:oh(cd),GetFeatureInfo:oh(cd)}),od=ph(Kc,{Format:nh(Oh),DCPType:nh(function(t,e){return dh({},sd,t,e)})}),sd=ph(Kc,{HTTP:oh(function(t,e){return dh({},ad,t,e)})}),ad=ph(Kc,{Get:oh(pd),Post:oh(pd)}),hd=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),LegendURL:nh(dd),StyleSheetURL:oh(pd),StyleURL:oh(pd)}),ld=ph(Kc,{Format:oh(Oh),OnlineResource:oh(Bc)}),ud=ph(Kc,{Keyword:ih(Oh)});function pd(t,e){return dh({},ld,t,e)}function cd(t,e){return dh({},od,t,e)}function dd(t,e){var i=pd(t,e);if(i){var r=[Ih(t.getAttribute("width")),Ih(t.getAttribute("height"))];return i.size=r,i}}function fd(t,e){return dh([],ud,t,e)}var gd=Hc,_d=function(t){function e(e){t.call(this);var i=e||{};this.featureNS_="http://mapserver.gis.umn.edu/mapserver",this.gmlFormat_=new Xp,this.layers_=i.layers?i.layers:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getLayers=function(){return this.layers_},e.prototype.setLayers=function(t){this.layers_=t},e.prototype.readFeatures_=function(t,e){t.setAttribute("namespaceURI",this.featureNS_);var i=t.localName,r=[];if(0===t.childNodes.length)return r;if("msGMLOutput"==i)for(var n=0,o=t.childNodes.length;n<o;n++){var s=t.childNodes[n];if(s.nodeType===Node.ELEMENT_NODE){var a=s,h=e[0],l=a.localName.replace("_layer","");if(!this.layers_||At(this.layers_,l)){var u=l+"_feature";h.featureType=u,h.featureNS=this.featureNS_;var p={};p[u]=ih(this.gmlFormat_.readFeatureElement,this.gmlFormat_);var c=ph([h.featureNS,null],p);a.setAttribute("namespaceURI",this.featureNS_);var d=dh([],c,a,e,this.gmlFormat_);d&&kt(r,d)}}}if("FeatureCollection"==i){var f=dh([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,t,[{}],this.gmlFormat_);f&&(r=f)}return r},e.prototype.readFeaturesFromNode=function(t,e){var i={};return e&&u(i,this.getReadOptions(t,e)),this.readFeatures_(t,[i])},e}(_h),yd=[null,"http://www.opengis.net/ows/1.1"],vd=ph(yd,{ServiceIdentification:oh(function(t,e){return dh({},Md,t,e)}),ServiceProvider:oh(function(t,e){return dh({},Fd,t,e)}),OperationsMetadata:oh(function(t,e){return dh({},Id,t,e)})}),md=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){var e=dh({},vd,t,[]);return e||null},e}(Wc),Ed=ph(yd,{DeliveryPoint:oh(Oh),City:oh(Oh),AdministrativeArea:oh(Oh),PostalCode:oh(Oh),Country:oh(Oh),ElectronicMailAddress:oh(Oh)}),Sd=ph(yd,{Value:nh(function(t,e){return Oh(t)})}),Td=ph(yd,{AllowedValues:oh(function(t,e){return dh({},Sd,t,e)})}),Cd=ph(yd,{Phone:oh(function(t,e){return dh({},Od,t,e)}),Address:oh(function(t,e){return dh({},Ed,t,e)})}),Rd=ph(yd,{HTTP:oh(function(t,e){return dh({},xd,t,e)})}),xd=ph(yd,{Get:nh(function(t,e){var i=Bc(t);if(!i)return;return dh({href:i},Ld,t,e)}),Post:void 0}),wd=ph(yd,{DCP:oh(function(t,e){return dh({},Rd,t,e)})}),Id=ph(yd,{Operation:function(t,e){var i=t.getAttribute("name"),r=dh({},wd,t,e);if(!r)return;e[e.length-1][i]=r}}),Od=ph(yd,{Voice:oh(Oh),Facsimile:oh(Oh)}),Ld=ph(yd,{Constraint:nh(function(t,e){var i=t.getAttribute("name");if(!i)return;return dh({name:i},Td,t,e)})}),Pd=ph(yd,{IndividualName:oh(Oh),PositionName:oh(Oh),ContactInfo:oh(function(t,e){return dh({},Cd,t,e)})}),Md=ph(yd,{Abstract:oh(Oh),AccessConstraints:oh(Oh),Fees:oh(Oh),Title:oh(Oh),ServiceTypeVersion:oh(Oh),ServiceType:oh(Oh)}),Fd=ph(yd,{ProviderName:oh(Oh),ProviderSite:oh(Bc),ServiceContact:oh(function(t,e){return dh({},Pd,t,e)})});var bd=md,Nd=[null,"http://www.opengis.net/wmts/1.0"],Ad=[null,"http://www.opengis.net/ows/1.1"],Gd=ph(Nd,{Contents:oh(function(t,e){return dh({},kd,t,e)})}),Dd=function(t){function e(){t.call(this),this.owsParser_=new bd}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){var e=t.getAttribute("version").trim(),i=this.owsParser_.readFromNode(t);return i?(i.version=e,(i=dh(i,Gd,t,[]))||null):null},e}(Wc),kd=ph(Nd,{Layer:nh(function(t,e){return dh({},Yd,t,e)}),TileMatrixSet:nh(function(t,e){return dh({},Kd,t,e)})}),Yd=ph(Nd,{Style:nh(function(t,e){var i=dh({},Ud,t,e);if(!i)return;var r="true"===t.getAttribute("isDefault");return i.isDefault=r,i}),Format:nh(Oh),TileMatrixSetLink:nh(function(t,e){return dh({},jd,t,e)}),Dimension:nh(function(t,e){return dh({},Vd,t,e)}),ResourceURL:nh(function(t,e){var i=t.getAttribute("format"),r=t.getAttribute("template"),n=t.getAttribute("resourceType"),o={};i&&(o.format=i);r&&(o.template=r);n&&(o.resourceType=n);return o})},ph(Ad,{Title:oh(Oh),Abstract:oh(Oh),WGS84BoundingBox:oh(function(t,e){var i=dh([],Wd,t,e);if(2!=i.length)return;return Ae(i)}),Identifier:oh(Oh)})),Ud=ph(Nd,{LegendURL:nh(function(t,e){var i={};return i.format=t.getAttribute("format"),i.href=Bc(t),i})},ph(Ad,{Title:oh(Oh),Identifier:oh(Oh)})),jd=ph(Nd,{TileMatrixSet:oh(Oh),TileMatrixSetLimits:oh(function(t,e){return dh([],Xd,t,e)})}),Xd=ph(Nd,{TileMatrixLimits:ih(function(t,e){return dh({},Bd,t,e)})}),Bd=ph(Nd,{TileMatrix:oh(Oh),MinTileRow:oh(wh),MaxTileRow:oh(wh),MinTileCol:oh(wh),MaxTileCol:oh(wh)}),Vd=ph(Nd,{Default:oh(Oh),Value:nh(Oh)},ph(Ad,{Identifier:oh(Oh)})),Wd=ph(Ad,{LowerCorner:ih(Zd),UpperCorner:ih(Zd)}),Kd=ph(Nd,{WellKnownScaleSet:oh(Oh),TileMatrix:nh(function(t,e){return dh({},zd,t,e)})},ph(Ad,{SupportedCRS:oh(Oh),Identifier:oh(Oh)})),zd=ph(Nd,{TopLeftCorner:oh(Zd),ScaleDenominator:oh(Rh),TileWidth:oh(wh),TileHeight:oh(wh),MatrixWidth:oh(wh),MatrixHeight:oh(wh)},ph(Ad,{Identifier:oh(Oh)}));function Zd(t,e){var i=Oh(t).split(/\s+/);if(i&&2==i.length){var r=+i[0],n=+i[1];if(!isNaN(r)&&!isNaN(n))return[r,n]}}var Hd=Dd,qd={Point:function(t,e,i){var r=t.coordinates;e&&i&&ef(r,e,i);return new Gr(r)},LineString:function(t,e){var i=Jd(t.arcs,e);return new Fa(i)},Polygon:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r)i[r]=Jd(t.arcs[r],e);return new qr(i)},MultiPoint:function(t,e,i){var r=t.coordinates;if(e&&i)for(var n=0,o=r.length;n<o;++n)ef(r[n],e,i);return new La(r)},MultiLineString:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r)i[r]=Jd(t.arcs[r],e);return new ba(i)},MultiPolygon:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r){for(var o=t.arcs[r],s=[],a=0,h=o.length;a<h;++a)s[a]=Jd(o[a],e);i[r]=s}return new Na(i)}};function Jd(t,e){for(var i,r,n=[],o=0,s=t.length;o<s;++o)i=t[o],o>0&&n.pop(),r=i>=0?e[i]:e[~i].slice().reverse(),n.push.apply(n,r);for(var a=0,h=n.length;a<h;++a)n[a]=n[a].slice();return n}function Qd(t,e,i,r,n,o,s){for(var a=t.geometries,h=[],l=0,u=a.length;l<u;++l)h[l]=$d(a[l],e,i,r,n,o,s);return h}function $d(t,e,i,r,n,o,s){var a,h=t.type,l=qd[h];a="Point"===h||"MultiPoint"===h?l(t,i,r):l(t,e);var u=new Oa;u.setGeometry(Ba(a,!1,s)),void 0!==t.id&&u.setId(t.id);var p=t.properties;return n&&(p||(p={}),p[n]=o),p&&u.setProperties(p),u}function tf(t,e,i){for(var r=0,n=0,o=0,s=t.length;o<s;++o){var a=t[o];r+=a[0],n+=a[1],a[0]=r,a[1]=n,ef(a,e,i)}}function ef(t,e,i){t[0]=t[0]*e[0]+i[0],t[1]=t[1]*e[1]+i[1]}var rf=function(t){function e(e){t.call(this);var i=e||{};this.layerName_=i.layerName,this.layers_=i.layers?i.layers:null,this.dataProjection=Zi(i.dataProjection?i.dataProjection:"EPSG:4326")}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeaturesFromObject=function(t,e){if("Topology"==t.type){var i,r=t,n=null,o=null;r.transform&&(n=(i=r.transform).scale,o=i.translate);var s=r.arcs;i&&function(t,e,i){for(var r=0,n=t.length;r<n;++r)tf(t[r],e,i)}(s,n,o);var a,h=[],l=r.objects,u=this.layerName_;for(var p in l)this.layers_&&-1==this.layers_.indexOf(p)||("GeometryCollection"===l[p].type?(a=l[p],h.push.apply(h,Qd(a,s,n,o,u,p,e))):(a=l[p],h.push($d(a,s,n,o,u,p,e))));return h}return[]},e.prototype.readProjectionFromObject=function(t){return this.dataProjection},e}(Wa),nf="renderOrder",of=function(t){function e(e){var i=e||{},r=u({},i);delete r.style,delete r.renderBuffer,delete r.updateWhileAnimating,delete r.updateWhileInteracting,t.call(this,r),this.declutter_=void 0!==i.declutter&&i.declutter,this.renderBuffer_=void 0!==i.renderBuffer?i.renderBuffer:100,this.style_=null,this.styleFunction_=void 0,this.setStyle(i.style),this.updateWhileAnimating_=void 0!==i.updateWhileAnimating&&i.updateWhileAnimating,this.updateWhileInteracting_=void 0!==i.updateWhileInteracting&&i.updateWhileInteracting,this.renderMode_=i.renderMode||Mo.VECTOR,this.type=Po.VECTOR}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDeclutter=function(){return this.declutter_},e.prototype.setDeclutter=function(t){this.declutter_=t},e.prototype.getRenderBuffer=function(){return this.renderBuffer_},e.prototype.getRenderOrder=function(){return this.get(nf)},e.prototype.getStyle=function(){return this.style_},e.prototype.getStyleFunction=function(){return this.styleFunction_},e.prototype.getUpdateWhileAnimating=function(){return this.updateWhileAnimating_},e.prototype.getUpdateWhileInteracting=function(){return this.updateWhileInteracting_},e.prototype.setRenderOrder=function(t){this.set(nf,t)},e.prototype.setStyle=function(t){this.style_=void 0!==t?t:Al,this.styleFunction_=null===t?void 0:function(t){var e;if("function"==typeof t)e=t;else{var i;Array.isArray(t)?i=t:(te("function"==typeof t.getZIndex,41),i=[t]),e=function(){return i}}return e}(this.style_),this.changed()},e.prototype.getRenderMode=function(){return this.renderMode_},e}(On);of.prototype.getSource;var sf=of;function af(t,e){return[[-1/0,-1/0,1/0,1/0]]}function hf(t){return t?Array.isArray(t)?function(e){return t}:"function"==typeof t?t:function(e){return[t]}:null}var lf=function(t){function e(e){t.call(this),this.projection_=Zi(e.projection),this.attributions_=hf(e.attributions),this.attributionsCollapsible_=void 0===e.attributionsCollapsible||e.attributionsCollapsible,this.loading=!1,this.state_=void 0!==e.state?e.state:dn.READY,this.wrapX_=void 0!==e.wrapX&&e.wrapX}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getAttributions=function(){return this.attributions_},e.prototype.getAttributionsCollapsible=function(){return this.attributionsCollapsible_},e.prototype.getProjection=function(){return this.projection_},e.prototype.getResolutions=function(){return r()},e.prototype.getState=function(){return this.state_},e.prototype.getWrapX=function(){return this.wrapX_},e.prototype.refresh=function(){this.changed()},e.prototype.setAttributions=function(t){this.attributions_=hf(t),this.changed()},e.prototype.setState=function(t){this.state_=t,this.changed()},e}(G),uf={ADDFEATURE:"addfeature",CHANGEFEATURE:"changefeature",CLEAR:"clear",REMOVEFEATURE:"removefeature"},pf=function(t){this.rbush_=xs()(t,void 0),this.items_={}};pf.prototype.insert=function(t,e){var i={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};this.rbush_.insert(i),this.items_[o(e)]=i},pf.prototype.load=function(t,e){for(var i=new Array(e.length),r=0,n=e.length;r<n;r++){var s=t[r],a=e[r],h={minX:s[0],minY:s[1],maxX:s[2],maxY:s[3],value:a};i[r]=h,this.items_[o(a)]=h}this.rbush_.load(i)},pf.prototype.remove=function(t){var e=o(t),i=this.items_[e];return delete this.items_[e],null!==this.rbush_.remove(i)},pf.prototype.update=function(t,e){var i=this.items_[o(e)];Ze([i.minX,i.minY,i.maxX,i.maxY],t)||(this.remove(e),this.insert(t,e))},pf.prototype.getAll=function(){return this.rbush_.all().map(function(t){return t.value})},pf.prototype.getInExtent=function(t){var e={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]};return this.rbush_.search(e).map(function(t){return t.value})},pf.prototype.forEach=function(t,e){return this.forEach_(this.getAll(),t,e)},pf.prototype.forEachInExtent=function(t,e,i){return this.forEach_(this.getInExtent(t),e,i)},pf.prototype.forEach_=function(t,e,i){for(var r,n=0,o=t.length;n<o;n++)if(r=e.call(i,t[n]))return r;return r},pf.prototype.isEmpty=function(){return d(this.items_)},pf.prototype.clear=function(){this.rbush_.clear(),this.items_={}},pf.prototype.getExtent=function(t){var e=this.rbush_.toJSON();return Ve(e.minX,e.minY,e.maxX,e.maxY,t)},pf.prototype.concat=function(t){for(var e in this.rbush_.load(t.rbush_.all()),t.items_)this.items_[e]=t.items_[e]};var cf=pf,df=function(t){function e(e,i){t.call(this,e),this.feature=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),ff=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:void 0,state:dn.READY,wrapX:void 0===i.wrapX||i.wrapX}),this.loader_=w,this.format_=i.format,this.overlaps_=null==i.overlaps||i.overlaps,this.url_=i.url,void 0!==i.loader?this.loader_=i.loader:void 0!==this.url_&&(te(this.format_,7),this.loader_=Ua(this.url_,this.format_)),this.strategy_=void 0!==i.strategy?i.strategy:af;var r,n,o=void 0===i.useSpatialIndex||i.useSpatialIndex;this.featuresRtree_=o?new cf:null,this.loadedExtentsRtree_=new cf,this.nullGeometryFeatures_={},this.idIndex_={},this.undefIdIndex_={},this.featureChangeKeys_={},this.featuresCollection_=null,Array.isArray(i.features)?n=i.features:i.features&&(n=(r=i.features).getArray()),o||void 0!==r||(r=new Y(n)),void 0!==n&&this.addFeaturesInternal(n),void 0!==r&&this.bindFeaturesCollection_(r)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature=function(t){this.addFeatureInternal(t),this.changed()},e.prototype.addFeatureInternal=function(t){var e=o(t);if(this.addToIndex_(e,t)){this.setupChangeEvents_(e,t);var i=t.getGeometry();if(i){var r=i.getExtent();this.featuresRtree_&&this.featuresRtree_.insert(r,t)}else this.nullGeometryFeatures_[e]=t;this.dispatchEvent(new df(uf.ADDFEATURE,t))}},e.prototype.setupChangeEvents_=function(t,e){this.featureChangeKeys_[t]=[v(e,M.CHANGE,this.handleFeatureChange_,this),v(e,l,this.handleFeatureChange_,this)]},e.prototype.addToIndex_=function(t,e){var i=!0,r=e.getId();return void 0!==r?r.toString()in this.idIndex_?i=!1:this.idIndex_[r.toString()]=e:(te(!(t in this.undefIdIndex_),30),this.undefIdIndex_[t]=e),i},e.prototype.addFeatures=function(t){this.addFeaturesInternal(t),this.changed()},e.prototype.addFeaturesInternal=function(t){for(var e=[],i=[],r=[],n=0,s=t.length;n<s;n++){var a=t[n],h=o(a);this.addToIndex_(h,a)&&i.push(a)}for(var l=0,u=i.length;l<u;l++){var p=i[l],c=o(p);this.setupChangeEvents_(c,p);var d=p.getGeometry();if(d){var f=d.getExtent();e.push(f),r.push(p)}else this.nullGeometryFeatures_[c]=p}this.featuresRtree_&&this.featuresRtree_.load(e,r);for(var g=0,_=i.length;g<_;g++)this.dispatchEvent(new df(uf.ADDFEATURE,i[g]))},e.prototype.bindFeaturesCollection_=function(t){var e=!1;v(this,uf.ADDFEATURE,function(i){e||(e=!0,t.push(i.feature),e=!1)}),v(this,uf.REMOVEFEATURE,function(i){e||(e=!0,t.remove(i.feature),e=!1)}),v(t,h.ADD,function(t){e||(e=!0,this.addFeature(t.element),e=!1)},this),v(t,h.REMOVE,function(t){e||(e=!0,this.removeFeature(t.element),e=!1)},this),this.featuresCollection_=t},e.prototype.clear=function(t){if(t){for(var e in this.featureChangeKeys_){this.featureChangeKeys_[e].forEach(S)}this.featuresCollection_||(this.featureChangeKeys_={},this.idIndex_={},this.undefIdIndex_={})}else if(this.featuresRtree_)for(var i in this.featuresRtree_.forEach(this.removeFeatureInternal,this),this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[i]);this.featuresCollection_&&this.featuresCollection_.clear(),this.featuresRtree_&&this.featuresRtree_.clear(),this.loadedExtentsRtree_.clear(),this.nullGeometryFeatures_={};var r=new df(uf.CLEAR);this.dispatchEvent(r),this.changed()},e.prototype.forEachFeature=function(t){if(this.featuresRtree_)return this.featuresRtree_.forEach(t);this.featuresCollection_&&this.featuresCollection_.forEach(t)},e.prototype.forEachFeatureAtCoordinateDirect=function(t,e){var i=[t[0],t[1],t[0],t[1]];return this.forEachFeatureInExtent(i,function(i){return i.getGeometry().intersectsCoordinate(t)?e(i):void 0})},e.prototype.forEachFeatureInExtent=function(t,e){if(this.featuresRtree_)return this.featuresRtree_.forEachInExtent(t,e);this.featuresCollection_&&this.featuresCollection_.forEach(e)},e.prototype.forEachFeatureIntersectingExtent=function(t,e){return this.forEachFeatureInExtent(t,function(i){if(i.getGeometry().intersectsExtent(t)){var r=e(i);if(r)return r}})},e.prototype.getFeaturesCollection=function(){return this.featuresCollection_},e.prototype.getFeatures=function(){var t;return this.featuresCollection_?t=this.featuresCollection_.getArray():this.featuresRtree_&&(t=this.featuresRtree_.getAll(),d(this.nullGeometryFeatures_)||kt(t,c(this.nullGeometryFeatures_))),t},e.prototype.getFeaturesAtCoordinate=function(t){var e=[];return this.forEachFeatureAtCoordinateDirect(t,function(t){e.push(t)}),e},e.prototype.getFeaturesInExtent=function(t){return this.featuresRtree_.getInExtent(t)},e.prototype.getClosestFeatureToCoordinate=function(t,e){var i=t[0],r=t[1],n=null,o=[NaN,NaN],s=1/0,a=[-1/0,-1/0,1/0,1/0],h=e||R;return this.featuresRtree_.forEachInExtent(a,function(t){if(h(t)){var e=t.getGeometry(),l=s;if((s=e.closestPointXY(i,r,o,s))<l){n=t;var u=Math.sqrt(s);a[0]=i-u,a[1]=r-u,a[2]=i+u,a[3]=r+u}}}),n},e.prototype.getExtent=function(t){return this.featuresRtree_.getExtent(t)},e.prototype.getFeatureById=function(t){var e=this.idIndex_[t.toString()];return void 0!==e?e:null},e.prototype.getFormat=function(){return this.format_},e.prototype.getOverlaps=function(){return this.overlaps_},e.prototype.getUrl=function(){return this.url_},e.prototype.handleFeatureChange_=function(t){var e=t.target,i=o(e),r=e.getGeometry();if(r){var n=r.getExtent();i in this.nullGeometryFeatures_?(delete this.nullGeometryFeatures_[i],this.featuresRtree_&&this.featuresRtree_.insert(n,e)):this.featuresRtree_&&this.featuresRtree_.update(n,e)}else i in this.nullGeometryFeatures_||(this.featuresRtree_&&this.featuresRtree_.remove(e),this.nullGeometryFeatures_[i]=e);var s=e.getId();if(void 0!==s){var a=s.toString();i in this.undefIdIndex_?(delete this.undefIdIndex_[i],this.idIndex_[a]=e):this.idIndex_[a]!==e&&(this.removeFromIdIndex_(e),this.idIndex_[a]=e)}else i in this.undefIdIndex_||(this.removeFromIdIndex_(e),this.undefIdIndex_[i]=e);this.changed(),this.dispatchEvent(new df(uf.CHANGEFEATURE,e))},e.prototype.hasFeature=function(t){var e=t.getId();return void 0!==e?e in this.idIndex_:o(t)in this.undefIdIndex_},e.prototype.isEmpty=function(){return this.featuresRtree_.isEmpty()&&d(this.nullGeometryFeatures_)},e.prototype.loadFeatures=function(t,e,i){var r=this,n=this.loadedExtentsRtree_,o=this.strategy_(t,e);this.loading=!1;for(var s=function(t,s){var a=o[t];n.forEachInExtent(a,function(t){return Ue(t.extent,a)})||(r.loader_.call(r,a,e,i),n.insert(a,{extent:a.slice()}),r.loading=r.loader_!==w)},a=0,h=o.length;a<h;++a)s(a)},e.prototype.removeLoadedExtent=function(t){var e,i=this.loadedExtentsRtree_;i.forEachInExtent(t,function(i){if(Ze(i.extent,t))return e=i,!0}),e&&i.remove(e)},e.prototype.removeFeature=function(t){var e=o(t);e in this.nullGeometryFeatures_?delete this.nullGeometryFeatures_[e]:this.featuresRtree_&&this.featuresRtree_.remove(t),this.removeFeatureInternal(t),this.changed()},e.prototype.removeFeatureInternal=function(t){var e=o(t);this.featureChangeKeys_[e].forEach(S),delete this.featureChangeKeys_[e];var i=t.getId();void 0!==i?delete this.idIndex_[i.toString()]:delete this.undefIdIndex_[e],this.dispatchEvent(new df(uf.REMOVEFEATURE,t))},e.prototype.removeFromIdIndex_=function(t){var e=!1;for(var i in this.idIndex_)if(this.idIndex_[i]===t){delete this.idIndex_[i],e=!0;break}return e},e.prototype.setLoader=function(t){this.loader_=t},e}(lf),gf={POINT:"Point",LINE_STRING:"LineString",POLYGON:"Polygon",CIRCLE:"Circle"},_f="drawstart",yf="drawend",vf=function(t){function e(e,i){t.call(this,e),this.feature=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);var mf=function(t){function e(e){var i=e;i.stopDown||(i.stopDown=x),t.call(this,i),this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=function(t){var e;t===_i.POINT||t===_i.MULTI_POINT?e=gf.POINT:t===_i.LINE_STRING||t===_i.MULTI_LINE_STRING?e=gf.LINE_STRING:t===_i.POLYGON||t===_i.MULTI_POLYGON?e=gf.POLYGON:t===_i.CIRCLE&&(e=gf.CIRCLE);return e}(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_===gf.POLYGON?3:2,this.maxPoints_=e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:R;var r,n=e.geometryFunction;if(!n)if(this.type_===_i.CIRCLE)n=function(t,e){var i=e||new Ga([NaN,NaN]),r=we(t[0],t[1]);return i.setCenterAndRadius(t[0],Math.sqrt(r)),i};else{var o,s=this.mode_;s===gf.POINT?o=Gr:s===gf.LINE_STRING?o=Fa:s===gf.POLYGON&&(o=qr),n=function(t,e){var i=e;return i?s===gf.POLYGON?t[0].length?i.setCoordinates([t[0].concat([t[0][0]])]):i.setCoordinates([]):i.setCoordinates(t):i=new o(t),i}}this.geometryFunction_=n,this.dragVertexDelay_=void 0!==e.dragVertexDelay?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new sf({source:new ff({useSpatialIndex:!1,wrapX:!!e.wrapX&&e.wrapX}),style:e.style?e.style:(r=Gl(),function(t,e){return r[t.getGeometry().getType()]}),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:Qn,this.freehandCondition_,e.freehand?this.freehandCondition_=zn:this.freehandCondition_=e.freehandCondition?e.freehandCondition:$n,v(this,A(Gn.ACTIVE),this.updateState_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setMap=function(e){t.prototype.setMap.call(this,e),this.updateState_()},e.prototype.getOverlay=function(){return this.overlay_},e.prototype.handleEvent=function(e){e.originalEvent.type===M.CONTEXTMENU&&e.preventDefault(),this.freehand_=this.mode_!==gf.POINT&&this.freehandCondition_(e);var i=e.type===Q.POINTERMOVE,r=!0;!this.freehand_&&this.lastDragTime_&&e.type===Q.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,i=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0));return this.freehand_&&e.type===Q.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(e),r=!1):this.freehand_&&e.type===Q.POINTERDOWN?r=!1:i?(r=e.type===Q.POINTERMOVE)&&this.freehand_?r=this.handlePointerMove_(e):(e.pointerEvent.pointerType==nt||e.type===Q.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(e):e.type===Q.DBLCLICK&&(r=!1),t.prototype.handleEvent.call(this,e)&&r},e.prototype.handleDownEvent=function(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t),!0):!!this.condition_(t)&&(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(function(){this.handlePointerMove_(new $(Q.POINTERMOVE,t.map,t.pointerEvent,!1,t.frameState))}.bind(this),this.dragVertexDelay_),this.downPx_=t.pixel,!0)},e.prototype.handleUpEvent=function(t){var e=!0;this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);var i=this.mode_===gf.CIRCLE;return this.shouldHandle_?(this.finishCoordinate_?this.freehand_||i?this.finishDrawing():this.atFinish_(t)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t):(this.startDrawing_(t),this.mode_===gf.POINT&&this.finishDrawing()),e=!1):this.freehand_&&(this.finishCoordinate_=null,this.abortDrawing_()),!e&&this.stopClick_&&t.stopPropagation(),e},e.prototype.handlePointerMove_=function(t){if(this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){var e=this.downPx_,i=t.pixel,r=e[0]-i[0],n=e[1]-i[1],o=r*r+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return!0}return this.finishCoordinate_?this.modifyDrawing_(t):this.createOrUpdateSketchPoint_(t),!0},e.prototype.atFinish_=function(t){var e=!1;if(this.sketchFeature_){var i=!1,r=[this.finishCoordinate_];if(this.mode_===gf.LINE_STRING)i=this.sketchCoords_.length>this.minPoints_;else if(this.mode_===gf.POLYGON){var n=this.sketchCoords_;i=n[0].length>this.minPoints_,r=[n[0][0],n[0][n[0].length-2]]}if(i)for(var o=t.map,s=0,a=r.length;s<a;s++){var h=r[s],l=o.getPixelFromCoordinate(h),u=t.pixel,p=u[0]-l[0],c=u[1]-l[1],d=this.freehand_?1:this.snapTolerance_;if(e=Math.sqrt(p*p+c*c)<=d){this.finishCoordinate_=h;break}}}return e},e.prototype.createOrUpdateSketchPoint_=function(t){var e=t.coordinate.slice();this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new Oa(new Gr(e)),this.updateSketchFeatures_())},e.prototype.startDrawing_=function(t){var e=t.coordinate;this.finishCoordinate_=e,this.mode_===gf.POINT?this.sketchCoords_=e.slice():this.mode_===gf.POLYGON?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Oa(new Fa(this.sketchLineCoords_)));var i=this.geometryFunction_(this.sketchCoords_);this.sketchFeature_=new Oa,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new vf(_f,this.sketchFeature_))},e.prototype.modifyDrawing_=function(t){var e,i,r,n=t.coordinate,o=this.sketchFeature_.getGeometry();(this.mode_===gf.POINT?i=this.sketchCoords_:this.mode_===gf.POLYGON?(i=(e=this.sketchCoords_[0])[e.length-1],this.atFinish_(t)&&(n=this.finishCoordinate_.slice())):i=(e=this.sketchCoords_)[e.length-1],i[0]=n[0],i[1]=n[1],this.geometryFunction_(this.sketchCoords_,o),this.sketchPoint_)&&this.sketchPoint_.getGeometry().setCoordinates(n);if(o.getType()==_i.POLYGON&&this.mode_!==gf.POLYGON){this.sketchLine_||(this.sketchLine_=new Oa);var s=o.getLinearRing(0);(r=this.sketchLine_.getGeometry())?(r.setFlatCoordinates(s.getLayout(),s.getFlatCoordinates()),r.changed()):(r=new Fa(s.getFlatCoordinates(),s.getLayout()),this.sketchLine_.setGeometry(r))}else this.sketchLineCoords_&&(r=this.sketchLine_.getGeometry()).setCoordinates(this.sketchLineCoords_);this.updateSketchFeatures_()},e.prototype.addToDrawing_=function(t){var e,i,r=t.coordinate,n=this.sketchFeature_.getGeometry();this.mode_===gf.LINE_STRING?(this.finishCoordinate_=r.slice(),(i=this.sketchCoords_).length>=this.maxPoints_&&(this.freehand_?i.pop():e=!0),i.push(r.slice()),this.geometryFunction_(i,n)):this.mode_===gf.POLYGON&&((i=this.sketchCoords_[0]).length>=this.maxPoints_&&(this.freehand_?i.pop():e=!0),i.push(r.slice()),e&&(this.finishCoordinate_=i[0]),this.geometryFunction_(this.sketchCoords_,n)),this.updateSketchFeatures_(),e&&this.finishDrawing()},e.prototype.removeLastPoint=function(){if(this.sketchFeature_){var t,e=this.sketchFeature_.getGeometry();this.mode_===gf.LINE_STRING?((t=this.sketchCoords_).splice(-2,1),this.geometryFunction_(t,e),t.length>=2&&(this.finishCoordinate_=t[t.length-2].slice())):this.mode_===gf.POLYGON&&((t=this.sketchCoords_[0]).splice(-2,1),this.sketchLine_.getGeometry().setCoordinates(t),this.geometryFunction_(this.sketchCoords_,e)),0===t.length&&(this.finishCoordinate_=null),this.updateSketchFeatures_()}},e.prototype.finishDrawing=function(){var t=this.abortDrawing_();if(t){var e=this.sketchCoords_,i=t.getGeometry();this.mode_===gf.LINE_STRING?(e.pop(),this.geometryFunction_(e,i)):this.mode_===gf.POLYGON&&(e[0].pop(),this.geometryFunction_(e,i),e=i.getCoordinates()),this.type_===_i.MULTI_POINT?t.setGeometry(new La([e])):this.type_===_i.MULTI_LINE_STRING?t.setGeometry(new ba([e])):this.type_===_i.MULTI_POLYGON&&t.setGeometry(new Na([e])),this.dispatchEvent(new vf(yf,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}},e.prototype.abortDrawing_=function(){this.finishCoordinate_=null;var t=this.sketchFeature_;return t&&(this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0)),t},e.prototype.extend=function(t){var e=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=e.getCoordinates();var i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.updateSketchFeatures_(),this.dispatchEvent(new vf(_f,this.sketchFeature_))},e.prototype.updateSketchFeatures_=function(){var t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);var e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)},e.prototype.updateState_=function(){var t=this.getMap(),e=this.getActive();t&&e||this.abortDrawing_(),this.overlay_.setMap(e?t:null)},e}(no),Ef="translatestart",Sf="translating",Tf="translateend",Cf=function(t){function e(e,i,r){t.call(this,e),this.features=i,this.coordinate=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),Rf=function(t){function e(e){var i,r=e||{};if(t.call(this,r),this.lastCoordinate_=null,this.features_=void 0!==r.features?r.features:null,r.layers)if("function"==typeof r.layers)i=r.layers;else{var n=r.layers;i=function(t){return At(n,t)}}else i=R;this.layerFilter_=i,this.hitTolerance_=r.hitTolerance?r.hitTolerance:0,this.lastFeature_=null,v(this,A(Gn.ACTIVE),this.handleActiveChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDownEvent=function(t){if(this.lastFeature_=this.featuresAtPixel_(t.pixel,t.map),!this.lastCoordinate_&&this.lastFeature_){this.lastCoordinate_=t.coordinate,this.handleMoveEvent(t);var e=this.features_||new Y([this.lastFeature_]);return this.dispatchEvent(new Cf(Ef,e,t.coordinate)),!0}return!1},e.prototype.handleUpEvent=function(t){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(t);var e=this.features_||new Y([this.lastFeature_]);return this.dispatchEvent(new Cf(Tf,e,t.coordinate)),!0}return!1},e.prototype.handleDragEvent=function(t){if(this.lastCoordinate_){var e=t.coordinate,i=e[0]-this.lastCoordinate_[0],r=e[1]-this.lastCoordinate_[1],n=this.features_||new Y([this.lastFeature_]);n.forEach(function(t){var e=t.getGeometry();e.translate(i,r),t.setGeometry(e)}),this.lastCoordinate_=e,this.dispatchEvent(new Cf(Sf,n,e))}},e.prototype.handleMoveEvent=function(t){var e=t.map.getViewport();this.featuresAtPixel_(t.pixel,t.map)?(e.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),e.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):e.classList.remove("ol-grab","ol-grabbing")},e.prototype.featuresAtPixel_=function(t,e){return e.forEachFeatureAtPixel(t,function(t){if(!this.features_||At(this.features_.getArray(),t))return t}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})},e.prototype.getHitTolerance=function(){return this.hitTolerance_},e.prototype.setHitTolerance=function(t){this.hitTolerance_=t},e.prototype.setMap=function(e){var i=this.getMap();t.prototype.setMap.call(this,e),this.updateState_(i)},e.prototype.handleActiveChanged_=function(){this.updateState_(null)},e.prototype.updateState_=function(t){var e=this.getMap(),i=this.getActive();e&&i||(e=e||t)&&e.getViewport().classList.remove("ol-grab","ol-grabbing")},e}(no);function xf(t){return t.feature?t.feature:t.element?t.element:void 0}var wf=function(t){function e(e){var i=e||{},r=i;r.handleDownEvent||(r.handleDownEvent=R),r.stopDown||(r.stopDown=x),t.call(this,r),this.source_=i.source?i.source:null,this.vertex_=void 0===i.vertex||i.vertex,this.edge_=void 0===i.edge||i.edge,this.features_=i.features?i.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelCoordinate_=null,this.pixelTolerance_=void 0!==i.pixelTolerance?i.pixelTolerance:10,this.sortByDistance_=function(t,e){var i=Oe(this.pixelCoordinate_,t.segment),r=Oe(this.pixelCoordinate_,e.segment);return i-r}.bind(this),this.rBush_=new cf,this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_,Circle:this.writeCircleGeometry_}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature=function(t,e){var i=void 0===e||e,r=o(t),n=t.getGeometry();if(n){var s=this.SEGMENT_WRITERS_[n.getType()];s&&(this.indexedFeaturesExtents_[r]=n.getExtent([1/0,1/0,-1/0,-1/0]),s.call(this,t,n))}i&&(this.featureChangeListenerKeys_[r]=v(t,M.CHANGE,this.handleFeatureChange_,this))},e.prototype.forEachFeatureAdd_=function(t){this.addFeature(t)},e.prototype.forEachFeatureRemove_=function(t){this.removeFeature(t)},e.prototype.getFeatures_=function(){var t;return this.features_?t=this.features_:this.source_&&(t=this.source_.getFeatures()),t},e.prototype.handleEvent=function(e){var i=this.snapTo(e.pixel,e.coordinate,e.map);return i.snapped&&(e.coordinate=i.vertex.slice(0,2),e.pixel=i.vertexPixel),t.prototype.handleEvent.call(this,e)},e.prototype.handleFeatureAdd_=function(t){var e=xf(t);this.addFeature(e)},e.prototype.handleFeatureRemove_=function(t){var e=xf(t);this.removeFeature(e)},e.prototype.handleFeatureChange_=function(t){var e=t.target;if(this.handlingDownUpSequence){var i=o(e);i in this.pendingFeatures_||(this.pendingFeatures_[i]=e)}else this.updateFeature_(e)},e.prototype.handleUpEvent=function(t){var e=c(this.pendingFeatures_);return e.length&&(e.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1},e.prototype.removeFeature=function(t,e){var i=void 0===e||e,r=o(t),n=this.indexedFeaturesExtents_[r];if(n){var s=this.rBush_,a=[];s.forEachInExtent(n,function(e){t===e.feature&&a.push(e)});for(var h=a.length-1;h>=0;--h)s.remove(a[h])}i&&(S(this.featureChangeListenerKeys_[r]),delete this.featureChangeListenerKeys_[r])},e.prototype.setMap=function(e){var i=this.getMap(),r=this.featuresListenerKeys_,n=this.getFeatures_();i&&(r.forEach(S),r.length=0,n.forEach(this.forEachFeatureRemove_.bind(this))),t.prototype.setMap.call(this,e),e&&(this.features_?r.push(v(this.features_,h.ADD,this.handleFeatureAdd_,this),v(this.features_,h.REMOVE,this.handleFeatureRemove_,this)):this.source_&&r.push(v(this.source_,uf.ADDFEATURE,this.handleFeatureAdd_,this),v(this.source_,uf.REMOVEFEATURE,this.handleFeatureRemove_,this)),n.forEach(this.forEachFeatureAdd_.bind(this)))},e.prototype.snapTo=function(t,e,i){var r=Ae([i.getCoordinateFromPixel([t[0]-this.pixelTolerance_,t[1]+this.pixelTolerance_]),i.getCoordinateFromPixel([t[0]+this.pixelTolerance_,t[1]-this.pixelTolerance_])]),n=this.rBush_.getInExtent(r);this.vertex_&&!this.edge_&&(n=n.filter(function(t){return t.feature.getGeometry().getType()!==_i.CIRCLE}));var o,s,a,h,l=!1,u=null,p=null;if(n.length>0){this.pixelCoordinate_=e,n.sort(this.sortByDistance_);var c=n[0].segment,d=n[0].feature.getGeometry().getType()===_i.CIRCLE;this.vertex_&&!this.edge_?(o=i.getPixelFromCoordinate(c[0]),s=i.getPixelFromCoordinate(c[1]),a=we(t,o),h=we(t,s),Math.sqrt(Math.min(a,h))<=this.pixelTolerance_&&(l=!0,u=a>h?c[1]:c[0],p=i.getPixelFromCoordinate(u))):this.edge_&&(u=d?function(t,e){var i=e.getRadius(),r=e.getCenter(),n=r[0],o=r[1],s=t[0]-n,a=t[1]-o;0===s&&0===a&&(s=1);var h=Math.sqrt(s*s+a*a);return[n+i*s/h,o+i*a/h]}(e,n[0].feature.getGeometry()):Te(e,c),Ie(t,p=i.getPixelFromCoordinate(u))<=this.pixelTolerance_&&(l=!0,this.vertex_&&!d&&(o=i.getPixelFromCoordinate(c[0]),s=i.getPixelFromCoordinate(c[1]),a=we(p,o),h=we(p,s),Math.sqrt(Math.min(a,h))<=this.pixelTolerance_&&(u=a>h?c[1]:c[0],p=i.getPixelFromCoordinate(u))))),l&&(p=[Math.round(p[0]),Math.round(p[1])])}return{snapped:l,vertex:u,vertexPixel:p}},e.prototype.updateFeature_=function(t){this.removeFeature(t,!1),this.addFeature(t,!1)},e.prototype.writeCircleGeometry_=function(t,e){for(var i=Qr(e).getCoordinates()[0],r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeGeometryCollectionGeometry_=function(t,e){for(var i=e.getGeometriesArray(),r=0;r<i.length;++r){var n=this.SEGMENT_WRITERS_[i[r].getType()];n&&n.call(this,t,i[r])}},e.prototype.writeLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeMultiLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writeMultiPointGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r){var o=i[r],s={feature:t,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},e.prototype.writeMultiPolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length;s<a;++s)for(var h=o[s],l=0,u=h.length-1;l<u;++l){var p=h.slice(l,l+2),c={feature:t,segment:p};this.rBush_.insert(Ae(p),c)}},e.prototype.writePointGeometry_=function(t,e){var i=e.getCoordinates(),r={feature:t,segment:[i,i]};this.rBush_.insert(e.getExtent(),r)},e.prototype.writePolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,segment:h};this.rBush_.insert(Ae(h),l)}},e}(no),If={SELECT:"select"},Of=function(t){function e(e,i,r,n){t.call(this,e),this.selected=i,this.deselected=r,this.mapBrowserEvent=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function Lf(t){if(!this.condition_(t))return!0;var e=this.addCondition_(t),i=this.removeCondition_(t),r=this.toggleCondition_(t),n=!e&&!i&&!r,o=t.map,s=this.getFeatures(),a=[],h=[];if(n){p(this.featureLayerAssociation_),o.forEachFeatureAtPixel(t.pixel,function(t,e){if(this.filter_(t,e))return h.push(t),this.addFeatureLayerAssociation_(t,e),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(var l=s.getLength()-1;l>=0;--l){var u=s.item(l),c=h.indexOf(u);c>-1?h.splice(c,1):(s.remove(u),a.push(u))}0!==h.length&&s.extend(h)}else{o.forEachFeatureAtPixel(t.pixel,function(t,n){if(this.filter_(t,n))return!e&&!r||At(s.getArray(),t)?(i||r)&&At(s.getArray(),t)&&(a.push(t),this.removeFeatureLayerAssociation_(t)):(h.push(t),this.addFeatureLayerAssociation_(t,n)),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(var d=a.length-1;d>=0;--d)s.remove(a[d]);s.extend(h)}return(h.length>0||a.length>0)&&this.dispatchEvent(new Of(If.SELECT,h,a,t)),qn(t)}function Pf(){var t=Gl();return kt(t[_i.POLYGON],t[_i.LINE_STRING]),kt(t[_i.GEOMETRY_COLLECTION],t[_i.LINE_STRING]),function(e,i){return e.getGeometry()?t[e.getGeometry().getType()]:null}}var Mf=function(t){function e(e){t.call(this,{handleEvent:Lf});var i=e||{};this.condition_=i.condition?i.condition:Jn,this.addCondition_=i.addCondition?i.addCondition:Hn,this.removeCondition_=i.removeCondition?i.removeCondition:Hn,this.toggleCondition_=i.toggleCondition?i.toggleCondition:$n,this.multi_=!!i.multi&&i.multi,this.filter_=i.filter?i.filter:R,this.hitTolerance_=i.hitTolerance?i.hitTolerance:0;var r,n=new sf({source:new ff({useSpatialIndex:!1,features:i.features,wrapX:i.wrapX}),style:i.style?i.style:Pf(),updateWhileAnimating:!0,updateWhileInteracting:!0});if(this.featureOverlay_=n,i.layers)if("function"==typeof i.layers)r=i.layers;else{var o=i.layers;r=function(t){return At(o,t)}}else r=R;this.layerFilter_=r,this.featureLayerAssociation_={};var s=this.getFeatures();v(s,h.ADD,this.addFeature_,this),v(s,h.REMOVE,this.removeFeature_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeatureLayerAssociation_=function(t,e){this.featureLayerAssociation_[o(t)]=e},e.prototype.getFeatures=function(){return this.featureOverlay_.getSource().getFeaturesCollection()},e.prototype.getHitTolerance=function(){return this.hitTolerance_},e.prototype.getLayer=function(t){return this.featureLayerAssociation_[o(t)]},e.prototype.getOverlay=function(){return this.featureOverlay_},e.prototype.setHitTolerance=function(t){this.hitTolerance_=t},e.prototype.setMap=function(e){var i=this.getMap(),r=this.getFeatures();i&&r.forEach(i.unskipFeature.bind(i)),t.prototype.setMap.call(this,e),this.featureOverlay_.setMap(e),e&&r.forEach(e.skipFeature.bind(e))},e.prototype.addFeature_=function(t){var e=this.getMap();e&&e.skipFeature(t.element)},e.prototype.removeFeature_=function(t){var e=this.getMap();e&&e.unskipFeature(t.element)},e.prototype.removeFeatureLayerAssociation_=function(t){delete this.featureLayerAssociation_[o(t)]},e}(jn),Ff=1,bf="modifystart",Nf="modifyend",Af=function(t){function e(e,i,r){t.call(this,e),this.features=i,this.mapBrowserEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function Gf(t,e){return t.index-e.index}function Df(t,e){var i=e.geometry;if(i.getType()===_i.CIRCLE){var r=i;if(e.index===Ff){var n=we(r.getCenter(),t),o=Math.sqrt(n)-r.getRadius();return o*o}}return Oe(t,e.segment)}function kf(t,e){var i=e.geometry;return i.getType()===_i.CIRCLE&&e.index===Ff?i.getClosestPoint(t):Te(t,e.segment)}function Yf(){var t=Gl();return function(e,i){return t[_i.POINT]}}var Uf=function(t){function e(e){var i;if(t.call(this,e),this.condition_=e.condition?e.condition:io,this.defaultDeleteCondition_=function(t){return Vn(t)&&Jn(t)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:zn,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.modified_=!1,this.rBush_=new cf,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new sf({source:new ff({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:Yf(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,Circle:this.writeCircleGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_},this.source_=null,e.source?(this.source_=e.source,i=new Y(this.source_.getFeatures()),v(this.source_,uf.ADDFEATURE,this.handleSourceAdd_,this),v(this.source_,uf.REMOVEFEATURE,this.handleSourceRemove_,this)):i=e.features,!i)throw new Error("The modify interaction requires features or a source");this.features_=i,this.features_.forEach(this.addFeature_.bind(this)),v(this.features_,h.ADD,this.handleFeatureAdd_,this),v(this.features_,h.REMOVE,this.handleFeatureRemove_,this),this.lastPointerEvent_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature_=function(t){var e=t.getGeometry();e&&e.getType()in this.SEGMENT_WRITERS_&&this.SEGMENT_WRITERS_[e.getType()].call(this,t,e);var i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),v(t,M.CHANGE,this.handleFeatureChange_,this)},e.prototype.willModifyFeatures_=function(t){this.modified_||(this.modified_=!0,this.dispatchEvent(new Af(bf,this.features_,t)))},e.prototype.removeFeature_=function(t){this.removeFeatureSegmentData_(t),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),E(t,M.CHANGE,this.handleFeatureChange_,this)},e.prototype.removeFeatureSegmentData_=function(t){var e=this.rBush_,i=[];e.forEach(function(e){t===e.feature&&i.push(e)});for(var r=i.length-1;r>=0;--r)e.remove(i[r])},e.prototype.setActive=function(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),t.prototype.setActive.call(this,e)},e.prototype.setMap=function(e){this.overlay_.setMap(e),t.prototype.setMap.call(this,e)},e.prototype.getOverlay=function(){return this.overlay_},e.prototype.handleSourceAdd_=function(t){t.feature&&this.features_.push(t.feature)},e.prototype.handleSourceRemove_=function(t){t.feature&&this.features_.remove(t.feature)},e.prototype.handleFeatureAdd_=function(t){this.addFeature_(t.element)},e.prototype.handleFeatureChange_=function(t){if(!this.changingFeature_){var e=t.target;this.removeFeature_(e),this.addFeature_(e)}},e.prototype.handleFeatureRemove_=function(t){var e=t.element;this.removeFeature_(e)},e.prototype.writePointGeometry_=function(t,e){var i=e.getCoordinates(),r={feature:t,geometry:e,segment:[i,i]};this.rBush_.insert(e.getExtent(),r)},e.prototype.writeMultiPointGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r){var o=i[r],s={feature:t,geometry:e,depth:[r],index:r,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},e.prototype.writeLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,geometry:e,index:r,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeMultiLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,geometry:e,depth:[r],index:s,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writePolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,geometry:e,depth:[r],index:s,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writeMultiPolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length;s<a;++s)for(var h=o[s],l=0,u=h.length-1;l<u;++l){var p=h.slice(l,l+2),c={feature:t,geometry:e,depth:[s,r],index:l,segment:p};this.rBush_.insert(Ae(p),c)}},e.prototype.writeCircleGeometry_=function(t,e){var i=e.getCenter(),r={feature:t,geometry:e,index:0,segment:[i,i]},n={feature:t,geometry:e,index:Ff,segment:[i,i]},o=[r,n];r.featureSegments=n.featureSegments=o,this.rBush_.insert(Ke(i),r),this.rBush_.insert(e.getExtent(),n)},e.prototype.writeGeometryCollectionGeometry_=function(t,e){for(var i=e.getGeometriesArray(),r=0;r<i.length;++r)this.SEGMENT_WRITERS_[i[r].getType()].call(this,t,i[r])},e.prototype.createOrUpdateVertexFeature_=function(t){var e=this.vertexFeature_;e?e.getGeometry().setCoordinates(t):(e=new Oa(new Gr(t)),this.vertexFeature_=e,this.overlay_.getSource().addFeature(e));return e},e.prototype.handleEvent=function(e){return!e.pointerEvent||(this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=Q.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(i=!(e.type!=Q.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==Q.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),t.prototype.handleEvent.call(this,e)&&!i);var i},e.prototype.handleDragEvent=function(t){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(t);for(var e=t.coordinate,i=0,r=this.dragSegments_.length;i<r;++i){for(var n=this.dragSegments_[i],o=n[0],s=o.depth,a=o.geometry,h=void 0,l=o.segment,u=n[1];e.length<a.getStride();)e.push(l[u][e.length]);switch(a.getType()){case _i.POINT:h=e,l[0]=l[1]=e;break;case _i.MULTI_POINT:(h=a.getCoordinates())[o.index]=e,l[0]=l[1]=e;break;case _i.LINE_STRING:(h=a.getCoordinates())[o.index+u]=e,l[u]=e;break;case _i.MULTI_LINE_STRING:case _i.POLYGON:(h=a.getCoordinates())[s[0]][o.index+u]=e,l[u]=e;break;case _i.MULTI_POLYGON:(h=a.getCoordinates())[s[1]][s[0]][o.index+u]=e,l[u]=e;break;case _i.CIRCLE:l[0]=l[1]=e,0===o.index?(this.changingFeature_=!0,a.setCenter(e),this.changingFeature_=!1):(this.changingFeature_=!0,a.setRadius(Ie(a.getCenter(),e)),this.changingFeature_=!1)}h&&this.setGeometryCoordinates_(a,h)}this.createOrUpdateVertexFeature_(e)},e.prototype.handleDownEvent=function(t){if(!this.condition_(t))return!1;this.handlePointerAtPixel_(t.pixel,t.map);var e=t.map.getCoordinateFromPixel(t.pixel);this.dragSegments_.length=0,this.modified_=!1;var i=this.vertexFeature_;if(i){var r=[],n=i.getGeometry().getCoordinates(),s=Ae([n]),a=this.rBush_.getInExtent(s),h={};a.sort(Gf);for(var l=0,u=a.length;l<u;++l){var p=a[l],c=p.segment,d=o(p.feature),f=p.depth;if(f&&(d+="-"+f.join("-")),h[d]||(h[d]=new Array(2)),p.geometry.getType()===_i.CIRCLE&&p.index===Ff)Ce(kf(e,p),n)&&!h[d][0]&&(this.dragSegments_.push([p,0]),h[d][0]=p);else if(Ce(c[0],n)&&!h[d][0])this.dragSegments_.push([p,0]),h[d][0]=p;else if(Ce(c[1],n)&&!h[d][1]){if((p.geometry.getType()===_i.LINE_STRING||p.geometry.getType()===_i.MULTI_LINE_STRING)&&h[d][0]&&0===h[d][0].index)continue;this.dragSegments_.push([p,1]),h[d][1]=p}else this.insertVertexCondition_(t)&&o(c)in this.vertexSegments_&&!h[d][0]&&!h[d][1]&&r.push([p,n])}r.length&&this.willModifyFeatures_(t);for(var g=r.length-1;g>=0;--g)this.insertVertex_.apply(this,r[g])}return!!this.vertexFeature_},e.prototype.handleUpEvent=function(t){for(var e=this.dragSegments_.length-1;e>=0;--e){var i=this.dragSegments_[e][0],r=i.geometry;if(r.getType()===_i.CIRCLE){var n=r.getCenter(),o=i.featureSegments[0],s=i.featureSegments[1];o.segment[0]=o.segment[1]=n,s.segment[0]=s.segment[1]=n,this.rBush_.update(Ke(n),o),this.rBush_.update(r.getExtent(),s)}else this.rBush_.update(Ae(i.segment),i)}return this.modified_&&(this.dispatchEvent(new Af(Nf,this.features_,t)),this.modified_=!1),!1},e.prototype.handlePointerMove_=function(t){this.lastPixel_=t.pixel,this.handlePointerAtPixel_(t.pixel,t.map)},e.prototype.handlePointerAtPixel_=function(t,e){var i=e.getCoordinateFromPixel(t),r=Ge(Ke(i),e.getView().getResolution()*this.pixelTolerance_),n=this.rBush_.getInExtent(r);if(n.length>0){n.sort(function(t,e){return Df(i,t)-Df(i,e)});var s=n[0],a=s.segment,h=kf(i,s),l=e.getPixelFromCoordinate(h),u=Ie(t,l);if(u<=this.pixelTolerance_){var p={};if(s.geometry.getType()===_i.CIRCLE&&s.index===Ff)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(h);else{var c=e.getPixelFromCoordinate(a[0]),d=e.getPixelFromCoordinate(a[1]),f=we(l,c),g=we(l,d);u=Math.sqrt(Math.min(f,g)),this.snappedToVertex_=u<=this.pixelTolerance_,this.snappedToVertex_&&(h=f>g?a[1]:a[0]),this.createOrUpdateVertexFeature_(h);for(var _=1,y=n.length;_<y;++_){var v=n[_].segment;if(!(Ce(a[0],v[0])&&Ce(a[1],v[1])||Ce(a[0],v[1])&&Ce(a[1],v[0])))break;p[o(v)]=!0}}return p[o(a)]=!0,void(this.vertexSegments_=p)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)},e.prototype.insertVertex_=function(t,e){for(var i,r=t.segment,n=t.feature,o=t.geometry,s=t.depth,a=t.index;e.length<o.getStride();)e.push(0);switch(o.getType()){case _i.MULTI_LINE_STRING:case _i.POLYGON:(i=o.getCoordinates())[s[0]].splice(a+1,0,e);break;case _i.MULTI_POLYGON:(i=o.getCoordinates())[s[1]][s[0]].splice(a+1,0,e);break;case _i.LINE_STRING:(i=o.getCoordinates()).splice(a+1,0,e);break;default:return}this.setGeometryCoordinates_(o,i);var h=this.rBush_;h.remove(t),this.updateSegmentIndices_(o,a,s,1);var l={segment:[r[0],e],feature:n,geometry:o,depth:s,index:a};h.insert(Ae(l.segment),l),this.dragSegments_.push([l,1]);var u={segment:[e,r[1]],feature:n,geometry:o,depth:s,index:a+1};h.insert(Ae(u.segment),u),this.dragSegments_.push([u,0]),this.ignoreNextSingleClick_=!0},e.prototype.removePoint=function(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=Q.POINTERDRAG){var t=this.lastPointerEvent_;return this.willModifyFeatures_(t),this.removeVertex_(),this.dispatchEvent(new Af(Nf,this.features_,t)),this.modified_=!1,!0}return!1},e.prototype.removeVertex_=function(){var t,e,i,r,n,s,a,h,l,u,p,c=this.dragSegments_,d={},f=!1;for(n=c.length-1;n>=0;--n)p=o((u=(i=c[n])[0]).feature),u.depth&&(p+="-"+u.depth.join("-")),p in d||(d[p]={}),0===i[1]?(d[p].right=u,d[p].index=u.index):1==i[1]&&(d[p].left=u,d[p].index=u.index+1);for(p in d){switch(l=d[p].right,a=d[p].left,(h=(s=d[p].index)-1)<0&&(h=0),t=e=(r=(u=void 0!==a?a:l).geometry).getCoordinates(),f=!1,r.getType()){case _i.MULTI_LINE_STRING:e[u.depth[0]].length>2&&(e[u.depth[0]].splice(s,1),f=!0);break;case _i.LINE_STRING:e.length>2&&(e.splice(s,1),f=!0);break;case _i.MULTI_POLYGON:t=t[u.depth[1]];case _i.POLYGON:(t=t[u.depth[0]]).length>4&&(s==t.length-1&&(s=0),t.splice(s,1),f=!0,0===s&&(t.pop(),t.push(t[0]),h=t.length-1))}if(f){this.setGeometryCoordinates_(r,e);var g=[];if(void 0!==a&&(this.rBush_.remove(a),g.push(a.segment[0])),void 0!==l&&(this.rBush_.remove(l),g.push(l.segment[1])),void 0!==a&&void 0!==l){var _={depth:u.depth,feature:u.feature,geometry:u.geometry,index:h,segment:g};this.rBush_.insert(Ae(_.segment),_)}this.updateSegmentIndices_(r,s,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),c.length=0}}return f},e.prototype.setGeometryCoordinates_=function(t,e){this.changingFeature_=!0,t.setCoordinates(e),this.changingFeature_=!1},e.prototype.updateSegmentIndices_=function(t,e,i,r){this.rBush_.forEachInExtent(t.getExtent(),function(n){n.geometry===t&&(void 0===i||void 0===n.depth||Ut(n.depth,i))&&n.index>e&&(n.index+=r)})},e}(no),jf="addfeatures",Xf=function(t){function e(e,i,r,n){t.call(this,e),this.features=r,this.file=i,this.projection=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function Bf(t){for(var e=t.dataTransfer.files,i=0,r=e.length;i<r;++i){var n=e.item(i),o=new FileReader;o.addEventListener(M.LOAD,this.handleResult_.bind(this,n)),o.readAsText(n)}}function Vf(t){t.stopPropagation(),t.preventDefault(),t.dataTransfer.dropEffect="copy"}var Wf=function(t){function e(e){var i=e||{};t.call(this,{handleEvent:R}),this.formatConstructors_=i.formatConstructors?i.formatConstructors:[],this.projection_=i.projection?Zi(i.projection):null,this.dropListenKeys_=null,this.source_=i.source||null,this.target=i.target?i.target:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleResult_=function(t,e){var i=e.target.result,r=this.getMap(),n=this.projection_;n||(n=r.getView().getProjection());for(var o=this.formatConstructors_,s=[],a=0,h=o.length;a<h;++a){var l=new o[a];if((s=this.tryReadFeatures_(l,i,{featureProjection:n}))&&s.length>0)break}this.source_&&(this.source_.clear(),this.source_.addFeatures(s)),this.dispatchEvent(new Xf(jf,t,s,n))},e.prototype.registerListeners_=function(){var t=this.getMap();if(t){var e=this.target?this.target:t.getViewport();this.dropListenKeys_=[v(e,M.DROP,Bf,this),v(e,M.DRAGENTER,Vf,this),v(e,M.DRAGOVER,Vf,this),v(e,M.DROP,Vf,this)]}},e.prototype.setActive=function(e){t.prototype.setActive.call(this,e),e?this.registerListeners_():this.unregisterListeners_()},e.prototype.setMap=function(e){this.unregisterListeners_(),t.prototype.setMap.call(this,e),this.getActive()&&this.registerListeners_()},e.prototype.tryReadFeatures_=function(t,e,i){try{return t.readFeatures(e,i)}catch(t){return null}},e.prototype.unregisterListeners_=function(){this.dropListenKeys_&&(this.dropListenKeys_.forEach(S),this.dropListenKeys_=null)},e}(jn),Kf="preload",zf="useInterimTilesOnError",Zf=function(t){function e(e){var i=e||{},r=u({},i);delete r.preload,delete r.useInterimTilesOnError,t.call(this,r),this.setPreload(void 0!==i.preload?i.preload:0),this.setUseInterimTilesOnError(void 0===i.useInterimTilesOnError||i.useInterimTilesOnError),this.type=Po.TILE}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getPreload=function(){return this.get(Kf)},e.prototype.setPreload=function(t){this.set(Kf,t)},e.prototype.getUseInterimTilesOnError=function(){return this.get(zf)},e.prototype.setUseInterimTilesOnError=function(t){this.set(zf,t)},e}(On);Zf.prototype.getSource;var Hf=Zf,qf=function(t){function e(e){var i=e||{};t.call(this,i),this.type=Po.IMAGE}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(On);qf.prototype.getSource;var Jf=qf;var Qf=function(t){function e(e){t.call(this,{attributions:e.attributions,wrapX:e.wrapX}),this.resolution=void 0,this.distance=void 0!==e.distance?e.distance:20,this.features=[],this.geometryFunction=e.geometryFunction||function(t){var e=t.getGeometry();return te(e.getType()==_i.POINT,10),e},this.source=e.source,v(this.source,M.CHANGE,this.refresh,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDistance=function(){return this.distance},e.prototype.getSource=function(){return this.source},e.prototype.loadFeatures=function(t,e,i){this.source.loadFeatures(t,e,i),e!==this.resolution&&(this.clear(),this.resolution=e,this.cluster(),this.addFeatures(this.features))},e.prototype.setDistance=function(t){this.distance=t,this.refresh()},e.prototype.refresh=function(){this.clear(),this.cluster(),this.addFeatures(this.features),t.prototype.refresh.call(this)},e.prototype.cluster=function(){if(void 0!==this.resolution){this.features.length=0;for(var t=[1/0,1/0,-1/0,-1/0],e=this.distance*this.resolution,i=this.source.getFeatures(),r={},n=0,s=i.length;n<s;n++){var a=i[n];if(!(o(a)in r)){var h=this.geometryFunction(a);if(h){Ke(h.getCoordinates(),t),Ge(t,e,t);var l=this.source.getFeaturesInExtent(t);l=l.filter(function(t){var e=o(t);return!(e in r)&&(r[e]=!0,!0)}),this.features.push(this.createCluster(l))}}}}},e.prototype.createCluster=function(t){for(var e=[0,0],i=t.length-1;i>=0;--i){var r=this.geometryFunction(t[i]);r?Se(e,r.getCoordinates()):t.splice(i,1)}xe(e,1/t.length);var n=new Oa(new Gr(e));return n.set("features",t),n},e}(ff),$f=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,Oo.IDLE),this.src_=n,this.image_=new Image,null!==o&&(this.image_.crossOrigin=o),this.imageListenerKeys_=null,this.state=Oo.IDLE,this.imageLoadFunction_=s}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getImage=function(){return this.image_},e.prototype.handleImageError_=function(){this.state=Oo.ERROR,this.unlistenImage_(),this.changed()},e.prototype.handleImageLoad_=function(){void 0===this.resolution&&(this.resolution=ai(this.extent)/this.image_.height),this.state=Oo.LOADED,this.unlistenImage_(),this.changed()},e.prototype.load=function(){this.state!=Oo.IDLE&&this.state!=Oo.ERROR||(this.state=Oo.LOADING,this.changed(),this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)],this.imageLoadFunction_(this,this.src_))},e.prototype.setImage=function(t){this.image_=t},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(Io);function tg(t,e,i,r){var n=ir(i,e,t),o=Hi(e,r,i),s=e.getMetersPerUnit();void 0!==s&&(o*=s);var a=t.getMetersPerUnit();void 0!==a&&(o/=a);var h=t.getExtent();if(!h||Ye(h,n)){var l=Hi(t,o,n)/o;isFinite(l)&&l>0&&(o/=l)}return o}function eg(t,e,i,r){var n=i-t,o=r-e,s=Math.sqrt(n*n+o*o);return[Math.round(i+n/s),Math.round(r+o/s)]}function ig(t,e,i,r,n,o,s,a,h,l,u){var p=on(Math.round(i*t),Math.round(i*e));if(0===h.length)return p.canvas;p.scale(i,i);var c=[1/0,1/0,-1/0,-1/0];h.forEach(function(t,e,i){He(c,t.extent)});var d=pi(c),f=ai(c),g=on(Math.round(i*d/r),Math.round(i*f/r)),_=i/r;h.forEach(function(t,e,i){var r=t.extent[0]-c[0],n=-(t.extent[3]-c[3]),o=pi(t.extent),s=ai(t.extent);g.drawImage(t.image,l,l,t.image.width-2*l,t.image.height-2*l,r*_,n*_,o*_,s*_)});var y=li(s);return a.getTriangles().forEach(function(t,e,n){var s=t.source,a=t.target,h=s[0][0],l=s[0][1],u=s[1][0],d=s[1][1],f=s[2][0],_=s[2][1],v=(a[0][0]-y[0])/o,m=-(a[0][1]-y[1])/o,E=(a[1][0]-y[0])/o,S=-(a[1][1]-y[1])/o,T=(a[2][0]-y[0])/o,C=-(a[2][1]-y[1])/o,R=h,x=l;h=0,l=0;var w=function(t){for(var e=t.length,i=0;i<e;i++){for(var r=i,n=Math.abs(t[i][i]),o=i+1;o<e;o++){var s=Math.abs(t[o][i]);s>n&&(n=s,r=o)}if(0===n)return null;var a=t[r];t[r]=t[i],t[i]=a;for(var h=i+1;h<e;h++)for(var l=-t[h][i]/t[i][i],u=i;u<e+1;u++)i==u?t[h][u]=0:t[h][u]+=l*t[i][u]}for(var p=new Array(e),c=e-1;c>=0;c--){p[c]=t[c][e]/t[c][c];for(var d=c-1;d>=0;d--)t[d][e]-=t[d][c]*p[c]}return p}([[u-=R,d-=x,0,0,E-v],[f-=R,_-=x,0,0,T-v],[0,0,u,d,S-m],[0,0,f,_,C-m]]);if(w){p.save(),p.beginPath();var I=(v+E+T)/3,O=(m+S+C)/3,L=eg(I,O,v,m),P=eg(I,O,E,S),M=eg(I,O,T,C);p.moveTo(P[0],P[1]),p.lineTo(L[0],L[1]),p.lineTo(M[0],M[1]),p.clip(),p.transform(w[0],w[2],w[1],w[3],v,m),p.translate(c[0]-R,c[3]-x),p.scale(r/i,-r/i),p.drawImage(g.canvas,0,0),p.restore()}}),u&&(p.save(),p.strokeStyle="black",p.lineWidth=1,a.getTriangles().forEach(function(t,e,i){var r=t.target,n=(r[0][0]-y[0])/o,s=-(r[0][1]-y[1])/o,a=(r[1][0]-y[0])/o,h=-(r[1][1]-y[1])/o,l=(r[2][0]-y[0])/o,u=-(r[2][1]-y[1])/o;p.beginPath(),p.moveTo(a,h),p.lineTo(n,s),p.lineTo(l,u),p.closePath(),p.stroke()}),p.restore()),p.canvas}var rg=function(t,e,i,r,n){this.sourceProj_=t,this.targetProj_=e;var o={},s=er(this.targetProj_,this.sourceProj_);this.transformInv_=function(t){var e=t[0]+"/"+t[1];return o[e]||(o[e]=s(t)),o[e]},this.maxSourceExtent_=r,this.errorThresholdSquared_=n*n,this.triangles_=[],this.wrapsXInSource_=!1,this.canWrapXInSource_=this.sourceProj_.canWrapX()&&!!r&&!!this.sourceProj_.getExtent()&&pi(r)==pi(this.sourceProj_.getExtent()),this.sourceWorldWidth_=this.sourceProj_.getExtent()?pi(this.sourceProj_.getExtent()):null,this.targetWorldWidth_=this.targetProj_.getExtent()?pi(this.targetProj_.getExtent()):null;var a=li(i),h=ui(i),l=ri(i),u=ii(i),p=this.transformInv_(a),c=this.transformInv_(h),d=this.transformInv_(l),f=this.transformInv_(u);if(this.addQuad_(a,h,l,u,p,c,d,f,10),this.wrapsXInSource_){var g=1/0;this.triangles_.forEach(function(t,e,i){g=Math.min(g,t.source[0][0],t.source[1][0],t.source[2][0])}),this.triangles_.forEach(function(t){if(Math.max(t.source[0][0],t.source[1][0],t.source[2][0])-g>this.sourceWorldWidth_/2){var e=[[t.source[0][0],t.source[0][1]],[t.source[1][0],t.source[1][1]],[t.source[2][0],t.source[2][1]]];e[0][0]-g>this.sourceWorldWidth_/2&&(e[0][0]-=this.sourceWorldWidth_),e[1][0]-g>this.sourceWorldWidth_/2&&(e[1][0]-=this.sourceWorldWidth_),e[2][0]-g>this.sourceWorldWidth_/2&&(e[2][0]-=this.sourceWorldWidth_);var i=Math.min(e[0][0],e[1][0],e[2][0]);Math.max(e[0][0],e[1][0],e[2][0])-i<this.sourceWorldWidth_/2&&(t.source=e)}}.bind(this))}o={}};rg.prototype.addTriangle_=function(t,e,i,r,n,o){this.triangles_.push({source:[r,n,o],target:[t,e,i]})},rg.prototype.addQuad_=function(t,e,i,r,n,o,s,a,h){var l=Ae([n,o,s,a]),u=this.sourceWorldWidth_?pi(l)/this.sourceWorldWidth_:null,p=this.sourceWorldWidth_,c=this.sourceProj_.canWrapX()&&u>.5&&u<1,d=!1;if(h>0){if(this.targetProj_.isGlobal()&&this.targetWorldWidth_)d=pi(Ae([t,e,i,r]))/this.targetWorldWidth_>.25||d;!c&&this.sourceProj_.isGlobal()&&u&&(d=u>.25||d)}if(d||!this.maxSourceExtent_||ci(l,this.maxSourceExtent_)){if(!(d||isFinite(n[0])&&isFinite(n[1])&&isFinite(o[0])&&isFinite(o[1])&&isFinite(s[0])&&isFinite(s[1])&&isFinite(a[0])&&isFinite(a[1]))){if(!(h>0))return;d=!0}if(h>0){if(!d){var f,g=[(t[0]+i[0])/2,(t[1]+i[1])/2],_=this.transformInv_(g);if(c)f=(ue(n[0],p)+ue(s[0],p))/2-ue(_[0],p);else f=(n[0]+s[0])/2-_[0];var y=(n[1]+s[1])/2-_[1];d=f*f+y*y>this.errorThresholdSquared_}if(d){if(Math.abs(t[0]-i[0])<=Math.abs(t[1]-i[1])){var v=[(e[0]+i[0])/2,(e[1]+i[1])/2],m=this.transformInv_(v),E=[(r[0]+t[0])/2,(r[1]+t[1])/2],S=this.transformInv_(E);this.addQuad_(t,e,v,E,n,o,m,S,h-1),this.addQuad_(E,v,i,r,S,m,s,a,h-1)}else{var T=[(t[0]+e[0])/2,(t[1]+e[1])/2],C=this.transformInv_(T),R=[(i[0]+r[0])/2,(i[1]+r[1])/2],x=this.transformInv_(R);this.addQuad_(t,T,R,r,n,C,x,a,h-1),this.addQuad_(T,e,i,R,C,o,s,x,h-1)}return}}if(c){if(!this.canWrapXInSource_)return;this.wrapsXInSource_=!0}this.addTriangle_(t,i,r,n,s,a),this.addTriangle_(t,e,i,n,o,s)}},rg.prototype.calculateSourceExtent=function(){var t=[1/0,1/0,-1/0,-1/0];return this.triangles_.forEach(function(e,i,r){var n=e.source;qe(t,n[0]),qe(t,n[1]),qe(t,n[2])}),t},rg.prototype.getTriangles=function(){return this.triangles_};var ng=rg,og=function(t){function e(e,i,r,n,o,s){var a=e.getExtent(),h=i.getExtent(),l=h?hi(r,h):r,u=tg(e,i,ni(l),n),p=new ng(e,i,l,a,u*wo),c=s(p.calculateSourceExtent(),u,o),d=Oo.LOADED;c&&(d=Oo.IDLE);var f=c?c.getPixelRatio():1;t.call(this,r,n,f,d),this.targetProj_=i,this.maxSourceExtent_=a,this.triangulation_=p,this.targetResolution_=n,this.targetExtent_=r,this.sourceImage_=c,this.sourcePixelRatio_=f,this.canvas_=null,this.sourceListenerKey_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==Oo.LOADING&&this.unlistenSource_(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.canvas_},e.prototype.getProjection=function(){return this.targetProj_},e.prototype.reproject_=function(){var t=this.sourceImage_.getState();if(t==Oo.LOADED){var e=pi(this.targetExtent_)/this.targetResolution_,i=ai(this.targetExtent_)/this.targetResolution_;this.canvas_=ig(e,i,this.sourcePixelRatio_,this.sourceImage_.getResolution(),this.maxSourceExtent_,this.targetResolution_,this.targetExtent_,this.triangulation_,[{extent:this.sourceImage_.getExtent(),image:this.sourceImage_.getImage()}],0)}this.state=t,this.changed()},e.prototype.load=function(){if(this.state==Oo.IDLE){this.state=Oo.LOADING,this.changed();var t=this.sourceImage_.getState();t==Oo.LOADED||t==Oo.ERROR?this.reproject_():(this.sourceListenerKey_=v(this.sourceImage_,M.CHANGE,function(t){var e=this.sourceImage_.getState();e!=Oo.LOADED&&e!=Oo.ERROR||(this.unlistenSource_(),this.reproject_())},this),this.sourceImage_.load())}},e.prototype.unlistenSource_=function(){S(this.sourceListenerKey_),this.sourceListenerKey_=null},e}(Io),sg="imageloadstart",ag="imageloadend",hg="imageloaderror",lg=function(t){function e(e,i){t.call(this,e),this.image=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function ug(t,e){t.getImage().src=e}var pg=function(t){function e(e){t.call(this,{attributions:e.attributions,projection:e.projection,state:e.state}),this.resolutions_=void 0!==e.resolutions?e.resolutions:null,this.reprojectedImage_=null,this.reprojectedRevision_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getResolutions=function(){return this.resolutions_},e.prototype.findNearestResolution=function(t){if(this.resolutions_){var e=Gt(this.resolutions_,t,0);t=this.resolutions_[e]}return t},e.prototype.getImage=function(t,e,i,r){var n=this.getProjection();if(n&&r&&!$i(n,r)){if(this.reprojectedImage_){if(this.reprojectedRevision_==this.getRevision()&&$i(this.reprojectedImage_.getProjection(),r)&&this.reprojectedImage_.getResolution()==e&&Ze(this.reprojectedImage_.getExtent(),t))return this.reprojectedImage_;this.reprojectedImage_.dispose(),this.reprojectedImage_=null}return this.reprojectedImage_=new og(n,r,t,e,i,function(t,e,i){return this.getImageInternal(t,e,i,n)}.bind(this)),this.reprojectedRevision_=this.getRevision(),this.reprojectedImage_}return n&&(r=n),this.getImageInternal(t,e,i,r)},e.prototype.getImageInternal=function(t,e,i,n){return r()},e.prototype.handleImageChange=function(t){var e=t.target;switch(e.getState()){case Oo.LOADING:this.loading=!0,this.dispatchEvent(new lg(sg,e));break;case Oo.LOADED:this.loading=!1,this.dispatchEvent(new lg(ag,e));break;case Oo.ERROR:this.loading=!1,this.dispatchEvent(new lg(hg,e))}},e}(lf),cg="carmentaserver",dg="geoserver",fg="mapserver",gg="qgis";function _g(t,e){var i=[];Object.keys(e).forEach(function(t){null!==e[t]&&void 0!==e[t]&&i.push(t+"="+encodeURIComponent(e[t]))});var r=i.join("&");return(t=-1===(t=t.replace(/[?&]$/,"")).indexOf("?")?t+"?":t+"&")+r}var yg=[101,101],vg=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:i.projection,resolutions:i.resolutions}),this.crossOrigin_=void 0!==i.crossOrigin?i.crossOrigin:null,this.url_=i.url,this.imageLoadFunction_=void 0!==i.imageLoadFunction?i.imageLoadFunction:ug,this.params_=i.params||{},this.v13_=!0,this.updateV13_(),this.serverType_=i.serverType,this.hidpi_=void 0===i.hidpi||i.hidpi,this.image_=null,this.imageSize_=[0,0],this.renderedRevision_=0,this.ratio_=void 0!==i.ratio?i.ratio:1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getGetFeatureInfoUrl=function(t,e,i,r){if(void 0!==this.url_){var n=Zi(i),o=this.getProjection();o&&o!==n&&(e=tg(o,n,t,e),t=ir(t,n,o));var s=si(t,e,0,yg),a={SERVICE:"WMS",VERSION:"1.3.0",REQUEST:"GetFeatureInfo",FORMAT:"image/png",TRANSPARENT:!0,QUERY_LAYERS:this.params_.LAYERS};u(a,this.params_,r);var h=Math.floor((t[0]-s[0])/e),l=Math.floor((s[3]-t[1])/e);return a[this.v13_?"I":"X"]=h,a[this.v13_?"J":"Y"]=l,this.getRequestUrl_(s,yg,1,o||n,a)}},e.prototype.getParams=function(){return this.params_},e.prototype.getImageInternal=function(t,e,i,r){if(void 0===this.url_)return null;e=this.findNearestResolution(e),1==i||this.hidpi_&&void 0!==this.serverType_||(i=1);var n=e/i,o=ni(t),s=si(o,n,0,[Math.ceil(pi(t)/n),Math.ceil(ai(t)/n)]),a=si(o,n,0,[Math.ceil(this.ratio_*pi(t)/n),Math.ceil(this.ratio_*ai(t)/n)]),h=this.image_;if(h&&this.renderedRevision_==this.getRevision()&&h.getResolution()==e&&h.getPixelRatio()==i&&Ue(h.getExtent(),s))return h;var l={SERVICE:"WMS",VERSION:"1.3.0",REQUEST:"GetMap",FORMAT:"image/png",TRANSPARENT:!0};u(l,this.params_),this.imageSize_[0]=Math.round(pi(a)/n),this.imageSize_[1]=Math.round(ai(a)/n);var p=this.getRequestUrl_(a,this.imageSize_,i,r,l);return this.image_=new $f(a,e,i,p,this.crossOrigin_,this.imageLoadFunction_),this.renderedRevision_=this.getRevision(),v(this.image_,M.CHANGE,this.handleImageChange,this),this.image_},e.prototype.getImageLoadFunction=function(){return this.imageLoadFunction_},e.prototype.getRequestUrl_=function(t,e,i,r,n){if(te(void 0!==this.url_,9),n[this.v13_?"CRS":"SRS"]=r.getCode(),"STYLES"in this.params_||(n.STYLES=""),1!=i)switch(this.serverType_){case dg:var o=90*i+.5|0;"FORMAT_OPTIONS"in n?n.FORMAT_OPTIONS+=";dpi:"+o:n.FORMAT_OPTIONS="dpi:"+o;break;case fg:n.MAP_RESOLUTION=90*i;break;case cg:case gg:n.DPI=90*i;break;default:te(!1,8)}n.WIDTH=e[0],n.HEIGHT=e[1];var s,a=r.getAxisOrientation();return s=this.v13_&&"ne"==a.substr(0,2)?[t[1],t[0],t[3],t[2]]:t,n.BBOX=s.join(","),_g(this.url_,n)},e.prototype.getUrl=function(){return this.url_},e.prototype.setImageLoadFunction=function(t){this.image_=null,this.imageLoadFunction_=t,this.changed()},e.prototype.setUrl=function(t){t!=this.url_&&(this.url_=t,this.image_=null,this.changed())},e.prototype.updateParams=function(t){u(this.params_,t),this.updateV13_(),this.image_=null,this.changed()},e.prototype.updateV13_=function(){var t=this.params_.VERSION||"1.3.0";this.v13_=function(t,e){for(var i=(""+t).split("."),r=(""+e).split("."),n=0;n<Math.max(i.length,r.length);n++){var o=parseInt(i[n]||"0",10),s=parseInt(r[n]||"0",10);if(o>s)return 1;if(s>o)return-1}return 0}(t,"1.3")>=0},e}(pg);function mg(t,e,i,r){return void 0!==r?(r[0]=t,r[1]=e,r[2]=i,r):[t,e,i]}function Eg(t,e,i){return t+"/"+e+"/"+i}function Sg(t){return Eg(t[0],t[1],t[2])}function Tg(t,e){var i=/\{z\}/g,r=/\{x\}/g,n=/\{y\}/g,o=/\{-y\}/g;return function(s,a,h){return s?t.replace(i,s[0].toString()).replace(r,s[1].toString()).replace(n,function(){return(-s[2]-1).toString()}).replace(o,function(){var t=s[0],i=e.getFullTileRange(t);return te(i,55),(i.getHeight()+s[2]).toString()}):void 0}}function Cg(t){return 1===t.length?t[0]:function(e,i,r){if(e){var n=ue(function(t){return(t[1]<<t[0])+t[2]}(e),t.length);return t[n](e,i,r)}}}function Rg(t,e,i){}function xg(t){var e=[],i=/\{([a-z])-([a-z])\}/.exec(t);if(i){var r,n=i[1].charCodeAt(0),o=i[2].charCodeAt(0);for(r=n;r<=o;++r)e.push(t.replace(i[0],String.fromCharCode(r)));return e}if(i=i=/\{(\d+)-(\d+)\}/.exec(t)){for(var s=parseInt(i[2],10),a=parseInt(i[1],10);a<=s;a++)e.push(t.replace(i[0],a.toString()));return e}return e.push(t),e}var wg=function(t){function e(e,i,r){t.call(this);var n=r||{};this.tileCoord=e,this.state=i,this.interimTile=null,this.key="",this.transition_=void 0===n.transition?250:n.transition,this.transitionStarts_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){this.dispatchEvent(M.CHANGE)},e.prototype.getKey=function(){return this.key+"/"+this.tileCoord},e.prototype.getInterimTile=function(){if(!this.interimTile)return this;var t=this.interimTile;do{if(t.getState()==$t.LOADED)return t;t=t.interimTile}while(t);return this},e.prototype.refreshInterimChain=function(){if(this.interimTile){var t=this.interimTile,e=this;do{if(t.getState()==$t.LOADED){t.interimTile=null;break}t.getState()==$t.LOADING?e=t:t.getState()==$t.IDLE?e.interimTile=t.interimTile:e=t,t=e.interimTile}while(t)}},e.prototype.getTileCoord=function(){return this.tileCoord},e.prototype.getState=function(){return this.state},e.prototype.setState=function(t){this.state=t,this.changed()},e.prototype.load=function(){},e.prototype.getAlpha=function(t,e){if(!this.transition_)return 1;var i=this.transitionStarts_[t];if(i){if(-1===i)return 1}else i=e,this.transitionStarts_[t]=i;var r=e-i+1e3/60;return r>=this.transition_?1:Le(r/this.transition_)},e.prototype.inTransition=function(t){return!!this.transition_&&-1!==this.transitionStarts_[t]},e.prototype.endTransition=function(t){this.transition_&&(this.transitionStarts_[t]=-1)},e}(P);function Ig(){var t=on(1,1);return t.fillStyle="rgba(0,0,0,0)",t.fillRect(0,0,1,1),t.canvas}var Og=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,s),this.crossOrigin_=n,this.src_=r,this.image_=new Image,null!==n&&(this.image_.crossOrigin=n),this.imageListenerKeys_=null,this.tileLoadFunction_=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==$t.LOADING&&(this.unlistenImage_(),this.image_=Ig()),this.interimTile&&this.interimTile.dispose(),this.state=$t.ABORT,this.changed(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.image_},e.prototype.getKey=function(){return this.src_},e.prototype.handleImageError_=function(){this.state=$t.ERROR,this.unlistenImage_(),this.image_=Ig(),this.changed()},e.prototype.handleImageLoad_=function(){var t=this.image_;t.naturalWidth&&t.naturalHeight?this.state=$t.LOADED:this.state=$t.EMPTY,this.unlistenImage_(),this.changed()},e.prototype.load=function(){this.state==$t.ERROR&&(this.state=$t.IDLE,this.image_=new Image,null!==this.crossOrigin_&&(this.image_.crossOrigin=this.crossOrigin_)),this.state==$t.IDLE&&(this.state=$t.LOADING,this.changed(),this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)],this.tileLoadFunction_(this,this.src_))},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(wg),Lg=function(t){function e(e){t.call(this,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.expireCache=function(t){for(;this.canExpireCache();){var e=this.peekLast(),i=e.tileCoord[0].toString();if(i in t&&t[i].contains(e.tileCoord))break;this.pop().dispose()}},e.prototype.pruneExceptNewestZ=function(){if(0!==this.getCount()){var t=function(t){return t.split("/").map(Number)}(this.peekFirstKey())[0];this.forEach(function(e){e.tileCoord[0]!==t&&(this.remove(Sg(e.tileCoord)),e.dispose())},this)}},e}(bo),Pg=function(t){function e(e,i,r,n,o,s,a,h,l,u,p){t.call(this,o,$t.IDLE),this.renderEdges_=void 0!==p&&p,this.pixelRatio_=a,this.gutter_=h,this.canvas_=null,this.sourceTileGrid_=i,this.targetTileGrid_=n,this.wrappedTileCoord_=s||o,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;var c=n.getTileCoordExtent(this.wrappedTileCoord_),d=this.targetTileGrid_.getExtent(),f=this.sourceTileGrid_.getExtent(),g=d?hi(c,d):c;if(0!==ei(g)){var _=e.getExtent();_&&(f=f?hi(f,_):_);var y=n.getResolution(this.wrappedTileCoord_[0]),v=tg(e,r,ni(g),y);if(!isFinite(v)||v<=0)this.state=$t.EMPTY;else{var m=void 0!==u?u:wo;if(this.triangulation_=new ng(e,r,g,f,v*m),0!==this.triangulation_.getTriangles().length){this.sourceZ_=i.getZForResolution(v);var E=this.triangulation_.calculateSourceExtent();if(f&&(e.canWrapX()?(E[1]=oe(E[1],f[1],f[3]),E[3]=oe(E[3],f[1],f[3])):E=hi(E,f)),ei(E)){for(var S=i.getTileRangeForExtentAndZ(E,this.sourceZ_),T=S.minX;T<=S.maxX;T++)for(var C=S.minY;C<=S.maxY;C++){var R=l(this.sourceZ_,T,C,a);R&&this.sourceTiles_.push(R)}0===this.sourceTiles_.length&&(this.state=$t.EMPTY)}else this.state=$t.EMPTY}else this.state=$t.EMPTY}}else this.state=$t.EMPTY}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==$t.LOADING&&this.unlistenSources_(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.canvas_},e.prototype.reproject_=function(){var t=[];if(this.sourceTiles_.forEach(function(e,i,r){e&&e.getState()==$t.LOADED&&t.push({extent:this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),image:e.getImage()})}.bind(this)),this.sourceTiles_.length=0,0===t.length)this.state=$t.ERROR;else{var e=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(e),r="number"==typeof i?i:i[0],n="number"==typeof i?i:i[1],o=this.targetTileGrid_.getResolution(e),s=this.sourceTileGrid_.getResolution(this.sourceZ_),a=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=ig(r,n,this.pixelRatio_,s,this.sourceTileGrid_.getExtent(),o,a,this.triangulation_,t,this.gutter_,this.renderEdges_),this.state=$t.LOADED}this.changed()},e.prototype.load=function(){if(this.state==$t.IDLE){this.state=$t.LOADING,this.changed();var t=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(function(e,i,r){var n=e.getState();if(n==$t.IDLE||n==$t.LOADING){t++;var o=v(e,M.CHANGE,function(i){var r=e.getState();r!=$t.LOADED&&r!=$t.ERROR&&r!=$t.EMPTY||(S(o),0===--t&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(o)}}.bind(this)),this.sourceTiles_.forEach(function(t,e,i){t.getState()==$t.IDLE&&t.load()}),0===t&&setTimeout(this.reproject_.bind(this),0)}},e.prototype.unlistenSources_=function(){this.sourcesListenerKeys_.forEach(S),this.sourcesListenerKeys_=null},e}(wg),Mg=[0,0,0],Fg=function(t){var e,i,r,n;if(this.minZoom=void 0!==t.minZoom?t.minZoom:0,this.resolutions_=t.resolutions,te((e=this.resolutions_,i=!0,r=function(t,e){return e-t}||Nt,e.every(function(t,n){if(0===n)return!0;var o=r(e[n-1],t);return!(o>0||i&&0===o)})),17),!t.origins)for(var o=0,s=this.resolutions_.length-1;o<s;++o)if(n){if(this.resolutions_[o]/this.resolutions_[o+1]!==n){n=void 0;break}}else n=this.resolutions_[o]/this.resolutions_[o+1];this.zoomFactor_=n,this.maxZoom=this.resolutions_.length-1,this.origin_=void 0!==t.origin?t.origin:null,this.origins_=null,void 0!==t.origins&&(this.origins_=t.origins,te(this.origins_.length==this.resolutions_.length,20));var a=t.extent;void 0===a||this.origin_||this.origins_||(this.origin_=li(a)),te(!this.origin_&&this.origins_||this.origin_&&!this.origins_,18),this.tileSizes_=null,void 0!==t.tileSizes&&(this.tileSizes_=t.tileSizes,te(this.tileSizes_.length==this.resolutions_.length,19)),this.tileSize_=void 0!==t.tileSize?t.tileSize:this.tileSizes_?null:ne,te(!this.tileSize_&&this.tileSizes_||this.tileSize_&&!this.tileSizes_,22),this.extent_=void 0!==a?a:null,this.fullTileRanges_=null,this.tmpSize_=[0,0],void 0!==t.sizes?this.fullTileRanges_=t.sizes.map(function(t,e){return new Ss(Math.min(0,t[0]),Math.max(t[0]-1,-1),Math.min(0,t[1]),Math.max(t[1]-1,-1))},this):a&&this.calculateTileRanges_(a)};Fg.prototype.forEachTileCoord=function(t,e,i){for(var r=this.getTileRangeForExtentAndZ(t,e),n=r.minX,o=r.maxX;n<=o;++n)for(var s=r.minY,a=r.maxY;s<=a;++s)i([e,n,s])},Fg.prototype.forEachTileCoordParentTileRange=function(t,e,i,r,n){var o,s,a,h=null,l=t[0]-1;for(2===this.zoomFactor_?(s=t[1],a=t[2]):h=this.getTileCoordExtent(t,n);l>=this.minZoom;){if(o=2===this.zoomFactor_?Es(s=Math.floor(s/2),s,a=Math.floor(a/2),a,r):this.getTileRangeForExtentAndZ(h,l,r),e.call(i,l,o))return!0;--l}return!1},Fg.prototype.getExtent=function(){return this.extent_},Fg.prototype.getMaxZoom=function(){return this.maxZoom},Fg.prototype.getMinZoom=function(){return this.minZoom},Fg.prototype.getOrigin=function(t){return this.origin_?this.origin_:this.origins_[t]},Fg.prototype.getResolution=function(t){return this.resolutions_[t]},Fg.prototype.getResolutions=function(){return this.resolutions_},Fg.prototype.getTileCoordChildTileRange=function(t,e,i){if(t[0]<this.maxZoom){if(2===this.zoomFactor_){var r=2*t[1],n=2*t[2];return Es(r,r+1,n,n+1,e)}var o=this.getTileCoordExtent(t,i);return this.getTileRangeForExtentAndZ(o,t[0]+1,e)}return null},Fg.prototype.getTileRangeExtent=function(t,e,i){var r=this.getOrigin(t),n=this.getResolution(t),o=_n(this.getTileSize(t),this.tmpSize_),s=r[0]+e.minX*o[0]*n,a=r[0]+(e.maxX+1)*o[0]*n;return Ve(s,r[1]+e.minY*o[1]*n,a,r[1]+(e.maxY+1)*o[1]*n,i)},Fg.prototype.getTileRangeForExtentAndZ=function(t,e,i){var r=Mg;this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,r);var n=r[1],o=r[2];return this.getTileCoordForXYAndZ_(t[2],t[3],e,!0,r),Es(n,r[1],o,r[2],i)},Fg.prototype.getTileCoordCenter=function(t){var e=this.getOrigin(t[0]),i=this.getResolution(t[0]),r=_n(this.getTileSize(t[0]),this.tmpSize_);return[e[0]+(t[1]+.5)*r[0]*i,e[1]+(t[2]+.5)*r[1]*i]},Fg.prototype.getTileCoordExtent=function(t,e){var i=this.getOrigin(t[0]),r=this.getResolution(t[0]),n=_n(this.getTileSize(t[0]),this.tmpSize_),o=i[0]+t[1]*n[0]*r,s=i[1]+t[2]*n[1]*r;return Ve(o,s,o+n[0]*r,s+n[1]*r,e)},Fg.prototype.getTileCoordForCoordAndResolution=function(t,e,i){return this.getTileCoordForXYAndResolution_(t[0],t[1],e,!1,i)},Fg.prototype.getTileCoordForXYAndResolution_=function(t,e,i,r,n){var o=this.getZForResolution(i),s=i/this.getResolution(o),a=this.getOrigin(o),h=_n(this.getTileSize(o),this.tmpSize_),l=r?.5:0,u=r?0:.5,p=Math.floor((t-a[0])/i+l),c=Math.floor((e-a[1])/i+u),d=s*p/h[0],f=s*c/h[1];return r?(d=Math.ceil(d)-1,f=Math.ceil(f)-1):(d=Math.floor(d),f=Math.floor(f)),mg(o,d,f,n)},Fg.prototype.getTileCoordForXYAndZ_=function(t,e,i,r,n){var o=this.getOrigin(i),s=this.getResolution(i),a=_n(this.getTileSize(i),this.tmpSize_),h=r?.5:0,l=r?0:.5,u=Math.floor((t-o[0])/s+h),p=Math.floor((e-o[1])/s+l),c=u/a[0],d=p/a[1];return r?(c=Math.ceil(c)-1,d=Math.ceil(d)-1):(c=Math.floor(c),d=Math.floor(d)),mg(i,c,d,n)},Fg.prototype.getTileCoordForCoordAndZ=function(t,e,i){return this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,i)},Fg.prototype.getTileCoordResolution=function(t){return this.resolutions_[t[0]]},Fg.prototype.getTileSize=function(t){return this.tileSize_?this.tileSize_:this.tileSizes_[t]},Fg.prototype.getFullTileRange=function(t){return this.fullTileRanges_?this.fullTileRanges_[t]:null},Fg.prototype.getZForResolution=function(t,e){return oe(Gt(this.resolutions_,t,e||0),this.minZoom,this.maxZoom)},Fg.prototype.calculateTileRanges_=function(t){for(var e=this.resolutions_.length,i=new Array(e),r=this.minZoom;r<e;++r)i[r]=this.getTileRangeForExtentAndZ(t,r);this.fullTileRanges_=i};var bg=Fg;function Ng(t){var e=t.getDefaultTileGrid();return e||(e=function(t,e,i,r){return function(t,e,i,r){var n=void 0!==r?r:be.TOP_LEFT,o=Ag(t,e,i);return new bg({extent:t,origin:oi(t,n),resolutions:o,tileSize:i})}(Gg(t),e,i,r)}(t),t.setDefaultTileGrid(e)),e}function Ag(t,e,i){for(var r=void 0!==e?e:re,n=ai(t),o=pi(t),s=_n(void 0!==i?i:ne),a=Math.max(o/s[0],n/s[1]),h=r+1,l=new Array(h),u=0;u<h;++u)l[u]=a/Math.pow(2,u);return l}function Gg(t){var e=(t=Zi(t)).getExtent();if(!e){var i=180*Ti[Ci.DEGREES]/t.getMetersPerUnit();e=Ve(-i,-i,i,i)}return e}var Dg=function(t){function e(e){t.call(this,{attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,projection:e.projection,state:e.state,wrapX:e.wrapX}),this.opaque_=void 0!==e.opaque&&e.opaque,this.tilePixelRatio_=void 0!==e.tilePixelRatio?e.tilePixelRatio:1,this.tileGrid=void 0!==e.tileGrid?e.tileGrid:null,this.tileCache=new Lg(e.cacheSize),this.tmpSize=[0,0],this.key_=e.key||"",this.tileOptions={transition:e.transition}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){return this.tileCache.canExpireCache()},e.prototype.expireCache=function(t,e){var i=this.getTileCacheForProjection(t);i&&i.expireCache(e)},e.prototype.forEachLoadedTile=function(t,e,i,r){var n=this.getTileCacheForProjection(t);if(!n)return!1;for(var o,s,a,h=!0,l=i.minX;l<=i.maxX;++l)for(var u=i.minY;u<=i.maxY;++u)s=Eg(e,l,u),a=!1,n.containsKey(s)&&(a=(o=n.get(s)).getState()===$t.LOADED)&&(a=!1!==r(o)),a||(h=!1);return h},e.prototype.getGutterForProjection=function(t){return 0},e.prototype.getKey=function(){return this.key_},e.prototype.setKey=function(t){this.key_!==t&&(this.key_=t,this.changed())},e.prototype.getOpaque=function(t){return this.opaque_},e.prototype.getResolutions=function(){return this.tileGrid.getResolutions()},e.prototype.getTile=function(t,e,i,n,o){return r()},e.prototype.getTileGrid=function(){return this.tileGrid},e.prototype.getTileGridForProjection=function(t){return this.tileGrid?this.tileGrid:Ng(t)},e.prototype.getTileCacheForProjection=function(t){var e=this.getProjection();return e&&!$i(e,t)?null:this.tileCache},e.prototype.getTilePixelRatio=function(t){return this.tilePixelRatio_},e.prototype.getTilePixelSize=function(t,e,i){var r,n,o,s=this.getTileGridForProjection(i),a=this.getTilePixelRatio(e),h=_n(s.getTileSize(t),this.tmpSize);return 1==a?h:(r=h,n=a,void 0===(o=this.tmpSize)&&(o=[0,0]),o[0]=r[0]*n+.5|0,o[1]=r[1]*n+.5|0,o)},e.prototype.getTileCoordForTileUrlFunction=function(t,e){var i=void 0!==e?e:this.getProjection(),r=this.getTileGridForProjection(i);return this.getWrapX()&&i.isGlobal()&&(t=function(t,e,i){var r=e[0],n=t.getTileCoordCenter(e),o=Gg(i);if(Ye(o,n))return e;var s=pi(o),a=Math.ceil((o[0]-n[0])/s);return n[0]+=s*a,t.getTileCoordForCoordAndZ(n,r)}(r,t,i)),function(t,e){var i=t[0],r=t[1],n=t[2];if(e.getMinZoom()>i||i>e.getMaxZoom())return!1;var o,s=e.getExtent();return!(o=s?e.getTileRangeForExtentAndZ(s,i):e.getFullTileRange(i))||o.containsXY(r,n)}(t,r)?t:null},e.prototype.refresh=function(){this.tileCache.clear(),this.changed()},e.prototype.useTile=function(t,e,i,r){},e}(lf),kg=function(t){function e(e,i){t.call(this,e),this.tile=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),Yg={TILELOADSTART:"tileloadstart",TILELOADEND:"tileloadend",TILELOADERROR:"tileloaderror"};function Ug(t,e){t.getImage().src=e}var jg=function(t){function e(e){t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,opaque:e.opaque,projection:e.projection,state:e.state,tileGrid:e.tileGrid,tileLoadFunction:e.tileLoadFunction?e.tileLoadFunction:Ug,tilePixelRatio:e.tilePixelRatio,tileUrlFunction:e.tileUrlFunction,url:e.url,urls:e.urls,wrapX:e.wrapX,transition:e.transition,key:e.key,attributionsCollapsible:e.attributionsCollapsible}),this.crossOrigin=void 0!==e.crossOrigin?e.crossOrigin:null,this.tileClass=void 0!==e.tileClass?e.tileClass:Og,this.tileCacheForProjection={},this.tileGridForProjection={},this.reprojectionErrorThreshold_=e.reprojectionErrorThreshold,this.renderReprojectionEdges_=!1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){if(this.tileCache.canExpireCache())return!0;for(var t in this.tileCacheForProjection)if(this.tileCacheForProjection[t].canExpireCache())return!0;return!1},e.prototype.expireCache=function(t,e){var i=this.getTileCacheForProjection(t);for(var r in this.tileCache.expireCache(this.tileCache==i?e:{}),this.tileCacheForProjection){var n=this.tileCacheForProjection[r];n.expireCache(n==i?e:{})}},e.prototype.getGutterForProjection=function(t){return this.getProjection()&&t&&!$i(this.getProjection(),t)?0:this.getGutter()},e.prototype.getGutter=function(){return 0},e.prototype.getOpaque=function(e){return!(this.getProjection()&&e&&!$i(this.getProjection(),e))&&t.prototype.getOpaque.call(this,e)},e.prototype.getTileGridForProjection=function(t){var e=this.getProjection();if(!this.tileGrid||e&&!$i(e,t)){var i=o(t);return i in this.tileGridForProjection||(this.tileGridForProjection[i]=Ng(t)),this.tileGridForProjection[i]}return this.tileGrid},e.prototype.getTileCacheForProjection=function(t){var e=this.getProjection();if(!e||$i(e,t))return this.tileCache;var i=o(t);return i in this.tileCacheForProjection||(this.tileCacheForProjection[i]=new Lg(this.tileCache.highWaterMark)),this.tileCacheForProjection[i]},e.prototype.createTile_=function(t,e,i,r,n,o){var s=[t,e,i],a=this.getTileCoordForTileUrlFunction(s,n),h=a?this.tileUrlFunction(a,r,n):void 0,l=new this.tileClass(s,void 0!==h?$t.IDLE:$t.EMPTY,void 0!==h?h:"",this.crossOrigin,this.tileLoadFunction,this.tileOptions);return l.key=o,v(l,M.CHANGE,this.handleTileChange,this),l},e.prototype.getTile=function(t,e,i,r,n){var o=this.getProjection();if(o&&n&&!$i(o,n)){var s,a=this.getTileCacheForProjection(n),h=[t,e,i],l=Sg(h);a.containsKey(l)&&(s=a.get(l));var u=this.getKey();if(s&&s.key==u)return s;var p=this.getTileGridForProjection(o),c=this.getTileGridForProjection(n),d=this.getTileCoordForTileUrlFunction(h,n),f=new Pg(o,p,n,c,h,d,this.getTilePixelRatio(r),this.getGutter(),function(t,e,i,r){return this.getTileInternal(t,e,i,r,o)}.bind(this),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_);return f.key=u,s?(f.interimTile=s,f.refreshInterimChain(),a.replace(l,f)):a.set(l,f),f}return this.getTileInternal(t,e,i,r,o||n)},e.prototype.getTileInternal=function(t,e,i,r,n){var o=null,s=Eg(t,e,i),a=this.getKey();if(this.tileCache.containsKey(s)){if((o=this.tileCache.get(s)).key!=a){var h=o;o=this.createTile_(t,e,i,r,n,a),h.getState()==$t.IDLE?o.interimTile=h.interimTile:o.interimTile=h,o.refreshInterimChain(),this.tileCache.replace(s,o)}}else o=this.createTile_(t,e,i,r,n,a),this.tileCache.set(s,o);return o},e.prototype.setRenderReprojectionEdges=function(t){if(this.renderReprojectionEdges_!=t){for(var e in this.renderReprojectionEdges_=t,this.tileCacheForProjection)this.tileCacheForProjection[e].clear();this.changed()}},e.prototype.setTileGridForProjection=function(t,e){var i=Zi(t);if(i){var r=o(i);r in this.tileGridForProjection||(this.tileGridForProjection[r]=e)}},e}(function(t){function e(e){t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,opaque:e.opaque,projection:e.projection,state:e.state,tileGrid:e.tileGrid,tilePixelRatio:e.tilePixelRatio,wrapX:e.wrapX,transition:e.transition,key:e.key,attributionsCollapsible:e.attributionsCollapsible}),this.generateTileUrlFunction_=!e.tileUrlFunction,this.tileLoadFunction=e.tileLoadFunction,this.tileUrlFunction=e.tileUrlFunction?e.tileUrlFunction.bind(this):Rg,this.urls=null,e.urls?this.setUrls(e.urls):e.url&&this.setUrl(e.url),e.tileUrlFunction&&this.setTileUrlFunction(e.tileUrlFunction,this.key_),this.tileLoadingKeys_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getTileLoadFunction=function(){return this.tileLoadFunction},e.prototype.getTileUrlFunction=function(){return this.tileUrlFunction},e.prototype.getUrls=function(){return this.urls},e.prototype.handleTileChange=function(t){var e,i=t.target,r=o(i),n=i.getState();n==$t.LOADING?(this.tileLoadingKeys_[r]=!0,e=Yg.TILELOADSTART):r in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[r],e=n==$t.ERROR?Yg.TILELOADERROR:n==$t.LOADED||n==$t.ABORT?Yg.TILELOADEND:void 0),null!=e&&this.dispatchEvent(new kg(e,i))},e.prototype.setTileLoadFunction=function(t){this.tileCache.clear(),this.tileLoadFunction=t,this.changed()},e.prototype.setTileUrlFunction=function(t,e){this.tileUrlFunction=t,this.tileCache.pruneExceptNewestZ(),void 0!==e?this.setKey(e):this.changed()},e.prototype.setUrl=function(t){var e=this.urls=xg(t);this.setUrls(e)},e.prototype.setUrls=function(t){this.urls=t;var e=t.join("\n");this.generateTileUrlFunction_?this.setTileUrlFunction(function(t,e){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=Tg(t[n],e);return Cg(r)}(t,this.tileGrid),e):this.setKey(e)},e.prototype.useTile=function(t,e,i){var r=Eg(t,e,i);this.tileCache.containsKey(r)&&this.tileCache.get(r)},e}(Dg)),Xg={KVP:"KVP",REST:"REST"},Bg=function(t){function e(e){t.call(this,{extent:e.extent,origin:e.origin,origins:e.origins,resolutions:e.resolutions,tileSize:e.tileSize,tileSizes:e.tileSizes,sizes:e.sizes}),this.matrixIds_=e.matrixIds}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getMatrixId=function(t){return this.matrixIds_[t]},e.prototype.getMatrixIds=function(){return this.matrixIds_},e}(bg);var Vg=function(t){function e(e){var i=void 0!==e.requestEncoding?e.requestEncoding:Xg.KVP,r=e.tileGrid,n=e.urls;void 0===n&&void 0!==e.url&&(n=xg(e.url)),t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,crossOrigin:e.crossOrigin,projection:e.projection,reprojectionErrorThreshold:e.reprojectionErrorThreshold,tileClass:e.tileClass,tileGrid:r,tileLoadFunction:e.tileLoadFunction,tilePixelRatio:e.tilePixelRatio,tileUrlFunction:Rg,urls:n,wrapX:void 0!==e.wrapX&&e.wrapX,transition:e.transition}),this.version_=void 0!==e.version?e.version:"1.0.0",this.format_=void 0!==e.format?e.format:"image/jpeg",this.dimensions_=void 0!==e.dimensions?e.dimensions:{},this.layer_=e.layer,this.matrixSet_=e.matrixSet,this.style_=e.style,this.requestEncoding_=i,this.setKey(this.getKeyForDimensions_()),n&&n.length>0&&(this.tileUrlFunction=Cg(n.map(Wg.bind(this))))}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setUrls=function(t){this.urls=t;var e=t.join("\n");this.setTileUrlFunction(Cg(t.map(Wg.bind(this))),e)},e.prototype.getDimensions=function(){return this.dimensions_},e.prototype.getFormat=function(){return this.format_},e.prototype.getLayer=function(){return this.layer_},e.prototype.getMatrixSet=function(){return this.matrixSet_},e.prototype.getRequestEncoding=function(){return this.requestEncoding_},e.prototype.getStyle=function(){return this.style_},e.prototype.getVersion=function(){return this.version_},e.prototype.getKeyForDimensions_=function(){var t=0,e=[];for(var i in this.dimensions_)e[t++]=i+"-"+this.dimensions_[i];return e.join("/")},e.prototype.updateDimensions=function(t){u(this.dimensions_,t),this.setKey(this.getKeyForDimensions_())},e}(jg);function Wg(t){var e=this.requestEncoding_,i={layer:this.layer_,style:this.style_,tilematrixset:this.matrixSet_};e==Xg.KVP&&u(i,{Service:"WMTS",Request:"GetTile",Version:this.version_,Format:this.format_}),t=e==Xg.KVP?_g(t,i):t.replace(/\{(\w+?)\}/g,function(t,e){return e.toLowerCase()in i?i[e.toLowerCase()]:t});var r=this.tileGrid,n=this.dimensions_;return function(i,o,s){if(i){var a={TileMatrix:r.getMatrixId(i[0]),TileCol:i[1],TileRow:-i[2]-1};u(a,n);var h=t;return h=e==Xg.KVP?_g(h,a):h.replace(/\{(\w+?)\}/g,function(t,e){return a[e]})}}}var Kg=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:i.projection,resolutions:i.resolutions,state:i.state}),this.canvasFunction_=i.canvasFunction,this.canvas_=null,this.renderedRevision_=0,this.ratio_=void 0!==i.ratio?i.ratio:1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getImageInternal=function(t,e,i,r){e=this.findNearestResolution(e);var n=this.canvas_;if(n&&this.renderedRevision_==this.getRevision()&&n.getResolution()==e&&n.getPixelRatio()==i&&Ue(n.getExtent(),t))return n;fi(t=t.slice(),this.ratio_);var o=[pi(t)/e*i,ai(t)/e*i],s=this.canvasFunction_.call(this,t,e,i,o,r);return s&&(n=new Lo(t,e,i,s)),this.canvas_=n,this.renderedRevision_=this.getRevision(),n},e}(pg);i.d(e,"array",function(){return zg}),i.d(e,"asserts",function(){return Zg}),i.d(e,"color",function(){return Hg}),i.d(e,"math",function(){return qg}),i.d(e,"string",function(){return Jg}),i.d(e,"control",function(){return Qg}),i.d(e,"events",function(){return $g}),i.d(e,"extent",function(){return t_}),i.d(e,"geom",function(){return e_}),i.d(e,"featureloader",function(){return i_}),i.d(e,"format",function(){return r_}),i.d(e,"interaction",function(){return n_}),i.d(e,"layer",function(){return o_}),i.d(e,"Observable",function(){return s_}),i.d(e,"Object",function(){return a_}),i.d(e,"proj",function(){return h_}),i.d(e,"render",function(){return l_}),i.d(e,"source",function(){return u_}),i.d(e,"style",function(){return p_}),i.d(e,"xml",function(){return c_}),i.d(e,"VERSION",function(){return s}),i.d(e,"Map",function(){return ca}),i.d(e,"View",function(){return nn}),i.d(e,"Overlay",function(){return ga}),i.d(e,"OverlayPositioning",function(){return da}),i.d(e,"Feature",function(){return Oa}),i.d(e,"Collection",function(){return Y}),i.d(e,"MapEventType",function(){return qt}),i.d(e,"MapBrowserEventType",function(){return Q}),i.d(e,"Image",function(){return $f}),Oa.createStyleFunction=Ia;const zg={};zg.extend=kt,zg.includes=At;const Zg={};Zg.assert=te;const Hg={};Hg.asArray=es,Hg.asString=$o;const qg={};qg.toRadians=le;const Jg={};Jg.padNumber=Ee;const Qg={};Qg.OverviewMap=ya,Qg.ScaleLine=Ta,Qg.Zoom=bn,Qg.ZoomSlider=xa,Qg.ZoomSlider.render=Ra,Qg.ZoomToExtent=wa;const $g={};$g.EventType=M,$g.listen=v,$g.unlisten=E,$g.condition={shiftKeyOnly:$n};const t_={};t_.getWidth=pi,t_.getHeight=ai,t_.containsCoordinate=Ye,t_.containsExtent=Ue,t_.buffer=Ge,t_.boundingExtent=Ae;const e_={};e_.Point=Gr,e_.MultiPoint=La,e_.LineString=Fa,e_.MultiLineString=ba,e_.Polygon=qr,e_.MultiPolygon=Na,e_.GeometryCollection=ka,e_.Circle=Ga,e_.GeometryType=_i,e_.GeometryLayout=yi,e_.flat={deflateCoordinates:xr,inflateCoordinates:Ir,linearRingLength:function(t,e,i,r){var n=Ls(t,e,i,r),o=t[i-r]-t[e],s=t[i-r+1]-t[e+1];return n+=Math.sqrt(o*o+s*s)}};const i_={};i_.xhr=Ua;const r_={};r_.Feature=Oa,r_.Feature.transformWithOptions=Ba,r_.GeoJSON=Za,r_.GMLBase=Eh,r_.GML=Yh,r_.GML2=Xp,r_.GML3=Dh,r_.GPX=El,r_.KML=kp,r_.WFS=mc,r_.WKT=jc,r_.WMSCapabilities=gd,r_.WMSGetFeatureInfo=_d,r_.WMTSCapabilities=Hd,r_.TopoJSON=rf,r_.xsd={readDecimal:Rh,readBoolean:Sh,readString:Oh,readNonNegativeInteger:wh,readDateTime:Ch,writeStringTextNode:bh,writeCDATASection:Ph,writeDecimalTextNode:Mh,writeBooleanTextNode:Lh,writeNonNegativeIntegerTextNode:Fh};const n_={};n_.defaults=xo,n_.Draw=mf,n_.Pointer=no,n_.Translate=Rf,n_.Snap=wf,n_.Select=Mf,n_.Modify=Uf,n_.DragAndDrop=Wf,n_.DoubleClickZoom=Bn;const o_={};o_.Layer=On,o_.Tile=Hf,o_.Image=Jf,o_.Vector=sf;const s_={unByKey:function(t){if(Array.isArray(t))for(var e=0,i=t.length;e<i;++e)S(t[e]);else S(t)}},a_={};a_.getChangeEventType=A;const h_={};h_.METERS_PER_UNIT=Ti,h_.Projection=xi,h_.addEquivalentProjections=qi,h_.get=Zi,h_.transform=ir,h_.transformExtent=rr,h_.getTransform=er,h_.Units=Ci,h_.proj4={register:function(t){var e,i,r,n,o,s,a,h,l=Object.keys(t.defs),u=l.length;for(e=0;e<u;++e){var p=l[e];if(!Zi(p)){var c=t.defs(p);zi(new xi({code:p,axisOrientation:c.axis,metersPerUnit:c.to_meter,units:c.units}))}}for(e=0;e<u;++e){var d=l[e],f=Zi(d);for(i=0;i<u;++i){var g=l[i],_=Zi(g);if(!Vi(d,g))if(t.defs[d]===t.defs[g])qi([f,_]);else{var y=t(d,g);r=f,n=_,o=y.forward,s=y.inverse,a=void 0,h=void 0,a=Zi(r),h=Zi(n),Bi(a,h,Qi(o)),Bi(h,a,Qi(s))}}}}},h_.EPSG4326={METERS_PER_UNIT:Ai,PROJECTIONS:Di};const l_={toContext:function(t,e){var i=t.canvas,r=e||{},n=r.pixelRatio||z,o=r.size;o&&(i.width=o[0]*n,i.height=o[1]*n,i.style.width=o[0]+"px",i.style.height=o[1]+"px");var s=[0,0,i.width,i.height],a=ur([1,0,0,1,0,0],n,n);return new as(t,n,s,a,0)}};l_.EventType=Qt;const u_={};u_.Vector=ff,u_.Cluster=Qf,u_.ImageWMS=vg,u_.WMTS=Vg,u_.WMTS.optionsFromCapabilities=function(t,e){var i=Yt(t.Contents.Layer,function(t,i,r){return t.Identifier==e.layer});if(null===i)return null;var r,n=t.Contents.TileMatrixSet;(r=i.TileMatrixSetLink.length>1?jt(i.TileMatrixSetLink,"projection"in e?function(t,i,r){var o=Yt(n,function(e){return e.Identifier==t.TileMatrixSet}).SupportedCRS,s=Zi(o.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(o),a=Zi(e.projection);return s&&a?$i(s,a):o==e.projection}:function(t,i,r){return t.TileMatrixSet==e.matrixSet}):0)<0&&(r=0);var o=i.TileMatrixSetLink[r].TileMatrixSet,s=i.TileMatrixSetLink[r].TileMatrixSetLimits,a=i.Format[0];"format"in e&&(a=e.format),(r=jt(i.Style,function(t,i,r){return"style"in e?t.Title==e.style:t.isDefault}))<0&&(r=0);var h=i.Style[r].Identifier,l={};"Dimension"in i&&i.Dimension.forEach(function(t,e,i){var r=t.Identifier,n=t.Default;void 0===n&&(n=t.Value[0]),l[r]=n});var u,p=Yt(t.Contents.TileMatrixSet,function(t,e,i){return t.Identifier==o}),c=p.SupportedCRS;if(c&&(u=Zi(c.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(c)),"projection"in e){var d=Zi(e.projection);d&&(u&&!$i(d,u)||(u=d))}var f,g,_=i.WGS84BoundingBox;if(void 0!==_){var y=Zi("EPSG:4326").getExtent();g=_[0]==y[0]&&_[2]==y[2],f=rr(_,"EPSG:4326",u);var v=u.getExtent();v&&(Ue(v,f)||(f=void 0))}var m=function(t,e,i){var r=[],n=[],o=[],s=[],a=[],h=void 0!==i?i:[],l=t.SupportedCRS,u=Zi(l.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(l),p=u.getMetersPerUnit(),c="ne"==u.getAxisOrientation().substr(0,2);return t.TileMatrix.sort(function(t,e){return e.ScaleDenominator-t.ScaleDenominator}),t.TileMatrix.forEach(function(e){if(!(h.length>0)||Yt(h,function(i){return e.Identifier==i.TileMatrix||-1===e.Identifier.indexOf(":")&&t.Identifier+":"+e.Identifier===i.TileMatrix})){n.push(e.Identifier);var i=28e-5*e.ScaleDenominator/p,l=e.TileWidth,u=e.TileHeight;c?o.push([e.TopLeftCorner[1],e.TopLeftCorner[0]]):o.push(e.TopLeftCorner),r.push(i),s.push(l==u?l:[l,u]),a.push([e.MatrixWidth,-e.MatrixHeight])}}),new Bg({extent:e,origins:o,resolutions:r,matrixIds:n,tileSizes:s,sizes:a})}(p,f,s),E=[],S=e.requestEncoding;if(S=void 0!==S?S:"","OperationsMetadata"in t&&"GetTile"in t.OperationsMetadata)for(var T=t.OperationsMetadata.GetTile.DCP.HTTP.Get,C=0,R=T.length;C<R;++C)if(T[C].Constraint){var x=Yt(T[C].Constraint,function(t){return"GetEncoding"==t.name}).AllowedValues.Value;if(""===S&&(S=x[0]),S!==Xg.KVP)break;At(x,Xg.KVP)&&E.push(T[C].href)}else T[C].href&&(S=Xg.KVP,E.push(T[C].href));return 0===E.length&&(S=Xg.REST,i.ResourceURL.forEach(function(t){"tile"===t.resourceType&&(a=t.format,E.push(t.template))})),{urls:E,layer:e.layer,matrixSet:o,format:a,projection:u,requestEncoding:S,tileGrid:m,style:h,dimensions:l,wrapX:g,crossOrigin:e.crossOrigin}},u_.TileEventType=Yg,u_.VectorEventType=uf,u_.ImageCanvas=Kg,u_.Image={defaultImageLoadFunction:ug};const p_={};p_.Style=kl,p_.RegularShape=Ml,p_.Circle=Fl,p_.Fill=Tl,p_.Icon=Ol,p_.Stroke=Pl,p_.Style=kl,p_.Text=zl,p_.IconAnchorUnits=Cl,p_.IconOrigin=xl;const c_={};c_.parse=th,c_.parseNode=ch,c_.createElementNS=Ja,c_.pushParseAndPop=dh,c_.pushSerializeAndPop=gh,c_.makeStructureNS=ph,c_.getAllTextContent=Qa,c_.makeChildAppender=sh,c_.makeReplacer=rh,c_.makeSequence=uh,c_.makeArrayPusher=ih,c_.makeArrayExtender=eh,c_.makeArraySerializer=ah,c_.makeObjectPropertySetter=oh,c_.makeSimpleNodeFactory=hh,c_.OBJECT_PROPERTY_NODE_FACTORY=lh,c_.XML_SCHEMA_INSTANCE_URI=qa,c_.DOCUMENT=Ha}]);
/*
Name: autoComplete
Author: Raymond Camden & Andy Matthews
Contributors: Jim Pease (@jmpease)
Website: http://raymondcamden.com/
http://andyMatthews.net
Packed With: http://jsutility.pjoneil.net/
Version: 1.4
Modificado por Fernando Lacunza
*/

var TC = TC || {};
TC.UI = TC.UI || {};

(function() {    

    var isPlainObject = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
    };

    var isFunction = function(fn) {
        return typeof fn == 'function';
    };

    var extend = function() {
        // Variables
        var extended = {};
        var deep = false;
        var i = 0;

        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }

        // Merge the object into the extended object
        var merge = function(obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    // If property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(extended[prop], obj[prop]);
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };

        // Loop through each object and conduct a merge
        for (; i < arguments.length; i++) {
            merge(arguments[i]);
        }

        return extended;

    };    

    var autocomplete = {
        defaults: {
            method: 'GET',
            cancelRequests: false,
            target: null,
            source: null,
            callback: null,
            link: null,
            minLength: 0,
            matchFromStart: true
        },
        openXHR: {},
        cache: {}
    },
        
        buildItems = function(inputText, data, settings) {
            var html = [];
            if (data) {
                if (settings.buildHTML) {

                    settings.target.innerHTML = settings.buildHTML({ results: data });

                    //var template = document.createElement('template');
                    //template.innerHTML = settings.buildHTML({ results: data });

                    //(template.content ? template.content : template).childNodes.forEach(function(childNode) {
                    //    settings.target.appendChild(childNode);
                    //});                    
                }
                else {
                    for (var i = 0; i < data.length; i++) {
                        var elm = data[i];
                        // are we working with objects or strings?
                        if (isPlainObject(elm)) {
                            html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm.id) + '">' + elm.label + '</a></li>';
                        } else {
                            html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm) + '">' + elm + '</a></li>';
                        }
                    }

                    var template = document.createElement('template');
                    template.innerHTML = html.join('');

                    settings.target.appendChild(template.content ? template.content.firstChild : template.firstChild);
                }

            }


            // is there a callback?
            if (settings.callback !== null && isFunction(settings.callback)) {
                attachCallback(settings);
            }

            if (inputText.value.length > 0) {
                inputText.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
            } else {
                inputText.dispatchEvent(new CustomEvent("targetCleared.autocomplete"));
            }
        },
        attachCallback = function(settings) {
            settings.target.querySelectorAll('li a').forEach(function(element) {
                element.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    settings.callback(e);
                });
            });

            //$('li a', $(settings.target)).on('click.autocomplete', function(e) {
            //    e.stopPropagation();
            //    e.preventDefault();
            //    settings.callback(e);
            //});
        },
        clearTarget = function(inputText, target) {
            //$target.html('').closest("fieldset").removeClass("ui-search-active");
            target.innerHTML = '';

            /* provisional el tema del fieldset */
            //document.querySelector("fieldset.ui-search-active").classList.remove("ui-search-active");

            inputText.dispatchEvent(new CustomEvent("targetCleared.autocomplete"));
        },
        handleInput = function(e) {
            var inputText = e.target,
                id = inputText.getAttribute("id"),
                text,
                data,
                autocomplete = inputText.getAttribute("autocomplete"),
                element_text,
                re;
            if (autocomplete) {
                var settings = this.settings;
                var openXHR = autocomplete.openXHR;
                // get the current text of the input field
                text = inputText.value;
                // if we don't have enough text zero out the target
                if (text.length < settings.minLength) {
                    clearTarget(inputText, settings.target);
                } else {
                    // are we looking at a source array or remote data?
                    if (Array.isArray(settings.source)) {
                        data = settings.source.sort().filter(function(element) {
                            // matching from start, or anywhere in the string?
                            if (settings.matchFromStart) {
                                // from start
                                element_text, re = new RegExp('^' + text, 'i');
                            } else {
                                // anywhere
                                element_text, re = new RegExp(text, 'i');
                            }
                            if (isPlainObject(element)) {
                                element_text = element.label;
                            } else {
                                element_text = element;
                            }
                            return re.test(element_text);
                        });
                        buildItems(inputText, data, settings);
                    }
                    // Accept a function as source.
                    // Function needs to call the callback, which is the first parameter.
                    // source:function(text,callback) { mydata = [1,2]; callback(mydata); }
                    else if (typeof settings.source === 'function') {
                        if (arguments && arguments[0]) {
                            if ([37, 39].indexOf(arguments[0].keyCode) > -1) {
                                return;
                            }
                        }

                        settings.source(text, function(data) {
                            buildItems(inputText, data, settings);
                        });

                    } else {

                        const beforeSend = function(jqXHR) {
                            if (settings.cancelRequests) {
                                if (openXHR[id]) {
                                    // If we have an open XML HTTP Request for this autoComplete ID, abort it
                                    openXHR[id].abort();
                                } else {
                                    // Set a loading indicator as a temporary stop-gap to the response time issue
                                    settings.target.innerHTML = '<li><a href="#">Searching...</a></li>';

                                    /* pendiente */
                                    //settings.target.closest("fieldset").addClass("ui-search-active");
                                }
                                // Set this request to the open XML HTTP Request list for this ID
                                openXHR[id] = jqXHR;
                            }
                        };

                        const complete = function() {
                            // Clear this ID's open XML HTTP Request from the list
                            if (settings.cancelRequests) {
                                openXHR[id] = null;
                            }
                        };

                        var xhr = new XMLHttpRequest();
                        xhr.overrideMimeType("application/json");
                        xhr.open('GET', url, true);
                        xhr.onload = function() {
                            complete();
                            var jsonResponse = JSON.parse(req.responseText);
                            buildItems(inputText, jsonResponse, settings);
                        };
                        xhr.onerror = function(error) {
                            complete();
                        };
                        beforeSend(xhr);
                        xhr.send(null);                        
                    }
                }
            }
        },
        methods = {
            init: function(options) {
                var el = this;
                var autocomplete = { settings: null };
                autocomplete.settings = extend({}, autocomplete.defaults, options);                

                el.setAttribute("autocomplete", true);

                var settings = autocomplete.settings;

                el.removeEventListener("keyup", handleInput);
                el.addEventListener("keyup", handleInput);

                if (el.parentNode.querySelector('.ui-input-clear')) {
                    el.parentNode.querySelector('.ui-input-clear').addEventListener('click', function(e) {
                        clearTarget(el, settings.target);
                    });
                }

                return el;                
            },
            // Allow dynamic update of source and link
            update: function(initialOptions, newOptions) {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    this.settings = extend(this.settings, newOptions);                    
                }
                return this;
            },
            // Method to forcibly clear our target
            clear: function(options) {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    clearTarget(this, this.settings.target);
                }
                return this;
            },
            // Method to destroy (cleanup) plugin
            destroy: function() {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    clearTarget(this, this.settings.target);
                    this.removeAttribute("autocomplete");
                    this.removeEventListener("keyup", handleInput);
                    //this.removeEventListener(".autocomplete");
                }
                return this;
            }
        };  

    TC.UI.autocomplete = function (method) {    
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            this.settings = arguments[0];
            return methods.init.apply(this, arguments);
        }
    };

})(TC);

/*!
 * Draggabilly PACKAGED v2.2.0
 * Make that shiz draggable
 * https://draggabilly.desandro.com
 * MIT license
 */

!function(i,e){"function"==typeof define&&define.amd?define("jquery-bridget/jquery-bridget",["jquery"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("jquery")):i.jQueryBridget=e(i,i.jQuery)}(window,function(t,i){"use strict";var c=Array.prototype.slice,e=t.console,p=void 0===e?function(){}:function(t){e.error(t)};function n(d,o,u){(u=u||i||t.jQuery)&&(o.prototype.option||(o.prototype.option=function(t){u.isPlainObject(t)&&(this.options=u.extend(!0,this.options,t))}),u.fn[d]=function(t){if("string"==typeof t){var i=c.call(arguments,1);return s=i,a="$()."+d+'("'+(r=t)+'")',(e=this).each(function(t,i){var e=u.data(i,d);if(e){var n=e[r];if(n&&"_"!=r.charAt(0)){var o=n.apply(e,s);h=void 0===h?o:h}else p(a+" is not a valid method")}else p(d+" not initialized. Cannot call methods, i.e. "+a)}),void 0!==h?h:e}var e,r,s,h,a,n;return n=t,this.each(function(t,i){var e=u.data(i,d);e?(e.option(n),e._init()):(e=new o(i,n),u.data(i,d,e))}),this},r(u))}function r(t){!t||t&&t.bridget||(t.bridget=n)}return r(i||t.jQuery),n}),function(t,i){"use strict";"function"==typeof define&&define.amd?define("get-size/get-size",[],function(){return i()}):"object"==typeof module&&module.exports?module.exports=i():t.getSize=i()}(window,function(){"use strict";function m(t){var i=parseFloat(t);return-1==t.indexOf("%")&&!isNaN(i)&&i}var e="undefined"==typeof console?function(){}:function(t){console.error(t)},y=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],b=y.length;function E(t){var i=getComputedStyle(t);return i||e("Style returned "+i+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),i}var _,x=!1;function P(t){if(function(){if(!x){x=!0;var t=document.createElement("div");t.style.width="200px",t.style.padding="1px 2px 3px 4px",t.style.borderStyle="solid",t.style.borderWidth="1px 2px 3px 4px",t.style.boxSizing="border-box";var i=document.body||document.documentElement;i.appendChild(t);var e=E(t);P.isBoxSizeOuter=_=200==m(e.width),i.removeChild(t)}}(),"string"==typeof t&&(t=document.querySelector(t)),t&&"object"==typeof t&&t.nodeType){var i=E(t);if("none"==i.display)return function(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},i=0;i<b;i++)t[y[i]]=0;return t}();var e={};e.width=t.offsetWidth,e.height=t.offsetHeight;for(var n=e.isBorderBox="border-box"==i.boxSizing,o=0;o<b;o++){var r=y[o],s=i[r],h=parseFloat(s);e[r]=isNaN(h)?0:h}var a=e.paddingLeft+e.paddingRight,d=e.paddingTop+e.paddingBottom,u=e.marginLeft+e.marginRight,c=e.marginTop+e.marginBottom,p=e.borderLeftWidth+e.borderRightWidth,f=e.borderTopWidth+e.borderBottomWidth,g=n&&_,l=m(i.width);!1!==l&&(e.width=l+(g?0:a+p));var v=m(i.height);return!1!==v&&(e.height=v+(g?0:d+f)),e.innerWidth=e.width-(a+p),e.innerHeight=e.height-(d+f),e.outerWidth=e.width+u,e.outerHeight=e.height+c,e}}return P}),function(t,i){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",i):"object"==typeof module&&module.exports?module.exports=i():t.EvEmitter=i()}("undefined"!=typeof window?window:this,function(){function t(){}var i=t.prototype;return i.on=function(t,i){if(t&&i){var e=this._events=this._events||{},n=e[t]=e[t]||[];return-1==n.indexOf(i)&&n.push(i),this}},i.once=function(t,i){if(t&&i){this.on(t,i);var e=this._onceEvents=this._onceEvents||{};return(e[t]=e[t]||{})[i]=!0,this}},i.off=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){var n=e.indexOf(i);return-1!=n&&e.splice(n,1),this}},i.emitEvent=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){e=e.slice(0),i=i||[];for(var n=this._onceEvents&&this._onceEvents[t],o=0;o<e.length;o++){var r=e[o];n&&n[r]&&(this.off(t,r),delete n[r]),r.apply(this,i)}return this}},i.allOff=function(){delete this._events,delete this._onceEvents},t}),function(i,e){"function"==typeof define&&define.amd?define("unipointer/unipointer",["ev-emitter/ev-emitter"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("ev-emitter")):i.Unipointer=e(i,i.EvEmitter)}(window,function(o,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindStartEvent=function(t){this._bindStartEvent(t,!0)},e.unbindStartEvent=function(t){this._bindStartEvent(t,!1)},e._bindStartEvent=function(t,i){var e=(i=void 0===i||i)?"addEventListener":"removeEventListener",n="mousedown";o.PointerEvent?n="pointerdown":"ontouchstart"in o&&(n="touchstart"),t[e](n,this)},e.handleEvent=function(t){var i="on"+t.type;this[i]&&this[i](t)},e.getTouch=function(t){for(var i=0;i<t.length;i++){var e=t[i];if(e.identifier==this.pointerIdentifier)return e}},e.onmousedown=function(t){var i=t.button;i&&0!==i&&1!==i||this._pointerDown(t,t)},e.ontouchstart=function(t){this._pointerDown(t,t.changedTouches[0])},e.onpointerdown=function(t){this._pointerDown(t,t)},e._pointerDown=function(t,i){t.button||this.isPointerDown||(this.isPointerDown=!0,this.pointerIdentifier=void 0!==i.pointerId?i.pointerId:i.identifier,this.pointerDown(t,i))},e.pointerDown=function(t,i){this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i])};var n={mousedown:["mousemove","mouseup"],touchstart:["touchmove","touchend","touchcancel"],pointerdown:["pointermove","pointerup","pointercancel"]};return e._bindPostStartEvents=function(t){if(t){var i=n[t.type];i.forEach(function(t){o.addEventListener(t,this)},this),this._boundPointerEvents=i}},e._unbindPostStartEvents=function(){this._boundPointerEvents&&(this._boundPointerEvents.forEach(function(t){o.removeEventListener(t,this)},this),delete this._boundPointerEvents)},e.onmousemove=function(t){this._pointerMove(t,t)},e.onpointermove=function(t){t.pointerId==this.pointerIdentifier&&this._pointerMove(t,t)},e.ontouchmove=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerMove(t,i)},e._pointerMove=function(t,i){this.pointerMove(t,i)},e.pointerMove=function(t,i){this.emitEvent("pointerMove",[t,i])},e.onmouseup=function(t){this._pointerUp(t,t)},e.onpointerup=function(t){t.pointerId==this.pointerIdentifier&&this._pointerUp(t,t)},e.ontouchend=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerUp(t,i)},e._pointerUp=function(t,i){this._pointerDone(),this.pointerUp(t,i)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i])},e._pointerDone=function(){this._pointerReset(),this._unbindPostStartEvents(),this.pointerDone()},e._pointerReset=function(){this.isPointerDown=!1,delete this.pointerIdentifier},e.pointerDone=function(){},e.onpointercancel=function(t){t.pointerId==this.pointerIdentifier&&this._pointerCancel(t,t)},e.ontouchcancel=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerCancel(t,i)},e._pointerCancel=function(t,i){this._pointerDone(),this.pointerCancel(t,i)},e.pointerCancel=function(t,i){this.emitEvent("pointerCancel",[t,i])},i.getPointerPoint=function(t){return{x:t.pageX,y:t.pageY}},i}),function(i,e){"function"==typeof define&&define.amd?define("unidragger/unidragger",["unipointer/unipointer"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("unipointer")):i.Unidragger=e(i,i.Unipointer)}(window,function(r,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindHandles=function(){this._bindHandles(!0)},e.unbindHandles=function(){this._bindHandles(!1)},e._bindHandles=function(t){for(var i=(t=void 0===t||t)?"addEventListener":"removeEventListener",e=t?this._touchActionValue:"",n=0;n<this.handles.length;n++){var o=this.handles[n];this._bindStartEvent(o,t),o[i]("click",this),r.PointerEvent&&(o.style.touchAction=e)}},e._touchActionValue="none",e.pointerDown=function(t,i){this.okayPointerDown(t)&&(this.pointerDownPointer=i,t.preventDefault(),this.pointerDownBlur(),this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i]))};var o={TEXTAREA:!0,INPUT:!0,SELECT:!0,OPTION:!0},s={radio:!0,checkbox:!0,button:!0,submit:!0,image:!0,file:!0};return e.okayPointerDown=function(t){var i=o[t.target.nodeName],e=s[t.target.type],n=!i||e;return n||this._pointerReset(),n},e.pointerDownBlur=function(){var t=document.activeElement;t&&t.blur&&t!=document.body&&t.blur()},e.pointerMove=function(t,i){var e=this._dragPointerMove(t,i);this.emitEvent("pointerMove",[t,i,e]),this._dragMove(t,i,e)},e._dragPointerMove=function(t,i){var e={x:i.pageX-this.pointerDownPointer.pageX,y:i.pageY-this.pointerDownPointer.pageY};return!this.isDragging&&this.hasDragStarted(e)&&this._dragStart(t,i),e},e.hasDragStarted=function(t){return 3<Math.abs(t.x)||3<Math.abs(t.y)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i]),this._dragPointerUp(t,i)},e._dragPointerUp=function(t,i){this.isDragging?this._dragEnd(t,i):this._staticClick(t,i)},e._dragStart=function(t,i){this.isDragging=!0,this.isPreventingClicks=!0,this.dragStart(t,i)},e.dragStart=function(t,i){this.emitEvent("dragStart",[t,i])},e._dragMove=function(t,i,e){this.isDragging&&this.dragMove(t,i,e)},e.dragMove=function(t,i,e){t.preventDefault(),this.emitEvent("dragMove",[t,i,e])},e._dragEnd=function(t,i){this.isDragging=!1,setTimeout(function(){delete this.isPreventingClicks}.bind(this)),this.dragEnd(t,i)},e.dragEnd=function(t,i){this.emitEvent("dragEnd",[t,i])},e.onclick=function(t){this.isPreventingClicks&&t.preventDefault()},e._staticClick=function(t,i){this.isIgnoringMouseUp&&"mouseup"==t.type||(this.staticClick(t,i),"mouseup"!=t.type&&(this.isIgnoringMouseUp=!0,setTimeout(function(){delete this.isIgnoringMouseUp}.bind(this),400)))},e.staticClick=function(t,i){this.emitEvent("staticClick",[t,i])},i.getPointerPoint=t.getPointerPoint,i}),function(e,n){"function"==typeof define&&define.amd?define(["get-size/get-size","unidragger/unidragger"],function(t,i){return n(e,t,i)}):"object"==typeof module&&module.exports?module.exports=n(e,require("get-size"),require("unidragger")):e.Draggabilly=n(e,e.getSize,e.Unidragger)}(window,function(r,a,t){function e(t,i){for(var e in i)t[e]=i[e];return t}var n=r.jQuery;function i(t,i){this.element="string"==typeof t?document.querySelector(t):t,n&&(this.$element=n(this.element)),this.options=e({},this.constructor.defaults),this.option(i),this._create()}var o=i.prototype=Object.create(t.prototype);i.defaults={},o.option=function(t){e(this.options,t)};var s={relative:!0,absolute:!0,fixed:!0};function d(t,i,e){return e=e||"round",i?Math[e](t/i)*i:t}return o._create=function(){this.position={},this._getPosition(),this.startPoint={x:0,y:0},this.dragPoint={x:0,y:0},this.startPosition=e({},this.position);var t=getComputedStyle(this.element);s[t.position]||(this.element.style.position="relative"),this.on("pointerDown",this.onPointerDown),this.on("pointerMove",this.onPointerMove),this.on("pointerUp",this.onPointerUp),this.enable(),this.setHandles()},o.setHandles=function(){this.handles=this.options.handle?this.element.querySelectorAll(this.options.handle):[this.element],this.bindHandles()},o.dispatchEvent=function(t,i,e){var n=[i].concat(e);this.emitEvent(t,n),this.dispatchJQueryEvent(t,i,e)},o.dispatchJQueryEvent=function(t,i,e){var n=r.jQuery;if(n&&this.$element){var o=n.Event(i);o.type=t,this.$element.trigger(o,e)}},o._getPosition=function(){var t=getComputedStyle(this.element),i=this._getPositionCoord(t.left,"width"),e=this._getPositionCoord(t.top,"height");this.position.x=isNaN(i)?0:i,this.position.y=isNaN(e)?0:e,this._addTransformPosition(t)},o._getPositionCoord=function(t,i){if(-1!=t.indexOf("%")){var e=a(this.element.parentNode);return e?parseFloat(t)/100*e[i]:0}return parseInt(t,10)},o._addTransformPosition=function(t){var i=t.transform;if(0===i.indexOf("matrix")){var e=i.split(","),n=0===i.indexOf("matrix3d")?12:4,o=parseInt(e[n],10),r=parseInt(e[n+1],10);this.position.x+=o,this.position.y+=r}},o.onPointerDown=function(t,i){this.element.classList.add("is-pointer-down"),this.dispatchJQueryEvent("pointerDown",t,[i])},o.dragStart=function(t,i){this.isEnabled&&(this._getPosition(),this.measureContainment(),this.startPosition.x=this.position.x,this.startPosition.y=this.position.y,this.setLeftTop(),this.dragPoint.x=0,this.dragPoint.y=0,this.element.classList.add("is-dragging"),this.dispatchEvent("dragStart",t,[i]),this.animate())},o.measureContainment=function(){var t=this.getContainer();if(t){var i=a(this.element),e=a(t),n=this.element.getBoundingClientRect(),o=t.getBoundingClientRect(),r=e.borderLeftWidth+e.borderRightWidth,s=e.borderTopWidth+e.borderBottomWidth,h=this.relativeStartPosition={x:n.left-(o.left+e.borderLeftWidth),y:n.top-(o.top+e.borderTopWidth)};this.containSize={width:e.width-r-h.x-i.width,height:e.height-s-h.y-i.height}}},o.getContainer=function(){var t=this.options.containment;if(t)return t instanceof HTMLElement?t:"string"==typeof t?document.querySelector(t):this.element.parentNode},o.onPointerMove=function(t,i,e){this.dispatchJQueryEvent("pointerMove",t,[i,e])},o.dragMove=function(t,i,e){if(this.isEnabled){var n=e.x,o=e.y,r=this.options.grid,s=r&&r[0],h=r&&r[1];n=d(n,s),o=d(o,h),n=this.containDrag("x",n,s),o=this.containDrag("y",o,h),n="y"==this.options.axis?0:n,o="x"==this.options.axis?0:o,this.position.x=this.startPosition.x+n,this.position.y=this.startPosition.y+o,this.dragPoint.x=n,this.dragPoint.y=o,this.dispatchEvent("dragMove",t,[i,e])}},o.containDrag=function(t,i,e){if(!this.options.containment)return i;var n="x"==t?"width":"height",o=d(-this.relativeStartPosition[t],e,"ceil"),r=this.containSize[n];return r=d(r,e,"floor"),Math.max(o,Math.min(r,i))},o.onPointerUp=function(t,i){this.element.classList.remove("is-pointer-down"),this.dispatchJQueryEvent("pointerUp",t,[i])},o.dragEnd=function(t,i){this.isEnabled&&(this.element.style.transform="",this.setLeftTop(),this.element.classList.remove("is-dragging"),this.dispatchEvent("dragEnd",t,[i]))},o.animate=function(){if(this.isDragging){this.positionDrag();var t=this;requestAnimationFrame(function(){t.animate()})}},o.setLeftTop=function(){this.element.style.left=this.position.x+"px",this.element.style.top=this.position.y+"px"},o.positionDrag=function(){this.element.style.transform="translate3d( "+this.dragPoint.x+"px, "+this.dragPoint.y+"px, 0)"},o.staticClick=function(t,i){this.dispatchEvent("staticClick",t,[i])},o.setPosition=function(t,i){this.position.x=t,this.position.y=i,this.setLeftTop()},o.enable=function(){this.isEnabled=!0},o.disable=function(){this.isEnabled=!1,this.isDragging&&this.dragEnd()},o.destroy=function(){this.disable(),this.element.style.transform="",this.element.style.left="",this.element.style.top="",this.element.style.position="",this.unbindHandles(),this.$element&&this.$element.removeData("draggabilly")},o._init=function(){},n&&n.bridget&&n.bridget("draggabilly",i),i});
/*! Sortable 1.8.2 - MIT | git://github.com/SortableJS/Sortable.git */

!function(t){"use strict";"function"==typeof define&&define.amd?define(t):"undefined"!=typeof module&&void 0!==module.exports?module.exports=t():window.Sortable=t()}(function(){"use strict";if("undefined"==typeof window||!window.document)return function(){throw new Error("Sortable.js requires a window with a document")};var V,q,G,u,K,Z,h,Y,M,k,Q,o,J,$,l,s,c,f,P,tt,et,nt,ot,it,rt,I=[],at=!1,p=!1,lt=!1,d=[],st=!1,ct=!1,i=/\s+/g,dt="Sortable"+(new Date).getTime(),ht=window,ut=ht.document,g=ht.parseInt,ft=ht.setTimeout,e=ht.jQuery||ht.Zepto,n=ht.Polymer,r={capture:!1,passive:!1},pt=!!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),v=!!navigator.userAgent.match(/Edge/i),m=v||pt?"cssFloat":"float",a="draggable"in ut.createElement("div"),b=function(){if(pt)return!1;var t=ut.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}(),gt=!1,w=!1,vt=Math.abs,_=Math.min,y=[],D=function(t,e){var n=B(t),o=g(n.width),i=W(t,0,e),r=W(t,1,e),a=i&&B(i),l=r&&B(r),s=a&&g(a.marginLeft)+g(a.marginRight)+Mt(i).width,c=l&&g(l.marginLeft)+g(l.marginRight)+Mt(r).width;if("flex"===n.display)return"column"===n.flexDirection||"column-reverse"===n.flexDirection?"vertical":"horizontal";if(i&&"none"!==a.float){var d="left"===a.float?"left":"right";return!r||"both"!==l.clear&&l.clear!==d?"horizontal":"vertical"}return i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||o<=s&&"none"===n[m]||r&&"none"===n[m]&&o<s+c)?"vertical":"horizontal"},mt=function(t,e){if(!t||!t.getBoundingClientRect)return ht;var n=t,o=!1;do{if(n.clientWidth<n.scrollWidth||n.clientHeight<n.scrollHeight){var i=B(n);if(n.clientWidth<n.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||n.clientHeight<n.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!n||!n.getBoundingClientRect||n===ut.body)return ht;if(o||e)return n;o=!0}}}while(n=n.parentNode);return ht},S=j(function(n,t,e,o){if(t.scroll){var i=e?e[dt]:window,r=t.scrollSensitivity,a=t.scrollSpeed,l=n.clientX,s=n.clientY,c=(window.innerWidth,window.innerHeight,!1);M!==e&&(A(),Y=t.scroll,k=t.scrollFn,!0===Y&&(Y=mt(e,!0),M=Y));var d=0,h=Y;do{var u,f,p,g,v,m,b,w,_,y=h,D=Mt(y),S=D.top,C=D.bottom,T=D.left,E=D.right,x=D.width,N=D.height;if(_=y!==ht?(u=y.scrollWidth,f=y.scrollHeight,p=B(y),m=x<u&&("auto"===p.overflowX||"scroll"===p.overflowX),b=N<f&&("auto"===p.overflowY||"scroll"===p.overflowY),w=y.scrollLeft,y.scrollTop):(u=ut.documentElement.scrollWidth,f=ut.documentElement.scrollHeight,p=B(ut.documentElement),m=x<u&&("auto"===p.overflowX||"scroll"===p.overflowX||"visible"===p.overflowX),b=N<f&&("auto"===p.overflowY||"scroll"===p.overflowY||"visible"===p.overflowY),w=ut.documentElement.scrollLeft,ut.documentElement.scrollTop),g=m&&(vt(E-l)<=r&&w+x<u)-(vt(T-l)<=r&&!!w),v=b&&(vt(C-s)<=r&&_+N<f)-(vt(S-s)<=r&&!!_),!I[d])for(var X=0;X<=d;X++)I[X]||(I[X]={});I[d].vx==g&&I[d].vy==v&&I[d].el===y||(I[d].el=y,I[d].vx=g,I[d].vy=v,clearInterval(I[d].pid),!y||0==g&&0==v||(c=!0,I[d].pid=setInterval(function(){o&&0===this.layer&&_t.active._emulateDragOver(!0);var t=I[this.layer].vy?I[this.layer].vy*a:0,e=I[this.layer].vx?I[this.layer].vx*a:0;"function"==typeof k&&"continue"!==k.call(i,e,t,n,P,I[this.layer].el)||(I[this.layer].el===ht?ht.scrollTo(ht.pageXOffset+e,ht.pageYOffset+t):(I[this.layer].el.scrollTop+=t,I[this.layer].el.scrollLeft+=e))}.bind({layer:d}),24))),d++}while(t.bubbleScroll&&h!==ht&&(h=mt(h,!1)));at=c}},30),A=function(){I.forEach(function(t){clearInterval(t.pid)}),I=[]},C=function(t){function s(a,l){return function(t,e,n,o){var i=t.options.group.name&&e.options.group.name&&t.options.group.name===e.options.group.name;if(null==a&&(l||i))return!0;if(null==a||!1===a)return!1;if(l&&"clone"===a)return a;if("function"==typeof a)return s(a(t,e,n,o),l)(t,e,n,o);var r=(l?t:e).options.group.name;return!0===a||"string"==typeof a&&a===r||a.join&&-1<a.indexOf(r)}}var e={},n=t.group;n&&"object"==typeof n||(n={name:n}),e.name=n.name,e.checkPull=s(n.pull,!0),e.checkPut=s(n.put),e.revertClone=n.revertClone,t.group=e},T=function(t){V&&V.parentNode&&V.parentNode[dt]&&V.parentNode[dt]._computeIsAligned(t)},bt=function(t,e){for(var n=e;!n[dt];)n=n.parentNode;return t===n},wt=function(t,e,n){for(var o=t.parentNode;o&&!o[dt];)o=o.parentNode;o&&o[dt][n](U(e,{artificialBubble:!0}))},E=function(){!b&&G&&B(G,"display","none")},x=function(){!b&&G&&B(G,"display","")};ut.addEventListener("click",function(t){if(lt)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),lt=!1},!0);var N,t=function(t){if(t=t.touches?t.touches[0]:t,V){var e=function(t,e){for(var n=0;n<d.length;n++)if(!d[n].children.length){var o=Mt(d[n]),i=d[n][dt].options.emptyInsertThreshold,r=t>=o.left-i&&t<=o.right+i,a=e>=o.top-i&&e<=o.bottom+i;if(r&&a)return d[n]}}(t.clientX,t.clientY);e&&e[dt]._onDragOver({clientX:t.clientX,clientY:t.clientY,target:e,rootEl:e})}};function _t(t,e){if(!t||!t.nodeType||1!==t.nodeType)throw"Sortable: `el` must be HTMLElement, not "+{}.toString.call(t);this.el=t,this.options=e=U({},e),t[dt]=this;var n={group:null,sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0,draggable:/[uo]l/i.test(t.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return D(t,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,touchStartThreshold:g(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==_t.supportPointer&&("PointerEvent"in window||window.navigator&&"msPointerEnabled"in window.navigator),emptyInsertThreshold:5};for(var o in n)!(o in e)&&(e[o]=n[o]);for(var i in C(e),this)"_"===i.charAt(0)&&"function"==typeof this[i]&&(this[i]=this[i].bind(this));this.nativeDraggable=!e.forceFallback&&a,e.supportPointer?X(t,"pointerdown",this._onTapStart):(X(t,"mousedown",this._onTapStart),X(t,"touchstart",this._onTapStart)),this.nativeDraggable&&(X(t,"dragover",this),X(t,"dragenter",this)),d.push(this.el),e.store&&e.store.get&&this.sort(e.store.get(this)||[])}function yt(t,e,n,o){if(t){n=n||ut;do{if(null!=e&&(">"===e[0]&&t.parentNode===n&&z(t,e.substring(1))||z(t,e))||o&&t===n)return t;if(t===n)break}while(t=(i=t).host&&i!==ut&&i.host.nodeType?i.host:i.parentNode)}var i;return null}function X(t,e,n){t.addEventListener(e,n,r)}function O(t,e,n){t.removeEventListener(e,n,r)}function Dt(t,e,n){if(t&&e)if(t.classList)t.classList[n?"add":"remove"](e);else{var o=(" "+t.className+" ").replace(i," ").replace(" "+e+" "," ");t.className=(o+(n?" "+e:"")).replace(i," ")}}function B(t,e,n){var o=t&&t.style;if(o){if(void 0===n)return ut.defaultView&&ut.defaultView.getComputedStyle?n=ut.defaultView.getComputedStyle(t,""):t.currentStyle&&(n=t.currentStyle),void 0===e?n:n[e];e in o||-1!==e.indexOf("webkit")||(e="-webkit-"+e),o[e]=n+("string"==typeof n?"":"px")}}function H(t){var e="";do{var n=B(t,"transform");n&&"none"!==n&&(e=n+" "+e)}while(t=t.parentNode);return window.DOMMatrix?new DOMMatrix(e):window.WebKitCSSMatrix?new WebKitCSSMatrix(e):window.CSSMatrix?new CSSMatrix(e):void 0}function R(t,e,n){if(t){var o=t.getElementsByTagName(e),i=0,r=o.length;if(n)for(;i<r;i++)n(o[i],i);return o}return[]}function St(t,e,n,o,i,r,a,l,s){var c,d=(t=t||e[dt]).options,h="on"+n.charAt(0).toUpperCase()+n.substr(1);!window.CustomEvent||pt||v?(c=ut.createEvent("Event")).initEvent(n,!0,!0):c=new CustomEvent(n,{bubbles:!0,cancelable:!0}),c.to=i||e,c.from=r||e,c.item=o||e,c.clone=u,c.oldIndex=a,c.newIndex=l,c.originalEvent=s,e&&e.dispatchEvent(c),d[h]&&d[h].call(t,c)}function Ct(t,e,n,o,i,r,a,l){var s,c,d=t[dt],h=d.options.onMove;return!window.CustomEvent||pt||v?(s=ut.createEvent("Event")).initEvent("move",!0,!0):s=new CustomEvent("move",{bubbles:!0,cancelable:!0}),s.to=e,s.from=t,s.dragged=n,s.draggedRect=o,s.related=i||e,s.relatedRect=r||Mt(e),s.willInsertAfter=l,s.originalEvent=a,t.dispatchEvent(s),h&&(c=h.call(d,s,a)),c}function L(t){t.draggable=!1}function Tt(){gt=!1}function W(t,e,n){for(var o=0,i=0,r=t.children;i<r.length;){if("none"!==r[i].style.display&&r[i]!==G&&r[i]!==V&&yt(r[i],n.draggable,t,!1)){if(o===e)return r[i];o++}i++}return null}function Et(t){for(var e=t.lastElementChild;(e===G||"none"===e.style.display)&&(e=e.previousElementSibling););return e||null}function F(t){for(var e=t.tagName+t.className+t.src+t.href+t.textContent,n=e.length,o=0;n--;)o+=e.charCodeAt(n);return o.toString(36)}function xt(t,e){var n=0;if(!t||!t.parentNode)return-1;for(;t&&(t=t.previousElementSibling);)"TEMPLATE"!==t.nodeName.toUpperCase()&&t!==u&&n++;return n}function z(t,e){if(t)try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return!1}return!1}function j(n,o){return function(){if(!N){var t=arguments,e=this;N=ft(function(){1===t.length?n.call(e,t[0]):n.apply(e,t),N=void 0},o)}}}function U(t,e){if(t&&e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function Nt(t){return n&&n.dom?n.dom(t).cloneNode(!0):e?e(t).clone(!0)[0]:t.cloneNode(!0)}function Xt(t){return ft(t,0)}function Yt(t){return clearTimeout(t)}function Mt(t,e,n){if(t.getBoundingClientRect||t===ht){var o,i,r,a,l,s,c;if(c=t!==ht?(i=(o=t.getBoundingClientRect()).top,r=o.left,a=o.bottom,l=o.right,s=o.height,o.width):(r=i=0,a=window.innerHeight,l=window.innerWidth,s=window.innerHeight,window.innerWidth),n&&t!==ht){if(e=e||t.parentNode,!pt)do{if(e&&e.getBoundingClientRect&&"none"!==B(e,"transform")){var d=e.getBoundingClientRect();i-=d.top+g(B(e,"border-top-width")),r-=d.left+g(B(e,"border-left-width")),a=i+o.height,l=r+o.width;break}}while(e=e.parentNode);var h=H(t),u=h&&h.a,f=h&&h.d;h&&(a=(i/=f)+(s/=f),l=(r/=u)+(c/=u))}return{top:i,left:r,bottom:a,right:l,width:c,height:s}}}return X(ut,"dragover",t),X(ut,"mousemove",t),X(ut,"touchmove",t),_t.prototype={constructor:_t,_computeIsAligned:function(t){var e;if(G&&!b?(E(),e=ut.elementFromPoint(t.clientX,t.clientY),x()):e=t.target,e=yt(e,this.options.draggable,this.el,!1),!w&&V&&V.parentNode===this.el){for(var n,o,i,r,a,l,s,c,d=this.el.children,h=0;h<d.length;h++)yt(d[h],this.options.draggable,this.el,!1)&&d[h]!==e&&(d[h].sortableMouseAligned=(n=t.clientX,o=t.clientY,i=d[h],r=this._getDirection(t,null),this.options,void 0,a=Mt(i),l="vertical"===r?a.left:a.top,s="vertical"===r?a.right:a.bottom,l<(c="vertical"===r?n:o)&&c<s));yt(e,this.options.draggable,this.el,!0)||(et=null),w=!0,ft(function(){w=!1},30)}},_getDirection:function(t,e){return"function"==typeof this.options.direction?this.options.direction.call(this,t,e,V):this.options.direction},_onTapStart:function(t){if(t.cancelable){var e,n=this,o=this.el,i=this.options,r=i.preventOnFilter,a=t.type,l=t.touches&&t.touches[0],s=(l||t).target,c=t.target.shadowRoot&&(t.path&&t.path[0]||t.composedPath&&t.composedPath()[0])||s,d=i.filter;if(function(t){y.length=0;var e=t.getElementsByTagName("input"),n=e.length;for(;n--;){var o=e[n];o.checked&&y.push(o)}}(o),(!pt||t.artificialBubble||bt(o,s))&&!V&&!(/mousedown|pointerdown/.test(a)&&0!==t.button||i.disabled||c.isContentEditable))if(s=yt(s,i.draggable,o,!1)){if(h!==s){if(e=xt(s,i.draggable),"function"==typeof d){if(d.call(this,t,s,this))return St(n,c,"filter",s,o,o,e),void(r&&t.cancelable&&t.preventDefault())}else if(d&&(d=d.split(",").some(function(t){if(t=yt(c,t.trim(),o,!1))return St(n,t,"filter",s,o,o,e),!0})))return void(r&&t.cancelable&&t.preventDefault());i.handle&&!yt(c,i.handle,o,!1)||this._prepareDragStart(t,l,s,e)}}else pt&&wt(o,t,"_onTapStart")}},_handleAutoScroll:function(e,n){if(V&&this.options.scroll){var o=e.clientX,i=e.clientY,t=ut.elementFromPoint(o,i),r=this;if(n||v||pt){S(e,r.options,t,n);var a=mt(t,!0);!at||l&&o===s&&i===c||(l&&clearInterval(l),l=setInterval(function(){if(V){var t=mt(ut.elementFromPoint(o,i),!0);t!==a&&(a=t,A(),S(e,r.options,a,n))}},10),s=o,c=i)}else{if(!r.options.bubbleScroll||mt(t,!0)===window)return void A();S(e,r.options,mt(t,!1),!1)}}},_prepareDragStart:function(t,e,n,o){var i,r=this,a=r.el,l=r.options,s=a.ownerDocument;n&&!V&&n.parentNode===a&&(K=a,q=(V=n).parentNode,Z=V.nextSibling,h=n,J=l.group,Q=o,f={target:V,clientX:(e||t).clientX,clientY:(e||t).clientY},this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,V.style["will-change"]="all",V.style.transition="",V.style.transform="",i=function(){r._disableDelayedDrag(),V.draggable=r.nativeDraggable,r._triggerDragStart(t,e),St(r,K,"choose",V,K,K,Q),Dt(V,l.chosenClass,!0)},l.ignore.split(",").forEach(function(t){R(V,t.trim(),L)}),l.supportPointer?X(s,"pointerup",r._onDrop):(X(s,"mouseup",r._onDrop),X(s,"touchend",r._onDrop),X(s,"touchcancel",r._onDrop)),l.delay?(X(s,"mouseup",r._disableDelayedDrag),X(s,"touchend",r._disableDelayedDrag),X(s,"touchcancel",r._disableDelayedDrag),X(s,"mousemove",r._delayedDragTouchMoveHandler),X(s,"touchmove",r._delayedDragTouchMoveHandler),l.supportPointer&&X(s,"pointermove",r._delayedDragTouchMoveHandler),r._dragStartTimer=ft(i,l.delay)):i())},_delayedDragTouchMoveHandler:function(t){var e=t.touches?t.touches[0]:t;_(vt(e.clientX-this._lastX),vt(e.clientY-this._lastY))>=this.options.touchStartThreshold&&this._disableDelayedDrag()},_disableDelayedDrag:function(){var t=this.el.ownerDocument;clearTimeout(this._dragStartTimer),O(t,"mouseup",this._disableDelayedDrag),O(t,"touchend",this._disableDelayedDrag),O(t,"touchcancel",this._disableDelayedDrag),O(t,"mousemove",this._delayedDragTouchMoveHandler),O(t,"touchmove",this._delayedDragTouchMoveHandler),O(t,"pointermove",this._delayedDragTouchMoveHandler)},_triggerDragStart:function(t,e){e=e||("touch"==t.pointerType?t:null),!this.nativeDraggable||e?this.options.supportPointer?X(ut,"pointermove",this._onTouchMove):X(ut,e?"touchmove":"mousemove",this._onTouchMove):(X(V,"dragend",this),X(K,"dragstart",this._onDragStart));try{ut.selection?Xt(function(){ut.selection.empty()}):window.getSelection().removeAllRanges()}catch(t){}},_dragStarted:function(t){if(p=!1,K&&V){this.nativeDraggable&&(X(ut,"dragover",this._handleAutoScroll),X(ut,"dragover",T));var e=this.options;!t&&Dt(V,e.dragClass,!1),Dt(V,e.ghostClass,!0),B(V,"transform",""),_t.active=this,t&&this._appendGhost(),St(this,K,"start",V,K,K,Q)}else this._nulling()},_emulateDragOver:function(t){if(P){if(this._lastX===P.clientX&&this._lastY===P.clientY&&!t)return;this._lastX=P.clientX,this._lastY=P.clientY,E();for(var e=ut.elementFromPoint(P.clientX,P.clientY),n=e;e&&e.shadowRoot;)n=e=e.shadowRoot.elementFromPoint(P.clientX,P.clientY);if(n)do{if(n[dt])if(n[dt]._onDragOver({clientX:P.clientX,clientY:P.clientY,target:e,rootEl:n})&&!this.options.dragoverBubble)break;e=n}while(n=n.parentNode);V.parentNode[dt]._computeIsAligned(P),x()}},_onTouchMove:function(t){if(f){var e=this.options,n=e.fallbackTolerance,o=e.fallbackOffset,i=t.touches?t.touches[0]:t,r=G&&H(G),a=G&&r&&r.a,l=G&&r&&r.d,s=(i.clientX-f.clientX+o.x)/(a||1),c=(i.clientY-f.clientY+o.y)/(l||1),d=t.touches?"translate3d("+s+"px,"+c+"px,0)":"translate("+s+"px,"+c+"px)";if(!_t.active&&!p){if(n&&_(vt(i.clientX-this._lastX),vt(i.clientY-this._lastY))<n)return;this._onDragStart(t,!0)}this._handleAutoScroll(i,!0),tt=!0,P=i,B(G,"webkitTransform",d),B(G,"mozTransform",d),B(G,"msTransform",d),B(G,"transform",d),t.cancelable&&t.preventDefault()}},_appendGhost:function(){if(!G){var t=Mt(V,this.options.fallbackOnBody?ut.body:K,!0),e=(B(V),this.options);Dt(G=V.cloneNode(!0),e.ghostClass,!1),Dt(G,e.fallbackClass,!0),Dt(G,e.dragClass,!0),B(G,"box-sizing","border-box"),B(G,"margin",0),B(G,"top",t.top),B(G,"left",t.left),B(G,"width",t.width),B(G,"height",t.height),B(G,"opacity","0.8"),B(G,"position","fixed"),B(G,"zIndex","100000"),B(G,"pointerEvents","none"),e.fallbackOnBody&&ut.body.appendChild(G)||K.appendChild(G)}},_onDragStart:function(t,e){var n=this,o=t.dataTransfer,i=n.options;(u=Nt(V)).draggable=!1,u.style["will-change"]="",this._hideClone(),Dt(u,n.options.chosenClass,!1),n._cloneId=Xt(function(){n.options.removeCloneOnHide||K.insertBefore(u,V),St(n,K,"clone",V)}),!e&&Dt(V,i.dragClass,!0),e?(lt=!0,n._loopId=setInterval(n._emulateDragOver,50)):(O(ut,"mouseup",n._onDrop),O(ut,"touchend",n._onDrop),O(ut,"touchcancel",n._onDrop),o&&(o.effectAllowed="move",i.setData&&i.setData.call(n,o,V)),X(ut,"drop",n),B(V,"transform","translateZ(0)")),p=!0,n._dragStartId=Xt(n._dragStarted.bind(n,e)),X(ut,"selectstart",n)},_onDragOver:function(t){var e,n,o,i=this.el,r=t.target,a=this.options,l=a.group,s=_t.active,c=J===l,d=a.sort,h=this;if(!gt&&(!pt||t.rootEl||t.artificialBubble||bt(i,r))){if(void 0!==t.preventDefault&&t.cancelable&&t.preventDefault(),tt=!0,r=yt(r,a.draggable,i,!0),yt(t.target,null,V,!0)||r.animated)return j();if(r!==V&&(lt=!1),s&&!a.disabled&&(c?d||(o=!K.contains(V)):$===this||(this.lastPutMode=J.checkPull(this,s,V,t))&&l.checkPut(this,s,V,t))){var u=this._getDirection(t,r);if(e=Mt(V),o)return this._hideClone(),q=K,Z?K.insertBefore(V,Z):K.appendChild(V),j();if(0===i.children.length||i.children[0]===G||(O=t,B=u,H=Mt(Et(i)),R="vertical"===B?O.clientY:O.clientX,L="vertical"===B?O.clientX:O.clientY,W="vertical"===B?H.bottom:H.right,F="vertical"===B?H.left:H.top,z="vertical"===B?H.right:H.bottom,("vertical"===B?z+10<L||L<=z&&W<R&&F<=L:W<R&&F<L||R<=W&&z+10<L)&&!V.animated)){if(0!==i.children.length&&i.children[0]!==G&&i===t.target&&(r=Et(i)),r&&(n=Mt(r)),c?s._hideClone():s._showClone(this),!1!==Ct(K,i,V,e,r,n,t,!!r))return i.appendChild(V),q=i,rt=null,U(),this._animate(e,V),r&&this._animate(n,r),j()}else if(r&&r!==V&&r.parentNode===i){var f,p=0,g=r.sortableMouseAligned,v=V.parentNode!==i,m=function(t,e){var n=mt(n,!0),o=Mt(t)[e];for(;n;){var i=Mt(n)[e];if(!("top"===e||"left"===e?i<=o:o<=i))return!0;if(n===ht)break;n=mt(n,!1)}return!1}(r,"vertical"===u?"top":"left");if(et!==r&&(ot=null,f=Mt(r)["vertical"===u?"top":"left"],st=!1),E=r,x=u,N=(T=V)===V&&rt||Mt(T),X=E===V&&rt||Mt(E),Y="vertical"===x?N.left:N.top,M="vertical"===x?N.right:N.bottom,k="vertical"===x?N.width:N.height,P="vertical"===x?X.left:X.top,I="vertical"===x?X.right:X.bottom,A="vertical"===x?X.width:X.height,ot=(Y===P||M===I||Y+k/2===P+A/2)&&g||v||m||a.invertSwap||"insert"===ot||"swap"===ot?("swap"!==ot&&(ct=a.invertSwap||v||at||m),p=function(t,e,n,o,i,r,a){var l=Mt(e),s="vertical"===n?t.clientY:t.clientX,c="vertical"===n?l.height:l.width,d="vertical"===n?l.top:l.left,h="vertical"===n?l.bottom:l.right,u=Mt(V),f=!1;if(!r)if(a&&it<c*o)if(!st&&(1===nt?d+c*i/2<s:s<h-c*i/2)&&(st=!0),st)f=!0;else{"vertical"===n?u.top:u.left,"vertical"===n?u.bottom:u.right;if(1===nt?s<d+it:h-it<s)return-1*nt}else if(d+c*(1-o)/2<s&&s<h-c*(1-o)/2)return d+c/2<s?-1:1;if((f=f||r)&&(s<d+c*i/2||h-c*i/2<s))return d+c/2<s?1:-1;return 0}(t,r,u,a.swapThreshold,null==a.invertedSwapThreshold?a.swapThreshold:a.invertedSwapThreshold,ct,et===r),"swap"):(y=r,S=xt(V,(D=a).draggable),C=xt(y,D.draggable),p=S<C?1:-1,"insert"),0===p)return j();rt=null,nt=p,n=Mt(et=r);var b=r.nextElementSibling,w=!1,_=Ct(K,i,V,e,r,n,t,w=1===p);if(!1!==_)return 1!==_&&-1!==_||(w=1===_),gt=!0,ft(Tt,30),c?s._hideClone():s._showClone(this),w&&!b?i.appendChild(V):r.parentNode.insertBefore(V,w?b:r),q=V.parentNode,void 0===f||ct||(it=vt(f-Mt(r)["vertical"===u?"top":"left"])),U(),!v&&this._animate(n,r),this._animate(e,V),j()}if(i.contains(V))return j()}var y,D,S,C,T,E,x,N,X,Y,M,k,P,I,A,O,B,H,R,L,W,F,z;return pt&&!t.rootEl&&wt(i,t,"_onDragOver"),!1}function j(){return s&&(Dt(V,$?$.options.ghostClass:s.options.ghostClass,!1),Dt(V,a.ghostClass,!0)),$!==h&&h!==_t.active?$=h:h===_t.active&&($=null),(r===V&&!V.animated||r===i&&!r.animated)&&(et=null),a.dragoverBubble||t.rootEl||r===ut||(h._handleAutoScroll(t),V.parentNode[dt]._computeIsAligned(t)),!a.dragoverBubble&&t.stopPropagation&&t.stopPropagation(),!0}function U(){St(h,K,"change",r,i,K,Q,xt(V,a.draggable),t)}},_animate:function(t,e){var n=this.options.animation;if(n){var o=Mt(e);if(e===V&&(rt=o),1===t.nodeType&&(t=Mt(t)),t.left+t.width/2!==o.left+o.width/2||t.top+t.height/2!==o.top+o.height/2){var i=H(this.el),r=i&&i.a,a=i&&i.d;B(e,"transition","none"),B(e,"transform","translate3d("+(t.left-o.left)/(r||1)+"px,"+(t.top-o.top)/(a||1)+"px,0)"),e.offsetWidth,B(e,"transition","transform "+n+"ms"+(this.options.easing?" "+this.options.easing:"")),B(e,"transform","translate3d(0,0,0)")}"number"==typeof e.animated&&clearTimeout(e.animated),e.animated=ft(function(){B(e,"transition",""),B(e,"transform",""),e.animated=!1},n)}},_offUpEvents:function(){var t=this.el.ownerDocument;O(ut,"touchmove",this._onTouchMove),O(ut,"pointermove",this._onTouchMove),O(t,"mouseup",this._onDrop),O(t,"touchend",this._onDrop),O(t,"pointerup",this._onDrop),O(t,"touchcancel",this._onDrop),O(ut,"selectstart",this)},_onDrop:function(t){var e=this.el,n=this.options;st=ct=at=p=!1,clearInterval(this._loopId),clearInterval(l),A(),clearTimeout(N),N=void 0,clearTimeout(this._dragStartTimer),Yt(this._cloneId),Yt(this._dragStartId),O(ut,"mousemove",this._onTouchMove),this.nativeDraggable&&(O(ut,"drop",this),O(e,"dragstart",this._onDragStart),O(ut,"dragover",this._handleAutoScroll),O(ut,"dragover",T)),this._offUpEvents(),t&&(tt&&(t.cancelable&&t.preventDefault(),!n.dropBubble&&t.stopPropagation()),G&&G.parentNode&&G.parentNode.removeChild(G),(K===q||$&&"clone"!==$.lastPutMode)&&u&&u.parentNode&&u.parentNode.removeChild(u),V&&(this.nativeDraggable&&O(V,"dragend",this),L(V),V.style["will-change"]="",Dt(V,$?$.options.ghostClass:this.options.ghostClass,!1),Dt(V,this.options.chosenClass,!1),St(this,K,"unchoose",V,q,K,Q,null,t),K!==q?(0<=(o=xt(V,n.draggable))&&(St(null,q,"add",V,q,K,Q,o,t),St(this,K,"remove",V,q,K,Q,o,t),St(null,q,"sort",V,q,K,Q,o,t),St(this,K,"sort",V,q,K,Q,o,t)),$&&$.save()):V.nextSibling!==Z&&0<=(o=xt(V,n.draggable))&&(St(this,K,"update",V,q,K,Q,o,t),St(this,K,"sort",V,q,K,Q,o,t)),_t.active&&(null!=o&&-1!==o||(o=Q),St(this,K,"end",V,q,K,Q,o,t),this.save()))),this._nulling()},_nulling:function(){K=V=q=G=Z=u=h=Y=M=I.length=l=s=c=f=P=tt=o=Q=et=nt=rt=$=J=_t.active=null,y.forEach(function(t){t.checked=!0}),y.length=0},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":V&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="none");t.cancelable&&t.preventDefault()}(t));break;case"selectstart":t.preventDefault()}},toArray:function(){for(var t,e=[],n=this.el.children,o=0,i=n.length,r=this.options;o<i;o++)yt(t=n[o],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||F(t));return e},sort:function(t){var o={},i=this.el;this.toArray().forEach(function(t,e){var n=i.children[e];yt(n,this.options.draggable,i,!1)&&(o[t]=n)},this),t.forEach(function(t){o[t]&&(i.removeChild(o[t]),i.appendChild(o[t]))})},save:function(){var t=this.options.store;t&&t.set&&t.set(this)},closest:function(t,e){return yt(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var n=this.options;if(void 0===e)return n[t];n[t]=e,"group"===t&&C(n)},destroy:function(){var t=this.el;t[dt]=null,O(t,"mousedown",this._onTapStart),O(t,"touchstart",this._onTapStart),O(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(O(t,"dragover",this),O(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable")}),this._onDrop(),d.splice(d.indexOf(this.el),1),this.el=t=null},_hideClone:function(){u.cloneHidden||(B(u,"display","none"),u.cloneHidden=!0,u.parentNode&&this.options.removeCloneOnHide&&u.parentNode.removeChild(u))},_showClone:function(t){"clone"===t.lastPutMode?u.cloneHidden&&(K.contains(V)&&!this.options.group.revertClone?K.insertBefore(u,V):Z?K.insertBefore(u,Z):K.appendChild(u),this.options.group.revertClone&&this._animate(V,u),B(u,"display",""),u.cloneHidden=!1):this._hideClone()}},X(ut,"touchmove",function(t){(_t.active||p)&&t.cancelable&&t.preventDefault()}),_t.utils={on:X,off:O,css:B,find:R,is:function(t,e){return!!yt(t,e,t,!1)},extend:U,throttle:j,closest:yt,toggleClass:Dt,clone:Nt,index:xt,nextTick:Xt,cancelNextTick:Yt,detectDirection:D,getChild:W},_t.create=function(t,e){return new _t(t,e)},_t.version="1.8.2",_t});
var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=['<table style="border:0;border-collapse:collapse;">'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+';"></td>');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();
(function (n) { n([], function () { var f = -1, e = -2, i = -3, n = -4, r = -5, h = function (s, h) { var l, c, a; h = h || {}; l = h.verbose || !1; l && console.log("Normalize the JSON Object"); s = typeof s == "string" ? this.JSON.parse(s) : s; l && console.log("Creating a empty dictionary"); c = { strings: [], integers: [], floats: [] }; l && console.log("Creating the AST"); var y = function v(s) { var y, w, a, p, h; if (l && console.log("Calling recursiveAstBuilder with " + this.JSON.stringify(s)), y = typeof s, s === null) return { type: "null", index: i }; if (typeof s == "undefined") return { type: "undefined", index: r }; if (s instanceof Array) { a = ["@"]; for (w in s) s.hasOwnProperty(w) && a.push(v(s[w])); return a } if (y === "object") { a = ["$"]; for (p in s) s.hasOwnProperty(p) && (a.push(v(p)), a.push(v(s[p]))); return a } if (s === "") return { type: "empty", index: n }; if (y === "string") return h = u.call(c.strings, s), h == -1 && (c.strings.push(o(s)), h = c.strings.length - 1), { type: "strings", index: h }; if (y === "number" && s % 1 == 0) return h = u.call(c.integers, s), h == -1 && (c.integers.push(t(s)), h = c.integers.length - 1), { type: "integers", index: h }; if (y === "number") return h = u.call(c.floats, s), h == -1 && (c.floats.push(s), h = c.floats.length - 1), { type: "floats", index: h }; if (y === "boolean") return { type: "boolean", index: s ? f : e }; throw new Error("Unexpected argument of type " + typeof s); }(s), p = c.strings.length, w = c.integers.length, k = c.floats.length; return (l && console.log("Parsing the dictionary"), a = c.strings.join("|"), a += "^" + c.integers.join("|"), a += "^" + c.floats.join("|"), l && console.log("Parsing the structure"), a += "^" + function b(u) { var e, s, f, o; if (l && console.log("Calling a recursiveParser with " + this.JSON.stringify(u)), u instanceof Array) { e = u.shift(); for (s in u) u.hasOwnProperty(s) && (e += b(u[s]) + "|"); return (e[e.length - 1] === "|" ? e.slice(0, -1) : e) + "]" } if (f = u.type, o = u.index, f === "strings") return t(o); if (f === "integers") return t(p + o); if (f === "floats") return t(p + w + o); if (f === "boolean") return u.index; if (f === "null") return i; if (f === "undefined") return r; if (f === "empty") return n; throw new TypeError("The item is alien!"); }(y), l && console.log("Ending parser"), h.debug) ? { dictionary: c, ast: y, packed: a } : a }, c = function (t, u) { var p, v, o, w, h, a, k, c; if (u = u || {}, p = t.split("^"), u.verbose && console.log("Building dictionary"), v = [], o = p[0], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the strings dictionary"), h = 0, w = o.length; h < w; h++) v.push(l(o[h])); if (o = p[1], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the integers dictionary"), h = 0, w = o.length; h < w; h++) v.push(s(o[h])); if (o = p[2], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the floats dictionary"), h = 0, w = o.length; h < w; h++) v.push(parseFloat(o[h])); o = null; u.verbose && console.log("Tokenizing the structure"); var b = "", y = [], g = p[3].length; for (h = 0; h < g; h++) a = p[3].charAt(h), a === "|" || a === "$" || a === "@" || a === "]" ? (b && (y.push(s(b)), b = ""), a !== "|" && y.push(a)) : b += a; return k = y.length, c = 0, u.verbose && console.log("Starting recursive parser"), function d() { var h = y[c++], t, s, o; if (u.verbose && console.log("Reading collection type " + (h === "$" ? "object" : "Array")), h === "@") { for (t = []; c < k; c++) { if (o = y[c], u.verbose && console.log("Read " + o + " symbol"), o === "]") return t; if (o === "@" || o === "$") t.push(d()); else switch (o) { case f: t.push(!0); break; case e: t.push(!1); break; case i: t.push(null); break; case r: t.push(undefined); break; case n: t.push(""); break; default: t.push(v[o]) } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } if (h === "$") { for (t = {}; c < k; c++) { if (s = y[c], s === "]") return t; if (s = s === n ? "" : v[s], o = y[++c], o === "@" || o === "$") t[s] = d(); else switch (o) { case f: t[s] = !0; break; case e: t[s] = !1; break; case i: t[s] = null; break; case r: t[s] = undefined; break; case n: t[s] = ""; break; default: t[s] = v[o] } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } throw new TypeError("Bad token " + h + " isn't a type"); }() }, a = function (s, h) { var c = typeof h, l; if (c === "boolean") return h ? f : e; if (h === null) return i; if (typeof h == "undefined") return r; if (h === "") return n; if (c === "string" && (h = o(h), l = u.call(s.strings, h), l === -1 && (s.strings.push(h), l = s.strings.length - 1)), c !== "string" && c !== "number") throw new Error("The type is not a JSON type"); return c === "string" ? h = o(h) : h % 1 == 0 && (h = t(h)), h = c === "number" ? t(h) : o(h), l = u.call(s[c], h), l === -1 && (s[c].push(h), l = s[c].length - 1), c === "number" ? "+" + l : l }, o = function (n) { return typeof n != "string" ? n : n.replace(/[\+ \|\^\%]/g, function (n) { return { " ": "+", "+": "%2B", "|": "%7C", "^": "%5E", "%": "%25" }[n] }) }, l = function (n) { return typeof n != "string" ? n : n.replace(/\+|%2B|%7C|%5E|%25/g, function (n) { return { "+": " ", "%2B": "+", "%7C": "|", "%5E": "^", "%25": "%" }[n] }) }, t = function (n) { return Number.prototype.toString.call(n, 36).toUpperCase() }, s = function (n) { return parseInt(n, 36) }, u = Array.prototype.indexOf || function (n, t) { for (var i = t || 0, r = this.length; i < r; i++) if (this[i] === n) return i; return -1 }; return { JSON: JSON, pack: h, unpack: c } }) })(typeof define == "undefined" || !define.amd ? function (n, t) { var i = t(), r; if (typeof exports != "undefined") for (r in i) exports[r] = i[r]; else window.jsonpack = i } : define);
/*!
 * UAParser.js v0.7.19
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 or MIT
 */
(function(window,undefined){"use strict";var LIBVERSION="0.7.19",EMPTY="",UNKNOWN="?",FUNC_TYPE="function",UNDEF_TYPE="undefined",OBJ_TYPE="object",STR_TYPE="string",MAJOR="major",MODEL="model",NAME="name",TYPE="type",VENDOR="vendor",VERSION="version",ARCHITECTURE="architecture",CONSOLE="console",MOBILE="mobile",TABLET="tablet",SMARTTV="smarttv",WEARABLE="wearable",EMBEDDED="embedded";var util={extend:function(regexes,extensions){var margedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){margedRegexes[i]=extensions[i].concat(regexes[i])}else{margedRegexes[i]=regexes[i]}}return margedRegexes},has:function(str1,str2){if(typeof str1==="string"){return str2.toLowerCase().indexOf(str1.toLowerCase())!==-1}else{return false}},lowerize:function(str){return str.toLowerCase()},major:function(version){return typeof version===STR_TYPE?version.replace(/[^\d\.]/g,"").split(".")[0]:undefined},trim:function(str){return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}};var mapper={rgx:function(ua,arrays){var i=0,j,k,p,q,matches,match;while(i<arrays.length&&!matches){var regex=arrays[i],props=arrays[i+1];j=k=0;while(j<regex.length&&!matches){matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];if(typeof q===OBJ_TYPE&&q.length>0){if(q.length==2){if(typeof q[1]==FUNC_TYPE){this[q[0]]=q[1].call(this,match)}else{this[q[0]]=q[1]}}else if(q.length==3){if(typeof q[1]===FUNC_TYPE&&!(q[1].exec&&q[1].test)){this[q[0]]=match?q[1].call(this,match,q[2]):undefined}else{this[q[0]]=match?match.replace(q[1],q[2]):undefined}}else if(q.length==4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined}}else{this[q]=match?match:undefined}}}}i+=2}},str:function(str,map){for(var i in map){if(typeof map[i]===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(util.has(map[i][j],str)){return i===UNKNOWN?undefined:i}}}else if(util.has(map[i],str)){return i===UNKNOWN?undefined:i}}return str}};var maps={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}};var regexes={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[NAME,VERSION],[/(opios)[\/\s]+([\w\.]+)/i],[[NAME,"Opera Mini"],VERSION],[/\s(opr)\/([\w\.]+)/i],[[NAME,"Opera"],VERSION],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,/(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]*)/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i],[NAME,VERSION],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[NAME,"IE"],VERSION],[/(edge|edgios|edga)\/((\d+)?[\w\.]+)/i],[[NAME,"Edge"],VERSION],[/(yabrowser)\/([\w\.]+)/i],[[NAME,"Yandex"],VERSION],[/(puffin)\/([\w\.]+)/i],[[NAME,"Puffin"],VERSION],[/(focus)\/([\w\.]+)/i],[[NAME,"Firefox Focus"],VERSION],[/(opt)\/([\w\.]+)/i],[[NAME,"Opera Touch"],VERSION],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[NAME,"UCBrowser"],VERSION],[/(comodo_dragon)\/([\w\.]+)/i],[[NAME,/_/g," "],VERSION],[/(micromessenger)\/([\w\.]+)/i],[[NAME,"WeChat"],VERSION],[/(brave)\/([\w\.]+)/i],[[NAME,"Brave"],VERSION],[/(qqbrowserlite)\/([\w\.]+)/i],[NAME,VERSION],[/(QQ)\/([\d\.]+)/i],[NAME,VERSION],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(BIDUBrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(2345Explorer)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(MetaSr)[\/\s]?([\w\.]+)/i],[NAME],[/(LBBROWSER)/i],[NAME],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[VERSION,[NAME,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[VERSION,[NAME,"Facebook"]],[/safari\s(line)\/([\w\.]+)/i,/android.+(line)\/([\w\.]+)\/iab/i],[NAME,VERSION],[/headlesschrome(?:\/([\w\.]+)|\s)/i],[VERSION,[NAME,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[NAME,/(.+)/,"$1 WebView"],VERSION],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[NAME,/(.+(?:g|us))(.+)/,"$1 $2"],VERSION],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[VERSION,[NAME,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[NAME,VERSION],[/(dolfin)\/([\w\.]+)/i],[[NAME,"Dolphin"],VERSION],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[NAME,"Chrome"],VERSION],[/(coast)\/([\w\.]+)/i],[[NAME,"Opera Coast"],VERSION],[/fxios\/([\w\.-]+)/i],[VERSION,[NAME,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[VERSION,[NAME,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[VERSION,NAME],[/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[[NAME,"GSA"],VERSION],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[NAME,[VERSION,mapper.str,maps.browser.oldsafari.version]],[/(konqueror)\/([\w\.]+)/i,/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[/(navigator|netscape)\/([\w\.-]+)/i],[[NAME,"Netscape"],VERSION],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]*)/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[NAME,VERSION]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[[ARCHITECTURE,"amd64"]],[/(ia32(?=;))/i],[[ARCHITECTURE,util.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[[ARCHITECTURE,"ia32"]],[/windows\s(ce|mobile);\sppc;/i],[[ARCHITECTURE,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[[ARCHITECTURE,/ower/,"",util.lowerize]],[/(sun4\w)[;\)]/i],[[ARCHITECTURE,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[[ARCHITECTURE,util.lowerize]]],device:[[/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],[MODEL,VENDOR,[TYPE,TABLET]],[/applecoremedia\/[\w\.]+ \((ipad)/],[MODEL,[VENDOR,"Apple"],[TYPE,TABLET]],[/(apple\s{0,1}tv)/i],[[MODEL,"Apple TV"],[VENDOR,"Apple"]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(kf[A-z]+)\sbuild\/.+silk\//i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],[[MODEL,mapper.str,maps.device.amazon.model],[VENDOR,"Amazon"],[TYPE,MOBILE]],[/android.+aft([bms])\sbuild/i],[MODEL,[VENDOR,"Amazon"],[TYPE,SMARTTV]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[MODEL,VENDOR,[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);/i],[MODEL,[VENDOR,"Apple"],[TYPE,MOBILE]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/\(bb10;\s(\w+)/i],[MODEL,[VENDOR,"BlackBerry"],[TYPE,MOBILE]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],[MODEL,[VENDOR,"Asus"],[TYPE,TABLET]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[VENDOR,"Sony"],[MODEL,"Xperia Tablet"],[TYPE,TABLET]],[/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],[MODEL,[VENDOR,"Sony"],[TYPE,MOBILE]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[VENDOR,MODEL,[TYPE,CONSOLE]],[/android.+;\s(shield)\sbuild/i],[MODEL,[VENDOR,"Nvidia"],[TYPE,CONSOLE]],[/(playstation\s[34portablevi]+)/i],[MODEL,[VENDOR,"Sony"],[TYPE,CONSOLE]],[/(sprint\s(\w+))/i],[[VENDOR,mapper.str,maps.device.sprint.vendor],[MODEL,mapper.str,maps.device.sprint.model],[TYPE,MOBILE]],[/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,/(zte)-(\w*)/i,/(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],[VENDOR,[MODEL,/_/g," "],[TYPE,MOBILE]],[/(nexus\s9)/i],[MODEL,[VENDOR,"HTC"],[TYPE,TABLET]],[/d\/huawei([\w\s-]+)[;\)]/i,/(nexus\s6p)/i],[MODEL,[VENDOR,"Huawei"],[TYPE,MOBILE]],[/(microsoft);\s(lumia[\s\w]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[MODEL,[VENDOR,"Microsoft"],[TYPE,CONSOLE]],[/(kin\.[onetw]{3})/i],[[MODEL,/\./g," "],[VENDOR,"Microsoft"],[TYPE,MOBILE]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w*)/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[MODEL,[VENDOR,"Motorola"],[TYPE,MOBILE]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[MODEL,[VENDOR,"Motorola"],[TYPE,TABLET]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[VENDOR,util.trim],[MODEL,util.trim],[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,"SmartTV"],[VENDOR,"Samsung"],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i],[MODEL,[VENDOR,"Sharp"],[TYPE,SMARTTV]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,TABLET]],[/smart-tv.+(samsung)/i],[VENDOR,[TYPE,SMARTTV],MODEL],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,/sec-((sgh\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,MOBILE]],[/sie-(\w*)/i],[MODEL,[VENDOR,"Siemens"],[TYPE,MOBILE]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]*)/i],[[VENDOR,"Nokia"],MODEL,[TYPE,MOBILE]],[/android\s3\.[\s\w;-]{10}(a\d{3})/i],[MODEL,[VENDOR,"Acer"],[TYPE,TABLET]],[/android.+([vl]k\-?\d{3})\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,TABLET]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[VENDOR,"LG"],MODEL,[TYPE,TABLET]],[/(lg) netcast\.tv/i],[VENDOR,MODEL,[TYPE,SMARTTV]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w*)/i,/android.+lg(\-?[\d\w]+)\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,MOBILE]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[MODEL,[VENDOR,"Lenovo"],[TYPE,TABLET]],[/linux;.+((jolla));/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/((pebble))app\/[\d\.]+\s/i],[VENDOR,MODEL,[TYPE,WEARABLE]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/crkey/i],[[MODEL,"Chromecast"],[VENDOR,"Google"]],[/android.+;\s(glass)\s\d/i],[MODEL,[VENDOR,"Google"],[TYPE,WEARABLE]],[/android.+;\s(pixel c)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,TABLET]],[/android.+;\s(pixel( [23])?( xl)?)\s/i],[MODEL,[VENDOR,"Google"],[TYPE,MOBILE]],[/android.+;\s(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,/android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,MOBILE]],[/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,TABLET]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[MODEL,[VENDOR,"Meizu"],[TYPE,TABLET]],[/(mz)-([\w-]{2,})/i],[[VENDOR,"Meizu"],MODEL,[TYPE,MOBILE]],[/android.+a000(1)\s+build/i,/android.+oneplus\s(a\d{4})\s+build/i],[MODEL,[VENDOR,"OnePlus"],[TYPE,MOBILE]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[MODEL,[VENDOR,"RCA"],[TYPE,TABLET]],[/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],[MODEL,[VENDOR,"Dell"],[TYPE,TABLET]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[MODEL,[VENDOR,"Verizon"],[TYPE,TABLET]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],[[VENDOR,"Barnes & Noble"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[MODEL,[VENDOR,"NuVision"],[TYPE,TABLET]],[/android.+;\s(k88)\sbuild/i],[MODEL,[VENDOR,"ZTE"],[TYPE,TABLET]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[MODEL,[VENDOR,"Swiss"],[TYPE,MOBILE]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[MODEL,[VENDOR,"Swiss"],[TYPE,TABLET]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[MODEL,[VENDOR,"Zeki"],[TYPE,TABLET]],[/(android).+[;\/]\s+([YR]\d{2})\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],[[VENDOR,"Dragon Touch"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],[MODEL,[VENDOR,"Insignia"],[TYPE,TABLET]],[/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],[MODEL,[VENDOR,"NextBook"],[TYPE,TABLET]],[/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[VENDOR,"Voice"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],[[VENDOR,"LvTel"],MODEL,[TYPE,MOBILE]],[/android.+;\s(PH-1)\s/i],[MODEL,[VENDOR,"Essential"],[TYPE,MOBILE]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[MODEL,[VENDOR,"Envizen"],[TYPE,TABLET]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],[MODEL,[VENDOR,"MachSpeed"],[TYPE,TABLET]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[MODEL,[VENDOR,"Rotor"],[TYPE,TABLET]],[/android.+(KS(.+))\s+build/i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[TYPE,util.lowerize],VENDOR,MODEL],[/(android[\w\.\s\-]{0,9});.+build/i],[MODEL,[VENDOR,"Generic"]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[VERSION,[NAME,"EdgeHTML"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9}).+(gecko)/i],[VERSION,NAME]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[NAME,VERSION],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[NAME,[VERSION,mapper.str,maps.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[NAME,"Windows"],[VERSION,mapper.str,maps.os.windows.version]],[/\((bb)(10);/i],[[NAME,"BlackBerry"],VERSION],[/(blackberry)\w*\/?([\w\.]*)/i,/(tizen)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,/linux;.+(sailfish);/i],[NAME,VERSION],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],[[NAME,"Symbian"],VERSION],[/\((series40);/i],[NAME],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[NAME,"Firefox OS"],VERSION],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w*)/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,/(hurd|linux)\s?([\w\.]*)/i,/(gnu)\s?([\w\.]*)/i],[NAME,VERSION],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[NAME,"Chromium OS"],VERSION],[/(sunos)\s?([\w\.\d]*)/i],[[NAME,"Solaris"],VERSION],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],[NAME,VERSION],[/(haiku)\s(\w+)/i],[NAME,VERSION],[/cfnetwork\/.+darwin/i,/ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],[[VERSION,/_/g,"."],[NAME,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]*)/i,/(macintosh|mac(?=_powerpc)\s)/i],[[NAME,"Mac OS"],[VERSION,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]*)/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,/(unix)\s?([\w\.]*)/i],[NAME,VERSION]]};var UAParser=function(uastring,extensions){if(typeof uastring==="object"){extensions=uastring;uastring=undefined}if(!(this instanceof UAParser)){return new UAParser(uastring,extensions).getResult()}var ua=uastring||(window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:EMPTY);var rgxmap=extensions?util.extend(regexes,extensions):regexes;this.getBrowser=function(){var browser={name:undefined,version:undefined};mapper.rgx.call(browser,ua,rgxmap.browser);browser.major=util.major(browser.version);return browser};this.getCPU=function(){var cpu={architecture:undefined};mapper.rgx.call(cpu,ua,rgxmap.cpu);return cpu};this.getDevice=function(){var device={vendor:undefined,model:undefined,type:undefined};mapper.rgx.call(device,ua,rgxmap.device);return device};this.getEngine=function(){var engine={name:undefined,version:undefined};mapper.rgx.call(engine,ua,rgxmap.engine);return engine};this.getOS=function(){var os={name:undefined,version:undefined};mapper.rgx.call(os,ua,rgxmap.os);return os};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return ua};this.setUA=function(uastring){ua=uastring;return this};return this};UAParser.VERSION=LIBVERSION;UAParser.BROWSER={NAME:NAME,MAJOR:MAJOR,VERSION:VERSION};UAParser.CPU={ARCHITECTURE:ARCHITECTURE};UAParser.DEVICE={MODEL:MODEL,VENDOR:VENDOR,TYPE:TYPE,CONSOLE:CONSOLE,MOBILE:MOBILE,SMARTTV:SMARTTV,TABLET:TABLET,WEARABLE:WEARABLE,EMBEDDED:EMBEDDED};UAParser.ENGINE={NAME:NAME,VERSION:VERSION};UAParser.OS={NAME:NAME,VERSION:VERSION};if(typeof exports!==UNDEF_TYPE){if(typeof module!==UNDEF_TYPE&&module.exports){exports=module.exports=UAParser}exports.UAParser=UAParser}else{if(typeof define===FUNC_TYPE&&define.amd){define(function(){return UAParser})}else if(window){window.UAParser=UAParser}}var $=window&&(window.jQuery||window.Zepto);if(typeof $!==UNDEF_TYPE&&!$.ua){var parser=new UAParser;$.ua=parser.getResult();$.ua.get=function(){return parser.getUA()};$.ua.set=function(uastring){parser.setUA(uastring);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop]}}}})(typeof window==="object"?window:this);
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.proj4=b()}(this,function(){"use strict";function a(a,b){if(a[b])return a[b];for(var c,d,e=Object.keys(a),f=b.toLowerCase().replace(Ob,""),g=-1;++g<e.length;)if(c=e[g],d=c.toLowerCase().replace(Ob,""),d===f)return a[c]}function b(a){if("string"!=typeof a)throw new Error("not a string");this.text=a.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=Qb}function c(a){var c=new b(a);return c.output()}function d(a,b,c){Array.isArray(b)&&(c.unshift(b),b=null);var d=b?{}:a,f=c.reduce(function(a,b){return e(b,a),a},d);b&&(a[b]=f)}function e(a,b){if(!Array.isArray(a))return void(b[a]=!0);var c=a.shift();if("PARAMETER"===c&&(c=a.shift()),1===a.length)return Array.isArray(a[0])?(b[c]={},void e(a[0],b[c])):void(b[c]=a[0]);if(!a.length)return void(b[c]=!0);if("TOWGS84"===c)return void(b[c]=a);Array.isArray(c)||(b[c]={});var f;switch(c){case"UNIT":case"PRIMEM":case"VERT_DATUM":return b[c]={name:a[0].toLowerCase(),convert:a[1]},void(3===a.length&&e(a[2],b[c]));case"SPHEROID":case"ELLIPSOID":return b[c]={name:a[0],a:a[1],rf:a[2]},void(4===a.length&&e(a[3],b[c]));case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"EDATUM":case"ENGINEERINGDATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":case"COMPD_CS":case"COMPOUNDCRS":case"ENGINEERINGCRS":case"ENGCRS":case"FITTED_CS":case"LOCAL_DATUM":case"DATUM":return a[0]=["name",a[0]],void d(b,c,a);default:for(f=-1;++f<a.length;)if(!Array.isArray(a[f]))return e(a,b[c]);return d(b,c,a)}}function f(a,b){var c=b[0],d=b[1];!(c in a)&&d in a&&(a[c]=a[d],3===b.length&&(a[c]=b[2](a[c])))}function g(a){return a*_b}function h(a){function b(b){var c=a.to_meter||1;return b*c}"GEOGCS"===a.type?a.projName="longlat":"LOCAL_CS"===a.type?(a.projName="identity",a.local=!0):"object"==typeof a.PROJECTION?a.projName=Object.keys(a.PROJECTION)[0]:a.projName=a.PROJECTION,a.UNIT&&(a.units=a.UNIT.name.toLowerCase(),"metre"===a.units&&(a.units="meter"),a.UNIT.convert&&("GEOGCS"===a.type?a.DATUM&&a.DATUM.SPHEROID&&(a.to_meter=a.UNIT.convert*a.DATUM.SPHEROID.a):(a.to_meter=a.UNIT.convert,10)));var c=a.GEOGCS;"GEOGCS"===a.type&&(c=a),c&&(c.DATUM?a.datumCode=c.DATUM.name.toLowerCase():a.datumCode=c.name.toLowerCase(),"d_"===a.datumCode.slice(0,2)&&(a.datumCode=a.datumCode.slice(2)),"new_zealand_geodetic_datum_1949"!==a.datumCode&&"new_zealand_1949"!==a.datumCode||(a.datumCode="nzgd49"),"wgs_1984"===a.datumCode&&("Mercator_Auxiliary_Sphere"===a.PROJECTION&&(a.sphere=!0),a.datumCode="wgs84"),"_ferro"===a.datumCode.slice(-6)&&(a.datumCode=a.datumCode.slice(0,-6)),"_jakarta"===a.datumCode.slice(-8)&&(a.datumCode=a.datumCode.slice(0,-8)),~a.datumCode.indexOf("belge")&&(a.datumCode="rnb72"),c.DATUM&&c.DATUM.SPHEROID&&(a.ellps=c.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===a.ellps.toLowerCase().slice(0,13)&&(a.ellps="intl"),a.a=c.DATUM.SPHEROID.a,a.rf=parseFloat(c.DATUM.SPHEROID.rf,10)),~a.datumCode.indexOf("osgb_1936")&&(a.datumCode="osgb36")),a.b&&!isFinite(a.b)&&(a.b=a.a);var d=function(b){return f(a,b)},e=[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_2","Standard_Parallel_2"],["false_easting","False_Easting"],["false_northing","False_Northing"],["central_meridian","Central_Meridian"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",g],["longitude_of_center","Longitude_Of_Center"],["longc","longitude_of_center",g],["x0","false_easting",b],["y0","false_northing",b],["long0","central_meridian",g],["lat0","latitude_of_origin",g],["lat0","standard_parallel_1",g],["lat1","standard_parallel_1",g],["lat2","standard_parallel_2",g],["alpha","azimuth",g],["srsCode","name"]];e.forEach(d),a.long0||!a.longc||"Albers_Conic_Equal_Area"!==a.projName&&"Lambert_Azimuthal_Equal_Area"!==a.projName||(a.long0=a.longc),a.lat_ts||!a.lat1||"Stereographic_South_Pole"!==a.projName&&"Polar Stereographic (variant B)"!==a.projName||(a.lat0=g(a.lat1>0?90:-90),a.lat_ts=a.lat1)}function i(a){var b=this;if(2===arguments.length){var c=arguments[1];"string"==typeof c?"+"===c.charAt(0)?i[a]=Pb(arguments[1]):i[a]=ac(arguments[1]):i[a]=c}else if(1===arguments.length){if(Array.isArray(a))return a.map(function(a){Array.isArray(a)?i.apply(b,a):i(a)});if("string"==typeof a){if(a in i)return i[a]}else"EPSG"in a?i["EPSG:"+a.EPSG]=a:"ESRI"in a?i["ESRI:"+a.ESRI]=a:"IAU2000"in a?i["IAU2000:"+a.IAU2000]=a:console.log(a);return}}function j(a){return"string"==typeof a}function k(a){return a in i}function l(a){return bc.some(function(b){return a.indexOf(b)>-1})}function m(a){return"+"===a[0]}function n(a){return j(a)?k(a)?i[a]:l(a)?ac(a):m(a)?Pb(a):void 0:a}function o(){var a=this.b/this.a;this.es=1-a*a,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1)}function p(a){var b=a.x,c=a.y;if(c*Ib>90&&c*Ib<-90&&b*Ib>180&&b*Ib<-180)return null;var d,e;if(Math.abs(Math.abs(c)-Cb)<=Gb)return null;if(this.sphere)d=this.x0+this.a*this.k0*fc(b-this.long0),e=this.y0+this.a*this.k0*Math.log(Math.tan(Jb+.5*c));else{var f=Math.sin(c),g=gc(this.e,c,f);d=this.x0+this.a*this.k0*fc(b-this.long0),e=this.y0-this.a*this.k0*Math.log(g)}return a.x=d,a.y=e,a}function q(a){var b,c,d=a.x-this.x0,e=a.y-this.y0;if(this.sphere)c=Cb-2*Math.atan(Math.exp(-e/(this.a*this.k0)));else{var f=Math.exp(-e/(this.a*this.k0));if(c=hc(this.e,f),c===-9999)return null}return b=fc(this.long0+d/(this.a*this.k0)),a.x=b,a.y=c,a}function r(){}function s(a){return a}function t(a,b){var c=oc.length;return a.names?(oc[c]=a,a.names.forEach(function(a){nc[a.toLowerCase()]=c}),this):(console.log(b),!0)}function u(a){if(!a)return!1;var b=a.toLowerCase();return"undefined"!=typeof nc[b]&&oc[nc[b]]?oc[nc[b]]:void 0}function v(){mc.forEach(t)}function w(a,b,c,d){var e=a*a,f=b*b,g=(e-f)/e,h=0;d?(a*=1-g*(Db+g*(Eb+g*Fb)),e=a*a,g=0):h=Math.sqrt(g);var i=(e-f)/f;return{es:g,e:h,ep2:i}}function x(b,c,d,e,f){if(!b){var g=a(qc,e);g||(g=rc),b=g.a,c=g.b,d=g.rf}return d&&!c&&(c=(1-1/d)*b),(0===d||Math.abs(b-c)<Gb)&&(f=!0,c=b),{a:b,b:c,rf:d,sphere:f}}function y(a,b,c,d,e,f){var g={};return void 0===a||"none"===a?g.datum_type=Ab:g.datum_type=zb,b&&(g.datum_params=b.map(parseFloat),0===g.datum_params[0]&&0===g.datum_params[1]&&0===g.datum_params[2]||(g.datum_type=xb),g.datum_params.length>3&&(0===g.datum_params[3]&&0===g.datum_params[4]&&0===g.datum_params[5]&&0===g.datum_params[6]||(g.datum_type=yb,g.datum_params[3]*=Bb,g.datum_params[4]*=Bb,g.datum_params[5]*=Bb,g.datum_params[6]=g.datum_params[6]/1e6+1))),g.a=c,g.b=d,g.es=e,g.ep2=f,g}function z(b,c){if(!(this instanceof z))return new z(b);c=c||function(a){if(a)throw a};var d=n(b);if("object"!=typeof d)return void c(b);var e=z.projections.get(d.projName);if(!e)return void c(b);if(d.datumCode&&"none"!==d.datumCode){var f=a(sc,d.datumCode);f&&(d.datum_params=f.towgs84?f.towgs84.split(","):null,d.ellps=f.ellipse,d.datumName=f.datumName?f.datumName:d.datumCode)}d.k0=d.k0||1,d.axis=d.axis||"enu",d.ellps=d.ellps||"wgs84";var g=x(d.a,d.b,d.rf,d.ellps,d.sphere),h=w(g.a,g.b,g.rf,d.R_A),i=d.datum||y(d.datumCode,d.datum_params,g.a,g.b,h.es,h.ep2);cc(this,d),cc(this,e),this.a=g.a,this.b=g.b,this.rf=g.rf,this.sphere=g.sphere,this.es=h.es,this.e=h.e,this.ep2=h.ep2,this.datum=i,this.init(),c(null,this)}function A(a,b){return a.datum_type===b.datum_type&&(!(a.a!==b.a||Math.abs(a.es-b.es)>5e-11)&&(a.datum_type===xb?a.datum_params[0]===b.datum_params[0]&&a.datum_params[1]===b.datum_params[1]&&a.datum_params[2]===b.datum_params[2]:a.datum_type!==yb||a.datum_params[0]===b.datum_params[0]&&a.datum_params[1]===b.datum_params[1]&&a.datum_params[2]===b.datum_params[2]&&a.datum_params[3]===b.datum_params[3]&&a.datum_params[4]===b.datum_params[4]&&a.datum_params[5]===b.datum_params[5]&&a.datum_params[6]===b.datum_params[6]))}function B(a,b,c){var d,e,f,g,h=a.x,i=a.y,j=a.z?a.z:0;if(i<-Cb&&i>-1.001*Cb)i=-Cb;else if(i>Cb&&i<1.001*Cb)i=Cb;else if(i<-Cb||i>Cb)return null;return h>Math.PI&&(h-=2*Math.PI),e=Math.sin(i),g=Math.cos(i),f=e*e,d=c/Math.sqrt(1-b*f),{x:(d+j)*g*Math.cos(h),y:(d+j)*g*Math.sin(h),z:(d*(1-b)+j)*e}}function C(a,b,c,d){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=1e-12,v=u*u,w=30,x=a.x,y=a.y,z=a.z?a.z:0;if(e=Math.sqrt(x*x+y*y),f=Math.sqrt(x*x+y*y+z*z),e/c<u){if(r=0,f/c<u)return s=Cb,t=-d,{x:a.x,y:a.y,z:a.z}}else r=Math.atan2(y,x);g=z/f,h=e/f,i=1/Math.sqrt(1-b*(2-b)*h*h),l=h*(1-b)*i,m=g*i,q=0;do q++,k=c/Math.sqrt(1-b*m*m),t=e*l+z*m-k*(1-b*m*m),j=b*k/(k+t),i=1/Math.sqrt(1-j*(2-j)*h*h),n=h*(1-j)*i,o=g*i,p=o*l-n*m,l=n,m=o;while(p*p>v&&q<w);return s=Math.atan(o/Math.abs(n)),{x:r,y:s,z:t}}function D(a,b,c){if(b===xb)return{x:a.x+c[0],y:a.y+c[1],z:a.z+c[2]};if(b===yb){var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],i=c[5],j=c[6];return{x:j*(a.x-i*a.y+h*a.z)+d,y:j*(i*a.x+a.y-g*a.z)+e,z:j*(-h*a.x+g*a.y+a.z)+f}}}function E(a,b,c){if(b===xb)return{x:a.x-c[0],y:a.y-c[1],z:a.z-c[2]};if(b===yb){var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],i=c[5],j=c[6],k=(a.x-d)/j,l=(a.y-e)/j,m=(a.z-f)/j;return{x:k+i*l-h*m,y:-i*k+l+g*m,z:h*k-g*l+m}}}function F(a){return a===xb||a===yb}function G(a,b){return(a.datum.datum_type===xb||a.datum.datum_type===yb)&&"WGS84"!==b.datumCode||(b.datum.datum_type===xb||b.datum.datum_type===yb)&&"WGS84"!==a.datumCode}function H(a,b,c){var d;return Array.isArray(c)&&(c=vc(c)),a.datum&&b.datum&&G(a,b)&&(d=new z("WGS84"),c=H(a,d,c),a=d),"enu"!==a.axis&&(c=uc(a,!1,c)),"longlat"===a.projName?c={x:c.x*Hb,y:c.y*Hb}:(a.to_meter&&(c={x:c.x*a.to_meter,y:c.y*a.to_meter}),c=a.inverse(c)),a.from_greenwich&&(c.x+=a.from_greenwich),c=tc(a.datum,b.datum,c),b.from_greenwich&&(c={x:c.x-b.from_greenwich,y:c.y}),"longlat"===b.projName?c={x:c.x*Ib,y:c.y*Ib}:(c=b.forward(c),b.to_meter&&(c={x:c.x/b.to_meter,y:c.y/b.to_meter})),"enu"!==b.axis?uc(b,!0,c):c}function I(a,b,c){var d;return Array.isArray(c)?(d=H(a,b,c),3===c.length?[d.x,d.y,d.z]:[d.x,d.y]):H(a,b,c)}function J(a){return a instanceof z?a:a.oProj?a.oProj:z(a)}function K(a,b,c){a=J(a);var d,e=!1;return"undefined"==typeof b?(b=a,a=wc,e=!0):("undefined"!=typeof b.x||Array.isArray(b))&&(c=b,b=a,a=wc,e=!0),b=J(b),c?I(a,b,c):(d={forward:function(c){return I(a,b,c)},inverse:function(c){return I(b,a,c)}},e&&(d.oProj=b),d)}function L(a,b){return b=b||5,T(Q({lat:a[1],lon:a[0]}),b)}function M(a){var b=R(X(a.toUpperCase()));return b.lat&&b.lon?[b.lon,b.lat,b.lon,b.lat]:[b.left,b.bottom,b.right,b.top]}function N(a){var b=R(X(a.toUpperCase()));return b.lat&&b.lon?[b.lon,b.lat]:[(b.left+b.right)/2,(b.top+b.bottom)/2]}function O(a){return a*(Math.PI/180)}function P(a){return 180*(a/Math.PI)}function Q(a){var b,c,d,e,f,g,h,i,j,k=a.lat,l=a.lon,m=6378137,n=.00669438,o=.9996,p=O(k),q=O(l);j=Math.floor((l+180)/6)+1,180===l&&(j=60),k>=56&&k<64&&l>=3&&l<12&&(j=32),k>=72&&k<84&&(l>=0&&l<9?j=31:l>=9&&l<21?j=33:l>=21&&l<33?j=35:l>=33&&l<42&&(j=37)),b=6*(j-1)-180+3,i=O(b),c=n/(1-n),d=m/Math.sqrt(1-n*Math.sin(p)*Math.sin(p)),e=Math.tan(p)*Math.tan(p),f=c*Math.cos(p)*Math.cos(p),g=Math.cos(p)*(q-i),h=m*((1-n/4-3*n*n/64-5*n*n*n/256)*p-(3*n/8+3*n*n/32+45*n*n*n/1024)*Math.sin(2*p)+(15*n*n/256+45*n*n*n/1024)*Math.sin(4*p)-35*n*n*n/3072*Math.sin(6*p));var r=o*d*(g+(1-e+f)*g*g*g/6+(5-18*e+e*e+72*f-58*c)*g*g*g*g*g/120)+5e5,s=o*(h+d*Math.tan(p)*(g*g/2+(5-e+9*f+4*f*f)*g*g*g*g/24+(61-58*e+e*e+600*f-330*c)*g*g*g*g*g*g/720));return k<0&&(s+=1e7),{northing:Math.round(s),easting:Math.round(r),zoneNumber:j,zoneLetter:S(k)}}function R(a){var b=a.northing,c=a.easting,d=a.zoneLetter,e=a.zoneNumber;if(e<0||e>60)return null;var f,g,h,i,j,k,l,m,n,o,p=.9996,q=6378137,r=.00669438,s=(1-Math.sqrt(1-r))/(1+Math.sqrt(1-r)),t=c-5e5,u=b;d<"N"&&(u-=1e7),m=6*(e-1)-180+3,f=r/(1-r),l=u/p,n=l/(q*(1-r/4-3*r*r/64-5*r*r*r/256)),o=n+(3*s/2-27*s*s*s/32)*Math.sin(2*n)+(21*s*s/16-55*s*s*s*s/32)*Math.sin(4*n)+151*s*s*s/96*Math.sin(6*n),g=q/Math.sqrt(1-r*Math.sin(o)*Math.sin(o)),h=Math.tan(o)*Math.tan(o),i=f*Math.cos(o)*Math.cos(o),j=q*(1-r)/Math.pow(1-r*Math.sin(o)*Math.sin(o),1.5),k=t/(g*p);var v=o-g*Math.tan(o)/j*(k*k/2-(5+3*h+10*i-4*i*i-9*f)*k*k*k*k/24+(61+90*h+298*i+45*h*h-252*f-3*i*i)*k*k*k*k*k*k/720);v=P(v);var w=(k-(1+2*h+i)*k*k*k/6+(5-2*i+28*h-3*i*i+8*f+24*h*h)*k*k*k*k*k/120)/Math.cos(o);w=m+P(w);var x;if(a.accuracy){var y=R({northing:a.northing+a.accuracy,easting:a.easting+a.accuracy,zoneLetter:a.zoneLetter,zoneNumber:a.zoneNumber});x={top:y.lat,right:y.lon,bottom:v,left:w}}else x={lat:v,lon:w};return x}function S(a){var b="Z";return 84>=a&&a>=72?b="X":72>a&&a>=64?b="W":64>a&&a>=56?b="V":56>a&&a>=48?b="U":48>a&&a>=40?b="T":40>a&&a>=32?b="S":32>a&&a>=24?b="R":24>a&&a>=16?b="Q":16>a&&a>=8?b="P":8>a&&a>=0?b="N":0>a&&a>=-8?b="M":-8>a&&a>=-16?b="L":-16>a&&a>=-24?b="K":-24>a&&a>=-32?b="J":-32>a&&a>=-40?b="H":-40>a&&a>=-48?b="G":-48>a&&a>=-56?b="F":-56>a&&a>=-64?b="E":-64>a&&a>=-72?b="D":-72>a&&a>=-80&&(b="C"),b}function T(a,b){var c="00000"+a.easting,d="00000"+a.northing;return a.zoneNumber+a.zoneLetter+U(a.easting,a.northing,a.zoneNumber)+c.substr(c.length-5,b)+d.substr(d.length-5,b)}function U(a,b,c){var d=V(c),e=Math.floor(a/1e5),f=Math.floor(b/1e5)%20;return W(e,f,d)}function V(a){var b=a%xc;return 0===b&&(b=xc),b}function W(a,b,c){var d=c-1,e=yc.charCodeAt(d),f=zc.charCodeAt(d),g=e+a-1,h=f+b,i=!1;g>Ec&&(g=g-Ec+Ac-1,i=!0),(g===Bc||e<Bc&&g>Bc||(g>Bc||e<Bc)&&i)&&g++,(g===Cc||e<Cc&&g>Cc||(g>Cc||e<Cc)&&i)&&(g++,g===Bc&&g++),g>Ec&&(g=g-Ec+Ac-1),h>Dc?(h=h-Dc+Ac-1,i=!0):i=!1,(h===Bc||f<Bc&&h>Bc||(h>Bc||f<Bc)&&i)&&h++,(h===Cc||f<Cc&&h>Cc||(h>Cc||f<Cc)&&i)&&(h++,h===Bc&&h++),h>Dc&&(h=h-Dc+Ac-1);var j=String.fromCharCode(g)+String.fromCharCode(h);return j}function X(a){if(a&&0===a.length)throw"MGRSPoint coverting from nothing";for(var b,c=a.length,d=null,e="",f=0;!/[A-Z]/.test(b=a.charAt(f));){if(f>=2)throw"MGRSPoint bad conversion from: "+a;e+=b,f++}var g=parseInt(e,10);if(0===f||f+3>c)throw"MGRSPoint bad conversion from: "+a;var h=a.charAt(f++);if(h<="A"||"B"===h||"Y"===h||h>="Z"||"I"===h||"O"===h)throw"MGRSPoint zone letter "+h+" not handled: "+a;d=a.substring(f,f+=2);for(var i=V(g),j=Y(d.charAt(0),i),k=Z(d.charAt(1),i);k<$(h);)k+=2e6;var l=c-f;if(l%2!==0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+a;var m,n,o,p,q,r=l/2,s=0,t=0;return r>0&&(m=1e5/Math.pow(10,r),n=a.substring(f,f+r),s=parseFloat(n)*m,o=a.substring(f+r),t=parseFloat(o)*m),p=s+j,q=t+k,{easting:p,northing:q,zoneLetter:h,zoneNumber:g,accuracy:m}}function Y(a,b){for(var c=yc.charCodeAt(b-1),d=1e5,e=!1;c!==a.charCodeAt(0);){if(c++,c===Bc&&c++,c===Cc&&c++,c>Ec){if(e)throw"Bad character: "+a;c=Ac,e=!0}d+=1e5}return d}function Z(a,b){if(a>"V")throw"MGRSPoint given invalid Northing "+a;for(var c=zc.charCodeAt(b-1),d=0,e=!1;c!==a.charCodeAt(0);){if(c++,c===Bc&&c++,c===Cc&&c++,c>Dc){if(e)throw"Bad character: "+a;c=Ac,e=!0}d+=1e5}return d}function $(a){var b;switch(a){case"C":b=11e5;break;case"D":b=2e6;break;case"E":b=28e5;break;case"F":b=37e5;break;case"G":b=46e5;break;case"H":b=55e5;break;case"J":b=64e5;break;case"K":b=73e5;break;case"L":b=82e5;break;case"M":b=91e5;break;case"N":b=0;break;case"P":b=8e5;break;case"Q":b=17e5;break;case"R":b=26e5;break;case"S":b=35e5;break;case"T":b=44e5;break;case"U":b=53e5;break;case"V":b=62e5;break;case"W":b=7e6;break;case"X":b=79e5;break;default:b=-1}if(b>=0)return b;throw"Invalid zone letter: "+a}function Point(a,b,c){if(!(this instanceof Point))return new Point(a,b,c);if(Array.isArray(a))this.x=a[0],this.y=a[1],this.z=a[2]||0;else if("object"==typeof a)this.x=a.x,this.y=a.y,this.z=a.z||0;else if("string"==typeof a&&"undefined"==typeof b){var d=a.split(",");this.x=parseFloat(d[0],10),this.y=parseFloat(d[1],10),this.z=parseFloat(d[2],10)||0}else this.x=a,this.y=b,this.z=c||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}function _(){this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.es&&(this.en=Tc(this.es),this.ml0=Uc(this.lat0,Math.sin(this.lat0),Math.cos(this.lat0),this.en))}function aa(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0),h=Math.sin(f),i=Math.cos(f);if(this.es){var j=i*g,k=Math.pow(j,2),l=this.ep2*Math.pow(i,2),m=Math.pow(l,2),n=Math.abs(i)>Gb?Math.tan(f):0,o=Math.pow(n,2),p=Math.pow(o,2);b=1-this.es*Math.pow(h,2),j/=Math.sqrt(b);var q=Uc(f,h,i,this.en);c=this.a*(this.k0*j*(1+k/6*(1-o+l+k/20*(5-18*o+p+14*l-58*o*l+k/42*(61+179*p-p*o-479*o)))))+this.x0,d=this.a*(this.k0*(q-this.ml0+h*g*j/2*(1+k/12*(5-o+9*l+4*m+k/30*(61+p-58*o+270*l-330*o*l+k/56*(1385+543*p-p*o-3111*o))))))+this.y0}else{var r=i*Math.sin(g);if(Math.abs(Math.abs(r)-1)<Gb)return 93;if(c=.5*this.a*this.k0*Math.log((1+r)/(1-r))+this.x0,d=i*Math.cos(g)/Math.sqrt(1-Math.pow(r,2)),r=Math.abs(d),r>=1){if(r-1>Gb)return 93;d=0}else d=Math.acos(d);f<0&&(d=-d),d=this.a*this.k0*(d-this.lat0)+this.y0}return a.x=c,a.y=d,a}function ba(a){var b,c,d,e,f=(a.x-this.x0)*(1/this.a),g=(a.y-this.y0)*(1/this.a);if(this.es)if(b=this.ml0+g/this.k0,c=Wc(b,this.es,this.en),Math.abs(c)<Cb){var h=Math.sin(c),i=Math.cos(c),j=Math.abs(i)>Gb?Math.tan(c):0,k=this.ep2*Math.pow(i,2),l=Math.pow(k,2),m=Math.pow(j,2),n=Math.pow(m,2);b=1-this.es*Math.pow(h,2);var o=f*Math.sqrt(b)/this.k0,p=Math.pow(o,2);b*=j,d=c-b*p/(1-this.es)*.5*(1-p/12*(5+3*m-9*k*m+k-4*l-p/30*(61+90*m-252*k*m+45*n+46*k-p/56*(1385+3633*m+4095*n+1574*n*m)))),e=fc(this.long0+o*(1-p/6*(1+2*m+k-p/20*(5+28*m+24*n+8*k*m+6*k-p/42*(61+662*m+1320*n+720*n*m))))/i)}else d=Cb*ec(g),e=0;else{var q=Math.exp(f/this.k0),r=.5*(q-1/q),s=this.lat0+g/this.k0,t=Math.cos(s);b=Math.sqrt((1-Math.pow(t,2))/(1+Math.pow(r,2))),d=Math.asin(b),g<0&&(d=-d),e=0===r&&0===t?0:fc(Math.atan2(r,t)+this.long0)}return a.x=e,a.y=d,a}function ca(){if(void 0===this.es||this.es<=0)throw new Error("incorrect elliptical usage");this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.cgb=[],this.cbg=[],this.utg=[],this.gtu=[];var a=this.es/(1+Math.sqrt(1-this.es)),b=a/(2-a),c=b;this.cgb[0]=b*(2+b*(-2/3+b*(-2+b*(116/45+b*(26/45+b*(-2854/675)))))),this.cbg[0]=b*(-2+b*(2/3+b*(4/3+b*(-82/45+b*(32/45+b*(4642/4725)))))),c*=b,this.cgb[1]=c*(7/3+b*(-1.6+b*(-227/45+b*(2704/315+b*(2323/945))))),this.cbg[1]=c*(5/3+b*(-16/15+b*(-13/9+b*(904/315+b*(-1522/945))))),c*=b,this.cgb[2]=c*(56/15+b*(-136/35+b*(-1262/105+b*(73814/2835)))),this.cbg[2]=c*(-26/15+b*(34/21+b*(1.6+b*(-12686/2835)))),c*=b,this.cgb[3]=c*(4279/630+b*(-332/35+b*(-399572/14175))),this.cbg[3]=c*(1237/630+b*(-2.4+b*(-24832/14175))),c*=b,this.cgb[4]=c*(4174/315+b*(-144838/6237)),this.cbg[4]=c*(-734/315+b*(109598/31185)),c*=b,this.cgb[5]=c*(601676/22275),this.cbg[5]=c*(444337/155925),c=Math.pow(b,2),this.Qn=this.k0/(1+b)*(1+c*(.25+c*(1/64+c/256))),this.utg[0]=b*(-.5+b*(2/3+b*(-37/96+b*(1/360+b*(81/512+b*(-96199/604800)))))),this.gtu[0]=b*(.5+b*(-2/3+b*(5/16+b*(41/180+b*(-127/288+b*(7891/37800)))))),this.utg[1]=c*(-1/48+b*(-1/15+b*(437/1440+b*(-46/105+b*(1118711/3870720))))),this.gtu[1]=c*(13/48+b*(-.6+b*(557/1440+b*(281/630+b*(-1983433/1935360))))),c*=b,this.utg[2]=c*(-17/480+b*(37/840+b*(209/4480+b*(-5569/90720)))),this.gtu[2]=c*(61/240+b*(-103/140+b*(15061/26880+b*(167603/181440)))),c*=b,this.utg[3]=c*(-4397/161280+b*(11/504+b*(830251/7257600))),this.gtu[3]=c*(49561/161280+b*(-179/168+b*(6601661/7257600))),c*=b,this.utg[4]=c*(-4583/161280+b*(108847/3991680)),this.gtu[4]=c*(34729/80640+b*(-3418889/1995840)),c*=b,this.utg[5]=c*-.03233083094085698,this.gtu[5]=.6650675310896665*c;var d=bd(this.cbg,this.lat0);this.Zb=-this.Qn*(d+cd(this.gtu,2*d))}function da(a){var b=fc(a.x-this.long0),c=a.y;c=bd(this.cbg,c);var d=Math.sin(c),e=Math.cos(c),f=Math.sin(b),g=Math.cos(b);c=Math.atan2(d,g*e),b=Math.atan2(f*e,$c(d,e*g)),b=ad(Math.tan(b));var h=ed(this.gtu,2*c,2*b);c+=h[0],b+=h[1];var i,j;return Math.abs(b)<=2.623395162778?(i=this.a*(this.Qn*b)+this.x0,j=this.a*(this.Qn*c+this.Zb)+this.y0):(i=1/0,j=1/0),a.x=i,a.y=j,a}function ea(a){var b=(a.x-this.x0)*(1/this.a),c=(a.y-this.y0)*(1/this.a);c=(c-this.Zb)/this.Qn,b/=this.Qn;var d,e;if(Math.abs(b)<=2.623395162778){var f=ed(this.utg,2*c,2*b);c+=f[0],b+=f[1],b=Math.atan(Zc(b));var g=Math.sin(c),h=Math.cos(c),i=Math.sin(b),j=Math.cos(b);c=Math.atan2(g*j,$c(i,j*h)),b=Math.atan2(i,j*h),d=fc(b+this.long0),e=bd(this.cgb,c)}else d=1/0,e=1/0;return a.x=d,a.y=e,a}function fa(){var a=hd(this.zone,this.long0);if(void 0===a)throw new Error("unknown utm zone");this.lat0=0,this.long0=(6*Math.abs(a)-183)*Hb,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,gd.init.apply(this),this.forward=gd.forward,this.inverse=gd.inverse}function ga(){var a=Math.sin(this.lat0),b=Math.cos(this.lat0);b*=b,this.rc=Math.sqrt(1-this.es)/(1-this.es*a*a),this.C=Math.sqrt(1+this.es*b*b/(1-this.es)),this.phic0=Math.asin(a/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+Jb)/(Math.pow(Math.tan(.5*this.lat0+Jb),this.C)*ld(this.e*a,this.ratexp))}function ha(a){var b=a.x,c=a.y;return a.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*c+Jb),this.C)*ld(this.e*Math.sin(c),this.ratexp))-Cb,a.x=this.C*b,a}function ia(a){for(var b=1e-14,c=a.x/this.C,d=a.y,e=Math.pow(Math.tan(.5*d+Jb)/this.K,1/this.C),f=md;f>0&&(d=2*Math.atan(e*ld(this.e*Math.sin(a.y),-.5*this.e))-Cb,!(Math.abs(d-a.y)<b));--f)a.y=d;return f?(a.x=c,a.y=d,a):null}function ja(){od.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))}function ka(a){var b,c,d,e;return a.x=fc(a.x-this.long0),od.forward.apply(this,[a]),b=Math.sin(a.y),c=Math.cos(a.y),d=Math.cos(a.x),e=this.k0*this.R2/(1+this.sinc0*b+this.cosc0*c*d),a.x=e*c*Math.sin(a.x),a.y=e*(this.cosc0*b-this.sinc0*c*d),a.x=this.a*a.x+this.x0,a.y=this.a*a.y+this.y0,a}function la(a){var b,c,d,e,f;if(a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,f=Math.sqrt(a.x*a.x+a.y*a.y)){var g=2*Math.atan2(f,this.R2);b=Math.sin(g),c=Math.cos(g),e=Math.asin(c*this.sinc0+a.y*b*this.cosc0/f),d=Math.atan2(a.x*b,f*this.cosc0*c-a.y*this.sinc0*b)}else e=this.phic0,d=0;return a.x=d,a.y=e,od.inverse.apply(this,[a]),a.x=fc(a.x+this.long0),a}function ma(a,b,c){return b*=c,Math.tan(.5*(Cb+a))*Math.pow((1-b)/(1+b),.5*c)}function na(){this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=Gb&&(this.k0=.5*(1+ec(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=Gb&&(this.lat0>0?this.con=1:this.con=-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=Gb&&(this.k0=.5*this.cons*dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/gc(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=dc(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-Cb,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))}function oa(a){var b,c,d,e,f,g,h=a.x,i=a.y,j=Math.sin(i),k=Math.cos(i),l=fc(h-this.long0);return Math.abs(Math.abs(h-this.long0)-Math.PI)<=Gb&&Math.abs(i+this.lat0)<=Gb?(a.x=NaN,a.y=NaN,a):this.sphere?(b=2*this.k0/(1+this.sinlat0*j+this.coslat0*k*Math.cos(l)),a.x=this.a*b*k*Math.sin(l)+this.x0,a.y=this.a*b*(this.coslat0*j-this.sinlat0*k*Math.cos(l))+this.y0,a):(c=2*Math.atan(this.ssfn_(i,j,this.e))-Cb,e=Math.cos(c),d=Math.sin(c),Math.abs(this.coslat0)<=Gb?(f=gc(this.e,i*this.con,this.con*j),g=2*this.a*this.k0*f/this.cons,a.x=this.x0+g*Math.sin(h-this.long0),a.y=this.y0-this.con*g*Math.cos(h-this.long0),a):(Math.abs(this.sinlat0)<Gb?(b=2*this.a*this.k0/(1+e*Math.cos(l)),a.y=b*d):(b=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*d+this.cosX0*e*Math.cos(l))),a.y=b*(this.cosX0*d-this.sinX0*e*Math.cos(l))+this.y0),a.x=b*e*Math.sin(l)+this.x0,a))}function pa(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g=Math.sqrt(a.x*a.x+a.y*a.y);if(this.sphere){var h=2*Math.atan(g/(.5*this.a*this.k0));return b=this.long0,c=this.lat0,g<=Gb?(a.x=b,a.y=c,a):(c=Math.asin(Math.cos(h)*this.sinlat0+a.y*Math.sin(h)*this.coslat0/g),b=fc(Math.abs(this.coslat0)<Gb?this.lat0>0?this.long0+Math.atan2(a.x,-1*a.y):this.long0+Math.atan2(a.x,a.y):this.long0+Math.atan2(a.x*Math.sin(h),g*this.coslat0*Math.cos(h)-a.y*this.sinlat0*Math.sin(h))),a.x=b,a.y=c,a)}if(Math.abs(this.coslat0)<=Gb){if(g<=Gb)return c=this.lat0,b=this.long0,a.x=b,a.y=c,a;a.x*=this.con,a.y*=this.con,d=g*this.cons/(2*this.a*this.k0),c=this.con*hc(this.e,d),b=this.con*fc(this.con*this.long0+Math.atan2(a.x,-1*a.y))}else e=2*Math.atan(g*this.cosX0/(2*this.a*this.k0*this.ms1)),b=this.long0,g<=Gb?f=this.X0:(f=Math.asin(Math.cos(e)*this.sinX0+a.y*Math.sin(e)*this.cosX0/g),b=fc(this.long0+Math.atan2(a.x*Math.sin(e),g*this.cosX0*Math.cos(e)-a.y*this.sinX0*Math.sin(e)))),c=-1*hc(this.e,Math.tan(.5*(Cb+f)));return a.x=b,a.y=c,a}function qa(){var a=this.lat0;this.lambda0=this.long0;var b=Math.sin(a),c=this.a,d=this.rf,e=1/d,f=2*e-Math.pow(e,2),g=this.e=Math.sqrt(f);this.R=this.k0*c*Math.sqrt(1-f)/(1-f*Math.pow(b,2)),this.alpha=Math.sqrt(1+f/(1-f)*Math.pow(Math.cos(a),4)),this.b0=Math.asin(b/this.alpha);var h=Math.log(Math.tan(Math.PI/4+this.b0/2)),i=Math.log(Math.tan(Math.PI/4+a/2)),j=Math.log((1+g*b)/(1-g*b));this.K=h-this.alpha*i+this.alpha*g/2*j}function ra(a){var b=Math.log(Math.tan(Math.PI/4-a.y/2)),c=this.e/2*Math.log((1+this.e*Math.sin(a.y))/(1-this.e*Math.sin(a.y))),d=-this.alpha*(b+c)+this.K,e=2*(Math.atan(Math.exp(d))-Math.PI/4),f=this.alpha*(a.x-this.lambda0),g=Math.atan(Math.sin(f)/(Math.sin(this.b0)*Math.tan(e)+Math.cos(this.b0)*Math.cos(f))),h=Math.asin(Math.cos(this.b0)*Math.sin(e)-Math.sin(this.b0)*Math.cos(e)*Math.cos(f));return a.y=this.R/2*Math.log((1+Math.sin(h))/(1-Math.sin(h)))+this.y0,a.x=this.R*g+this.x0,a}function sa(a){for(var b=a.x-this.x0,c=a.y-this.y0,d=b/this.R,e=2*(Math.atan(Math.exp(c/this.R))-Math.PI/4),f=Math.asin(Math.cos(this.b0)*Math.sin(e)+Math.sin(this.b0)*Math.cos(e)*Math.cos(d)),g=Math.atan(Math.sin(d)/(Math.cos(this.b0)*Math.cos(d)-Math.sin(this.b0)*Math.tan(e))),h=this.lambda0+g/this.alpha,i=0,j=f,k=-1e3,l=0;Math.abs(j-k)>1e-7;){if(++l>20)return;i=1/this.alpha*(Math.log(Math.tan(Math.PI/4+f/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(j))/2)),k=j,j=2*Math.atan(Math.exp(i))-Math.PI/2}return a.x=h,a.y=j,a}function ta(){this.no_off=this.no_off||!1,this.no_rot=this.no_rot||!1,isNaN(this.k0)&&(this.k0=1);var a=Math.sin(this.lat0),b=Math.cos(this.lat0),c=this.e*a;this.bl=Math.sqrt(1+this.es/(1-this.es)*Math.pow(b,4)),this.al=this.a*this.bl*this.k0*Math.sqrt(1-this.es)/(1-c*c);var d=gc(this.e,this.lat0,a),e=this.bl/b*Math.sqrt((1-this.es)/(1-c*c));e*e<1&&(e=1);var f,g;if(isNaN(this.longc)){var h=gc(this.e,this.lat1,Math.sin(this.lat1)),i=gc(this.e,this.lat2,Math.sin(this.lat2));this.lat0>=0?this.el=(e+Math.sqrt(e*e-1))*Math.pow(d,this.bl):this.el=(e-Math.sqrt(e*e-1))*Math.pow(d,this.bl);var j=Math.pow(h,this.bl),k=Math.pow(i,this.bl);f=this.el/j,g=.5*(f-1/f);var l=(this.el*this.el-k*j)/(this.el*this.el+k*j),m=(k-j)/(k+j),n=fc(this.long1-this.long2);this.long0=.5*(this.long1+this.long2)-Math.atan(l*Math.tan(.5*this.bl*n)/m)/this.bl,this.long0=fc(this.long0);var o=fc(this.long1-this.long0);this.gamma0=Math.atan(Math.sin(this.bl*o)/g),this.alpha=Math.asin(e*Math.sin(this.gamma0))}else f=this.lat0>=0?e+Math.sqrt(e*e-1):e-Math.sqrt(e*e-1),this.el=f*Math.pow(d,this.bl),g=.5*(f-1/f),this.gamma0=Math.asin(Math.sin(this.alpha)/e),this.long0=this.longc-Math.asin(g*Math.tan(this.gamma0))/this.bl;this.no_off?this.uc=0:this.lat0>=0?this.uc=this.al/this.bl*Math.atan2(Math.sqrt(e*e-1),Math.cos(this.alpha)):this.uc=-1*this.al/this.bl*Math.atan2(Math.sqrt(e*e-1),Math.cos(this.alpha))}function ua(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0);if(Math.abs(Math.abs(f)-Cb)<=Gb)d=f>0?-1:1,c=this.al/this.bl*Math.log(Math.tan(Jb+d*this.gamma0*.5)),b=-1*d*Cb*this.al/this.bl;else{var h=gc(this.e,f,Math.sin(f)),i=this.el/Math.pow(h,this.bl),j=.5*(i-1/i),k=.5*(i+1/i),l=Math.sin(this.bl*g),m=(j*Math.sin(this.gamma0)-l*Math.cos(this.gamma0))/k;c=Math.abs(Math.abs(m)-1)<=Gb?Number.POSITIVE_INFINITY:.5*this.al*Math.log((1-m)/(1+m))/this.bl,b=Math.abs(Math.cos(this.bl*g))<=Gb?this.al*this.bl*g:this.al*Math.atan2(j*Math.cos(this.gamma0)+l*Math.sin(this.gamma0),Math.cos(this.bl*g))/this.bl}return this.no_rot?(a.x=this.x0+b,a.y=this.y0+c):(b-=this.uc,a.x=this.x0+c*Math.cos(this.alpha)+b*Math.sin(this.alpha),a.y=this.y0+b*Math.cos(this.alpha)-c*Math.sin(this.alpha)),a}function va(a){var b,c;this.no_rot?(c=a.y-this.y0,b=a.x-this.x0):(c=(a.x-this.x0)*Math.cos(this.alpha)-(a.y-this.y0)*Math.sin(this.alpha),b=(a.y-this.y0)*Math.cos(this.alpha)+(a.x-this.x0)*Math.sin(this.alpha),b+=this.uc);var d=Math.exp(-1*this.bl*c/this.al),e=.5*(d-1/d),f=.5*(d+1/d),g=Math.sin(this.bl*b/this.al),h=(g*Math.cos(this.gamma0)+e*Math.sin(this.gamma0))/f,i=Math.pow(this.el/Math.sqrt((1+h)/(1-h)),1/this.bl);return Math.abs(h-1)<Gb?(a.x=this.long0,a.y=Cb):Math.abs(h+1)<Gb?(a.x=this.long0,a.y=-1*Cb):(a.y=hc(this.e,i),a.x=fc(this.long0-Math.atan2(e*Math.cos(this.gamma0)-g*Math.sin(this.gamma0),Math.cos(this.bl*b/this.al))/this.bl)),a}function wa(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<Gb)){var a=this.b/this.a;this.e=Math.sqrt(1-a*a);var b=Math.sin(this.lat1),c=Math.cos(this.lat1),d=dc(this.e,b,c),e=gc(this.e,this.lat1,b),f=Math.sin(this.lat2),g=Math.cos(this.lat2),h=dc(this.e,f,g),i=gc(this.e,this.lat2,f),j=gc(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>Gb?this.ns=Math.log(d/h)/Math.log(e/i):this.ns=b,isNaN(this.ns)&&(this.ns=b),this.f0=d/(this.ns*Math.pow(e,this.ns)),this.rh=this.a*this.f0*Math.pow(j,this.ns),this.title||(this.title="Lambert Conformal Conic")}}function xa(a){var b=a.x,c=a.y;Math.abs(2*Math.abs(c)-Math.PI)<=Gb&&(c=ec(c)*(Cb-2*Gb));var d,e,f=Math.abs(Math.abs(c)-Cb);if(f>Gb)d=gc(this.e,c,Math.sin(c)),e=this.a*this.f0*Math.pow(d,this.ns);else{if(f=c*this.ns,f<=0)return null;e=0}var g=this.ns*fc(b-this.long0);return a.x=this.k0*(e*Math.sin(g))+this.x0,a.y=this.k0*(this.rh-e*Math.cos(g))+this.y0,a}function ya(a){var b,c,d,e,f,g=(a.x-this.x0)/this.k0,h=this.rh-(a.y-this.y0)/this.k0;this.ns>0?(b=Math.sqrt(g*g+h*h),c=1):(b=-Math.sqrt(g*g+h*h),c=-1);var i=0;if(0!==b&&(i=Math.atan2(c*g,c*h)),0!==b||this.ns>0){if(c=1/this.ns,d=Math.pow(b/(this.a*this.f0),c),e=hc(this.e,d),e===-9999)return null}else e=-Cb;return f=fc(i/this.ns+this.long0),a.x=f,a.y=e,a}function za(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq}function Aa(a){var b,c,d,e,f,g,h,i=a.x,j=a.y,k=fc(i-this.long0);return b=Math.pow((1+this.e*Math.sin(j))/(1-this.e*Math.sin(j)),this.alfa*this.e/2),c=2*(Math.atan(this.k*Math.pow(Math.tan(j/2+this.s45),this.alfa)/b)-this.s45),d=-k*this.alfa,
e=Math.asin(Math.cos(this.ad)*Math.sin(c)+Math.sin(this.ad)*Math.cos(c)*Math.cos(d)),f=Math.asin(Math.cos(c)*Math.sin(d)/Math.cos(e)),g=this.n*f,h=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(e/2+this.s45),this.n),a.y=h*Math.cos(g)/1,a.x=h*Math.sin(g)/1,this.czech||(a.y*=-1,a.x*=-1),a}function Ba(a){var b,c,d,e,f,g,h,i,j=a.x;a.x=a.y,a.y=j,this.czech||(a.y*=-1,a.x*=-1),g=Math.sqrt(a.x*a.x+a.y*a.y),f=Math.atan2(a.y,a.x),e=f/Math.sin(this.s0),d=2*(Math.atan(Math.pow(this.ro0/g,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),b=Math.asin(Math.cos(this.ad)*Math.sin(d)-Math.sin(this.ad)*Math.cos(d)*Math.cos(e)),c=Math.asin(Math.cos(d)*Math.sin(e)/Math.cos(b)),a.x=this.long0-c/this.alfa,h=b,i=0;var k=0;do a.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(b/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(h))/(1-this.e*Math.sin(h)),this.e/2))-this.s45),Math.abs(h-a.y)<1e-10&&(i=1),h=a.y,k+=1;while(0===i&&k<15);return k>=15?null:a}function Ca(){this.sphere||(this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.ml0=this.a*Bd(this.e0,this.e1,this.e2,this.e3,this.lat0))}function Da(a){var b,c,d=a.x,e=a.y;if(d=fc(d-this.long0),this.sphere)b=this.a*Math.asin(Math.cos(e)*Math.sin(d)),c=this.a*(Math.atan2(Math.tan(e),Math.cos(d))-this.lat0);else{var f=Math.sin(e),g=Math.cos(e),h=Gd(this.a,this.e,f),i=Math.tan(e)*Math.tan(e),j=d*Math.cos(e),k=j*j,l=this.es*g*g/(1-this.es),m=this.a*Bd(this.e0,this.e1,this.e2,this.e3,e);b=h*j*(1-k*i*(1/6-(8-i+8*l)*k/120)),c=m-this.ml0+h*f/g*k*(.5+(5-i+6*l)*k/24)}return a.x=b+this.x0,a.y=c+this.y0,a}function Ea(a){a.x-=this.x0,a.y-=this.y0;var b,c,d=a.x/this.a,e=a.y/this.a;if(this.sphere){var f=e+this.lat0;b=Math.asin(Math.sin(f)*Math.cos(d)),c=Math.atan2(Math.tan(d),Math.cos(f))}else{var g=this.ml0/this.a+e,h=Id(g,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(h)-Cb)<=Gb)return a.x=this.long0,a.y=Cb,e<0&&(a.y*=-1),a;var i=Gd(this.a,this.e,Math.sin(h)),j=i*i*i/this.a/this.a*(1-this.es),k=Math.pow(Math.tan(h),2),l=d*this.a/i,m=l*l;b=h-i*Math.tan(h)/j*l*l*(.5-(1+3*k)*l*l/24),c=l*(1-m*(k/3+(1+3*k)*k*m/15))/Math.cos(h)}return a.x=fc(c+this.long0),a.y=Hd(b),a}function Fa(){var a=Math.abs(this.lat0);if(Math.abs(a-Cb)<Gb?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(a)<Gb?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0){var b;switch(this.qp=Ld(this.e,1),this.mmf=.5/(1-this.es),this.apa=Ia(this.es),this.mode){case this.N_POLE:this.dd=1;break;case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),b=Math.sin(this.lat0),this.sinb1=Ld(this.e,b)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*b*b)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))}function Ga(a){var b,c,d,e,f,g,h,i,j,k,l=a.x,m=a.y;if(l=fc(l-this.long0),this.sphere){if(f=Math.sin(m),k=Math.cos(m),d=Math.cos(l),this.mode===this.OBLIQ||this.mode===this.EQUIT){if(c=this.mode===this.EQUIT?1+k*d:1+this.sinph0*f+this.cosph0*k*d,c<=Gb)return null;c=Math.sqrt(2/c),b=c*k*Math.sin(l),c*=this.mode===this.EQUIT?f:this.cosph0*f-this.sinph0*k*d}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(d=-d),Math.abs(m+this.phi0)<Gb)return null;c=Jb-.5*m,c=2*(this.mode===this.S_POLE?Math.cos(c):Math.sin(c)),b=c*Math.sin(l),c*=d}}else{switch(h=0,i=0,j=0,d=Math.cos(l),e=Math.sin(l),f=Math.sin(m),g=Ld(this.e,f),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(h=g/this.qp,i=Math.sqrt(1-h*h)),this.mode){case this.OBLIQ:j=1+this.sinb1*h+this.cosb1*i*d;break;case this.EQUIT:j=1+i*d;break;case this.N_POLE:j=Cb+m,g=this.qp-g;break;case this.S_POLE:j=m-Cb,g=this.qp+g}if(Math.abs(j)<Gb)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:j=Math.sqrt(2/j),c=this.mode===this.OBLIQ?this.ymf*j*(this.cosb1*h-this.sinb1*i*d):(j=Math.sqrt(2/(1+i*d)))*h*this.ymf,b=this.xmf*j*i*e;break;case this.N_POLE:case this.S_POLE:g>=0?(b=(j=Math.sqrt(g))*e,c=d*(this.mode===this.S_POLE?j:-j)):b=c=0}}return a.x=this.a*b+this.x0,a.y=this.a*c+this.y0,a}function Ha(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g,h,i=a.x/this.a,j=a.y/this.a;if(this.sphere){var k,l=0,m=0;if(k=Math.sqrt(i*i+j*j),c=.5*k,c>1)return null;switch(c=2*Math.asin(c),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(m=Math.sin(c),l=Math.cos(c)),this.mode){case this.EQUIT:c=Math.abs(k)<=Gb?0:Math.asin(j*m/k),i*=m,j=l*k;break;case this.OBLIQ:c=Math.abs(k)<=Gb?this.phi0:Math.asin(l*this.sinph0+j*m*this.cosph0/k),i*=m*this.cosph0,j=(l-Math.sin(c)*this.sinph0)*k;break;case this.N_POLE:j=-j,c=Cb-c;break;case this.S_POLE:c-=Cb}b=0!==j||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(i,j):0}else{if(h=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(i/=this.dd,j*=this.dd,g=Math.sqrt(i*i+j*j),g<Gb)return a.x=0,a.y=this.phi0,a;e=2*Math.asin(.5*g/this.rq),d=Math.cos(e),i*=e=Math.sin(e),this.mode===this.OBLIQ?(h=d*this.sinb1+j*e*this.cosb1/g,f=this.qp*h,j=g*this.cosb1*d-j*this.sinb1*e):(h=j*e/g,f=this.qp*h,j=g*d)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(j=-j),f=i*i+j*j,!f)return a.x=0,a.y=this.phi0,a;h=1-f/this.qp,this.mode===this.S_POLE&&(h=-h)}b=Math.atan2(i,j),c=Ja(Math.asin(h),this.apa)}return a.x=fc(this.long0+b),a.y=c,a}function Ia(a){var b,c=[];return c[0]=a*Qd,b=a*a,c[0]+=b*Rd,c[1]=b*Td,b*=a,c[0]+=b*Sd,c[1]+=b*Ud,c[2]=b*Vd,c}function Ja(a,b){var c=a+a;return a+b[0]*Math.sin(c)+b[1]*Math.sin(c+c)+b[2]*Math.sin(c+c+c)}function Ka(){Math.abs(this.lat1+this.lat2)<Gb||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=dc(this.e3,this.sin_po,this.cos_po),this.qs1=Ld(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=dc(this.e3,this.sin_po,this.cos_po),this.qs2=Ld(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=Ld(this.e3,this.sin_po,this.cos_po),Math.abs(this.lat1-this.lat2)>Gb?this.ns0=(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.ns0=this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)}function La(a){var b=a.x,c=a.y;this.sin_phi=Math.sin(c),this.cos_phi=Math.cos(c);var d=Ld(this.e3,this.sin_phi,this.cos_phi),e=this.a*Math.sqrt(this.c-this.ns0*d)/this.ns0,f=this.ns0*fc(b-this.long0),g=e*Math.sin(f)+this.x0,h=this.rh-e*Math.cos(f)+this.y0;return a.x=g,a.y=h,a}function Ma(a){var b,c,d,e,f,g;return a.x-=this.x0,a.y=this.rh-a.y+this.y0,this.ns0>=0?(b=Math.sqrt(a.x*a.x+a.y*a.y),d=1):(b=-Math.sqrt(a.x*a.x+a.y*a.y),d=-1),e=0,0!==b&&(e=Math.atan2(d*a.x,d*a.y)),d=b*this.ns0/this.a,this.sphere?g=Math.asin((this.c-d*d)/(2*this.ns0)):(c=(this.c-d*d)/this.ns0,g=this.phi1z(this.e3,c)),f=fc(e/this.ns0+this.long0),a.x=f,a.y=g,a}function Na(a,b){var c,d,e,f,g,h=Yd(.5*b);if(a<Gb)return h;for(var i=a*a,j=1;j<=25;j++)if(c=Math.sin(h),d=Math.cos(h),e=a*c,f=1-e*e,g=.5*f*f/d*(b/(1-i)-c/f+.5/a*Math.log((1-e)/(1+e))),h+=g,Math.abs(g)<=1e-7)return h;return null}function Oa(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1}function Pa(a){var b,c,d,e,f,g,h,i,j=a.x,k=a.y;return d=fc(j-this.long0),b=Math.sin(k),c=Math.cos(k),e=Math.cos(d),g=this.sin_p14*b+this.cos_p14*c*e,f=1,g>0||Math.abs(g)<=Gb?(h=this.x0+this.a*f*c*Math.sin(d)/g,i=this.y0+this.a*f*(this.cos_p14*b-this.sin_p14*c*e)/g):(h=this.x0+this.infinity_dist*c*Math.sin(d),i=this.y0+this.infinity_dist*(this.cos_p14*b-this.sin_p14*c*e)),a.x=h,a.y=i,a}function Qa(a){var b,c,d,e,f,g;return a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,(b=Math.sqrt(a.x*a.x+a.y*a.y))?(e=Math.atan2(b,this.rc),c=Math.sin(e),d=Math.cos(e),g=Yd(d*this.sin_p14+a.y*c*this.cos_p14/b),f=Math.atan2(a.x*c,b*this.cos_p14*d-a.y*this.sin_p14*c),f=fc(this.long0+f)):(g=this.phic0,f=0),a.x=f,a.y=g,a}function Ra(){this.sphere||(this.k0=dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))}function Sa(a){var b,c,d=a.x,e=a.y,f=fc(d-this.long0);if(this.sphere)b=this.x0+this.a*f*Math.cos(this.lat_ts),c=this.y0+this.a*Math.sin(e)/Math.cos(this.lat_ts);else{var g=Ld(this.e,Math.sin(e));b=this.x0+this.a*this.k0*f,c=this.y0+this.a*g*.5/this.k0}return a.x=b,a.y=c,a}function Ta(a){a.x-=this.x0,a.y-=this.y0;var b,c;return this.sphere?(b=fc(this.long0+a.x/this.a/Math.cos(this.lat_ts)),c=Math.asin(a.y/this.a*Math.cos(this.lat_ts))):(c=be(this.e,2*a.y*this.k0/this.a),b=fc(this.long0+a.x/(this.a*this.k0))),a.x=b,a.y=c,a}function Ua(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)}function Va(a){var b=a.x,c=a.y,d=fc(b-this.long0),e=Hd(c-this.lat0);return a.x=this.x0+this.a*d*this.rc,a.y=this.y0+this.a*e,a}function Wa(a){var b=a.x,c=a.y;return a.x=fc(this.long0+(b-this.x0)/(this.a*this.rc)),a.y=Hd(this.lat0+(c-this.y0)/this.a),a}function Xa(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.ml0=this.a*Bd(this.e0,this.e1,this.e2,this.e3,this.lat0)}function Ya(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0);if(d=g*Math.sin(f),this.sphere)Math.abs(f)<=Gb?(b=this.a*g,c=-1*this.a*this.lat0):(b=this.a*Math.sin(d)/Math.tan(f),c=this.a*(Hd(f-this.lat0)+(1-Math.cos(d))/Math.tan(f)));else if(Math.abs(f)<=Gb)b=this.a*g,c=-1*this.ml0;else{var h=Gd(this.a,this.e,Math.sin(f))/Math.tan(f);b=h*Math.sin(d),c=this.a*Bd(this.e0,this.e1,this.e2,this.e3,f)-this.ml0+h*(1-Math.cos(d))}return a.x=b+this.x0,a.y=c+this.y0,a}function Za(a){var b,c,d,e,f,g,h,i,j;if(d=a.x-this.x0,e=a.y-this.y0,this.sphere)if(Math.abs(e+this.a*this.lat0)<=Gb)b=fc(d/this.a+this.long0),c=0;else{g=this.lat0+e/this.a,h=d*d/this.a/this.a+g*g,i=g;var k;for(f=ge;f;--f)if(k=Math.tan(i),j=-1*(g*(i*k+1)-i-.5*(i*i+h)*k)/((i-g)/k-1),i+=j,Math.abs(j)<=Gb){c=i;break}b=fc(this.long0+Math.asin(d*Math.tan(i)/this.a)/Math.sin(c))}else if(Math.abs(e+this.ml0)<=Gb)c=0,b=fc(this.long0+d/this.a);else{g=(this.ml0+e)/this.a,h=d*d/this.a/this.a+g*g,i=g;var l,m,n,o,p;for(f=ge;f;--f)if(p=this.e*Math.sin(i),l=Math.sqrt(1-p*p)*Math.tan(i),m=this.a*Bd(this.e0,this.e1,this.e2,this.e3,i),n=this.e0-2*this.e1*Math.cos(2*i)+4*this.e2*Math.cos(4*i)-6*this.e3*Math.cos(6*i),o=m/this.a,j=(g*(l*o+1)-o-.5*l*(o*o+h))/(this.es*Math.sin(2*i)*(o*o+h-2*g*o)/(4*l)+(g-o)*(l*n-2/Math.sin(2*i))-n),i-=j,Math.abs(j)<=Gb){c=i;break}l=Math.sqrt(1-this.es*Math.pow(Math.sin(c),2))*Math.tan(c),b=fc(this.long0+Math.asin(d*l/this.a)/Math.sin(c))}return a.x=b,a.y=c,a}function $a(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013}function _a(a){var b,c=a.x,d=a.y,e=d-this.lat0,f=c-this.long0,g=e/Bb*1e-5,h=f,i=1,j=0;for(b=1;b<=10;b++)i*=g,j+=this.A[b]*i;var k,l,m=j,n=h,o=1,p=0,q=0,r=0;for(b=1;b<=6;b++)k=o*m-p*n,l=p*m+o*n,o=k,p=l,q=q+this.B_re[b]*o-this.B_im[b]*p,r=r+this.B_im[b]*o+this.B_re[b]*p;return a.x=r*this.a+this.x0,a.y=q*this.a+this.y0,a}function ab(a){var b,c,d,e=a.x,f=a.y,g=e-this.x0,h=f-this.y0,i=h/this.a,j=g/this.a,k=1,l=0,m=0,n=0;for(b=1;b<=6;b++)c=k*i-l*j,d=l*i+k*j,k=c,l=d,m=m+this.C_re[b]*k-this.C_im[b]*l,n=n+this.C_im[b]*k+this.C_re[b]*l;for(var o=0;o<this.iterations;o++){var p,q,r=m,s=n,t=i,u=j;for(b=2;b<=6;b++)p=r*m-s*n,q=s*m+r*n,r=p,s=q,t+=(b-1)*(this.B_re[b]*r-this.B_im[b]*s),u+=(b-1)*(this.B_im[b]*r+this.B_re[b]*s);r=1,s=0;var v=this.B_re[1],w=this.B_im[1];for(b=2;b<=6;b++)p=r*m-s*n,q=s*m+r*n,r=p,s=q,v+=b*(this.B_re[b]*r-this.B_im[b]*s),w+=b*(this.B_im[b]*r+this.B_re[b]*s);var x=v*v+w*w;m=(t*v+u*w)/x,n=(u*v-t*w)/x}var y=m,z=n,A=1,B=0;for(b=1;b<=9;b++)A*=y,B+=this.D[b]*A;var C=this.lat0+B*Bb*1e5,D=this.long0+z;return a.x=D,a.y=C,a}function bb(){}function cb(a){var b=a.x,c=a.y,d=fc(b-this.long0),e=this.x0+this.a*d,f=this.y0+this.a*Math.log(Math.tan(Math.PI/4+c/2.5))*1.25;return a.x=e,a.y=f,a}function db(a){a.x-=this.x0,a.y-=this.y0;var b=fc(this.long0+a.x/this.a),c=2.5*(Math.atan(Math.exp(.8*a.y/this.a))-Math.PI/4);return a.x=b,a.y=c,a}function eb(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=Tc(this.es)}function fb(a){var b,c,d=a.x,e=a.y;if(d=fc(d-this.long0),this.sphere){if(this.m)for(var f=this.n*Math.sin(e),g=ne;g;--g){var h=(this.m*e+Math.sin(e)-f)/(this.m+Math.cos(e));if(e-=h,Math.abs(h)<Gb)break}else e=1!==this.n?Math.asin(this.n*Math.sin(e)):e;b=this.a*this.C_x*d*(this.m+Math.cos(e)),c=this.a*this.C_y*e}else{var i=Math.sin(e),j=Math.cos(e);c=this.a*Uc(e,i,j,this.en),b=this.a*d*j/Math.sqrt(1-this.es*i*i)}return a.x=b,a.y=c,a}function gb(a){var b,c,d,e;return a.x-=this.x0,d=a.x/this.a,a.y-=this.y0,b=a.y/this.a,this.sphere?(b/=this.C_y,d/=this.C_x*(this.m+Math.cos(b)),this.m?b=Yd((this.m*b+Math.sin(b))/this.n):1!==this.n&&(b=Yd(Math.sin(b)/this.n)),d=fc(d+this.long0),b=Hd(b)):(b=Wc(a.y/this.a,this.es,this.en),e=Math.abs(b),e<Cb?(e=Math.sin(b),c=this.long0+a.x*Math.sqrt(1-this.es*e*e)/(this.a*Math.cos(b)),d=fc(c)):e-Gb<Cb&&(d=this.long0)),a.x=d,a.y=b,a}function hb(){}function ib(a){for(var b=a.x,c=a.y,d=fc(b-this.long0),e=c,f=Math.PI*Math.sin(c),g=0;!0;g++){var h=-(e+Math.sin(e)-f)/(1+Math.cos(e));if(e+=h,Math.abs(h)<Gb)break}e/=2,Math.PI/2-Math.abs(c)<Gb&&(d=0);var i=.900316316158*this.a*d*Math.cos(e)+this.x0,j=1.4142135623731*this.a*Math.sin(e)+this.y0;return a.x=i,a.y=j,a}function jb(a){var b,c;a.x-=this.x0,a.y-=this.y0,c=a.y/(1.4142135623731*this.a),Math.abs(c)>.999999999999&&(c=.999999999999),b=Math.asin(c);var d=fc(this.long0+a.x/(.900316316158*this.a*Math.cos(b)));d<-Math.PI&&(d=-Math.PI),d>Math.PI&&(d=Math.PI),c=(2*b+Math.sin(2*b))/Math.PI,Math.abs(c)>1&&(c=1);var e=Math.asin(c);return a.x=d,a.y=e,a}function kb(){Math.abs(this.lat1+this.lat2)<Gb||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=dc(this.e,this.sinphi,this.cosphi),this.ml1=Bd(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<Gb?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=dc(this.e,this.sinphi,this.cosphi),this.ml2=Bd(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=Bd(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))}function lb(a){var b,c=a.x,d=a.y;if(this.sphere)b=this.a*(this.g-d);else{var e=Bd(this.e0,this.e1,this.e2,this.e3,d);b=this.a*(this.g-e)}var f=this.ns*fc(c-this.long0),g=this.x0+b*Math.sin(f),h=this.y0+this.rh-b*Math.cos(f);return a.x=g,a.y=h,a}function mb(a){a.x-=this.x0,a.y=this.rh-a.y+this.y0;var b,c,d,e;this.ns>=0?(c=Math.sqrt(a.x*a.x+a.y*a.y),b=1):(c=-Math.sqrt(a.x*a.x+a.y*a.y),b=-1);var f=0;if(0!==c&&(f=Math.atan2(b*a.x,b*a.y)),this.sphere)return e=fc(this.long0+f/this.ns),d=Hd(this.g-c/this.a),a.x=e,a.y=d,a;var g=this.g-c/this.a;return d=Id(g,this.e0,this.e1,this.e2,this.e3),e=fc(this.long0+f/this.ns),a.x=e,a.y=d,a}function nb(){this.R=this.a}function ob(a){var b,c,d=a.x,e=a.y,f=fc(d-this.long0);Math.abs(e)<=Gb&&(b=this.x0+this.R*f,c=this.y0);var g=Yd(2*Math.abs(e/Math.PI));(Math.abs(f)<=Gb||Math.abs(Math.abs(e)-Cb)<=Gb)&&(b=this.x0,c=e>=0?this.y0+Math.PI*this.R*Math.tan(.5*g):this.y0+Math.PI*this.R*-Math.tan(.5*g));var h=.5*Math.abs(Math.PI/f-f/Math.PI),i=h*h,j=Math.sin(g),k=Math.cos(g),l=k/(j+k-1),m=l*l,n=l*(2/j-1),o=n*n,p=Math.PI*this.R*(h*(l-o)+Math.sqrt(i*(l-o)*(l-o)-(o+i)*(m-o)))/(o+i);f<0&&(p=-p),b=this.x0+p;var q=i+l;return p=Math.PI*this.R*(n*q-h*Math.sqrt((o+i)*(i+1)-q*q))/(o+i),c=e>=0?this.y0+p:this.y0-p,a.x=b,a.y=c,a}function pb(a){var b,c,d,e,f,g,h,i,j,k,l,m,n;return a.x-=this.x0,a.y-=this.y0,l=Math.PI*this.R,d=a.x/l,e=a.y/l,f=d*d+e*e,g=-Math.abs(e)*(1+f),h=g-2*e*e+d*d,i=-2*g+1+2*e*e+f*f,n=e*e/i+(2*h*h*h/i/i/i-9*g*h/i/i)/27,j=(g-h*h/3/i)/i,k=2*Math.sqrt(-j/3),l=3*n/j/k,Math.abs(l)>1&&(l=l>=0?1:-1),m=Math.acos(l)/3,c=a.y>=0?(-k*Math.cos(m+Math.PI/3)-h/3/i)*Math.PI:-(-k*Math.cos(m+Math.PI/3)-h/3/i)*Math.PI,b=Math.abs(d)<Gb?this.long0:fc(this.long0+Math.PI*(f-1+Math.sqrt(1+2*(d*d-e*e)+f*f))/2/d),a.x=b,a.y=c,a}function qb(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0)}function rb(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y=a.x,z=a.y,A=Math.sin(a.y),B=Math.cos(a.y),C=fc(y-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=Gb?(a.x=this.x0+this.a*(Cb-z)*Math.sin(C),a.y=this.y0-this.a*(Cb-z)*Math.cos(C),a):Math.abs(this.sin_p12+1)<=Gb?(a.x=this.x0+this.a*(Cb+z)*Math.sin(C),a.y=this.y0+this.a*(Cb+z)*Math.cos(C),a):(s=this.sin_p12*A+this.cos_p12*B*Math.cos(C),q=Math.acos(s),r=q/Math.sin(q),a.x=this.x0+this.a*r*B*Math.sin(C),a.y=this.y0+this.a*r*(this.cos_p12*A-this.sin_p12*B*Math.cos(C)),a):(b=Cd(this.es),c=Dd(this.es),d=Ed(this.es),e=Fd(this.es),Math.abs(this.sin_p12-1)<=Gb?(f=this.a*Bd(b,c,d,e,Cb),g=this.a*Bd(b,c,d,e,z),a.x=this.x0+(f-g)*Math.sin(C),a.y=this.y0-(f-g)*Math.cos(C),a):Math.abs(this.sin_p12+1)<=Gb?(f=this.a*Bd(b,c,d,e,Cb),g=this.a*Bd(b,c,d,e,z),a.x=this.x0+(f+g)*Math.sin(C),a.y=this.y0+(f+g)*Math.cos(C),a):(h=A/B,i=Gd(this.a,this.e,this.sin_p12),j=Gd(this.a,this.e,A),k=Math.atan((1-this.es)*h+this.es*i*this.sin_p12/(j*B)),l=Math.atan2(Math.sin(C),this.cos_p12*Math.tan(k)-this.sin_p12*Math.cos(C)),t=0===l?Math.asin(this.cos_p12*Math.sin(k)-this.sin_p12*Math.cos(k)):Math.abs(Math.abs(l)-Math.PI)<=Gb?-Math.asin(this.cos_p12*Math.sin(k)-this.sin_p12*Math.cos(k)):Math.asin(Math.sin(C)*Math.cos(k)/Math.sin(l)),m=this.e*this.sin_p12/Math.sqrt(1-this.es),n=this.e*this.cos_p12*Math.cos(l)/Math.sqrt(1-this.es),o=m*n,p=n*n,u=t*t,v=u*t,w=v*t,x=w*t,q=i*t*(1-u*p*(1-p)/6+v/8*o*(1-2*p)+w/120*(p*(4-7*p)-3*m*m*(1-7*p))-x/48*o),a.x=this.x0+q*Math.sin(l),a.y=this.y0+q*Math.cos(l),a))}function sb(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x;if(this.sphere){if(b=Math.sqrt(a.x*a.x+a.y*a.y),b>2*Cb*this.a)return;return c=b/this.a,d=Math.sin(c),e=Math.cos(c),f=this.long0,Math.abs(b)<=Gb?g=this.lat0:(g=Yd(e*this.sin_p12+a.y*d*this.cos_p12/b),h=Math.abs(this.lat0)-Cb,f=fc(Math.abs(h)<=Gb?this.lat0>=0?this.long0+Math.atan2(a.x,-a.y):this.long0-Math.atan2(-a.x,a.y):this.long0+Math.atan2(a.x*d,b*this.cos_p12*e-a.y*this.sin_p12*d))),a.x=f,a.y=g,a}return i=Cd(this.es),j=Dd(this.es),k=Ed(this.es),l=Fd(this.es),Math.abs(this.sin_p12-1)<=Gb?(m=this.a*Bd(i,j,k,l,Cb),b=Math.sqrt(a.x*a.x+a.y*a.y),n=m-b,g=Id(n/this.a,i,j,k,l),f=fc(this.long0+Math.atan2(a.x,-1*a.y)),a.x=f,a.y=g,a):Math.abs(this.sin_p12+1)<=Gb?(m=this.a*Bd(i,j,k,l,Cb),b=Math.sqrt(a.x*a.x+a.y*a.y),n=b-m,g=Id(n/this.a,i,j,k,l),f=fc(this.long0+Math.atan2(a.x,a.y)),a.x=f,a.y=g,a):(b=Math.sqrt(a.x*a.x+a.y*a.y),q=Math.atan2(a.x,a.y),o=Gd(this.a,this.e,this.sin_p12),r=Math.cos(q),s=this.e*this.cos_p12*r,t=-s*s/(1-this.es),u=3*this.es*(1-t)*this.sin_p12*this.cos_p12*r/(1-this.es),v=b/o,w=v-t*(1+t)*Math.pow(v,3)/6-u*(1+3*t)*Math.pow(v,4)/24,x=1-t*w*w/2-v*w*w*w/6,p=Math.asin(this.sin_p12*Math.cos(w)+this.cos_p12*Math.sin(w)*r),f=fc(this.long0+Math.asin(Math.sin(q)*Math.sin(w)/Math.cos(p))),g=Math.atan((1-this.es*x*this.sin_p12/Math.sin(p))*Math.tan(p)/(1-this.es)),a.x=f,a.y=g,a)}function tb(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0)}function ub(a){var b,c,d,e,f,g,h,i,j=a.x,k=a.y;return d=fc(j-this.long0),b=Math.sin(k),c=Math.cos(k),e=Math.cos(d),g=this.sin_p14*b+this.cos_p14*c*e,f=1,(g>0||Math.abs(g)<=Gb)&&(h=this.a*f*c*Math.sin(d),i=this.y0+this.a*f*(this.cos_p14*b-this.sin_p14*c*e)),a.x=h,a.y=i,a}function vb(a){var b,c,d,e,f,g,h;return a.x-=this.x0,a.y-=this.y0,b=Math.sqrt(a.x*a.x+a.y*a.y),c=Yd(b/this.a),d=Math.sin(c),e=Math.cos(c),g=this.long0,Math.abs(b)<=Gb?(h=this.lat0,a.x=g,a.y=h,a):(h=Yd(e*this.sin_p14+a.y*d*this.cos_p14/b),f=Math.abs(this.lat0)-Cb,Math.abs(f)<=Gb?(g=fc(this.lat0>=0?this.long0+Math.atan2(a.x,-a.y):this.long0-Math.atan2(-a.x,a.y)),a.x=g,a.y=h,a):(g=fc(this.long0+Math.atan2(a.x*d,b*this.cos_p14*e-a.y*this.sin_p14*d)),a.x=g,a.y=h,a))}var wb=function(a){a("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),a("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),a("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),a.WGS84=a["EPSG:4326"],a["EPSG:3785"]=a["EPSG:3857"],a.GOOGLE=a["EPSG:3857"],a["EPSG:900913"]=a["EPSG:3857"],a["EPSG:102113"]=a["EPSG:3857"]},xb=1,yb=2,zb=4,Ab=5,Bb=484813681109536e-20,Cb=Math.PI/2,Db=.16666666666666666,Eb=.04722222222222222,Fb=.022156084656084655,Gb="undefined"==typeof Number.EPSILON?1e-10:Number.EPSILON,Hb=.017453292519943295,Ib=57.29577951308232,Jb=Math.PI/4,Kb=2*Math.PI,Lb=3.14159265359,Mb={};Mb.greenwich=0,Mb.lisbon=-9.131906111111,Mb.paris=2.337229166667,Mb.bogota=-74.080916666667,Mb.madrid=-3.687938888889,Mb.rome=12.452333333333,Mb.bern=7.439583333333,Mb.jakarta=106.807719444444,Mb.ferro=-17.666666666667,Mb.brussels=4.367975,Mb.stockholm=18.058277777778,Mb.athens=23.7163375,Mb.oslo=10.722916666667;var Nb={ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937}},Ob=/[\s_\-\/\(\)]/g,Pb=function(b){var c,d,e,f={},g=b.split("+").map(function(a){return a.trim()}).filter(function(a){return a}).reduce(function(a,b){var c=b.split("=");return c.push(!0),a[c[0].toLowerCase()]=c[1],a},{}),h={proj:"projName",datum:"datumCode",rf:function(a){f.rf=parseFloat(a)},lat_0:function(a){f.lat0=a*Hb},lat_1:function(a){f.lat1=a*Hb},lat_2:function(a){f.lat2=a*Hb},lat_ts:function(a){f.lat_ts=a*Hb},lon_0:function(a){f.long0=a*Hb},lon_1:function(a){f.long1=a*Hb},lon_2:function(a){f.long2=a*Hb},alpha:function(a){f.alpha=parseFloat(a)*Hb},lonc:function(a){f.longc=a*Hb},x_0:function(a){f.x0=parseFloat(a)},y_0:function(a){f.y0=parseFloat(a)},k_0:function(a){f.k0=parseFloat(a)},k:function(a){f.k0=parseFloat(a)},a:function(a){f.a=parseFloat(a)},b:function(a){f.b=parseFloat(a)},r_a:function(){f.R_A=!0},zone:function(a){f.zone=parseInt(a,10)},south:function(){f.utmSouth=!0},towgs84:function(a){f.datum_params=a.split(",").map(function(a){return parseFloat(a)})},to_meter:function(a){f.to_meter=parseFloat(a)},units:function(b){f.units=b;var c=a(Nb,b);c&&(f.to_meter=c.to_meter)},from_greenwich:function(a){f.from_greenwich=a*Hb},pm:function(b){var c=a(Mb,b);f.from_greenwich=(c?c:parseFloat(b))*Hb},nadgrids:function(a){"@null"===a?f.datumCode="none":f.nadgrids=a},axis:function(a){var b="ewnsud";3===a.length&&b.indexOf(a.substr(0,1))!==-1&&b.indexOf(a.substr(1,1))!==-1&&b.indexOf(a.substr(2,1))!==-1&&(f.axis=a)}};for(c in g)d=g[c],c in h?(e=h[c],"function"==typeof e?e(d):f[e]=d):f[c]=d;return"string"==typeof f.datumCode&&"WGS84"!==f.datumCode&&(f.datumCode=f.datumCode.toLowerCase()),f},Qb=1,Rb=2,Sb=3,Tb=4,Ub=5,Vb=-1,Wb=/\s/,Xb=/[A-Za-z]/,Yb=/[A-Za-z84]/,Zb=/[,\]]/,$b=/[\d\.E\-\+]/;b.prototype.readCharicter=function(){var a=this.text[this.place++];if(this.state!==Tb)for(;Wb.test(a);){if(this.place>=this.text.length)return;a=this.text[this.place++]}switch(this.state){case Qb:return this.neutral(a);case Rb:return this.keyword(a);case Tb:return this.quoted(a);case Ub:return this.afterquote(a);case Sb:return this.number(a);case Vb:return}},b.prototype.afterquote=function(a){if('"'===a)return this.word+='"',void(this.state=Tb);if(Zb.test(a))return this.word=this.word.trim(),void this.afterItem(a);throw new Error("havn't handled \""+a+'" in afterquote yet, index '+this.place)},b.prototype.afterItem=function(a){return","===a?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=Qb)):"]"===a?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=Qb,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=Vb))):void 0},b.prototype.number=function(a){if($b.test(a))return void(this.word+=a);if(Zb.test(a))return this.word=parseFloat(this.word),void this.afterItem(a);throw new Error("havn't handled \""+a+'" in number yet, index '+this.place)},b.prototype.quoted=function(a){return'"'===a?void(this.state=Ub):void(this.word+=a)},b.prototype.keyword=function(a){if(Yb.test(a))return void(this.word+=a);if("["===a){var b=[];return b.push(this.word),this.level++,null===this.root?this.root=b:this.currentObject.push(b),this.stack.push(this.currentObject),this.currentObject=b,void(this.state=Qb)}if(Zb.test(a))return void this.afterItem(a);throw new Error("havn't handled \""+a+'" in keyword yet, index '+this.place)},b.prototype.neutral=function(a){if(Xb.test(a))return this.word=a,void(this.state=Rb);if('"'===a)return this.word="",void(this.state=Tb);if($b.test(a))return this.word=a,void(this.state=Sb);if(Zb.test(a))return void this.afterItem(a);throw new Error("havn't handled \""+a+'" in neutral yet, index '+this.place)},b.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(this.state===Vb)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};var _b=.017453292519943295,ac=function(a){var b=c(a),d=b.shift(),f=b.shift();b.unshift(["name",f]),b.unshift(["type",d]);var g={};return e(b,g),h(g),g};wb(i);var bc=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"],cc=function(a,b){a=a||{};var c,d;if(!b)return a;for(d in b)c=b[d],void 0!==c&&(a[d]=c);return a},dc=function(a,b,c){var d=a*b;return c/Math.sqrt(1-d*d)},ec=function(a){return a<0?-1:1},fc=function(a){return Math.abs(a)<=Lb?a:a-ec(a)*Kb},gc=function(a,b,c){var d=a*c,e=.5*a;return d=Math.pow((1-d)/(1+d),e),Math.tan(.5*(Cb-b))/d},hc=function(a,b){for(var c,d,e=.5*a,f=Cb-2*Math.atan(b),g=0;g<=15;g++)if(c=a*Math.sin(f),d=Cb-2*Math.atan(b*Math.pow((1-c)/(1+c),e))-f,f+=d,Math.abs(d)<=1e-10)return f;return-9999},ic=["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"],jc={init:o,forward:p,inverse:q,names:ic},kc=["longlat","identity"],lc={init:r,forward:s,inverse:s,names:kc},mc=[jc,lc],nc={},oc=[],pc={start:v,add:t,get:u},qc={};qc.MERIT={a:6378137,rf:298.257,ellipseName:"MERIT 1983"},qc.SGS85={a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},qc.GRS80={a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},qc.IAU76={a:6378140,rf:298.257,ellipseName:"IAU 1976"},qc.airy={a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},qc.APL4={a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},qc.NWL9D={a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},qc.mod_airy={a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},qc.andrae={a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},qc.aust_SA={a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},qc.GRS67={a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},qc.bessel={a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},qc.bess_nam={a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},qc.clrk66={a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},qc.clrk80={a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},qc.clrk58={a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},qc.CPM={a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},qc.delmbr={a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},qc.engelis={a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},qc.evrst30={a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},qc.evrst48={a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},qc.evrst56={a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},qc.evrst69={a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},qc.evrstSS={a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},qc.fschr60={a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},qc.fschr60m={a:6378155,rf:298.3,ellipseName:"Fischer 1960"},qc.fschr68={a:6378150,rf:298.3,ellipseName:"Fischer 1968"},qc.helmert={a:6378200,rf:298.3,ellipseName:"Helmert 1906"},qc.hough={a:6378270,rf:297,ellipseName:"Hough"},qc.intl={a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},qc.kaula={a:6378163,rf:298.24,ellipseName:"Kaula 1961"},qc.lerch={a:6378139,rf:298.257,ellipseName:"Lerch 1979"},qc.mprts={a:6397300,rf:191,ellipseName:"Maupertius 1738"},qc.new_intl={a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},qc.plessis={a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},qc.krass={a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},qc.SEasia={a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},qc.walbeck={a:6376896,b:6355834.8467,ellipseName:"Walbeck"},qc.WGS60={a:6378165,rf:298.3,ellipseName:"WGS 60"},qc.WGS66={a:6378145,rf:298.25,ellipseName:"WGS 66"},qc.WGS7={a:6378135,rf:298.26,ellipseName:"WGS 72"};var rc=qc.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"};qc.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"};var sc={};sc.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},sc.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},sc.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},sc.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},sc.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},sc.potsdam={towgs84:"606.0,23.0,413.0",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},sc.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},sc.hermannskogel={towgs84:"653.0,-212.0,449.0",ellipse:"bessel",datumName:"Hermannskogel"},sc.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},sc.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},sc.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},sc.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},sc.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},sc.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},sc.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},sc.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"},z.projections=pc,z.projections.start();
var tc=function(a,b,c){return A(a,b)?c:a.datum_type===Ab||b.datum_type===Ab?c:a.es!==b.es||a.a!==b.a||F(a.datum_type)||F(b.datum_type)?(c=B(c,a.es,a.a),F(a.datum_type)&&(c=D(c,a.datum_type,a.datum_params)),F(b.datum_type)&&(c=E(c,b.datum_type,b.datum_params)),C(c,b.es,b.a,b.b)):c},uc=function(a,b,c){var d,e,f,g=c.x,h=c.y,i=c.z||0,j={};for(f=0;f<3;f++)if(!b||2!==f||void 0!==c.z)switch(0===f?(d=g,e="x"):1===f?(d=h,e="y"):(d=i,e="z"),a.axis[f]){case"e":j[e]=d;break;case"w":j[e]=-d;break;case"n":j[e]=d;break;case"s":j[e]=-d;break;case"u":void 0!==c[e]&&(j.z=d);break;case"d":void 0!==c[e]&&(j.z=-d);break;default:return null}return j},vc=function(a){var b={x:a[0],y:a[1]};return a.length>2&&(b.z=a[2]),a.length>3&&(b.m=a[3]),b},wc=z("WGS84"),xc=6,yc="AJSAJS",zc="AFAFAF",Ac=65,Bc=73,Cc=79,Dc=86,Ec=90,Fc={forward:L,inverse:M,toPoint:N};Point.fromMGRS=function(a){return new Point(N(a))},Point.prototype.toMGRS=function(a){return L([this.x,this.y],a)};var Gc="2.4.3",Hc=1,Ic=.25,Jc=.046875,Kc=.01953125,Lc=.01068115234375,Mc=.75,Nc=.46875,Oc=.013020833333333334,Pc=.007120768229166667,Qc=.3645833333333333,Rc=.005696614583333333,Sc=.3076171875,Tc=function(a){var b=[];b[0]=Hc-a*(Ic+a*(Jc+a*(Kc+a*Lc))),b[1]=a*(Mc-a*(Jc+a*(Kc+a*Lc)));var c=a*a;return b[2]=c*(Nc-a*(Oc+a*Pc)),c*=a,b[3]=c*(Qc-a*Rc),b[4]=c*a*Sc,b},Uc=function(a,b,c,d){return c*=b,b*=b,d[0]*a-c*(d[1]+b*(d[2]+b*(d[3]+b*d[4])))},Vc=20,Wc=function(a,b,c){for(var d=1/(1-b),e=a,f=Vc;f;--f){var g=Math.sin(e),h=1-b*g*g;if(h=(Uc(e,g,Math.cos(e),c)-a)*(h*Math.sqrt(h))*d,e-=h,Math.abs(h)<Gb)return e}return e},Xc=["Transverse_Mercator","Transverse Mercator","tmerc"],Yc={init:_,forward:aa,inverse:ba,names:Xc},Zc=function(a){var b=Math.exp(a);return b=(b-1/b)/2},$c=function(a,b){a=Math.abs(a),b=Math.abs(b);var c=Math.max(a,b),d=Math.min(a,b)/(c?c:1);return c*Math.sqrt(1+Math.pow(d,2))},_c=function(a){var b=1+a,c=b-1;return 0===c?a:a*Math.log(b)/c},ad=function(a){var b=Math.abs(a);return b=_c(b*(1+b/($c(1,b)+1))),a<0?-b:b},bd=function(a,b){for(var c,d=2*Math.cos(2*b),e=a.length-1,f=a[e],g=0;--e>=0;)c=-g+d*f+a[e],g=f,f=c;return b+c*Math.sin(2*b)},cd=function(a,b){for(var c,d=2*Math.cos(b),e=a.length-1,f=a[e],g=0;--e>=0;)c=-g+d*f+a[e],g=f,f=c;return Math.sin(b)*c},dd=function(a){var b=Math.exp(a);return b=(b+1/b)/2},ed=function(a,b,c){for(var d,e,f=Math.sin(b),g=Math.cos(b),h=Zc(c),i=dd(c),j=2*g*i,k=-2*f*h,l=a.length-1,m=a[l],n=0,o=0,p=0;--l>=0;)d=o,e=n,o=m,n=p,m=-d+j*o-k*n+a[l],p=-e+k*o+j*n;return j=f*i,k=g*h,[j*m-k*p,j*p+k*m]},fd=["Extended_Transverse_Mercator","Extended Transverse Mercator","etmerc"],gd={init:ca,forward:da,inverse:ea,names:fd},hd=function(a,b){if(void 0===a){if(a=Math.floor(30*(fc(b)+Math.PI)/Math.PI)+1,a<0)return 0;if(a>60)return 60}return a},id="etmerc",jd=["Universal Transverse Mercator System","utm"],kd={init:fa,names:jd,dependsOn:id},ld=function(a,b){return Math.pow((1-a)/(1+a),b)},md=20,nd=["gauss"],od={init:ga,forward:ha,inverse:ia,names:nd},pd=["Stereographic_North_Pole","Oblique_Stereographic","Polar_Stereographic","sterea","Oblique Stereographic Alternative"],qd={init:ja,forward:ka,inverse:la,names:pd},rd=["stere","Stereographic_South_Pole","Polar Stereographic (variant B)"],sd={init:na,forward:oa,inverse:pa,names:rd,ssfn_:ma},td=["somerc"],ud={init:qa,forward:ra,inverse:sa,names:td},vd=["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","omerc"],wd={init:ta,forward:ua,inverse:va,names:vd},xd=["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_2SP","lcc"],yd={init:wa,forward:xa,inverse:ya,names:xd},zd=["Krovak","krovak"],Ad={init:za,forward:Aa,inverse:Ba,names:zd},Bd=function(a,b,c,d,e){return a*e-b*Math.sin(2*e)+c*Math.sin(4*e)-d*Math.sin(6*e)},Cd=function(a){return 1-.25*a*(1+a/16*(3+1.25*a))},Dd=function(a){return.375*a*(1+.25*a*(1+.46875*a))},Ed=function(a){return.05859375*a*a*(1+.75*a)},Fd=function(a){return a*a*a*(35/3072)},Gd=function(a,b,c){var d=b*c;return a/Math.sqrt(1-d*d)},Hd=function(a){return Math.abs(a)<Cb?a:a-ec(a)*Math.PI},Id=function(a,b,c,d,e){var f,g;f=a/b;for(var h=0;h<15;h++)if(g=(a-(b*f-c*Math.sin(2*f)+d*Math.sin(4*f)-e*Math.sin(6*f)))/(b-2*c*Math.cos(2*f)+4*d*Math.cos(4*f)-6*e*Math.cos(6*f)),f+=g,Math.abs(g)<=1e-10)return f;return NaN},Jd=["Cassini","Cassini_Soldner","cass"],Kd={init:Ca,forward:Da,inverse:Ea,names:Jd},Ld=function(a,b){var c;return a>1e-7?(c=a*b,(1-a*a)*(b/(1-c*c)-.5/a*Math.log((1-c)/(1+c)))):2*b},Md=1,Nd=2,Od=3,Pd=4,Qd=.3333333333333333,Rd=.17222222222222222,Sd=.10257936507936508,Td=.06388888888888888,Ud=.0664021164021164,Vd=.016415012942191543,Wd=["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],Xd={init:Fa,forward:Ga,inverse:Ha,names:Wd,S_POLE:Md,N_POLE:Nd,EQUIT:Od,OBLIQ:Pd},Yd=function(a){return Math.abs(a)>1&&(a=a>1?1:-1),Math.asin(a)},Zd=["Albers_Conic_Equal_Area","Albers","aea"],$d={init:Ka,forward:La,inverse:Ma,names:Zd,phi1z:Na},_d=["gnom"],ae={init:Oa,forward:Pa,inverse:Qa,names:_d},be=function(a,b){var c=1-(1-a*a)/(2*a)*Math.log((1-a)/(1+a));if(Math.abs(Math.abs(b)-c)<1e-6)return b<0?-1*Cb:Cb;for(var d,e,f,g,h=Math.asin(.5*b),i=0;i<30;i++)if(e=Math.sin(h),f=Math.cos(h),g=a*e,d=Math.pow(1-g*g,2)/(2*f)*(b/(1-a*a)-e/(1-g*g)+.5/a*Math.log((1-g)/(1+g))),h+=d,Math.abs(d)<=1e-10)return h;return NaN},ce=["cea"],de={init:Ra,forward:Sa,inverse:Ta,names:ce},ee=["Equirectangular","Equidistant_Cylindrical","eqc"],fe={init:Ua,forward:Va,inverse:Wa,names:ee},ge=20,he=["Polyconic","poly"],ie={init:Xa,forward:Ya,inverse:Za,names:he},je=["New_Zealand_Map_Grid","nzmg"],ke={init:$a,forward:_a,inverse:ab,names:je},le=["Miller_Cylindrical","mill"],me={init:bb,forward:cb,inverse:db,names:le},ne=20,oe=["Sinusoidal","sinu"],pe={init:eb,forward:fb,inverse:gb,names:oe},qe=["Mollweide","moll"],re={init:hb,forward:ib,inverse:jb,names:qe},se=["Equidistant_Conic","eqdc"],te={init:kb,forward:lb,inverse:mb,names:se},ue=["Van_der_Grinten_I","VanDerGrinten","vandg"],ve={init:nb,forward:ob,inverse:pb,names:ue},we=["Azimuthal_Equidistant","aeqd"],xe={init:qb,forward:rb,inverse:sb,names:we},ye=["ortho"],ze={init:tb,forward:ub,inverse:vb,names:ye},Ae=function(proj4){proj4.Proj.projections.add(Yc),proj4.Proj.projections.add(gd),proj4.Proj.projections.add(kd),proj4.Proj.projections.add(qd),proj4.Proj.projections.add(sd),proj4.Proj.projections.add(ud),proj4.Proj.projections.add(wd),proj4.Proj.projections.add(yd),proj4.Proj.projections.add(Ad),proj4.Proj.projections.add(Kd),proj4.Proj.projections.add(Xd),proj4.Proj.projections.add($d),proj4.Proj.projections.add(ae),proj4.Proj.projections.add(de),proj4.Proj.projections.add(fe),proj4.Proj.projections.add(ie),proj4.Proj.projections.add(ke),proj4.Proj.projections.add(me),proj4.Proj.projections.add(pe),proj4.Proj.projections.add(re),proj4.Proj.projections.add(te),proj4.Proj.projections.add(ve),proj4.Proj.projections.add(xe),proj4.Proj.projections.add(ze)};return K.defaultDatum="WGS84",K.Proj=z,K.WGS84=new K.Proj("WGS84"),K.Point=Point,K.toPoint=vc,K.defs=i,K.transform=H,K.mgrs=Fc,K.version=Gc,Ae(K),K});
var TC = TC || {};

TC.tool = TC.tool || {};

TC.tool.Proxification = function (proxy, options) {
    var self = this;

    self.Consts = {
        url: {
            SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/
        }
    };

    if (proxy === undefined) {
        throw new TypeError('"proxy" parameter is undefined', "TC.tool.Proxification.js");
    }

    if (typeof proxy == "function") {
        self.proxy = proxy;
    } else {
        self.proxy = function (url) {
            var result = proxy;
            if (url.substr(0, 4) != "http") {
                result += window.location.protocol;
            }
            result += encodeURIComponent(url);
            return result;
        };
    }

    options = options || {};

    self._location = options.location || window.location;

    self.preventMixedContent = options.allowedMixedContent !== undefined ? !options.allowedMixedContent : true;
};

(function () {
    if (!window.fetch) {
        (function (self) {
            // polyfill https://github.com/github/fetch/
            'use strict'; if (self.fetch) { return }
            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }
            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }
            function normalizeName(name) {
                if (typeof name !== 'string') { name = String(name) }
                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) { throw new TypeError('Invalid character in header field name') }
                return name.toLowerCase()
            }
            function normalizeValue(value) {
                if (typeof value !== 'string') { value = String(value) }
                return value
            }
            function iteratorFor(items) {
                var iterator = {
                    next: function () {
                        var value = items.shift()
                        return { done: value === undefined, value: value }
                    }
                }
                if (support.iterable) { iterator[Symbol.iterator] = function () { return iterator } }
                return iterator
            }
            function Headers(headers) {
                this.map = {}
                if (headers instanceof Headers) { headers.forEach(function (value, name) { this.append(name, value) }, this) } else if (Array.isArray(headers)) { headers.forEach(function (header) { this.append(header[0], header[1]) }, this) } else if (headers) { Object.getOwnPropertyNames(headers).forEach(function (name) { this.append(name, headers[name]) }, this) }
            }
            Headers.prototype.append = function (name, value) {
                name = normalizeName(name)
                value = normalizeValue(value)
                var oldValue = this.map[name]
                this.map[name] = oldValue ? oldValue + ',' + value : value
            }
            Headers.prototype['delete'] = function (name) { delete this.map[normalizeName(name)] }
            Headers.prototype.get = function (name) {
                name = normalizeName(name)
                return this.has(name) ? this.map[name] : null
            }
            Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)) }
            Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = normalizeValue(value) }
            Headers.prototype.forEach = function (callback, thisArg) { for (var name in this.map) { if (this.map.hasOwnProperty(name)) { callback.call(thisArg, this.map[name], name, this) } } }
            Headers.prototype.keys = function () {
                var items = []
                this.forEach(function (value, name) { items.push(name) })
                return iteratorFor(items)
            }
            Headers.prototype.values = function () {
                var items = []
                this.forEach(function (value) { items.push(value) })
                return iteratorFor(items)
            }
            Headers.prototype.entries = function () {
                var items = []
                this.forEach(function (value, name) { items.push([name, value]) })
                return iteratorFor(items)
            }
            if (support.iterable) { Headers.prototype[Symbol.iterator] = Headers.prototype.entries }
            function consumed(body) {
                if (body.bodyUsed) { return Promise.reject(new TypeError('Already read')) }
                body.bodyUsed = !0
            }
            function fileReaderReady(reader) {
                return new Promise(function (resolve, reject) {
                    reader.onload = function () { resolve(reader.result) }
                    reader.onerror = function () { reject(reader.error) }
                })
            }
            function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsArrayBuffer(blob)
                return promise
            }
            function readBlobAsText(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsText(blob)
                return promise
            }
            function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf)
                var chars = new Array(view.length)
                for (var i = 0; i < view.length; i++) { chars[i] = String.fromCharCode(view[i]) }
                return chars.join('')
            }
            function bufferClone(buf) {
                if (buf.slice) { return buf.slice(0) } else {
                    var view = new Uint8Array(buf.byteLength)
                    view.set(new Uint8Array(buf))
                    return view.buffer
                }
            }
            function Body() {
                this.bodyUsed = !1
                this._initBody = function (body) {
                    this._bodyInit = body
                    if (!body) { this._bodyText = '' } else if (typeof body === 'string') { this._bodyText = body } else if (support.blob && Blob.prototype.isPrototypeOf(body)) { this._bodyBlob = body } else if (support.formData && FormData.prototype.isPrototypeOf(body)) { this._bodyFormData = body } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this._bodyText = body.toString() } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                        this._bodyArrayBuffer = bufferClone(body.buffer)
                        this._bodyInit = new Blob([this._bodyArrayBuffer])
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) { this._bodyArrayBuffer = bufferClone(body) } else { throw new Error('unsupported BodyInit type') }
                    if (!this.headers.get('content-type')) { if (typeof body === 'string') { this.headers.set('content-type', 'text/plain;charset=UTF-8') } else if (this._bodyBlob && this._bodyBlob.type) { this.headers.set('content-type', this._bodyBlob.type) } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8') } }
                }
                if (support.blob) {
                    this.blob = function () {
                        var rejected = consumed(this)
                        if (rejected) { return rejected }
                        if (this._bodyBlob) { return Promise.resolve(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(new Blob([this._bodyArrayBuffer])) } else if (this._bodyFormData) { throw new Error('could not read FormData body as blob') } else { return Promise.resolve(new Blob([this._bodyText])) }
                    }
                    this.arrayBuffer = function () { if (this._bodyArrayBuffer) { return consumed(this) || Promise.resolve(this._bodyArrayBuffer) } else { return this.blob().then(readBlobAsArrayBuffer) } }
                }
                this.text = function () {
                    var rejected = consumed(this)
                    if (rejected) { return rejected }
                    if (this._bodyBlob) { return readBlobAsText(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer)) } else if (this._bodyFormData) { throw new Error('could not read FormData body as text') } else { return Promise.resolve(this._bodyText) }
                }
                if (support.formData) { this.formData = function () { return this.text().then(decode) } }
                this.json = function () { return this.text().then(JSON.parse) }
                return this
            }
            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
            function normalizeMethod(method) {
                var upcased = method.toUpperCase()
                return (methods.indexOf(upcased) > -1) ? upcased : method
            }
            function Request(input, options) {
                options = options || {}
                var body = options.body
                if (input instanceof Request) {
                    if (input.bodyUsed) { throw new TypeError('Already read') }
                    this.url = input.url
                    this.credentials = input.credentials
                    if (!options.headers) { this.headers = new Headers(input.headers) }
                    this.method = input.method
                    this.mode = input.mode
                    if (!body && input._bodyInit != null) {
                        body = input._bodyInit
                        input.bodyUsed = !0
                    }
                } else { this.url = String(input) }
                this.credentials = options.credentials || this.credentials || 'omit'
                if (options.headers || !this.headers) { this.headers = new Headers(options.headers) }
                this.method = normalizeMethod(options.method || this.method || 'GET')
                this.mode = options.mode || this.mode || null
                this.referrer = null
                if ((this.method === 'GET' || this.method === 'HEAD') && body) { throw new TypeError('Body not allowed for GET or HEAD requests') }
                this._initBody(body)
            }
            Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }) }
            function decode(body) {
                var form = new FormData()
                body.trim().split('&').forEach(function (bytes) {
                    if (bytes) {
                        var split = bytes.split('=')
                        var name = split.shift().replace(/\+/g, ' ')
                        var value = split.join('=').replace(/\+/g, ' ')
                        form.append(decodeURIComponent(name), decodeURIComponent(value))
                    }
                })
                return form
            }
            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }
            Body.call(Request.prototype)
            function Response(bodyInit, options) {
                if (!options) { options = {} }
                this.type = 'default'
                this.status = options.status === undefined ? 200 : options.status
                this.ok = this.status >= 200 && this.status < 300
                this.statusText = 'statusText' in options ? options.statusText : 'OK'
                this.headers = new Headers(options.headers)
                this.url = options.url || ''
                this._initBody(bodyInit)
            }
            Body.call(Response.prototype)
            Response.prototype.clone = function () { return new Response(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url }) }
            Response.error = function () {
                var response = new Response(null, { status: 0, statusText: '' })
                response.type = 'error'
                return response
            }
            var redirectStatuses = [301, 302, 303, 307, 308]
            Response.redirect = function (url, status) {
                if (redirectStatuses.indexOf(status) === -1) { throw new RangeError('Invalid status code') }
                return new Response(null, { status: status, headers: { location: url } })
            }
            self.Headers = Headers
            self.Request = Request
            self.Response = Response
            self.fetch = function (input, init) {
                return new Promise(function (resolve, reject) {
                    var request = new Request(input, init);
                    init = init || {};
                    var xhr = new XMLHttpRequest();
                    xhr.onload = function () {
                        if (xhr.status === 0) {
                            return new Response(null, { status: xhr.status });
                        } else {
                            var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') }
                            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
                            var body = 'response' in xhr ? xhr.response : xhr.responseText
                            resolve(new Response(body, options))
                        }
                    }
                    xhr.onerror = function () { reject(new TypeError('Network request failed')) }
                    xhr.ontimeout = function () { reject(new TypeError('Network request failed')) }
                    xhr.open(request.method, request.url, !init.sync)
                    if (request.credentials === 'include') { xhr.withCredentials = !0 } else if (request.credentials === 'omit') { xhr.withCredentials = !1 }
                    if (!init.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' }
                    request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) })
                    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
                })
            }
            self.fetch.polyfill = !0
        })(typeof self !== 'undefined' ? self : this);
    }

    var srcToURL = function (src) {
        // GLS: 30/01/2019 Se carga un polyfill que no implementa correctamente el origin
        //if (window.URL && !(src.indexOf('//') == 0)) {
        //    try {
        //        var url = new URL(src);
        //        if (url.origin && url.origin.length > 0) {
        //            return url;
        //        }
        //    }
        //    catch (error) {
        //        // no hacemos nada y seguimos adelante
        //    }
        //}

        var anchor = document.createElement('a');
        anchor.href = src;

        if (!anchor.origin) {

            if (!(anchor.protocol && anchor.hostname)) {
                var urlParts = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(anchor.href);

                anchor.protocol = urlParts[1];

                if (urlParts[4].indexOf(':') > -1) {
                    var hostname = urlParts[4].split(':');
                    anchor.hostname = hostname[0];
                    anchor.port = hostname[1];
                } else {
                    anchor.hostname = urlParts[4];
                }
            }

            anchor.origin = (anchor.protocol.length === 0 ? window.location.protocol : anchor.protocol) + "//" + anchor.hostname + (anchor.port && (src.indexOf(anchor.port) > -1) ? ':' + anchor.port : '');
        }

        return anchor;
    };

    function HostCacheService(objectStoreName) {
        this.database = null;
        this.objectStoreName = objectStoreName;
    }

    HostCacheService.prototype = {
        /* createDB : create the scheme of the database  */
        createDB: function () {

            // In the following line, you should include the prefixes of implementations you want to test.
            window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            // DON'T use "var indexedDB = ..." if you're not in a function.
            // Moreover, you may need references to some window.IDB* objects:
            window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
            window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
            if (!window.indexedDB) {
                window.alert("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
            }

            var request = window.indexedDB.open('HostCacheService', 1);
            var that = this;
            request.onsuccess = function (evt) {
                that.database = evt.target.result;
            };
            request.onerror = function (evt) {
                console.log("IndexedDB--> onerror ");
            };
            request.onupgradeneeded = function (evt) {
                var thisDB = evt.target.result;
                if (!thisDB.objectStoreNames.contains('HostAction')) {
                    var store = thisDB.createObjectStore('HostAction', { keyPath: 'id' });
                    store.createIndex("host", ["action"], { unique: true });
                }
            };
        },
        /* info on available storage */
        info: function () {
            // Request storage usage and capacity left
            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT
                function (used, remaining) {
                    console.log("Used quota: " + used + ", remaining quota: " + remaining);
                }, function (e) {
                    console.log('Error', e);
                });
        },
        /* isReady when objectStore has been created  */
        isReady: function () {
            if (!this.database)
                return false;

            return this.database.objectStoreNames.contains(this.objectStoreName);
        },
        getHost: function (host) {
            return new Promise(function (resolve, reject) {
                if (!this.database) {
                    console.log("getAction no database", this.database);
                    reject("no IndexedDB");
                }
                else {
                    var transaction = this.database.transaction(this.objectStoreName);
                    var hostIndex = transaction.objectStore(this.objectStoreName).index("host");

                    var requestGet = hostIndex.get([host]);
                    requestGet.onsuccess = function (evt) {
                        if (evt.target.result) {
                            resolve({ data: evt.target.result });
                        }
                        else { reject("no action"); }
                    };

                    requestGet.onerror = function (evt) {
                        reject("no action get failed");
                    };
                }
            });
        },
        addHost: function (host, action) {

            if (this.database) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                try {
                    // the transaction could abort because of a QuotaExceededError error
                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });
                    transaction.objectStore(this.objectStoreName).add({ id: guid, host: host, action: action });
                }
                catch (ex) {
                    console.log(ex);
                }

            }
            else {
                console.log("addHost no database");
            }
        },
        removeHost: function (host) {
            this.getHost(host).then(function (host) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                transaction.objectStore(this.objectStoreName).delete(host.data.id);
            });
        }
    };

    const HostCacheItem = function () {
        this.key = "";
        this.action = null;
        this.actionName = "";
    };

    const HostCache = function () {
        var toHost = function (src) {
            var url = srcToURL(src);
            if (url) {
                return url.origin;
            }

            return null;
        };

        //this.hostCacheService = new HostCacheService("HostAction");
        //this.hostCacheService.createDB();

        this._hosts = [];
        this._hostsImage = [];

        this.is = function (src, options) {
            var host = toHost(src);

            return this.get(host, options) !== null;
        };

        this.get = function (host, options) {
            if (this.getList(options).length === 0) {
                return null;
            } else {
                var filtered = this.getList(options).filter(function (h) {
                    return h.key === host && options.exportable == h.exportable;
                });
                if (filtered.length === 0) {
                    return null;
                } else {
                    return filtered[0];
                }
            }
        };

        this.getList = function (options) {
            return options.forImage ? this._hostsImage : this._hosts;
        };

        this.addKey = function (src, options) {
            var host = toHost(src);
            var newItem = { key: host, action: null };
            if (options.exportable) {
                newItem.exportable = options.exportable;
            }
            this.getList(options).push(newItem);
            return this.getList(options)[this.getList(options).length - 1];
        };

        this.removeKey = function (src, options) {
            var host = toHost(src);

            for (var i = 0; i < this.getList(options).length; i++) {
                if (this.getList(options)[i].key === host && options.exportable == this.getList(options)[i].exportable) {
                    this.getList(options).splice(i, 1);
                    break;
                }
            }
        };

        this.getAction = function (src, options) {
            options = options || {};

            var host = toHost(src);
            var cache = this.get(host, options);
            if (!cache) {
                return Promise.reject(new Error('Cache null'));
            }
            return cache._actionPromise;
        };
    };

    var toolProto = TC.tool.Proxification.prototype;

    toolProto.cacheHost = new HostCache();

    toolProto._isServiceWorker = function () {
        if (navigator.serviceWorker) {
            if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                return true;
            } else {
                navigator.serviceWorker.ready
                    .then(function (registration) {
                        if (registration.active) {
                            return true;
                        } else {
                            return false;
                        }
                    });

                return false;
            }
        } else {
            return false;
        }
    };

    toolProto._isSameOrigin = function (uri) {
        var self = this;

        var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
        var urlParts = !result && uri.match(self.Consts.url.SPLIT_REGEX);
        if (urlParts) {
            var uProtocol = urlParts[1];
            result = (uProtocol == self._location.protocol || uProtocol == undefined) && urlParts[3] == self._location.hostname;
            var uPort = urlParts[4], lPort = self._location.port;
            if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                result = result && uPort == lPort;
            }
        }
        return result;
    };

    toolProto._isSameProtocol = function (uri) {
        var protocolRegex = /^(https?:\/\/)/i;
        var uriProtocol = uri.match(protocolRegex);
        if (uriProtocol && uriProtocol.length > 1) {
            var locationProtocol = self._location.match(protocolRegex);
            if (locationProtocol && locationProtocol.length > 1) {
                return uriProtocol[0].trim() === locationProtocol[0].trim();
            }
        }

        return false;
    };

    toolProto._isSecureURL = function (url) {
        //sino empieza por http ni por https la consideramos segura
        if (!/^(f|ht)tps?:\/\//i.test(url))
            return true;
        return (/^(f|ht)tps:\/\//i.test(url));
    };

    const ResponseError = function (status, text, url) {
        this.status = status;
        this.text = text;
        this.url = url;
    };

    var changeProtocol = function (src, newProtocol) {
        var url = srcToURL(src);
        return src.replace(url.protocol, newProtocol);
    };

    var toHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    var toHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    var _currentHTTP = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTPS(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTPS);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTP(src), options, resolve, reject);
            }
        });
    };

    var _currentHTTPS = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTP(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTP);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTPS(src), options, resolve, reject);
            }
        });
    };

    var _byProxy = function (src, options, resolve, reject) {
        var self = this;

        options.sameOrigin = self._isSameOrigin(self._actionProxy.call(self, src));

        self._image.getImgTagByAction(src, options, self._actionProxy.bind(self)).then(function (img) {
            resolve(img, self._actionProxy);
        }, function (error) {
            reject(error);
        });
    };

    toolProto._actionDirect = function (src) {
        return src;
    };

    toolProto._actionHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    toolProto._actionHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    toolProto._actionProxy = function (src) {
        var self = this;

        return self.proxy(src);
    };

    toolProto._image = {
        ErrorType: {
            CORS: 'cors',
            PROTOCOL: 'protocol',
            NOTFOUNDED: 'notfounded',
            UNEXPECTED: 'unexpected'
        },
        checkHttpStatus: function (src) {
            const self = this;
            return fetch(src, { credentials: 'omit' })
                .then(function (response) {
                    return { status: response.status, statusText: response.statusText };
                })
                .catch(function (error) {
                    return self.ErrorType.UNEXPECTED;
                });
        },
        getImgTag: function (src, options) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (options.exportable && !options.sameOrigin) {
                    img.dataset.checkCORSHeaders = true;
                    img.crossOrigin = "anonymous";
                }

                img.onload = function () {

                    console.log('Load OK: ' + img.src);

                    img.onload = img.onerror = undefined;

                    if (options.exportable && !options.sameOrigin) {
                        var createCanvas = function (img) {
                            var canvas = document.createElement('CANVAS');
                            var ctx = canvas.getContext('2d');
                            canvas.height = img.height;
                            canvas.width = img.width;
                            ctx.drawImage(img, 0, 0);

                            return canvas;
                        };

                        try {
                            var canvas = createCanvas(img);
                            result = canvas.toDataURL("image/png");
                            resolve(img);
                        } catch (e) {
                            if (e.code === 18) { // GLS: 18 - SECURITY_ERR
                                reject(self.ErrorType.CORS);
                            } else {
                                resolve(img);
                            }
                        }
                    } else { resolve(img); }
                };

                img.onerror = function (error) {

                    console.log('Load crossOrigin ERROR: ' + img.src);

                    if (img.dataset.checkCORSHeaders) {
                        img.crossOrigin = null;

                        img.onerror = undefined;
                        img.onerror = function (error) {
                            console.log('Load ERROR: ' + img.src);

                            self.checkHttpStatus(img.src).then(function (error) {
                                if (options.ignoreProxification) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    if (error.status === 400) {
                                        reject(self.ErrorType.PROTOCOL);
                                    } else {
                                        reject(error);
                                    }
                                }
                            }).catch(reject);
                            img.onload = img.onerror = undefined;
                        };

                        img.src = src;

                    } else {
                        console.log('Load ERROR: ' + img.src);

                        img.onload = img.onerror = undefined;

                        self.checkHttpStatus(img.src).then(function (error) {
                            if (options.ignoreProxification) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                if (error.status === 400) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    reject(error);
                                }
                            }
                        }).catch(reject);
                    }
                };

                try {
                    img.src = src;
                } catch (ex) {
                    console.log('Load ERROR: ' + img.src);

                    reject(self.ErrorType.UNEXPECTED);
                }
            }.bind(toolProto._image));
        },
        getImgTagByAction: function (src, options, action) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (!options.sameOrigin) {
                    if (options.exportable) {
                        img.crossOrigin = "anonymous";
                    }
                }

                img.onload = function () {
                    img.onload = img.onerror = undefined;
                    resolve(img);
                };
                img.onerror = function (error) {
                    console.log('Load ERROR: ' + img.src);
                    img.onload = img.onerror = undefined;

                    self.checkHttpStatus(img.src).then(function (error) {
                        if (options.ignoreProxification) {
                            reject(self.ErrorType.PROTOCOL);
                        } else {
                            if (error.status === 400) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                reject(error);
                            }
                        }
                    }).catch(reject);
                };
                img.src = action(src);
            }.bind(toolProto._image));
        }
    };

    toolProto._fetch = {
        Headers: {
            CONTENTTYPE: "content-type"
        },
        ErrorType: {
            CORS: 'cors',
            NOTFOUNDED: 'Not_Founded',
            UNEXPECTED: 'Un_Expected',
            UNEXPECTEDCONTENTTYPE: 'Un_Expected_ContentType'
        },
        validateResponse: function (response) {
            if (!response.ok) { // status no está en el rango 200-299
                throw new ResponseError(response.status, response.statusText, response.url);
            }
            return response;
        },
        validateContentType: function (expectedContentType, response) {
            const self = this;

            if (!expectedContentType) {
                return response;
            }

            var contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);
            if (contentType && contentType.indexOf(expectedContentType) === -1) {
                throw Error(self._fetch.ErrorType.UNEXPECTEDCONTENTTYPE);
            }

            return response;
        }
    };

    /* Sólo GET */
    toolProto.fetchImage = function (src, options) {
        var self = this;

        options = options || {};
        options.forImage = true;

        return new Promise(function (resolve, reject) {

            if (self.cacheHost.is(src, options)) {
                self.cacheHost.getAction(src, options).then(function (cache) {
                    options.sameOrigin = self._isSameOrigin(cache.action(src));
                    self._image.getImgTagByAction(src, options, cache.action).then(function (img) {
                        resolve(img);
                    }, function (error) {
                        reject(error);
                    });
                });
            } else {
                var cache = self.cacheHost.addKey(src, options);
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    const _caching = function (img, action) {
                        cache.action = action.bind(self);
                        cache.exportable = options.exportable;

                        resolveActionPromise({ action: cache.action });

                        resolve(img);
                    };

                    const _reject = function (error) {
                        if (error.status == 200) {
                            //options.useCredentials = true;

                            // GLS: 04/01/2019 comento la siguiente línea porque no para de pedir al obtener una respuesta correcta y en el cuerpo viene una excepción
                            //makeRequest(options);

                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        } else {
                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        }
                    };

                    const makeRequest = function (options) {
                        if (self._isSameOrigin(src)) {
                            options.sameOrigin = true;
                            self._image.getImgTag(src, options).then(function (img) {
                                _caching(img, self._actionDirect);
                            }, _reject);
                        } else {
                            if (!self._isSecureURL(src)) {
                                if (self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                    // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                    _currentHTTP.call(self, src, options, _caching, _reject);
                                } else {
                                    // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                    self._image.getImgTag(src, options).then(function (img) {
                                        _caching(img, self._actionDirect);
                                    }, function (error) {
                                        if ((options.exportable && error === self._image.ErrorType.CORS) || !self._isSecureURL(self._location)) {
                                            // Si la imagen debe ser exportable y en la solicitud por HTTP tenemos error de CORS, deducimos que por HTTPS pasará lo mismo
                                            if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                                _reject(error);
                                            } else {
                                                _byProxy.call(self, src, options, _caching, _reject);
                                            }
                                        } else {
                                            _currentHTTP.call(self, src, options, _caching, _reject);
                                        }
                                    });

                                }
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                self._image.getImgTag(src, options).then(function (img) {
                                    _caching(img, self._actionDirect);
                                }, function (error) {
                                    if ((options.exportable && error === self._image.ErrorType.CORS) || self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                        // Si la imagen debe ser exportable y en la solicitud por HTTPS tenemos error de CORS, deducimos que por HTTP pasará lo mismo
                                        if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                            _reject(error);
                                        } else {
                                            _byProxy.call(self, src, options, _caching, _reject);
                                        }
                                    } else {
                                        _currentHTTPS.call(self, src, options, _caching, _reject);
                                    }
                                });
                            }
                        }
                    };

                    makeRequest(options);
                });
            }
        });
    };

    toolProto.fetchRetry = function (url, options, n) {
        const self = this;
        var _fetch = fetch;

        if (options.sync) {
            _fetch = self.fetchSync;
        }

        return _fetch(url, options).catch(function (error) {
            if (n === 1) throw error;
            return self.fetchRetry(url, options, n - 1);
        });
    };

    toolProto.fetchSync = function (url, options) {
        var self = this;

        return new Promise(function (resolve, reject) {

            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }

            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }

            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }


            var request = new Request(url, options);
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') };
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
            };
            xhr.onerror = function () { reject(new TypeError('Network request failed')) };
            xhr.ontimeout = function () { reject(new TypeError('Network request failed')) };
            xhr.open(request.method, request.url, false);
            if (request.credentials === 'include') { xhr.withCredentials = !options.sync } else if (request.credentials === 'omit') { xhr.withCredentials = !1 };
            if (!options.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' };
            request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) });
            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        })
    };

    toolProto.fetchXML = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "xml"; // No puedo usar la constante de la API porque está como application/xml y hay servicios que devuelven text/xml //TC.Consts.mimeType.XML;

        return self.fetch(url, options);
    };

    toolProto.fetchJSON = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = TC.Consts.mimeType.JSON;

        return self.fetch(url, options);
    };

    toolProto.fetchBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "blob";

        return self.fetch(url, options);
    };

    /* Para imágenes por POST */
    toolProto.fetchImageAsBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "image";

        return self.fetch(url, options);
    };

    /*
        type: GET|POST
        data: cuerpo del mensaje
        contentType: tipo del cuerpo del mensaje
        responseType: tipo de respuesta esperada
        retryAttempts: número de intentos por llamada
    */
    // indicar responseType en options
    toolProto.fetch = function (url, options) {
        const self = this;

        options = options || {};

        if (options.type) {
            options.method = options.type;

            delete options.type;
        }

        if (options.data) {
            options.body = options.data;

            delete options.data;
        }

        if (options.contentType) {
            options.headers = new Headers();
            options.headers.append('Content-Type', options.contentType);

            delete options.contentType;
        }

        if (!options.responseType) {
            options.responseType = '';
        }

        var _makeRequest = function (url, options, actions, cache) {
            var request;

            // fetch no incluye por defecto las cookies de autenticación, hay que indicarlo.
            //options.credentials = 'include';

            return (options.retryAttempts ? self.fetchRetry(actions[0].call(self, url), options, options.retryAttempts) : fetch(actions[0].call(self, url), options))
                .then(self._fetch.validateResponse)
                .then(self._fetch.validateContentType.bind(self, options.responseType))
                .then(function (response) {
                    if (cache) {
                        cache.action = actions[0].bind(self);
                    }

                    const contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);

                    //if (!options.responseType) {
                    //    if (contentType) {
                    //        options.responseType = contentType;
                    //    } else {
                    //        return response.text();
                    //    }
                    //}

                    const responseWithCharsetToDecodedString = function (charset) {
                        /*
                                2018 08 16
                                https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods
                                No existe método xml

                                https://developer.mozilla.org/en-US/docs/Web/API/Body/text
                                The text() method of the Body mixin takes a Response stream and reads it to completion.
                                It returns a promise that resolves with a USVString object (text).
                                The response is always decoded using UTF-8.
                            */

                        return response.blob().then(function (blob) {
                            const reader = new FileReader();

                            return new Promise(function (resolve, reject) {

                                reader.addEventListener("error", function () {
                                    reader.abort();
                                    reject(new DOMException("Problem decoding"));
                                });

                                reader.addEventListener("loadend", function () {
                                    resolve(reader.result);
                                });

                                reader.readAsText(blob, charset);
                            });
                        });
                    };

                    switch (true) {
                        case options.responseType.indexOf('xml') > -1:
                        case options.responseType.indexOf('text/xml') > -1:
                        case options.responseType.indexOf(TC.Consts.mimeType.XML) > -1:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    return (new window.DOMParser()).parseFromString(text, "text/xml");
                                });
                            } else {
                                return response.text().then(function (data) {
                                    return (new window.DOMParser()).parseFromString(data, "text/xml");
                                });
                            }
                        case options.responseType.indexOf('arraybuffer') > -1:
                            return response.arrayBuffer();
                        case options.responseType.indexOf('image') > -1:
                        case options.responseType.indexOf('blob') > -1:
                            return response.blob().then(function (blob) {
                                return new Blob([blob], { type: contentType });
                            });
                        case options.responseType.indexOf('document') > -1:
                            throw new DeveloperError('Unhandled responseType: ' + options.responseType);
                        case options.responseType.indexOf(TC.Consts.mimeType.JSON) > -1:
                            return response.json();
                        case options.responseType == '':
                        case options.responseType.indexOf('text') > -1:
                        default:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            } else {
                                return response.text().then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            }
                    }
                })
                .catch(function (error) {
                    if (actions.length === 1) {
                        console.log('request failed', error);
                        return Promise.reject(error);
                    }

                    actions.shift();
                    return _makeRequest(url, options, actions, cache);
                });
        };

        if (self.cacheHost.is(url, options)) {
            return new Promise(function (resolve, reject) {
                self.cacheHost.getAction(url, options).then(function (cache) {
                    resolve(_makeRequest(url, options, [cache.action]));
                }).catch(function (error) {
                    if (error.status > 400) {
                        reject(new Error(error.text));
                    } else {
                        resolve(self.fetch(url, options));
                    }
                });
            });            
        } else {
            var cache = self.cacheHost.addKey(url, options);
            return new Promise(function (resolve, reject) {
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    url = srcToURL(url).href;

                    const fnResolve = function (data) {
                        //self.cacheHost.hostCacheService.addHost(cache.key, cache.action);
                        resolveActionPromise({ action: cache.action });
                        resolve(data);
                    };

                    const fnReject = function (error) {
                        //self.cacheHost.hostCacheService.removeHost(cache.key);
                        self.cacheHost.removeKey(url, options);

                        rejectActionPromise(error);
                        reject(new Error(error.text));
                    };

                    if (self._isSameOrigin(url)) {
                        _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                    } else {
                        if (!self._isSecureURL(url)) {
                            if (self._isServiceWorker()) {
                                // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                _makeRequest(url, options, [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                _makeRequest(url, options, !self._isSecureURL(self._location) ? [self._actionDirect, self._actionHTTPS, self._actionProxy] : [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        } else {
                            if (self._isServiceWorker()) {
                                // HTTPS -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionHTTP, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        }
                    }
                });
                cache._actionPromise.catch(function (error) {
                    if (error.status > 400) {
                        reject(new Error(error.text));
                    } else {
                        resolve(self.fetch(url, options));
                    }
                });
            });
        }
    };
})();
var TC = TC || {};

TC.inherit = function (childCtor, parentCtor) {
    childCtor.prototype = Object.create(parentCtor.prototype);
    childCtor.prototype.constructor = childCtor;
    childCtor._super = parentCtor.prototype;
};

(function () {

    // Polyfill de CustomEvent
    /*! (c) Andrea Giammarchi - ISC */
    var self = this || /* istanbul ignore next */ {};
    self.CustomEvent = typeof CustomEvent === 'function' ?
        CustomEvent :
        (function (__p__) {
            CustomEvent[__p__] = new CustomEvent('').constructor[__p__];
            return CustomEvent;
            function CustomEvent(type, init) {
                if (!init) init = {};
                var e = document.createEvent('CustomEvent');
                e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);
                return e;
            }
        }('prototype'));

    if (!Element.prototype.matches) {
        Element.prototype.matches =
            Element.prototype.matchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.oMatchesSelector ||
            Element.prototype.webkitMatchesSelector;
    }

    const getNativeListener = function (evt, callback) {
        const result = function (evt) {
            const cbParameter = {
                type: evt.type,
                target: this,
                currentTarget: this
            };
            if (evt.detail) {
                Object.keys(evt.detail).forEach(function (key) {
                    if (!(key in cbParameter)) {
                        cbParameter[key] = evt.detail[key];
                    }
                });
            }
            return callback.call(this, cbParameter);
        }.bind(this);
        const stack = this._listeners[evt] = this._listeners[evt] || new Map();
        stack.set(callback, result);
        return result;
    };

    const onInternal = function (events, callback, options) {
        const self = this;
        events.split(' ').forEach(function (evt) {
            self.$events.addEventListener(evt, getNativeListener.call(self, evt, callback), options);
        });
        return self;
    };

    TC.EventTarget = function () {
        const self = this;
        self._listeners = {};
        self.$events = document.createDocumentFragment();

        const delegate = function (method) {
            this[method] = self.$events[method].bind(self.$events);
        };
        const methods = [
            'addEventListener',
            'dispatchEvent',
            'removeEventListener'
        ];
        methods.forEach(delegate, self);

        const fill$events = function (method) {
            self.$events[method] = self[method].bind(self);
        };
        methods.push('on');
        methods.push('one');
        methods.push('off');
        methods.push('trigger');
        methods.forEach(fill$events, self);
    };

    const etProto = TC.EventTarget.prototype;

    etProto.on = function (events, callback) {
        return onInternal.call(this, events, callback);
    };

    if (navigator.userAgent.indexOf("Trident") >= 0 || navigator.userAgent.indexOf("MSIE") >= 0) {
        // Parche para IE
        etProto.one = function (events, callback) {
            const self = this;
            const newCallback = function (e) {
                self.off(events, newCallback);
                callback.call(this, e);
            };
            self.on(events, newCallback);
            return self;
        };
    } else {
        etProto.one = function (events, callback) {
            return onInternal.call(this, events, callback, { once: true });
        };
    }

    etProto.off = function (events, callback) {
        const self = this;
        const eventList = events.split(' ');
        if (callback) {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack && stack.has(callback)) {
                    self.$events.removeEventListener(evt, stack.get(callback));
                }
            });
        }
        else {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack) {
                    stack.forEach(function (cb) {
                        self.$events.removeEventListener(evt, cb);
                    });
                    stack.clear();
                }
            });
        }
        return self;
    };

    etProto.trigger = function (type, options) {
        const self = this;
        //Compatibilidad hacia atrás
        if (window.$ && $.Event && type instanceof $.Event) {
            options = {};
            Object.keys(type).forEach(function (key) {
                if (key !== 'type') {
                    options[key] = type[key];
                }
            });
            type = type.type;
        }
        var ceOptions;
        if (options) {
            ceOptions = {
                detail: options
            };
        }
        const event = new CustomEvent(type, ceOptions);
        self.dispatchEvent(event);
    };

    TC.EventTarget._onBySelectorMap = new WeakMap();

    TC.EventTarget.listenerBySelector = function (selector, callback) {
        // Crea una estructura a partir de un mapa cuyas claves son los elementos.
        // Los valores son objetos cuyas claves son tipos de eventos
        // y cuyos valores son objetos que tienen como claves los selectores
        // y cuyos valores son las funciones de callback.
        // Se crea una función que va buscando la primera correspondencia con un selector.
        // En cuanto la encuentra, ejecuta el callback y deja de procesar.
        return function (e) {
            const element = this;
            const eventType = e.type;
            var eventTypes = TC.EventTarget._onBySelectorMap.get(element);
            if (!eventTypes) {
                eventTypes = {};
                TC.EventTarget._onBySelectorMap.set(element, eventTypes);
            }
            var selectors = eventTypes[eventType];
            if (!selectors) {
                eventTypes[eventType] = selectors = {};
            }
            if (!selectors[selector]) {
                selectors[selector] = callback;
            }
            // Para cada evento en cada elemento hay que llamar una sola vez al callback que toque.
            // Así que si se ejecuta un callback, prohibimos al resto de los listeners resolverse.
            if (!e._listenerBySelectorCalled) {
                var matches = false;
                var elm = e.target;
                var result;
                while (elm && elm !== element) {
                    for (selector in selectors) {
                        if (elm.matches && elm.matches(selector)) {
                            matches = true;
                            result = selectors[selector].call(element, e);
                            e._listenerBySelectorCalled = true;
                        }
                    }
                    if (matches) {
                        return result;
                    }
                    elm = elm.parentNode;
                }
            }
        };
    };

    /**
     * <p>Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que el constructor es asíncrono, por tanto cualquier código que haga uso de este objeto debería
     * estar dentro de una función de callback pasada como parámetro al método {{#crossLink "TC.Map/loaded:method"}}{{/crossLink}}.</p>
     * <p>Puede consultar también online el <a href="../../examples/Map.1.html">ejemplo 1</a>, el <a href="../../examples/Map.2.html">ejemplo 2</a> y el <a href="../../examples/Map.3.html">ejemplo 3</a>.</p>
     * @class TC.Map
     * @constructor
     * @async
     * @param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
     * @param {object} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global {{#crossLink "TC.Cfg"}}{{/crossLink}}.
     * @param {string} [options.crs="EPSG:25830"] Código EPSG del sistema de referencia espacial del mapa.
     * @param {array} [options.initialExtent] Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. 
     * Esta opción es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver TC.Cfg.{{#crossLink "TC.Cfg/crs:property"}}{{/crossLink}}).
     * Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/initialExtent:property"}}{{/crossLink}}.
     * @param {array} [options.maxExtent] Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima. Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/maxExtent:property"}}{{/crossLink}}.
     * @param {string} [options.layout] URL de una carpeta de maquetación. Consultar TC.Cfg.{{#crossLink "TC.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones.
     * @param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. 
     * @param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. 
     * @param {TC.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.
     * @param {TC.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geográficas.
     * @param {string} [options.locale="es-ES"] Código de idioma de la interfaz de usuario. Este código debe ser obedecer la sintaxis definida por la <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF</a>.
     * Los valores posibles son <code>es-ES</code>, <code>eu-ES</code> y <code>en-US</code>.
     * @param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver TC.Cfg.{{#crossLink "TC.Cfg/proxy:property"}}{{/crossLink}}).
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa con las opciones por defecto.
     *         var map = new TC.Map("mapa");
     *     </script>
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
     *         var map = new TC.Map("mapa", {
     *             crs: "EPSG:4326",
     *             initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             maxExtent: [
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             baseLayers: [
     * 				TC.Consts.layer.IDENA_DYNBASEMAP
     *             ]
     *         });
     *     </script>
     * @example
     *     <div id="mapa"></div>
     *     <script>
     *         // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
     *         var map = new TC.Map("mapa", {
     *             workLayers: [
     *                 {
     *                     id: "topo_mallas",
     *                     title: "Toponimia y mallas cartográficas",
     *                     type: TC.Consts.layerType.WMS,
     *                     url: "//idena.navarra.es/ogc/wms",
     *                     layerNames: "IDENA:toponimia,IDENA:mallas"
     *                 }
     *             ]
     *         });
     *     </script>
     */

    var currentState = null;
    var previousState = null;
    const _setupStateControl = function () {
        const self = this;

        var MIN_TIMEOUT_VALUE = 4;

        // eventos a los que estamos suscritos para obtener el estado            
        var events = [
            TC.Consts.event.LAYERADD,
            TC.Consts.event.LAYERORDER,
            TC.Consts.event.LAYERREMOVE,
            //TC.Consts.event.LAYEROPACITY, // Este evento lo vamos a tratar por separado, para evitar exceso de actualizaciones de estado.
            TC.Consts.event.LAYERVISIBILITY,
            TC.Consts.event.ZOOM,
            TC.Consts.event.BASELAYERCHANGE].join(' ');

        // gestión siguiente - anterior

        // registramos el estado inicial                
        self.replaceCurrent = true;
        _addToHistory.call(self);

        const fn_addToHistory = _addToHistory.bind(self);

        // nos suscribimos a los eventos para registrar el estado en cada uno de ellos
        self.on(events, fn_addToHistory);

        // a la gestión del evento de opacidad le metemos un retardo, para evitar que haya un exceso de actualizaciones de estado.
        var layerOpacityHandlerTimeout;
        self.on(TC.Consts.event.LAYEROPACITY, function (e) {
            clearTimeout(layerOpacityHandlerTimeout);
            layerOpacityHandlerTimeout = setTimeout(function () {
                _addToHistory.call(self, e);
            }, 500);
        });

        // gestión siguiente - anterior
        window.addEventListener('popstate', function (e) {
            var wait;
            wait = self.loadingCtrl && self.loadingCtrl.addWait();
            setTimeout(function () {
                if (e) {
                    // eliminamos la suscripción para no registrar el cambio de estado que vamos a provocar
                    self.off(events, fn_addToHistory);

                    var state = e.state;
                    if (Object.prototype.toString.call(state) === '[object Object]') {
                        state = self.checkLocation();
                    }

                    // gestionamos la actualización para volver a suscribirnos a los eventos del mapa                        
                    _loadIntoMap.call(self, state).then(function () {
                        setTimeout(function () {
                            self.on(events, fn_addToHistory);
                        }, 200);
                        self.loadingCtrl && self.loadingCtrl.removeWait(wait);
                    });
                }
            }, MIN_TIMEOUT_VALUE);
        });
    };
    const _addToHistory = function (e) {
        const self = this;

        var state = _getMapState.call(self);
        if (self.replaceCurrent) {
            window.history.replaceState(state, null, null);
            delete self.replaceCurrent;

            return;
        } else {

            /*if (self.registerState != undefined && !self.registerState) {
                self.registerState = true;
                return;
            }*/
            self.lastEventType = e.type;

            var saveState = function () {
                previousState = currentState;
                currentState = TC.Util.utf8ToBase64(state);
                if (currentState !== previousState) {
                    window.history.pushState(state, null, window.location.href.split('#').shift() + '#' + currentState);
                }
            };

            if (e) {
                switch (true) {
                    case (e.type == TC.Consts.event.BASELAYERCHANGE):
                    case (e.type == TC.Consts.event.LAYERORDER):
                    case (e.type == TC.Consts.event.ZOOM):
                        saveState();
                        break;
                    case (e.type.toLowerCase().indexOf("LAYER".toLowerCase()) > -1):
                        // unicamente modifico el hash si la capa es WMS
                        if (e.layer.type == TC.Consts.layerType.WMS)
                            saveState();
                        break;
                }
            }
        }
    };
    const _getMapState = function (extraStates) {
        const self = this;

        var state = {};

        if (self.crs !== self.options.crs) {
            state.crs = self.crs;
        }

        var ext = self.getExtent();
        for (var i = 0; i < ext.length; i++) {
            if (Math.abs(ext[i]) > 180)
                ext[i] = Math.floor(ext[i] * 1000) / 1000;
        }
        state.ext = ext;

        //determinar capa base
        var baseLayerData = [];

        // ¿es una capa de respaldo?
        if (self.baseLayers) {
            baseLayerData = self.baseLayers.filter(function (baseLayer) {
                return baseLayer.isRaster() && baseLayer.fallbackLayer;
            }).map(function (baseLayer) {
                return {
                    baseLayer: baseLayer, fallbackLayerID: baseLayer.fallbackLayer.id
                };
            }).filter(function (baseLayerData) {
                return baseLayerData.fallbackLayerID === (self.baseLayer ? self.baseLayer.id : self.baseLayers[0].id);
            });
        }

        if (baseLayerData.length > 0) {
            state.base = baseLayerData[0].baseLayer.id;
        } else {
            state.base = (self.baseLayer || self.baseLayers[0]).id;
        }

        //capas cargadas
        state.layers = [];

        var layer, entry;
        for (var i = 0; i < self.workLayers.length; i++) {
            layer = self.workLayers[i];
            if (layer.type == "WMS" && !layer.options.stateless) {
                if (layer.layerNames && layer.layerNames.length) {
                    entry = {
                        u: TC.Util.isOnCapabilities(layer.url),
                        n: Array.isArray(layer.names) ? layer.names.join(',') : layer.names,
                        o: layer.getOpacity(),
                        v: layer.getVisibility(),
                        h: layer.options.hideTitle,
                        ur: layer.unremovable,
                        t: layer.title,
                    };

                    state.layers.push(entry);
                }
            }
        }

        if (self.on3DView && self.view3D.cameraControls) {
            state.vw3 = self.view3D.cameraControls.getCameraState();
        }

        if (!window.jsonpack) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSONPACK);
        }

        if (extraStates) {
            TC.Util.extend(state, extraStates);
        }

        return jsonpack.pack(state);
    };
    const _clearMap = function () {
        const self = this;

        self.workLayers.filter(function (layer) {
            return !(layer instanceof (TC.layer.Vector));
        }).forEach(function (layer) {
            if (layer.unremovable) {
                layer.unremovable = false;
            }
            self.removeLayer(layer);
        });
    };
    const _loadIntoMap = function (stringOrJson) {
        const self = this;
        const promises = [];

        if (!self.loadingctrl) {
            self.loadingCtrl = self.getControlsByClass("TC.control.LoadingIndicator")[0];
        }

        if (!self.hasWait) {
            self.hasWait = self.loadingCtrl && self.loadingCtrl.addWait();
        }

        // GLS lo añado para poder gestionar el final de la actualización de estado y volver a suscribirme a los eventos del mapa
        return new Promise(function (resolve, reject) {
            var resolved = function () {
                self.loadingCtrl && self.loadingCtrl.removeWait(self.hasWait);
                delete self.hasWait;
                resolve();
            };

            var obj;
            if (typeof (stringOrJson) == "string") {
                try {
                    obj = jsonpack.unpack(stringOrJson);
                }
                catch (error) {
                    try {
                        obj = JSON.parse(stringOrJson);
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'));
                    }
                }
            } else {
                obj = stringOrJson;
            }

            if (obj) {
                // CRS
                if ((obj.crs && obj.crs !== self.crs) || (typeof obj.crs === 'undefined' && self.crs !== self.options.crs)) {
                    promises.push(self.setProjection({
                        crs: obj.crs || self.options.crs,
                        oldCrs: self.crs,
                        extent: obj.ext,
                        baseLayer: self.getLayer(obj.base)
                    }));
                }
                else {
                    //capa base
                    if (obj.base != self.getBaseLayer().id) {
                        if (self.getLayer(obj.base)) {
                            self.setBaseLayer(obj.base);
                        }
                        const firstOption = self.baseLayers.filter(function (baseLayer) {
                            return baseLayer.options.fallbackLayer === obj.base;
                        })[0];
                        if (firstOption) {
                            const fbPromise = self.addLayer(firstOption.getFallbackLayer());
                            promises.push(fbPromise);
                            fbPromise.then(function (newLayer) {
                                self.setBaseLayer(newLayer);
                            });
                        }
                    }

                    //extent
                    if (obj.ext) {
                        promises.push(self.setExtent(obj.ext, { animate: false }));
                    }
                }

                //capas cargadas        
                //borrar primero
                _clearMap.call(self);

                obj.layers = obj.layers || obj.capas || [];

                if (obj.layers.length > 0) {

                    for (var i = 0; i < obj.layers.length; i++) {
                        var capa = obj.layers[i];

                        var layerInConfig = false;

                        for (j = 0; j < self.options.workLayers.length; j++) {
                            var lyrCfg = TC.Util.extend({}, self.options.workLayers[j], { map: self });

                            if (capa.u === lyrCfg.url && lyrCfg.layerNames.indexOf(capa.n) >= 0) {
                                layerInConfig = true;
                                lyrCfg.renderOptions = { "opacity": capa.o, "hide": !capa.v };
                                lyrCfg.unremovable = capa.ur;
                                lyrCfg.title = capa.t;
                                promises.push(self.addLayer(lyrCfg).then(function (layer) {
                                    layer.setVisibility(this.v);
                                    layer.setOpacity(this.o, true);
                                }.bind(capa)));
                            }
                        }

                        if (!layerInConfig) {
                            promises.push(self.addLayer({
                                id: TC.getUID(),
                                url: TC.Util.isOnCapabilities(capa.u, capa.u.indexOf(window.location.protocol) < 0) || capa.u,
                                hideTitle: capa.h,
                                layerNames: capa.n ? capa.n.split(',') : "",
                                unremovable: capa.ur,
                                title: capa.t,
                                renderOptions: {
                                    opacity: capa.o,
                                    hide: !capa.v
                                }
                            }).then(function (layer) {
                                var rootNode = layer.wrap.getRootLayerNode();
                                layer.title = rootNode.Title || rootNode.title;
                                /*URI:el setOpacity recibe un nuevo parametro. Que indica si se no se va a lanzar evento LAYEROPACITY
                                esto es porque en el loadstate al establecer la opacidad dedido a un timeout pasados X segundos se lanzaba 
                                este evento y producía un push en el state innecesario*/
                                layer.setOpacity(this.o, true);
                                layer.setVisibility(this.v);
                            }.bind(capa)));
                        }
                    }
                }

                Promise.all(promises)
                    .then(function () {
                        resolved();
                    })
                    .catch(function () {
                        resolved();
                    });
            }
        });
    };

    const getReduceByBooleanFunction = function (prop) {
        return function (prev, cur, idx) {
            return cur[prop] ? idx : prev;
        };
    };
    const getReduceByIdFunction = function (id) {
        return function (prev, cur, idx, arr) {
            return cur.id === id ? idx : prev;
        };
    };

    const getAvailableBaseLayer = function (id) {
        const ablCollection = this instanceof TC.Map ? this.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
        return ablCollection.filter(function (abl) {
            return abl.id === id;
        })[0];
    };

    TC.Map = TC.Map || function (div, options) {
        ///<summary>
        ///Constructor
        ///</summary>
        ///<param name="div" type="HTMLElement|string">Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.</param>
        ///<param name="options" type="object" optional="true">Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global TC.Cfg.</param>
        ///<returns type="TC.Map"></returns>
        ///<field name='isReady' type='boolean'>Indica si todos los controles del mapa están cargados.</field>
        ///<field name='isLoaded' type='boolean' default='false'>Indica si todos los controles y todas las capas del mapa están cargados.</field>
        ///<field name='activeControl' type='TC.Control'>Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.</field>
        ///<field name='layers' type='array' elementType='TC.Layer'>Lista de todas las capas base cargadas en el mapa.</field>
        ///<field name='controls' type='array' elementType='TC.Control'>Lista de todos los controles del mapa.</field>
        const self = this;
        TC.EventTarget.call(self);
        TC.Map._instances.push(self);

        //TC.Object.apply(self, arguments);

        /**
         * Indica si todos los controles del mapa están cargados.
         * @property isReady
         * @type boolean
         * @default false
         */
        self.isReady = false;

        /**
         * Indica si todos los controles y todas las capas del mapa están cargados.
         * @property isLoaded
         * @type boolean
         * @default false
         */
        self.isLoaded = false;

        /**
         * Lista de todos los controles del mapa.
         * @property controls
         * @type array
         * @default []
         */
        self.controls = [];

        /**
         * Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.
         * @property activeControl
         * @type TC.Control
         * @default null
         */
        self.activeControl = null;

        /**
         * Lista de todas las capas cargadas en el mapa.
         * @property layers
         * @type array
         * @default []
         */
        self.layers = [];

        /**
         * Lista de todas las capas base cargadas en el mapa.
         * @property baseLayers
         * @type array
         * @default []
         */
        self.baseLayers = [];

        /**
         * Lista de todas las capas de trabajo cargadas en el mapa.
         * @property workLayers
         * @type array
         * @default []
         */
        self.workLayers = [];

        /**
         * Capa base actual del mapa.
         * @property baseLayer
         * @type TC.Layer
         */
        self.baseLayer = null;

        /**
         * Capa donde se dibujan las entidades geográficas si no se especifica la capa explícitamente. Se instancia en el momento de añadir la primera entidad.
         * @property vectors
         * @type TC.layer.Vector
         * @default null
         */
        self.vectors = null;

        var loadingLayerCount = 0;
        /**
         * Elemento del DOM donde se ha creado el mapa.
         * @property div
         * @type HTMLElement
         */
        self.div = TC.Util.getDiv(div);
        if (TC._jQueryIsLoaded) {
            self._$div = $(self.div);
        }
        /**
         * El mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event MAPLOAD
         */
        /**
         * El mapa ha cargado todos sus controles, pero no hay garantía de que estén cargadas las capas
         * @event MAPREADY
         */
        /**
         * Se va a añadir una capa al mapa.
         * @event BEFORELAYERADD
         * @param {TC.Layer} layer Capa que se va a añadir.
         */
        /**
         * Se ha añadido una capa al mapa.
         * @event LAYERADD
         * @param {TC.Layer} layer Capa que se ha añadido.
         */
        /**
         * Se ha eliminado una capa del mapa.
         * @event LAYERREMOVE
         * @param {TC.Layer} layer Capa que se ha eliminado.
         */
        /**
         * Se ha cambiado de posición una capa en la lista de capas del mapa.
         * @event LAYERORDER
         * @param {TC.Layer} layer Capa que se ha eliminado.
         * @param {number} oldIndex Índice de la posición antes del cambio.
         * @param {number} newIndex Índice de la posición después del cambio.
         */
        /**
         * Se va a actualizar una capa del mapa: se van a modificar sus entidades o se va solicitar una nueva imagen.
         * @event BEFORELAYERUPDATE
         * @param {TC.Layer} layer Capa que va a actualizarse.
         */
        /**
         * Se ha actualizado una capa del mapa: se ha modificado sus entidades o se ha cargado una imagen nueva.
         * @event LAYERUPDATE
         * @param {TC.Layer} layer Capa que se ha actualizado.
         */
        /**
         * Ha habido un error al cargar la capa, bien porque no se ha podido obtener su capabilities o porque no soporta CRS compatibles.
         * @event LAYERERROR
         * @param {TC.Layer} layer Capa que sufre el error.
         */
        /**
         * Se ha establecido una nueva capa como mapa base.
         * @event BASELAYERCHANGE
         * @param {TC.Layer} layer Capa que es el nuevo mapa base.
         */
        /**
         * Se va a actualizar alguna capa del mapa.
         * @event BEFOREUPDATE
         */

        self.div.classList.add(TC.Consts.classes.LOADING, TC.Consts.classes.MAP);

        // Para gestionar zoomToMarkers
        self._markerPromises = [];

        self._layerBuffer = {
            layers: [],
            contains: function (id) {
                return this.layers.some(function (l) {
                    return l.id === id;
                });
            },
            getIndex: function (id) {
                return this.layers.reduce(getReduceByIdFunction(id), -1);
            },
            add: function (id, isRaster, isBase) {
                var idx;
                const obj = {
                    id: id,
                    pending: true,
                    isRaster: isRaster,
                    isBase: isBase
                };
                if (isRaster) {
                    idx = this.getRasterIndex();
                    this.layers.splice(idx, 0, obj);
                }
                else {
                    idx = this.layers.length;
                    this.layers[idx] = obj;
                }
            },
            remove: function (id) {
                this.layers.splice(this.getIndex(id), 1);
            },
            getMapLayers: function () {
                return this.layers
                    .filter(l => l.pending === false)
                    .filter(l => !l.rejected)
                    .map(l => l.mapLayer);
            },
            resolve: function (map, layer, isBase) {
                const layerObj = this.layers[this.getIndex(layer.id)];
                layerObj.mapLayer = layer;
                layerObj.pending = false;
                map.layers = this.getMapLayers();
                if (isBase) {
                    if (map.baseLayers.length === 0) {
                        map.baseLayers = new Array(map.options.baseLayers.length);
                    }

                    var index = map.options.baseLayers.map(function (l) { return l.id }).indexOf(layer.id);
                    if (index < 0) {
                        var index = map.baseLayers.map(function (l) { return l.type }).indexOf(TC.Consts.layerType.VECTOR);
                        if (index < 0) {
                            map.baseLayers.push(layer);
                        } else {
                            map.baseLayers.splice(index, 0, layer);
                        }
                    } else {
                        map.baseLayers.splice(index, 1, layer);
                    }
                }
                else {
                    map.workLayers = map.layers.filter(function (l) {
                        return !l.isBase;
                    });
                }
            },
            reject: function (map, error) {
                const layerObj = this.layers[this.getIndex(error.layerId)];
                layerObj.mapLayer = null;
                layerObj.pending = false;
                layerObj.rejected = true;
                var index = map.options.baseLayers.map(l => l.id).indexOf(error.layerId);
                if (index >= 0) {
                    map.baseLayers.splice(index, 1);
                }
            },
            getResolvedWorkLayerIndex: function (map, id) {
                return this.layers.filter(function (l) {
                    return l.id === id || (!l.isBase && l.pending === false);
                }).reduce(getReduceByIdFunction(id), -1);
            },
            getResolvedVisibleLayerIndex: function (map, id) {
                var index = this.getResolvedWorkLayerIndex(map, id);
                if (map.baseLayer) {
                    index = index + 1;
                }
                return index;
            },
            getRasterIndex: function () {
                return this.layers.reduce(getReduceByBooleanFunction('isRaster'), -1) + 1;
            },
            checkMapLoad: function (map) {
                const self = this;
                if (map.options.baseLayers
                    .concat(map.options.workLayers)
                    .every(function (l) {
                        return self.contains(l.id || l);
                    }) && // Si ya se han empezado a procesar todas las capas de las opciones
                    !this.layers.some(function (layer) {
                        return layer.pending === true; // Si ya se han terminado de procesar
                    })) {
                    const throwMapLoad = function () {
                        if (!map.isLoaded) {
                            const setLoaded = function () {

                                // 07/03/2019 GLS: Bug 24832 la gestión del estado comienza después de TC.Consts.event.MAPLOAD, 
                                // como los callbacks a loaded se lanzan según el orden de suscripción, el de script.js de IDENA se lanza antes 
                                // que el de la gestión del estado, lo que provoca que las capas añadidas por queryString no se registren.
                                if (map.options.stateful) {
                                    _setupStateControl.call(map);
                                }

                                map.isLoaded = true;
                                map.div.classList.remove(TC.Consts.classes.LOADING);
                                map.trigger(TC.Consts.event.MAPLOAD);
                            };
                            // tenemos estado 3d
                            if (map.state && map.state.vw3) {
                                if (!map.div.classList.contains(TC.Consts.classes.THREED)) {
                                    map.div.classList.add(TC.Consts.classes.THREED);

                                    TC.loadJS(
                                        !TC.view || !TC.view.ThreeD,
                                        TC.apiLocation + 'TC/view/ThreeD',
                                        function () {
                                            TC.view.ThreeD.apply({
                                                map: map, state: map.state.vw3, callback: function () {
                                                    setLoaded();

                                                    map.getControlsByClass(TC.control.ThreeD)[0].button.removeAttribute("disabled");
                                                }
                                            });
                                        }
                                    );
                                }
                            } else {
                                setLoaded();
                            }
                        }
                    };
                    // Gestionamos el final de la carga del mapa
                    if (map.baseLayer) {
                        throwMapLoad();
                    }
                    else {
                        //GLS: Si no hay mapa de fondo cargado es posible que se haya añadido desde diálogo modal, lo comprobamos en todos los mapas de fondo disponibles del API
                        var onAvailables = [];
                        if (map.state && map.state.base) {
                            onAvailables = TC.Cfg.availableBaseLayers.filter(function (l) { return l.id === map.state.base });
                        }

                        if (onAvailables.length > 0) {
                            onAvailables[0].isBase = true;
                            map.addLayer(onAvailables[0]).then(function (layer) {
                                throwMapLoad();
                            });
                        }
                        else {
                            // Si no hay capa base cargada cargamos la primera compatible
                            const lastResortBaseLayer = map.baseLayers.filter(function (layer) {
                                return !layer.mustReproject;
                            }).filter(function (l) {
                                return l.wrap && l.wrap.layer;
                            });

                            if (lastResortBaseLayer.length > 0) {
                                map.wrap.setBaseLayer(lastResortBaseLayer[0].wrap.layer);
                                map.baseLayer = lastResortBaseLayer[0];
                            }

                            throwMapLoad();
                        }
                    }
                }
            }
        };

        self._layerBuffer.layers = [];

        if (!TC.ready) {
            TC.Cfg = TC.Util.extend({}, TC.Defaults, TC.Cfg);
            TC.ready = true;
        }

        // GLS: mergeOptions es inclusivo, para poder sobrescribir los tipos de búsqueda, añado con valor a false las que el usuario no haya configurado.
        if (options && options.controls && options.controls.search && options.controls.search.allowedSearchTypes) {
            for (var allowed in TC.Cfg.controls.search.allowedSearchTypes) {
                if (!options.controls.search.allowedSearchTypes.hasOwnProperty(allowed)) {
                    options.controls.search.allowedSearchTypes[allowed] = false;
                }
            }
        }

        // Añado las capas disponibles a la configuración general

        /**
         * Objeto de opciones del constructor.
         * @property options
         * @type object
         */
        options = options || {};
        mergeOptions.call(self, options);

        var init = function () {

            TC.loadJS(
                self.options.stateful && !window.jsonpack,
                [TC.apiLocation + TC.Consts.url.JSONPACK],
                function () {
                    if (self.options.stateful) {
                        self.state = self.checkLocation();
                    }

                    if (self.options.layout) {
                        self.trigger(TC.Consts.event.LAYOUTLOAD, { map: self });
                    }

                    if (options && options.workLayers !== undefined) {
                        self.options.workLayers = options.workLayers;
                    }
                    if (options && options.baseLayers !== undefined) {
                        self.options.baseLayers = options.baseLayers;
                    }

                    if (self.options.zoomToFeatures) {
                        // zoom a features solo cuando se cargue el mapa
                        var handleFeaturesAdd = function handleFeaturesAdd(e) {
                            clearTimeout(self._zoomToFeaturesTimeout);

                            self._zoomToFeaturesTimeout = setTimeout(function () {
                                self.zoomToFeatures(e.layer.features, { animate: false });
                                self.off(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                            }, 100);
                        };
                        self.on(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                    }
                    var _handleLayerAdd = function _handleLayerAdd(e) {
                        if (e.layer.isBase && (e.layer === self.baseLayer || (self.baseLayer && e.layer.fallbackLayer && e.layer.fallbackLayer.id === self.baseLayer.id))) {
                            if (typeof self.state !== "undefined") {
                                if (self.state.crs) {
                                    self.loaded(function () {
                                        self.setProjection({
                                            crs: self.state.crs,
                                            extent: self.state.ext
                                        });
                                    });
                                }
                                else {
                                    self.setExtent(self.state.ext, { animate: false });
                                }
                            }
                            self.off(TC.Consts.event.LAYERADD, _handleLayerAdd);
                        }
                    };
                    self.on(TC.Consts.event.LAYERADD, _handleLayerAdd);


                    /**
                     * Well-known ID (WKID) del CRS del mapa.
                     * @property crs
                     * @type string
                     */
                    self.crs = self.options.crs;
                    self.initialExtent = self.options.initialExtent;
                    self.maxExtent = self.options.maxExtent;

                    self.wrap = new TC.wrap.Map(self);

                    TC.loadJS(
                        !window[TC.Consts.PROJ4JSOBJ],
                        [
                            TC.url.proj4js
                        ],
                        function () {
                            TC.loadJSInOrder(
                                !window[TC.Consts.OLNS],
                                [
                                    TC.url.ol,
                                    TC.url.olConnector
                                ],
                                function () {
                                    TC.loadProjDef({
                                        crs: self.options.crs,
                                        callback: function () {
                                            self.wrap.setMap();
                                            const ctlPromises = [];
                                            for (var name in self.options.controls) {
                                                var ctlOptions = self.options.controls[name];
                                                if (ctlOptions) {
                                                    ctlOptions = typeof ctlOptions === 'boolean' ? {} : TC.Util.extend(true, {}, ctlOptions);
                                                    if (typeof ctlOptions.div === 'string') {
                                                        ctlOptions.div = self.div.querySelector('#' + ctlOptions.div) || ctlOptions.div;
                                                    }
                                                    ctlPromises.push(self.addControl(name, ctlOptions));
                                                }
                                            }

                                            self.on(TC.Consts.event.BEFORELAYERUPDATE, _triggerLayersBeforeUpdateEvent);
                                            self.on(TC.Consts.event.LAYERUPDATE, _triggerLayersUpdateEvent);

                                            var i;
                                            var j;
                                            var lyrCfg;
                                            for (i = 0; i < self.options.baseLayers.length; i++) {
                                                lyrCfg = self.options.baseLayers[i];
                                                if (typeof lyrCfg === 'string') {
                                                    lyrCfg = getAvailableBaseLayer.call(self, lyrCfg);
                                                }
                                                self.addLayer(TC.Util.extend({}, lyrCfg, { isBase: true, map: self }));
                                            }

                                            var setVisibility = function (layer) {
                                                if (layer.isRaster() && !layer.names) {
                                                    layer.setVisibility(false);
                                                }
                                            };
                                            const workLayersNotInState = self.options.workLayers
                                                .map(function (workLayer) {
                                                    return TC.Util.extend({}, workLayer, { map: self });
                                                })
                                                .filter(function (workLayer) {
                                                    if (!self.state || !self.state.layers) {
                                                        return true;
                                                    }
                                                    return !self.state.layers.some(function (stateLayer) {
                                                        const result = stateLayer.u === workLayer.url && workLayer.layerNames.indexOf(stateLayer.n) >= 0;
                                                        if (result) {
                                                            stateLayer.id = workLayer.id; // Hemos identificado la capa, le damos el id que le corresponde
                                                        }
                                                        return result;
                                                    });
                                                });
                                            workLayersNotInState.forEach(function (workLayer) {
                                                self.addLayer(workLayer).then(setVisibility);
                                            });

                                            if (self.state && self.state.layers) {

                                                self.state.layers.forEach(function (stateLayer) {

                                                    // añado como promesa cada una de las capas que se añaden
                                                    self.addLayer({
                                                        id: stateLayer.id || TC.getUID(),
                                                        url: TC.Util.isOnCapabilities(stateLayer.u, stateLayer.u.indexOf(window.location.protocol) < 0) || stateLayer.u,
                                                        hideTitle: stateLayer.h,
                                                        layerNames: stateLayer.n ? stateLayer.n.split(',') : "",
                                                        unremovable: stateLayer.ur,
                                                        title: stateLayer.t,
                                                        renderOptions: {
                                                            opacity: stateLayer.o,
                                                            hide: !stateLayer.v
                                                        }
                                                    }).then(function (layer) {
                                                        layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                                                            var layer = this.parent;
                                                            if (event.error.code === 401 || event.error.code === 403)
                                                                layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                                                            layer.map.removeLayer(layer);
                                                        });
                                                        var rootNode = layer.wrap.getRootLayerNode();
                                                        layer.title = stateLayer.t || rootNode.Title || rootNode.title;
                                                        if (this.o < 1) {
                                                            layer.setOpacity(this.o);
                                                        }
                                                        if (!this.v) {
                                                            layer.setVisibility(this.v);
                                                        }
                                                    }.bind(stateLayer));
                                                });
                                            }
                                            Promise.all(ctlPromises).finally(function () {
                                                self.isReady = true;
                                                self.trigger(TC.Consts.event.MAPREADY);
                                            })
                                            setHeightFix(self.div);
                                        }
                                    });
                                }
                            );
                        }
                    );

                    self.on(TC.Consts.event.FEATURECLICK, function (e) {
                        if (!self.activeControl || !self.activeControl.isExclusive()) {
                            if (self.on3DView) {
                                e.feature.showResultsPanel();
                            } else {
                                e.feature.showPopup();
                            }
                        }
                    });

                    self.on(TC.Consts.event.NOFEATURECLICK, function (e) {
                        e.layer._noFeatureClicked = true;
                        var allLayersClicked = true;
                        for (var i = 0, len = self.workLayers.length; i < len; i++) {
                            if (!self.workLayers[i]._noFeatureClicked) {
                                allLayersClicked = false;
                                break;
                            }
                        }
                        if (allLayersClicked) {
                            self.workLayers.forEach(function (wl) {
                                delete wl._noFeatureClicked;
                            });
                            self.getControlsByClass(TC.control.Popup).forEach(function (p) {
                                p.hide();
                            });
                        }
                    });
                }
            );
        };

        mapProto.getMapState = function (extraStates) {
            const self = this;

            var state = _getMapState.call(self, extraStates);
            return TC.Util.utf8ToBase64(state);
        };

        mapProto.getPreviousMapState = function () {
            return previousState;
        };

        mapProto.checkLocation = function () {
            var hash = window.location.hash;

            if (hash && hash.length > 1) {
                hash = hash.substr(1);

                var obj;
                try {
                    obj = jsonpack.unpack(TC.Util.base64ToUtf8(hash));
                }
                catch (error) {
                    try {
                        obj = JSON.parse(TC.Util.base64ToUtf8(hash));
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                        return;
                    }
                }

                if (TC.Util.detectIE() && window.location.href.length === 2047) {
                    TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValidForEdge'), TC.Consts.msgErrorMode.TOAST);
                }

                if (obj) {
                    var inValidState = false;
                    //chequeo la integriadad del objeto restaurado del State
                    if (!obj.hasOwnProperty("ext")) {
                        inValidState = true;
                        obj.ext = self.options.initialExtent;
                    }
                    if (!obj.hasOwnProperty("base")) {
                        inValidState = true;
                        obj.base = self.options.defaultBaseLayer;
                    }
                    if (!obj.hasOwnProperty("layers")) {
                        inValidState = true;
                        obj.layers = [];
                    }
                    else {
                        for (var i = obj.layers.length - 1; i >= 0; i--) {
                            if (!obj.layers[i] || !obj.layers[i].hasOwnProperty("u") || !obj.layers[i].hasOwnProperty("n")) {
                                inValidState = true;
                                obj.layers.length = obj.layers.length - 1;
                                continue;
                            }
                            else if (!obj.layers[i].hasOwnProperty("o") || !obj.layers[i].hasOwnProperty("v") || !obj.layers[i].hasOwnProperty("h")) {
                                inValidState = true
                                TC.Util.extend(obj.layers[i], {
                                    o: (obj.layers[i].o || 1),
                                    v: (obj.layers[i].v || true),
                                    h: (obj.layers[i].h || false)
                                });
                            }
                        }
                    }

                    if (obj.hasOwnProperty("vw3")) {

                        if (!obj.vw3) {
                            inValidState = true;
                        } else if (!obj.vw3.cp || (obj.vw3.cp && obj.vw3.cp.length != 3) ||
                            !obj.vw3.chpr || (obj.vw3.chpr && obj.vw3.chpr.length != 3) ||
                            !obj.vw3.bcpd) {
                            inValidState = true;
                        }
                    }

                    if (inValidState)
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                    return obj;
                }
                TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            return;
        };

        var _checkIntegrity = function () {
        };

        /*
        *  _triggerLayersBeforeUpdateEvent: Triggers map beforeupdate event (jQuery.Event) when any layer starts loading
        *  Parameters: OpenLayers.Layer, event name ('loadstart', 'loadend')
        */
        var _triggerLayersBeforeUpdateEvent = function (e) {
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.BEFOREUPDATE);
            }
            loadingLayerCount = loadingLayerCount + 1;
        };

        var _triggerLayersUpdateEvent = function (e) {
            loadingLayerCount = loadingLayerCount - 1;
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.UPDATE);
            }
        };

        TC.i18n = TC.i18n || {};
        // i18n: carga de recursos si no está cargados previamente
        TC.i18n.loadResources = TC.i18n.loadResources || function (condition, path, locale) {
            var result;
            if (condition) {
                result = new Promise(function (resolve, reject) {
                    TC.ajax({
                        url: path + locale + '.json',
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    })
                        .then(function (response) {
                            const data = response.data;
                            TC.i18n[locale] = TC.i18n[locale] || {};
                            TC.Util.extend(TC.i18n[locale], data);
                            if (typeof (dust) !== 'undefined') {
                                TC.loadJS(
                                    !window.dust.i18n,
                                    TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                                    function () {
                                        dust.i18n.add(locale, TC.i18n[locale]);
                                        resolve();
                                    });
                            }
                        })
                        .catch(function (err) {
                            reject(err);
                        });
                });
            } else {
                dust.i18n.add(locale, TC.i18n[locale]);
                result = Promise.resolve();
            }
            return result;
        };

        var i18nPromises = [];
        var locale = self.options.locale;
        i18nPromises.push(new Promise(function (resolve, reject) {
            TC.loadJSInOrder(
                !window.dust || !window.dust.i18n,
                TC.url.templating,
                function () {
                    if (locale) {
                        dust.i18n.setLanguages([locale]);

                        i18nPromises.push(TC.i18n.loadResources(!TC.i18n[locale], TC.apiLocation + 'TC/resources/', locale));
                    }
                    resolve();
                }
            );
        }));

        Promise.all(i18nPromises).finally(function () {
            // 22/03/2019 GLS: siempre vamos a tener layout porque en sitna.js (1757) se establece por defecto layout/responsive
            //                 si el usuario define otro se sobrescribe
            if (self.options.layout) {
                var layout = self.options.layout;

                self.trigger(TC.Consts.event.BEFORELAYOUTLOAD, { map: self });

                var layoutURLs = {};
                var ignoreError = false;
                if (typeof layout === 'string') {
                    var href = layout.trim();
                    href += href.match(/\/$/) ? '' : '/';

                    layoutURLs.config = href + 'config.json';
                    layoutURLs.markup = href + 'markup.html';
                    layoutURLs.style = href + 'style.css';
                    layoutURLs.script = href + 'script.js';
                    layoutURLs.i18n = href + 'resources';

                    // Si el layout se define como string, no podemos saber qué archivos a definido y cuales no, 
                    // por eso tampoco podemos saber si es un error de configuración o es que no lo ha definido así que no mostramos error entendiendo que si
                    // el archivo no está es porque no quiere.
                    ignoreError = true;
                }
                else if (
                    layout.hasOwnProperty('config') ||
                    layout.hasOwnProperty('markup') ||
                    layout.hasOwnProperty('style') ||
                    layout.hasOwnProperty('script') ||
                    layout.hasOwnProperty('href') ||
                    layout.hasOwnProperty('i18n')
                ) {
                    layoutURLs = TC.Util.extend({}, layout);
                }

                if (layoutURLs.i18n) {
                    layoutURLs.i18n += layoutURLs.i18n.match(/\/$/) ? '' : '/';
                }

                self.layout = layoutURLs;

                const layoutPromises = [];
                const ResponseError = function (status, url) {
                    this.status = status;
                    this.url = url;
                };
                const onError = function (error) {
                    if (!ignoreError || error.status.toString() !== "404") {
                        const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));
                        TC.error(
                            TC.Util.getLocaleString(mapObj.options.locale, "urlFailedToLoad",
                                { url: error.url }),
                            [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],
                            "Error al cargar " + error.url);
                    }
                };

                const i18LayoutPromise = new Promise(function (resolve, reject) {
                    if (layoutURLs.config) {

                        layoutPromises.push(fetch(layoutURLs.config)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.config);
                                }
                                return response.json();
                            }).then(function (data) {
                                resolve(data.i18n);
                                mergeOptions.call(self, data, options);
                            }).catch(function (error) {
                                onError(error);

                                resolve(false);
                            }));
                    }
                    else {
                        resolve(false);
                    }
                });
                layoutPromises.push(i18LayoutPromise);

                if (layoutURLs.style) {
                    // Añadimos una clase para hacer más fáciles las reglas del layout
                    self.div.classList.add('tc-lo');

                    // GLS: 28/03/2019 Necesito hacer el HEAD para validar si existe porque si lo hago directamente y lo cargo como BLOB, 
                    // las referencias a las fuentes son relativas al blob por lo que no funcionan, así que HEAD y si existe lo cargo por href
                    fetch(layoutURLs.style, {
                        method: navigator.onLine ? 'HEAD': 'GET' // FLP: Las peticiones HEAD no se guardan en la cache, así que offline fallan, por eso la opción GET.
                    }).then(function (response) {
                        if (!response.ok) { // status no está en el rango 200-299
                            throw new ResponseError(response.status, layoutURLs.style);
                        }
                        return response;
                    }).then(function () {
                        var linkElement = document.createElement('link');
                        linkElement.rel = 'stylesheet';
                        linkElement.href = layoutURLs.style;

                        document.head.appendChild(linkElement);
                    }).catch(function (error) {
                        onError(error);
                    });
                }

                if (layoutURLs.markup) {
                    layoutPromises.push(new Promise(function (resolve, reject) {

                        fetch(layoutURLs.markup)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.markup);
                                }
                                return response.text();
                            }).then(function (data) {
                                // markup.html puede ser una plantilla dust para soportar i18n, compilarla si es el caso
                                i18LayoutPromise.then(function (i18n) {
                                    if (i18n && locale && layoutURLs.i18n) {
                                        TC.i18n.loadResources(true, layoutURLs.i18n, locale).finally(function () {
                                            var replacerFunction = function (str, match1, match2) {
                                                return TC.Util.getLocaleString(locale, match1 || match2);
                                            };
                                            //data = data.replace(/\{\{([^\}\{]+)\}\}/g, replacerFunction); // Estilo {{key}}
                                            //data = data.replace(/\{@i18n \$key="([^\}\{]+)"\/\}/g, replacerFunction); // Estilo {@i18n $key="key"/}
                                            data = data.replace(/(?:\{\{([^\}\{]+)\}\}|\{@i18n \$key="([^\}\{]+)"\/\})/g, replacerFunction); // Ambos estilos anteriores
                                            self.div.insertAdjacentHTML('beforeend', data);
                                            resolve();
                                        });
                                    }
                                    else {
                                        self.div.insertAdjacentHTML('beforeend', data);
                                        resolve();
                                    }
                                });
                            }).catch(function (error) {
                                onError(error);

                                reject(Error(error));
                            });
                    }));
                }

                Promise.all(layoutPromises).finally(function () {

                    if (layoutURLs.script) {
                        fetch(layoutURLs.script)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.script);
                                }
                                return response.blob();
                            }).then(function (fileBlob) {
                                var fileURL = URL.createObjectURL(fileBlob);

                                var scriptElement = document.createElement('script');
                                scriptElement.src = fileURL;

                                scriptElement.onload = function () {
                                    setHeightFix(self.div);
                                    init();
                                };

                                document.head.appendChild(scriptElement);

                            }).catch(function (error) {
                                onError(error);
                                init();
                            });
                    } else {
                        init();
                    }
                });

            }
            else {
                init();
            }
        });

        // Borramos árboles de capas cacheados
        self.on(TC.Consts.event.UPDATEPARAMS, function (e) {
            deleteTreeCache(e.layer);
        });
        self.on(TC.Consts.event.ZOOM, function () {
            for (var i = 0; i < self.workLayers.length; i++) {
                deleteTreeCache(self.workLayers[i]);
            }
        });

        // Redefinimos TC.error para añadir un aviso en el mapa
        /*var oldError = TC.error;
        TC.error = function (text) {
            oldError(text);
            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
        };*/
        var oldError = TC.error;
        TC.error = function (text, options, subject) {
            if (TC.isDebug && console.trace) {
                console.trace();
            }
            if (!options) {
                oldError(text);
                self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
            }
            else {
                var fnc = function (text, mode, subject) {
                    switch (mode) {
                        case TC.Consts.msgErrorMode.TOAST:
                            if (!self.toast) { console.warn("No existe el objeto Toast"); return; }
                            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
                            break;
                        case TC.Consts.msgErrorMode.EMAIL:
                            if (TC.Cfg.loggingErrorsEnabled) {
                                JL("onerrorLogger").fatalException(!subject ? text : {
                                    "msg": subject,
                                    "errorMsg": text,
                                }, null);
                            }
                            break;
                        case TC.Consts.msgErrorMode.CONSOLE:
                        default:
                            console.error(text)
                            break;
                    }
                }
                if (!Array.isArray(options)) {
                    fnc(text, options, subject)
                }
                else {
                    for (var i = 0; i < options.length; i++)
                        fnc(text, options[i], subject)
                }
            }

        };
    };

    TC.Map._instances = [];

    TC.Map.get = function (elm) {
        for (var i = 0, len = TC.Map._instances.length; i < len; i++) {
            const instance = TC.Map._instances[i];
            if (instance.div === elm) {
                return instance;
            }
        }
    };

    TC.inherit(TC.Map, TC.EventTarget);

    var deleteTreeCache = function (layer) {
        if (layer.type === TC.Consts.layerType.WMS) {
            layer.tree = null;
        }
    };

    /**
     * Función que mezcla opciones de mapa relativos a capa, teniendo cuidado de que puede haber objetos de opciones de capa o identificadores de capa.
     * En este último caso, si no son la opción prioritaria, hay que sustituirlos por los objetos de definiciones de capa.
     */
    var mergeLayerOptions = function (optionsArray, propertyName) {
        // lista de opciones de capa de los argumentos
        var layerOptions = Array.prototype.slice.call(optionsArray).map(function (elm) {
            var result = {};
            if (elm) {
                result[propertyName] = elm[propertyName];
            }
            return result;
        });
        if (propertyName === 'availableBaseLayers') console.log("layerOptions", layerOptions);
        // añadimos las opciones de capa de la configuración general
        var layerOption = {};
        layerOption[propertyName] = TC.Cfg[propertyName];
        layerOptions.unshift(layerOption);

        //Si se han definido baseLayers en el visor, hay que hacer un merge con las predefinidas en la API
        if (propertyName === 'baseLayers' && layerOptions[1]['baseLayers']) {
            layerOption = layerOptions[1];

            for (var i = 0; i < layerOption['baseLayers'].length; i++) {
                if (typeof layerOption['baseLayers'][i] === 'object') {
                    TC.Util.extend(layerOption['baseLayers'][i], getAvailableBaseLayer.call(this, layerOption['baseLayers'][i].id));
                }
            }
        } else {
            layerOptions.unshift(true); // Deep merge
            layerOption = TC.Util.extend.apply(this, layerOptions);
            if (propertyName === 'availableBaseLayers') console.log("layerOption", layerOption);
        }

        return layerOption[propertyName];
    };

    const mergeControlOptions = function (controlOptions) {
        if (controlOptions.controlContainer) {
            Object.keys(controlOptions).filter(function (key) {
                return Object.keys(controlOptions.controlContainer.controls).indexOf(key) > -1
            }).forEach(function (key) {
                const containerControl = controlOptions.controlContainer.controls[key];
                if (typeof containerControl.options === 'boolean') {
                    containerControl.options = {}
                }
                TC.Util.extend(containerControl.options, controlOptions[key]);
                delete controlOptions[key];
            });
        }

        return controlOptions;
    }

    const mergeOptions = function () {
        const argArray = [true, {}, TC.Cfg].concat(Array.prototype.slice.call(arguments));
        const result = this.options = TC.Util.extend.apply(this, argArray);
        // Concatenamos las colecciones availableBaseLayers
        result.availableBaseLayers = TC.Cfg.availableBaseLayers.concat.apply(TC.Cfg.availableBaseLayers, Array.prototype.map.call(arguments, function (arg) {
            return arg.availableBaseLayers || [];
        }));
        result.baseLayers = mergeLayerOptions.call(this, arguments, 'baseLayers');
        result.workLayers = mergeLayerOptions.call(this, arguments, 'workLayers');

        const controls = Array.prototype.slice.call(arguments)
            .filter(elem => elem.controls)
            .map(elem => elem.controls);
        if (controls.length > 0) {
            result.controls = mergeControlOptions(result.controls);
        }

        return result;
    };

    var mapProto = TC.Map.prototype;

    var crsLayerError = function (map, layer) {
        var errorMessage = 'Layer "' + layer.title + '" ("' + layer.names + '"): ';
        var reason;
        if (layer.isValidFromNames()) {
            reason = 'layerSrsNotCompatible'
        } else {
            reason = 'layerNameNotValid';
        }
        errorMessage += TC.Util.getLocaleString(map.options.locale, reason);
        TC.error(errorMessage);
        map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: reason });
    };

    mapProto.getCRS = function () {
        const self = this;

        if (!self.on3DView) {
            return self.crs;
        } else {
            return self.view3D.crs;
        }
    };

    /**
     * Añade una capa al mapa.
     * @method addLayer
     * @async
     * @param {TC.Layer|TC.cfg.LayerOptions|string} layer Objeto de capa, objeto de opciones del constructor de la capa, o identificador de capa.
     * @param {function} [callback] Función de callback.
     * @return {Promise} Promesa de objeto {{#crossLink "TC.Layer"}}{{/crossLink}}
     */
    mapProto.addLayer = function (layer, callback) {
        const self = this;

        const result = new Promise(function (resolve, reject) {

            const isLayerRaster = isRaster(layer);
            if (typeof layer === 'object' && !layer.id) {
                layer.id = TC.getUID();
            }

            self._layerBuffer.add(layer.id || layer, isLayerRaster, layer.isBase);

            if (self.getLayer(layer.id)) {
                // Si ya existe capa con el mismo id, lanzamos error
                const error = Error(`Layer "${layer.id}" already exists`);
                error.layerId = layer.id;
                reject(error);
                return;
            }

            var lyr;
            var test;
            var objUrl;

            if (isLayerRaster) {
                test = !TC.layer || !TC.layer.Raster;
                objUrl = TC.apiLocation + 'TC/layer/Raster';
            }
            else {
                test = !TC.layer || !TC.layer.Vector;
                objUrl = TC.apiLocation + 'TC/layer/Vector';
            }
            TC.loadJS(
                test,
                [objUrl],
                function () {
                    if (typeof layer === 'string') {
                        lyr = new TC.layer.Raster(TC.Util.extend({}, getAvailableBaseLayer.call(self, layer), { map: self }));
                    }
                    else {
                        if (layer instanceof TC.Layer) {
                            lyr = layer;
                            lyr.map = self;
                        }
                        else {
                            layer.map = self;
                            if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                                lyr = new TC.layer.Vector(layer);
                            }
                            else {
                                lyr = new TC.layer.Raster(layer);
                            }
                        }
                    }

                    Promise.all([self.wrap.getMap(), lyr.wrap.getLayer()]).then(function () {

                        self.trigger(TC.Consts.event.BEFORELAYERADD, { layer: lyr });

                        // Nos aseguramos de que las capas raster se quedan por debajo de las vectoriales
                        var idx;
                        if (isRaster(lyr)) {
                            idx = self.wrap.indexOfFirstVector();
                        }
                        if (idx === -1) {
                            idx = self.wrap.getLayerCount();
                        }

                        const currentCrs = self.state && self.state.crs ? self.state.crs : self.getCRS();                        
                        TC.loadProjDef({
                            crs: currentCrs,
                            callback: function () {                                
                                const isCompatible = lyr.isCompatible(currentCrs);
                                if (lyr.isBase) {
                                    if (!isCompatible) {
                                        if (!lyr.type === TC.Consts.layerType.WMTS) {
                                            lyr.mustReproject = true;
                                        }
                                        else {
                                            const compatibleMatrixSet = lyr.wrap.getCompatibleMatrixSets(currentCrs)[0];
                                            if (compatibleMatrixSet) {
                                                lyr.wrap.setMatrixSet(compatibleMatrixSet);
                                            }
                                            else {
                                                lyr.mustReproject = true;
                                            }
                                        }
                                    }
                                    if (self.state) {
                                        lyr.isDefault = (self.state.base === lyr.id) || (self.state.base === lyr.options.fallbackLayer);
                                    }
                                    else if (typeof self.options.defaultBaseLayer === 'string') {
                                        lyr.isDefault = self.options.defaultBaseLayer === lyr.id;
                                    }
                                    else if (typeof self.options.defaultBaseLayer === 'number') {
                                        lyr.isDefault = self.options.defaultBaseLayer === self.baseLayers.length;
                                    }
                                    if (lyr.isDefault) {
                                        var fit;
                                        if (lyr.mustReproject && !lyr.type === TC.Consts.layerType.WMTS ||
                                            lyr.mustReproject && lyr.type === TC.Consts.layerType.WMTS && !lyr.wrap.getCompatibleMatrixSets(currentCrs)[0]) {
                                            if (lyr.options.fallbackLayer && lyr.getFallbackLayer) {

                                                self.addLayer(lyr.getFallbackLayer()).then(function (l) {
                                                    self.wrap.setBaseLayer(l.wrap.layer);
                                                    self.baseLayer = l.wrap.parent;
                                                    // GLS: Tema casita + initialExtent
                                                    fitToExtent(fit);

                                                    resolve(lyr);
                                                });
                                            } else {
                                                crsLayerError(self, lyr);
                                                const error = Error('Layer ' + lyr.id + ' incompatible with CRS');
                                                error.layerId = layer.id;
                                                reject(error);
                                            }
                                        }
                                        else {
                                            fit = self.baseLayer === null;

                                            lyr.wrap.getLayer().then(function (ollyr) {
                                                self.wrap.setBaseLayer(ollyr);
                                                self.baseLayer = lyr;

                                                // GLS: Tema casita + initialExtent
                                                fitToExtent(fit);

                                                resolve(lyr);
                                            });
                                        }
                                    }
                                    else {
                                        //self.baseLayers[self.baseLayers.length] = lyr;
                                        resolve(lyr);
                                    }
                                }
                                else {
                                    if (isCompatible) {
                                        lyr.wrap.getLayer().then(function (l) {
                                            resolve(lyr);
                                        });
                                    }
                                    else {
                                        crsLayerError(self, lyr);
                                        const error = Error('Layer ' + lyr.id + ' incompatible with CRS');
                                        error.layerId = layer.id;
                                        reject(error);
                                    }
                                }
                            }
                        });
                    }, function (error) {
                        error.layerId = layer.id;
                        reject(error);
                    });
                }
            );
        });

        result
            .then(function (l) {
                self._layerBuffer.resolve(self, l, l.isBase);
                if (!l.isBase) {
                    self.wrap.insertLayer(l.wrap.layer, self._layerBuffer.getResolvedVisibleLayerIndex(self, l.id));
                }
                self.trigger(TC.Consts.event.LAYERADD, { layer: l });
                self._layerBuffer.checkMapLoad(self);
                if (TC.Util.isFunction(callback)) {
                    callback(l);
                }
            })
            .catch(function (err) {
                self._layerBuffer.reject(self, err);
                self._layerBuffer.checkMapLoad(self);
            });

        const fitToExtent = function (fit) {
            if (fit) {
                var opt = {
                    projection: self.wrap.map.getView().getProjection(),
                    extent: self.initialExtent
                };
                var resolutions = self.baseLayer.getResolutions();
                if (resolutions && resolutions.length) {
                    opt.resolutions = resolutions;
                }
                else {
                    opt.minZoom = self.wrap.map.getView().getMinZoom();
                    opt.maxZoom = self.wrap.map.getView().getMaxZoom();
                    var minResolution = self.baseLayer.wrap.layer.getMinResolution();
                    if (minResolution !== 0) {
                        opt.minResolution = minResolution;
                    }
                    var maxResolution = self.baseLayer.wrap.layer.getMaxResolution();
                    if (maxResolution !== Number.POSITIVE_INFINITY) {
                        opt.maxResolution = maxResolution;
                    }
                }

                self.wrap.map.setView(new ol.View(opt));
                self.wrap.map.getView().fit(self.initialExtent);
            }
        };
        return result;
    };


    mapProto.removeLayer = function (layer) {
        const self = this;

        return new Promise(function (resolve, reject) {

            if (layer.unremovable) {
                return reject("Unremovable");
            }

            layer.wrap.getLayer().then(function (olLayer) {
                for (var i = 0; i < self.layers.length; i++) {
                    if (self.layers[i] === layer) {
                        self.layers.splice(i, 1);
                        break;
                    }
                }
                if (layer.isBase) {
                    for (var i = 0; i < self.baseLayers.length; i++) {
                        if (self.baseLayers[i] === layer) {
                            self.baseLayers.splice(i, 1);
                            if (self.baseLayer === layer) {
                                self.setBaseLayer(self.baseLayers[0]);
                            }
                            break;
                        }
                    }
                }
                else {
                    for (var i = 0; i < self.workLayers.length; i++) {
                        if (self.workLayers[i] === layer) {
                            self.workLayers.splice(i, 1);
                            break;
                        }
                    }
                    if (layer === self.vectors) {
                        self.vectors = null;
                    }
                }
                self.wrap.removeLayer(olLayer);
                self._layerBuffer.remove(layer.id);
                self.trigger(TC.Consts.event.LAYERREMOVE, { layer: layer });
                self._layerBuffer.checkMapLoad(self);
                resolve(layer);
            });
        });
    };


    mapProto.insertLayer = function (layer, idx, callback) {
        var self = this;
        var beforeIdx = -1;
        for (var i = 0; i < self.layers.length; i++) {
            if (layer === self.layers[i]) {
                beforeIdx = i;
                break;
            }
        }

        var promises = [];
        promises.push(layer.wrap.getLayer());
        var targetLayer = self.layers[idx];
        if (targetLayer) {
            promises.push(targetLayer.wrap.getLayer());
        }
        Promise.all(promises).then(function (olLayers) {
            const olLayer = olLayers[0];
            const olTargetLayer = olLayers[1];
            var olIdx = -1;
            if (olTargetLayer) {
                olIdx = self.wrap.getLayerIndex(olTargetLayer);
            }
            else {
                olIdx = self.wrap.getLayerCount();
            }
            if (olIdx >= 0) {
                layer.map = self;
                self.wrap.insertLayer(olLayer, olIdx);
                if (beforeIdx > -1) {
                    self.layers.splice(beforeIdx, 1);
                }
                self.layers.splice(idx, 0, layer);
                self.workLayers = self.layers.filter(function (elm) {
                    return !elm.isBase;
                });
                self.trigger(TC.Consts.event.LAYERORDER, { layer: layer, oldIndex: beforeIdx, newIndex: idx });
            }
            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    mapProto.setLayerIndex = function (layer, idx) {
        this.wrap.setLayerIndex(layer.wrap.layer, idx);
    };

    mapProto.putLayerOnTop = function (layer) {
        var self = this;
        var n = self.wrap.getLayerCount();
        self.setLayerIndex(layer, n - 1);
    };

    /*
    *  setBaseLayer: Set a layer as base layer, it is added to layers collection it wasn't before
    *  Parameters: TC.Layer or string, callback which accepts layer as parameter
    *  Returns: TC.Layer promise
    */
    mapProto.setBaseLayer = function (layer, callback) {
        var self = this;
        var result = null;
        var found = false;

        if (typeof layer === 'string') {
            var i;
            for (i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    layer = self.layers[i];
                    found = true;
                    break;
                }
            }
            if (!found) {
                layer = getAvailableBaseLayer.call(self, layer);
                if (layer) {
                    layer = self.addLayer(TC.Util.extend(true, {}, layer, { isDefault: true, map: self }));
                    found = true;
                }
            }
        }
        else {
            if (self.layers.indexOf(layer) < 0) {
                layer.isDefault = true;
                layer.map = self;
                self.addLayer(layer);
                // GLS: comento lo siguiente porque ya se va a tratar en la línea 1838, si no, se lanza el evento 2 veces
                //.then(function () {                
                //self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                //if (TC.Util.isFunction(callback)) {
                //    callback();
                //}
                //});

                //result = layer;
                //return result;
            }
            found = true;
        }
        if (!found) {
            TC.error('Base layer is not available');
        }
        else {
            if (!layer.isCompatible(self.getCRS()) && (!layer.fallbackLayer || layer.fallbackLayer && !layer.fallbackLayer.isCompatible(self.getCRS()))) {
                TC.error('Base layer must be reprojected');
            }
            else {
                self.trigger(TC.Consts.event.BEFOREBASELAYERCHANGE, { oldLayer: self.getBaseLayer(), newLayer: layer });

                result = layer;
                self.wrap.getMap().then(function (olMap) {
                    layer.wrap.getLayer().then(function (olLayer) {
                        self.wrap.setBaseLayer(olLayer).then(function () {
                            self.baseLayer = layer;
                            self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                            if (TC.Util.isFunction(callback)) {
                                callback();
                            }
                        });
                    });
                });
            }
        }
        return result;
    };

    mapProto.setView = function (view) {
        const self = this;

        self.view = view;
        self.trigger(TC.Consts.event.VIEWCHANGE, { view: view });
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles del mapa se hayan cargado.
     * @method ready
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.ready = function (callback) {
        var self = this;
        if (TC.Util.isFunction(callback)) {
            if (self.isReady) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPREADY, callback);
            }
        }
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles y las capas iniciales del mapa se hayan cargado.
     * @method loaded
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.loaded = function (callback) {
        var self = this;
        if (TC.Util.isFunction(callback)) {
            if (self.isLoaded) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };



    /**
     * Devuelve un árbol de capas del mapa.
     * @method getLayerTree
     * @return {TC.LayerTree}
     */
    mapProto.getLayerTree = function () {


        var _traverse = function (o, func) {
            for (var i in o.children) {
                if (o.children && o.children.length > 0) {
                    //bajar un nivel en el árbol
                    _traverse(o.children[i], func);
                }

                func.apply(this, [o]);
            }
        };



        var self = this;
        var result = { baseLayers: [], workLayers: [] };
        if (self.baseLayer) {
            result.baseLayers[0] = self.baseLayer.getTree();
        }
        for (var i = 0; i < self.workLayers.length; i++) {
            var tree = self.workLayers[i].getTree();

            if (tree) {
                result.workLayers.unshift(tree);
            }
        }
        return result;
    };

    /**
     * Añade un control al mapa.
     * @method addControl
     * @async
     * @param {TC.Control|string} control Control a añadir o nombre del control
     * @param {object} [options] Objeto de opciones de configuración del control. Consultar el parámetro de opciones del constructor del control.
     * @return {Promise} Promesa de objeto {{#crossLink "TC.Control"}}{{/crossLink}}
     */
    mapProto.addControl = function (control, options) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const _addCtl = function (ctl) {
                self.controls.push(ctl);
                // Lo envolvemos en Promise.resolve para asegurarse compatibilidad hacia atrás con los controles que devuelven un $.Deferred.
                return Promise.resolve(ctl.register(self))
                    .then(function (c) {
                        if (!ctl.div.parentElement) {
                            self.div.appendChild(ctl.div);
                        }
                        self.trigger(TC.Consts.event.CONTROLADD, { control: ctl });
                        return c;
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            };
            if (typeof control === 'string') {
                control = control.substr(0, 1).toUpperCase() + control.substr(1);
                TC.loadJS(
                    !TC.Control || !TC.control[control],
                    [TC.apiLocation + 'TC/control/' + control],
                    function () {
                        _addCtl(new TC.control[control](null, options)).then(function (ctl) {
                            resolve(ctl)
                        });
                    }
                );
            }
            else {
                _addCtl(control).then(function (ctl) {
                    resolve(ctl);
                });
            }
        });
    };

    /**
     * Devuelve la lista de controles que son de la clase especificada.
     * @method getControlsByClass
     * @param {function|string} classObj Nombre de la clase o función constructora de la clase.
     * @return {array}
     */
    mapProto.getControlsByClass = function (classObj) {
        var self = this;
        var result = [];
        var obj = classObj;
        if (typeof classObj === 'string') {
            obj = window;
            var namespaces = classObj.split('.');
            for (var i = 0; i < namespaces.length; i++) {
                obj = obj[namespaces[i]];
                if (!obj) {
                    break;
                }
            }
        }
        if (TC.Util.isFunction(obj)) {
            for (var i = 0; i < self.controls.length; i++) {
                var ctl = self.controls[i];
                if (ctl instanceof obj) {
                    result.push(ctl);
                }
            }
        }

        return result;
    };

    mapProto.getControlById = function (id) {
        const self = this;
        for (var i = 0, len = self.controls.length; i < len; i++) {
            const ctl = self.controls[i];
            if (ctl.id === id) {
                return ctl;
            }
        }
        return null;
    };

    mapProto.getDefaultControl = function () {
        const self = this;
        var candidate;
        if (self.options.defaultActiveControl) {
            candidate = self.getControlsByClass('TC.control.' + self.options.defaultActiveControl.substr(0, 1).toUpperCase() + self.options.defaultActiveControl.substr(1))[0];
        }
        if (!candidate) {
            candidate = self.getControlsByClass('TC.control.MultiFeatureInfo')[0];
            if (candidate) {
                candidate = candidate.lastCtrlActive;
            }
            else {
                candidate = self.getControlsByClass('TC.control.FeatureInfo')[0];
            }
        }
        return candidate;
    };

    /**
     * Devuelve el primer control del mapa que sea de la clase {{#crossLink "TC.control.LoadingIndicator"}}{{/crossLink}}.
     * @method getLoadingIndicator
     * @return {TC.control.LoadingIndicator}
     */
    mapProto.getLoadingIndicator = function () {
        var result = null;
        var ctls = this.getControlsByClass('TC.control.LoadingIndicator');
        if (ctls.length) {
            result = ctls[0];
        }
        return result;
    };

    /**
     * Establece la extensión del mapa.
     * @method setExtent
     * @param {array} extent Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al cambiar la extensión.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.setExtent = function (extent, options) {
        return this.wrap.setExtent(extent, options);
    };

    /**
     * Obtiene la extensión actual del mapa.
     * @method getExtent
     * @return {array} Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.getExtent = function () {
        return this.wrap.getExtent();
    };

    /**
     * Establece el centro del mapa.
     * @method setCenter
     * @param {array} coord Array de dos números que representan la coordenada del punto en las unidades correspondientes al CRS del mapa.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al centrar.
     */
    mapProto.setCenter = function (coord, options) {
        return this.wrap.setCenter(coord, options);
    };

    mapProto.getCenter = function () {
        return this.wrap.getCenter();
    };

    mapProto.setRotation = function (rotation) {
        this.wrap.setRotation(rotation);
    };

    mapProto.getRotation = function () {
        return this.wrap.getRotation();
    };

    mapProto.getViewHTML = function () {
        return this.wrap.getViewport();
    };


    mapProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        const layers = options.layers || self.workLayers.concat(self.baseLayer);
        const crsLists = layers
            .filter(function (layer) {
                return layer.isRaster();
            }) // capas raster
            .map(function (layer) {
                return layer.getCompatibleCRS({ normalized: true, includeFallback: options.includeFallbacks });
            });
        const otherCrsLists = crsLists.slice(1);
        return crsLists[0].filter(function (elm) {
            return otherCrsLists.every(function (crsList) {
                return crsList.indexOf(elm) >= 0;
            });
        });
    };

    mapProto.loadProjections = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            const crsList = options.crsList || [];
            Promise.all(crsList
                .map(function (crs) {
                    return TC.getProjectionData({
                        crs: TC.Util.getCRSCode(crs)
                    });
                })).then(function (responses) {
                    var projList = responses
                        .filter(function (response) {
                            return response.status === 'ok' && response.number_result > 0;
                        })
                        .map(function (response) {
                            const projData = response.results[0];
                            const code = 'EPSG:' + projData.code;
                            TC.loadProjDef({
                                crs: code,
                                def: projData.def,
                                name: projData.name
                            });
                            return {
                                code: code,
                                name: projData.name,
                                proj4: projData.proj4,
                                unit: projData.unit
                            };
                        });
                    if (options.orderBy) {
                        projList = projList
                            .sort(TC.Util.getSorterByProperty(options.orderBy));
                    }
                    resolve(projList);
                },
                function (error) {
                    reject(error);
                });
        });
    };

    mapProto.setProjection = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            var baseLayer;
            if (options.crs) {
                if (options.baseLayer) {
                    baseLayer = options.baseLayer;
                }
                else if (options.allowFallbackLayer) {
                    // Cambiamos de capa de fondo si es mejor o no hay más remedio
                    if (!self.baseLayer.isCompatible(options.crs) &&
                        self.baseLayer.wrap.getCompatibleMatrixSets(options.crs).length === 0) {
                        if (self.baseLayer.options.fallbackLayer) {
                            baseLayer = self.baseLayer.getFallbackLayer();
                        }
                    }
                    else if (self.baseLayer.firstOption && (self.baseLayer.firstOption.isCompatible(options.crs) ||
                        self.baseLayer.firstOption.wrap.getCompatibleMatrixSets(options.crs).length > 0)) {
                        baseLayer = self.baseLayer.firstOption;
                    }
                }
                if (!baseLayer) {
                    baseLayer = self.baseLayer;
                }

                // 03/04/2019 GLS: esperamos a que termine de añadirse la capa porque si no se duplica en la gestión de la carga del CRS.
                const loadProj = function () {
                    TC.loadProjDef({
                        crs: options.crs,
                        callback: function () {
                            const setProjection = function (baseLayer) {

                                const _setProjection = function () {
                                    const layerProjectionOptions = TC.Util.extend({}, options, { oldCrs: self.crs });
                                    const setLayerProjection = function (layer) {
                                        layer.setProjection(layerProjectionOptions);
                                    };
                                    if (baseLayer.isCompatible(options.crs) || baseLayer.wrap.getCompatibleMatrixSets(options.crs).length > 0) {
                                        baseLayer.setProjection(layerProjectionOptions);
                                        self.wrap.setProjection(TC.Util.extend({}, options, { baseLayer: baseLayer }));
                                        self.crs = options.crs;
                                        // En las capas base disponibles, evaluar su compatibilidad con el nuevo CRS
                                        self.baseLayers
                                            .filter(function (layer) {
                                                return layer !== baseLayer;
                                            })
                                            .forEach(setLayerProjection);
                                        // Reprojectamos capas cargadas
                                        self.workLayers.forEach(setLayerProjection);
                                        const resolveChange = function () {
                                            self.trigger(TC.Consts.event.PROJECTIONCHANGE, { crs: options.crs });
                                            resolve();
                                        };
                                        if (baseLayer && baseLayer !== self.baseLayer) {
                                            self.setBaseLayer(baseLayer, resolveChange);
                                        }
                                        else {
                                            resolveChange();
                                        }
                                    }
                                    else if (baseLayer.fallbackLayer) {
                                        setProjection(baseLayer.fallbackLayer);
                                    } else {
                                        reject();
                                    }
                                };

                                if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                                    baseLayer.getCapabilitiesPromise().then(_setProjection);
                                } else {
                                    _setProjection();
                                }
                            };

                            setProjection(baseLayer);
                        }
                    });
                };

                if (self.baseLayers.indexOf(baseLayer) < 0) {
                    self.addLayer(baseLayer).then(loadProj);
                } else {
                    loadProj();
                }
            }
        });
    };

    mapProto.getMetersPerUnit = function () {
        return this.wrap.getMetersPerUnit();
    };

    /**
     * Obtiene una coordenada a partir de una posición del área de visualización del mapa en píxeles.
     * @method getCoordinateFromPixel
     * @param {array} xy Coordenada en píxeles de la posición en el área de visualización.
     * @return {array} Array de dos números que representa las coordenada del punto en las unidades correspondientes al CRS del mapa.
     */
    mapProto.getCoordinateFromPixel = function (xy) {
        return this.wrap.getCoordinateFromPixel(xy);
    };

    /**
     * Obtiene una posición en el área de visualización a partir de una coordenada.
     * @method getCoordinateFromPixel
     * @param {array} coord Coordenada en el mapa.
     * @return {array} Array de dos números que representa las posición del punto en píxeles.
     */
    mapProto.getPixelFromCoordinate = function (coord) {
        return this.wrap.getPixelFromCoordinate(coord);
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas las entidades geográficas pasadas por parámetro.
     * @method zoomToFeatures
     * @param {array} features Array de entidades geográficas. Si está vacío este método no hace nada.
     * @param {object} [options] Objeto de opciones de zoom.
     * @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del punto que se respetará al hacer zoom.
     * @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas las entidades. 
     * @param {boolean} [options.animate=false] Realizar animación al hacer el zoom. 
     * El valor es la relación resultante de la diferencia de dimensiones entre la extensión ampliada y la original relativa a la original.
     */
    mapProto.zoomToFeatures = function (features, options) {
        var self = this;
        if (features.length > 0) {
            var bounds = [Infinity, Infinity, -Infinity, -Infinity];
            var opts = options || {};
            var radius = opts.pointBoundsRadius || self.options.pointBoundsRadius;
            radius = radius / self.getMetersPerUnit();
            var extentMargin = opts.extentMargin;
            if (typeof extentMargin !== 'number') {
                extentMargin = self.options.extentMargin;
            }
            for (var i = 0; i < features.length; i++) {
                var b = features[i].getBounds();
                if (b) {
                    bounds[0] = Math.min(bounds[0], b[0]);
                    bounds[1] = Math.min(bounds[1], b[1]);
                    bounds[2] = Math.max(bounds[2], b[2]);
                    bounds[3] = Math.max(bounds[3], b[3]);
                }
            }
            if (bounds[2] - bounds[0] === 0) {
                bounds[0] = bounds[0] - radius;
                bounds[2] = bounds[2] + radius;
            }
            if (bounds[3] - bounds[1] === 0) {
                bounds[1] = bounds[1] - radius;
                bounds[3] = bounds[3] + radius;
            }
            if (self.options.extentMargin) {
                var dx = (bounds[2] - bounds[0]) * extentMargin / 2;
                var dy = (bounds[3] - bounds[1]) * extentMargin / 2;
                bounds[0] = bounds[0] - dx;
                bounds[1] = bounds[1] - dy;
                bounds[2] = bounds[2] + dx;
                bounds[3] = bounds[3] + dy;
            }
            if (self.options.maxExtent) {
                bounds[0] = Math.max(bounds[0], self.options.maxExtent[0]);
                bounds[1] = Math.max(bounds[1], self.options.maxExtent[1]);
                bounds[2] = Math.min(bounds[2], self.options.maxExtent[2]);
                bounds[3] = Math.min(bounds[3], self.options.maxExtent[3]);
            }
            self.wrap.setExtent(bounds, opts);

            // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
            self.trigger(TC.Consts.event.ZOOMTO, { extent: bounds });
        }
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas los marcadores que existen en él.
     * El método espera a todos los marcadores pendientes de incluir, dado que el método {{#crossLink "TC.Map/addMarker:method"}}{{/crossLink}} es asíncrono.
     * @method zoomToMarkers
     */
    mapProto.zoomToMarkers = function (options) {
        var self = this;
        Promise.all(self._markerPromises).then(function () {
            var markers = [];
            for (var i = 0; i < self.workLayers.length; i++) {
                var layer = self.workLayers[i];
                if (layer.type === TC.Consts.layerType.VECTOR) {
                    for (var j = 0; j < layer.features.length; j++) {
                        var feature = layer.features[j];
                        if (feature instanceof TC.feature.Marker) {
                            markers[markers.length] = feature;
                        }
                    }
                }
            }

            self.zoomToFeatures(markers, options);
            self._markerPromises = [];
        });
    };

    /**
     * Obtiene una capa por su identificador o devuelve la propia capa.
     * @method getLayer
     * @param {string|TC.Layer} layer Identificador de la capa u objeto de capa.
     * @return {TC.Layer}
     */
    mapProto.getLayer = function (layer) {
        const self = this;
        var result = null;
        if (typeof layer === 'string') {
            for (var i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    result = self.layers[i];
                    break;
                }
            }
        }
        else if (TC.Layer && layer instanceof TC.Layer && layer.map === self) {
            result = layer;
        }
        return result;
    };

    var _getVectors = function (map) {
        var result;
        if (!map.vectors) {
            result = map.addLayer({
                id: TC.getUID(), title: TC.i18n[map.options.locale]['vectors'], type: TC.Consts.layerType.VECTOR
            });
            map.vectors = result;
            result.then(function (vectors) {
                map.vectors = vectors;
            });
        }
        else {
            result = Promise.resolve(map.vectors);
        }
        return result;
    };

    /**
     * Añade un punto al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPoint
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.PointStyleOptions} [options] Opciones del punto.
     */
    mapProto.addPoint = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                layer.addPoint(coord, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPoint(coord, options);
            });
        }
    };

    /**
     * Añade un marcador puntual al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addMarker
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.MarkerStyleOptions} [options] Opciones del marcador.
     */
    mapProto.addMarker = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                self._markerPromises.push(layer.addMarker(coord, options));

            }
            else {
                self._markerPromises.push(Promise.reject(new Error('Layer "' + options.layer + '" not found')));
            }
        }
        else {
            // Se añade una promise más para evitar que zoomToMarkers salte antes de poblarse el array _markerPromises.
            self._markerPromises.push(new Promise(function (resolve, reject) {
                _getVectors(self).then(function (vectors) {
                    vectors.addMarker(coord, options).then(function (marker) {
                        resolve(marker);
                    });
                });
            }));
        }
    };

    /**
     * Añade una polilínea al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolyline
     * @async
     * @param {array} coords Array de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * @param {object} [options] Opciones de la polilínea.
     */
    mapProto.addPolyline = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolyline(coords, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolyline(coords, options);
            });
        }
    };

    /**
     * Añade un polígono al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolygon
     * @async
     * @param {array} coords Array que contiene anillos. Estos a su vez son arrays de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * El primer anillo es el exterior y el resto son islas. No es necesario cerrar los anillos (poner el mismo vértice al principio y al final).
     * @param {object} [options] Opciones del polígono.
     */
    mapProto.addPolygon = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolygon(coords, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolygon(coords, options);
            });
        }
    };




    mapProto.getBaseLayer = function () {
        return this.baseLayer || this.baseLayers[0];
    };

    mapProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    mapProto.getResolution = function () {
        return this.wrap.getResolution();
    };

    mapProto.setResolution = function (resolution) {
        this.wrap.setResolution(resolution);
    };

    mapProto.exportFeatures = function (features, options) {
        var self = this;
        options = options || {};
        var loadingCtl = self.getLoadingIndicator();
        var waitId = loadingCtl && loadingCtl.addWait();
        // Eliminamos las elevaciones nulas
        // En GPX hay un bug con los valores cero, que hace que se tome el valor de elevación del punto previo, por eso ponemos NaN.
        const elevSubst = options.format === TC.Consts.format.GPX ? Number.NaN : 0;
        features.forEach(function (feature, idx) {
            var flatCoords = feature.getCoords({ pointArray: true });
            if (flatCoords.some(function (point) {
                return point[2] === null;
            })) {
                features[idx] = feature = feature.clone();
                flatCoords = feature.getCoords({ pointArray: true });
                flatCoords.forEach(function (point) {
                    if (point[2] === null) {
                        point[2] = elevSubst;
                    }
                });
            }
        });

        const text = self.wrap.exportFeatures(features, options);
        const mimeType = TC.Consts.mimeType[options.format];
        const format = options.format || "";
        TC.Util.downloadFile((options.fileName || TC.getUID()) + '.' + format.toLowerCase(), mimeType, text);
        loadingCtl && loadingCtl.removeWait(waitId);
    };


    var toastContainerClass = 'tc-toast-container';
    var toastClass = 'tc-toast';
    var toasts = {};
    var toastHide = function () {
        const toast = this;
        var container = toast;
        do {
            container = container.parentElement;
        }
        while (container && !container.matches('.' + toastContainerClass));
        const text = toast.innerHTML;
        toast.classList.add(TC.Consts.classes.HIDDEN);
        if (toasts[text] !== undefined) {
            toasts[text] = undefined;
        }
        setTimeout(function () {
            if (toast.parentElement) {
                toast.parentElement.removeChild(toast);
            }
            if (container && !container.querySelector('.' + toastClass) && container.parentElement) {
                container.parentElement.removeChild(container);
            }
        }, 1000);
    };

    mapProto.toastHide = function (text) {
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
    };

    mapProto.toast = function (text, options) {
        const self = this;
        var opts = options || {
        };
        var duration = opts.duration || TC.Cfg.toastDuration;
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
        var container = self.div.querySelector('.' + toastContainerClass);
        if (!container) {
            container = document.createElement('div');
            container.classList.add(toastContainerClass);
            (opts.container ? opts.container : self.div).appendChild(container);
        }
        const toast = document.createElement('div');
        const span = document.createElement('span');
        toast.classList.add(toastClass);
        toast.appendChild(span);
        const p = document.createElement('p');
        p.innerHTML = text;
        toast.appendChild(p);
        toast.addEventListener(TC.Consts.event.CLICK, toastHide);
        container.appendChild(toast);
        toastInfo = toasts[text] = {
            toast: toast
        };

        var className = '';
        switch (opts.type) {
            case TC.Consts.msgType.INFO:
                className = TC.Consts.classes.INFO;
                break;
            case TC.Consts.msgType.WARNING:
                className = TC.Consts.classes.WARNING;
                break;
            case TC.Consts.msgType.ERROR:
                className = TC.Consts.classes.ERROR;
                break;
        }
        if (className.length) {
            toastInfo.toast.classList.add(className);
        }

        toastInfo.timeout = setTimeout(function () {
            toastHide.call(toastInfo.toast);
        }, duration);
    };

    // iPad iOS7 bug fix
    var mapHeightNeedsFix = false;
    var setHeightFix = function (div) {
        if (/iPad/i.test(navigator.userAgent)) {
            var ih = window.innerHeight;
            var mh = div.getBoundingClientRect.height;
            var dh = matchMedia('only screen and (orientation : landscape)').matches ? 20 : 0;
            if (mh === ih + dh) {
                mapHeightNeedsFix = true;
            }
        }
        var fix = function () {
            div.classList.toggle(TC.Consts.classes.IPAD_IOS7_FIX, matchMedia('only screen and (orientation : landscape)').matches);
        };
        if (mapHeightNeedsFix) {
            fix();
            window.addEventListener('resize', fix);
        }
        else {
            window.removeEventListener('resize', fix);
        }
    };

    var isRaster = function (layer) {
        return typeof layer === 'string' || (layer.type !== TC.Consts.layerType.VECTOR && layer.type !== TC.Consts.layerType.KML && layer.type !== TC.Consts.layerType.WFS);
    };

    mapProto.exportImage = function () {
        var self = this;
        var result = null;
        var errorMsg = 'El mapa actual no es compatible con la exportación de imágenes';
        var canvas = self.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
        if (canvas && self.options.crossOrigin) {
            try {
                result = canvas.toDataURL();
            }
            catch (e) {
                TC.error(errorMsg + ': ' + e.message);
            }
        }
        else {
            TC.error(errorMsg);
        }
        return result;
    };
})();

/**
 * Árbol de capas del mapa.
 * Esta clase no tiene constructor.
 * @class TC.LayerTree
 * @static
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas base del mapa.
 * @property baseLayers
 * @type array
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas de trabajo del mapa.
 * @property workLayers
 * @type array
 */

; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Util = factory();
    }
})(TC, function () {

    String.prototype.soundex = function () {
        var a = this.toLowerCase().split('')
        f = a.shift(),
            r = '',
            codes = {
                a: '', e: '', i: '', o: '', u: '',
                b: 1, f: 1, p: 1, v: 1,
                c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2,
                d: 3, t: 3,
                l: 4,
                m: 5, n: 5,
                r: 6
            };

        r = f +
            a
                .map(function (v, i, a) { return codes[v] })
                .filter(function (v, i, a) { return ((i === 0) ? v !== codes[f] : v !== a[i - 1]); })
                .join('');

        return (r + '000').slice(0, 4).toUpperCase();
    }

    // Polyfill para IE
    Number.isInteger = Number.isInteger || function (value) {
        return typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value;
    };

    // GLS: Parche: Chrome no formatea correctamente los números en euskera, establece como separador de decimales el (.)
    var toLocaleString = Number.prototype.toLocaleString;
    Number.prototype.toLocaleString = function (locale, options) {
        if (locale == "eu-ES" && !TC.Util.detectIE()) {
            var sNum = toLocaleString.apply(this, arguments);
            sNum = sNum.replace(/\,/g, '.')
            if (!(Math.floor(this) == this && Number.isInteger(Math.floor(this))))
                sNum = sNum.replace(/.([^.]*)$/, ",$1");

            return sNum;
        }
        else
            return toLocaleString.apply(this, arguments);
    }

    var iconUrlCache = {};
    var markerGroupClassCache = {};

    var path1 = ["Capability", "Request", "GetMap", "DCPType", "0", "HTTP", "Get", "OnlineResource"];
    var path2 = ["OperationsMetadata", "GetTile", "DCP", "HTTP", "Get", "0", "href"];
    var getOnPath = function (obj, p, i) {
        if (i < p.length - 1) {
            if (obj.hasOwnProperty(p[i]))
                return getOnPath(obj[p[i]], p, ++i);
            else return null;
        } else {
            return obj[p[i]];
        }
    };

    const swipeHandlers = new WeakMap();
    const modalCloseHandlers = new WeakMap();
    const hasOwn = ({}).hasOwnProperty;

    var Util = {

        isPlainObject: function (obj) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (typeof obj !== 'object' || obj.nodeType || obj.window === obj) {
                return false;
            }

            if (obj.constructor &&
                !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }

            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        isFunction: function (obj) {
            return typeof obj === 'function';
        },

        extend: function () {
            var clone,
                target = arguments[0] || {},
                i = 1,
                deep = false;

            // Comprobar si hay que hacer copia profunda (primer parámetro === true)
            if (typeof target === 'boolean') {
                deep = target;

                target = arguments[i] || {};
                i++;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== 'object' && !Util.isFunction(target)) {
                target = {};
            }

            for (var len = arguments.length; i < len; i++) {
                // Only deal with non-null/undefined values
                const options = arguments[i];
                if (options != null) {
                    // Extend the base object
                    for (var name in options) {
                        const src = target[name];
                        const copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        const copyIsArray = Array.isArray(copy);
                        if (deep && copy && (Util.isPlainObject(copy) || copyIsArray)) {
                            if (copyIsArray) {
                                clone = src && Array.isArray(src) ? src : [];

                            } else {
                                clone = src && Util.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = Util.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        },

        getMapLocale: function (map) {
            return map.options && map.options.locale && map.options.locale.replace('_', '-') || "es-ES";
        },

        regex: {
            PROTOCOL: /(^https?:)/i
        },

        isOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            if (withProtocol) {
                if (TC.capabilities[testUrl])
                    return url;
            } else {
                for (var c in TC.capabilities) {
                    if (c.replace(TC.Util.regex.PROTOCOL, "") == testUrl)
                        return c;
                }
            }

            for (c in TC.capabilities) {
                var u = getOnPath(TC.capabilities[c], path1, 0) || getOnPath(TC.capabilities[c], path2, 0);

                if (u && withProtocol && url == u) return u;
                else if (u && url.replace(TC.Util.regex.PROTOCOL, "") == u.replace(TC.Util.regex.PROTOCOL, "")) return u;
            }

            return url;
        },

        reqGetMapOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            var _get = function (caps) {
                var u = getOnPath(caps, path1, 0) || getOnPath(caps, path2, 0);
                if (u)
                    return !withProtocol ? u.split('?')[0].replace(TC.Util.regex.PROTOCOL, "") : u.split('?')[0];

                return null;
            };
            if (TC.capabilities[url]) {
                return _get(TC.capabilities[url]);
            }

            return null;
        },

        getFNFromString: function (fnName) {
            var scope = window;
            var scopeSplit = fnName.split('.');
            for (i = 0; i < scopeSplit.length - 1; i++) {
                scope = scope[scopeSplit[i]];

                if (scope == undefined) return;
            }

            return scope[scopeSplit[scopeSplit.length - 1]];
        },

        isURL: function (text) {
            return /^(http|https|ftp|mailto)\:\/\//i.test(text);
        },

        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        isSameOrigin: function (uri) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var location = window.location;
                var uProtocol = urlParts[1];
                result =
                    (uProtocol == location.protocol || uProtocol == undefined) &&
                    urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        formatNumber: function (value, locale) {
            var t = typeof value;
            if (t === 'number') {
                return value.toLocaleString(locale);
            }
            else if (t === 'string') {
                n = parseFloat(value);
                if (n === new Number(value).valueOf()) {
                    return n.toLocaleString(locale);
                }
            }
            return value;
        },

        addProtocol: function (uri) {
            var result = uri;
            if (uri && uri.indexOf('//') === 0) {
                result = location.protocol + uri;
            }
            return result;
        },

        /* 
        * getDiv: returns HTML element or null if the parameter is invalid
        * Parameter: string with element ID or HTML element
        */
        getDiv: function (div) {
            var result;
            if (typeof div === 'string') {
                result = document.getElementById(div);
            }
            else if (div instanceof HTMLElement) {
                result = div;
            }
            else if ('$' in window && div instanceof $ && div.length) {
                result = div[0];
            }
            else {
                result = document.createElement('div');
            }
            return result;
        },

        getScriptLocation: function () {
            var src;
            var script;
            if (document.currentScript) {
                script = document.currentScript;
            }
            else {
                var scripts = document.getElementsByTagName('script');
                script = scripts[scripts.length - 1];
            }
            src = script.getAttribute('src');
            if (src) {
                return src.substr(0, src.lastIndexOf('/') + 1);
            }
            return "";
        },

        /* 
        * getBackgroundUrlFromCss: devuelve la URL de background-image en CSS
        * Parameter: string con nombre de clase
        */
        getBackgroundUrlFromCss: function (cssClass) {
            var result = '';

            if (cssClass) {
                if (iconUrlCache[cssClass] !== undefined) {
                    result = iconUrlCache[cssClass];
                }
                else {
                    const iconDiv = document.createElement('div');
                    iconDiv.style.display = 'none';
                    iconDiv.classList.add(cssClass);                    
                    document.body.appendChild(iconDiv);                    
                    // The regular expression is nongreedy (.*?), otherwise in FF and IE it gets 'url_to_image"'
                    var match = /^url\(['"]?(.*?)['"]?\)$/gi.exec(window.getComputedStyle(iconDiv, null).backgroundImage);
                    if (match && match.length > 1) {
                        result = match[match.length - 1];
                    }
                    iconDiv.parentElement.removeChild(iconDiv);
                    iconUrlCache[cssClass] = result;
                }
            }
            return result;
        },

        getPointIconUrl: function getPointIconUrl(options) {
            var result = null;
            if (options.url) {
                result = options.url;
            }
            else {
                var className;
                if (typeof options.cssClass === 'string') {
                    className = options.cssClass;
                }
                else {
                    var classes = options.classes || TC.Cfg.styles.marker.classes;
                    className = classes[0];
                    if (options.group) {
                        if (markerGroupClassCache[options.group] === undefined) {
                            var i = 0;
                            for (var key in markerGroupClassCache) {
                                i++;
                            }
                            i = i % classes.length;
                            markerGroupClassCache[options.group] = classes[i];
                        }
                        className = markerGroupClassCache[options.group];
                    }
                }
                result = TC.Util.getBackgroundUrlFromCss(className);
            }
            if (!result && options !== TC.Cfg.styles.point && options.cssClass !== '') {
                result = getPointIconUrl(TC.Cfg.styles.point);
            }
            return result;
        },

        /* 
        * addPathToTree: añade a un array a un árbol, cada elemento en un nivel anidado
        * Parameters: array, nodo de árbol, [índice]
        * Returns: último nodo insertado, null si ya existía la ruta
        */
        addArrayToTree: function addArrayToTree(path, treeNode, index) {
            var result = null;
            var found = false;
            index = index || 0;
            var name = path[index];
            if (name) {
                var n;
                for (var i = 0, len = treeNode.children.length; i < len; i++) {
                    n = treeNode.children[i];
                    if (n.name === name) {
                        found = true;
                        var r = addArrayToTree(path, n, index + 1);
                        if (r) {
                            result = r;
                        }
                        break;
                    }
                }
                if (!found) {
                    n = { name: name, title: name, uid: '/' + path.slice(0, index + 1).join('/'), children: [] };
                    treeNode.children.push(n);
                    result = n;
                }
            }
            return result;
        },

        parseCoords: function (text) {
            var result = null;

            var _parseGeoCoord = function (text) {
                var t = text;
                var result = {};
                result.type = TC.Consts.GEOGRAPHIC;
                var idx = t.indexOf('\u00B0');
                result.value = parseFloat(t.substr(0, idx));
                t = t.substr(idx + 1);
                idx = t.indexOf('\'');
                if (idx >= 0) {
                    var v = parseFloat(t.substr(0, idx)) / 60;
                    if (result.value >= 0) {
                        result.value += v;
                    }
                    else {
                        result.value -= v;
                    }
                    t = t.substr(idx + 1);
                    idx = t.indexOf('\'');
                    if (idx >= 0) {
                        v = parseFloat(t.substr(0, idx).replace(',', '.')) / 3600;
                        if (result.value >= 0) {
                            result.value += v;
                        }
                        else {
                            result.value -= v;
                        }
                    }
                }
                return result;
            };

            var _parseCoord = function (text) {
                var t = text.trim();
                // nnºnn'nn''N
                if (t.match(/^1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?\s*[NnSsWwOoEe]$/g)) {
                    switch (t[t.length - 1]) {
                        case 'S':
                        case 's':
                        case 'W':
                        case 'w':
                        case 'O':
                        case 'o':
                            t = '-' + t;
                            break;
                    }
                    t = t.substr(0, t.length - 1);
                    return _parseGeoCoord(t);
                }
                // +nnºnn'nn''
                if (t.match(/^[+-]?1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?$/g)) {
                    return _parseGeoCoord(t);
                }
                // nn.nn N
                if (t.match(/^1?\d{0,2}([.,]\d+)?\s*\u00B0?\s*[NnSsWwOoEe]$/g)) {
                    var result = { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.substr(0, t.length - 1).replace(',', '.')) };
                    if (t.match(/[SsWwOo]$/)) {
                        result.value = -result.value;
                    }
                    return result;
                }
                // +nn.nn
                if (t.match(/^[+-]?1?\d{0,2}([.,]\d+)?\s*\u00B0?$/g)) {
                    return { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.replace(',', '.')) };
                }
                // UTM
                if (t.match(/^\d{6,7}([.,]\d+)?$/g)) {
                    return { type: TC.Consts.UTM, value: parseFloat(t.replace(',', '.')) };
                }
                return null;
            };

            text = text.trim().toUpperCase();
            var xy = text.split(',');
            if (xy.length === 4) {
                xy = [xy.slice(0, 1).join('.'), xy.slice(2, 3).join('.')];
            }
            else if (xy.length === 1 || xy.length === 3) {
                xy = text.split(' ');
            }
            if (xy.length === 2) {
                var x = _parseCoord(xy[0]);
                var y = _parseCoord(xy[1]);
                if (x !== null && y !== null) {
                    result = [x, y];
                }
            }
            return result;
        },

        reproject: function (coords, sourceCrs, targetCrs) {
            var result;
            var multipoint = true;
            var multiring = true;
            var multipoly = true;
            if (Array.isArray(coords[0])) {
                if (Array.isArray(coords[0][0])) {
                    if (!Array.isArray(coords[0][0][0])) {
                        multipoly = false;
                        coords = [coords];
                    }
                }
                else {
                    multiring = false;
                    coords = [[coords]];
                }
            }
            else {
                multipoint = false;
                multiring = false;
                multipoly = false;
                coords = [[[coords]]];
            }
            TC.loadProjDef({ crs: sourceCrs, sync: true });
            TC.loadProjDef({ crs: targetCrs, sync: true });
            var sourcePrj = proj4(proj4.defs[sourceCrs]);
            var targetPrj = proj4(proj4.defs[targetCrs]);
            result = new Array(coords.length);
            coords.forEach(function (poly, pidx) {
                const rp = result[pidx] = [];
                poly.forEach(function (ring, ridx) {
                    const rr = rp[ridx] = [];
                    ring.forEach(function (coord, cidx) {
                        var point = proj4(sourcePrj, targetPrj, { x: coord[0], y: coord[1] });
                        rr[cidx] = [point.x, point.y];
                        if (coord.length > 2) {
                            rr[cidx][2] = coord[2];
                        }
                    });
                });
            });
            if (!multipoint) {
                result = result[0][0][0];
            }
            else if (!multiring) {
                result = result[0][0];
            }
            else if (!multipoly) {
                result = result[0];
            }
            return result;
        },

        getMetersPerDegree: function (extent) {
            var result = undefined;
            var R = 6370997; // m
            var toRad = function (number) {
                return number * Math.PI / 180;
            };
            if (Array.isArray(extent) && extent.length >= 4) {
                var dLat = this.degToRad(extent[3] - extent[1]);
                var sindlat2 = Math.sin(dLat / 2);
                var a = sindlat2 * sindlat2;
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                result = R * c / (extent[3] - extent[1]);
            }
            return result;
        },

        radToDeg: function (rad) { // convert radians to degrees
            return rad * 180 / Math.PI;
        },
        degToRad: function (deg) { // convert degrees to radians
            return deg * Math.PI / 180;
        },
        mod: function (n) { // modulo for negative values
            return ((n % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        },

        getCRSCode: function (crs) {
            var result = null;
            crs = crs.trim();
            if (/^EPSG:\d{4,6}$/g.test(crs) || //formato EPSG
                /^urn:ogc:def:crs:EPSG:.*:\d{4,6}/g.test(crs) || // formato URN
                /http:\/\/www.opengis.net\/gml\/srs\/epsg.xml#\d{4,6}$/g.test(crs)) { // formato GML
                var match = crs.trim().match(/^.+[:#](\d{4,6})$/); // devuelve la parte numérica del código
                if (match) {
                    result = match[1];
                }
            }
            return result;
        },

        CRSCodesEqual: function (crs1, crs2) {
            if (crs1 === crs2) {
                return true;
            }
            var code1 = this.getCRSCode(crs1);
            var code2 = this.getCRSCode(crs2);
            return code1 !== null && code2 !== null && code1 === code2;
        },

        getLocaleString: function (locale, key, texts) {
            var result = key;
            if (TC.i18n && TC.i18n[locale]) {
                var text = TC.i18n[locale][key];
                if (text) {
                    result = text;
                    if (texts) {
                        for (var k in texts) {
                            result = result.replace('{' + k + '}', texts[k]);
                        }
                    }
                }
            }
            return result;
        },

        getSimpleMimeType: function (mimeType) {
            var result = '';
            if (mimeType) {
                var end = mimeType.indexOf(';');
                if (end > 0) {
                    mimeType = mimeType.substring(0, end);
                }
                result = mimeType;
            }
            return result;
        },

        getQueryStringParams: function (url) {
            var queryString;
            if (url) {
                var queryIdx = url.indexOf('?');
                if (queryIdx >= 0) {
                    queryString = url.substr(queryIdx);
                    var fragmentIdx = queryString.indexOf('#');
                    if (fragmentIdx >= 0) {
                        queryString = queryString.substr(0, fragmentIdx)
                    }
                }
                else {
                    queryString = '?';
                }
            }
            else {
                queryString = location.search;
            }
            var result = queryString.replace(/(^\?)/, '').split("&").map(function (elm) {
                return elm = elm.split("="), this[elm[0]] = elm[1], this
            }.bind({}))[0];
            delete result[''];
            return result;
        },

        getParamString: function (obj) {
            const arr = [];
            for (var key in obj) {
                arr[arr.length] = encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]);
            }
            return arr.join('&').replace(/%20/g, '+');
        },

        fastUnshift: function (a, elm) {
            var len = a.length;
            while (len) {
                a[len] = a[len - 1];
                len--;
            }
            a[0] = elm;
        },

        storage: {
            getCookie: function (key) {
                return TC.cookie(key);
            },
            setCookie: function (key, value, options) {
                return TC.cookie(key, value, options);
            },
            getLocalValue: function (key) {
                var result = null;
                if (localStorage && localStorage instanceof Storage) {
                    result = localStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setLocalValue: function (key, value) {
                if (localStorage && localStorage instanceof Storage) {
                    if (value === undefined) {
                        localStorage.removeItem(key);
                    }
                    else {
                        localStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            },
            getSessionLocalValue: function (key) {
                var result = null;
                if (sessionStorage && sessionStorage instanceof Storage) {
                    result = sessionStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setSessionLocalValue: function (key, value) {
                if (sessionStorage && sessionStorage instanceof Storage) {
                    if (value === undefined) {
                        sessionStorage.removeItem(key);
                    }
                    else {
                        sessionStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            }
        },
        detectFirefox: function () {
            if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent)) //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);
                return new Number(RegExp.$1); // capture x.x portion and store as a number
            else
                return false;
        },
        detectIE: function () {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            // GLS: 13/02/2019. Comento lo que respecta a Edge, no tiene sentido meterlo en el mismo saco que un navegador obsoleto.
            // No lo comento porque en la mesa no hay quorum.
            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // IE 12 => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },
        detectChrome: function () {
            return window.chrome;

        },
        detectSafari: function () {
            return !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);
        },
        detectMouse: function () {
            const matchesCoarse = matchMedia('(pointer:coarse)').matches;
            const matchesFine = matchMedia('(pointer:fine)').matches;
            if (matchesCoarse && matchesFine) {
                return true;
            }
            if (matchesCoarse && !matchesFine) {
                var testHover = function () {
                    //console.log('estamos en testHover');
                    var mq = '(hover: hover)',
                        hover = !TC.browserFeatures.touch(), // fallback if mq4 not supported: no hover for touch
                        mqResult;

                    mqResult = window.matchMedia(mq);
                    //console.log('resultado de window.matchMedia(mq): ' + mqResult.media);
                    //console.log('mq: ' + mq);
                    if (mqResult.media === mq) {
                        //console.log('es igual');
                        // matchMedia supports hover detection, so we rely on that
                        hover = mqResult.matches;
                        //console.log('va retornar: ' + hover);
                    }

                    return hover;
                };

                if (testHover())
                    return true;
                else return false;
            }
            if (!matchesCoarse && matchesFine) {
                return true;
            }
            if (matchMedia('(pointer:none)').matches) {
                return false;
            }
            if (!TC.browserFeatures.touch()) {
                return true;
            }
        },
        detectAndroid: function () {
            return navigator.userAgent.match(/Android/i);
        },
        detectBlackBerry: function () {
            return navigator.userAgent.match(/BlackBerry/i);
        },
        detectIOS: function () {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        detectMobileWindows: function () {
            return navigator.userAgent.match(/IEMobile/i);
        },
        detectMobile: function () {
            return (TC.Util.detectAndroid() || TC.Util.detectIOS() || TC.Util.detectMobileWindows() || TC.Util.detectBlackBerry());
        },
        getBrowser: function () {
            if (!window.UAParser) {
                TC.syncLoadJS(TC.apiLocation + TC.Consts.url.UA_PARSER);
            }

            var parser = new UAParser();
            var browser = parser.getBrowser();
            return { name: browser.name, version: browser.major };
        },
        getElementByNodeName: function (parentNode, nodeName) {
            var colonIndex = nodeName.indexOf(":");
            var tag = nodeName.substr(colonIndex + 1);
            var nodes = parentNode.getElementsByTagNameNS("*", tag);

            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeName == nodeName)
                    return nodes;
            }
            return undefined;
        },
        addURLParameters: function (url, parameters) {
            if (!parameters) {
                return url;
            }
            var toAdd = Object.keys(parameters).map(function (key) {
                return encodeURIComponent(key) + '=' + (parameters[key] ? encodeURIComponent(parameters[key]) : '');
            }).join('&');

            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var params = urlparts[1].split(/[&;]/g);
                params.push(toAdd);

                url = urlparts[0] + '?' + params.join('&');
                return url;
            } else {
                urlparts = url.split('#');
                if (urlparts.length >= 2) {
                    urlparts.shift();
                    url = urlparts[0] + '?' + toAdd + '#' + urlparts.join('#');
                    return url;
                }
                else {
                    url = url + '?' + toAdd;
                    return url;
                }
            }
        },
        removeURLParameter: function (url, parameter) {
            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var prefix = encodeURIComponent(parameter.toLowerCase()) + '=';
                var pars = urlparts[1].toLowerCase().split(/[&;]/g);

                //reverse iteration as may be destructive
                for (var i = pars.length; i-- > 0;) {
                    //idiom for string.startsWith
                    if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                        pars.splice(i, 1);
                    }
                }

                url = urlparts[0] + '?' + pars.join('&');
                return url;
            } else {
                return url;
            }
        },

        showModal: function (contentNode, options) {
            options = options || {};

            contentNode.hidden = false;
            if (window.$ && contentNode instanceof $) {
                contentNode = contentNode.get(0);
            }
            contentNode.classList.add(TC.Consts.classes.VISIBLE);
            const closeButton = contentNode.querySelectorAll('.tc-modal-close');
            if (closeButton && closeButton.length > 0) {
                for (var i = 0; i < closeButton.length; i++) {
                    var closeCallback = modalCloseHandlers.get(closeButton[i]);
                    if (closeCallback) {
                        modalCloseHandlers.delete(closeButton[i]);
                    }
                    else {
                        closeCallback = function (e) {
                            e.stopPropagation();
                            return TC.Util.closeModal(options.closeCallback, e.target);
                        };
                        modalCloseHandlers.set(closeButton[i], closeCallback);
                    }
                    modalCloseHandlers.set(closeButton[i], closeCallback);
                    closeButton[i].addEventListener('click', closeCallback);
                    if (Util.isFunction(options.openCallback)) {
                        options.openCallback();
                    }
                }
            }
        },

        closeModal: function (callback, target) {

            const hide = function (modal) {
                modal.classList.remove(TC.Consts.classes.VISIBLE);
            };

            var modal;
            if (target) {
                modal = target;
                while (modal && !modal.matches('.tc-modal')) {
                    modal = modal.parentElement;
                }

                hide(modal);
            } else {
                Array.prototype.forEach.call(document.querySelectorAll('.tc-modal'), function (modal) {
                    hide(modal);
                });
            }

            if (callback) {
                callback();
            }
        },

        closeAlert: function (btn) {
            var elm = btn;
            do {
                elm = elm.parentElement;
                if (elm.matches('.tc-alert')) {
                    elm.style.display = 'none';
                }
            }
            while (elm);
        },

        swipe: function (target, options) {
            const addListeners = function (handlers) {
                target.addEventListener('mousedown', handlers.start);
                target.addEventListener('touchstart', handlers.start);
                target.addEventListener('mouseup', handlers.end);
                target.addEventListener('touchend', handlers.end);
            };

            if (options === 'disable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    target.removeEventListener('mousedown', handlers.start);
                    target.removeEventListener('touchstart', handlers.start);
                    target.removeEventListener('mouseup', handlers.end);
                    target.removeEventListener('touchend', handlers.end);
                }
                return;
            }
            else if (options === 'enable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    addListeners(handlers);
                }
                return;
            }

            options = options || {};
            const minDistance = options.minDistance || 30;
            const maxCrossDistance = options.maxCrossDistance || 30;
            const maxAllowedTime = options.maxAllowedTime || 1000;
            var touchStartCoords = { 'x': -1, 'y': -1 }, // X and Y coordinates on mousedown or touchstart events.
                touchEndCoords = { 'x': -1, 'y': -1 },// X and Y coordinates on mouseup or touchend events.
                startTime = 0,// Time on swipeStart
                elapsedTime = 0;// Elapsed time between swipeStart and swipeEnd

            const getDirection = function (startCoords, endCoords) {
                const dx = endCoords.x - startCoords.x;
                const dy = endCoords.y - startCoords.y;
                const adx = Math.abs(dx);
                const ady = Math.abs(dy);
                if (adx > ady && adx > minDistance && ady <= maxCrossDistance) {
                    return dx < 0 ? 'left' : 'right';
                }
                if (ady > adx && ady > minDistance && adx <= maxCrossDistance) {
                    return dy < 0 ? 'up' : 'down';
                }
                return 'none';
            };

            const mustSwipe = function (e) {
                if (options.noSwipe) {
                    var elm = e.target;
                    while (elm && elm !== target) {
                        if (elm.matches && elm.matches(options.noSwipe)) {
                            return false;
                        }
                        elm = elm.parentNode;
                    }
                }
                return true;
            };

            const swipeStart = function (e) {
                if (mustSwipe(e)) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchStartCoords.x = e.pageX;
                    touchStartCoords.y = e.pageY;
                    startTime = new Date().getTime();
                }
            };

            const swipeEnd = function (e) {
                if (startTime) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchEndCoords.x = e.pageX;
                    touchEndCoords.y = e.pageY;
                    elapsedTime = new Date().getTime() - startTime;
                    if (elapsedTime <= maxAllowedTime) {
                        const callback = options[getDirection(touchStartCoords, touchEndCoords)];
                        if (callback) {
                            callback.call(target);
                        }
                    }
                    startTime = 0;
                }
            };

            const handlers = {
                start: swipeStart,
                end: swipeEnd
            };
            swipeHandlers.set(target, handlers);
            addListeners(handlers);
        },

        getParameterByName: function (name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)", "i"),
                results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        },

        getLocaleUserChoice: function (options) {
            var result = 'en-US';
            options = options || {};
            var cookieName = options.cookieName || 'SITNA.language';
            var paramName = options.paramName || 'lang';
            // Obtenemos preferencia de lenguaje
            var browserLanguage = (navigator.languages && navigator.languages.length) ? navigator.languages[0] : navigator.language || navigator.userLanguage;
            var lang = TC.Util.getParameterByName(paramName) || TC.Util.storage.getCookie(cookieName) || browserLanguage;
            var hyphenIdx = lang.indexOf('-');
            if (hyphenIdx >= 0) {
                lang = lang.substr(0, hyphenIdx);
            }
            var expirationDate = new Date(new Date().getTime() + 365 * 24 * 60 * 60 * 1000);
            TC.Util.storage.setCookie(cookieName, lang, { expires: expirationDate });

            switch (lang) {
                case 'eu':
                    result = 'eu-ES';
                    break;
                case 'es':
                    result = 'es-ES';
                    break;
                default:
                    result = 'en-US';
                    break;
            }
            return result;
        },

        getValidFilename: function (filename) {
            return (filename || '').replace(/[/\\?%*:|"<>]/g, '-');
        },

        downloadBlob: function (filename, blob) {
            var link = document.createElement("a");
            if (link.download !== undefined) {
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", TC.Util.getValidFilename(filename));
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        downloadFile: function (filename, type, data) {
            var blob = new Blob([data], { type: type });
            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        downloadDataURI: function (filename, type, dataURI) {
            var binary = atob(dataURI.split(',')[1]);

            var array = [];
            for (var i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            var blob = new Blob([new Uint8Array(array)], { type: type });

            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        /**
         * Acorta una URL utilizando el servicio de Bit.ly. No funciona para URLs locales.
         */
        shortenUrl: function (url) {
            return new Promise(function (resolve, reject) {
                TC.ajax({
                    url: "https://api-ssl.bitly.com/v3/shorten",
                    data: { access_token: "6c466047309f44bd8173d83e81491648b243ee3d", longUrl: url },
                })
                    .then(function (response) {
                        resolve(response.data);
                    })
                    .catch(function (e) {
                        reject(e);
                    });
            });
        },

        /**
         * Convierte a Base64.
         */
        utf8ToBase64: function (str) {
            return window.btoa(unescape(encodeURIComponent(str)));
        },

        /**
         * Decodifica un string en Base64.
         */
        base64ToUtf8: function (str) {
            var result;
            try {
                result = decodeURIComponent(escape(window.atob(str)));
            }
            catch (error) {
                result = null;
            }
            return result;
        },

        colorArrayToString: function (color) {
            if (Array.isArray(color)) {
                color = color
                    .slice(0, 3)
                    .reduce(function (prev, cur) {
                        const str = cur.toString(16);
                        return prev + '00'.substring(0, 2 - str.length) + str;
                    }, '#');
            }
            return color;
        },

        // Generic helper function that can be used for the three operations:        
        operation: function (list1, list2, comparerFn, operationIsUnion) {
            var result = [];

            for (var i = 0; i < list1.length; i++) {
                var item1 = list1[i],
                    found = false;
                for (var j = 0; j < list2.length; j++) {
                    if (comparerFn(item1, list2[j])) {
                        found = true;
                        break;
                    }
                }
                if (found === operationIsUnion) {
                    result.push(item1);
                }
            }
            return result;
        },
        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        // Following functions are to be used:
        inBoth: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, true);
        },

        inFirstOnly: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, false);
        },

        inSecondOnly: function (list1, list2, comparerFn) {
            return this.inFirstOnly(list2, list1, comparerFn);
        },

        toDataUrl: function (canvas, backgroundColour) {
            var defaultOptions = { type: 'image/png', encoderOptions: 0.92 };

            var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions,
                type = _ref.type,
                encoderOptions = _ref.encoderOptions;

            var context = canvas.getContext('2d');

            if (!context) {
                return '';
            }

            var width = canvas.width;
            var height = canvas.height;

            var data = context.getImageData(0, 0, width, height);
            var compositeOperation = context.globalCompositeOperation;

            if (backgroundColour) {

                context.globalCompositeOperation = 'destination-over';
                context.fillStyle = backgroundColour;
                context.fillRect(0, 0, width, height);
            }

            var imageData = canvas.toDataURL(type, encoderOptions);

            if (backgroundColour) {
                context.clearRect(0, 0, width, height);
                context.putImageData(data, 0, 0);
                context.globalCompositeOperation = compositeOperation;
            }

            return imageData;
        },

        imgToDataUrl: function (src, outputFormat) {

            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function () {
                    var canvas = createCanvas(img);
                    var dataURL;

                    try {
                        dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                            type: outputFormat || 'image/jpeg',
                            encoderOptions: 1.0
                        });
                        resolve({ dataUrl: dataURL, canvas: canvas });
                    } catch (error) {
                        img.src = TC.proxify(src);
                    }
                };

                img.onerror = function (error) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', TC.proxify(src), true);
                    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function (e) {
                        if (this.status === 200) {
                            var uInt8Array = new Uint8Array(this.response);
                            var i = uInt8Array.length;
                            var binaryString = new Array(i);
                            while (i--) {
                                binaryString[i] = String.fromCharCode(uInt8Array[i]);
                            }
                            var data = binaryString.join('');
                            var type = xhr.getResponseHeader('content-type');
                            if (type.indexOf('image') === 0) {
                                img.src = 'data:' + type + ';base64,' + window.btoa(data);
                                img.onload = function () {
                                    var canvas = createCanvas(img);
                                    dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                                        type: outputFormat || 'image/jpeg',
                                        encoderOptions: 1.0
                                    });
                                    resolve({ dataUrl: dataURL, canvas: canvas });
                                }
                            }
                        }
                    };
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4) {
                            if (xhr.status !== 200) {
                                reject();
                            }
                        }
                    };

                    xhr.send();
                };

                img.src = src;
                if (img.complete || img.complete === undefined) {
                    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                    img.src = src;
                }
            });
        },

        imgTagToDataUrl: function (img, outputFormat) {
            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            var canvas = createCanvas(img);
            var dataURL;

            try {
                dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                    type: outputFormat || 'image/jpeg',
                    encoderOptions: 1.0
                });
                return { base64: dataURL, canvas: canvas };
            } catch (error) {
                return null;
            }
        },

        addToCanvas: function (canvas, img, position, size) {
            var newCanvas = TC.Util.cloneCanvas(canvas);
            var context = newCanvas.getContext('2d');

            return new Promise(function (resolve, reject) {
                var newImage = new Image();
                img.crossOrigin = 'anonymous';
                newImage.src = img;
                newImage.onload = function () {
                    if (size) {
                        context.drawImage(newImage, position.x || 0, position.y || 0, size.width, size.height);
                    } else {
                        context.drawImage(newImage, position.x || 0, position.y || 0);
                    }
                    resolve(newCanvas);
                }
            });
        },

        cloneCanvas: function (oldCanvas) {
            //create a new canvas
            var newCanvas = document.createElement('canvas');
            var context = newCanvas.getContext('2d');

            //set dimensions
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;

            //apply the old canvas to the new one
            context.drawImage(oldCanvas, 0, 0);

            //return the new canvas
            return newCanvas;
        },

        calculateAspectRatioFit: function (srcWidth, srcHeight, maxWidth, maxHeight) {
            var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);

            return { width: srcWidth * ratio, height: srcHeight * ratio };
        },

        getFormattedDate: function (date, hasTime) {
            function pad(s) { return (s < 10) ? '0' + s : s; }

            var d = new Date(date);
            return [d.getFullYear(), pad(d.getMonth() + 1), pad(d.getDate())].concat(hasTime ? ["_", pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())] : []).join('');

        },

        replaceAccent: function (t) {
            var translate = {
                "ä": "a", "ö": "o", "ü": "u",
                "Ä": "A", "Ö": "O", "Ü": "U",
                "á": "a", "é": "e", "i": "i", "ó": "o", "ú": "u",
                "Á": "A", "É": "E", "Í": "I", "Ó": "O", "Ú": "U",
                "ñ": "n", "Ñ": "N"
            };
            return t.replace(/[öäüÖÄÜáéíóúÁÉÍÓÚñÑ]/g, function (match) {
                return translate[match];
            });
        },

        downloadFileForm: function (url, data) {
            var download = function (url, data) {

                new Promise(function (resolve, reject) {
                    const request = new XMLHttpRequest();
                    request.responseType = "blob";
                    request.open("POST", url);
                    request.setRequestHeader('Content-Type', 'application/xml; charset=UTF-8');

                    request.onreadystatechange = function (e) {
                        if (request.readyState === 4) { // DONE
                            if (request.status !== 200) {
                                reject({
                                    status: request.status,
                                    msg: request.statusText,
                                    url: options.url
                                });
                            } else {

                                try {
                                    //URI: Miro si devuelve una cabecera content-disposition attachment. Si es asi uso el filenae como nombre de fichero. Esta descarga seguramente venga
                                    //de un proxy con postproceso de zippeado
                                    const contentDispositionHeader = request.getResponseHeader("Content-disposition");
                                    var filename = "";
                                    if (contentDispositionHeader) {
                                        filename = contentDispositionHeader.split("; ")[1].substring(9);
                                        if (contentDispositionHeader.split("; ")[0] !== "attachment") {
                                            filename = filename.substring(0, filename.lastIndexOf("."));
                                        }
                                    }
                                    resolve({ data: request.response, contentType: request.getResponseHeader("Content-type"), filename: filename });
                                }
                                catch (error) {
                                    reject(error);
                                }
                            }
                        }
                    };

                    try {
                        request.send(data);
                    } catch (error) {
                        reject(error);
                    }
                }).then(function (response) {
                    var format = "";
                    if (response.data.type.indexOf("kml") >= 0)
                        format = ".kml";
                    else if (response.data.type.indexOf("json") >= 0)
                        format = ".geojson";
                    else if (response.data.type.indexOf("xml") >= 0)
                        format = ".gml";
                    TC.Util.downloadFile((response.filename ? response.filename : TC.getUID()) + format, response.contentType, response.data)
                });
            };            
            var htmlObj = [];
            if (Array.isArray(url)) {
                var arrDownloads = url;
                for (var i = 0; i < arrDownloads.length; i++) {
                    download(arrDownloads[i].url, arrDownloads[i].data);
                }
            }
            else {
                download(url, data);
            }            
        },

        WFSQueryBuilder: function (layers, filter, capabilities, outputFormat, onlyHits, srsName) {
            const getSRSAttribute = function () {                
                if (srsName) {
                    return ' srsName="' + srsName +'"'
                }
                else
                    return '';
            }
            if (!Array.isArray(layers))
                layers = [layers];
            var queryHeader = 'xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd" ' +
                'xmlns:ogc="http://www.opengis.net/ogc" service="WFS" {resultType} {format} ';
            switch (capabilities.version) {
                case "1.0.0":
                case "1.1.0":
                    queryHeader += 'xmlns:gml="http://www.opengis.net/gml" xmlns:wfs="http://www.opengis.net/wfs" ';
                    break;
                case "2.0.0":
                    queryHeader += 'xmlns:wfs=\"http://www.opengis.net/wfs/2.0\" xmlns:gml=\"http://www.opengis.net/gml/3.2\" ';
                    break;
            }
            for (var i in capabilities) {
                if (typeof (capabilities[i]) === "string" && i.indexOf("gml") < 0 && capabilities[i].indexOf("wfs") < 0)
                    queryHeader += (i + '="' + capabilities[i] + '" ');
            }

            var query = '<wfs:GetFeature ' + queryHeader.format({ resultType: (onlyHits ? 'resultType="hits"' : ''), format: 'outputFormat="' + outputFormat + '"' }) + '>';
            var queryBody = '';

            var queryItem = '<wfs:Query typeName' + (capabilities.version === "2.0.0" ? 's' : '') + '="{typeName}"' + getSRSAttribute() + '>{filter}</wfs:Query>';
            layers.forEach(function (value) {
                queryBody += queryItem.format({ typeName: value, filter: (filter ? filter.getText(capabilities.version) : "") });
            });
            query += queryBody + '</wfs:GetFeature>'
            return query;
        },

        WFSFilterBuilder: function (feature, version, srsName) {
            var filter = '';
            if (Util.isPlainObject(feature)) {
                filter = '<{prefix}:Filter><{prefix}:Intersects><fes:ValueReference></fes:ValueReference><{prefix}:Function name="querySingle"><{prefix}:Literal>{clipLayer}</{prefix}:Literal><{prefix}:Literal>{geometryName}</{prefix}:Literal><{prefix}:Literal>{where}</{prefix}:Literal></{prefix}:Function></{prefix}:Intersects></{prefix}:Filter>'
                    .format({ prefix: (version === "2.0.0" ? "fes" : "ogc"), "clipLayer": feature.clipLayer, "geometryName": feature.geometryName, "where": feature.where })
            }
            else {
                switch (true) {
                    case !feature:
                        break;
                    case Array.isArray(feature)://bbox
                        var gmlEnvelope = ('<gml:Envelope>' +
                            '<gml:lowerCorner>{lowerCorner}</gml:lowerCorner>' +
                            '<gml:upperCorner>{upperCorner}</gml:upperCorner>' +
                            '</gml:Envelope>').format({ lowerCorner: (feature[0] + ' ' + feature[1]), upperCorner: (feature[2] + ' ' + feature[3]) });
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:BBOX>' + gmlEnvelope + '</ogc:BBOX></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:BBOX>' + gmlEnvelope + '</fes:BBOX></fes:Filter>';
                                break;
                        }
                        break;
                    case feature instanceof TC.Feature:
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:Intersects><ogc:PropertyName></ogc:PropertyName>' + TC.Util.writeGMLGeometry(feature, { version: "2.0", srsName: srsName  }) + '</ogc:Intersects></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:Intersects><fes:ValueReference></fes:ValueReference>' + TC.Util.writeGMLGeometry(feature, { version: "3.2", srsName: srsName }) + '</fes:Intersects></fes:Filter>';
                                break;
                        }

                        break;
                    default:
                        TC.error("Geometr\u00eda no v\u00e1lida");
                        break;
                }
            }

            return filter;
        },

        writeGMLGeometry: function (feature, options) {
            options = options || {};
            const gmlVersion = options.version;
            const getSRSName = function () {
                if (options.srsName) {
                    return ' srsName="' + options.srsName + '"'
                }
                else
                    return '';
            };
            var getGmlCoordinates = function (coords) {
                var result;
                if (gmlVersion.indexOf('3') === 0) {
                    result = coords.toString();
                    while (result.indexOf(",") >= 0) {
                        result = result.replace(",", " ");
                    }
                }
                else {
                    result = coords.map(function (coord) {
                        return coord.join(',');
                    }).join(' ');
                }
                return result;
            };

            switch (gmlVersion) {
                case "3.1.1":
                    break;
                case "3.2":
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString srsDimension=\"2\"" + getSRSName()+"><gml:posList>" +
                                getGmlCoordinates(feature.geometry) +
                                "</gml:posList></gml:LineString>";
                            break;
                            break;
                        default:
                            return "<gml:Polygon srsDimension=\"2\"" + getSRSName() +"><gml:exterior><gml:LinearRing><gml:posList>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>";
                            break;
                    }
                    break;
                case "2.0":
                default:
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString" + getSRSName() +"><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LineString>";
                            break;
                        default:
                            return "<gml:Polygon" + getSRSName() +"><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>";
                            break;
                    }
                    break;
            }
        },

        isServiceWorker: function () {
            if (navigator.serviceWorker) {
                if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        },

        isSameOriginByLocation: function (uri, location) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var uProtocol = urlParts[1];
                result = (uProtocol == location.protocol || uProtocol == undefined) && urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        isSameProtocol: function (uri, location) {
            if (uri.match(/^(\/\/)/i)) {
                return true;
            }
            var protocolRegex = /^(https?:\/\/)/i;
            var uriProtocol = uri.match(protocolRegex);
            if (uriProtocol && uriProtocol.length > 1) {
                var locationProtocol = location.match(protocolRegex);
                if (locationProtocol && locationProtocol.length > 1) {
                    return uriProtocol[0].trim() === locationProtocol[0].trim();
                }
            }

            return false;
        },

        consoleRegister: function (msg) {
            if (TC.isDebug) {
                console.log(msg);
            }
        },

        getSorterByProperty: function (propName) {
            return function (a, b) {
                if (a[propName] > b[propName]) {
                    return 1;
                }
                if (a[propName] < b[propName]) {
                    return -1;
                }
                return 0;
            };
        },

        getSoundexDifference: function (a, b) {
            var res = 0

            for (var i = 0; i < a.length; i++) {
                if (a.charAt(i) == b.charAt(i)) {
                    res++;
                }
            }

            return res;
        },

        toAbsolutePath: function (href) {
            var link = document.createElement("a");
            link.href = href;
            return link.href;
        },

        getRenderedHtml: function (templateId, template, data, callback) {
            return new Promise(function (resolve, reject) {
                var render = function () {
                    if (dust.cache[templateId]) {
                        dust.render(templateId, data, function (err, out) {
                            if (err) {
                                TC.error(err);
                                reject(Error(err));
                            }
                            else {
                                if (Util.isFunction(callback)) {
                                    callback(out);
                                }
                                resolve(out);
                            }
                        });
                    }
                };
                TC.loadJSInOrder(
                    !window.dust,
                    TC.url.templating,
                    function () {
                        if (!dust.cache[templateId]) {
                            if (typeof template === 'string') {
                                TC.ajax({
                                    url: template,
                                    method: "GET",
                                    responseType: 'text'
                                })
                                    .then(function (response) {
                                        const html = response.data;
                                        var tpl = dust.compile(html, templateId);
                                        dust.loadSource(tpl);
                                        render();
                                    })
                                    .catch(function (err) {
                                        console.log("Error fetching template: " + err)
                                    });
                            }
                            else if (Util.isFunction(template)) {
                                template();
                                render();
                            }
                        }
                        else {
                            render();
                        }
                    }
                );
            });
        },

        explodeGeometry: function (obj) {
            const origin = obj.origin;
            const iterationFunction = function (elm, idx, arr) {
                if (Array.isArray(elm)) {
                    elm.forEach(iterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = elm + origin[0];
                    }
                    if (idx === 1) {
                        arr[1] = elm + origin[1];
                    }
                }
            };
            obj.geom.forEach(iterationFunction);
            return obj.geom;
        },

        cloneMappingFunction: function (elm) {
            if (Array.isArray(elm)) {
                return elm.map(TC.Util.cloneMappingFunction);
            }
            return elm;
        },

        compactGeometry: function (geometry, precision) {
            const origin = [Number.MAX_VALUE, Number.MAX_VALUE];
            const newGeom = geometry.map(TC.Util.cloneMappingFunction);
            const firstIterationFunction = function (elm, idx) {
                if (Array.isArray(elm)) {
                    elm.forEach(firstIterationFunction);
                }
                else {
                    if (idx === 0 && elm < origin[0]) {
                        origin[0] = elm;
                    }
                    else if (idx === 1 && elm < origin[1]) {
                        origin[1] = elm;
                    }
                }
            };
            newGeom.forEach(firstIterationFunction);

            const round = function (val) {
                return Math.round(val * precision) / precision;
            }
            origin[0] = round(origin[0]);
            origin[1] = round(origin[1]);
            const secondIterationFunction = function (elm, idx, arr) {
                if (Array.isArray(elm)) {
                    elm.forEach(secondIterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = round(elm - origin[0]);
                    }
                    if (idx === 1) {
                        arr[1] = round(elm - origin[1]);
                    }
                }
            };
            newGeom.forEach(secondIterationFunction);
            return {
                origin: origin,
                geom: newGeom
            }
        }
    };
    String.prototype.format = function () {
        var str = this.toString();
        if (!arguments.length)
            return str;
        var args = typeof arguments[0],
            args = (("string" == args || "number" == args) ? arguments : arguments[0]);
        for (arg in args)
            str = str.replace(RegExp("\\{" + arg + "\\}", "gi"), args[arg]);
        return str;
    };
    var fncOvelaps = function (elem1, elem2,comparisonFnc) {        
        return comparisonFnc(elem1.getBoundingClientRect(), elem2.getBoundingClientRect());
    }
    if (this.HTMLElement) {
        HTMLElement.prototype.colliding = function (other) {
            return fncOvelaps(this, other, function (rect1, rect2) {
                return !(
                    rect1.top > rect2.bottom ||
                    rect1.right < rect2.left ||
                    rect1.bottom < rect2.top ||
                    rect1.left > rect2.right
                );
            });
        };
        HTMLElement.prototype.containing = function (other) {
            fncOvelaps(this, other, function (rect1, rect2) {
                return !(
                    rect1.left <= rect2.left &&
                    rect2.left < rect1.width &&
                    rect1.top <= rect2.top &&
                    rect2.top < rect1.height
                );
            });
        };
        HTMLElement.prototype.inside = function (other) {
            return fncOvelaps(this, other, function (rect1, rect2) {
                return (
                    ((rect2.top <= rect1.top) && (rect1.top <= rect2.bottom)) &&
                    ((rect2.top <= rect1.bottom) && (rect1.bottom <= rect2.bottom)) &&
                    ((rect2.left <= rect1.left) && (rect1.left <= rect2.right)) &&
                    ((rect2.left <= rect1.right) && (rect1.right <= rect2.right))
                );
            });
        };
    }
    return Util;
});

/**
 * LoadJS descargado de https://github.com/muicss/loadjs
 * @version 3.5.2
 */
loadjs = function () { var l = function () { }, c = {}, f = {}, u = {}; function o(e, n) { if (e) { var t = u[e]; if (f[e] = n, t) for (; t.length;)t[0](e, n), t.splice(0, 1) } } function s(e, n) { e.call && (e = { success: e }), n.length ? (e.error || l)(n) : (e.success || l)(e) } function h(t, r, i, c) { var o, s, e = document, n = i.async, f = (i.numRetries || 0) + 1, u = i.before || l, a = t.replace(/^(css|img)!/, ""); c = c || 0, /(^css!|\.css$)/.test(t) ? (o = !0, (s = e.createElement("link")).rel = "stylesheet", s.href = a) : /(^img!|\.(png|gif|jpg|svg)$)/.test(t) ? (s = e.createElement("img")).src = a : ((s = e.createElement("script")).src = t, s.async = void 0 === n || n), !(s.onload = s.onerror = s.onbeforeload = function (e) { var n = e.type[0]; if (o && "hideFocus" in s) try { s.sheet.cssText.length || (n = "e") } catch (e) { 18 != e.code && (n = "e") } if ("e" == n && (c += 1) < f) return h(t, r, i, c); r(t, n, e.defaultPrevented) }) !== u(t, s) && e.head.appendChild(s) } function t(e, n, t) { var r, i; if (n && n.trim && (r = n), i = (r ? t : n) || {}, r) { if (r in c) throw "LoadJS"; c[r] = !0 } !function (e, r, n) { var t, i, c = (e = e.push ? e : [e]).length, o = c, s = []; for (t = function (e, n, t) { if ("e" == n && s.push(e), "b" == n) { if (!t) return; s.push(e) } --c || r(s) }, i = 0; i < o; i++)h(e[i], t, n) }(e, function (e) { s(i, e), o(r, e) }, i) } return t.ready = function (e, n) { return function (e, t) { e = e.push ? e : [e]; var n, r, i, c = [], o = e.length, s = o; for (n = function (e, n) { n.length && c.push(e), --s || t(c) }; o--;)r = e[o], (i = f[r]) ? n(r, i) : (u[r] = u[r] || []).push(n) }(e, function (e) { s(n, e) }), t }, t.done = function (e) { o(e, []) }, t.reset = function () { c = {}, f = {}, u = {} }, t.isDefined = function (e) { return e in c }, t }();

var TC = TC || {};
/*
 * Initialization
 */
TC.version = '2.0.0 [2019-10-4 14:25:49]';
(function () {
    if (!TC.apiLocation) {
        var src;
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
    }
})();

if (!TC.Consts) {
    TC.Consts = {};
    TC.Consts.OLNS = 'ol';
    TC.Consts.PROJ4JSOBJ = 'proj4';
    TC.Consts.GEOGRAPHIC = 'geographic';
    TC.Consts.UTM = 'UTM';
    TC.Consts.OLD_BROWSER_ALERT = 'TC.oldBrowserAlert';
    TC.Consts.CLUSTER_ANIMATION_DURATION = 200;
    TC.Consts.ZOOM_ANIMATION_DURATION = 300;
    TC.Consts.URL_MAX_LENGTH = 2048;
    TC.Consts.METER_PRECISION = 0;
    TC.Consts.DEGREE_PRECISION = 5;
    TC.Consts.EXTENT_TOLERANCE = 0.9998;/*URI: debido al redondeo del extente en el hash se obtiene un nivel de resolución mayor al debido. Con este valor definimos una tolerancia para que use una resolución si es muy muy muy próxima*/
    TC.Consts.SRSDOWNLOAD_GEOJSON_KML = "EPSG:4326";
    TC.Consts.url = {
        SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
        OL: 'lib/ol/build/ol-sitna',
        OL_CONNECTOR: 'TC/ol/ol',
        TEMPLATING: 'lib/dust/dust-full-helpers.min.js',
        TEMPLATING_I18N: 'lib/dust/dustjs-i18n.min.js',
        TEMPLATING_OVERRIDES: 'lib/dust/dust.overrides.js',
        PROJ4JS: 'lib/proj4js/proj4-src.js',
        EPSG: 'https://epsg.io/',
        LOCALFORAGE: TC.apiLocation + 'lib/localForage/localforage.min.js',
        D3C3: TC.apiLocation + 'lib/d3c3/d3c3.min.js',
        CESIUM: TC.apiLocation + 'lib/cesium/release/Cesium.js',
        JSNLOG: 'lib/jsnlog/jsnlog.min.js',
        ERROR_LOGGER: TC.apiLocation + 'errors/logger.ashx',
        PDFMAKE: TC.apiLocation + 'lib/pdfmake/pdfmake-fonts.min.js',
        JSONPACK: 'lib/jsonpack/jsonpack.min.js',
        UA_PARSER: 'lib/ua-parser/ua-parser.min.js',
        HASH: 'lib/jshash/md5-min.js',
        DRAGGABILLY: 'lib/draggabilly/draggabilly.pkgd',
        URL_POLYFILL: 'lib/polyfill/url.js',
        PROMISE_POLYFILL: 'lib/polyfill/promise/polyfill.min.js'
    };
    TC.Consts.classes = {
        MAP: 'tc-map',
        POINT: 'tc-point',
        MARKER: 'tc-marker',
        VISIBLE: 'tc-visible',
        HIDDEN: 'tc-hidden',
        COLLAPSED: 'tc-collapsed',
        CHECKED: 'tc-checked',
        DISABLED: 'tc-disabled',
        ACTIVE: 'tc-active',
        DEFAULT: 'tc-default',
        LASTCHILD: 'tc-lastchild',
        TRANSPARENT: 'tc-transparent',
        DROP: 'tc-drop',
        LOADING: 'tc-loading',
        IPAD_IOS7_FIX: 'tc-ipad-ios7-fix',
        INFO: 'tc-msg-info',
        WARNING: 'tc-msg-warning',
        ERROR: 'tc-msg-error',
        THREED: 'tc-threed'
    };
    TC.Consts.msgType = {
        INFO: 'info',
        WARNING: 'warning',
        ERROR: 'error'
    };
    TC.Consts.msgErrorMode = {
        TOAST: 'toast',
        CONSOLE: 'console',
        EMAIL: 'email'
    };
    TC.Consts.event = {
        /**
         * Se lanza cuando el mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event mapload
         */
        MAPLOAD: 'mapload.tc',
        MAPREADY: 'mapready.tc',
        BEFORELAYERADD: 'beforelayeradd.tc',
        LAYERADD: 'layeradd.tc',
        LAYERREMOVE: 'layerremove.tc',
        LAYERORDER: 'layerorder.tc',
        BEFORELAYERUPDATE: 'beforelayerupdate.tc',
        LAYERUPDATE: 'layerupdate.tc',
        LAYERERROR: 'layererror.tc',
        BEFOREBASELAYERCHANGE: 'beforebaselayerchange.tc',
        BASELAYERCHANGE: 'baselayerchange.tc',
        BEFOREUPDATE: 'beforeupdate.tc',
        UPDATE: 'update.tc',
        BEFOREZOOM: 'beforezoom.tc',
        ZOOM: 'zoom.tc',
        BEFOREUPDATEPARAMS: 'beforeupdateparams.tc',
        UPDATEPARAMS: 'updateparams.tc',
        VECTORUPDATE: 'vectorupdate.tc',
        FEATUREADD: 'featureadd.tc',
        BEFOREFEATURESADD: 'beforefeaturesadd.tc',
        FEATURESADD: 'featuresadd.tc',
        FEATUREREMOVE: 'featureremove.tc',
        FEATURESCLEAR: 'featuresclear.tc',
        FEATURESIMPORT: 'featuresimport.tc',
        FEATURESIMPORTERROR: 'featuresimporterror.tc',
        BEFORETILELOAD: 'beforetileload.tc',
        TILELOAD: 'tileload.tc',
        TILELOADERROR: 'tileloaderror.tc',
        CONTROLADD: 'controladd.tc',
        CONTROLACTIVATE: 'controlactivate.tc',
        CONTROLDEACTIVATE: 'controldeactivate.tc',
        BEFORECONTROLRENDER: 'beforecontrolrender.tc',
        CONTROLRENDER: 'controlrender.tc',
        BEFORELAYOUTLOAD: 'beforelayoutload.tc',
        LAYOUTLOAD: 'layoutload.tc',
        LAYERVISIBILITY: 'layervisibility.tc',
        LAYEROPACITY: 'layeropacity.tc',
        FEATURECLICK: 'featureclick.tc',
        NOFEATURECLICK: 'nofeatureclick.tc',
        FEATUREOVER: 'featureover.tc',
        FEATUREOUT: 'featureout.tc',
        BEFOREFEATUREINFO: 'beforefeatureinfo.tc',
        FEATUREINFO: 'featureinfo.tc',
        NOFEATUREINFO: 'nofeatureinfo.tc',
        FEATUREINFOERROR: 'featureinfoerror.tc',
        CLICK: 'click',
        MOUSEUP: 'mouseup',
        MOUSEMOVE: 'mousemove',
        MOUSELEAVE: 'mouseleave',
        STARTLOADING: 'startloading.tc',
        STOPLOADING: 'stoploading.tc',
        EXTERNALSERVICEADDED: 'externalserviceadded.tc',
        ZOOMTO: 'zoomto.tc',
        PROJECTIONCHANGE: 'projectionchange.tc',
        VIEWCHANGE: 'viewchange.tc',
        TERRAINPROVIDERADD: 'terrainprovideradd.tc',
        TERRAINPROVIDERREMOVE: 'terrainproviderremove.tc',
        OVERVIEWBASELAYERCHANGE: 'overviewbaselayerchange.tc',
        POPUP: 'popup.tc'
    };
    TC.Consts.layer = {
        IDENA_ORTHOPHOTO: 'ortofoto',
        IDENA_BASEMAP: 'mapabase',
        IDENA_CADASTER: 'catastro',
        IDENA_CARTO: 'cartografia',
        IDENA_ORTHOPHOTO2018: 'ortofoto2018',
        IDENA_ORTHOPHOTO2017: 'ortofoto2017',
        IDENA_ORTHOPHOTO2014: 'ortofoto2014',
        IDENA_ORTHOPHOTO2012: 'ortofoto2012',
        IDENA_DYNBASEMAP: 'mapabase_dinamico',
        IDENA_DYNORTHOPHOTO: 'ortofoto_dinamico',
        IDENA_DYNORTHOPHOTO2018: 'ortofoto2018_dinamico',
        IDENA_DYNORTHOPHOTO2017: 'ortofoto2017_dinamico',
        IDENA_DYNORTHOPHOTO2014: 'ortofoto2014_dinamico',
        IDENA_DYNORTHOPHOTO2012: 'ortofoto2012_dinamico',
        IDENA_DYNCARTO: 'cartografia_dinamico',
        IDENA_BW_RELIEF: 'relieve_bn',
        IDENA_BASEMAP_ORTHOPHOTO: 'base_orto',

        IGN_ES_CARTO: "ign-raster",
        IGN_ES_BASEMAP: "ign-base",
        IGN_ES_BASEMAP_GREY: "ign-base-gris",
        IGN_ES_RELIEF: "ign-mtn",
        IGN_ES_ORTHOPHOTO: "ign-pnoa",
        IGN_ES_LIDAR: "ign-lidar",

        IGN_ES_DYNCARTO: "ign-raster-dyn",
        IGN_ES_DYNBASEMAP: "ign-base-dyn",
        IGN_ES_DYNBASEMAP_GREY: "ign-base-gris-dyn",
        IGN_ES_DYNRELIEF: "ign-mtn-dyn",
        IGN_ES_DYNORTHOPHOTO: "ign-pnoa-dyn",
        IGN_ES_DYNLIDAR: "ign-lidar-dyn",

        IGN_FR_CARTO: "ign-fr-cartes",
        IGN_FR_BASEMAP: "ign-fr-base",
        IGN_FR_RELIEF: "ign-fr-estompage",
        IGN_FR_ORTHOPHOTO: "ign-fr-orto",

        IGN_FR_DYNCARTO: "ign-fr-cartes-dyn",
        IGN_FR_DYNBASEMAP: "ign-fr-base-dyn",
        IGN_FR_DYNRELIEF: "ign-fr-estompage-dyn",
        IGN_FR_DYNORTHOPHOTO: "ign-fr-orto-dyn",

        OSM: 'osm',
        CARTO_VOYAGER: 'carto_voyager',
        CARTO_LIGHT: 'carto_light',
        CARTO_DARK: 'carto_dark',
        MAPBOX_STREETS: 'mapbox_streets',
        MAPBOX_SATELLITE: 'mapbox_satellite',

        BLANK: 'ninguno'
    };
    TC.Consts.text = {
        API_ERROR: 'Error API SITNA',
        APP_ERROR: 'Error de aplicación'
    };
    /**
     * Colección de identificadores de tipo de capa.
     * No se deberían modificar las propiedades de esta clase.
     * @class TC.consts.LayerType
     * @static
     */
    /**
     * Identificador de capa de tipo WMS.
     * @property WMS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo WMTS.
     * @property WMTS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo WFS.
     * @property WFS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo KML.
     * @property KML
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo GPX.
     * @property GPX
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo vectorial. Este tipo de capa es la que se utiliza para dibujar marcadores.
     * @property VECTOR
     * @type string
     * @final
     */
    /**
     * Identificador de capa de grupo.
     * @property GROUP
     * @type string
     * @final
     */
    TC.Consts.layerType = {
        WMS: 'WMS',
        WMTS: 'WMTS',
        WFS: 'WFS',
        VECTOR: 'vector',
        KML: 'KML',
        GPX: 'GPX',
        GML: 'GML',
        GEOJSON: 'GeoJSON',
        GROUP: 'group'
    };
    TC.Consts.geom = {
        POINT: 'point',
        MULTIPOINT: 'multipoint',
        POLYLINE: 'polyline',
        POLYGON: 'polygon',
        MULTIPOLYLINE: 'multipolyline',
        MULTIPOLYGON: 'multipolygon',
        CIRCLE: 'circle',
        RECTANGLE: 'rectangle'
    };
    TC.Consts.searchType = {
        CADASTRAL: 'cadastral',
        COORDINATES: 'coordinates',
        MUNICIPALITY: 'municipality',
        COUNCIL: 'council',
        LOCALITY: 'locality',
        STREET: 'street',
        NUMBER: 'number',
        URBAN: 'urban',
        COMMONWEALTH: 'commonwealth',
        ROAD: 'road',
        ROADPK: 'roadpk',
        PLACENAME: 'placename',
        PLACENAMEMUNICIPALITY: 'placenamemunicipality'
    };
    TC.Consts.mapSearchType = {
        MUNICIPALITY: TC.Consts.searchType.MUNICIPALITY,
        COUNCIL: TC.Consts.searchType.COUNCIL,
        URBAN: TC.Consts.searchType.URBAN,
        COMMONWEALTH: TC.Consts.searchType.COMMONWEALTH,
        GENERIC: 'generic'
    };
    TC.Consts.comparison = {
        EQUAL_TO: '==',
        NOT_EQUAL_TO: '!=',
        LESS_THAN: '<',
        GREATER_THAN: '>',
        LESS_THAN_EQUAL_TO: '=<',
        GREATER_THAN_EQUAL_TO: '>=',
        LIKE: 'is'
    };
    TC.Consts.logicalOperator = {
        AND: 'and',
        OR: 'or'
    };
    TC.Consts.WMTSEncoding = {
        KVP: 'KVP',
        RESTFUL: 'RESTful'
    };
    TC.Consts.mimeType = {
        PNG: 'image/png',
        JPEG: 'image/jpeg',
        JSON: 'application/json',
        GEOJSON: 'application/vnd.geo+json',
        KML: 'application/vnd.google-earth.kml+xml',
        GML: 'application/gml+xml',
        GPX: 'application/gpx+xml',
        XML: 'application/xml'
    };
    TC.Consts.format = {
        JSON: 'JSON',
        KML: 'KML',
        GML: 'GML',
        GML2: 'GML2',
        GML3: 'GML2',
        GEOJSON: 'GeoJSON',
        TOPOJSON: 'TopoJSON',
        GPX: 'GPX',
        WKT: 'WKT'
    };
    //enumerado de errores y warninqs derivados de descargas, getfeatures
    TC.Consts.WFSErrors = {
        GetFeatureNotAvailable: "GetFeatureNotAvailable",
        LayersNotAvailable: "LayersNotAvailable",
        NoLayers: "NoLayers",
        NoValidLayers: "noValidLayers",
        QueryNotAvailable: "QueryNotAvailable",
        CapabilitiesParseError: "CapabilitiesParseError",
        NumMaxFeatures: "NumMaxFeatures",
        GetCapabilities: "GetCapabilities",
        Indeterminate: "Indeterminate",
        NoFeatures: "NoFeatures"
    }
    /**
     * Colección de identificadores de estados de visibilidad.
     * No se deberían modificar las propiedades de esta clase.
     * @class TC.consts.Visibility
     * @static
     */
    /**
     * Identificador de nodo no visible.
     * @property NOT_VISIBLE
     * @type number
     * @final
     */
    /**
     * Identificador de nodo no visible a la resolución actual.
     * @property NOT_VISIBLE_AT_RESOLUTION
     * @type number
     * @final
     */
    /**
     * Identificador de nodo no visible pero que tiene nodos hijos visibles.
     * @property HAS_VISIBLE
     * @type number
     * @final
     */
    /**
     * Identificador de nodo visible.
     * @property VISIBLE
     * @type number
     * @final
     */
    TC.Consts.visibility = {
        NOT_VISIBLE: 0,
        NOT_VISIBLE_AT_RESOLUTION: 1,
        HAS_VISIBLE: 2,
        VISIBLE: 4
    };

    TC.Consts.view = {
        DEFAULT: 0,
        THREED: 1,
        PRINTING: 2
    };

    TC.Consts.units = {
        DEGREES: "degrees",
        METERS: "m"
    };

    TC.Consts.MARKER = 'marker';

    TC.Defaults = (function () {

        var clusterRadii = {};
        var getClusterRadius = function (feature) {
            var count = feature.features.length;
            var result = clusterRadii[count];
            if (!result) {
                result = 2 + Math.round(Math.sqrt(count) * 5);
                clusterRadii[count] = result;
            }
            return result;
        };

        return {
            imageRatio: 1.05,
            proxy: '',

            crs: 'EPSG:25830',
            utmCrs: 'EPSG:25830',
            geoCrs: 'EPSG:4326',
            initialExtent: [541084.221, 4640788.225, 685574.4632, 4796618.764],
            maxExtent: false,
            baselayerExtent: [480408, 4599748, 742552, 4861892],
            resolutions: [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, .5, .25],
            pointBoundsRadius: 30,
            extentMargin: 0.2,
            mouseWheelZoom: true,
            attribution: '<a href="http://sitna.navarra.es/" target="_blank">SITNA</a>',
            oldBrowserAlert: true,
            notifyApplicationErrors: false,
            loggingErrorsEnabled: true,
            maxErrorCount: 10,

            locale: 'es-ES',

            view: TC.Consts.view.DEFAULT,

            screenSize: 20,
            pixelTolerance: 10, // Used in GFI requests
            maxResolutionError: 0.01, // Max error ratio to consider two resolutions equivalent

            toastDuration: 5000,

            avgTileSize: 31000,

            availableBaseLayers: [
                {
                    id: TC.Consts.layer.IDENA_BASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830extended',
                    layerNames: 'mapabase',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: true,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO,
                    title: 'Ortofoto máxima actualidad',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto_maxima_actualidad',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2018,
                    title: 'Ortofoto 2018',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2018',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2017,
                    title: 'Ortofoto 2017',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2017',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830reduced',
                    layerNames: 'ortofoto2014',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2012',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CARTO,
                    title: 'Cartografía topográfica 2017',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'mapaTopografico',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CADASTER,
                    title: 'Catastro',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'catastro,regionesFronterizas',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-cadaster.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BW_RELIEF,
                    title: 'Relieve',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'IDENA:mapa_relieve_bn',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_bw.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BASEMAP_ORTHOPHOTO,
                    title: 'Mapa base/ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase_orto',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-base_ortho.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNBASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase,regionesFronterizas',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    title: 'Ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_maxima_actualidad',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2018',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2017',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2014',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2012',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNCARTO,
                    title: 'Cartografía topográfica',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'MTNa5_BTA',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_CARTO,
                    type: TC.Consts.layerType.WMTS,
                    title: "Cartografía raster \r\n (IGN ES)",
                    url: "//www.ign.es/wmts/mapa-raster",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "MTN",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP,
                    title: "Callejero \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBaseTodo",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP_GREY,
                    title: "Callejero gris \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBase-gris",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_grey_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_RELIEF,
                    title: "Relieve \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/mdt",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "Relieve",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-relief_ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_ORTHOPHOTO,
                    title: "Ortofoto PNOA",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/pnoa-ma",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "OI.OrthoimageCoverage",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-orthophoto_pnoa.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_LIDAR,
                    title: "Modelo digital LIDAR (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "http://wmts-mapa-lidar.idee.es/lidar",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "EL.GridCoverageDSM",
                    matrixSet: "GoogleMapsCompatible",
                    format: "image/png",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-lidar_ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNLIDAR,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    title: 'Callejero gris \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo-gris',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_grey_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/pnoa-ma',
                    layerNames: 'OI.OrthoimageCoverage',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto_pnoa.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNCARTO,
                    title: 'Cartografía topográfica \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mapa-raster',
                    layerNames: 'mtn_rasterizado',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    title: 'Relieve \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mdt',
                    layerNames: 'relieve',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_ign.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNLIDAR,
                    title: 'Modelo digital LIDAR (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//wms-mapa-lidar.idee.es/lidar',
                    layerNames: 'EL.GridCoverage',
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-lidar_ign.jpg",
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_CARTO,
                    title: "Cartografía raster \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNCARTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_BASEMAP,
                    title: "Mapa base \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_RELIEF,
                    title: "Relieve \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE.SHADOW",
                    matrixSet: "PM",
                    format: "image/png",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_ORTHOPHOTO,
                    title: "Ortofoto \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ORTHOIMAGERY.ORTHOPHOTOS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNCARTO,
                    title: 'Cartografía raster \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP,
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    title: 'Relieve \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "HR.ORTHOIMAGERY.ORTHOPHOTOS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.OSM,
                    title: 'OSM',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/osm/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'osm',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-osm.png',
                    overviewMapLayer: TC.Consts.layer.OSM
                },
                {
                    id: TC.Consts.layer.CARTO_VOYAGER,
                    title: 'CARTO Voyager',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'voyager',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-voyager.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_LIGHT,
                    title: 'CARTO light',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'light_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-light.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_DARK,
                    title: 'CARTO dark',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'dark_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-dark.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.MAPBOX_STREETS,
                    title: 'Mapbox Streets',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'streets',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-streets.png',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.MAPBOX_SATELLITE,
                    title: 'Mapbox Satellite',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'satellite',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-satellite.jpg',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.BLANK,
                    title: 'Mapa en blanco',
                    type: TC.Consts.layerType.VECTOR
                }
            ],

            baseLayers: [
                TC.Consts.layer.IDENA_BASEMAP,
                TC.Consts.layer.IDENA_ORTHOPHOTO,
                TC.Consts.layer.IDENA_CADASTER,
                TC.Consts.layer.IDENA_CARTO
            ],

            defaultBaseLayer: TC.Consts.layer.IDENA_BASEMAP,

            workLayers: [],

            controls: {
                loadingIndicator: true,
                navBar: false,
                scaleBar: false,
                scale: false,
                scaleSelector: false,
                overviewMap: false,
                basemapSelector: false,
                attribution: true,
                TOC: false,
                coordinates: true,
                legend: false,
                popup: false,
                search: {
                    url: '//idena.navarra.es/ogc/wfs',
                    allowedSearchTypes: {
                        coordinates: {},
                        municipality: {},
                        urban: {},
                        street: {},
                        number: {},
                        cadastral: {}
                    }
                },
                measure: false,
                streetView: false,
                featureInfo: true,
                featureTools: true
            },

            layout: null,

            styles: {
                point: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    radius: 6,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -16],
                    fontColor: '#000000',
                    fontSize: 10
                },
                marker: {
                    classes: [
                        TC.Consts.classes.MARKER + 1,
                        TC.Consts.classes.MARKER + 2,
                        TC.Consts.classes.MARKER + 3,
                        TC.Consts.classes.MARKER + 4,
                        TC.Consts.classes.MARKER + 5
                    ],
                    anchor: [.5, 1],
                    width: 32,
                    height: 32,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -32],
                    fontColor: '#000000',
                    fontSize: 10
                },
                line: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                polygon: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    fillColor: '#000000',
                    fillOpacity: 0.3,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                cluster: {
                    point: {
                        fillColor: '#333366',
                        fillOpacity: 0.6,
                        radius: getClusterRadius,
                        label: '${features.length}',
                        fontColor: "#fff",
                        fontSize: 9
                    }
                },
                selection: {
                    point: {
                        fillColor: '#0000ff',
                        fillOpacity: 0.5,
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        radius: 6,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        labelOffset: [0, -16],
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    line: {
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    polygon: {
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        fillColor: '#000000',
                        fillOpacity: .3,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    }
                }
            }
        };
    })();

    (function () {
        if (!Array.prototype.map) {
            Array.prototype.map = function (fun /*, thisArg */) {
                "use strict";

                if (this === void 0 || this === null)
                    throw new TypeError();

                var t = Object(this);
                var len = t.length >>> 0;
                if (typeof fun !== "function")
                    throw new TypeError();

                var res = new Array(len);
                var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                for (var i = 0; i < len; i++) {
                    // NOTE: Absolute correctness would demand Object.defineProperty
                    //       be used.  But this method is fairly new, and failure is
                    //       possible only if Object.prototype or Array.prototype
                    //       has a property |i| (very unlikely), so use a less-correct
                    //       but more portable alternative.
                    if (i in t)
                        res[i] = fun.call(thisArg, t[i], i, t);
                }

                return res;
            };
        }

        /* 
         * proxify: returns cross-origin safe URL
         */
        TC.proxify = function (url) {
            url = url.trim();
            var result = url;
            if (TC.Cfg.proxy) {
                var prevent = false;
                if (TC.Cfg.proxyExceptions) {
                    for (var i = 0; i < TC.Cfg.proxyExceptions.length; i++) {
                        if (url.indexOf(TC.Cfg.proxyExceptions[i]) > -1) {
                            prevent = true;
                            break;
                        }
                    }
                }

                if (!prevent && !TC.Util.isSameOrigin(url)) {
                    if (typeof TC.Cfg.proxy == "function") {
                        result = TC.Cfg.proxy(url);
                    } else {
                        result = TC.Cfg.proxy;
                        if (url.substr(0, 4) != "http") result += window.location.protocol;
                        result += encodeURIComponent(url);
                    }
                }
            }
            return result;
        };

        var getHead = function () {
            var result;
            var d = document;
            var ah = d.getElementsByTagName("head");
            if (ah.length === 0) {
                result = d.createElement("head");
                d.documentElement.insertBefore(result, document.body);
            }
            else {
                result = ah[0];
            }
            return result;
        };

        if (typeof TC.isDebug != "boolean") {
            TC.isDebug = true;
        };

        var _showLoadFailedError = function (url) {
            const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));
            TC.error(
                TC.Util.getLocaleString(mapObj.options.locale, "urlFailedToLoad",
                    { url: url }),
                [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],
                "Error al cargar " + url);
        };

        TC.syncLoadJS = function (url) {
            var _sendRequest = function (url, callbackErrorFn) {
                var req = new XMLHttpRequest();
                req.open("GET", url, false); // 'false': synchronous.
                var result;

                req.onreadystatechange = function (e) {
                    if (req.readyState === 4) {
                        if (req.status === 404) {
                            result = false;
                            callbackErrorFn(true);
                        } else if (req.status !== 200) {
                            callbackErrorFn();
                            result = false;
                        } else {
                            result = req.responseText;
                        }
                    }
                };


                try {
                    req.send(null);
                } catch (error) {
                    result = false;
                    callbackErrorFn();
                }

                return result;
            };

            if (!/(\.js|\/)$/i.test(url)) { // Si pedimos un archivo sin extensión se la ponemos según el entorno
                url = url + (TC.isDebug ? '.js' : '.min.js');
            }

            var reqResult = _sendRequest(url, function (is404) {
                if (is404) {
                    _showLoadFailedError(url);
                    return false;
                } else {
                    return _sendRequest(url, function () {
                        _showLoadFailedError(url);
                    });
                }
            });

            if (reqResult) {
                var script = document.createElement("script");
                script.type = "text/javascript";
                script.text = reqResult;
                getHead().appendChild(script);
            }
        };

        const prefixes = ['', '-webkit-', '-moz-', '-o-', '-ms-'];
        const randomText = ':-)';
        const urlString = 'http://sitna.tracasa.es/';
        var touch;
        var inputTypeColor;
        var urlParser;
        TC.browserFeatures = {
            touch: function () {
                if (touch === undefined) {
                    if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
                        touch = true;
                        return true;
                    }
                    const query = prefixes
                        .map(function (prefix) { return '(' + prefix + 'touch-enabled)'; })
                        .join();
                    touch = matchMedia(query).matches;
                }
                return touch;
            },
            inputTypeColor: function () {
                if (inputTypeColor === undefined) {
                    const elm = document.createElement('input');
                    elm.setAttribute('type', 'color');
                    inputTypeColor = elm.type !== 'text' && 'style' in elm;
                    if (inputTypeColor) {
                        elm.value = randomText;
                        inputTypeColor = elm.value !== randomText;
                    }
                }
                return inputTypeColor;
            },
            urlParser: function () {
                if (urlParser === undefined) {
                    try {
                        // have to actually try use it, because Safari defines a dud constructor
                        const url = new URL(urlString);
                        urlParser = url.href === urlString;
                    } catch (e) {
                        urlParser = false;
                    }
                }
                return urlParser;
            }
        };

        const patchJQuery = function () {
            // Parche para soportar $.when
            $._oldWhen = $.when;
            $.when = function () {
                const newArgs = new Array(arguments.length);
                for (var i = 0; i < arguments.length; i++) {
                    const arg = newArgs[i] = arguments[i];
                    if (arg instanceof Promise) {
                        const newArg = $.Deferred();
                        arg
                            .then(function (val) {
                                newArg.resolve(val)
                            })
                            .catch(function (err) {
                                newArg.reject(err);
                            });
                        newArgs[i] = newArg;
                    }
                }
                return $._oldWhen.apply(this, newArgs);
            };
        };

        if (window.jQuery) {
            TC._jQueryIsLoaded = true;
            patchJQuery();
        }
        //else {
        //    Object.defineProperty(window, 'jQuery', {
        //        configurable: true,
        //        get: fnction () {
        //            console.trace();
        //            Object.defineProperty(window, 'jQuery', { writable: true });
        //            TC.syncLoadJS(TC.Consts.url.JQUERY);
        //            patchJQuery();
        //            TC._jQueryIsLoaded = true;
        //            return jQuery;
        //        }
        //    });
        //    Object.defineProperty(window, '$', {
        //        configurable: true,
        //        get: function () {
        //            console.trace();
        //            Object.defineProperty(window, '$', { writable: true });
        //            TC.syncLoadJS(TC.Consts.url.JQUERY);
        //            patchJQuery();
        //            TC._jQueryIsLoaded = true;
        //            return $;
        //        }
        //    });
        //}

        if (!('Promise' in window)) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.PROMISE_POLYFILL);
        }
        // Polyfill para NodeList.forEach
        if (window.NodeList && !NodeList.prototype.forEach) {
            NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if (!('finally' in Promise.prototype)) {
            // Muchos polyfills de Promise no implementan finally, lo hacemos aquí en ese caso
            Promise.prototype.finally = function (callback) {
                const ctor = this.constructor;
                return this.then(
                    function (val) {
                        return ctor.resolve(callback()).then(function () {
                            return value;
                        });
                    },
                    function (err) {
                        return ctor.resolve(callback()).then(function () {
                            return ctor.reject(err);
                        });
                    }
                );
            };
        }

        if (!TC.tool || !TC.tool.Proxification) {
            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
        }

        // Transformación de petición AJAX de jQuery a promesa nativa
        TC.ajax = function (options) {
            return new Promise(function (resolve, reject) {
                options = options || {};
                const method = options.method || 'GET';
                var data;
                if (options.data) {
                    if (typeof options.data === 'string') {
                        data = options.data;
                    }
                    else if (typeof options.data === 'object') {
                        const paramArray = [];
                        for (var key in options.data) {
                            paramArray[paramArray.length] = key + '=' + options.data[key].toString();
                        }
                        data = paramArray.join('&');
                    }
                }
                var url = options.url;
                if (method === 'GET') {
                    url = url + '?' + data;
                }
                if (options.cache === false) {
                    url += (url.indexOf('?') < 0 ? '&' : '?') + 'ts=' + Date.now();
                }
                const request = new XMLHttpRequest();
                request.open(method, options.url);

                if (options.contentType || typeof options.contentType === 'boolean') {
                    if (options.contentType) {
                        request.setRequestHeader('Content-Type', options.contentType + '; charset=UTF-8');
                    }

                }
                else {
                    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                }

                request.onreadystatechange = function (e) {
                    if (request.readyState === 4) { // DONE
                        if (request.status !== 200) {
                            reject({
                                status: request.status,
                                msg: request.statusText,
                                url: options.url
                            });
                        } else {
                            var responseData;
                            try {
                                switch (options.responseType) {
                                    case TC.Consts.mimeType.JSON:
                                        responseData = JSON.parse(request.responseText);
                                        break;
                                    case TC.Consts.mimeType.XML:
                                        responseData = new DOMParser().parseFromString(request.responseText, 'application/xml');
                                        break;
                                    default:
                                        responseData = request.responseText;
                                        break;
                                }
                                resolve({ data: responseData, contentType: request.getResponseHeader("Content-type") });
                            }
                            catch (error) {
                                reject(error);
                            }
                        }
                    }
                };

                try {
                    request.send(method === 'POST' ? data : null);
                } catch (error) {
                    reject(error);
                }
            });
        };

        // Completamos los datos de versión
        document.addEventListener('DOMContentLoaded', function () {
            var build;
            var mapLibrary = 'Unknown library';
            var OL = 'OpenLayers';
            if (TC.Control) {
                build = 'Compiled';
                if (window.ol) {
                    mapLibrary = OL + ' ' + ol.VERSION;
                }
            }
            else {
                build = 'On demand';
                mapLibrary = OL;
            }
            TC.version = TC.version + ' (' + build + '; ' + mapLibrary + '; @ ' + TC.apiLocation + ')';
        });

        TC.loadJSInOrder = function (condition, url, callback) {
            TC.loadJS(condition, url, callback, true);
        };

        const addCrossOriginAttr = function (path, scriptEl) {
            if (!TC.Util.isSameOrigin(path)) {
                scriptEl.crossOrigin = "anonymous";
            }
        };

        TC.loadJS = function (condition, url, callback, inOrder, notCrossOrigin) {
            if (arguments.length < 4) {
                inOrder = false;
            }

            var urls = Array.isArray(url) ? url : [url];
            urls = urls.map(function (elm) {
                if (!/\.js$/i.test(elm) && elm.indexOf(TC.apiLocation) === 0) { // Si pedimos un archivo sin extensión y es nuestro se la ponemos según el entorno
                    return elm + (TC.isDebug ? '.js' : '.min.js');
                }
                return elm;
            });

            if (condition) {
                urls = urls instanceof Array ? urls : [urls];

                var name = "";
                const getName = function (path) {
                    return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
                };
                if (urls.length > 1) {
                    var toReduce = urls.slice(0).filter(function (path, index) {
                        if (loadjs.isDefined(getName(path))) {
                            urls.splice(index, 1);
                            loadjs.ready(getName(path), callback);
                            return false;
                        } else {
                            return true;
                        }
                    });
                    if (toReduce.length === 1) {
                        name = getName(toReduce[0]);
                    } else if (toReduce.length > 0) {
                        name = toReduce.reduce(function (prev, curr) {
                            return getName(prev) + "_" + getName(curr);
                        });
                    }
                } else {
                    name = getName(urls[0]);
                }

                if (name.length > 0) {
                    if (!loadjs.isDefined(name)) {
                        var options = {
                            async: !inOrder,
                            numRetries: 1
                        };

                        if (!notCrossOrigin && !TC.Util.detectIE()) {
                            options.before = addCrossOriginAttr;
                        }

                        loadjs(urls, name, options);
                        loadjs.ready(name, {
                            success: function () {
                                callback();
                            },
                            error: function (pathsNotFound) {
                                _showLoadFailedError(pathsNotFound);
                            }
                        });
                    } else {
                        // Esto vuelve a añadir el script al head si se está pidiendo un script cargado previamente.
                        urls.forEach(function (url) {
                            const urlObj = new URL(url, location.href);
                            const script = Array.from(document.scripts).filter((scr) => scr.src === urlObj.href)[0];
                            if (script) {
                                document.head.appendChild(script.cloneNode());
                            }
                        });
                        loadjs.ready(name, callback);
                    }
                }
            }
            else {
                callback();
            }
        };

        TC.loadCSS = function (url) {
            const getName = function (path) {
                return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
            };

            const name = getName(url);
            if (!loadjs.isDefined(name)) {
                loadjs(url, name, {
                    error: function (pathsNotFound) {
                        _showLoadFailedError(pathsNotFound);
                    },
                    numRetries: 1
                });
            } else {
                loadjs.ready(name, {});
            }
        };

        var projectionDataCache = {};

        TC.getProjectionData = function (options) {
            return new Promise(function (resolve, reject) {
                options = options || {};
                var code = options.crs.substr(options.crs.indexOf(':') + 1);
                if (Number.isNaN(parseInt(code))) {
                    // El CRS no está en modo urn o EPSG
                    code = options.crs.substr(options.crs.lastIndexOf('/') + 1);
                }
                var projData = projectionDataCache[code];
                if (projData) {
                    resolve(projData);
                }
                else {
                    var url = TC.Consts.url.EPSG + '?format=json&q=' + code;
                    const toolProxification = new TC.tool.Proxification(TC.proxify);
                    toolProxification.fetchJSON(url, options).then(function (data) {
                        projectionDataCache[code] = data;
                        resolve(data);
                    }).catch(function (error) {
                        reject(Error(error));
                    });
                }
            });
        };

        TC.loadProjDef = function (options) {
            options = options || {};
            const crs = options.crs;
            const epsgPrefix = 'EPSG:';
            const urnPrefix = 'urn:ogc:def:crs:EPSG::';
            const urnxPrefix = 'urn:x-ogc:def:crs:EPSG:';
            const gmlPrefix = 'http://www.opengis.net/gml/srs/epsg.xml#';

            const fromHTTPURIToURN = function (name) {
                var match = /http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/\d\/(\d{4})/.exec(name);
                if (match && match.length === 2) {
                    return urnPrefix + match[1];
                }

                return name;
            };

            var getDef;
            if (!window[TC.Consts.PROJ4JSOBJ]) {
                TC.syncLoadJS(TC.url.proj4js);
            }
            getDef = function (name) {
                name = fromHTTPURIToURN(name);
                return proj4.defs(name);
            };
            const loadProj4Def = function (code, def) {
                proj4.defs(code, def);
                if (window.ol && window.ol.proj) {
                    // https://openlayers.org/en/latest/apidoc/module-ol_proj_proj4.html
                    window.ol.proj.proj4.register(proj4);
                }
            };
            const isFunction = function (obj) {
                return typeof obj === 'function';
            };
            const loadDef = function (code, def, name) {
                const epsgCode = epsgPrefix + code;
                const urnCode = urnPrefix + code;
                const urnxCode = urnxPrefix + code;
                const gmlCode = gmlPrefix + code;
                var axisUnawareDef;
                if (typeof def === 'object') {
                    axisUnawareDef = TC.Util.extend({}, def);
                    def = TC.Util.extend({}, def);
                    if (axisUnawareDef.axis) {
                        delete axisUnawareDef.axis;
                    }
                }
                else if (typeof def === 'string') {
                    axisUnawareDef = def.replace('+axis=neu', '');
                }
                loadProj4Def(epsgCode, def);
                loadProj4Def(urnCode, def);
                loadProj4Def(urnxCode, def);
                // Por convención, los CRS definidos por URI siempre tienen orden de coordenadas X-Y.
                loadProj4Def(gmlCode, axisUnawareDef);
                if (crs.indexOf('http') === 0) {
                    // El CRS es tipo URI, usado seguramente en un GML.
                    loadProj4Def(crs, axisUnawareDef);
                    getDef(crs).name = name;
                }
                getDef(epsgCode).name = name;
                getDef(gmlCode).name = name;
            };
            const loadDefResponse = function (data) {
                var result = data.status === 'ok' && data.number_result === 1;
                if (result) {
                    var def = data.results[0];
                    loadDef(def.code, def.proj4, def.name);
                }
                return result;
            };

            var idx = crs.lastIndexOf('#');
            if (idx < 0) {
                idx = crs.lastIndexOf('/');
            }
            if (idx < 0) {
                idx = crs.lastIndexOf(':');
            }
            var code = crs.substr(idx + 1);
            var def = getDef(crs);
            if (def) {
                loadDef(code, def, options.name);
                if (isFunction(options.callback)) {
                    options.callback();
                }
            }
            else {
                if (options.def) {
                    loadDef(code, options.def, options.name);
                    if (isFunction(options.callback)) {
                        options.callback();
                    }
                }
                else {
                    TC.getProjectionData(options).then(function (data) {
                        if (loadDefResponse(data) && isFunction(options.callback)) {
                            options.callback();
                        };
                    });
                }
            }
        };

        TC.url = {
            templating: [
                TC.apiLocation + TC.Consts.url.TEMPLATING,
                TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                TC.apiLocation + TC.Consts.url.TEMPLATING_OVERRIDES
            ]
        };

        TC.url.ol = TC.apiLocation + TC.Consts.url.OL;
        TC.url.olConnector = TC.apiLocation + TC.Consts.url.OL_CONNECTOR;
        TC.url.proj4js = TC.apiLocation + TC.Consts.url.PROJ4JS;

        // Precargamos el CRS por defecto
        TC.loadProjDef({ crs: 'EPSG:25830', name: 'ETRS89 / UTM zone 30N', def: '+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs' });
        // Precargamos los CRS de IDENA que tienen orden de ejes neu
        TC.loadProjDef({ crs: 'EPSG:4258', name: 'ETRS89', def: '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3040', name: 'ETRS89 / UTM zone 28N (N-E)', def: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3041', name: 'ETRS89 / UTM zone 29N (N-E)', def: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3042', name: 'ETRS89 / UTM zone 30N (N-E)', def: '+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3043', name: 'ETRS89 / UTM zone 31N (N-E)', def: '+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:4230', name: 'ED50', def: '+proj=longlat +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +no_defs +axis=neu' });

        if (!TC.Util) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Util');
        }

        TC.Cfg = TC.Util.extend(true, {}, TC.Defaults, TC.Cfg);

        TC.capabilities = {};

        TC.WFScapabilities = {};

        TC.cache = {};

        TC.alert = function (text) {
            alert(text);
        };

        TC.prompt = function (text, value, callback) {
            var newValue = prompt(text, value);
            if (TC.Util.isFunction(callback)) {
                callback(newValue);
            }
        };

        TC.confirm = function (text, accept, cancel) {
            if (confirm(text)) {
                if (TC.Util.isFunction(accept)) {
                    accept();
                }
            }
            else {
                if (TC.Util.isFunction(cancel)) {
                    cancel();
                }
            }
        };

        TC.error = function (text) {
            if (window.console) {
                console.error(text);
            }

        };

        if (!TC.Map) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Map');
        }

        // OpenLayers connectors
        TC.wrap = {
            Map: function (map) {
                var self = this;
                self.parent = map;
                self.map = null;
                /*
                 *  wrap.getMap: Gets OpenLayers map or a promise for the OpenLayers map
                 */
                self.getMap = function () {
                    return self._promise;
                };                
            },
            Layer: function (layer) {
                var self = this;
                self.parent = layer;
                self.layer = null;
                TC.EventTarget.call(self);
                /*
                 *  getLayer: Gets OpenLayers layer or a promise for the OpenLayers layer
                 */
                self.getLayer = function () {
                    if (self.layer) {
                        return Promise.resolve(self.layer);
                    }
                    return self._promise;
                };
                /*
                 *  setLayer: Resolves the deferred layer object
                 * Parameter: the OpenLayers layer
                 */
                self.setLayer = function (olLayer) {
                    self.layer = olLayer;
                };
            },
            layer: {
                Raster: function () { TC.wrap.Layer.apply(this, arguments); },
                Vector: function () { TC.wrap.Layer.apply(this, arguments); }
            },
            Control: function (ctl) {
                var self = this;
                self.parent = ctl;
            },
            control: {
                Click: function () { TC.wrap.Control.apply(this, arguments); },
                ScaleBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBarHome: function () { TC.wrap.Control.apply(this, arguments); },
                Coordinates: function () { TC.wrap.Control.apply(this, arguments); },
                Search: function () { TC.wrap.Control.apply(this, arguments); },
                Measure: function () { TC.wrap.Control.apply(this, arguments); },
                OverviewMap: function () { TC.wrap.Control.apply(this, arguments); },
                FeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Popup: function () { TC.wrap.Control.apply(this, arguments); },
                GeometryFeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Geolocation: function () { TC.wrap.Control.apply(this, arguments); },
                Draw: function () { TC.wrap.Control.apply(this, arguments); },
                Modify: function () { TC.wrap.Control.apply(this, arguments); },
                CacheBuilder: function () { TC.wrap.Control.apply(this, arguments); },
                Edit: function () { TC.wrap.Control.apply(this, arguments); },
                ResultsPanel: function () { TC.wrap.Control.apply(this, arguments); }
            },
            Feature: function () { },
            Geometry: function () { }
        };
        TC.inherit(TC.wrap.Layer, TC.EventTarget);
        TC.inherit(TC.wrap.layer.Raster, TC.wrap.Layer);
        TC.inherit(TC.wrap.layer.Vector, TC.wrap.Layer);
        TC.inherit(TC.wrap.control.Click, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ScaleBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBarHome, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Coordinates, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Measure, TC.wrap.Control);
        TC.inherit(TC.wrap.control.OverviewMap, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Popup, TC.wrap.Control);
        TC.inherit(TC.wrap.control.FeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.GeometryFeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.Geolocation, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Draw, TC.wrap.Control);
        TC.inherit(TC.wrap.control.CacheBuilder, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Edit, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ResultsPanel, TC.wrap.Control);

        TC.loadCSS(TC.apiLocation + 'TC/css/tcmap.css');


        TC.loadJS(!TC.browserFeatures.urlParser(), TC.apiLocation + TC.Consts.url.URL_POLYFILL, function () { });

        var uids = {};
        TC.getUID = function (prefix) {
            prefix = prefix || '';
            var value = uids[prefix];
            if (!value) {
                value = uids[prefix] = 1;
            }
            var result = prefix + value;
            uids[prefix] = value + 1;
            return result;
        };

        const pluses = /\+/g;
        function raw(s) {
            return s;
        }
        function decoded(s) {
            return decodeURIComponent(s.replace(pluses, ' '));
        }

        TC.cookie = function (key, value, options) {

            // key and at least value given, set cookie...
            if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value === null)) {
                options = TC.Util.extend({}, options);

                if (value === null) {
                    options.expires = -1;
                }

                if (typeof options.expires === 'number') {
                    var days = options.expires, t = options.expires = new Date();
                    t.setDate(t.getDate() + days);
                }

                value = String(value);

                return (document.cookie = [
                    encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
                    options.expires ? ';expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    options.path ? ';path=' + options.path : '',
                    options.domain ? ';domain=' + options.domain : '',
                    options.secure ? ';secure' : ''
                ].join(''));
            }

            // key and possibly options given, get cookie...
            options = value || {};
            var decode = options.raw ? raw : decoded;
            var cookies = document.cookie.split('; ');
            for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
                if (decode(parts.shift()) === key) {
                    return decode(parts.join('='));
                }
            }
            return null;
        };

    })();
}

document.addEventListener('DOMContentLoaded', function () {

    TC.browser = TC.Util.getBrowser();

    TC.loadJS(!TC.Cfg.acceptedBrowserVersions, TC.apiLocation + 'TC/config/browser-versions.js', function (result) {
        var isSupported = true;
        var versions = TC.Cfg.acceptedBrowserVersions;

        var match = versions.filter(function (item) {
            return item.name.toLowerCase() === TC.browser.name.toLowerCase();
        });

        // GLS: 14/02/2019 Añadimos gestión para que no muestre tostada ni envíe correos en caso de que el navegador sea uno expirado
        if (match.length > 0 && match[0].expired) {
            TC.Cfg.loggingErrorsEnabled = false;
        } else {
            if (match.length > 0 && !isNaN(match[0].version)) {
                if (TC.browser.version < match[0].version) {
                    isSupported = false;
                }
            }

            if (TC.Cfg.oldBrowserAlert && !isSupported) {
                TC.Cfg.loggingErrorsEnabled = false;
                const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));

                TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale).then(function () {
                    TC.error(TC.Util.getLocaleString(mapObj.options.locale, 'outdatedBrowser'), TC.Consts.msgErrorMode.TOAST);
                });
            }
        }
    });

    if (/ip(ad|hone|od)/i.test(navigator.userAgent)) {
        // En iOS, el primer click es un mouseover, por eso usamos touchstart como sustituto.
        TC.Consts.event.CLICK = "touchstart";
    }

    // Gestión de errores
    if (!window.JL) {
        TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSNLOG);
    }
    JL.defaultAjaxUrl = TC.Consts.url.ERROR_LOGGER;

    const onError = (function () {
        var errorCount = 0;

        var mapObj;

        return function (e) {
            mapObj = mapObj || TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));

            var errorMsg, url = "", lineNumber = -1, column = -1, errorObj, apiError;

            if (e.type === "unhandledrejection") {
                errorMsg = e.reason ? e.reason.message : "";
                if (e.reason && e.reason.stack) {
                    apiError = e.reason.stack.indexOf(TC.apiLocation) >= 0;
                } else {
                    apiError = true;
                }
                errorObj = e.reason;
            } else {
                errorMsg = e.message;
                url = e.filename;
                lineNumber = e.lineno;
                column = e.colno;
                errorObj = e.error;
                apiError = url.indexOf(TC.apiLocation) >= 0;
            }
            
            // Si notifyApplicationErrors === false solo capturamos los errores de la API
            if ((TC.Cfg.notifyApplicationErrors || apiError) && errorCount < TC.Cfg.maxErrorCount && TC.Cfg.loggingErrorsEnabled) {
                // Send object with all data to server side log, using severity fatal, 
                // from logger "onerrorLogger"
                var msg = apiError ? TC.Consts.text.API_ERROR : TC.Consts.text.APP_ERROR;
                JL("onerrorLogger").fatalException({
                    "msg": msg,
                    "errorMsg": errorMsg,
                    "url": url,
                    "lineNumber": lineNumber,
                    "column": column,
                    "appUrl": location.href,
                    "apiVersion": TC.version,
                    "prevState": mapObj.getPreviousMapState(),
                    "userAgent": navigator.userAgent
                }, errorObj);
                errorCount++;

                if (!TC.isDebug) {
                    var DEFAULT_CONTACT_EMAIL = "webmaster@itracasa.es";
                    TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale)
                        .then(function () {
                            TC.error(TC.Util.getLocaleString(mapObj.options.locale, "genericError") + (mapObj.options.contactEmail || DEFAULT_CONTACT_EMAIL), { type: TC.Consts.msgType.ERROR });
                        });
                }
            }
            // Tell browser to run its own error handler as well   
            return false;
        };
    })();

    window.addEventListener('error', onError, false);
    window.addEventListener('unhandledrejection', onError, false);
});
/*!
    localForage -- Offline Storage, Improved
    Version 1.5.5
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&"object"==typeof a&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=c=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},c.resolve=k,c.reject=l,c.all=m,c.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!la)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function l(a){return new oa(function(b){var c=a.transaction(pa,sa),d=g([""]);c.objectStore(pa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function m(a){return"boolean"==typeof ma?oa.resolve(ma):l(a).then(function(a){return ma=a})}function n(a){var b=na[a.name],c={};c.promise=new oa(function(a){c.resolve=a}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function o(a){var b=na[a.name],c=b.deferredOperations.pop();c&&c.resolve()}function p(a,b){var c=na[a.name],d=c.deferredOperations.pop();d&&d.reject(b)}function q(a,b){return new oa(function(c,d){if(a.db){if(!b)return c(a.db);n(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=la.open.apply(la,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(pa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),o(a)}})}function r(a){return q(a,!1)}function s(a){return q(a,!0)}function t(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function u(a){return new oa(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function v(a){return g([k(atob(a.data))],{type:a.type})}function w(a){return a&&a.__local_forage_encoded_blob}function x(a){var b=this,c=b._initReady().then(function(){var a=na[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function y(a){n(a);for(var b=na[a.name],c=b.forages,d=0;d<c.length;d++)c[d]._dbInfo.db&&(c[d]._dbInfo.db.close(),c[d]._dbInfo.db=null);return q(a,!1).then(function(a){for(var b=0;b<c.length;b++)c[b]._dbInfo.db=a}).catch(function(b){throw p(a,b),b})}function z(a,b,c){try{var d=a.db.transaction(a.storeName,b);c(null,d)}catch(d){if(!a.db||"InvalidStateError"===d.name)return y(a).then(function(){var d=a.db.transaction(a.storeName,b);c(null,d)});c(d)}}function A(a){function b(){return oa.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];na||(na={});var f=na[d.name];f||(f={forages:[],db:null,dbReady:null,deferredOperations:[]},na[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=x);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return oa.all(g).then(function(){return d.db=f.db,r(d)}).then(function(a){return d.db=a,t(d,c._defaultConfig.version)?s(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function B(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),w(a)&&(a=v(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function C(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;w(d)&&(d=v(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function D(a,b,c){var d=this;a=j(a);var e=new oa(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===qa.call(b)?m(f.db).then(function(a){return a?b:u(b)}):b}).then(function(b){z(d._dbInfo,sa,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function E(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,sa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,sa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function G(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,ra,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function H(a,b){var c=this,d=new oa(function(b,d){if(a<0)return void b(null);c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function I(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,ra,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(){return"function"==typeof openDatabase}function K(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=ua.indexOf(a[b]),d=ua.indexOf(a[b+1]),e=ua.indexOf(a[b+2]),f=ua.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function L(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=ua[c[b]>>2],d+=ua[(3&c[b])<<4|c[b+1]>>4],d+=ua[(15&c[b+1])<<2|c[b+2]>>6],d+=ua[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function M(a,b){var c="";if(a&&(c=La.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===La.call(a.buffer))){var d,e=xa;a instanceof ArrayBuffer?(d=a,e+=za):(d=a.buffer,"[object Int8Array]"===c?e+=Ba:"[object Uint8Array]"===c?e+=Ca:"[object Uint8ClampedArray]"===c?e+=Da:"[object Int16Array]"===c?e+=Ea:"[object Uint16Array]"===c?e+=Ga:"[object Int32Array]"===c?e+=Fa:"[object Uint32Array]"===c?e+=Ha:"[object Float32Array]"===c?e+=Ia:"[object Float64Array]"===c?e+=Ja:b(new Error("Failed to get type for BinaryArray"))),b(e+L(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=va+a.type+"~"+L(this.result);b(xa+Aa+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function N(a){if(a.substring(0,ya)!==xa)return JSON.parse(a);var b,c=a.substring(Ka),d=a.substring(ya,Ka);if(d===Aa&&wa.test(c)){var e=c.match(wa);b=e[1],c=c.substring(e[0].length)}var f=K(c);switch(d){case za:return f;case Aa:return g([f],{type:b});case Ba:return new Int8Array(f);case Ca:return new Uint8Array(f);case Da:return new Uint8ClampedArray(f);case Ea:return new Int16Array(f);case Ga:return new Uint16Array(f);case Fa:return new Int32Array(f);case Ha:return new Uint32Array(f);case Ia:return new Float32Array(f);case Ja:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function O(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new oa(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){e.executeSql("CREATE TABLE IF NOT EXISTS "+c.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],function(){b._dbInfo=c,a()},function(a,b){d(b)})})});return c.serializer=Ma,e}function P(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Q(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function R(a,b,c,d){var e=this;a=j(a);var f=new oa(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){c.executeSql("INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(R.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function S(a,b,c){return R.apply(this,[a,b,c,1])}function T(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function U(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function V(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function W(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function X(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function Y(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&"function"==typeof localStorage.setItem}catch(a){return!1}}function Z(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function $(){return!Z()||localStorage.length>0}function _(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=c.name+"/",c.storeName!==b._defaultConfig.storeName&&(c.keyPrefix+=c.storeName+"/"),$()?(b._dbInfo=c,c.serializer=Ma,oa.resolve()):oa.reject()}function aa(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ba(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ca(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function da(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ea(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function fa(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function ga(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function ha(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new oa(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function ia(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function ja(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&(Pa(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ka="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},la=e();"undefined"==typeof Promise&&a(3);var ma,na,oa=Promise,pa="local-forage-detect-blob-support",qa=Object.prototype.toString,ra="readonly",sa="readwrite",ta={_driver:"asyncStorage",_initStorage:A,_support:f(),iterate:C,getItem:B,setItem:D,removeItem:E,clear:F,length:G,key:H,keys:I},ua="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",va="~~local_forage_type~",wa=/^~~local_forage_type~([^~]+)~/,xa="__lfsc__:",ya=xa.length,za="arbf",Aa="blob",Ba="si08",Ca="ui08",Da="uic8",Ea="si16",Fa="si32",Ga="ur16",Ha="ui32",Ia="fl32",Ja="fl64",Ka=ya+za.length,La=Object.prototype.toString,Ma={serialize:M,deserialize:N,stringToBuffer:K,bufferToString:L},Na={_driver:"webSQLStorage",_initStorage:O,_support:J(),iterate:Q,getItem:P,setItem:S,removeItem:T,clear:U,length:V,key:W,keys:X},Oa={_driver:"localStorageWrapper",_initStorage:_,_support:Y(),iterate:ca,getItem:ba,setItem:ha,removeItem:ga,clear:aa,length:fa,key:da,keys:ea},Pa=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},Qa={},Ra={},Sa={INDEXEDDB:ta,WEBSQL:Na,LOCALSTORAGE:Oa},Ta=[Sa.INDEXEDDB._driver,Sa.WEBSQL._driver,Sa.LOCALSTORAGE._driver],Ua=["clear","getItem","iterate","key","keys","length","removeItem","setItem"],Va={description:"",driver:Ta.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},Wa=function(){function a(b){d(this,a);for(var c in Sa)if(Sa.hasOwnProperty(c)){var e=Sa[c],f=e._driver;this[c]=f,Qa[f]||this.defineDriver(e)}this._defaultConfig=ja({},Va),this._config=ja({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ka(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new oa(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=Ua.concat("_initStorage"),g=0,h=f.length;g<h;g++){var i=f[g];if(!i||!a[i]||"function"!=typeof a[i])return void c(e)}var j=function(c){Qa[d]&&console.info("Redefining LocalForage driver: "+d),Qa[d]=a,Ra[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(j,c):j(!!a._support):j(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=Qa[a]?oa.resolve(Qa[a]):oa.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=oa.resolve(Ma);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=oa.reject(h),g._driverSet}var c=0;return b()}}var g=this;Pa(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return oa.resolve()}):oa.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=oa.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!Ra[a]},a.prototype._extend=function(a){ja(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=Ua.length;a<b;a++)ia(this,Ua[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),Xa=new Wa;b.exports=Xa},{3:3}]},{},[4])(4)});
/**
 * Opciones de capa.
 * Esta clase no tiene constructor.
 * @class TC.cfg.LayerOptions
 * @static
 */
/**
 * Identificador único de capa.
 * @property id
 * @type string|undefined
 */
/**
 * Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
 * @property title
 * @type string|undefined
 */
/**
 * Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {{#crossLink "TC.consts.LayerType"}}{{/crossLink}}.
 * @property type
 * @type string|undefined
 */
/**
 * Tipo MIME del formato de archivo de imagen a obtener del servicio. Si esta propiedad no está definida, se comprobará si la capa es un mapa de fondo 
 * (consultar propiedad {{#crossLink "TC.cfg.LayerOptions/isBase:property"}}{{/crossLink}}). En caso afirmativo, el formato elegido será <code>"image/jpeg"</code>, 
 * de lo contrario el formato será <code>"image/png"</code>.
 * @property format
 * @type string|undefined
 */
/**
 * La capa se muestra por defecto si forma parte de los mapas de fondo.
 * @property isDefault
 * @type boolean|undefined
 */
/**
 * La capa es un mapa de fondo.
 * @property isBase
 * @type boolean|undefined
 */
/**
 * Aplicable a capas de tipo WMS y KML. La capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
 * @property hideTree
 * @type boolean|undefined
 */
/**
 * La capa no muestra su título cuando es añadida al control de capas de trabajo.
 * @property hideTitle
 * @type boolean|undefined
 * @default false
 */
/**
 * La capa no aparece en la tabla de contenidos ni en la leyenda. De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
 * @property stealth
 * @type boolean|undefined
 */
/**
 * URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
 * @property thumbnail
 * @type string|undefined
 */
/**
 * Opciones de clustering de puntos.
 * @property cluster
 * @type TC.cfg.ClusterOptions|undefined
 */

/**
 * Árbol de elementos de capa.
 * Esta clase no tiene constructor.
 * @class TC.layer.LayerTree
 * @static
 */
/**
 * Nombre de capa en servicios WMS o WMTS.
 * @property name
 * @type string|undefined
 */
/**
 * Título de capa. Es un texto descriptivo para el usuario.
 * @property title
 * @type string|undefined
 */
/**
 * Identificador único de la capa.
 * @property uid
 * @type string|undefined
 */
/**
 * URL de la imagen con la leyenda de la capa.
 * @property legend
 * @type string|undefined
 */
/**
 * Lista de nodos hijos del nodo actual.
 * @property children
 * @type array|undefined
 */

/**
 * Capa de mapa. Esta clase no debería instanciarse directamente, sino mediante alguna de las clases que heredan de ella.
 * @class TC.Layer
 * @constructor
 * @async
 * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
 */
TC.Layer = function (options) {
    ///<summary>
    ///Constructor
    ///</summary>
    ///<param name="options" type="object">Objeto de opciones de capa.</param>
    ///<returns type="TC.Layer"></returns>
    var _layer = this;

    /**
     * Objeto de opciones de capa.
     * @property options
     * @type TC.cfg.LayerOptions
     * @default {}
     */
    _layer.options = options || {};
    TC.Util.extend(_layer, _layer.options);

    /**
     * Identificador de capa, debe ser único en el mapa. Si no se asigna en las opciones del constructor, se genera uno automáticamente.
     * @property id
     * @type string
     */
    _layer.id = _layer.options.id || TC.getUID();

    /**
     * Objeto del mapa al que pertenece la capa.
     * @property map
     * @type TC.Map|undefined
     */
    _layer.map = _layer.options.map;
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     */
    _layer.type = _layer.options.type || TC.Consts.layerType.WMS;

    /**
     * Fragmento HTML para utilizar como leyenda.
     * @property customLegend
     * @type string
     */
    _layer.customLegend = _layer.options.customLegend; 
    var defaultFormat = _layer.options.isBase ? TC.Consts.mimeType.JPEG : TC.Consts.mimeType.PNG;
    _layer.options.format = _layer.options.format || defaultFormat;

    if (_layer.options.hideTree === undefined) {
        _layer.options.hideTree = true;
    }

    if (_layer.options.hideTitle === undefined) {
        _layer.options.hideTitle = false;
    }

    _layer._cache = {
        visibilityStates: {}
    };

    /**
     * Árbol de los componentes de la capa. Estos componentes son distintos según el tipo de capa: así, en una capa WMS son las distintas capas del servicio, 
     * en una capa KML son carpetas.
     * @property tree
     * @type TC.layer.LayerTree|null
     */
    _layer.tree = null;

    /**
     * Objeto envoltorio de la capa nativa de OpenLayers.
     * @property wrap
     * @type TC.wrap.Layer|null
     */
    _layer.wrap = null;
};

TC.Layer.state = {
    IDLE: 'idle',
    LOADING: 'loading'
};

/**
 * Establece la visibilidad de la capa en el mapa.
 * @method setVisibility
 * @param {boolean} visible <code>true</code> si se quiere mostrar la capa, <code>false</code> si se quiere ocultarla.
 */
TC.Layer.prototype.setVisibility = function (visible) {
    this.wrap.setVisibility(visible);
};

/**
 * Obtiene la visibilidad actual de la capa en el mapa.
 * @method getVisibility
 * @return {boolean} <code>true</code> si la capa está visible, <code>false</code> si está oculta.
 */
TC.Layer.prototype.getVisibility = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.getVisibility();
        }
    }
    return result;
};


/**
 * Obtiene la opacidad actual de la capa en el mapa.
 * @method getOpacity
 * @return {number}.
 */
TC.Layer.prototype.getOpacity = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.layer.getOpacity();
        }
    }
    return result;
};

/**
 * Establece la opacidad de la capa en el mapa. Hay que tener en cuenta que establecer opacidad 0 a una capa no es 
 * equivalente que llamar a TC.Layer.{{#crossLink "TC.Layer/setVisibility:method"}}{{/crossLink}} con el valor del parámetro <code>false</code>.
 * @method setOpacity
 * @param {number} opacity Valor entre <code>0</code> (capa transparente) y <code>1</code> (capa opaca).
 * @param {boolean} mute Indica si al establecer opacidad no se lanza evento LAYEROPACITY.
 */
TC.Layer.prototype.setOpacity = function (opacity, mute) {
    var layer = this;
    this.wrap.getLayer().then(function (olLayer) {
        olLayer.setOpacity(opacity);
        layer.opacity = opacity;
        if (layer.map && !mute) {
            layer.map.trigger(TC.Consts.event.LAYEROPACITY, { layer: layer, opacity: opacity });
        }
    });
};

/**
 * Determina si la capa se puede mostrar en el CRS especificado.
 * @method isCompatible
 * @param {string} crs Cadena con el well-known ID (WKID) del CRS.
 * @return {boolean}
 */
TC.Layer.prototype.isCompatible = function (crs) {
    return true;
};

/**
 * Determina si la capa tiene nombres válidos.
 * @method isValidFromNames
 * @return {boolean}
 */
TC.Layer.prototype.isValidFromNames = function () {
    return true;
};

/**
 * Determina si la capa es de tipo raster.
 * @method isRaster
 * @return {boolean}
 */
TC.Layer.prototype.isRaster = function () {
    var result = true;
    var _layer = this;
    switch (_layer.type) {
        case TC.Consts.layerType.VECTOR:
        case TC.Consts.layerType.KML:
        case TC.Consts.layerType.WFS:
        case TC.Consts.layerType.GROUP:
            result = false;
            break;
        default:
            break;
    }
    return result;
};

/**
 * Determina si la capa es visible a la resolución actual. Para ello consulta el documento de capabilities en los casos en que exista.
 * @method isVisibleByScale
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByScale = function (name) {
    return true;
};


/**
 * Determina si una capa del servicio está establecida en el mapa como visible.
 * @method isVisibleByName
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByName = function (name) {
    return true;
};

/**
 * <p>Devuelve un árbol de información de la capa. Como mínimo devuelve un nodo raíz con el título de la capa.</p>
 * <p>En capas de servicios WMS es la jerarquía de capas obtenida del documento capabilities. Dependiendo del valor de la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/hideTree:property"}}{{/crossLink}}, 
 * puede mostrar un árbol de todas las capas del servicio o solo un árbol de las capas visibles inicialmente.</p>
 * <p>En capas de documentos KML cada nodo es una carpeta del documento.</p>
 * <p>Si la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/stealth:property"}}{{/crossLink}} está establecida a <code>true</code>, este método devuelve <code>null</code>.</p>
 * @method getTree
 * @return {TC.layer.LayerTree}
 */
TC.Layer.prototype.getTree = function () {
    var _layer = this;
    var result = { name: _layer.name, title: _layer.title };
    return result;
};

/**
 * Devuelve un nodo del árbol de información de la capa.
 * @method findNode
 * @param {string} id Identificador del nodo.
 * @param {TC.layer.LayerTree} parent Nodo desde el que se comienza la búsqueda.
 * @return {TC.layer.LayerTree} Si no se encuentra el nodo el método devuelve <code>null</code>.
 */
TC.Layer.prototype.findNode = function findNode(id, parent) {
    var result = null;
    if (parent.uid == id) {
        result = parent;
    }
    else {
        for (var i = 0; i < parent.children.length; i++) {
            var r = findNode(id, parent.children[i]);
            if (r) {
                result = r;
                break;
            }
        }
    }
    return result;
};


/**
 * Establece la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method setNodeVisibility
 * @param {string} id Identificador del nodo.
 * @param {boolean} visible <code>true</code> si se quiere mostrar el elemento, <code>false</code> si se quiere ocultar.
 */
TC.Layer.prototype.setNodeVisibility = function (id, visible) {
    this.setVisibility(visible);
};

/**
 * Obtiene la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method getNodeVisibility
 * @param {string} id Identificador del nodo.
 * @return {TC.consts.Visibility}
 */
TC.Layer.prototype.getNodeVisibility = function (id) {
    return TC.Consts.visibility.VISIBLE;
};


TC.Layer.prototype.getResolutions = function () {
    if (this.wrap.getResolutions) {
        return this.wrap.getResolutions();
    }
    else {
        return [];
    }
};

TC.Layer.prototype.setProjection = function () {
};

TC.control = TC.control || {};
TC.Control = function () {
    const self = this;
    TC.EventTarget.call(self);

    self.map = null;
    self.isActive = false;
    self.isDisabled = false;

    var len = arguments.length;

    self.options = TC.Util.extend({}, len > 1 ? arguments[1] : arguments[0]);
    self.id = self.options.id || TC.getUID(self.CLASS.substr(TC.Control.prototype.CLASS.length + 1) + '-');
    self.div = TC.Util.getDiv(self.options.div ? self.options.div : arguments[0]);
    if (TC._jQueryIsLoaded) {
        self._$div = $(self.div);
    }

    self.div.classList.add(TC.Control.prototype.CLASS, self.CLASS);
    
    self.template = self.options.template || self.template;
    self.exportsState = false;
};

TC.inherit(TC.Control, TC.EventTarget);

(function () {
    const ctlProto = TC.Control.prototype;

    ctlProto.CLASS = 'tc-ctl';

    ctlProto.template = '';

    ctlProto.show = function () {
        this.div.style.display = '';
    };

    ctlProto.hide = function () {
        this.div.style.display = 'none';
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(null, function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto._set1stRenderPromise = function (promise) {
        const self = this;
        if (!self._firstRender) {
            self._firstRender = promise;
        }
        return promise;
    };

    const processTemplates = function (ctl, data, templates) {
        return new Promise(function (resolve, reject) {
            const htmlPromises = [];
            const templateKeys = [];
            for (var key in templates) {
                var template = templates[key];
                if (typeof template === 'string') {
                    if (dust.cache[ctl.CLASS]) {
                        dust.render(ctl.CLASS, data, function (err, out) {
                            ctl.div.innerHTML = out;
                            if (err) {
                                TC.error(err);
                            }
                        });
                    } else {
                        var prom = TC.ajax({
                            url: template,
                            method: "GET",
                            responseType: 'text'
                        });
                        htmlPromises.push(prom);
                        templateKeys.push(key);
                    }
                }
                else if (TC.Util.isFunction(template)) {
                    template();
                }
            }

            if (htmlPromises.length === 0) {
                resolve();
            }
            else {
                Promise.all(htmlPromises)
                    .then(function (responseArray) {
                        responseArray
                            .map(response => response.data)
                            .forEach(function (template, idx) {
                            const tpl = dust.compile(template, templateKeys[idx]);
                            dust.loadSource(tpl);
                        });
                        resolve();
                    })
                    .catch(function (err) {
                        console.error("Error fetching templates: " + err);
                        reject(err instanceof Error ? err : Error(err));
                    });
            }

        });
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.map) {
                self.trigger(TC.Consts.event.BEFORECONTROLRENDER, { dataObject: data });
            }
            self.div.classList.toggle(TC.Consts.classes.DISABLED, self.isDisabled);

            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    var tplProm;

                    if (typeof self.template === 'object') {
                        tplProm = processTemplates(self, data, self.template);
                    }
                    else {
                        var templates = {};

                        if (self.template) templates[self.CLASS] = self.template;


                        tplProm = processTemplates(self, data, templates);
                    }

                    tplProm
                        .then(function () {
                            if (dust.cache[self.CLASS]) {
                                dust.render(self.CLASS, data, function (err, out) {
                                    self.div.innerHTML = out;
                                    if (err) {
                                        reject(Error(err));
                                        TC.error(err);
                                    }
                                });
                            }

                            self.trigger(TC.Consts.event.CONTROLRENDER);
                            if (TC.Util.isFunction(callback)) {
                                callback();
                            }
                            resolve();
                        })
                        .catch(function (err) {
                            reject(Error(err));
                        });
                }
            );
        });
    };

    ctlProto.getRenderedHtml = function (templateId, data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var render = function () {
                if (dust.cache[templateId]) {
                    dust.render(templateId, data, function (err, out) {
                        if (err) {
                            TC.error(err);
                            reject(Error(err));
                        }
                        else {
                            if (TC.Util.isFunction(callback)) {
                                callback(out);
                            }
                            resolve(out);
                        }
                    });
                }
            };
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    if (!dust.cache[templateId]) {
                        var template = self.template[templateId];
                        if (typeof template === 'string') {
                            TC.ajax({
                                url: template,
                                method: "GET",
                                responseType: 'text'
                            })
                                .then(function (response) {
                                    const html = response.data;
                                    var tpl = dust.compile(html, templateId);
                                    dust.loadSource(tpl);
                                    render();
                                })
                                .catch(function (err) {
                                    console.log("Error fetching template: " + err)
                                });
                        }
                        else if (TC.Util.isFunction(template)) {
                            template();
                            render();
                        }
                    }
                    else {
                        render();
                    }
                }
            );
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.map = map;
            Promise.resolve(self.render()).then(function () {
                if (self.options.active) {
                    self.activate();
                }
                resolve(self);
            });
        });
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.map && self.map.activeControl && self.map.activeControl != self) {
            self.map.previousActiveControl = self.map.activeControl;
            self.map.activeControl.deactivate();
        }
        self.isActive = true;
        if (self.map) {
            self.map.activeControl = self;
            self.map.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
        }
    };

    ctlProto.deactivate = function (stopChain) {
        if (arguments.length == 0) stopChain = false;

        var self = this;
        self.isActive = false;
        if (self.map) {
            self.map.activeControl = null;

            if (!stopChain) {
                //determinar cuál es el control predeterminado para reactivarlo
                //salvo que sea yo mismo, claro
                var nextControl = self.map.getDefaultControl();
                if (nextControl == self) nextControl = null;
                else if (self.map.previousActiveControl == self) // GLS: Validamos antes de activar que el control activo anterior sea distinto al control actual
                    nextControl = null;
                else if (!nextControl) {
                    nextControl = self.map.previousActiveControl;
                }

                if (nextControl)
                    nextControl.activate();
            }
            self.map.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
        }
    };

    ctlProto.enable = function () {
        var self = this;
        self.isDisabled = false;
        if (self.div) {
            self.div.classList.remove(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.disable = function () {
        var self = this;
        self.isDisabled = true;
        if (self.div) {
            self.div.classList.add(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.renderPromise = function () {
        const self = this;
        return self._firstRender || new Promise(function (resolve, reject) {
            self.one(TC.Consts.event.CONTROLRENDER, function () {
                resolve(self);
            });
        });
    };

    ctlProto.addUIEventListener = function (selector, event, listener) {
        const self = this;
        const elements = selector ? self.div.querySelectorAll(selector) : [self.div];
        elements.forEach(function (elm) {
            elm.addEventListener(event, listener);
        });
    };

    ctlProto.addUIEventListeners = function () {
    };

    ctlProto.isExclusive = function () {
        return false;
    };

    ctlProto.getLocaleString = function (key, texts) {
        var self = this;
        var locale = self.map ? self.map.options.locale : TC.Cfg.locale;
        return TC.Util.getLocaleString(locale, key, texts);
    };

    ctlProto.getUID = function () {
        const self = this;
        return TC.getUID(self.id + '-');
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {};
        }
        return null;
    };

    ctlProto.importState = function (state) {
    };
})();
TC.feature = TC.feature || {};
TC.Feature = function (coords, options) {
    var self = this;

    self.wrap = new TC.wrap.Feature();
    self.wrap.parent = self;
    if (self.wrap.isNative(coords)) {
        self.wrap.feature = coords;
        coords._wrap = self.wrap;
        self.id = self.wrap.getId();
        self.geometry = self.wrap.getGeometry();
        if (coords._folders) {
            self.folders = coords._folders;
        }
        self.data = self.wrap.getData();
    }

    var opts = self.options = TC.Util.extend(true, {}, options);

    self.id = self.id || opts.id || TC.getUID();
    self.data = opts.data || self.data || null;
    self._visibilityState = TC.Consts.visibility.VISIBLE;
    if (opts.showsPopup === undefined) {
        self.showsPopup = true;
    }
    else {
        self.showsPopup = opts.showsPopup;
    }
    self.layer = opts.layer || null;
    self._selected = false;

    if (opts.selected) {
        self.select();
    }
};

TC.Feature.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.Feature.prototype.CLASSNAME = 'TC.Feature';

TC.Feature.prototype.getPath = function () {
    var result = [];
    var self = this;
    if (self.folders) {
        result = self.folders;
    }
    else if (self.options.group) {
        result = [self.options.group];
    }
    return result;
};

TC.Feature.prototype.setVisibility = function (visible) {
    var self = this;

    // Ocultamos el posible popup
    if (!visible && self.showsPopup && self.layer) {
        var popup = self.layer.map.getControlsByClass(TC.control.Popup).filter(function (popup) {
            return popup.currentFeature === self
        });

        if (popup.length > 0) {
            popup[0].hide();
        }
    }

    if ((visible && self._visibilityState === TC.Consts.visibility.NOT_VISIBLE) || (!visible && self._visibilityState === TC.Consts.visibility.VISIBLE)) {
        self._visibilityState = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
        self.layer.wrap.setFeatureVisibility(self, visible);
    }
};

TC.Feature.prototype.setId = function (id) {
    var self = this;
    self.id = id;
    self.wrap.setId(id);
};

TC.Feature.prototype.getBounds = function () {
    return this.wrap.getBounds();
};

TC.Feature.prototype.setStyle = function (style) {
    this.wrap.setStyle(style);
};

TC.Feature.prototype.toggleSelectedStyle = function (condition) {
    this.wrap.toggleSelectedStyle(condition);
};

TC.Feature.prototype.getLegend = function () {
    var self = this;
    if (!self._legend) {
        self._legend = self.wrap.getLegend();
    }
    return self._legend;
};

TC.Feature.prototype.getCoords = function () {
    const self = this;
    self.geometry = self.wrap.getGeometry();
    return self.geometry;
};

TC.Feature.prototype.getCoordsArray = function () {
    const self = this;
    const isPoint = function (elm) {
        return Array.isArray(elm) && elm.length >= 2 && typeof elm[0] === 'number' && typeof elm[1] === 'number';
    };
    const flattenFn = function (val) {
        return isPoint(val) ? [val] : val.reduce(reduceFn, []);
    }
    const reduceFn = function (acc, elm) {
        if (isPoint(elm)) {
            acc[acc.length] = elm;
        }
        else {
            acc = acc.concat(flattenFn(elm));
        }
        return acc;
    };
    return flattenFn(self.getCoords());
};

TC.Feature.prototype.getGeometryStride = function () {
    const self = this;
    const coordsArray = self.getCoordsArray();
    const firstCoord = coordsArray[0];
    if (firstCoord) {
        return firstCoord.length;
    }
    return 0;
}


TC.Feature.prototype.setCoords = function (coords) {
    const self = this;

    const toNumberCoords = function (arr) {
        arr.forEach(function (elm, idx) {
            if (Array.isArray(elm)) {
                toNumberCoords(elm);
            }
            else {
                if (typeof elm !== 'number') {
                    console.log('Warning: coordinate does not have number type');
                    arr[idx] = parseFloat(elm);
                }
            }
        });
    };

    if (Array.isArray(coords)) {
        toNumberCoords(coords);
    }

    self.geometry = coords;
    return self.wrap.setGeometry(coords);
};

TC.Feature.prototype.getData = function () {
    var result = null;
    var self = this;
    if (self.data) {
        result = self.data;
    }
    else {
        result = self.wrap.getData();
    }
    return result;
};

TC.Feature.prototype.setData = function (data) {
    var self = this;
    self.data = TC.Util.extend(self.data, data);
    self.wrap.setData(data);
};

TC.Feature.prototype.clearData = function () {
    var self = this;
    self.data = {};
    self.wrap.clearData();
};

TC.Feature.prototype.getInfo = function (options) {
    var result = null;
    var self = this;
    options = options || {};
    var locale = options.locale || (self.layer && self.layer.map && TC.Util.getMapLocale(self.layer.map));
    var data = self.getData();
    if (typeof data === 'object') {
        var template = self.wrap.getTemplate();
        if (template) {
            // GLS: Contemplo en la expresión regular la opción de que el nombre del campo se componga de $[aaa/abc/loQueMeInteresa] 
            // (la expresión no está limitada a 2 niveles), hasta ahora se manejaba $[loQueMeInteresa]
            result = template.replace(/\$\[?(?:\w+\/)*(\w+)\]/g, function (match, p1) {
                return data[p1];
            });
        }
        else {
            var html = [];
            const hSlots = [];
            const openText = TC.Util.getLocaleString(locale, 'open');
            const titleText = TC.Util.getLocaleString(locale, 'linkInNewWindow');
            for (var key in data) {
                const value = data[key];
                const match = key.match(/^h(\d)_/i);
                if (match) {
                    hSlots[match[1]] = value;
                }
                else {
                    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined') {
                        html[html.length] = '<tr><th>';
                        html[html.length] = key;
                        html[html.length] = '</th><td>';
                        var isUrl = TC.Util.isURL(value);
                        if (isUrl) {
                            html[html.length] = '<a href="';
                            html[html.length] = value;
                            html[html.length] = '" target="_blank" title="';
                            html[html.length] = titleText;
                            html[html.length] = '">';
                            html[html.length] = openText;
                            html[html.length] = '</a>';
                        }
                        else {
                            html[html.length] = value !== undefined ? TC.Util.formatNumber(value, locale) : '&mdash;';
                        }
                        html[html.length] = '</td></tr>';
                    }
                }
            }
            const headers = hSlots
                .map(function (val, idx) {
                    if (val) {
                        return '<h' + idx + '>' + val + '</h' + idx + '>';
                    }
                })
                .filter(function (val) {
                    return val;
                });
            if (headers.length) {
                html = headers.concat(html);
            }
            if (html.length > 0) {
                html.unshift('<table class="tc-attr">');
                html[html.length] = '</table>';
                result = html.join('');
            }
        }
    }
    else if (typeof data === 'string') {
        result = data;
    }
    if (!result) {
        result = self.title;
        if (self.group) {
            result += ' ' + self.group;
        }
    }
    if (!result) {
        result = TC.Util.getLocaleString(locale, 'noData');
    }
    return result;
};

TC.Feature.prototype.clone = function () {
    var self = this;
    var nativeClone = self.wrap.cloneFeature();
    nativeClone._wrap = self.wrap;
    return new self.constructor(nativeClone, self.options);
};

TC.Feature.prototype.getStyle = function () {
    return this.wrap.getStyle();
};

TC.Feature.prototype.showPopup = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;
        var popup = control || self.popup;
        if (!popup) {
            // Buscamos un popup existente que no esté asociado a un control.
            var popups = map.getControlsByClass('TC.control.Popup');
            for (var i = 0, len = popups.length; i < len; i++) {
                var p = popups[i];
                if (!p.caller) {
                    popup = p;
                    break;
                }
            }
        }
        if (popup) {
            popup.currentFeature = self;
            ctlPromise = Promise.resolve(popup);
        }
        else {
            ctlPromise = map.addControl('popup');
        }
        ctlPromise.then(function (ctl) {            
            ctl.currentFeature = self;
            map.getControlsByClass(TC.control.Popup).forEach(function (p) {
                if (p.isVisible()) {
                    p.hide();
                }
            });
            self.wrap.showPopup(ctl);
            // Ajustamos el ancho del título al de la tabla de atributos
            const attrTable = ctl.contentDiv.querySelector("table.tc-attr");
            const headers = ctl.contentDiv.querySelectorAll("h1,h2,h3,h4,h5");
            if (attrTable && headers.length) {
                const maxWidth = attrTable.getBoundingClientRect().width + 'px';
                headers.forEach(function (h) {
                    h.style.maxWidth = maxWidth;
                });
            }
            map.trigger(TC.Consts.event.POPUP, { control: ctl });
            ctl.fitToView(true);
        });
    }
};

TC.Feature.prototype.showResultsPanel = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;
        var panel = control;
        if (!panel) {
            // Buscamos un resultsPanel existente que no esté asociado a un control.
            var resultsPanels = map.getControlsByClass('TC.control.ResultsPanel').filter(function (ctrl) { return ctrl.options.content === "table" });
            for (var i = 0, len = resultsPanels.length; i < len; i++) {
                var p = resultsPanels[i];
                if (!p.caller) {
                    panel = p;
                    break;
                }
            }
        }
        if (panel) {
            panel.currentFeature = self;
            ctlPromise = Promise.resolve(panel);
        }
        else {
            var resultsPanelOptions = {
                content: "table"
            };            
            var controlContainer = map.getControlsByClass('TC.control.ControlContainer')[0];
            if (controlContainer) {
                resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
            } else {
                resultsPanelOptions.div = document.createElement('div');
                map.div.appendChild(resultsPanelOptions.div);
                ctlPromise = map.addControl('resultsPanel', resultsPanelOptions);
            }
        }
        ctlPromise.then(function (ctl) {            
            ctl.currentFeature = self;

            // GLS: si contamos con el contenedor de controles no es necesario cerra el resto de paneles ya que no habrá solape excepto los paneles
            if (map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctrl) { return ctrl.options.content === "table" }).forEach(function (p) {
                    p.close();
                });
            }

            // cerramos los paneles con feature asociada
            const panels = map.getControlsByClass('TC.control.ResultsPanel');
            panels.forEach(function (p) {
                if (p.currentFeature) {
                    p.close();
                }
            });

            if (ctl.div.querySelector('.tc-ctl-print-btn')) {
                ctl.div.querySelector('.tc-ctl-print-btn').remove();
            }
            ctl.menuDiv.innerHTML = '';
            ctl.open(self.getInfo({ locale: map.options.locale }), ctl.getInfoContainer());            

            var onViewChange = function (e) {
                map.off(TC.Consts.event.VIEWCHANGE, onViewChange);

                ctl.close();
            };
            map.on(TC.Consts.event.VIEWCHANGE, onViewChange);
        });
    }
};


TC.Feature.prototype.select = function () {
    var self = this;
    self._selected = true;
    if (self.layer) {
        self.layer.selectedFeatures.push(self);
    }
    var selectionOptions = self.options.selection || {};
    self.setStyle(TC.Util.extend({}, TC.Cfg.styles.selection[self.STYLETYPE], selectionOptions[self.STYLETYPE]));
};

TC.Feature.prototype.unselect = function () {
    const self = this;
    self._selected = false;
    // Volvemos al estilo por defecto
    self.setStyle(self.options);

    if (self.layer) {
        const idx = self.layer.selectedFeatures.indexOf(self);
        if (idx >= 0) {
            self.layer.selectedFeatures.splice(idx, 1);
        }
    }
};

TC.Feature.prototype.isSelected = function () {
    return this._selected;
};

TC.Feature.prototype.toGML = function (version, srsName) {
    return this.wrap.toGML(version, srsName);
};



TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/**
 * <p>Opciones de estilo de punto. Esta clase no tiene constructor.</p>
 * @class TC.cfg.PointStyleOptions
 * @static
 */
/**
 * Radio en píxeles del símbolo del punto.
 * @property radius
 * @type number
 * @default 8
 */
/**
 * Color de relleno del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property fillColor
 * @type string
 */
/**
 * Opacidad de relleno del símbolo del punto. Número entre 0 (transparente) y 1 (opaco).
 * @property fillOpacity
 * @type number
 */
/**
 * Color de línea del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property strokeColor
 * @type string
 */
/**
 * Ancho de línea en píxeles del símbolo del punto.
 * @property strokeWidth
 * @type number
 * @default 2
 */
/**
 * Nombre del grupo en el que incluir el punto. Los grupos de puntos son entidades para facilitar la organización de estos, 
 * ya que un grupo se mostrará en la tabla de contenidos y en la leyenda.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Point = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.feature = coords;
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.point, options);
        self.wrap.createPoint(coords, options);
    }
};

TC.inherit(TC.feature.Point, TC.Feature);

TC.feature.Point.prototype.STYLETYPE = TC.Consts.geom.POINT;

TC.feature.Point.prototype.CLASSNAME = 'TC.feature.Point';

TC.feature.Point.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [coords];
    }
    return coords;
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

TC.feature.Circle = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createCircle(coords, options);
    }
};

TC.inherit(TC.feature.Circle, TC.Feature);

(function () {
    var featProto = TC.feature.Circle.prototype;

    featProto.STYLETYPE = TC.Consts.geom.POLYGON;

    featProto.CLASSNAME = 'TC.feature.Circle';

    featProto.getCoords = function () {
        return this.wrap.getGeometry();

    };

    featProto.setCoords = function (coords) {
        const self = this;
        if (Array.isArray(coords) &&
            Array.isArray(coords[0])
            && !Array.isArray(coords[0][0]) && !Array.isArray(coords[0][1])
            && !Array.isArray(coords[1])) {
            return TC.Feature.prototype.setCoords.call(self, coords);
        }
        else {
            throw new Error('Coordinates not valid for circle');
        }
    };

})();
TC.feature = TC.feature || {};

if (!TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}

/**
 * <p>Opciones de estilo de marcador (punto de mapa con icono). Esta clase no tiene constructor.</p>
 * @class TC.cfg.MarkerStyleOptions
 * @static
 */
/**
 * URL de la imagen del icono del marcador.
 * @property url
 * @type string
 */
/**
 * Clase CSS de la que obtener el icono del marcador, extrayendo la URL de la imagen del atributo <code>background-image</code> asociado a la clase.
 * @property cssClass
 * @type string
 * @default "tc-marker1"
 */
/**
 * Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo <code>background-image</code> asociado a la clase.
 * @property classes
 * @type array
 * @default ["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]
 */
/**
 * Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono.
 * @property anchor
 * @type array
 * @default [.5, 1]
 */
/**
 * Anchura en píxeles del icono.
 * @property width
 * @type number
 * @default 32
 */
/**
 * Altura en píxeles del icono.
 * @property height
 * @type number
 * @default 32
 */
/**
 * Nombre del grupo en el que incluir el marcador. Los grupos de marcadores son entidades para facilitar la organización de estos: 
 * por un lado, un grupo se mostrará en la tabla de contenidos y en la leyenda, por otro, si no se especifica explícitamente un icono para el marcador, 
 * todos los marcadores del mismo grupo tendrán el mismo icono. La asignación de icono a grupo se hará rotando entre los elementos de la propiedad 
 * {{#crossLink "TC.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Marker = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.marker, options);
        var locale = self.layer && self.layer.map ? self.layer.map.options.locale: TC.Cfg.locale;
        self.title = options.title || TC.i18n[locale][TC.Consts.MARKER];
        self.wrap.createMarker(coords, options);
    }
};

TC.inherit(TC.feature.Marker, TC.feature.Point);

TC.feature.Marker.prototype.STYLETYPE = 'marker';

TC.feature.Marker.prototype.CLASSNAME = 'TC.feature.Marker';
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * MultiPolygon
 * Parameters: coords, array of array of array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolygon = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createMultiPolygon(coords, options);
    }
};

TC.inherit(TC.feature.MultiPolygon, TC.Feature);

TC.feature.MultiPolygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.MultiPolygon.prototype.CLASSNAME = 'TC.feature.MultiPolygon';

TC.feature.MultiPolygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], [].concat.apply([], coords));
    }
    return coords;
};

TC.feature.MultiPolygon.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0])) {
        if (!Array.isArray(coords[0][0])) {
            coords = [[coords]];
        }
        else if (!Array.isArray(coords[0][0][0])) {
            coords = [coords];
        }
    }
    else {
        throw new Error('Coordinates not valid for multipolygon');
    }
    coords.forEach(function (polygon) {
        polygon.forEach(function (ring) {
            const startPoint = ring[0];
            const endPoint = ring[ring.length - 1];
            if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
                ring[ring.length] = startPoint;
            }
        });
    });
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.MultiPolygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolyline = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.line, options);
        self.wrap.createMultiPolyline(coords, options);
    }
};

TC.inherit(TC.feature.MultiPolyline, TC.Feature);

TC.feature.MultiPolyline.prototype.STYLETYPE = "line";

TC.feature.MultiPolyline.prototype.CLASSNAME = 'TC.feature.MultiPolyline';

TC.feature.MultiPolyline.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.MultiPolyline.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0]) && !Array.isArray(coords[0][0])) {
        coords = [coords];
    }
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.MultiPolyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polygon
 * Parameters: coords, array of array of 2 element arrays of numbers; options, object
 */
TC.feature.Polygon = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createPolygon(coords, options);
    }
};

TC.inherit(TC.feature.Polygon, TC.Feature);

TC.feature.Polygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.Polygon.prototype.CLASSNAME = 'TC.feature.Polygon';

TC.feature.Polygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.Polygon.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0])) {
        if (!Array.isArray(coords[0][0])) {
            coords = [coords];
        }
    }
    else {
        throw new Error('Coordinates not valid for polygon');
    }
    coords.forEach(function (ring) {
        const startPoint = ring[0];
        const endPoint = ring[ring.length - 1];
        if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
            ring[ring.length] = startPoint;
        }
    });
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.Polygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};

TC.feature.Polygon.prototype.getArea = function (options) {
    return this.wrap.getArea(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.Polyline = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        options = self.options = TC.Util.extend(true, self.options, TC.Cfg.styles.line, options);
        self.wrap.createPolyline(coords, options);
    }
};

TC.inherit(TC.feature.Polyline, TC.Feature);

TC.feature.Polyline.prototype.STYLETYPE = "line";

TC.feature.Polyline.prototype.CLASSNAME = 'TC.feature.Polyline';

TC.feature.Polyline.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && !Array.isArray(coords[0])) {
        coords = [coords];
    }
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.Polyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.filter = {};

TC.filter.Filter = function (tagName) {
    this.tagName_ = tagName;
    
    this._defaultNSURL = "http://www.opengis.net/ogc";
    this._defaultPrefixNS = this._wfsPrefixNS = "ogc";
    this._fieldTitle = "PropertyName";

    this._defaultNSURL = this._wfsNSURL = "http://www.opengis.net/ogc";
    this._wfs2prefixNS = "fes";
    this._wfs2NSURL = "http://www.opengis.net/fes/2.0";
    this._wfs2FieldTitle = "ValueReference";
};

TC.filter.Filter.prototype.getTagName = function () {
    return this.tagName_;
};

TC.filter.Filter.prototype.writeFilterCondition_ = function () {

    //return '<{prefix}:{tag}>{childs}</{prefix}:{tag}>'.format({prefix:"ogc",tag:filter.getTagName(),childs:""});
    var filter = this;
    return '<{prefix}:Filter xmlns:{prefix}=\"{NSURL}">{inner}</{prefix}:Filter>'.format({
        prefix: this._defaultPrefixNS,
        NSURL: this._defaultNSURL,
        tag: filter.getTagName(),
        inner: this.writeInnerCondition_(filter)
    });

    /*ol.xml.pushSerializeAndPop(item,
        ol.format.WFS.GETFEATURE_SERIALIZERS_,
        ol.xml.makeSimpleNodeFactory(filter.getTagName()),
        [filter], objectStack);*/
}
TC.filter.Filter.prototype.writeInnerCondition_ = function (filter) {
    if (filter != this) {
        filter._defaultNSURL = this._defaultNSURL;
        filter._defaultPrefixNS = this._defaultPrefixNS
    }

    if (filter instanceof TC.filter.LogicalNary) {
        return filter.write()
    }
    else if (filter instanceof TC.filter.ComparisonBinary) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Comparison) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Spatial) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Function) {
        return filter.write();
    }
    else
        return filter.write();
};
TC.filter.Filter.prototype.writeInnerArrayCondition_ = function (filters) {
    return filters.reduce(function (vi, va, index) {
        return (vi instanceof TC.filter.Filter ? vi.writeInnerCondition_(vi) : vi) + va.writeInnerCondition_(va);
    });
}

TC.filter.Filter.prototype.getText = function (wfsVersion) {
    if (wfsVersion && parseFloat(wfsVersion,10) >= 2) {
        this._defaultPrefixNS = this._wfs2prefixNS;
        this._defaultNSURL = this._wfs2NSURL;
        this._fieldTitle = this._wfs2FieldTitle;
    }
    return this.writeFilterCondition_();
};

TC.filter.and = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.And, params));
};

TC.filter.or = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.Or, params));
};

TC.filter.not = function (condition) {
    return new TC.filter.Not(condition);
};

TC.filter.bbox = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Bbox(null, arguments[0], arguments[1]);
    else        
        return new TC.filter.Bbox(arguments[0], arguments[1], arguments[2]);
};

TC.filter.intersects = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Intersects(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Intersects(arguments[0], arguments[1], arguments[2]);
};


TC.filter.within = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Within(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Within(arguments[0], arguments[1], arguments[2]);
};


TC.filter.equalTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.EqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.notEqualTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.NotEqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.lessThan = function (propertyName, expression) {
    return new TC.filter.LessThan(propertyName, expression);
};

TC.filter.lessThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.LessThanOrEqualTo(propertyName, expression);
};

TC.filter.greaterThan = function (propertyName, expression) {
    return new TC.filter.GreaterThan(propertyName, expression);
};

TC.filter.greaterThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.GreaterThanOrEqualTo(propertyName, expression);
};

TC.filter.isNull = function (propertyName) {
    return new TC.filter.IsNull(propertyName);
};

TC.filter.between = function (propertyName, lowerBoundary, upperBoundary) {
    return new TC.filter.IsBetween(propertyName, lowerBoundary, upperBoundary);
};

TC.filter["function"] = function (functionName, params) {
    return new TC.filter.Function(functionName, params);
};

TC.filter.like = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    return new TC.filter.IsLike(propertyName, pattern,
        opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
};

TC.filter.LogicalNary = function (tagName, conditions) {

    TC.filter.Filter.call(this, tagName);

    this.conditions = Array.prototype.slice.call(arguments, 1);
};
TC.inherit(TC.filter.LogicalNary, TC.filter.Filter);

TC.filter.And = function (conditions) {
    var params = ['And'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.And, TC.filter.LogicalNary);

TC.filter.Or = function (conditions) {
    var params = ['Or'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.Or, TC.filter.LogicalNary);

TC.filter.LogicalNary.prototype.write = function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerArrayCondition_(this.conditions)
    });
}

TC.filter.Not = function (condition) {
    this.condition = condition;
    TC.filter.Filter.call(this, 'Not');
    
};
TC.inherit(TC.filter.Not, TC.filter.Filter);

TC.filter.Filter.prototype.write=function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerCondition_(this.condition)
    });
}


TC.filter.Bbox = function (geometryName, extent, opt_srsName) {

    TC.filter.Filter.call(this, 'BBOX');

    this.geometryName = geometryName;

    this.extent = extent;

    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Bbox, TC.filter.Filter);

TC.filter.Comparison = function (tagName, propertyName) {

    TC.filter.Filter.call(this, tagName);

    this.propertyName = propertyName;
};
TC.inherit(TC.filter.Comparison, TC.filter.Filter);

TC.filter.Comparison.prototype.write = function () {
    var values = '';
    //isbetween
    if (this.lowerBoundary && this.upperBoundary)
        values = '<{prefix}:LowerBoundary><{prefix}:Literal>{LowerBoundary}</{prefix}:Literal></{prefix}:LowerBoundary><{prefix}:UpperBoundary><{prefix}:Literal>{UpperBoundary}</{prefix}:Literal></{prefix}:UpperBoundary>'.format({
            prefix:this._defaultPrefixNS,
            LowerBoundary: this.lowerBoundary,
            UpperBoundary: this.upperBoundary
        });
    if (this.pattern)
        values = '<{prefix}:Literal>{Pattern}</{prefix}:Literal>'.format({
            prefix: this._defaultPrefixNS,
            Pattern: this.pattern
        });
    if (this.params)
        if (Array.isArray(this.params))
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (text) {
                    return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: text });
                }
                return (i > 0 ? a : fmt(a)) + fmt(b);
            });
        else
            values = '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: this.params });

    return '<{prefix}:{tag}{matchCase}{escape}{singleChar}{wildCard}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{values}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        escape: (typeof (this.escapeChar) !== "undefined" ? " escape=\"" + this.escapeChar + "\"" : ""),
        singleChar: (typeof (this.singleChar) !== "undefined" ? " singleChar=\"" + this.singleChar + "\"" : ""),
        wildCard: (typeof (this.wildCard) !== "undefined" ? " wildCard=\"" + this.wildCard + "\"" : ""),
        name: this.propertyName,
        values: values,
        fieldTitle: this._fieldTitle
    });
}

TC.filter.ComparisonBinary = function (
    tagName, propertyName, expression, opt_matchCase) {

    TC.filter.Comparison.call(this, tagName, propertyName);

    this.expression = expression;

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.ComparisonBinary, TC.filter.Comparison);

TC.filter.ComparisonBinary.prototype.write = function () {
    var _str = '<{prefix}:{tag}{matchCase}>' + (this.propertyName instanceof TC.filter.Filter ? '{name}' : '<{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>') + '<{prefix}:Literal>{value}</{prefix}:Literal></{prefix}:{tag}>';
    return _str.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        //escape:(typeof(this.escapeChar)!=="undefined"? " escape=\"" + this.escapeChar+ "\"":""),
        //singleChar:(typeof(this.singleChar)!=="undefined"? " singleChar=\"" + this.singleChar+ "\"":""),
        //wildCard:(typeof(this.wildCard)!=="undefined"? " wildCard=\"" + this.wildCard+ "\"":""),
        name: this.propertyName instanceof TC.filter.Filter ? this.propertyName.write() : this.propertyName,
        value: this.expression,
        fieldTitle: this._fieldTitle
    });
}
TC.filter.EqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.EqualTo, TC.filter.ComparisonBinary);

TC.filter.GreaterThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThan', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThan, TC.filter.ComparisonBinary);

TC.filter.GreaterThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.LessThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThan', propertyName, expression);
};
TC.inherit(TC.filter.LessThan, TC.filter.ComparisonBinary);

TC.filter.LessThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.LessThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.NotEqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.NotEqualTo, TC.filter.ComparisonBinary);

TC.filter.IsLike = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    TC.filter.Comparison.call(this, 'PropertyIsLike', propertyName);

    this.pattern = pattern;

    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';

    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';

    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.IsLike, TC.filter.Comparison);

TC.filter.IsNull = function (propertyName) {
    TC.filter.Comparison.call(this, 'PropertyIsNull', propertyName);
};
TC.inherit(TC.filter.IsNull, TC.filter.Comparison);

TC.filter.IsBetween = function (propertyName, lowerBoundary, upperBoundary) {
    TC.filter.Comparison.call(this, 'PropertyIsBetween', propertyName);
    this.lowerBoundary = lowerBoundary;
    this.upperBoundary = upperBoundary;
};
TC.inherit(TC.filter.IsBetween, TC.filter.Comparison);

TC.filter.Function = function (functionName, params) {
    TC.filter.Filter.call(this, functionName);
    this.params = params
};
TC.inherit(TC.filter.Function, TC.filter.Filter);

TC.filter.Function.prototype.write = function () {
    var values = '';
    if (this.params) {
        var _paramsToText = function (param, prefix) {
            if (typeof (param) === "string") {
                return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: prefix, value: param });
            }
            if (typeof (param) === "object") {
                var _text = '';
                for (var attr in param) {
                    _text = _text + '<{prefix}:{key}>{value}</{prefix}:{key}>'.format({ prefix: prefix, value: param[attr], key: attr })
                }
                return _text;
            }
        }
        if (Array.isArray(this.params)) {
            var prefix = this._defaultPrefixNS;
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (param) {
                    return _paramsToText(param, prefix);
                }
                return (i > 1 ? a : fmt(a)) + fmt(b);
            });
        }
        else
            values = _paramsToText(this.params, this._defaultPrefixNS);
    }
    return '<{prefix}:Function name="{tag}">{inner}</{prefix}:Function>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: values
    });
};

TC.filter.Spatial = function (tagName, geometryName, geometry, opt_srsName) {
    TC.filter.Filter.call(this, tagName);
    this.geometryName = geometryName;
    this.geometry = geometry;
    this.srsName = opt_srsName;
    this.wrap = new TC.wrap.Filter(this);
};

TC.wrap.Filter = function (filter) {
    this.parent = filter;
};

TC.wrap.Filter.prototype.getAxisOrientation = function () {
    // Establecemos el srsName a EPSG:xxxx o urn:x-ogc:def:crs:EPSG:xxxx dependiendo del orden de eje de coordenadas del CRS.
    // Esto se debe a que GeoServer hace asunciones en el orden de los ejes dependiendo del formato de srsName que se use.
    // Más información: https://docs.geoserver.org/latest/en/user/services/wfs/basics.html#wfs-basics-axis
    var srsName = this.parent.srsName;
    if (srsName) {
        const match = srsName.match(/\d{4,6}$/);
        if (match) {
            const code = match[0];
            const def = ol.proj.get(srsName);
            if (def) {
                return ((def.axisOrientation_ === 'neu' ? 'urn:x-ogc:def:crs:EPSG:' : 'EPSG:') + code);
            }
        }
    }
    return srsName;
};

TC.inherit(TC.filter.Spatial, TC.filter.Filter);

TC.filter.Spatial.prototype.write = function () {
    var pattern = null;
    if (this.geometryName) {
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{geometry}</{prefix}:{tag}>';
    }
    else {
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}/>{geometry}</{prefix}:{tag}>';
    }

    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        name: this.geometryName,
        geometry: (this.geometry instanceof TC.filter.Function ? this.writeInnerCondition_(this.geometry) : this.geometry.wrap.toGML(undefined, this.wrap.getAxisOrientation())),
        fieldTitle: this._fieldTitle
    });
};

TC.filter.Bbox = function (geometryName, extent, opt_srsName) {
    TC.filter.Filter.call(this, 'BBOX');
    this.geometryName = geometryName;
    this.extent = extent;
    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Bbox, TC.filter.Filter);

TC.filter.Bbox.prototype.write = function () {
    var bbox = '<gml:Envelope{srsName}><gml:lowerCorner>{lowerCorner}</gml:lowerCorner><gml:upperCorner>{upperCorner}</gml:upperCorner></gml:Envelope>'
	.format({
	    srsName: (typeof (this.srsName) !== "undefined" ? " srsName=\"" + this.srsName + "\"" : ""),
	    lowerCorner: (this.extent[0] + ' ' + this.extent[1]),
	    upperCorner: (this.extent[2] + ' ' + this.extent[3])
	});
    var pattern = null;
    if (this.geometryName)
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{BBOX}</{prefix}:{tag}>';
    else
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}/>{BBOX}</{prefix}:{tag}>';
    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        fieldTitle:  this._fieldTitle,
        name: this.geometryName,
        BBOX: bbox
    });
};

TC.filter.Intersects = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Intersects', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Intersects, TC.filter.Spatial);

TC.filter.Within = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Within', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Within, TC.filter.Spatial);
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapContents = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.layerTrees = {};
};

TC.inherit(TC.control.MapContents, TC.Control);

(function () {
    var ctlProto = TC.control.MapContents.prototype;

    ctlProto.CLASS = 'tc-ctl-mc';

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }) : Promise.reject());
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                for (var i = 0, len = map.layers.length; i < len; i++) {
                    self.updateLayerTree(map.layers[i]);
                }

                map
                    .on(TC.Consts.event.ZOOM + ' ' + TC.Consts.event.PROJECTIONCHANGE, function () {
                        self.updateScale();
                    })
                    .on(TC.Consts.event.UPDATEPARAMS, function (e) {
                        const layer = e.layer;
                        var names = layer.names;
                        var containsName = function containsName(node) {
                            var result = false;
                            if (node) {
                                if (names.indexOf(node.name) >= 0) {
                                    result = true;
                                }
                                else {
                                    for (var i = 0; i < node.children.length; i++) {
                                        if (containsName(node.children[i])) {
                                            result = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            return result;
                        };
                        if (containsName(self.layerTrees[layer.id]) || names.length === 0) {
                            self.update();
                        }
                        else {
                            self.updateLayerTree(layer);
                        }
                    })
                    .on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                        self.updateLayerVisibility(e.layer);
                    })
                    .on(TC.Consts.event.LAYERADD, function (e) {
                        self.updateLayerTree(e.layer);
                    })
                    .on(TC.Consts.event.VECTORUPDATE + ' ' + TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                        const layer = e.layer;
                        // Se introduce un timeout porque pueden venir muchos eventos de este tipo seguidos y no tiene sentido actualizar con cada uno
                        if (self._updateLayerTreeTimeout) {
                            clearTimeout(self._updateLayerTreeTimeout);
                        }
                        self._updateLayerTreeTimeout = setTimeout(function () {
                            if (self.map.workLayers.indexOf(layer) > -1) {
                                // GLS: Validamos si la capa que ha provocado el evento sigue en worklayers, si es borrada debido a la espera del timeout el TOC puede reflejar capas que ya no están
                                self.updateLayerTree(layer);
                                delete self._updateLayerTreeTimeout;
                            }
                        }, 100);
                    })
                    .on(TC.Consts.event.LAYERREMOVE, function (e) {
                        self.removeLayer(e.layer);
                    })
                    .on(TC.Consts.event.LAYERORDER, function (e) {
                        self.updateLayerOrder(e.layer, e.oldIndex, e.newIndex);
                    })
                    .on(TC.Consts.event.LAYERERROR, function (e) {
                        self.onErrorLayer(e.layer);                                                    
                    });

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        });
    };

    ctlProto.updateScale = function () {
    };

    ctlProto.updateLayerVisibility = function (layer) {
    };

    ctlProto.updateLayerTree = function (layer) {
        this.layerTrees[layer.id] = layer.getTree();
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx, collection) {
        const self = this;
        if (oldIdx >= 0 && oldIdx !== newIdx) {
            var currentElm, previousElm;
            const elms = self.getLayerUIElements();

            collection = collection || self.map.workLayers;

            for (var i = collection.length - 1; i >= 0; i--) {
                const l = collection[i];
                previousElm = currentElm;
                for (var j = 0, jj = elms.length; j < jj; j++) {
                    const elm = elms[j];
                    if (elm.dataset.layerId === l.id) {
                        currentElm = elm;
                        break;
                    }
                }
                if (l === layer) {
                    if (previousElm) {
                        previousElm.insertAdjacentElement('afterend', currentElm);
                    }
                    else {
                        currentElm.parentElement.firstChild.insertAdjacentElement('beforebegin', currentElm);
                    }
                    break;
                }
            }
        }
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        const liCollection = self.getLayerUIElements();
        for (var i = 0, len = liCollection.length; i < len; i++) {
            const li = liCollection[i];
            if (li.dataset.layerId === layer.id) {
                li.parentElement.removeChild(li);
                break;
            }
        }
        if (self.getLayerUIElements().length === 0) {
            self.div.querySelector('.' + self.CLASS + '-empty').classList.remove(TC.Consts.classes.HIDDEN);
        }
    };

    ctlProto.onErrorLayer = function (layer) { };

    ctlProto.getLayerUIElements = function () {
        return this.div.querySelector('ul').children;
    };

    var isGetLegendGraphic = function (url) {
        return /[&?]REQUEST=getLegendGraphic/i.test(url);
    };

    /**
     * Carga y le da estilo a la imagen de la leyenda.
     * @param {string} requestMethod Si queremos pedir la imagen de la leyenda por POST, podemos especificarlo utilizando el parámetro requestMethod.
     */
    ctlProto.styleLegendImage = function (img, layer) {
        if (!img.getAttribute('src')) {
            var imgSrc = img.dataset.img;

            const toolProxification = new TC.tool.Proxification(TC.proxify);

            if (layer && layer.options.method && layer.options.method === "POST") {
                layer.getLegendGraphicImage()
                    .then(function (src) {
                        img.src = src; // ya se ha validado en getLegendGraphicImage
                    }).catch(function (err) {
                        TC.error(err);
                    });
            } else {
                if (isGetLegendGraphic(imgSrc)) {
                    const watch = img.parentElement;
                    // A\u00f1adimos el par\u00e1metro que define el estilo de los textos en la imagen
                    var colorStr = watch.style.color;
                    // Convertimos el color de formato rgb(r,g,b) a 0xRRGGBB
                    var openIdx = colorStr.indexOf('(');
                    var closeIdx = colorStr.indexOf(')');
                    if (openIdx >= 0 && closeIdx > openIdx) {
                        color = colorStr
                            .substr(0, closeIdx)
                            .substr(openIdx + 1)
                            .split(',');
                        colorStr = '0x';
                        for (var i = 0; i < 3; i++) {
                            var component = parseInt(color[i]).toString(16);
                            colorStr += component.length === 1 ? '0' + component : component;
                        }
                    }
                    else {
                        colorStr.replace('#', '0x');
                    }
                    imgSrc += '&LEGEND_OPTIONS=fontName:' + watch.style.fontFamily +
                        ';fontSize:' + parseInt(watch.style.fontSize) +
                        ';fontColor:' + colorStr +
                        ';fontAntiAliasing:true';
                    if (layer.params && layer.params.sld_body) {
                        imgSrc = TC.Util.addURLParameters(imgSrc, { sld_body: layer.params.sld_body });
                    }

                    toolProxification.fetchImage(imgSrc).then(function (img) {
                        img.dataset.img = img.src;
                    }).catch(function (err) {
                        TC.error(err);
                    });
                }

                toolProxification.fetchImage(imgSrc).then(function (i) {
                    img.src = i.src;
                }).catch(function (err) {
                    TC.error(err.statusText);
                });                
            }
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapInfo = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.MapInfo, TC.Control);

(function () {
    var ctlProto = TC.control.MapInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-mi';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.QR_MAX_URL_LENGTH = 150;
        self.SHORTEN_URL_LENGTH = 32715;

        self.exportsState = false;

        self.includeControls = self.options.includeControls === undefined || self.options.includeControls;

        map.ready(function () {
            const controlStates = map.state && map.state.ctl;
            if (controlStates) {
                if (!map._controlStatesLoaded) { // Para evitar que si hay varios controles Share cargados, cada uno importe por su cuenta.
                    self.importControlStates(controlStates);
                    map._controlStatesLoaded = true;
                }
            }
        });

        return result;
    }

    ctlProto.exportControlStates = function () {
        const self = this;
        if (self.map) {
            return self.map.controls
                .map(function (ctl) {
                    return ctl.exportState();
                })
                .filter(function (state) {
                    // Quitamos los estados nulos o vacíos
                    if (state) {
                        for (var key in state) {
                            if (state.hasOwnProperty(key)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
        }
        return [];
    };

    ctlProto.importControlStates = function (stateArray) {
        const self = this;
        if (self.map) {
            stateArray.forEach(function (state) {
                const ctl = self.map.getControlById(state.id);
                if (ctl) {
                    self.map.loaded(function () {
                        ctl.importState(state);
                    });
                }
            });
        }
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.featureToShare || self.sharedFeaturesLayer) {
                var layerState;
                state.id = self.id;
                if (self.featureToShare) {
                    const featureToShare = self.featureToShare.clone();
                    featureToShare.showsPopup = true;
                    layerState = self.featureToShare.layer.exportState({
                        features: [featureToShare]
                    });
                }
                else {
                    layerState = self.sharedFeaturesLayer.exportState();
                }
                state.features = layerState.features;
                if (layerState.crs) {
                    state.crs = layerState.crs;
                }
            }
            return state;
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map && state.features.length) {
            self.map.addLayer({
                id: self.getUID(),
                type: TC.Consts.layerType.VECTOR,
                title: self.getLocaleString('foi'),
                stealth: true
            }).then(function (layer) {
                self.sharedFeaturesLayer = layer;
                layer.importState({ features: state.features, crs: state.crs }).then(function () {
                    self.map.zoomToFeatures(layer.features);
                });
            });
        }
    };

    ctlProto.manageMaxLengthExceed = function () {
        throw "Falta implementación del método manageMaxLengthExceed";
    };

    ctlProto.generateLink = function () {
        var self = this;

        var currentUrl = window.location.href;
        var hashPosition = currentUrl.indexOf('#');
        if (hashPosition > 0) {
            currentUrl = currentUrl.substring(0, hashPosition);
        }

        if (self.extraParams) {
            // Hacemos merge de parámetros de URL
            var params = TC.Util.getQueryStringParams(currentUrl);
            TC.Util.extend(params, self.extraParams);
            var qsPosition = currentUrl.indexOf('?');
            if (qsPosition >= 0) {
                currentUrl = currentUrl.substring(0, qsPosition);
            }
            currentUrl = currentUrl.concat('?', TC.Util.getParamString(params));
        }

        // eliminamos el parámetro del idioma, si no lo arrastramos al compartir
        if (TC.Util.getParameterByName('lang').length > 0) {
            if (currentUrl.indexOf('&') > -1) { // tenemos más parámetros en la url
                currentUrl = currentUrl.replace("lang" + "=" + TC.Util.getParameterByName('lang') + '&', '');
            } else {
                currentUrl = currentUrl.replace('?' + "lang" + "=" + TC.Util.getParameterByName('lang'), '');
            }
        }

        const controlStates = self.includeControls ? self.exportControlStates() : [];
        if (self.exportsState && (self.featureToShare || self.sharedFeaturesLayer)) {
            controlStates.push(self.exportState());
        }
        const extraStates = controlStates.length ? { ctl: controlStates } : undefined;

        var hashState = self.map.getMapState(extraStates);

        var url = currentUrl.concat("#", hashState);
        self.manageMaxLengthExceed({ browser: url.length > TC.Consts.URL_MAX_LENGTH, qr: url.length > self.SHORTEN_URL_LENGTH });
        return url;
    };

    ctlProto.shortenedLink = function () {
        const self = this;
        var wait;

        const generateLinkWithoutParams = function () {
            var url = self.generateLink();
            var start = url.indexOf('?');
            var end = url.indexOf('#');

            //Borramos los parámetros de la URL y dejamos sólo el hash
            if (start > 0) {
                if (start < end) {
                    url = url.replace(url.substring(start, end), '');
                } else {
                    url = url.replace(url.substring(start, url.length - 1), '');
                }
            }

            return url;
        };
        const shortenUrl = function (url) {
            var shortenServiceUrl = "https://tinyurl.com/api-create.php";

            if (!TC.tool || !TC.tool.Proxification) {
                TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
            }

            var data = new FormData();
            data.append("url", url);

            var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: false });
            return toolProxification.fetch(shortenServiceUrl, {
                type: 'POST',
                data: data
            }).then(function (data) {
                return data;
            }).catch(function (error) {
                return null;
            });
        };

        return new Promise(function (resolve, reject) {
            const onError = function () {
                self.map.toast(self.getLocaleString("urlTooLongForShortener"), { type: TC.Consts.msgType.ERROR });
                self.map.getLoadingIndicator().removeWait(wait);
                resolve("");
            };

            var url = generateLinkWithoutParams();

            if (url.length > self.QR_MAX_URL_LENGTH && url.length < self.SHORTEN_URL_LENGTH) {

                wait = self.map.getLoadingIndicator().addWait();

                shortenUrl(url).then(function (response) {
                    if (response && response.responseText) {
                        self.map.getLoadingIndicator().removeWait(wait);
                        resolve(response.responseText.replace('http://', 'https://'));
                    } else {
                        onError();
                    }
                }, onError);
            } else {
                if (url.length >= self.SHORTEN_URL_LENGTH) {
                    onError();
                }

                resolve("");
            }
        });
    };

    ctlProto.makeQRCode = function (codeContainer, width, height) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.loadJS(
                typeof QRCode === 'undefined',
                [TC.apiLocation + 'lib/qrcode/qrcode.min.js'],
                function () {
                    self.shortenedLink().then(function (url) {
                        url = url || "";
                        if (url.length > 0) {
                            var options = {
                                text: url
                            };

                            if (width && height) {
                                options.width = width;
                                options.height = height;
                            }

                            var config = { attributes: true, childList: true, subtree: true };
                            var observer = new MutationObserver(function (mutationsList, observer) {
                                var srcMutation = mutationsList.filter(function (mutation) {
                                    return mutation.type === "attributes"
                                }).filter(function (mutation) {
                                    return mutation.attributeName.indexOf('src') > -1;
                                });

                                if (srcMutation.length > 0) {
                                    observer.disconnect();
                                    resolve(srcMutation[0].target.src);
                                }
                            });
                            observer.observe(codeContainer, config);
                            new QRCode(codeContainer, options);
                        } else {
                            resolve();
                        }
                    });
                });
        });
    };

    ctlProto.drawScaleBarIntoCanvas = function (options) {
        const self = this;
        var canvas;
        var sb = self.map.getControlsByClass(TC.control.ScaleBar);
        if (sb.length == 0) {
            return null;
        }

        options = options || {};

        const drawFill = function (ctx, width, height) {
            var elem = document.getElementsByClassName(sb[0].CLASS);
            var fillnode = elem.item(0);
            var fillBoundingCR = TC.Util.extend({}, fillnode.getBoundingClientRect());

            fillBoundingCR.left = (options.left || 15) - 2;

            fillBoundingCR.top = options.top || 15;
            fillBoundingCR.top--;

            ctx.globalAlpha = 0.5;
            ctx.fillStyle = window.getComputedStyle(fillnode).backgroundColor;
            width += 4;
            height += 4;
            ctx.fillRect(fillBoundingCR.left, fillBoundingCR.top, width, height);
        };

        if (!options.canvas) {
            canvas = document.createElement('CANVAS');
        } else {
            canvas = options.canvas;
        }

        var ctx = canvas.getContext("2d");
        ctx.save();

        var elem = document.getElementsByClassName("ol-scale-line-inner");
        var node = elem.item(0);
        var boundingCR = TC.Util.extend({}, node.getBoundingClientRect());

        var text = node.textContent;

        ctx.beginPath();
        ctx.strokeStyle = window.getComputedStyle(node).borderColor;

        var width, height;

        if (boundingCR.width > boundingCR.height) {

            width = boundingCR.width;
            height = boundingCR.height;
        }
        else {

            width = boundingCR.height;
            height = boundingCR.width;
        }

        if (options.setSize) {
            canvas.width = width;
            canvas.height = height;
        }        

        boundingCR.left = options.left != undefined ? options.left : 15;
        boundingCR.top = options.top != undefined ? options.top : 15;

        ctx.moveTo(boundingCR.left, boundingCR.top);
        ctx.lineTo(boundingCR.left, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top);

        ctx.stroke();

        var textMetrics = ctx.measureText(text);
        var textPosition = {
            x: boundingCR.left + width / 2,
            y: boundingCR.top + height / 2
        };

        if (options.fill) {
            drawFill(ctx, width, height);
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = options.textColor != undefined ? options.textColor : window.getComputedStyle(node).color;

        ctx.font = options.font != undefined ? options.font : window.getComputedStyle(node).fontSize + " " + window.getComputedStyle(node).fontFamily;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, textPosition.x, textPosition.y);

        return canvas;
    };

    ctlProto.registerListeners = function () {
        const self = this;

        if (!self.registeredListeners) {
            self.map.on(TC.Consts.event.LAYERADD, self.generateLink.bind(self))
                .on(TC.Consts.event.LAYERREMOVE, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREADD, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, self.generateLink.bind(self));

            self.registeredListeners = true;
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.TOC = function () {
    var self = this;

    TC.control.MapContents.apply(self, arguments);
};

TC.inherit(TC.control.TOC, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.TOC.prototype;

    ctlProto.CLASS = 'tc-ctl-toc';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/TOC.html";
        ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/TOCBranch.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/TOCNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "worklayers" }).w("</h2><div class=\"tc-ctl-toc-tree\"><div class=\"tc-ctl-toc-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</div><ul class=\"tc-ctl-toc-branch tc-ctl-toc-wl\">").s(ctx.get(["workLayers"], false), ctx, { "block": body_1 }, {}).w("</ul></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-toc-wlbranch", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-branch'] = function () { dust.register(ctlProto.CLASS + '-branch', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><button class=\"tc-ctl-toc-collapse-btn\"></button><input type=\"checkbox\" class=\"tc-ctl-toc-branch-cb\" name=\"toc\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["isVisible"], false), ctx, { "block": body_3 }, {}).w(" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-toc-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_4 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node tc-ctl-toc-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" checked"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.p("tc-ctl-toc-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_4.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\">").x(ctx.get(["children"], false), ctx, { "block": body_3 }, {}).w("<input type=\"checkbox\" name=\"toc\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["isVisible"], false), ctx, { "block": body_4 }, {}).w(" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-toc-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_5 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node tc-ctl-toc-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<button class=\"tc-ctl-toc-collapse-btn\"></button>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w(" checked"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.p("tc-ctl-toc-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_5.__dustBody = !0; return body_0 };
    }

    var _dataKeys = {
        layer: 'tcLayer',
        layerUid: 'tcLayerUid'
    };

    var CLICKEVENT = 'click';

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapContents.prototype.register.call(self, map);

        map.on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
            self.onExternalServiceAdded(e);
        });

        return result;
    };

    ctlProto.onExternalServiceAdded = function (e) {
        const self = this;
        if (e && e.layer) {
            e.layer.map = self.map;
            self.map.addLayer(e.layer).then(function (layer) {
                self.updateLayerTree(e.layer);
            });
        }
    };

    ctlProto.addUIEventListeners = function () {
        const self = this;
        self.div.addEventListener(CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) { // No usamos TC.Consts.event.CLICK porque en iPad los eventos touchstart no van bien en los checkbox
            const checkbox = e.target;
            var ul = checkbox;
            while (ul && !ul.matches('ul.' + self.CLASS + '-wl')) {
                ul = ul.parentElement;
            }
            const lis = [];
            for (var i = 0, len = ul.children.length; i < len; i++) {
                child = ul.children[i];
                if (child.tagName === 'LI') {
                    lis.push(child);
                }
            }
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.contains(checkbox)) {
                    const layer = self.map.getLayer(li.dataset.layerId);
                    var parent = checkbox;
                    do {
                        parent = parent.parentElement;
                    }
                    while (parent && parent.tagName !== 'LI');
                    const uid = parent.dataset.layerUid;
                    layer.setNodeVisibility(uid, checkbox.checked);
                    break;
                }
            }

            e.stopPropagation();
        }));
        self.div.addEventListener(TC.Consts.event.MOUSEUP, TC.EventTarget.listenerBySelector('button.' + self.CLASS + '-collapse-btn', function (e) {
            e.target.blur();
            const li = e.target.parentElement;
            if (!li.classList.contains(self.CLASS + '-leaf')) {
                li.classList.toggle(TC.Consts.classes.COLLAPSED);
                const ul = li.querySelector('ul');
                ul.classList.toggle(TC.Consts.classes.COLLAPSED);
                e.stopPropagation();
            }
        }));
    };

    ctlProto.update = function () {
        var self = this;

        var _getCheckbox = function (li) {
            for (var i = 0, len = li.children.length; i < len; i++) {
                const child = li.children[i];
                if (child.matches('input[type=checkbox]')) {
                    return child;
                }
            }
            return null;
        };

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                _getCheckbox(li).checked = layer.getVisibility();

                layer.tree = null;

                li.querySelectorAll('li').forEach(function (l) {
                    const checkbox = _getCheckbox(l);
                    const uid = l.dataset.layerUid;
                    switch (layer.getNodeVisibility(uid)) {
                        case TC.Consts.visibility.VISIBLE:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.NOT_VISIBLE_AT_RESOLUTION:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            checkbox.checked = false;
                            checkbox.indeterminate = true;
                            break;
                        default:
                            checkbox.checked = false;
                            checkbox.indeterminate = false;
                    }
                });
            }
        });

        self.updateScale();
    };

    ctlProto.updateScale = function () {
        const self = this;
        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            li.querySelectorAll('li').forEach(function (elm) {
                const uid = elm.dataset.layerUid;
                elm.classList.toggle(self.CLASS + '-node-notvisible', !layer.isVisibleByScale(uid));
            });
        });
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);

            var template = self.CLASS + '-branch';
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(template, self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        const uid = newLi.dataset.layerUid;
                        const li = self.div.querySelector('.' + self.CLASS + '-wl li[data-layer-uid="' + uid + '"]');
                        if (li) {
                            li.innerHTML = newLi.innerHTML;
                            li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                            if (!li.dataset.layerId) {
                                li.dataset.layerId = layer.id;
                            }
                        }
                        else {
                            newLi.dataset.layerId = layer.id;
                            const ul = self.div.querySelector('.' + self.CLASS + '-wl');
                            ul.insertBefore(newLi, ul.firstChild);
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    var wl = 'ul.' + self.CLASS + '-wl';
                    var branch = 'ul.' + self.CLASS + '-branch';
                    var node = 'li.' + self.CLASS + '-node';
                    var leaf = 'li.' + self.CLASS + '-leaf';
                    self.div.querySelectorAll(wl + ' ' + branch + ' ' + branch + ',' + wl + ' ' + branch + ' ' + node).forEach(function (node) {
                        if (!node.matches(leaf)) {
                            node.classList.add(TC.Consts.classes.COLLAPSED);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                var isHidden = !layer.getVisibility();
                li.querySelectorAll('input[type=checkbox]').forEach(function (checkbox) {
                    if (checkbox.matches('.' + self.CLASS + '-branch-cb')) {
                        checkbox.checked = !isHidden;
                    }
                    else {
                        checkbox.disabled = isHidden;
                    }
                });
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // Este control no tiene que hacer nada
    };

    ctlProto.render = function (callback) {
        const self = this;

        return TC.Control.prototype.render.call(self, function () {

            var controlOptions = self.options.controls || [];

            if (controlOptions.length > 0) {
                var ctl = controlOptions[0];
                var newDiv = document.createElement("div");
                self.div.appendChild(newDiv);
                self.map.addControl(ctl.name, TC.Util.extend({ 'div': newDiv }, ctl.options));
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        const result = [];
        const children = self.div.querySelector('ul.' + self.CLASS + '-wl').children;
        for (var i = 0, len = children.length; i < len; i++) {
            child = children[i];
            if (child.tagName === 'LI') {
                result[result.length] = child;
            }
        }
        return result;
    };
})();

TC.control = TC.control || {};

if (!TC.control.TOC) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TOC');
}

TC.control.WorkLayerManager = function (options) {
    var self = this;
    TC.control.TOC.apply(self, arguments);
    self.layers = [];
    self.queries = self.options.queries;
};

TC.inherit(TC.control.WorkLayerManager, TC.control.TOC);

(function () {
    var ctlProto = TC.control.WorkLayerManager.prototype;

    ctlProto.CLASS = 'tc-ctl-wlm';
    ctlProto.CLICKEVENT = 'click';

    TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
    TC.Consts.classes.DRAGEND = TC.Consts.classes.DRAGEND || 'tc-dragend';

    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/WorkLayerManager.html";
        ctlProto.template[ctlProto.CLASS + '-elm'] = TC.apiLocation + "TC/templates/WorkLayerManagerElement.html";
        ctlProto.template[ctlProto.CLASS + '-type-sgl'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipSingle.html";
        ctlProto.template[ctlProto.CLASS + '-type-grp'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroup.html";
        ctlProto.template[ctlProto.CLASS + '-type-grp-node'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroupNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "loadedLayers" }).w("<span class=\"tc-ctl-wlm-n\"></span><button class=\"tc-ctl-wlm-del-all tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "removeAllLayersFromMap" }).w("\"></button></h2><div class=\"tc-ctl-wlm-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</div><div class=\"tc-ctl-wlm-content tc-hidden\"><form><ul>").s(ctx.get(["workLayers"], false), ctx, { "block": body_1 }, {}).w("</ul></form></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-elm", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-elm'] = function () { dust.register(ctlProto.CLASS + '-elm', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-wlm-elm\" tabindex=\"-1\"><div class=\"tc-ctl-wlm-lyr\">").x(ctx.get(["path"], false), ctx, { "block": body_1 }, {}).w("</div><div class=\"tc-ctl-wlm-type\"></div><div class=\"tc-ctl-wlm-path\" title=\"").s(ctx.get(["path"], false), ctx, { "else": body_2, "block": body_3 }, {}).w("\">").s(ctx.get(["path"], false), ctx, { "else": body_5, "block": body_6 }, {}).w("</div><div class=\"tc-ctl-wlm-buttons\"><div class=\"tc-ctl-wlm-btn-info\" title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\"></div><input type=\"range\" value=\"").f(ctx.get(["opacity"], false), ctx, "h").w("\" title=\"").h("i18n", ctx, {}, { "$key": "transparencyOfThisLayer" }).w("\" /><input type=\"checkbox\" ").nx(ctx.get(["hide"], false), ctx, { "block": body_8 }, {}).w(" title=\"").h("i18n", ctx, {}, { "$key": "visibilityOfThisLayer" }).w("\" /></div><div class=\"tc-ctl-wlm-info tc-hidden\">").x(ctx.get(["abstract"], false), ctx, { "block": body_9 }, {}).x(ctx.get(["customLegend"], false), ctx, { "else": body_10, "block": body_13 }, {}).x(ctx.get(["metadata"], false), ctx, { "block": body_14 }, {}).w("</div><div class=\"tc-ctl-wlm-dd ").x(ctx.get(["hide"], false), ctx, { "block": body_16 }, {}).w("\" title=\"").h("i18n", ctx, {}, { "$key": "dragToReorder" }).w("\"></div><div class=\"tc-ctl-wlm-del ").x(ctx.get(["unremovable"], false), ctx, { "block": body_17 }, {}).w(" ").nx(ctx.get(["hide"], false), ctx, { "block": body_18 }, {}).w("\" ").nx(ctx.get(["unremovable"], false), ctx, { "block": body_19 }, {}).w("></div></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_4 }, {}); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w(" &bull; "); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_7 }, {}); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(" &bull; "); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("checked=\"checked\""); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-abstract\"><h4>").h("i18n", ctx, {}, { "$key": "abstract" }).w("</h4><div><pre>").f(ctx.get(["abstract"], false), ctx, "h", ["s"]).w("</pre></div></div>"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.x(ctx.get(["legend"], false), ctx, { "block": body_11 }, {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-legend\" data-layer-name=\"").f(ctx.get(["layerNames"], false), ctx, "h").w("\"><h4>").h("i18n", ctx, {}, { "$key": "content" }).w("</h4>").s(ctx.get(["legend"], false), ctx, { "block": body_12 }, {}).w("</div>"); } body_11.__dustBody = !0; function body_12(chk, ctx) { return chk.w("<div><p>").f(ctx.get(["title"], false), ctx, "h").w("</p><img data-img=\"").f(ctx.get(["src"], false), ctx, "h").w("\" /></div>"); } body_12.__dustBody = !0; function body_13(chk, ctx) { return chk.w("<ul class=\"tc-ctl-wlm-custom-legend\">").f(ctx.get(["customLegend"], false), ctx, "h", ["s"]).w("</ul>"); } body_13.__dustBody = !0; function body_14(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-metadata\"><h4>").h("i18n", ctx, {}, { "$key": "metadata" }).w("</h4><ul>").s(ctx.get(["metadata"], false), ctx, { "block": body_15 }, {}).w("</ul></div>"); } body_14.__dustBody = !0; function body_15(chk, ctx) { return chk.w("<li><a href=\"").f(ctx.get(["url"], false), ctx, "h", ["s"]).w("\" type=\"").f(ctx.get(["format"], false), ctx, "h").w("\" title=\"").f(ctx.get(["formatDescription"], false), ctx, "h").w("\" target=\"_blank\">").f(ctx.get(["formatDescription"], false), ctx, "h").w("</a></li>"); } body_15.__dustBody = !0; function body_16(chk, ctx) { return chk.w("tc-hidden"); } body_16.__dustBody = !0; function body_17(chk, ctx) { return chk.w("disabled"); } body_17.__dustBody = !0; function body_18(chk, ctx) { return chk.w("tc-hidden"); } body_18.__dustBody = !0; function body_19(chk, ctx) { return chk.w("title=\"").h("i18n", ctx, {}, { "$key": "removeLayerFromMap" }).w("\""); } body_19.__dustBody = !0; return body_0; };
        ctlProto.template[ctlProto.CLASS + '-type-sgl'] = function () { dust.register(ctlProto.CLASS + '-type-sgl', body_0); function body_0(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "singleLayer" }); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-type-grp'] = function () { dust.register(ctlProto.CLASS + '-type-grp', body_0); function body_0(chk, ctx) { return chk.w("<div>").h("i18n", ctx, {}, { "$key": "groupLayerThatContains" }).w(":</div><ul>").s(ctx.get(["Layer"], false), ctx, { "block": body_1 }, {}).w("</ul>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-type-grp-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-type-grp-node'] = function () { dust.register(ctlProto.CLASS + '-type-grp-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-wlm-tip-grp-elm\"><span>").f(ctx.get(["Title"], false), ctx, "h").w("</span><ul>").s(ctx.get(["Layer"], false), ctx, { "block": body_1 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-type-grp-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
    }

    const findLayerElement = function (ctl, layer) {
        return ctl.getLayerUIElements().filter(function (li) {
            return li.dataset.layerId === layer.id;
        })[0];
    };

    var getElligibleLayersNumber = function (ctl) {
        return ctl.layers.length;
    };

    const shouldBeDelAllVisible = function (ctl) {
        return !ctl.layers.some(function (layer) { return layer.unremovable });
    };

    const moveLayer = function (ctl, listItem, oldIndex, newIndex, callback) {
        const layerItems = ctl.getLayerUIElements();
        var targetItem;
        if (newIndex > oldIndex) {
            targetItem = layerItems[newIndex - 1];
        }
        else if (newIndex < oldIndex) {
            targetItem = layerItems[newIndex + 1];
        }
        else {
            return;
        }
        const sourceLayer = ctl.map.getLayer(listItem.dataset.layerId);
        const targetLayer = ctl.map.getLayer(targetItem.dataset.layerId);
        var newIdx = -1;
        for (var i = 0; i < ctl.map.layers.length; i++) {
            if (targetLayer === ctl.map.layers[i]) {
                newIdx = i;
                break;
            }
        }
        if (newIdx >= 1 && newIdx < ctl.map.layers.length) {
            ctl.map.insertLayer(sourceLayer, newIdx, callback);
        }
    };

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            TC.loadJS(
                !window.Sortable,
                [TC.apiLocation + 'lib/sortable/Sortable.min.js'],
                function () {
                    self.map.workLayers
                        .filter(function (layer) {
                            return !layer.stealth;
                        })
                        .forEach(function (layer) {
                            self.updateLayerTree(layer);
                        });


                    const ul = self.div.querySelector('ul');
                    self._sortable = Sortable.create(ul, {
                        handle: '.' + self.CLASS + '-dd',
                        animation: 150,
                        onSort: function (e) {
                            moveLayer(self, e.item, e.oldIndex, e.newIndex);
                        }
                    });

                    ul.addEventListener('keydown', TC.EventTarget.listenerBySelector('li', function (e) {
                        // Para mover capas con el teclado.
                        var elm = e.target;
                        while (elm.tagName !== 'LI') {
                            elm = elm.parentElement;
                            if (!elm) {
                                return;
                            }
                        }
                        const swap = function (oldIdx, newIdx) {
                            const sortableItems = self._sortable.toArray();
                            const buffer = sortableItems[oldIdx];
                            sortableItems[oldIdx] = sortableItems[newIdx];
                            sortableItems[newIdx] = buffer;
                            self._sortable.sort(sortableItems);
                            moveLayer(self, elm, oldIdx, newIdx);
                        };
                        const listItems = self.getLayerUIElements();
                        const elmIdx = listItems.indexOf(elm);
                        switch (true) {
                            case /Up$/.test(e.key):
                                if (elmIdx > 0) {
                                    swap(elmIdx, elmIdx - 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Down$/.test(e.key):
                                if (elmIdx < listItems.length - 1) {
                                    swap(elmIdx, elmIdx + 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Enter$/.test(e.key):
                                elm.blur();
                                e.stopPropagation();
                                break;
                            default:
                                break;
                        }
                    }));

                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            );
        }) : Promise.reject());
    };

    ctlProto.register = function (map) {
        const self = this;

        return new Promise(function (resolve, reject) {
            TC.control.TOC.prototype.register.call(self, map).then(function () {

                map.loaded(function () {                   
                    self.updateScale();
                });

                map
                    .on(TC.Consts.event.LAYEROPACITY, function (e) {
                        const li = findLayerElement(self, e.layer);
                        if (li) {
                            li.querySelector('input[type=range]').value = Math.round(e.opacity * 100);
                        }
                    })
                    .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                        var fileName = e.fileName;
                        if (e.features && e.features.length > 0) { // GLS: Escuchamos al evento FEATURESIMPORT para poder desplegar el control de capas cargadas
                            // Ignoramos los GPX (se supone que los gestionará Geolocation)
                            var pattern = '.' + TC.Consts.format.GPX.toLowerCase();
                            if (e.fileName.toLowerCase().indexOf(pattern) === e.fileName.length - pattern.length) {
                                return;
                            }

                            map.one(TC.Consts.event.LAYERADD, function (e) {
                                if (e && e.layer && e.layer.title == fileName) {
                                    // Desplegamos el control capas cargadas
                                    if (self.map && self.map.layout && self.map.layout.accordion) {
                                        if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                            self.map.controls
                                                .filter(function (ctl) {
                                                    // Todos los otros controles que no cuelgan de otro control
                                                    return ctl !== self && !ctl.containerControl;
                                                })
                                                .forEach(function (ctl) {
                                                    ctl.div.classList.add(TC.Consts.classes.COLLAPSED);
                                                });
                                        }
                                    }

                                    // abrimos el panel de herramientas
                                    self.map.trigger(TC.Consts.event.TOOLSOPEN);

                                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                                }
                            });
                        }
                    });
                if (self.queries) {
                    if (!TC.control.WFSQuery) {
                        TC.syncLoadJS(TC.apiLocation + 'TC/Control/WFSQuery');
                    }
                    ctlProto.queryControl = new TC.control.WFSQuery(null, self.queries instanceof Object ? self.queries : null);
                    self.map.addControl(ctlProto.queryControl);
                }
                resolve(self);
            });
        });
    };

    ctlProto.onExternalServiceAdded = function (e) {
        // Este control no tiene que aceptar servicios externos directamente
    };

    ctlProto.addUIEventListeners = function () {
        const self = this;

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
            // al estar en ipad el evento pasa a ser touchstart en la constante: TC.Consts.event.CLICK, los checkbox no funcionan bien con este evento
            const checkbox = e.target;
            var li = checkbox;
            do {
                li = li.parentElement;
            }
            while (li && !li.matches('li.' + self.CLASS + '-elm'));

            const layer = self.map.getLayer(li.dataset.layerId);
            layer.setVisibility(checkbox.checked);
            e.stopPropagation();
        }));

        const inputRangeListener = function (e) {
            const range = e.target;
            var li = range;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');

            const layer = self.map.getLayer(li.dataset.layerId);
            layer.setOpacity(range.value / 100);
        };
        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));
        self.div.addEventListener('input', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-del' + ':not(.disabled)', function (e) {
            var li = e.target;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const layer = self.map.getLayer(li.dataset.layerId);
            self.map.removeLayer(layer);
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-del-all', function (e) {
            TC.confirm(self.getLocaleString('layersRemove.confirm'), function () {
                self.getLayerUIElements()
                    .map(function (li) {
                        return self.map.getLayer(li.dataset.layerId);
                    })
                    .forEach(function (layer) {
                        self.map.removeLayer(layer);
                    });
            });
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn-info', function (e) {
            const a = e.target;
            var li = a;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const info = li.querySelector('.' + self.CLASS + '-info');
            const layer = self.map.getLayer(li.dataset.layerId);
            // Cargamos la imagen de la leyenda
            info.querySelectorAll('.' + self.CLASS + '-legend img').forEach(function (img) {
                self.styleLegendImage(img, layer);
            });
            info.classList.toggle(TC.Consts.classes.HIDDEN);

            if (li.querySelector('input[type="checkbox"]').checked) {
                const dragHandle = li.querySelector('.' + self.CLASS + '-dd');
                dragHandle.classList.toggle(TC.Consts.classes.HIDDEN, !info.classList.contains(TC.Consts.classes.HIDDEN));
            }

            a.classList.toggle(TC.Consts.classes.CHECKED);
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn-query', function (e) {
            if (e.target.classList.contains('tc-unavailable') || e.target.classList.contains('tc-loading')) {
                return;
            }
            const a = e.target;
            var li = a;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const layer = self.map.getLayer(li.dataset.layerId);
            self.queryControl.renderModalDialog(layer);
        }));
    };

    ctlProto.updateLayerVisibility = function (layer) {
        const self = this;
        const li = findLayerElement(self, layer);
        if (li) {
            const visible = layer.getVisibility();
            li.querySelector('input[type="checkbox"]').checked = visible;
            const delBtn = li.querySelector('.' + self.CLASS + '-del');
            const info = li.querySelector('.' + self.CLASS + '-info');
            const dragHandle = li.querySelector('.' + self.CLASS + '-dd');
            if (visible) {
                delBtn.classList.add(TC.Consts.classes.HIDDEN);
                if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                    dragHandle.classList.remove(TC.Consts.classes.HIDDEN);
                }
            }
            else {
                delBtn.classList.remove(TC.Consts.classes.HIDDEN);
                if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                    dragHandle.classList.add(TC.Consts.classes.HIDDEN);
                }
            }
        }
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;        

        var getLegendImgByPost = function (layer) {
            return new Promise(function (resolve, reject) {
                if (layer && layer.options.method && layer.options.method === "POST") {
                    layer.getLegendGraphicImage()
                        .then(function (src) {
                            resolve(src);
                        })
                        .catch(function (err) { TC.error(err); });
                } else {
                    resolve();
                }
            });
        };

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            var alreadyExists = false;
            for (var i = 0, len = self.layers.length; i < len; i++) {
                if (layer === self.layers[i]) {
                    alreadyExists = true;
                    break;
                }
            }

            if (!alreadyExists) {
                var template = self.CLASS + '-elm';
                self.layers.push(layer);

                TC.loadJSInOrder(
                    !window.dust,
                    TC.url.templating,
                    function () {
                        var domReadyPromise;
                        var layerTitle = layer.title || layer.wrap.getServiceTitle();
                        var layerData = {
                            title: layer.options.hideTitle ? '' : layerTitle,
                            hide: layer.renderOptions && layer.renderOptions.hide ? true : false,
                            opacity: layer.renderOptions && layer.renderOptions.opacity ? (layer.renderOptions.opacity * 100) : 100,
                            customLegend: layer.customLegend,
                            unremovable: layer.unremovable
                        };
                        var isRaster = layer.isRaster();
                        if (isRaster) {
                            layerData.layerNames = layer.layerNames;
                            var path = layer.getPath();
                            path.shift();
                            layerData.path = path;
                            var name = layer.names[0];
                            var info = layer.wrap.getInfo(name);
                            layerData.legend = info.legend;
                            layerData['abstract'] = info['abstract'];
                            var hasInfo = (info.hasOwnProperty('abstract') || info.hasOwnProperty('legend') || info.hasOwnProperty('metadata'));
                            var metadata;
                            if (layer.tree && layer.tree.children && layer.tree.children.length && layer.tree.children[0].children && layer.tree.children[0].children.length) {
                                metadata = null;
                            }
                            else {
                                metadata = info.metadata;
                                if (metadata) {
                                    for (var j = 0, len = metadata.length; j < len; j++) {
                                        var md = metadata[j];
                                        md.formatDescription = self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) || self.getLocaleString('viewMetadata');
                                    }
                                }
                            }
                            layerData.metadata = metadata;
                            if (self.queries) {
                                domReadyPromise = checkWFSAvailable(layer);
                            }
                        }


                        getLegendImgByPost(layer).then(function (src) {
                            if (src) {
                                legend.src = src; // ya se ha validado en getLegendImgByPost
                            }

                            dust.render(template, layerData, function (err, out) {
                                const parser = new DOMParser();
                                const li = parser.parseFromString(out, 'text/html').body.firstChild;
                                var layerNode;
                                var isGroup = false;
                                if (isRaster) {
                                    isGroup = layer.names.length > 1;
                                    if (!isGroup) {
                                        var layerNodes = layer.wrap.getAllLayerNodes();
                                        for (var i = 0; i < layerNodes.length; i++) {
                                            var node = layerNodes[i];
                                            if (layer.wrap.getName(node) === name) {
                                                layerNode = node;
                                                if (layer.wrap.getLayerNodes(node).length > 0) {
                                                    isGroup = true;
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }

                                const typeElm = li.querySelector('.' + self.CLASS + '-type');
                                const className = isGroup ? self.CLASS + '-type-grp' : self.CLASS + '-type-sgl';
                                typeElm.classList.add(className);

                                if (!hasInfo) {
                                    li.querySelector('.' + self.CLASS + '-btn-info').classList.add(TC.Consts.classes.HIDDEN);
                                }

                                if (layerNode) {
                                    layer.wrap.normalizeLayerNode(layerNode);

                                    dust.render(className, layerNode, function (err, out) {
                                        var tip;

                                        typeElm.addEventListener('mouseover', function (e) {
                                            const mapDiv = self.map.div;
                                            const typeElmRect = typeElm.getBoundingClientRect();
                                            tip = document.createElement('div');
                                            tip.classList.add(self.CLASS + '-tip');
                                            tip.innerHTML = out;
                                            tip.style.top = (typeElmRect.top - mapDiv.offsetTop) + 'px';
                                            tip.style.right = mapDiv.offsetWidth - (typeElmRect.left - mapDiv.offsetLeft) + 'px';
                                            mapDiv.appendChild(tip);
                                        });
                                        typeElm.addEventListener('mouseout', function (e) {
                                            tip.parentElement.removeChild(tip);
                                        });
                                    });
                                }
                                const ul = self.div.querySelector('ul');
                                li.dataset.layerId = layer.id;

                                const lis = self.getLayerUIElements();
                                const layerList = self.map.workLayers
                                    .filter(function (l) {
                                        return !l.stealth;
                                    });
                                const layerIdx = layerList.indexOf(layer);
                                var inserted = false;
                                for (var i = 0, ii = lis.length; i < ii; i++) {
                                    const referenceLi = lis[i];
                                    const referenceLayerIdx = layerList.indexOf(self.map.getLayer(referenceLi.dataset.layerId));
                                    if (referenceLayerIdx < layerIdx) {
                                        referenceLi.insertAdjacentElement('beforebegin', li);
                                        inserted = true;
                                        break;
                                    }
                                }
                                if (!inserted) {
                                    ul.appendChild(li);
                                }

                                if (domReadyPromise) domReadyPromise(li);
                                self.updateScale();
                            });
                        });
                    }
                );

                var elligibleLayersNum = getElligibleLayersNumber(self);
                const numElm = self.div.querySelector('.' + self.CLASS + '-n');
                const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
                const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
                numElm.textContent = elligibleLayersNum;
                if (elligibleLayersNum > 0) {
                    numElm.classList.add(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.add(TC.Consts.classes.HIDDEN);
                    contentElm.classList.remove(TC.Consts.classes.HIDDEN);
                }
                else {
                    numElm.classList.remove(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
                    contentElm.classList.add(TC.Consts.classes.HIDDEN);
                }

                const deleteAllElm = self.div.querySelector('.' + self.CLASS + '-del-all');
                deleteAllElm.classList.toggle(TC.Consts.classes.HIDDEN, !shouldBeDelAllVisible(self));
            }
        }
    };

    ctlProto.updateScale = function () {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            var layer = self.map.getLayer(li.dataset.layerId);
            if (layer.names) {
                var isVisible = false;
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        isVisible = true;
                        break;
                    }
                }
                li.classList.toggle(self.CLASS + '-elm-notvisible', !isVisible);
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        //TC.control.MapContents.prototype.updateLayerOrder.call(this, layer, oldIdx, newIdx);
        const self = this;
        self.map.workLayers
            .filter(function (layer) {
                return !layer.stealth;
            })
            .forEach(function (layer) {
                const li = findLayerElement(self, layer);
                if (li) {
                    li.parentElement.firstChild.insertAdjacentElement('beforebegin', li);
                }
            });
    };

    ctlProto.removeLayer = function (layer) {
        var self = this;
        var idx = self.layers.indexOf(layer);
        if (idx >= 0) {
            self.layers.splice(idx, 1);
        }
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                li.parentElement.removeChild(li);
            }
        });
        const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
        const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
        const numberElm = self.div.querySelector('.' + self.CLASS + '-n');
        var nChildren = getElligibleLayersNumber(self);
        numberElm.textContent = nChildren;
        if (nChildren > 0) {
            contentElm.classList.remove(TC.Consts.classes.HIDDEN);
            emptyElm.classList.add(TC.Consts.classes.HIDDEN);
            numberElm.classList.add(TC.Consts.classes.VISIBLE);
        }
        else {
            if (shouldBeDelAllVisible(self)) {
                self.div.querySelector('.' + self.CLASS + '-del-all').classList.add(TC.Consts.classes.HIDDEN);
            }
            contentElm.classList.add(TC.Consts.classes.HIDDEN);
            emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
            numberElm.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        return Array.from(self.div.querySelectorAll(`ul > li.${self.CLASS}-elm`));
    };

    //analiza la nueva capa añadida si tiene habilitado o no el WFS
    const checkWFSAvailable = function (layer) {
        var fncResolve = null;
        var domReadyPromise = new Promise(function (resolve, reject) {
            fncResolve = resolve;
        })
        var cssClassUnavailable = 'tc-unavailable';

        var queryButton;
        domReadyPromise.then(function (li) {
            queryButton = document.createElement('div');
            queryButton.classList.add(ctlProto.CLASS + '-btn-query');
            queryButton.classList.add(TC.Consts.classes.LOADING);
            queryButton.setAttribute('title', ctlProto.getLocaleString('query.tooltipMagnifBtn'));
            li.querySelector('.' + ctlProto.CLASS + '-btn-info').insertAdjacentElement('afterend', queryButton);
        });
        var getCapProm = layer.getWFSCapabilitiesPromise()
        const noWFSAvailabeManage = function () {
            if (queryButton) {
                queryButton.classList.remove(TC.Consts.classes.LOADING);
                queryButton.classList.add(cssClassUnavailable);
            }
            //queryButton.attr("title", getLocaleString("query.tooltipMagnifBtnDisabled"));
            console.log("El servicio " + (layer.title || layer.tree.title) + " no tiene disponible el WFS");
        }
        Promise.all([getCapProm, domReadyPromise]).then(function () {
            var capabilities = arguments[0][0];
            //comprobamos que la solo es una capa y existe en el capabilities del WFS                        
            if (queryButton) {
                queryButton.classList.remove(TC.Consts.classes.LOADING)
                var layers = layer.getDisgregatedLayerNames();
                if (layers.length === 1 && !capabilities.FeatureTypes.hasOwnProperty(layers[0].substring(layers[0].indexOf(":") + 1))) {
                    queryButton.classList.add(cssClassUnavailable);
                    //queryButton.attr("title", getLocaleString("query.tooltipMagnifBtnDisabled"));
                    console.log("El servicio WFS de " + (layer.title || layer.tree.title) + " no dispone de la capa " + layers[0]);
                }
            }

        }).catch(noWFSAvailabeManage);
        getCapProm.catch(noWFSAvailabeManage);
        return fncResolve;
    }
})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Click = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if (self.options && self.options.callback) {
        self.callback = self.options.callback;
    }

    self.wrap = new TC.wrap.control.Click(self);
};

TC.inherit(TC.control.Click, TC.Control);

(function () {
    var ctlProto = TC.control.Click.prototype;

    ctlProto.CLASS = 'tc-ctl-click';

    ctlProto.register = function (map) {
        var self = this;
        self.wrap.register(map);
        return TC.Control.prototype.register.call(self, map);
    };

    ctlProto.activate = function () {
        var self = this;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate();
    };

    ctlProto.deactivate = function () {
        var self = this;
        self.wrap.deactivate();
        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.callback = function (coord, point) {
        console.log('[Click][' + coord[0] + ', ' + coord[1] + '][' + point[0] + ', ' + point[1] + ']');
    };
})();
TC.control = TC.control || {};

if (!TC.control.Click) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Click');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';
TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';

TC.control.FeatureInfoCommons = function () {
    const self = this;
    TC.control.Click.apply(self, arguments);

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        LIST_ITEM: 'ul' + cs + '-features li'
    };

    self.resultsLayer = null;
    self.filterLayer = null;
    self._layersPromise = null;
    self.filterFeature = null;
    self.info = null;
    self.popup = null;
    self.resultsPanel = null;
    self.lastFeatureCount = null;
    self.exportsState = true;
};

TC.control.FeatureInfoCommons.displayMode = {
    POPUP: 'popup',
    RESULTS_PANEL: 'resultsPanel'
};

(function () {

    var layerCount = function (ctl) {
        return ctl.info.services ?
            ctl.info.services.reduce(function (sCount, service) {
                return sCount + service.layers.reduce(function (lCount, layer) {
                    return lCount + 1;
                }, 0);
            }, 0) : 0;
    };

    TC.inherit(TC.control.FeatureInfoCommons, TC.control.Click);

    var ctlProto = TC.control.FeatureInfoCommons.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

    ctlProto.TITLE_SEPARATOR = ' • ';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FeatureInfo.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["displayElevation"], false), ctx, { "block": body_1 }, {}).w("<ul class=\"tc-ctl-finfo-services\">").s(ctx.get(["services"], false), ctx, { "else": body_4, "block": body_6 }, {}).w("</ul>").x(ctx.get(["featureCount"], false), ctx, { "block": body_30 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-finfo-coords\"><span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-crs\">CRS: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.get(["crs"], false), ctx, "h").w("</span></span> ").x(ctx.get(["isGeo"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" <span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-elev\">").h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-finfo-coords-val\"></span></span></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-x\">x: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "0"]), ctx, "h").w("</span></span> <span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-x\">y: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "1"]), ctx, "h").w("</span></span> "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-lat\">").h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "1"]), ctx, "h").w("</span></span> <span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-lon\">").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "0"]), ctx, "h").w("</span></span> "); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.nx(ctx.get(["displayElevation"], false), ctx, { "block": body_5 }, {}); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</li>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<li><h3>").x(ctx.get(["title"], false), ctx, { "else": body_7, "block": body_10 }, {}).w("</h3><div class=\"tc-ctl-finfo-service-content\">").s(ctx.get(["hasLimits"], false), ctx, { "else": body_11, "block": body_29 }, {}).w("</div></li>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.x(ctx.getPath(false, ["layers", "0", "title"]), ctx, { "else": body_8, "block": body_9 }, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.f(ctx.getPath(false, ["layer", "name"]), ctx, "h"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.f(ctx.getPath(false, ["layers", "0", "title"]), ctx, "h"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.w("<ul class=\"tc-ctl-finfo-layers\">").s(ctx.get(["layers"], false), ctx, { "else": body_12, "block": body_13 }, {}).w("</ul>"); } body_11.__dustBody = !0; function body_12(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noDataAtThisService" }).w("</li>"); } body_12.__dustBody = !0; function body_13(chk, ctx) { return chk.w("<li><h4><span class=\"tc-ctl-finfo-layer-n\">").f(ctx.getPath(false, ["features", "length"]), ctx, "h").w("</span> ").s(ctx.get(["path"], false), ctx, { "block": body_14 }, {}).w("</h4> <div class=\"tc-ctl-finfo-layer-content\"><ul class=\"tc-ctl-finfo-features\">").s(ctx.get(["features"], false), ctx, { "else": body_16, "block": body_17 }, {}).w("</ul></div></li>"); } body_13.__dustBody = !0; function body_14(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_15 }, {}); } body_14.__dustBody = !0; function body_15(chk, ctx) { return chk.w(" &bull; "); } body_15.__dustBody = !0; function body_16(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noDataInThisLayer" }).w("</li>"); } body_16.__dustBody = !0; function body_17(chk, ctx) { return chk.w("<li>").x(ctx.get(["rawContent"], false), ctx, { "else": body_18, "block": body_23 }, {}).w("</li>"); } body_17.__dustBody = !0; function body_18(chk, ctx) { return chk.x(ctx.get(["error"], false), ctx, { "else": body_19, "block": body_22 }, {}); } body_18.__dustBody = !0; function body_19(chk, ctx) { return chk.w("<h5>").f(ctx.get(["id"], false), ctx, "h").w("</h5><table").x(ctx.get(["geometry"], false), ctx, { "block": body_20 }, {}).w("><tbody>").s(ctx.get(["attributes"], false), ctx, { "block": body_21 }, {}).w("</tbody></table>"); } body_19.__dustBody = !0; function body_20(chk, ctx) { return chk.w(" title=\"").h("i18n", ctx, {}, { "$key": "clickToShowOnMap" }).w("\""); } body_20.__dustBody = !0; function body_21(chk, ctx) { return chk.w("<tr><th class=\"tc-ctl-finfo-attr\">").f(ctx.get(["name"], false), ctx, "h").w("</th><td class=\"tc-ctl-finfo-val\">").f(ctx.get(["value"], false), ctx, "h").w("</td></tr>"); } body_21.__dustBody = !0; function body_22(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-errors\">").h("i18n", ctx, {}, { "$key": "fi.error" }).w("<span class=\"tc-ctl-finfo-error-text\">").f(ctx.get(["error"], false), ctx, "h").w("</span></span>"); } body_22.__dustBody = !0; function body_23(chk, ctx) { return chk.w("<h5>").h("i18n", ctx, {}, { "$key": "feature" }).w("</h5>").h("eq", ctx, { "else": body_24, "block": body_25 }, { "key": ctx.get(["rawFormat"], false), "value": "text/html" }); } body_23.__dustBody = !0; function body_24(chk, ctx) { return chk.w("<pre>").f(ctx.get(["rawContent"], false), ctx, "h").w("</pre>"); } body_24.__dustBody = !0; function body_25(chk, ctx) { return chk.w(" ").x(ctx.get(["expandUrl"], false), ctx, { "block": body_26 }, {}); } body_25.__dustBody = !0; function body_26(chk, ctx) { return chk.h("ne", ctx, { "else": body_27, "block": body_28 }, { "key": ctx.get(["expandUrl"], false), "value": "" }); } body_26.__dustBody = !0; function body_27(chk, ctx) { return chk.w("<iframe src=\"").f(ctx.get(["rawUrl"], false), ctx, "h").w("\"></iframe>"); } body_27.__dustBody = !0; function body_28(chk, ctx) { return chk.w("<div class=\"tc-ctl-finfo-features-iframe-cnt\"><iframe src=\"").f(ctx.get(["rawUrl"], false), ctx, "h").w("\"></iframe><a class=\"tc-ctl-finfo-open\" onclick=\"window.open('").f(ctx.get(["expandUrl"], false), ctx, "h").w("', '_blank')\" title=\"").h("i18n", ctx, {}, { "$key": "expand" }).w("\"></a></div>"); } body_28.__dustBody = !0; function body_29(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-errors\">").f(ctx.get(["hasLimits"], false), ctx, "h").w("</span>"); } body_29.__dustBody = !0; function body_30(chk, ctx) { return chk.h("gt", ctx, { "block": body_31 }, { "key": ctx.get(["featureCount"], false), "value": "1", "type": "number" }); } body_30.__dustBody = !0; function body_31(chk, ctx) { return chk.w("<a class=\"tc-ctl-btn tc-ctl-finfo-btn-prev\">").h("i18n", ctx, {}, { "$key": "previous" }).w("</a><div class=\"tc-ctl-finfo-counter\"><span class=\"tc-ctl-finfo-counter-current\"></span>/").f(ctx.get(["featureCount"], false), ctx, "h").w("</div><a class=\"tc-ctl-btn tc-ctl-finfo-btn-next\">").h("i18n", ctx, {}, { "$key": "next" }).w("</a>"); } body_31.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.Click.prototype.register.call(self, map);

        self._createLayers();

        map.loaded(function () {
            const shareCtl = map.getControlsByClass('TC.control.Share')[0];
            if (shareCtl) {
                self.loadSharedFeature(shareCtl.loadParamFeature());
            }
        });

        self.displayMode = self.options.displayMode || TC.control.FeatureInfoCommons.displayMode.POPUP;
        self.setDisplayMode(self.displayMode);

        map
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                if (e.control === self.getDisplayControl() && self.resultsLayer) {
                    if (self.highlightedFeature) {
                        self.resultsLayer.removeFeature(self.highlightedFeature);
                        self.highlightedFeature = null;
                    }
                    if (!self.querying && e.feature) {
                        self.filterLayer.removeFeature(e.feature);
                    }
                }
            })
            .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.highlightedFeature = null;
            })
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                const control = e.control;
                if (control.currentFeature !== self.filterFeature) {
                    self.highlightedFeature = control.currentFeature;
                }

                // GLS: si la feature es resultado de GFI decoramos
                if (e.control.currentFeature &&
                    e.control.currentFeature.layer &&
                    self.filterLayer &&
                    self.resultsLayer &&
                    [self.filterLayer.id, self.resultsLayer.id].indexOf(e.control.currentFeature.layer.id) > -1) {
                    self._decorateDisplay(control);
                }
            })
            .on(TC.Consts.event.DRAWCHART, function (e) {
                setTimeout(function () {
                    self.highlightedFeature = e.control.currentFeature;
                }, 50);
            })
            .on(TC.Consts.event.LAYERREMOVE, function () {
                if (self.info && self.info.services) {
                    const services = {};
                    self.map.workLayers
                        .filter(function (layer) {
                            return layer.type === TC.Consts.layerType.WMS;
                        })
                        .forEach(function (layer) {
                            const names = services[layer.url] || [];
                            services[layer.url] = names.concat(layer.getDisgregatedLayerNames())
                        });
                    for (var i = 0, len = self.info.services.length; i < len; i++) {
                        const service = self.info.services[i];
                        const mapNames = services[service.mapLayers[0].url] || [];
                        const infoNames = service.layers.reduce(function (arr, layer) {
                            return arr.concat(layer.name);
                        }, []);
                        if (!infoNames.every(function (name) {
                            return mapNames.indexOf(name) >= 0;
                        })) {
                            // En el objeto info hay capas que no están ya en el mapa: borramos resultados.
                            self.downplayFeatures();
                            self.info = null;
                            self.closeResults();
                            break;
                        }
                    }
                }
            })
            .on(TC.Consts.event.VIEWCHANGE, function (e) {                
                self.closeResults();
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        // Este div se usa como buffer, así que no debe ser visible.
        self.div.classList.add(TC.Consts.classes.HIDDEN);
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.responseCallback = function (options) {
        const self = this;
        self.querying = false;

        if (self.filterFeature) {
            self.info = { services: options.services };
        }

        if (!options.featureCount) {
            self.lastFeatureCount = 0;
            self.map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self });
            self.closeResults();
        }
        else {
            self._addSourceAttributes();
            self.lastFeatureCount = options.featureCount;
            self.map.trigger(TC.Consts.event.FEATUREINFO, TC.Util.extend({ control: self }, options));
        }
    };

    ctlProto.responseError = function (options) {
        const self = this;
        if (options.status === 404) {
            self.map.toast(self.getLocaleString("featureInfo.tooManyLayers"), { type: TC.Consts.msgType.ERROR });
        }
        self.responseCallback({});
    };

    ctlProto.markerStyle = {
        cssClass: TC.Consts.classes.POINT,
        anchor: [0.5, 0.5],
        width: 15,
        height: 15,
        noPrint: true
    };

    ctlProto.setDisplayMode = function (mode) {
        var self = this;
        self.displayMode = mode;
        var map = self.map;
        switch (mode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (!self.resultsPanel) {
                    var rp = map.getControlsByClass('TC.control.ResultsPanel').filter(function (ctrl) { return ctrl.options.content === "table" })[0];
                    if (rp) {
                        self.resultsPanel = rp;
                        rp.caller = self;
                    }
                    else {
                        var setResultsPanel = function setResultsPanel(e) {
                            const control = e.control;
                            if (TC.control.ResultsPanel && control instanceof TC.control.ResultsPanel) {
                                self.resultsPanel = control;
                                control.caller = self;
                                map.off(TC.Consts.event.CONTROLADD, setResultsPanel);
                            }
                        };
                        map.on(TC.Consts.event.CONTROLADD, setResultsPanel);
                    }
                }
                break;
            default:
                self.displayMode = TC.control.FeatureInfoCommons.displayMode.POPUP;
                if (!self.popup) {
                    map.addControl('popup', {
                        closeButton: true,
                        draggable: self.options.draggable
                    }).then(function (popup) {
                        self.popup = popup;
                        popup.caller = self;
                        map.on(TC.Consts.event.POPUP, function (e) {
                            self.onShowPopup(e);
                        });

                        map.on(TC.Consts.event.POPUPHIDE, function (e) {
                            if (e.control === popup) {
                                //restaurar el ancho automático
                                self._resetSize();
                            }
                        });
                    });
                }
                break;
        }
    };

    ctlProto.getDisplayControl = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel;
            default:
                return self.popup;
        }
    };

    ctlProto.getDisplayTarget = function (options) {
        var self = this;
        options = options || {};
        if (options.control) {
            switch (true) {
                case TC.control.Popup && options.control instanceof TC.control.Popup:
                    return options.control.getContainerElement();
                case TC.control.ResultsPanel && options.control instanceof TC.control.ResultsPanel:
                    return options.control.getTableContainer();
                default:
                    return null;
            }
        }
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getTableContainer();
            default:
                return self.popup.getContainerElement();
        }
    };

    ctlProto.getMenuTarget = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getMenuElement();
            default:
                return self.popup.getMenuElement();
        }
    };

    ctlProto.displayResults = function () {
        var self = this;
        const clone = self.div.cloneNode(true);
        clone.classList.remove(TC.Consts.classes.HIDDEN);
        self.filterFeature.data = clone.outerHTML;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel) {

                    // GLS: si contamos con el control de controles no es necesario cerrar los paneles visibles ya que no habría solape
                    if (self.map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                        self.map.getControlsByClass(TC.control.ResultsPanel).forEach(function (p) {
                            if (p.isVisible()) {
                                p.close();
                            }
                        });
                    } else {
                        // cerramos los paneles con feature asociada
                        const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                        panels.forEach(function (p) {
                            if (p !== self.resultsPanel && p.currentFeature) {
                                p.close();
                            }
                        });
                    }

                    self.resultsPanel.currentFeature = self.filterFeature;
                    self.resultsPanel.open(self.filterFeature.data, self.resultsPanel.getInfoContainer());
                    

                    self.displayResultsCallback();
                }

                break;
            default:
                if (self.popup) {
                    self.filterFeature.showPopup(self.popup);
                }
                break;
        }
    };

    const getElementIndex = function (elm) {
        return Array.from(elm.parentElement.childNodes).indexOf(elm);
    };

    const getParentElement = function (elm, tagName) {
        var result = elm;
        do {
            result = result.parentElement;
        }
        while (result && result.tagName !== tagName);
        return result;
    };

    ctlProto.getFeatureElement = function (feature) {
        const self = this;
        var result;
        const getIndex = function (elm) {
            return Array.from(elm.parentElement.childNodes).getIndex(elm);
        };
        self.getDisplayTarget().querySelectorAll(self._selectors.LIST_ITEM).forEach(function (li) {
            const currentFeatureLi = li;
            const currentLayerLi = getParentElement(li, 'LI');
            const currentServiceLi = getParentElement(currentLayerLi, 'LI');
            var feat = self.getFeature(getElementIndex(currentServiceLi), getElementIndex(currentLayerLi), getElementIndex(currentFeatureLi));
            if (feat === feature) {
                result = currentFeatureLi;
            }
        });
        return result;
    };

    ctlProto.getNextFeatureElement = function (delta) {
        const self = this;
        const lis = self.getDisplayTarget().querySelectorAll('ul.' + self.CLASS + '-features > li');
        const length = lis.length;
        for (var i = 0; i < length; i++) {
            if (lis[i].matches('.' + TC.Consts.classes.CHECKED)) {
                return lis[(i + delta + length) % length]
            }
        }
        return null;
    };

    ctlProto.getFeaturePath = function (feature) {
        const self = this;
        if (self.info && self.info.services) {
            for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                const service = self.info.services[i];
                for (var j = 0, jj = service.layers.length; j < jj; j++) {
                    const layer = service.layers[j];
                    for (var k = 0, kk = layer.features.length; k < kk; k++) {
                        if (layer.features[k] === feature) {
                            return {
                                service: service.title || service.mapLayers.reduce(function (prev, cur) {
                                    return prev || cur.title;
                                }, ''),
                                layer: layer.path
                            };
                        }
                    }
                }
            }
        }
        return null;
    };

    ctlProto.closeResults = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel && self.resultsPanel.isVisible()) {
                    self.resultsPanel.close();
                }
                break;
            default:
                if (self.popup && self.popup.isVisible()) {
                    self.popup.hide();
                }
                break;
        }
    };

    ctlProto.displayResultsCallback = function () {
        var self = this;
        const content = self.getDisplayTarget().querySelector('.' + self.CLASS);

        var selector;
        // Evento para resaltar una feature
        var eventType = 'click'; // En iPad se usa click en vez de touchstart para evitar que se resalte una feature al hacer scroll
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(self._selectors.LIST_ITEM, function (e) {
            self.highlightFeature(e.target);
        }));

        // Evento para ir a la siguiente feature
        eventType = TC.Consts.event.CLICK;
        selector = '.' + self.CLASS + '-btn-next';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(1), 1);
            return false;
        }));

        // Evento para ir a la feature anterior
        selector = '.' + self.CLASS + '-btn-prev';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(-1), -1);
            return false;
        }));

        // Evento para desplegar/replegar features de capa
        selector = 'ul.' + self.CLASS + '-layers h4';

        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            const li = getParentElement(e.target, 'LI');
            if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                // Si no está en modo móvil ocultamos la capa (si hay más de una)
                const anotherLayer = content.querySelector('.tc-ctl-finfo-layers li:not(.tc-checked)');
                if (anotherLayer && getComputedStyle(anotherLayer).display !== 'none') {
                    self.downplayFeatures();
                }
            }
            else {
                self.highlightFeature(li.querySelector(self._selectors.LIST_ITEM));
                if (self.displayMode === TC.control.FeatureInfoCommons.displayMode.POPUP) {
                    self.popup.fitToView(true);
                }
            }
        }));

        // Evento para borrar la feature resaltada
        selector = '.' + self.CLASS + '-del-btn';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.downplayFeatures();
            self.closeResults();
        }));

        if (self.info) {
            if (self.info.defaultFeature && self.getFeatureElement(self.info.defaultFeature)) {
                self.getFeatureElement(self.info.defaultFeature).classList.add(TC.Consts.classes.DEFAULT);
                self.highlightFeature(self.info.defaultFeature);
            }
            else if (content.querySelector(self._selectors.LIST_ITEM)) {
                self.highlightFeature(content.querySelector(self._selectors.LIST_ITEM));
            }
        }

        content.querySelectorAll('table').forEach(function (table) {
            table.addEventListener(TC.Consts.event.CLICK, function (e) {                
                const li = this.parentElement;
                if (li.classList.contains(TC.Consts.classes.DISABLED)) {
                    return;
                }
                if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                    // Si ya está seleccionada hacemos zoom
                    if (self.resultsLayer.features[0] && window.getSelection() && window.getSelection().toString().trim().length === 0) {
                        // Proceso para desactivar highlightFeature mientras hacemos zoom
                        var zoomHandler = function zoomHandler() {
                            self._zooming = false;
                            self.map.off(TC.Consts.event.ZOOM, zoomHandler);
                        };
                        self.map.on(TC.Consts.event.ZOOM, zoomHandler);
                        self._zooming = true;
                        ///////
                        
                        self.map.zoomToFeatures([self.resultsLayer.features[0]], { animate: true });
                    }
                }
                else {
                    // Si no está seleccionada la seleccionamos
                    self.highlightFeature(li);
                }
                e.stopPropagation();
            });
        });
        content.querySelectorAll('table a').forEach(function (a) {
            a.addEventListener(TC.Consts.event.CLICK, function (e) {
                e.stopPropagation();
            });
        });

        if (TC.browserFeatures.touch() && self.displayMode === TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL) {
            if (content.querySelector('.' + self.CLASS + '-btn-prev').style.display !== 'none') { // Si los botones de anterior/siguiente están visibles, montamos el swipe
                if (self.resultsPanel) {
                    TC.Util.swipe(self.resultsPanel.div, 'disable');
                }

                if (layerCount(self) > 1) {
                    TC.Util.swipe(content, {
                        left: function () {
                            self.highlightFeature(self.getNextFeatureElement(1), 1);
                        },
                        right: function () {
                            self.highlightFeature(self.getNextFeatureElement(-1), -1);
                        }
                    });
                }
            }
        }
    };

    ctlProto.onShowPopup = function (e) {
        const self = this;
        if (e.control === self.popup) {

            self.displayResultsCallback();

            //ajustar el ancho para que no sobre a la derecha
            self._fitSize();
        }
    };

    ctlProto.loadSharedFeature = function (featureObj) {

    };

    ctlProto.insertLinks = function () {
        var self = this;
        const linkText = self.getLocaleString('open');
        const titleText = self.getLocaleString('linkInNewWindow');
        self.div.querySelectorAll('td.' + self.CLASS + '-val').forEach(function (td) {
            const text = td.textContent;
            if (TC.Util.isURL(text)) {
                td.innerHTML = '<a href="' + text + '" target="_blank" title="' + titleText + '">' + linkText + '</a>';
            }
        });
    };

    ctlProto.highlightFeature = function (featureOrElement, delta) {
        const self = this;
        var feature;
        if (!self._zooming) {
            var featureLi;
            // this puede ser o el elemento HTML de la lista correspondiente a la feature o la feature en sí
            if (featureOrElement instanceof TC.Feature) {
                feature = featureOrElement;
                featureLi = self.getFeatureElement(feature);
            }
            else {
                featureLi = featureOrElement;
                while (featureLi && featureLi.tagName !== 'LI') {
                    featureLi = featureLi.parentElement;
                }
            }
            const layerLi = getParentElement(featureLi, 'LI');
            const serviceLi = getParentElement(layerLi, 'LI');

            const serviceIdx = getElementIndex(serviceLi);
            const layerIdx = getElementIndex(layerLi);
            const featureIdx = getElementIndex(featureLi);
            feature = feature || self.getFeature(serviceIdx, layerIdx, featureIdx);

            self.downplayFeatures({ exception: feature });
            featureLi.classList.add(TC.Consts.classes.CHECKED);
            layerLi.classList.add(TC.Consts.classes.CHECKED);
            serviceLi.classList.add(TC.Consts.classes.CHECKED);
            if (delta > 0) {
                featureLi.classList.add(TC.Consts.classes.FROMLEFT);
                layerLi.classList.add(TC.Consts.classes.FROMLEFT);
                serviceLi.classList.add(TC.Consts.classes.FROMLEFT);
            }
            else if (delta < 0) {
                featureLi.classList.add(TC.Consts.classes.FROMRIGHT);
                layerLi.classList.add(TC.Consts.classes.FROMRIGHT);
                serviceLi.classList.add(TC.Consts.classes.FROMRIGHT);
            }

            if (featureLi.querySelector('table')) {
                featureLi.querySelector('table').setAttribute('title', self.getLocaleString('clickToCenter'));
            }

            self.highlightedFeature = feature;

            if (self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current')) {
                self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current').innerHTML = self.getFeatureIndex(serviceIdx, layerIdx, featureIdx) + 1;
            }


            var features = self.resultsLayer.features.slice();
            var featureAlreadyHighlighted = features.filter(function (item) {
                return feature && feature.id === item.id;
            });

            //Si la feature a resaltar ya está resaltada, no hacemos nada. Así evitamos parpadeo
            if (featureAlreadyHighlighted.length > 0) {
                return;
            }

            for (var i = 0; i < features.length; i++) {
                var f = features[i];
                if (f !== self.filterFeature) {
                    self.resultsLayer.removeFeature(f);
                }
            }
            if (feature && feature.geometry) {
                self.resultsLayer.addFeature(feature);
            }
            else {
                featureLi.classList.add(TC.Consts.classes.DISABLED);
            }
        }
    };

    ctlProto.downplayFeatures = function (options) {
        const self = this;
        options = options || {};
        if (self.highlightedFeature !== options.exception) {
            self.highlightedFeature = null;
        }
        const exceptionFLi = options.exception ? self.getFeatureElement(options.exception) : undefined;
        var exceptionLLi, exceptionSLi;
        if (exceptionFLi) {
            exceptionLLi = getParentElement(exceptionFLi, 'LI');
            exceptionSLi = getParentElement(exceptionLLi, 'LI');
        }

        self.resultsLayer.clearFeatures();
        const target = self.getDisplayTarget();
        Array.from(target.querySelectorAll('ul.' + self.CLASS + '-services li'))
            .filter(function (li) {
                return li !== exceptionFLi && li !== exceptionLLi && li !== exceptionSLi;
            })
            .forEach(function (li) {
                li.classList.remove(
                    TC.Consts.classes.CHECKED,
                    TC.Consts.classes.DISABLED,
                    TC.Consts.classes.FROMLEFT,
                    TC.Consts.classes.FROMRIGHT);
            });
        target.querySelectorAll('.' + self.CLASS + '-features table').forEach(function (table) {
            table.setAttribute('title', self.getLocaleString('clickToShowOnMap'));
        });
    };

    ctlProto._fitSize = function () {
        const self = this;
        const target = self.getDisplayTarget();
        var max = 0;
        //medir la máxima anchura de <ul>
        target.querySelectorAll(".tc-ctl-finfo-features li").forEach(function (elm) {
            max = Math.max(max, elm.offsetLeft + elm.offsetWidth);
        });

        //alert("max=" + max);
        if (max) {
            target.style.width = max + 50 + 'px';
        }
    };

    ctlProto._resetSize = function () {
        const self = this;
        self.getDisplayTarget().style.removeProperty('width');
    };

    ctlProto.getFeature = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result;
        const info = self.info;
        if (info && info.services) {
            result = info.services[serviceIdx];
            if (result) {
                result = result.layers[layerIdx];
                if (result) {
                    result = result.features[featureIdx];
                }
            }
        }
        return result;
    };

    ctlProto.getFeatureIndex = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result = -1;
        const info = self.info;
        if (info) {
            for (var i = 0; i <= serviceIdx; i++) {
                var service = info.services[i];
                var maxj = i === serviceIdx ? layerIdx : service.layers.length - 1;
                for (var j = 0; j <= maxj; j++) {
                    var layer = service.layers[j];
                    var maxk = j === layerIdx ? featureIdx : layer.features.length - 1;
                    for (var k = 0; k <= maxk; k++) {
                        result = result + 1;
                    }
                }
            }
        }
        return result;
    };

    ctlProto.beforeRequest = function (options) {
        var self = this;
        self.querying = true;
        self.map.trigger(TC.Consts.event.BEFOREFEATUREINFO, {
            xy: options.xy,
            control: self
        });
        self.closeResults();
        if (self.map && self.resultsLayer) {
            self.lastFeatureCount = null;

            self.resultsLayer.features.forEach(function (feature) {
                self.resultsLayer.removeFeature(feature);
            });
            self.info = null;
        }
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.wrap) {
            self.wrap.activate();
        }
        TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function (stopChain) {
        var self = this;
        if (self.popup) {
            self.popup.hide();
        }
        self.resultsLayer.clearFeatures();
        self.filterLayer.clearFeatures();
        self.filterFeature = null;
        if (self.wrap) {
            self.wrap.deactivate();
        }
        TC.Control.prototype.deactivate.call(self, stopChain);
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.resultsLayer) {
            return {
                id: self.id,
                layer: self.resultsLayer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self._layersPromise.then(function () {
            self.resultsLayer.importState(state.layer);
        });
    };

    ctlProto._createLayers = function () {
        const self = this;

        var resultsLayer;
        if (self.options.resultsLayer) { // En caso de que se haya indicado una capa por configuración, la utilizamos
            resultsLayer = self.options.resultsLayer;
        } else {
            resultsLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Results layer',
                type: TC.Consts.layerType.VECTOR,
                stealth: true
            };
        }
        var filterLayer;
        if (self.options.filterLayer) {
            filterLayer = self.options.filterLayer;
        }
        else {
            filterLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Filter layer',
                stealth: true,
                type: TC.Consts.layerType.VECTOR
                , styles: {
                    line: { strokeColor: self.lineColor, strokeWidth: 2 },
                    polygon: { strokeColor: self.lineColor, strokeWidth: 2, fillColor: "#000", fillOpacity: 0.3 }
                }
            };
        }

        const map = self.map;
        self._layersPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                Promise.all([map.addLayer(resultsLayer), map.addLayer(filterLayer)]).then(function (layers) {
                    self.resultsLayer = layers[0];
                    self.filterLayer = layers[1];
                    resolve();
                });
            });
        });

        return self._layersPromise;
    };

    ctlProto._decorateDisplay = function (ctl) {
        const self = this;        

        const resultsContainer = self.getDisplayTarget({ control: ctl });

        // Añadimos botón de imprimir
        TC.loadJS(
            !TC.control.Print,
            [TC.apiLocation + 'TC/control/Print'],
            function () {
                if (!resultsContainer.querySelectorAll('.' + TC.control.Print.prototype.CLASS + '-btn').length) {
                    var printTitle = self.getLocaleString("feature");
                    if (ctl === self.getDisplayControl()) {
                        if (TC.feature.Point && self.filterFeature instanceof TC.feature.Point) {
                            const geom = self.filterFeature.geometry;
                            printTitle = self.getLocaleString('featuresAt', {
                                crs: self.map.crs,
                                x: TC.Util.formatNumber(geom[0], self.map.locale),
                                y: TC.Util.formatNumber(geom[1], self.map.locale)
                            });
                        }
                        else {
                            printTitle = self.getLocaleString('spatialQueryResults');
                        }
                    }
                    else if (ctl.currentFeature) {
                        printTitle = ctl.currentFeature.id;
                    }
                    // Si hay datos porque el popup es de un GFI con éxito o es de una feature resaltada damos la opción de imprimirlos
                    if (self.lastFeatureCount || (ctl.currentFeature && ctl.currentFeature.showsPopup === true)) {
                        new TC.control.Print({
                            target: resultsContainer,
                            title: printTitle
                        });
                    }
                }
            }
        );
    };

    ctlProto._addSourceAttributes = function () {
        const self = this;
        const serviceAttrName = 'h3_' + self.getLocaleString('service');
        const layerAttrName = 'h4_' + self.getLocaleString('layer');
        // Añadimos como atributos los títulos de servicio y capa
        if (self.info && self.info.services) {
            self.info.services.forEach(function (service) {
                service.layers.forEach(function (layer) {
                    layer.features.forEach(function (feature) {
                        if (feature instanceof TC.Feature) {
                            const path = self.getFeaturePath(feature);
                            if (path) {
                                const newData = {};
                                newData[serviceAttrName] = path.service;
                                if (path.layer) {
                                    newData[layerAttrName] = path.layer.join(self.TITLE_SEPARATOR);
                                }
                                const allData = TC.Util.extend(newData, feature.getData());
                                feature.clearData();
                                feature.setData(allData);
                            }
                        }
                    });
                });
            });
        }
    };

})();

TC.control = TC.control || {};
TC.Consts = TC.Consts || {};
TC.Consts.SCREEN_SIZE_KEY = 'TC.Map.screenSize';

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Scale = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.Scale, TC.Control);

(function () {
    var ctlProto = TC.control.Scale.prototype;

    ctlProto.CLASS = 'tc-ctl-scl';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Scale.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"ol-scale-line ol-unselectable\"><span>1:").h("math", ctx, {}, { "key": body_1, "method": "round" }).w("</span> <input type=\"button\" value=\"").f(ctx.get(["screenSize"], false), ctx, "h").w("''\" title=\"").h("i18n", ctx, {}, { "$key": "estimatedMapSize" }).w("\" /></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.f(ctx.get(["scale"], false), ctx, "h"); } body_1.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize }, function () {

            const span = self.div.querySelector('span');
            span.textContent = '1:' + self.format(span.textContent.substr(2));

            self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        var screenSize = TC.Util.storage.getLocalValue(TC.Consts.SCREEN_SIZE_KEY);
        if (screenSize) {
            TC.Cfg.screenSize = screenSize;
        }
        self.render(function () {
            map.on(TC.Consts.event.ZOOM, function () {
                delete self.metersPerDegree;
                self.update();
            });
        });

        return result;
    };

    ctlProto.update = function () {
        this.render();
    };

    /*
     *  setScreenSize: Prompts for screen size in inches, updates and stores value
     */
    ctlProto.setScreenSize = function () {
        var self = this;
        TC.prompt(self.getLocaleString('selectScreenSize'), TC.Cfg.screenSize, function (value) {
            if (value) {
                TC.Cfg.screenSize = parseFloat(value);
                TC.Util.storage.setLocalValue(TC.Consts.SCREEN_SIZE_KEY, TC.Cfg.screenSize);
                self.update();
            }
        });
    };

    /*
     *  getScale: Gets scale denominator with a resolution or current map resolution and estimated screen DPI
     *  Parameters: number (optional), the resolution to get scale from. If no parameter is given, current map resolution is used
     *  Returns: number
     */
    ctlProto.getScale = function (resolution) {
        var self = this;
        var result = 0;
        var res = (!resolution && self.map) ? self.map.wrap.getResolution() : resolution;
        if (res) {
            result = res * self.getDpi(TC.Cfg.screenSize) / .0254;
            if (window.devicePixelRatio) {
                result = result * window.devicePixelRatio;
            }
        }
        if (self.map && self.map.wrap.isGeo()) {
            if (!self.metersPerDegree) {
                var extent = self.map.getExtent();
                if (extent) {
                    self.metersPerDegree = TC.Util.getMetersPerDegree(extent);
                }
            }
            if (self.metersPerDegree) {
                result = result * self.metersPerDegree;
            }
        }
        return result;
    };

    /*
     *  getDpi: Gets estimated DPI based on screen resolution and screenSize value
     *  Returns: number
     */
    ctlProto.getDpi = function (screenSize) {
        var self = this;
        self.dpi = Math.sqrt(screen.width * screen.width + screen.height * screen.height) / screenSize;
        return self.dpi;
    };


    ctlProto.format = function (number) {
        var n = (new Number(number)).toFixed(0);
        var a = [];
        while (n.length > 3) {
            var l = n.length - 3;
            a.unshift(n.substr(l));
            n = n.substr(0, l);
        }
        if (n) {
            a.unshift(n);
        }
        return a.join('.');
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.SWCacheClient = function () {
        const self = this;
        TC.Control.apply(this, arguments);
        self.serviceWorkerEnabled = false;
    };

    TC.inherit(TC.control.SWCacheClient, TC.Control);

    var ctlProto = TC.control.SWCacheClient.prototype;

    ctlProto.CLASS = 'tc-ctl-swcc';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        // Si el navegador es compatible, añadimos el service worker.
        self._swPromise = new Promise(function (resolve, reject) {
            if (navigator.serviceWorker) {

                navigator.serviceWorker.register('tc-cb-service-worker.js', {
                    scope: './'
                }).then(
                    function (reg) {
                        self.serviceWorkerEnabled = true;
                        if (reg.installing) {
                            resolve(reg.installing);
                        } else if (reg.waiting) {
                            resolve(reg.waiting);
                        } else if (reg.active) {
                            resolve(reg.active);
                        }
                        console.log(reg.scope, 'register');
                    },
                    function (reason) {
                        self.serviceWorkerEnabled = false;
                        reject();
                        console.error('Could not register service worker: ' + reason);
                    });
            }
            else {                
                reject(new Error("Browser does not support service workers"));
            }
        });

        return result;
    };

    ctlProto.getServiceWorker = function () {
        if (!this._swPromise) {
            return Promise.reject(new Error('No service worker available'));
        }
        return this._swPromise;
    };

    var addMessageEventListener = function (resolve, reject, cacheName, action, eventName) {
        var MESSAGE = 'message';
        var messageHandler = function messageHandler(event) {
            if (event.data.name === cacheName) {
                if (event.data.action === action && event.data.event === eventName) {
                    resolve(cacheName);
                }
                else if (event.data.event === 'error') {
                    reject();
                }
                navigator.serviceWorker.removeEventListener(MESSAGE, messageHandler);
            }
        };
        navigator.serviceWorker.addEventListener(MESSAGE, messageHandler);
    };

    ctlProto.createCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'create';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'cached');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    list: opts.urlList || [],
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

    ctlProto.deleteCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'delete';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'deleted');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POINT = 'point.tc';

TC.control.Measure = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.drawControls = [];
    self.persistentDrawControls = false;
    self.NOMEASURE = '-';

    self.exportsState = true;

    this.renderPromise().then(function () {
        self.measureMode = self.options.mode;

        self.history = [];
        self.historyIndex = 0;
        self.reset = true;

        self.wrap = new TC.wrap.control.Measure(self);

        self._len = self.div.querySelector('.tc-ctl-meas-val-len');
        self._area = self.div.querySelector('.tc-ctl-meas-val-area');
        self._peri = self.div.querySelector('.tc-ctl-meas-val-peri');

        self.setMode(self.options.mode);
    });
};

TC.inherit(TC.control.Measure, TC.Control);

(function () {
    var ctlProto = TC.control.Measure.prototype;

    ctlProto.CLASS = 'tc-ctl-meas';

    if (TC.isDebug)
        ctlProto.template = TC.apiLocation + "TC/templates/Measure.html";
    else
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "measure" }).w("</h2><div class=\"tc-ctl-meas-select\"><form><label class=\"tc-ctl-meas-btn-len\"><input type=\"radio\" name=\"mode\" value=\"polyline\" /><span>").h("i18n", ctx, {}, { "$key": "length" }).w("</span></label><label class=\"tc-ctl-meas-btn-area\"><input type=\"radio\" name=\"mode\" value=\"polygon\" /><span>").h("i18n", ctx, {}, { "$key": "areaAndPerimeter" }).w("</span></label></form></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-len tc-hidden\"><div class=\"tc-ctl-meas-line\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "length" }).w(": <span class=\"tc-ctl-meas-val-len\"></span></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-area tc-hidden\"><div class=\"tc-ctl-meas-polygon\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "area" }).w(": <span class=\"tc-ctl-meas-val-area\"></span>, ").h("i18n", ctx, {}, { "$key": "perimeter" }).w(": <span class=\"tc-ctl-meas-val-peri\"></span></div></div>"); } body_0.__dustBody = !0; return body_0 };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(TC.Control.prototype.render.call(self, function () {
            TC.loadJS(
                !TC.control.Draw,
                TC.apiLocation + 'TC/control/Draw',
                function () {
                    if (self.options.mode) {
                        self.div.querySelector('.tc-ctl-meas-select').classList.add(TC.Consts.classes.HIDDEN);
                    }

                    self.div.querySelectorAll(`.${TC.control.Measure.prototype.CLASS}-select span`).forEach(function (span) {
                        span.addEventListener(TC.Consts.event.CLICK, function (e) {
                            var label = this;
                            while (label && label.tagName !== 'LABEL') {
                                label = label.parentElement;
                            }
                            var checkbox = label.querySelector('input[type=radio][name=mode]');
                            var newMode = checkbox.value;

                            checkbox.checked = true;
                            self.setMode(newMode, true);
                        });
                    });

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map).then(function () {
                self.map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (self.map.view === TC.Consts.view.PRINTING) {
                        self.trigger(TC.Consts.event.DRAWEND);
                    }
                });

                const layerId = self.getUID();
                const drawLinesId = self.getUID();
                const drawPolygonsId = self.getUID();

                self.layerPromise = map.addLayer({
                    id: layerId,
                    title: self.getLocaleString('measure'),
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR,
                    styles: {
                        point: map.options.styles.point,
                        line: map.options.styles.line,
                        polygon: map.options.styles.polygon
                    }
                });

                Promise.all([self.layerPromise, self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);

                    self._drawLinesPromise = map.addControl('draw', {
                        id: drawLinesId,
                        div: self.div.querySelector('.tc-ctl-meas-line'),
                        mode: TC.Consts.geom.POLYLINE,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });
                    self._drawPolygonsPromise = map.addControl('draw', {
                        id: drawPolygonsId,
                        div: self.div.querySelector('.tc-ctl-meas-polygon'),
                        mode: TC.Consts.geom.POLYGON,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });

                    Promise.all([self._drawLinesPromise, self._drawPolygonsPromise]).then(function (controls) {
                        self.drawLines = controls[0];
                        self.drawPolygons = controls[1];
                        controls.forEach(function (ctl) {
                            ctl.containerControl = self;
                            self.drawControls.push(ctl);
                            ctl
                                .on(TC.Consts.event.MEASURE + ' ' + TC.Consts.event.MEASUREPARTIAL, function (e) {
                                    self.showMeasures(e);
                                })
                                .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                    // Alerta de condición de carrera si no ponemos un timeout:
                                    // 1- Se llama a cancel de un control Draw.
                                    // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                    // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                    // 4- Se llama a cancel desde aquí.
                                    // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                    // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                    // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                    setTimeout(function () {
                                        self.cancel();
                                    }, 100);
                                });
                            // Desactivamos el método exportState que ya se encarga el control padre de ello
                            ctl.exportsState = false;
                        });

                        resolve(self);
                        self.setMode(self.options.mode);
                    }).catch(reject);
                }).catch(reject);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;

        const modes = [];
        self.div.querySelectorAll('.tc-ctl-meas-mode').forEach(function (elm) {
            modes.push(elm);
        });
        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-len');
                })[0];
                break;
            case TC.Consts.geom.POLYGON:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-area');
                })[0];
                break;
            case null:
            case undefined:
                self._activeMode = null;
                break;
            default:
                break;
        }

        const hiddenModes = modes.filter(function (elm) {
            return elm !== self._activeMode;
        });

        if (mode) {
            const radio = self.div.querySelector('input[type=radio][name=mode][value=' + mode + ']');
            radio.checked = true;
        }
        else {
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.checked = false;
            });
        }
        if (self._activeMode) {
            self._activeMode.classList.remove(TC.Consts.classes.HIDDEN);
            self._activeMode.querySelector('.tc-ctl').classList.remove(TC.Consts.classes.COLLAPSED);
        }
        hiddenModes.forEach(function (elm) {
            elm.classList.add(TC.Consts.classes.HIDDEN);
        });
        return self;
    };

    ctlProto.setMode = function (mode) {
        const self = this;

        self.mode = mode;
        self.displayMode(mode);

        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self.drawLines.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case TC.Consts.geom.POLYGON:
                self.drawPolygons.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case null:
            case undefined:
                self.drawControls.forEach(function (ctl) {
                    if (ctl.isActive) {
                        ctl.cancel();
                    }
                });
                event = TC.Consts.event.CONTROLDEACTIVATE;
                break;
            default:
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
        }

        self.resetValues();

        if (event && self.map) {
            self.map.trigger(event, { control: self });
        }
        return self;
    };

    ctlProto.cancel = function () {
        this.setMode(null, false);
        return this;
    }

    ctlProto.showMeasures = function (options) {
        const self = this;
        options = options || {};
        var units = options.units;
        var precision;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.area) {
            var area = options.area;
            if (area > 10000) {
                area = area / 1000000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._area.innerHTML = TC.Util.formatNumber(area.toFixed(precision), locale) + ' ' + units + '&sup2;';
        }
        if (options.perimeter) {
            var perimeter = options.perimeter;
            if (perimeter > 1000) {
                perimeter = perimeter / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._peri.innerHTML = TC.Util.formatNumber(perimeter.toFixed(precision), locale) + ' ' + units;
        }
        if (options.length) {
            var length = options.length;
            if (length > 1000) {
                length = length / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._len.innerHTML = TC.Util.formatNumber(length.toFixed(precision), locale) + ' ' + units;
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        if (self._len) {
            self._len.textContent = self.NOMEASURE;
            self._area.textContent = self.NOMEASURE;
            self._peri.textContent = self.NOMEASURE;
        }
        return self;
    };

    ctlProto.getDrawLines = function () {

    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.layer) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.layerPromise.then(function (layer) {
            layer.importState(state.layer);
        });
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.ProjectionSelector = function () {
        const self = this;

        TC.Control.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code',
            CHANGE: self.CLASS + '-change',
            NO_CHANGE: self.CLASS + '-no-change'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.' + self._cssClasses.LOAD_CRS_BUTTON + ')', function (e) {
            const crs = e.target.dataset.crsCode;
            if (crs) {
                self.setProjection({
                    crs: crs,
                    allowFallbackLayer: true
                });
            }
        }));

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON, function (e) {
            self.loadFallbackProjections();
        }));
    };

    TC.inherit(TC.control.ProjectionSelector, TC.Control);

    const ctlProto = TC.control.ProjectionSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-projs';

    const _dataKeys = {
        LAYER: 'tcLayer',
        FALLBACK_LAYER: 'tcFallbackLayer'
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        });
        return result;
    };

    ctlProto.getAvailableCRS = function (options) {
        return this.map.getCompatibleCRS(TC.Util.extend(options || {}, { includeFallbacks: true }))
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self._cssClasses.CRS_DIALOG);
        const body = dialog.querySelector('.tc-modal-body');
        body.classList.add(TC.Consts.classes.LOADING);
        const ul = body.querySelector('ul.' + self._cssClasses.CRS_LIST);
        ul.innerHTML = '';
        const blFirstOption = self.map.baseLayer.firstOption || self.map.baseLayer;
        const blFallback = blFirstOption.isRaster() ? blFirstOption.getFallbackLayer() : null;

        const loadProjs = function () {
            var crsList = [];
            var blCRSList = [];

            options = options || {};
            
            if (blFirstOption.isRaster()) {
                blCRSList = blFirstOption.getCompatibleCRS();
                crsList = self.getAvailableCRS(TC.Util.extend(options, {}));
            } else {
                blCRSList = self.map.baseLayers
                    .filter((layer) => {
                        return layer.isRaster();
                    })
                    .map((layer) => {
                        return layer.getCompatibleCRS({ normalized: true, includeFallback: true });
                    })
                    .reduce((prev, current, index, array) => {
                        return prev.concat(current.filter((l) => { return prev.indexOf(l) < 0 }));
                    });

                const crsLists = (options.layer ? self.map.workLayers.concat(options.layer) : self.map.workLayers)
                    .filter(function (layer) {
                        return layer.isRaster();
                    })
                    .map(function (layer) {
                        return layer.getCompatibleCRS({ normalized: true, includeFallback: true });
                    });

                crsList = blCRSList.filter((crs) => {
                    return crsLists.every((elm) => {
                        return elm.indexOf(crs) > -1;
                    });
                });
            }

            self.map.loadProjections({
                crsList: crsList,
                orderBy: 'name'
            }).then(function (projList) {
                var hasFallbackCRS = false;
                var currentCRSName = dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_NAME);
                var currentCRSCode = dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_CODE);
                projList
                    .forEach(function (projObj) {
                        if (currentCRSName && currentCRSCode && TC.Util.CRSCodesEqual(self.map.crs, projObj.code)) {
                            currentCRSName.textContent = projObj.name;
                            currentCRSCode.textContent = projObj.code;
                        }
                        else {
                            const button = document.createElement('button');
                            button.textContent = projObj.name + ' (' + projObj.code + ')';
                            button.dataset.crsCode = projObj.code;
                            const li = document.createElement('li');
                            li.appendChild(button);
                            if (blCRSList.filter(function (crs) {
                                return TC.Util.CRSCodesEqual(crs, projObj.code)
                            }).length === 0) {
                                // Es un CRS del fallback
                                hasFallbackCRS = true;
                                li.classList.add(TC.Consts.classes.HIDDEN);
                                button.classList.add(TC.Consts.classes.WARNING);
                            }
                            ul.appendChild(li);
                        }
                    });
                if (hasFallbackCRS) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                    button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                    li.appendChild(button);
                    ul.appendChild(li);
                }

                // Mostramos un aviso si no hay CRS compatibles
                if (ul.querySelectorAll('li').length === 0) {
                    const li = document.createElement('li');
                    li.innerHTML = self.getLocaleString('thereAreNoCompatibleCRS');
                    ul.appendChild(li);
                }
                const visibleLi = ul.querySelectorAll('li:not(.' + TC.Consts.classes.HIDDEN + ')');
                dialog.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? '' : 'none';
                });
                dialog.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? 'none' : '';
                });
                dialog.querySelector('ul.' + self._cssClasses.CRS_LIST).style.display = visibleLi.length > 0 || hasFallbackCRS ? '' : 'none';
                body.classList.remove(TC.Consts.classes.LOADING);
            });
        };

        if (blFallback) {
            blFallback.getCapabilitiesPromise().then(loadProjs);
        }
        else {
            loadProjs();
        }
        TC.Util.showModal(dialog, options);
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options);
            }
        });
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
        self._dialogDiv.querySelectorAll('p.' + TC.Consts.classes.WARNING).forEach(function (p) {
            p.classList.remove(TC.Consts.classes.HIDDEN);
        })
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? '' : 'none';
        });
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? 'none' : '';
        });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Container = function () {
    var self = this;

    TC.Control.apply(self, arguments);    

    self.controlOptions = self.options.controls || [];

    self.ctlCount = self.controlOptions instanceof Array ? self.controlOptions.length : Object.keys(self.controlOptions).length;    
    self.defaultSelection = self.options.defaultSelection;
};

TC.inherit(TC.control.Container, TC.Control);

(function () {
    var ctlProto = TC.control.Container.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.uids = new Array(self.ctlCount);
        self.uids.forEach(function (elm, idx, arr) {
            arr[idx] = self.getUID();
        });

        return new Promise(function (resolve, rejetc) {
            Promise.all([result, self.renderPromise()]).then(function () {
                self.onRenderPromise();

                resolve();
            });
        });        
    };

    ctlProto.onRenderPromise = function () { };

    ctlProto.render = function (callback) { };

    ctlProto.getControl = function (idx) {
        var promise = this._ctlPromises[idx];
        if (!promise) {
            return new Promise(function (resolve, reject) {
                reject();
            });            
        }

        return promise;
    };

})();

TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.TabContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        TAB: cs + '-tab',
        RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
        ELEMENT: cs + '-elm'
    };    
};

TC.inherit(TC.control.TabContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.TabContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-tctr';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/TabContainer.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").f(ctx.get(["title"], false), ctx, "h").w("</h2><div class=\"tc-ctl-tctr-select\"><form>").s(ctx.get(["controls"], false), ctx, { "block": body_1 }, {}).w("</form></div>").s(ctx.get(["controls"], false), ctx, { "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<label class=\"tc-ctl-tctr-tab tc-ctl-tctr-tab-").f(ctx.get(["$idx"], false), ctx, "h").w("\" style=\"width:calc(100%/").f(ctx.get(["$len"], false), ctx, "h").w(" - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"").f(ctx.get(["$idx"], false), ctx, "h").w("\" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-tctr-elm tc-ctl-tctr-elm-").f(ctx.get(["$idx"], false), ctx, "h").w(" tc-hidden\"></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.onRenderPromise = function () {
        const self = this;

        self.title = self.title || self.getLocaleString(self.options.title || 'moreControls');
        self.div.querySelector('h2').innerHTML = self.title;

        var bufferPromises = new Array(self.ctlCount);
        for (var i = 0, len = self.controlOptions.length; i < len; i++) {
            var ctl = self.controlOptions[i];
            bufferPromises[i] = self.map.addControl(ctl.name, TC.Util.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i)
            }, ctl.options));
        }
        var writeTitle = function (ctl, idx) {
            ctl.renderPromise().then(function () {
                const title = self.getLocaleString(self.controlOptions[idx].title) || ctl.div.querySelector('h2').innerHTML;
                var parent = ctl.div;
                do {
                    parent = parent.parentElement;
                }
                while (parent && !parent.matches(self._classSelector));
                parent.querySelector(self._selectors.TAB + '-' + idx + ' span').innerHTML = title;
            });
        };
        Promise.all(bufferPromises).then(function (controls) {
            for (var i = 0, len = controls.length; i < len; i++) {
                var ctl = controls[i];
                ctl.containerControl = self;
                writeTitle(ctl, i);                
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ title: self.title, controls: self.controlOptions }, function () {

            var clickHandler = function (e) {
                var closest = this;
                while (closest && !closest.matches(self._selectors.TAB)) {
                    closest = closest.parentElement;
                }
                var active, hidden = [];
                const checkbox = closest.querySelector(self._selectors.RADIOBUTTON);
                const newValue = checkbox.value;
                const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                if (self._oldValue === newValue && self.options.deselectable) {
                    setTimeout(function () {
                        checkbox.checked = false;
                    }, 0);
                    self._oldValue = null;
                    active = null;
                    hidden = elms;
                }
                else {
                    elms.forEach(function (elm) {
                        if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                            active = elm;
                        }
                        else {
                            hidden.push(elm);
                        }
                    });
                    self._oldValue = newValue;
                }

                if (active) {
                    active.classList.remove(TC.Consts.classes.HIDDEN);
                }
                hidden.forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
                checkbox.checked = true;
            };

            self.div.querySelectorAll('span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, clickHandler);
            });

            // GLS: Si en el register de control se llama a render, ¿por qué volvemos a llamarlo aquí?
            //for (var i = 0, len = self._ctlPromises.length; i < len; i++) {
            //    self.getControl(i).then(function (ctl) {
            //        ctl.render();
            //    });
            //}

            if (typeof self.defaultSelection === 'number') {
                clickHandler.call(self.div.querySelectorAll(self._selectors.RADIOBUTTON)[self.defaultSelection]);
            }
        }));
    };

})();

(function () {
    /**
     * @const
     * @type {Array<null|string>}
     */
    let NAMESPACE_URIS = [
        null,
        'http://www.topografix.com/GPX/1/0',
        'http://www.topografix.com/GPX/1/1'
    ];


    // GLS: Obtenemos las combinaciones posibles
    const getAllCombinations = function (array) {
        var combi = [];
        var temp = [];

        var len = Math.pow(2, array.length);

        for (var i = 0; i < len; i++) {
            temp = [];
            for (var j = 0; j < array.length; j++) {
                if ((i & Math.pow(2, j))) {
                    if (temp.indexOf(array[j]) == -1)
                        temp.push(array[j]);
                }
            }
            if (temp.length > 0) {
                if (combi.indexOf(temp.join(' ')) == -1)
                    combi.push(temp.join(' '));
            }
        }

        return combi;
    }

    // GLS: Limpiamos de los nuevos los URIS ya disponibles en el formato
    const cleanCombinationsByFormat = function (customURIS, formatURIS) {
        if (customURIS && customURIS.length > 0) {
            for (var i = 0; i < formatURIS.length; i++) {
                var index = customURIS.indexOf(formatURIS[i]);
                if (index > -1)
                    customURIS.splice(index, 1);
            }
        }
    };

    // GLS: Obtenemos los nuevos URIS para KML
    const CUSTOM_NAMESPACE_URIS = getAllCombinations(NAMESPACE_URIS.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(CUSTOM_NAMESPACE_URIS, NAMESPACE_URIS);
    NAMESPACE_URIS = NAMESPACE_URIS.concat(CUSTOM_NAMESPACE_URIS);

    // FLP: No utilizamos directamente ol.format.xsd.readDateTime porque esta función devuelve un timestamp en segundos.
    const readDateTime = function (node) {
        return ol.format.xsd.readDateTime(node) * 1000;
    };

    /**
     * @const
     * @type {string}
     */
    const SCHEMA_LOCATION = 'http://www.topografix.com/GPX/1/1 ' +
        'http://www.topografix.com/GPX/1/1/gpx.xsd';

    /**
     * @const
     * @type {Object<string, function(Node, Array<*>): (ol.Feature|undefined)>}
     */
    const FEATURE_READER = {
        'rte': readRte,
        'trk': readTrk,
        'wpt': readWpt
    };


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GPX_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'rte': ol.xml.makeArrayPusher(readRte),
            'trk': ol.xml.makeArrayPusher(readTrk),
            'wpt': ol.xml.makeArrayPusher(readWpt)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString, 'linkText'),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString, 'linkType')
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const GPX_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'rte': ol.xml.makeChildAppender(writeRte),
            'trk': ol.xml.makeChildAppender(writeTrk),
            'wpt': ol.xml.makeChildAppender(writeWpt)
        });

    const writeDateTimeTextNode = function (node, dateTime) {
        var date = new Date(dateTime);
        var string = date.getUTCFullYear() + '-' +
            ol.string.padNumber(date.getUTCMonth() + 1, 2) + '-' +
            ol.string.padNumber(date.getUTCDate(), 2) + 'T' +
            ol.string.padNumber(date.getUTCHours(), 2) + ':' +
            ol.string.padNumber(date.getUTCMinutes(), 2) + ':' +
            ol.string.padNumber(date.getUTCSeconds(), 2) + 'Z';
        node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
    };

    /**
     * @typedef {Object} Options
     * @property {function(Feature, Node)} [readExtensions] Callback function
     * to process `extensions` nodes. To prevent memory leaks, this callback function must
     * not store any references to the node. Note that the `extensions`
     * node is not allowed in GPX 1.0. Moreover, only `extensions`
     * nodes from `wpt`, `rte` and `trk` can be processed, as those are
     * directly mapped to a feature.
     */

    /**
     * @typedef {Object} LayoutOptions
     * @property {boolean} [hasZ]
     * @property {boolean} [hasM]
     */

    /**
     * @classdesc
     * Feature format for reading and writing data in the GPX format.
     *
     * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first
     * feature of the source.
     *
     * When reading, routes (`<rte>`) are converted into LineString geometries, and
     * tracks (`<trk>`) into MultiLineString. Any properties on route and track
     * waypoints are ignored.
     *
     * When writing, LineString geometries are output as routes (`<rte>`), and
     * MultiLineString as tracks (`<trk>`).
     *
     * @api
     */
    class GPXCustom extends ol.format.GPX {

        /**
         * @param {Options=} opt_options Options.
         */
        constructor(opt_options) {
            super(opt_options);
        }

        /**
         * @inheritDoc
         */
        readFeatureFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return null;
            }
            const featureReader = FEATURE_READER[node.localName];
            if (!featureReader) {
                return null;
            }
            const feature = featureReader(node, [this.getReadOptions(node, opt_options)]);
            if (!feature) {
                return null;
            }
            this.handleReadExtensions_([feature]);
            return feature;
        }

        /**
         * @inheritDoc
         */
        readFeaturesFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return [];
            }
            if (node.localName == 'gpx') {
                /** @type {Array<ol.Feature>} */
                const features = ol.xml.pushParseAndPop([], GPX_PARSERS,
                    node, [this.getReadOptions(node, opt_options)]);
                if (features) {
                    this.handleReadExtensions_(features);
                    return features;
                } else {
                    return [];
                }
            }
            return [];
        }

        writeFeaturesNode(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            //FIXME Serialize metadata
            const gpx = ol.xml.createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');
            const xmlnsUri = 'http://www.w3.org/2000/xmlns/';
            gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', ol.xml.XML_SCHEMA_INSTANCE_URI);
            gpx.setAttributeNS(ol.xml.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);
            gpx.setAttribute('version', '1.1');
            gpx.setAttribute('creator', 'OpenLayers');

            ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */
                ({ node: gpx }), GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
            return gpx;
        }
    };


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const RTE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'number': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'extensions': parseExtensions,
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'rtept': parseRtePt
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const RTEPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'number': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'extensions': parseExtensions,
            'trkseg': parseTrkSeg
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRKSEG_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'trkpt': parseTrkPt
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRKPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const WPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime),
            'magvar': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'geoidheight': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'sym': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'fix': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'sat': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'hdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'vdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'pdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'ageofdgpsdata': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'dgpsid': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'extensions': parseExtensions
        });


    /**
     * @const
     * @type {Array<string>}
     */
    const LINK_SEQUENCE = ['text', 'type'];


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LINK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const RTE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'rtept'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const RTE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'number': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'rtept': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(writeWptType))
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const RTEPT_TYPE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'ele', 'time'
        ]);


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const TRK_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'trkseg'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const TRK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'number': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'trkseg': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(writeTrkSeg))
        });


    /**
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const TRKSEG_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('trkpt');


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const TRKSEG_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'trkpt': ol.xml.makeChildAppender(writeWptType)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const WPT_TYPE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'ele', 'time', 'magvar', 'geoidheight', 'name', 'cmt', 'desc', 'src',
            'link', 'sym', 'type', 'fix', 'sat', 'hdop', 'vdop', 'pdop',
            'ageofdgpsdata', 'dgpsid'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const WPT_TYPE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'time': ol.xml.makeChildAppender(writeDateTimeTextNode),
            'magvar': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'geoidheight': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'sym': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'fix': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'sat': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'hdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'vdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'pdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'ageofdgpsdata': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'dgpsid': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode)
        });


    /**
     * @const
     * @type {Object<string, string>}
     */
    const GEOMETRY_TYPE_TO_NODENAME = {
        'Point': 'wpt',
        'LineString': 'rte',
        'MultiLineString': 'trk'
    };


    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
        const geometry = /** @type {ol.Feature} */ (value).getGeometry();
        if (geometry) {
            const nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
            if (nodeName) {
                const parentNode = objectStack[objectStack.length - 1].node;
                return ol.xml.createElementNS(parentNode.namespaceURI, nodeName);
            }
        }
    }


    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {LayoutOptions} layoutOptions Layout options.
     * @param {Element} node Node.
     * @param {!Object} values Values.
     * @return {Array<number>} Flat coordinates.
     */
    function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
        flatCoordinates.push(
            parseFloat(node.getAttribute('lon')),
            parseFloat(node.getAttribute('lat')));
        if ('ele' in values) {
            flatCoordinates.push(/** @type {number} */(values['ele']));
            delete values['ele'];
            layoutOptions.hasZ = true;
        } else {
            flatCoordinates.push(0);
        }
        if ('time' in values) {
            flatCoordinates.push(/** @type {number} */(values['time']));
            delete values['time'];
            layoutOptions.hasM = true;
        } else {
            flatCoordinates.push(0);
        }
        return flatCoordinates;
    }


    /**
     * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates
     * and ends arrays by shrinking them accordingly (removing unused zero entries).
     *
     * @param {LayoutOptions} layoutOptions Layout options.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {Array<number>=} ends Ends.
     * @return {ol.geom.GeometryLayout} Layout.
     */
    function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
        let layout = ol.geom.GeometryLayout.XY;
        let stride = 2;
        if (layoutOptions.hasZ && layoutOptions.hasM) {
            layout = ol.geom.GeometryLayout.XYZM;
            stride = 4;
        } else if (layoutOptions.hasZ) {
            layout = ol.geom.GeometryLayout.XYZ;
            stride = 3;
        } else if (layoutOptions.hasM) {
            layout = ol.geom.GeometryLayout.XYM;
            stride = 3;
        }
        if (stride !== 4) {
            for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
                flatCoordinates[i * stride] = flatCoordinates[i * 4];
                flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
                if (layoutOptions.hasZ) {
                    flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
                }
                if (layoutOptions.hasM) {
                    flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
                }
            }
            flatCoordinates.length = flatCoordinates.length / 4 * stride;
            if (ends) {
                for (let i = 0, ii = ends.length; i < ii; i++) {
                    ends[i] = ends[i] / 4 * stride;
                }
            }
        }
        return layout;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseLink(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const href = node.getAttribute('href');
        if (href !== null) {
            values['link'] = href;
        }
        ol.xml.parseNode(LINK_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseExtensions(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        values['extensionsNode_'] = node;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseRtePt(node, objectStack) {
        const values = ol.xml.pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
        if (values) {
            const rteValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            const flatCoordinates = /** @type {Array<number>} */ (rteValues['flatCoordinates']);
            const layoutOptions = /** @type {LayoutOptions} */ (rteValues['layoutOptions']);
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseTrkPt(node, objectStack) {
        const values = ol.xml.pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
        if (values) {
            const trkValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            const flatCoordinates = /** @type {Array<number>} */ (trkValues['flatCoordinates']);
            const layoutOptions = /** @type {LayoutOptions} */ (trkValues['layoutOptions']);
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseTrkSeg(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        ol.xml.parseNode(TRKSEG_PARSERS, node, objectStack);
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        const ends = /** @type {Array<number>} */ (values['ends']);
        ends.push(flatCoordinates.length);
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Track.
     */
    function readRte(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({
            'flatCoordinates': [],
            'layoutOptions': {}
        }, RTE_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        delete values['flatCoordinates'];
        const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
        delete values['layoutOptions'];
        const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
        const geometry = new ol.geom.LineString(flatCoordinates, layout);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Track.
     */
    function readTrk(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({
            'flatCoordinates': [],
            'ends': [],
            'layoutOptions': {}
        }, TRK_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        delete values['flatCoordinates'];
        const ends = /** @type {Array<number>} */ (values['ends']);
        delete values['ends'];
        const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
        delete values['layoutOptions'];
        const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
        const geometry = new ol.geom.MultiLineString(flatCoordinates, layout, ends);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Waypoint.
     */
    function readWpt(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({}, WPT_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const layoutOptions = /** @type {LayoutOptions} */ ({});
        const coordinates = appendCoordinate([], layoutOptions, node, values);
        const layout = applyLayoutOptions(layoutOptions, coordinates);
        const geometry = new ol.geom.Point(coordinates, layout);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {string} value Value for the link's `href` attribute.
     * @param {Array<*>} objectStack Node stack.
     */
    function writeLink(node, value, objectStack) {
        node.setAttribute('href', value);
        const context = objectStack[objectStack.length - 1];
        const properties = context['properties'];
        const link = [
            properties['linkText'],
            properties['linkType']
        ];
        ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */({ node: node }),
            LINK_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            link, objectStack, LINK_SEQUENCE);
    }


    /**
     * @param {Element} node Node.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeWptType(node, coordinate, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const namespaceURI = parentNode.namespaceURI;
        const properties = context['properties'];
        //FIXME Projection handling
        node.setAttributeNS(null, 'lat', String(coordinate[1]));
        node.setAttributeNS(null, 'lon', String(coordinate[0]));
        const geometryLayout = context['geometryLayout'];
        switch (geometryLayout) {
            case ol.geom.GeometryLayout.XYZM:
                if (coordinate[3] !== 0) {
                    properties['time'] = coordinate[3];
                }
            // fall through
            case ol.geom.GeometryLayout.XYZ:
                if (coordinate[2] !== 0) {
                    properties['ele'] = coordinate[2];
                }
                break;
            case ol.geom.GeometryLayout.XYM:
                if (coordinate[2] !== 0) {
                    properties['time'] = coordinate[2];
                }
                break;
            default:
            // pass
        }
        const orderedKeys = (node.nodeName == 'rtept') ?
            RTEPT_TYPE_SEQUENCE[namespaceURI] :
            WPT_TYPE_SEQUENCE[namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */
            ({ node: node, 'properties': properties }),
            WPT_TYPE_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeRte(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const properties = feature.getProperties();
        const context = { node: node };
        context['properties'] = properties;
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.LINE_STRING) {
            const lineString = /** @type {ol.geom.LineString} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            context['geometryLayout'] = lineString.getLayout();
            properties['rtept'] = lineString.getCoordinates();
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            RTE_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeTrk(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const properties = feature.getProperties();
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        context['properties'] = properties;
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.MULTI_LINE_STRING) {
            const multiLineString = /** @type {ol.geom.MultiLineString} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            properties['trkseg'] = multiLineString.getLineStrings();
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            TRK_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.geom.LineString} lineString LineString.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeTrkSeg(node, lineString, objectStack) {
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        context['geometryLayout'] = lineString.getLayout();
        context['properties'] = {};
        ol.xml.pushSerializeAndPop(context,
            TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY,
            lineString.getCoordinates(), objectStack);
    }


    /**
     * @param {Element} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeWpt(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const context = objectStack[objectStack.length - 1];
        context['properties'] = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.POINT) {
            const point = /** @type {ol.geom.Point} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            context['geometryLayout'] = point.getLayout();
            writeWptType(node, point.getCoordinates(), objectStack);
        }
    }

    ol.format.GPXCustom = GPXCustom;

})();

/**
 * @typedef {Object} Vec2
 * @property {number} x
 * @property {ol.style.IconAnchorUnits} xunits
 * @property {number} y
 * @property {ol.style.IconAnchorUnits} yunits
 * @property {ol.style.IconOrigin} origin
 */

/**
 * @typedef {Object} GxTrackObject
 * @property {Array<number>} flatCoordinates
 * @property {Array<number>} whens
 */

(function () {

    /**
     * @const
     * @type {Array<string>}
     */
    const GX_NAMESPACE_URIS = [
        'http://www.google.com/kml/ext/2.2'
    ];


    /**
     * @const
     * @type {Array<null|string>}
     */
    let NAMESPACE_URIS = [
        null,
        'http://earth.google.com/kml/2.0',
        'http://earth.google.com/kml/2.1',
        'http://earth.google.com/kml/2.2',
        'http://www.opengis.net/kml/2.2'
    ];

    // GLS: Obtenemos las combinaciones posibles
    const getAllCombinations = function (array) {
        var combi = [];
        var temp = [];

        var len = Math.pow(2, array.length);

        for (var i = 0; i < len; i++) {
            temp = [];
            for (var j = 0; j < array.length; j++) {
                if ((i & Math.pow(2, j))) {
                    if (temp.indexOf(array[j]) == -1)
                        temp.push(array[j]);
                }
            }
            if (temp.length > 0) {
                if (combi.indexOf(temp.join(' ')) == -1)
                    combi.push(temp.join(' '));
            }
        }

        return combi;
    }

    // GLS: Limpiamos de los nuevos los URIS ya disponibles en el formato
    const cleanCombinationsByFormat = function (customURIS, formatURIS) {
        if (customURIS && customURIS.length > 0) {
            for (var i = 0; i < formatURIS.length; i++) {
                var index = customURIS.indexOf(formatURIS[i]);
                if (index > -1)
                    customURIS.splice(index, 1);
            }
        }
    };

    // GLS: Obtenemos los nuevos URIS para KML
    const CUSTOM_NAMESPACE_URIS = getAllCombinations(NAMESPACE_URIS.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(CUSTOM_NAMESPACE_URIS, NAMESPACE_URIS);
    NAMESPACE_URIS = NAMESPACE_URIS.concat(CUSTOM_NAMESPACE_URIS);

    /**
     * @type {Object<string, ol.style.IconAnchorUnits>}
     */
    const ICON_ANCHOR_UNITS_MAP = {
        'fraction': ol.style.IconAnchorUnits.FRACTION,
        'pixels': ol.style.IconAnchorUnits.PIXELS,
        'insetPixels': ol.style.IconAnchorUnits.PIXELS
    };

    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const PLACEMARK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ExtendedData': extendedDataParser,
            'Region': regionParser,
            'MultiGeometry': ol.xml.makeObjectPropertySetter(
                readMultiGeometry, 'geometry'),
            'LineString': ol.xml.makeObjectPropertySetter(
                readLineString, 'geometry'),
            'LinearRing': ol.xml.makeObjectPropertySetter(
                readLinearRing, 'geometry'),
            'Point': ol.xml.makeObjectPropertySetter(
                readPoint, 'geometry'),
            'Polygon': ol.xml.makeObjectPropertySetter(
                readPolygon, 'geometry'),
            'Style': ol.xml.makeObjectPropertySetter(readStyle),
            'StyleMap': placemarkStyleMapParser,
            'address': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'description': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'open': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'phoneNumber': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'styleUrl': ol.xml.makeObjectPropertySetter(readURI),
            'visibility': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'MultiTrack': ol.xml.makeObjectPropertySetter(
                    readGxMultiTrack, 'geometry'),
                'Track': ol.xml.makeObjectPropertySetter(
                    readGxTrack, 'geometry')
            }
        ));


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeObjectPropertySetter(readURI)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const REGION_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LatLonAltBox': latLonAltBoxParser,
            'Lod': lodParser
        });


    /**
     * @type {import("../color.js").Color}
     */
    let DEFAULT_COLOR;

    /**
     * @type {ol.style.Fill}
     */
    let DEFAULT_FILL_STYLE = null;

    /**
     * Get the default fill style (or null if not yet set).
     * @return {ol.style.Fill} The default fill style.
     */
    function getDefaultFillStyle() {
        return DEFAULT_FILL_STYLE;
    }

    /**
     * @type {import("../size.js").Size}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR;

    /**
     * @type {ol.style.IconAnchorUnits}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;

    /**
     * @type {ol.style.IconAnchorUnits}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;

    /**
     * @type {import("../size.js").Size}
     */
    let DEFAULT_IMAGE_STYLE_SIZE;

    /**
     * @type {string}
     */
    let DEFAULT_IMAGE_STYLE_SRC;

    /**
     * @type {number}
     */
    let DEFAULT_IMAGE_SCALE_MULTIPLIER;

    /**
     * @type {import("../style/Image.js").default}
     */
    let DEFAULT_IMAGE_STYLE = null;

    /**
     * Get the default image style (or null if not yet set).
     * @return {import("../style/Image.js").default} The default image style.
     */
    function getDefaultImageStyle() {
        return DEFAULT_IMAGE_STYLE;
    }

    /**
     * @type {string}
     */
    let DEFAULT_NO_IMAGE_STYLE;

    /**
     * @type {ol.style.Stroke}
     */
    let DEFAULT_STROKE_STYLE = null;

    /**
     * Get the default stroke style (or null if not yet set).
     * @return {ol.style.Stroke} The default stroke style.
     */
    function getDefaultStrokeStyle() {
        return DEFAULT_STROKE_STYLE;
    }

    /**
     * @type {ol.style.Stroke}
     */
    let DEFAULT_TEXT_STROKE_STYLE;

    /**
     * @type {ol.style.Text}
     */
    let DEFAULT_TEXT_STYLE = null;

    /**
     * Get the default text style (or null if not yet set).
     * @return {ol.style.Text} The default text style.
     */
    function getDefaultTextStyle() {
        return DEFAULT_TEXT_STYLE;
    }

    /**
     * @type {ol.style.Style}
     */
    let DEFAULT_STYLE = null;

    /**
     * @type {Array<ol.style.Style>}
     */
    let DEFAULT_STYLE_ARRAY = null;

    const getRGBA = function (color, opacity) {
        var result;
        if (color) {
            result = ol.color.asArray(color);
            result = result.slice();
            if (opacity !== undefined) {
                result[3] = opacity;
            }
        }
        else {
            result = [0, 0, 0, 1];
        }
        return result;
    };


    function createStyleDefaults() {
        // Rehacemos los estilos por defecto de KML para que se adecúen al de la API
        DEFAULT_COLOR = [255, 255, 255, 1];

        DEFAULT_FILL_STYLE = new ol.style.Fill({
            color: getRGBA(TC.Cfg.styles.polygon.fillColor, TC.Cfg.styles.polygon.fillOpacity)
        });

        DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2]; // FIXME maybe [8, 32] ?

        DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = ol.style.IconAnchorUnits.PIXELS;

        DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = ol.style.IconAnchorUnits.PIXELS;

        DEFAULT_IMAGE_STYLE_SIZE = [64, 64];

        DEFAULT_IMAGE_STYLE_SRC =
            'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';

        DEFAULT_IMAGE_SCALE_MULTIPLIER = 0.5;

        DEFAULT_IMAGE_STYLE = new ol.style.Icon({
            anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
            anchorOrigin: ol.style.IconOrigin.BOTTOM_LEFT,
            anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
            anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
            crossOrigin: 'anonymous',
            rotation: 0,
            scale: DEFAULT_IMAGE_SCALE_MULTIPLIER,
            size: DEFAULT_IMAGE_STYLE_SIZE,
            src: DEFAULT_IMAGE_STYLE_SRC
        });

        DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';

        DEFAULT_STROKE_STYLE = new ol.style.Stroke({
            color: getRGBA(TC.Cfg.styles.line.strokeColor, 1),
            width: TC.Cfg.styles.line.strokeWidth || 1
        });

        DEFAULT_TEXT_STROKE_STYLE = new ol.style.Stroke({
            color: [51, 51, 51, 1],
            width: 2
        });

        DEFAULT_TEXT_STYLE = new ol.style.Text({
            font: 'bold 16px Helvetica',
            fill: DEFAULT_FILL_STYLE,
            stroke: DEFAULT_TEXT_STROKE_STYLE,
            scale: 0.8
        });

        DEFAULT_STYLE = new ol.style.Style({
            fill: DEFAULT_FILL_STYLE,
            image: DEFAULT_IMAGE_STYLE,
            text: DEFAULT_TEXT_STYLE,
            stroke: DEFAULT_STROKE_STYLE,
            zIndex: 0
        });

        DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];

    }

    const namespaceURISmanage = function (source, format) {
        const xml = ol.xml.parse(source);
        const tags = xml.getElementsByTagName(format.toLowerCase());
        if (tags && tags.length > 0) {
            var value = tags[0].getAttribute('xmlns');
            if (value && value.indexOf(' ') > -1 && NAMESPACE_URIS.indexOf(value) > -1) {
                const values = value.split(' ');
                const namespaces = [];
                for (var i = 0; i < values.length; i++) {
                    namespaces.push(('xmlns:' + format.toLowerCase() + i) + "=\"" + values[i].trim() + "\"");
                }
            }
        }

        return source;
    };

    /**
     * @typedef {Object} Options
     * @property {boolean} [extractStyles=true] Extract styles from the KML.
     * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
     * @property {Array<ol.style.Style>} [defaultStyle] Default style. The
     * default default style is the same as Google Earth.
     * @property {boolean} [writeStyles=true] Write styles into KML.
     */


    class KMLCustom extends ol.format.KML {

        /**
         * @param {Options=} opt_options Options.
         */
        constructor(opt_options) {

            super(opt_options);

            const options = opt_options ? opt_options : {};


            if (!DEFAULT_STYLE_ARRAY) {
                createStyleDefaults();
            }

            this.defaultStyle_ = options.defaultStyle ?
                options.defaultStyle : DEFAULT_STYLE_ARRAY;
        }

        readFeatures(source, opt_options) {
            if (typeof source === 'string') {
                const kmlTag = '<kml';
                let startIdx = source.indexOf(kmlTag);
                if (startIdx >= 0) {
                    startIdx += kmlTag.length;
                    if (source.indexOf('xmlns:xsi=') < 0) {
                        source = source.substr(0, startIdx) + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' + source.substr(startIdx);
                    }

                    source = namespaceURISmanage(source, 'KML');
                }
            }
            return ol.format.KML.prototype.readFeatures.call(this, source, opt_options);
        }

        readDocumentOrFolder_(node, objectStack) {
            // FIXME use scope somehow
            const parsersNS = ol.xml.makeStructureNS(
                NAMESPACE_URIS, {
                    'Document': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),
                    'Folder': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),
                    'Placemark': ol.xml.makeArrayPusher(this.readPlacemark_, this),
                    'Style': this.readSharedStyle_.bind(this),
                    'StyleMap': this.readSharedStyleMap_.bind(this)
                });
            /** @type {Array<Feature>} */
            const features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack, this);
            if (features) {
                // Reescritura de código para leer las carpetas del KML
                if (node.localName == 'Folder') {
                    for (let i = 0, ii = features.length; i < ii; i++) {
                        const feature = features[i];
                        if (!Array.isArray(feature._folders)) {
                            feature._folders = [];
                        }
                        var nameElm = node.getElementsByTagName('name')[0];
                        if (nameElm) {
                            //feature._folders.unshift(nameElm.innerHTML || nameElm.textContent);
                            // Versión rápida de unshift
                            TC.Util.fastUnshift(feature._folders, nameElm.innerHTML || nameElm.textContent);
                        }
                    }
                }
                ///////////////////////////////////////////////////////
                return features;
            } else {
                return undefined;
            }
        }

        readPlacemark_(node, objectStack) {
            const object = ol.xml.pushParseAndPop({ 'geometry': null },
                PLACEMARK_PARSERS, node, objectStack);
            if (!object) {
                return undefined;
            }
            const feature = new ol.Feature();
            const id = node.getAttribute('id');
            if (id !== null) {
                feature.setId(id);
            }
            const options = objectStack[0];

            const geometry = object['geometry'];
            if (geometry) {
                ol.format.Feature.transformWithOptions(geometry, false, options);
            }
            feature.setGeometry(geometry);
            delete object['geometry'];

            if (this.extractStyles_) {
                let style = object['Style'];
                let styleUrl = object['styleUrl'];
                const styleFunction = createFeatureStyleFunction(
                    style, styleUrl, this.defaultStyle_, this.sharedStyles_,
                    this.showPointNames_);
                feature.setStyle(styleFunction);
            }
            delete object['Style'];
            // we do not remove the styleUrl property from the object, so it
            // gets stored on feature when setProperties is called

            feature.setProperties(object, true);

            return feature;
        }


        // TODO: completar con los cambios en ol-es.
        readSharedStyle_(node, objectStack) {
            const id = node.getAttribute('id');
            if (id !== null) {
                const style = readStyle(node, objectStack);
                if (style) {
                    let styleUri;
                    let baseURI = node.baseURI;
                    if (!baseURI || baseURI == 'about:blank') {
                        baseURI = window.location.href;
                    }
                    if (baseURI) {
                        const url = new URL('#' + id, baseURI);
                        styleUri = url.href;
                    } else {
                        styleUri = '#' + id;
                    }
                    this.sharedStyles_[styleUri] = style;
                }
            }
        }

        /**
         * @inheritDoc
         */
        readFeatureFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return null;
            }
            const feature = this.readPlacemark_(
                node, [this.getReadOptions(node, opt_options)]);
            if (feature) {
                return feature;
            } else {
                return null;
            }
        }

        /**
         * @inheritDoc
         */
        readFeaturesFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return [];
            }
            let features;
            const localName = node.localName;
            if (localName == 'Document' || localName == 'Folder') {
                features = this.readDocumentOrFolder_(
                    node, [this.getReadOptions(node, opt_options)]);
                if (features) {
                    return features;
                } else {
                    return [];
                }
            } else if (localName == 'Placemark') {
                const feature = this.readPlacemark_(
                    node, [this.getReadOptions(node, opt_options)]);
                if (feature) {
                    return [feature];
                } else {
                    return [];
                }
            } else if (localName == 'kml') {
                features = [];
                for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
                    const fs = this.readFeaturesFromNode(n, opt_options);
                    if (fs) {
                        ol.array.extend(features, fs);
                    }
                }
                return features;
            } else {
                return [];
            }
        }
    };

    /**
     * @param {ol.style.Style|undefined} foundStyle Style.
     * @param {string} name Name.
     * @return {ol.style.Style} style Style.
     */
    function createNameStyleFunction(foundStyle, name) {
        let textStyle = null;
        const textOffset = [0, 0];
        let textAlign = 'start';
        if (foundStyle.getImage()) {
            let imageSize = foundStyle.getImage().getImageSize();
            if (imageSize === null) {
                imageSize = DEFAULT_IMAGE_STYLE_SIZE;
            }
            if (imageSize.length == 2) {
                const imageScale = foundStyle.getImage().getScale();
                // Offset the label to be centered to the right of the icon, if there is
                // one.
                textOffset[0] = imageScale * imageSize[0] / 2;
                textOffset[1] = -imageScale * imageSize[1] / 2;
                textAlign = 'left';
            }
        }
        if (foundStyle.getText() !== null) {
            // clone the text style, customizing it with name, alignments and offset.
            // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
            const foundText = foundStyle.getText();
            textStyle = foundText.clone();
            textStyle.setFont(foundText.getFont() || DEFAULT_TEXT_STYLE.getFont());
            textStyle.setScale(foundText.getScale() || DEFAULT_TEXT_STYLE.getScale());
            textStyle.setFill(foundText.getFill() || DEFAULT_TEXT_STYLE.getFill());
            textStyle.setStroke(foundText.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
        } else {
            textStyle = DEFAULT_TEXT_STYLE.clone();
        }
        textStyle.setText(name);
        textStyle.setOffsetX(textOffset[0]);
        textStyle.setOffsetY(textOffset[1]);
        textStyle.setTextAlign(textAlign);

        const nameStyle = new ol.style.Style({
            text: textStyle
        });
        return nameStyle;
    }


    /**
     * @param {Array<ol.style.Style>|undefined} style Style.
     * @param {string} styleUrl Style URL.
     * @param {Array<ol.style.Style>} defaultStyle Default style.
     * @param {!Object<string, (Array<ol.style.Style>|string)>} sharedStyles Shared styles.
     * @param {boolean|undefined} showPointNames true to show names for point placemarks.
     * @return {import("../style/Style.js").StyleFunction} Feature style function.
     */
    function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {

        return (
            /**
             * @param {Feature} feature feature.
             * @param {number} resolution Resolution.
             * @return {Array<ol.style.Style>} Style.
             */
            function (feature, resolution) {
                let drawName = showPointNames;
                /** @type {ol.style.Style|undefined} */
                let nameStyle;
                let name = '';
                if (drawName) {
                    const geometry = feature.getGeometry();
                    if (geometry) {
                        drawName = geometry.getType() === ol.geom.GeometryType.POINT;
                    }
                }

                if (drawName) {
                    name = /** @type {string} */ (feature.get('name'));
                    drawName = drawName && !!name;
                }

                if (style) {
                    if (drawName) {
                        nameStyle = createNameStyleFunction(style[0], name);
                        return style.concat(nameStyle);
                    }
                    return style;
                }
                if (styleUrl) {
                    const foundStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
                    if (drawName) {
                        nameStyle = createNameStyleFunction(foundStyle[0], name);
                        return foundStyle.concat(nameStyle);
                    }
                    return foundStyle;
                }
                if (drawName) {
                    nameStyle = createNameStyleFunction(defaultStyle[0], name);
                    return defaultStyle.concat(nameStyle);
                }
                return defaultStyle;
            }
        );
    }


    /**
     * @param {Array<ol.style.Style>|string|undefined} styleValue Style value.
     * @param {Array<ol.style.Style>} defaultStyle Default style.
     * @param {!Object<string, (Array<ol.style.Style>|string)>} sharedStyles
     * Shared styles.
     * @return {Array<ol.style.Style>} Style.
     */
    function findStyle(styleValue, defaultStyle, sharedStyles) {
        if (Array.isArray(styleValue)) {
            return styleValue;
        } else if (typeof styleValue === 'string') {
            // KML files in the wild occasionally forget the leading `#` on styleUrls
            // defined in the same document.  Add a leading `#` if it enables to find
            // a style.
            if (!(styleValue in sharedStyles) && ('#' + styleValue in sharedStyles)) {
                styleValue = '#' + styleValue;
            }
            return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
        } else {
            return defaultStyle;
        }
    }


    /**
     * @param {Node} node Node.
     * @return {import("../color.js").Color|undefined} Color.
     */
    function readColor(node) {
        const s = ol.xml.getAllTextContent(node, false);
        // The KML specification states that colors should not include a leading `#`
        // but we tolerate them.
        const m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
        if (m) {
            const hexColor = m[1];
            return [
                parseInt(hexColor.substr(6, 2), 16),
                parseInt(hexColor.substr(4, 2), 16),
                parseInt(hexColor.substr(2, 2), 16),
                parseInt(hexColor.substr(0, 2), 16) / 255
            ];

        } else {
            return undefined;
        }
    }


    /**
     * @param {Node} node Node.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    function readFlatCoordinates(node) {
        let s = ol.xml.getAllTextContent(node, false);
        const flatCoordinates = [];
        // The KML specification states that coordinate tuples should not include
        // spaces, but we tolerate them.
        const re =
            /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;
        let m;
        while ((m = re.exec(s))) {
            const x = parseFloat(m[1]);
            const y = parseFloat(m[2]);
            const z = m[3] ? parseFloat(m[3]) : 0;
            flatCoordinates.push(x, y, z);
            s = s.substr(m[0].length);
        }
        if (s !== '') {
            return undefined;
        }
        return flatCoordinates;
    }


    /**
     * @param {Node} node Node.
     * @return {string} URI.
     */
    function readURI(node) {
        const s = ol.xml.getAllTextContent(node, false).trim();
        let baseURI = node.baseURI;
        if (!baseURI || baseURI == 'about:blank') {
            baseURI = window.location.href;
        }

        if (baseURI) {
            // flacunza: Parche para evitar peticiones HTTP desde una página HTTPS
            if (location.protocol === 'https:' && baseURI.indexOf('http://') === 0) {
                baseURI = baseURI.substr(5);
            }
            const url = new URL(s, baseURI);
            return url.href;
        } else {
            return s;
        }
    }


    /**
     * @param {Element} node Node.
     * @return {Vec2} Vec2.
     */
    function readVec2(node) {
        const xunits = node.getAttribute('xunits');
        const yunits = node.getAttribute('yunits');
        let origin;
        if (xunits !== 'insetPixels') {
            if (yunits !== 'insetPixels') {
                origin = ol.style.IconOrigin.BOTTOM_LEFT;
            } else {
                origin = ol.style.IconOrigin.TOP_LEFT;
            }
        } else {
            if (yunits !== 'insetPixels') {
                origin = ol.style.IconOrigin.BOTTOM_RIGHT;
            } else {
                origin = ol.style.IconOrigin.TOP_RIGHT;
            }
        }
        return {
            x: parseFloat(node.getAttribute('x')),
            xunits: ICON_ANCHOR_UNITS_MAP[xunits],
            y: parseFloat(node.getAttribute('y')),
            yunits: ICON_ANCHOR_UNITS_MAP[yunits],
            origin: origin
        };
    }


    /**
     * @param {Node} node Node.
     * @return {number|undefined} Scale.
     */
    function readScale(node) {
        return ol.format.xsd.readDecimal(node);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const STYLE_MAP_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Pair': pairDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<ol.style.Style>|string|undefined} StyleMap.
     */
    function readStyleMapValue(node, objectStack) {
        return ol.xml.pushParseAndPop(undefined,
            STYLE_MAP_PARSERS, node, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const ICON_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Icon': ol.xml.makeObjectPropertySetter(readIcon),
            'heading': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'hotSpot': ol.xml.makeObjectPropertySetter(readVec2),
            'scale': ol.xml.makeObjectPropertySetter(readScale)
        });

    // Creamos un parser para interpretar la plantilla de los bocadillos
    const readText = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'text');
        var s = ol.format.xsd.readString(node);
        return s.trim();
    };

    const balloonStyleParser = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'BalloonStyle');
        // FIXME colorMode
        var object = ol.xml.pushParseAndPop(
            {}, BALLOON_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const type = typeof styleObject;
        ol.asserts.assert(type == 'object' && styleObject != null || type == 'function');
        var textStyle = new ol.style.Text({
            text: (object['text'])
        });
        styleObject['balloonStyle'] = textStyle;
    };

    const BALLOON_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeObjectPropertySetter(readText),
        });

    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function iconStyleParser(node, objectStack) {
        // FIXME refreshMode
        // FIXME refreshInterval
        // FIXME viewRefreshTime
        // FIXME viewBoundScale
        // FIXME viewFormat
        // FIXME httpQuery
        const object = ol.xml.pushParseAndPop(
            {}, ICON_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const IconObject = 'Icon' in object ? object['Icon'] : {};
        const drawIcon = (!('Icon' in object) || Object.keys(IconObject).length > 0);
        let src;
        const href = /** @type {string|undefined} */
            (IconObject['href']);
        if (href) {
            src = href;
        } else if (drawIcon) {
            src = DEFAULT_IMAGE_STYLE_SRC;
        }
        let anchor, anchorXUnits, anchorYUnits;
        let anchorOrigin = ol.style.IconOrigin.BOTTOM_LEFT;
        const hotSpot = /** @type {Vec2|undefined} */
            (object['hotSpot']);
        if (hotSpot) {
            anchor = [hotSpot.x, hotSpot.y];
            anchorXUnits = hotSpot.xunits;
            anchorYUnits = hotSpot.yunits;
            anchorOrigin = hotSpot.origin;
        } else if (src === DEFAULT_IMAGE_STYLE_SRC) {
            anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
            anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
            anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
            anchor = [0.5, 0];
            anchorXUnits = ol.style.IconAnchorUnits.FRACTION;
            anchorYUnits = ol.style.IconAnchorUnits.FRACTION;
        }

        let offset;
        const x = /** @type {number|undefined} */
            (IconObject['x']);
        const y = /** @type {number|undefined} */
            (IconObject['y']);
        if (x !== undefined && y !== undefined) {
            offset = [x, y];
        }

        let size;
        const w = /** @type {number|undefined} */
            (IconObject['w']);
        const h = /** @type {number|undefined} */
            (IconObject['h']);
        if (w !== undefined && h !== undefined) {
            size = [w, h];
        }

        let rotation;
        const heading = /** @type {number} */
            (object['heading']);
        if (heading !== undefined) {
            rotation = ol.math.toRadians(heading);
        }

        let scale = /** @type {number|undefined} */
            (object['scale']);

        if (drawIcon) {
            if (src == DEFAULT_IMAGE_STYLE_SRC) {
                size = DEFAULT_IMAGE_STYLE_SIZE;
                if (scale === undefined) {
                    scale = DEFAULT_IMAGE_SCALE_MULTIPLIER;
                }
            }

            const imageStyle = new ol.style.Icon({
                anchor: anchor,
                anchorOrigin: anchorOrigin,
                anchorXUnits: anchorXUnits,
                anchorYUnits: anchorYUnits,
                crossOrigin: 'anonymous', // FIXME should this be configurable?
                offset: offset,
                offsetOrigin: ol.style.IconOrigin.BOTTOM_LEFT,
                rotation: rotation,
                scale: scale,
                size: size,
                src: src
            });
            styleObject['imageStyle'] = imageStyle;
        } else {
            // handle the case when we explicitly want to draw no icon.
            styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LABEL_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'scale': ol.xml.makeObjectPropertySetter(readScale)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function labelStyleParser(node, objectStack) {
        // FIXME colorMode
        const object = ol.xml.pushParseAndPop(
            {}, LABEL_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const textStyle = new ol.style.Text({
            fill: new ol.style.Fill({
                color: /** @type {import("../color.js").Color} */
                    ('color' in object ? object['color'] : DEFAULT_COLOR)
            }),
            scale: /** @type {number|undefined} */
                (object['scale'])
        });
        styleObject['textStyle'] = textStyle;
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINE_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'width': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function lineStyleParser(node, objectStack) {
        // FIXME colorMode
        // FIXME gx:outerColor
        // FIXME gx:outerWidth
        // FIXME gx:physicalWidth
        // FIXME gx:labelVisibility
        const object = ol.xml.pushParseAndPop(
            {}, LINE_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const strokeStyle = new ol.style.Stroke({
            color: /** @type {import("../color.js").Color} */
                ('color' in object ? object['color'] : DEFAULT_COLOR),
            width: /** @type {number} */ ('width' in object ? object['width'] : 1)
        });
        styleObject['strokeStyle'] = strokeStyle;
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const POLY_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'fill': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'outline': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function polyStyleParser(node, objectStack) {
        // FIXME colorMode
        const object = ol.xml.pushParseAndPop(
            {}, POLY_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const fillStyle = new ol.style.Fill({
            color: /** @type {import("../color.js").Color} */
                ('color' in object ? object['color'] : DEFAULT_COLOR)
        });
        styleObject['fillStyle'] = fillStyle;
        const fill = /** @type {boolean|undefined} */ (object['fill']);
        if (fill !== undefined) {
            styleObject['fill'] = fill;
        }
        const outline = /** @type {boolean|undefined} */ (object['outline']);
        if (outline !== undefined) {
            styleObject['outline'] = outline;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const FLAT_LINEAR_RING_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'coordinates': ol.xml.makeReplacer(readFlatCoordinates)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} LinearRing flat coordinates.
     */
    function readFlatLinearRing(node, objectStack) {
        return ol.xml.pushParseAndPop(null,
            FLAT_LINEAR_RING_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function gxCoordParser(node, objectStack) {
        const gxTrackObject = /** @type {GxTrackObject} */
            (objectStack[objectStack.length - 1]);
        const flatCoordinates = gxTrackObject.flatCoordinates;
        const s = ol.xml.getAllTextContent(node, false);
        const re =
            /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
        const m = re.exec(s);
        if (m) {
            const x = parseFloat(m[1]);
            const y = parseFloat(m[2]);
            const z = parseFloat(m[3]);
            flatCoordinates.push(x, y, z, 0);
        } else {
            flatCoordinates.push(0, 0, 0, 0);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GX_MULTITRACK_GEOMETRY_PARSERS = ol.xml.makeStructureNS(
        GX_NAMESPACE_URIS, {
            'Track': ol.xml.makeArrayPusher(readGxTrack)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.MultiLineString|undefined} MultiLineString.
     */
    function readGxMultiTrack(node, objectStack) {
        const lineStrings = ol.xml.pushParseAndPop([],
            GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
        if (!lineStrings) {
            return undefined;
        }
        return new ol.geom.MultiLineString(lineStrings);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GX_TRACK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'when': whenParser
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'coord': gxCoordParser
            }));


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.LineString|undefined} LineString.
     */
    function readGxTrack(node, objectStack) {
        const gxTrackObject = ol.xml.pushParseAndPop(
    /** @type {GxTrackObject} */({
                flatCoordinates: [],
                whens: []
            }), GX_TRACK_PARSERS, node, objectStack);
        if (!gxTrackObject) {
            return undefined;
        }
        const flatCoordinates = gxTrackObject.flatCoordinates;
        const whens = gxTrackObject.whens;
        for (let i = 0, ii = Math.min(flatCoordinates.length, whens.length); i < ii; ++i) {
            flatCoordinates[4 * i + 3] = whens[i];
        }
        return new ol.geom.LineString(flatCoordinates, ol.geom.GeometryLayout.XYZM);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const ICON_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeObjectPropertySetter(readURI)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'x': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'y': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'w': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'h': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
            }));


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Object} Icon object.
     */
    function readIcon(node, objectStack) {
        const iconObject = ol.xml.pushParseAndPop(
            {}, ICON_PARSERS, node, objectStack);
        if (iconObject) {
            return iconObject;
        } else {
            return null;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GEOMETRY_FLAT_COORDINATES_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'coordinates': ol.xml.makeReplacer(readFlatCoordinates)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    function readFlatCoordinatesFromNode(node, objectStack) {
        return ol.xml.pushParseAndPop(null,
            GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const EXTRUDE_AND_ALTITUDE_MODE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'extrude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'tessellate': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.LineString|undefined} LineString.
     */
    function readLineString(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const lineString = new ol.geom.LineString(flatCoordinates, ol.geom.GeometryLayout.XYZ);
            lineString.setProperties(properties, true);
            return lineString;
        } else {
            return undefined;
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Polygon|undefined} Polygon.
     */
    function readLinearRing(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const polygon = new ol.geom.Polygon(flatCoordinates, ol.geom.GeometryLayout.XYZ, [flatCoordinates.length]);
            polygon.setProperties(properties, true);
            return polygon;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const MULTI_GEOMETRY_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LineString': ol.xml.makeArrayPusher(readLineString),
            'LinearRing': ol.xml.makeArrayPusher(readLinearRing),
            'MultiGeometry': ol.xml.makeArrayPusher(readMultiGeometry),
            'Point': ol.xml.makeArrayPusher(readPoint),
            'Polygon': ol.xml.makeArrayPusher(readPolygon)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    function readMultiGeometry(node, objectStack) {
        const geometries = ol.xml.pushParseAndPop([],
            MULTI_GEOMETRY_PARSERS, node, objectStack);
        if (!geometries) {
            return null;
        }
        if (geometries.length === 0) {
            return new ol.geom.GeometryCollection(geometries);
        }
        let multiGeometry;
        let homogeneous = true;
        const type = geometries[0].getType();
        let geometry;
        for (let i = 1, ii = geometries.length; i < ii; ++i) {
            geometry = geometries[i];
            if (geometry.getType() != type) {
                homogeneous = false;
                break;
            }
        }
        if (homogeneous) {
            let layout;
            let flatCoordinates;
            if (type == ol.geom.GeometryType.POINT) {
                const point = geometries[0];
                layout = point.getLayout();
                flatCoordinates = point.getFlatCoordinates();
                for (let i = 1, ii = geometries.length; i < ii; ++i) {
                    geometry = geometries[i];
                    ol.array.extend(flatCoordinates, geometry.getFlatCoordinates());
                }
                multiGeometry = new ol.geom.MultiPoint(flatCoordinates, layout);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.LINE_STRING) {
                multiGeometry = new ol.geom.MultiLineString(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.POLYGON) {
                multiGeometry = new ol.geom.MultiPolygon(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
                multiGeometry = new ol.geom.GeometryCollection(geometries);
            } else {
                assert(false, 37); // Unknown geometry type found
            }
        } else {
            multiGeometry = new ol.geom.GeometryCollection(geometries);
        }
        return (
    /** @type {import("../geom/Geometry.js").default} */ (multiGeometry)
        );
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Point|undefined} Point.
     */
    function readPoint(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const point = new ol.geom.Point(flatCoordinates, ol.geom.GeometryLayout.XYZ);
            point.setProperties(properties, true);
            return point;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const FLAT_LINEAR_RINGS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'innerBoundaryIs': innerBoundaryIsParser,
            'outerBoundaryIs': outerBoundaryIsParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Polygon|undefined} Polygon.
     */
    function readPolygon(node, objectStack) {
        const properties = ol.xml.pushParseAndPop(/** @type {Object<string,*>} */({}),
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatLinearRings = ol.xml.pushParseAndPop([null],
            FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [flatCoordinates.length];
            for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                ol.array.extend(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            const polygon = new ol.geom.Polygon(flatCoordinates, ol.geom.GeometryLayout.XYZ, ends);
            polygon.setProperties(properties, true);
            return polygon;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'IconStyle': iconStyleParser,
            'LabelStyle': labelStyleParser,
            'LineStyle': lineStyleParser,
            'PolyStyle': polyStyleParser,
            'BalloonStyle': balloonStyleParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<ol.style.Style>} Style.
     */
    function readStyle(node, objectStack) {
        const styleObject = ol.xml.pushParseAndPop(
            {}, STYLE_PARSERS, node, objectStack);
        if (!styleObject) {
            return null;
        }
        let fillStyle = /** @type {ol.style.Fill} */
            ('fillStyle' in styleObject ?
                styleObject['fillStyle'] : DEFAULT_FILL_STYLE);
        const fill = /** @type {boolean|undefined} */ (styleObject['fill']);
        if (fill !== undefined && !fill) {
            fillStyle = null;
        }
        let imageStyle;
        if ('imageStyle' in styleObject) {
            if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {
                imageStyle = styleObject['imageStyle'];
            }
        } else {
            imageStyle = DEFAULT_IMAGE_STYLE;
        }
        const textStyle = /** @type {ol.style.Text} */
            ('textStyle' in styleObject ?
                styleObject['textStyle'] : DEFAULT_TEXT_STYLE);
        let strokeStyle = /** @type {ol.style.Stroke} */
            ('strokeStyle' in styleObject ?
                styleObject['strokeStyle'] : DEFAULT_STROKE_STYLE);
        // GLS: Comento el machaque del estilo de línea por que no haya outline, según la documentación (https://developers.google.com/kml/documentation/kmlreference#style) 
        // es opcional indicar outline
        // Corregimos el bug 25306 No se carga el estilo de VV-del-Irati.kml
        //const outline = /** @type {boolean|undefined} */
        //    (styleObject['outline']);
        //if (outline !== undefined && !outline) {
        //    strokeStyle = null;
        //}
        const balloonStyle = styleObject['balloonStyle'];
        const returnStyle = new ol.style.Style({
            fill: fillStyle,
            image: imageStyle,
            stroke: strokeStyle,
            text: textStyle,
            zIndex: undefined // FIXME
        });
        if (balloonStyle) {
            returnStyle._balloon = balloonStyle;
        }
        return [returnStyle];
    }


    /**
     * Reads an array of geometries and creates arrays for common geometry
     * properties. Then sets them to the multi geometry.
     * @param {ol.geom.MultiPoint|ol.geom.MultiLineString|ol.geom.MultiPolygon} multiGeometry A multi-geometry.
     * @param {Array<import("../geom/Geometry.js").default>} geometries List of geometries.
     */
    function setCommonGeometryProperties(multiGeometry, geometries) {
        const ii = geometries.length;
        const extrudes = new Array(geometries.length);
        const tessellates = new Array(geometries.length);
        const altitudeModes = new Array(geometries.length);
        let hasExtrude, hasTessellate, hasAltitudeMode;
        hasExtrude = hasTessellate = hasAltitudeMode = false;
        for (let i = 0; i < ii; ++i) {
            const geometry = geometries[i];
            extrudes[i] = geometry.get('extrude');
            tessellates[i] = geometry.get('tessellate');
            altitudeModes[i] = geometry.get('altitudeMode');
            hasExtrude = hasExtrude || extrudes[i] !== undefined;
            hasTessellate = hasTessellate || tessellates[i] !== undefined;
            hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
        }
        if (hasExtrude) {
            multiGeometry.set('extrude', extrudes);
        }
        if (hasTessellate) {
            multiGeometry.set('tessellate', tessellates);
        }
        if (hasAltitudeMode) {
            multiGeometry.set('altitudeMode', altitudeModes);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'displayName': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'value': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function dataParser(node, objectStack) {
        const name = node.getAttribute('name');
        ol.xml.parseNode(DATA_PARSERS, node, objectStack);
        const featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        if (name !== null) {
            featureObject[name] = featureObject.value;
        } else if (featureObject.displayName !== null) {
            featureObject[featureObject.displayName] = featureObject.value;
        }
        delete featureObject['value'];
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const EXTENDED_DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Data': dataParser,
            'SchemaData': schemaDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function extendedDataParser(node, objectStack) {
        ol.xml.parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
    }

    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function regionParser(node, objectStack) {
        ol.xml.parseNode(REGION_PARSERS, node, objectStack);
    }

    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const PAIR_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Style': ol.xml.makeObjectPropertySetter(readStyle),
            'key': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'styleUrl': ol.xml.makeObjectPropertySetter(readURI)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function pairDataParser(node, objectStack) {
        const pairObject = ol.xml.pushParseAndPop(
            {}, PAIR_PARSERS, node, objectStack);
        if (!pairObject) {
            return;
        }
        const key = /** @type {string|undefined} */
            (pairObject['key']);
        if (key && key == 'normal') {
            const styleUrl = /** @type {string|undefined} */
                (pairObject['styleUrl']);
            if (styleUrl) {
                objectStack[objectStack.length - 1] = styleUrl;
            }
            const style = /** @type {ol.style.Style} */
                (pairObject['Style']);
            if (style) {
                objectStack[objectStack.length - 1] = style;
            }
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function placemarkStyleMapParser(node, objectStack) {
        const styleMapValue = readStyleMapValue(node, objectStack);
        if (!styleMapValue) {
            return;
        }
        const placemarkObject = objectStack[objectStack.length - 1];
        if (Array.isArray(styleMapValue)) {
            placemarkObject['Style'] = styleMapValue;
        } else if (typeof styleMapValue === 'string') {
            placemarkObject['styleUrl'] = styleMapValue;
        } else {
            assert(false, 38); // `styleMapValue` has an unknown type
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const SCHEMA_DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'SimpleData': simpleDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function schemaDataParser(node, objectStack) {
        ol.xml.parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function simpleDataParser(node, objectStack) {
        const name = node.getAttribute('name');
        if (name !== null) {
            const data = ol.format.xsd.readString(node);
            const featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
            featureObject[name] = data;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LAT_LON_ALT_BOX_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'minAltitude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxAltitude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'north': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'south': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'east': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'west': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function latLonAltBoxParser(node, objectStack) {
        const object = ol.xml.pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const regionObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const extent = [
            parseFloat(object['west']),
            parseFloat(object['south']),
            parseFloat(object['east']),
            parseFloat(object['north'])
        ];
        regionObject['extent'] = extent;
        regionObject['altitudeMode'] = object['altitudeMode'];
        regionObject['minAltitude'] = parseFloat(object['minAltitude']);
        regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LOD_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'minLodPixels': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxLodPixels': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'minFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function lodParser(node, objectStack) {
        const object = ol.xml.pushParseAndPop({}, LOD_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
        lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
        lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
        lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const INNER_BOUNDARY_IS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeReplacer(readFlatLinearRing)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function innerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */
        const flatLinearRing = ol.xml.pushParseAndPop(undefined,
            INNER_BOUNDARY_IS_PARSERS, node, objectStack);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */
                (objectStack[objectStack.length - 1]);
            flatLinearRings.push(flatLinearRing);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const OUTER_BOUNDARY_IS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeReplacer(readFlatLinearRing)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function outerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */
        const flatLinearRing = ol.xml.pushParseAndPop(undefined,
            OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */
                (objectStack[objectStack.length - 1]);
            flatLinearRings[0] = flatLinearRing;
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function linkParser(node, objectStack) {
        ol.xml.parseNode(LINK_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function whenParser(node, objectStack) {
        const gxTrackObject = /** @type {GxTrackObject} */
            (objectStack[objectStack.length - 1]);
        const whens = gxTrackObject.whens;
        const s = ol.xml.getAllTextContent(node, false);
        const when = Date.parse(s);
        whens.push(isNaN(when) ? 0 : when);
    }


    /**
     * @param {Node} node Node to append a TextNode with the color to.
     * @param {import("../color.js").Color|string} color Color.
     */
    function writeColorTextNode(node, color) {
        const rgba = asArray(color);
        const opacity = (rgba.length == 4) ? rgba[3] : 1;
        /** @type {Array<string|number>} */
        const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
        for (let i = 0; i < 4; ++i) {
            const hex = Math.floor(/** @type {number} */(abgr[i])).toString(16);
            abgr[i] = (hex.length == 1) ? '0' + hex : hex;
        }
        ol.format.xsd.writeStringTextNode(node, abgr.join(''));
    }


    /**
     * @param {Node} node Node to append a TextNode with the coordinates to.
     * @param {Array<number>} coordinates Coordinates.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeCoordinatesTextNode(node, coordinates, objectStack) {
        const context = objectStack[objectStack.length - 1];

        const layout = context['layout'];
        const stride = context['stride'];

        let dimension;
        if (layout == ol.geom.GeometryLayout.XY ||
            layout == ol.geom.GeometryLayout.XYM) {
            dimension = 2;
        } else if (layout == ol.geom.GeometryLayout.XYZ ||
            layout == ol.geom.GeometryLayout.XYZM) {
            dimension = 3;
        } else {
            assert(false, 34); // Invalid geometry layout
        }

        const ii = coordinates.length;
        let text = '';
        if (ii > 0) {
            text += coordinates[0];
            for (let d = 1; d < dimension; ++d) {
                text += ',' + coordinates[d];
            }
            for (let i = stride; i < ii; i += stride) {
                text += ' ' + coordinates[i];
                for (let d = 1; d < dimension; ++d) {
                    text += ',' + coordinates[i + d];
                }
            }
        }
        ol.format.xsd.writeStringTextNode(node, text);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const EXTENDEDDATA_NODE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Data': ol.xml.makeChildAppender(writeDataNode),
            'value': ol.xml.makeChildAppender(writeDataNodeValue),
            'displayName': ol.xml.makeChildAppender(writeDataNodeName)
        });


    /**
     * @param {Element} node Node.
     * @param {{name: *, value: *}} pair Name value pair.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeDataNode(node, pair, objectStack) {
        node.setAttribute('name', pair.name);
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const value = pair.value;

        if (typeof value == 'object') {
            if (value !== null && value.displayName) {
                ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                    ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);
            }

            if (value !== null && value.value) {
                ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                    ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);
            }
        } else {
            ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);
        }
    }


    /**
     * @param {Node} node Node to append a TextNode with the name to.
     * @param {string} name DisplayName.
     */
    function writeDataNodeName(node, name) {
        ol.format.xsd.writeCDATASection(node, name);
    }


    /**
     * @param {Node} node Node to append a CDATA Section with the value to.
     * @param {string} value Value.
     */
    function writeDataNodeValue(node, value) {
        ol.format.xsd.writeStringTextNode(node, value);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const DOCUMENT_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Placemark': ol.xml.makeChildAppender(writePlacemark)
        });


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const DOCUMENT_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return ol.xml.createElementNS(parentNode.namespaceURI, 'Placemark');
    };


    /**
     * @param {Node} node Node.
     * @param {Array<Feature>} features Features.
     * @param {Array<*>} objectStack Object stack.
     * @this {KML}
     */
    function writeDocument(node, features, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context, DOCUMENT_SERIALIZERS,
            DOCUMENT_NODE_FACTORY, features, objectStack, undefined,
            this);
    }


    /**
     * A factory for creating Data nodes.
     * @const
     * @type {function(*, Array<*>): (Node|undefined)}
     */
    const DATA_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Data');


    /**
     * @param {Node} node Node.
     * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeExtendedData(node, namesAndValues, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const names = namesAndValues.names;
        const values = namesAndValues.values;
        const length = names.length;

        for (let i = 0; i < length; i++) {
            ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
        }
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const ICON_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'href'
        ],
        ol.xml.makeStructureNS(GX_NAMESPACE_URIS, [
            'x', 'y', 'w', 'h'
        ]));


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const ICON_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'x': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'y': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'w': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'h': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode)
            }));


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const GX_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        return ol.xml.createElementNS(GX_NAMESPACE_URIS[0],
            'gx:' + opt_nodeName);
    };


    /**
     * @param {Node} node Node.
     * @param {Object} icon Icon object.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeIcon(node, icon, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const parentNode = objectStack[objectStack.length - 1].node;
        let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
        let values = ol.xml.makeSequence(icon, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            ICON_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
        orderedKeys =
            ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
        values = ol.xml.makeSequence(icon, orderedKeys);
        ol.xml.pushSerializeAndPop(context, ICON_SERIALIZERS,
            GX_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const ICON_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'scale', 'heading', 'Icon', 'hotSpot'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const ICON_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Icon': ol.xml.makeChildAppender(writeIcon),
            'heading': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'hotSpot': ol.xml.makeChildAppender(writeVec2),
            'scale': ol.xml.makeChildAppender(writeScaleTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../style/Icon.js").default} style Icon style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeIconStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const src = style.getSrc();
        const size = style.getSize();
        const iconImageSize = style.getImageSize();
        const iconProperties = {
            'href': src
        };

        if (size) {
            iconProperties['w'] = size[0];
            iconProperties['h'] = size[1];
            const anchor = style.getAnchor(); // top-left
            const origin = style.getOrigin(); // top-left

            if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
                iconProperties['x'] = origin[0];
                iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);
            }

            if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
                const /** @type {Vec2} */ hotSpot = {
                    x: anchor[0],
                    xunits: ol.style.IconAnchorUnits.PIXELS,
                    y: size[1] - anchor[1],
                    yunits: ol.style.IconAnchorUnits.PIXELS
                };
                properties['hotSpot'] = hotSpot;
            }
        }

        properties['Icon'] = iconProperties;

        const scale = style.getScale();
        if (scale !== 1) {
            properties['scale'] = scale;
        }

        const rotation = style.getRotation();
        if (rotation !== 0) {
            properties['heading'] = rotation; // 0-360
        }

        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const LABEL_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'color', 'scale'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LABEL_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode),
            'scale': ol.xml.makeChildAppender(writeScaleTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Text} style style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeLabelStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const fill = style.getFill();
        if (fill) {
            properties['color'] = fill.getColor();
        }
        const scale = style.getScale();
        if (scale && scale !== 1) {
            properties['scale'] = scale;
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys =
            LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const LINE_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'color', 'width'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LINE_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode),
            'width': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Stroke} style style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeLineStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {
            'color': style.getColor(),
            'width': style.getWidth()
        };
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, string>}
     */
    const GEOMETRY_TYPE_TO_NODENAME = {
        'Point': 'Point',
        'LineString': 'LineString',
        'LinearRing': 'LinearRing',
        'Polygon': 'Polygon',
        'MultiPoint': 'MultiGeometry',
        'MultiLineString': 'MultiGeometry',
        'MultiPolygon': 'MultiGeometry',
        'GeometryCollection': 'MultiGeometry'
    };


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const GEOMETRY_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        if (value) {
            const parentNode = objectStack[objectStack.length - 1].node;
            return ol.xml.createElementNS(parentNode.namespaceURI,
                GEOMETRY_TYPE_TO_NODENAME[/** @type {import("../geom/Geometry.js").default} */ (value).getType()]);
        }
    };


    /**
     * A factory for creating Point nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const POINT_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Point');


    /**
     * A factory for creating LineString nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const LINE_STRING_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('LineString');


    /**
     * A factory for creating LinearRing nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const LINEAR_RING_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('LinearRing');


    /**
     * A factory for creating Polygon nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const POLYGON_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Polygon');


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const MULTI_GEOMETRY_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LineString': ol.xml.makeChildAppender(
                writePrimitiveGeometry),
            'Point': ol.xml.makeChildAppender(
                writePrimitiveGeometry),
            'Polygon': ol.xml.makeChildAppender(writePolygon),
            'GeometryCollection': ol.xml.makeChildAppender(
                writeMultiGeometry)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeMultiGeometry(node, geometry, objectStack) {
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        const type = geometry.getType();
        /** @type {Array<import("../geom/Geometry.js").default>} */
        let geometries;
        /** @type {function(*, Array<*>, string=): (Node|undefined)} */
        let factory;
        if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
            geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();
            factory = GEOMETRY_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_POINT) {
            geometries = /** @type {ol.geom.MultiPoint} */ (geometry).getPoints();
            factory = POINT_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_LINE_STRING) {
            geometries =
                (/** @type {ol.geom.MultiLineString} */ (geometry)).getLineStrings();
            factory = LINE_STRING_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_POLYGON) {
            geometries =
                (/** @type {ol.geom.MultiPolygon} */ (geometry)).getPolygons();
            factory = POLYGON_NODE_FACTORY;
        } else {
            assert(false, 39); // Unknown geometry type
        }
        ol.xml.pushSerializeAndPop(context,
            MULTI_GEOMETRY_SERIALIZERS, factory,
            geometries, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const BOUNDARY_IS_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeChildAppender(
                writePrimitiveGeometry)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/LinearRing.js").default} linearRing Linear ring.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeBoundaryIs(node, linearRing, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context,
            BOUNDARY_IS_SERIALIZERS,
            LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const PLACEMARK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ExtendedData': ol.xml.makeChildAppender(writeExtendedData),
            'MultiGeometry': ol.xml.makeChildAppender(writeMultiGeometry),
            'LineString': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'LinearRing': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'Point': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'Polygon': ol.xml.makeChildAppender(writePolygon),
            'Style': ol.xml.makeChildAppender(writeStyle),
            'address': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'description': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'open': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'phoneNumber': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'styleUrl': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'visibility': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const PLACEMARK_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'open', 'visibility', 'address', 'phoneNumber', 'description',
            'styleUrl', 'Style'
        ]);


    /**
     * A factory for creating ExtendedData nodes.
     * @const
     * @type {function(*, Array<*>): (Node|undefined)}
     */
    const EXTENDEDDATA_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('ExtendedData');


    /**
     * FIXME currently we do serialize arbitrary/custom feature properties
     * (ExtendedData).
     * @param {Element} node Node.
     * @param {Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     * @this {KML}
     */
    function writePlacemark(node, feature, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };

        // set id
        if (feature.getId()) {
            node.setAttribute('id', /** @type {string} */(feature.getId()));
        }

        // serialize properties (properties unknown to KML are not serialized)
        const properties = feature.getProperties();

        // don't export these to ExtendedData
        const filter = {
            'address': 1, 'description': 1, 'name': 1, 'open': 1,
            'phoneNumber': 1, 'styleUrl': 1, 'visibility': 1
        };
        filter[feature.getGeometryName()] = 1;
        const keys = Object.keys(properties || {}).sort().filter(function (v) {
            return !filter[v];
        });

        if (keys.length > 0) {
            const sequence = ol.xml.makeSequence(properties, keys);
            const namesAndValues = { names: keys, values: sequence };
            ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
                EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
        }

        const styleFunction = feature.getStyleFunction();
        if (styleFunction) {
            // FIXME the styles returned by the style function are supposed to be
            // resolution-independent here
            const styles = styleFunction(feature, 0);
            if (styles) {
                const style = Array.isArray(styles) ? styles[0] : styles;
                if (this.writeStyles_) {
                    properties['Style'] = style;
                }
                const textStyle = style.getText();
                if (textStyle) {
                    properties['name'] = textStyle.getText();
                }
            }
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);

        // serialize geometry
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        let geometry = feature.getGeometry();
        if (geometry) {
            geometry = ol.format.Feature.transformGeometryWithOptions(geometry, true, options);
        }
        ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
            GEOMETRY_NODE_FACTORY, [geometry], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const PRIMITIVE_GEOMETRY_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'extrude', 'tessellate', 'altitudeMode', 'coordinates'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const PRIMITIVE_GEOMETRY_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'extrude': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'tessellate': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'altitudeMode': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'coordinates': ol.xml.makeChildAppender(writeCoordinatesTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePrimitiveGeometry(node, geometry, objectStack) {
        const flatCoordinates = geometry.getFlatCoordinates();
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        context['layout'] = geometry.getLayout();
        context['stride'] = geometry.getStride();

        // serialize properties (properties unknown to KML are not serialized)
        const properties = geometry.getProperties();
        properties.coordinates = flatCoordinates;

        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const POLYGON_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'outerBoundaryIs': ol.xml.makeChildAppender(
                writeBoundaryIs),
            'innerBoundaryIs': ol.xml.makeChildAppender(
                writeBoundaryIs)
        });


    /**
     * A factory for creating innerBoundaryIs nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const INNER_BOUNDARY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('innerBoundaryIs');


    /**
     * A factory for creating outerBoundaryIs nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const OUTER_BOUNDARY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('outerBoundaryIs');


    /**
     * @param {Node} node Node.
     * @param {ol.geom.Polygon} polygon Polygon.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePolygon(node, polygon, objectStack) {
        const linearRings = polygon.getLinearRings();
        const outerRing = linearRings.shift();
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        // inner rings
        ol.xml.pushSerializeAndPop(context,
            POLYGON_SERIALIZERS,
            INNER_BOUNDARY_NODE_FACTORY,
            linearRings, objectStack);
        // outer ring
        ol.xml.pushSerializeAndPop(context,
            POLYGON_SERIALIZERS,
            OUTER_BOUNDARY_NODE_FACTORY,
            [outerRing], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const POLY_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode)
        });


    /**
     * A factory for creating coordinates nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const COLOR_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('color');


    /**
     * @param {Node} node Node.
     * @param {ol.style.Fill} style Style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePolyStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS,
            COLOR_NODE_FACTORY, [style.getColor()], objectStack);
    }


    /**
     * @param {Node} node Node to append a TextNode with the scale to.
     * @param {number|undefined} scale Scale.
     */
    function writeScaleTextNode(node, scale) {
        // the Math is to remove any excess decimals created by float arithmetic
        ol.format.xsd.writeDecimalTextNode(node,
            Math.round(scale * 1e6) / 1e6);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'IconStyle': ol.xml.makeChildAppender(writeIconStyle),
            'LabelStyle': ol.xml.makeChildAppender(writeLabelStyle),
            'LineStyle': ol.xml.makeChildAppender(writeLineStyle),
            'PolyStyle': ol.xml.makeChildAppender(writePolyStyle)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Style} style Style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const fillStyle = style.getFill();
        const strokeStyle = style.getStroke();
        const imageStyle = style.getImage();
        const textStyle = style.getText();
        if (imageStyle && typeof /** @type {?} */ (imageStyle).getSrc === 'function') {
            properties['IconStyle'] = imageStyle;
        }
        if (textStyle) {
            properties['LabelStyle'] = textStyle;
        }
        if (strokeStyle) {
            properties['LineStyle'] = strokeStyle;
        }
        if (fillStyle) {
            properties['PolyStyle'] = fillStyle;
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @param {Element} node Node to append a TextNode with the Vec2 to.
     * @param {Vec2} vec2 Vec2.
     */
    function writeVec2(node, vec2) {
        node.setAttribute('x', String(vec2.x));
        node.setAttribute('y', String(vec2.y));
        node.setAttribute('xunits', vec2.xunits);
        node.setAttribute('yunits', vec2.yunits);
    }

    ol.format.KMLCustom = KMLCustom;
})();

; (function (root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(['../../lib/ol/build/ol-sitna'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../../lib/ol/build/ol-sitna'));
    } else {
        root.ol = factory(root.ol);
    }

})(this, function (ol) {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };

    // requestAnimationFrame polyfill
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };

    // Nombres de tipos de eventos
    const MOUSEMOVE = 'mousemove';
    const MOUSEOVER = 'mouseover';
    const RESIZE = ol.events.EventType.RESIZE;
    const DRAGENTER = ol.events.EventType.DRAGENTER;
    const DRAGOVER = ol.events.EventType.DRAGOVER;
    const DROP = ol.events.EventType.DROP;
    const CHANGE = ol.events.EventType.CHANGE;
    const SINGLECLICK = ol.MapBrowserEventType.SINGLECLICK;
    const POINTERMOVE = ol.MapBrowserEventType.POINTERMOVE;
    const MOVEEND = ol.MapEventType.MOVEEND;
    const POSTRENDER = ol.MapEventType.POSTRENDER;
    const POSTCOMPOSE = ol.render.EventType.POSTCOMPOSE;
    const ADDFEATURE = ol.source.VectorEventType.ADDFEATURE;
    const REMOVEFEATURE = ol.source.VectorEventType.REMOVEFEATURE;
    const CLEAR = ol.source.VectorEventType.CLEAR;
    const TILELOADSTART = ol.source.TileEventType.TILELOADSTART;
    const TILELOADEND = ol.source.TileEventType.TILELOADEND;
    const TILELOADERROR = ol.source.TileEventType.TILELOADERROR;

    const hitTolerance = TC.Util.detectMouse() ? 3 : 10;

    var cssUrl = TC.url.ol.substr(0, TC.url.ol.lastIndexOf('/'));
    cssUrl = cssUrl.substr(0, cssUrl.lastIndexOf('/') + 1) + 'css/ol.css';
    //TC.loadCSS(cssUrl);


    /////////////////////////// ol patches

    if (!ol.format.KMLCustom) {
        TC.syncLoadJS(TC.apiLocation + 'TC/ol/format/KMLCustom');
    }

    if (!ol.format.GPXCustom) {
        TC.syncLoadJS(TC.apiLocation + 'TC/ol/format/GPXCustom');
    }

    // Parche para evitar el error AssertionError: Assertion failed: calculated value (1.020636810790192) ouside allowed range (0-1)
    ol.View.prototype.getValueForResolutionFunction = function (opt_power) {
        const power = opt_power || 2;
        const maxResolution = this.maxResolution_;
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
            /**
                 * @param {number} resolution Resolution.
                 * @return {number} Value.
             */
            function (resolution) {
                var value =
                    (Math.log(maxResolution / resolution) / Math.log(power)) / max;
                value = Math.max(Math.min(1, value), 0);
                return value;
            });
    };

    if (!TC.Util.detectMobile()) {
        // Parche para situar el ancla del popup cuando tenemos zoom in/out de navegador o pantalla
        ol.Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
            const style = this.element.style;
            const offset = this.getOffset();

            const positioning = this.getPositioning();

            this.setVisible(true);

            var offsetX = offset[0];
            var offsetY = offset[1];
            if (positioning == ol.OverlayPositioning.BOTTOM_RIGHT ||
                positioning == ol.OverlayPositioning.CENTER_RIGHT ||
                positioning == ol.OverlayPositioning.TOP_RIGHT) {
                if (this.rendered.left_ !== '') {
                    this.rendered.left_ = style.left = '';
                }
                const right = Math.round(mapSize[0] - pixel[0] - offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.right_ != right) {
                    this.rendered.right_ = style.right = right;
                }
            } else {
                if (this.rendered.right_ !== '') {
                    this.rendered.right_ = style.right = '';
                }
                if (positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.TOP_CENTER) {
                    offsetX -= this.element.offsetWidth / 2;
                }
                const left = Math.round(pixel[0] + offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.left_ != left) {
                    this.rendered.left_ = style.left = left;
                }
            }
            if (positioning == ol.OverlayPositioning.BOTTOM_LEFT ||
                positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                positioning == ol.OverlayPositioning.BOTTOM_RIGHT) {
                if (this.rendered.top_ !== '') {
                    this.rendered.top_ = style.top = '';
                }
                const bottom = Math.round(mapSize[1] - pixel[1] - offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.bottom_ != bottom) {
                    this.rendered.bottom_ = style.bottom = bottom;
                }
            } else {
                if (this.rendered.bottom_ !== '') {
                    this.rendered.bottom_ = style.bottom = '';
                }
                if (positioning == ol.OverlayPositioning.CENTER_LEFT ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_RIGHT) {
                    offsetY -= this.element.offsetHeight / 2;
                }
                const top = Math.round(pixel[1] + offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.top_ != top) {
                    this.rendered.top_ = style.top = top;
                }
            }
        };
    }

    // Modificación para cambiar el comportamiento de ol.control.OverviewMap:
    // Mantener la caja del extent siempre centrada.
    ol.control.OverviewMap.prototype._validateExtent_ = ol.control.OverviewMap.prototype.validateExtent_;
    ol.control.OverviewMap.prototype.validateExtent_ = function () {
        var self = this;
        self._validateExtent_();
        if (self._wrap && self._wrap.parent.options.alwaysCentered) {
            self.recenter_();
        }
    };

    // En modo 3D, cambiar la lógica de la escala para que siempre muestre área de visión.
    ol.control.OverviewMap.prototype._resetExtent_ = ol.control.OverviewMap.prototype.resetExtent_;
    ol.control.OverviewMap.prototype.resetExtent_ = function () {
        var self = this;
        self._resetExtent_.call(self);
        var wrap = self._wrap;
        if (wrap.is3D) {
            var ovmap = self.ovmap_;
            var ovview = ovmap.getView();
            var extent = ovview.calculateExtent();
            var feature = wrap.get3DCameraLayer().getSource().getFeatures()[0];
            if (feature) {
                coordinates = feature.getGeometry().getCoordinates();
                var coord1 = coordinates[0][0];
                var coord2 = coordinates[0][1];
                if (!ol.extent.containsCoordinate(extent, coord1) || !ol.extent.containsCoordinate(extent, coord2)) {
                    var buffer = Math.max(
                        extent[0] - coord1[0],
                        extent[1] - coord1[1],
                        coord1[0] - extent[2],
                        coord1[1] - extent[3],
                        extent[0] - coord2[0],
                        extent[1] - coord2[1],
                        coord2[0] - extent[2],
                        coord2[1] - extent[3]
                    );
                    ovview.fit(ol.extent.buffer(extent, buffer));
                }
            }
        }
    };

    ol.format.GML3CRS84 = function () {
        ol.format.GML3.call(this, {
            srsName: 'CRS:84'
        });
    };
    TC.inherit(ol.format.GML3CRS84, ol.format.GML3);

    ol.format.GML2CRS84 = function () {
        ol.format.GML2.call(this, {
            srsName: 'CRS:84'
        });
    };
    TC.inherit(ol.format.GML2CRS84, ol.format.GML2);

    // Añadido el espacio de nombres de GML 3.2 al parser
    const gmlNamespace = 'http://www.opengis.net/gml';
    const gml32Namespace = 'http://www.opengis.net/gml/3.2';
    ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.RING_PARSERS[gml32Namespace] = ol.format.GMLBase.prototype.RING_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gml32Namespace] = ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.MULTICURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTICURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.ENVELOPE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.ENVELOPE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.PATCHES_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.PATCHES_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SEGMENTS_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SEGMENTS_PARSERS_[gmlNamespace];

    // Bug de OpenLayers hasta 5.3.0 como mínimo:
    // El parser de GML2 no lee las siguientes features del GML si tienen un featureType distinto del primero.
    // Esto pasa porque genera el objeto de featureTypes con la primera y en las siguientes iteraciones si el objeto existe no se regenera.
    // Entre comentarios /* */ se elimina lo que sobra.
    //
    // Más: se añade para FeatureCollection un parser por cada namespaceURI del nodo. 
    // Esto es porque QGIS genera GML cuyo nodo FeatureCollection tiene namespace = http://ogr.maptools.org/.
    ol.format.GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {
        const localName = node.localName;
        let features = null;
        if (localName == 'FeatureCollection') {
            // Ñapa para leer GML de https://catastro.navarra.es/ref_catastral/gml.ashx?C=217&PO=5&PA=626
            // y demás GMLs obtenidos de un WFS de GeoServer.
            var gmlnsCollectionParser = this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.prototype.namespace];
            if (!gmlnsCollectionParser['member']) {
                gmlnsCollectionParser['member'] = ol.xml.makeArrayPusher(
                    ol.format.GMLBase.prototype.readFeaturesInternal);
            };
            //////
            // Sustituimos la siguienta instrucción por la siguiente condición :
            //features = pushParseAndPop([],
            //    this.FEATURE_COLLECTION_PARSERS, node,
            //    objectStack, this);
            if (node.namespaceURI === 'http://www.opengis.net/wfs') {
                features = ol.xml.pushParseAndPop([],
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            } else {
                this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] =
                    this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] || this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.prototype.namespace];
                features = ol.xml.pushParseAndPop(/*null*/[], // Cambiado null por [] porque si no, no crea el array de features
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            }
            //////
        } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
            const context = objectStack[0];
            let featureType = context['featureType'];
            let featureNS = context['featureNS'];
            const prefix = 'p';
            const defaultPrefix = 'p0';
            if (/*!featureType && */node.childNodes) {
                featureType = [], featureNS = {};
                for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {
                    const child = node.childNodes[i];
                    if (child.nodeType === 1) {
                        const ft = child.nodeName.split(':').pop();
                        if (featureType.indexOf(ft) === -1) {
                            let key = '';
                            let count = 0;
                            const uri = child.namespaceURI;
                            for (const candidate in featureNS) {
                                if (featureNS[candidate] === uri) {
                                    key = candidate;
                                    break;
                                }
                                ++count;
                            }
                            if (!key) {
                                key = prefix + count;
                                featureNS[key] = uri;
                            }
                            featureType.push(key + ':' + ft);
                        }
                    }
                }
                if (localName != 'featureMember') {
                    // recheck featureType for each featureMember
                    context['featureType'] = featureType;
                    context['featureNS'] = featureNS;
                }
            }
            if (typeof featureNS === 'string') {
                const ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
            }
            /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */
            const parsersNS = {};
            const featureTypes = Array.isArray(featureType) ? featureType : [featureType];
            for (const p in featureNS) {
                /** @type {Object<string, import("../xml.js").Parser>} */
                const parsers = {};
                for (let i = 0, ii = featureTypes.length; i < ii; ++i) {
                    const featurePrefix = featureTypes[i].indexOf(':') === -1 ?
                        defaultPrefix : featureTypes[i].split(':')[0];
                    if (featurePrefix === p) {
                        parsers[featureTypes[i].split(':').pop()] =
                            (localName == 'featureMembers') ?
                                ol.xml.makeArrayPusher(this.readFeatureElement, this) :
                                ol.xml.makeReplacer(this.readFeatureElement, this);
                    }
                }
                parsersNS[featureNS[p]] = parsers;
            }
            if (localName == 'featureMember') {
                features = ol.xml.pushParseAndPop(undefined, parsersNS, node, objectStack);
            } else {
                features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack);
            }
        }
        if (features === null) {
            features = [];
        }
        return features;
    };

    ol.proj.proj4.register(proj4);
    // OpenLayers usa para las proyecciones geográficas un valor ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES], calculado con una esfera, salvo
    // EPSG:4326, en la que usa ol.proj.EPSG4326.METERS_PER_UNIT, calculado con el geoide. Esto hace que las proyecciones en EPSG:4258 salgan desplazadas,
    // pese a que para todos los efectos son iguales a las EPSG:4326. Para evitar eso, introducimos en las 4258 el valor ol.proj.EPSG4326.METERS_PER_UNIT.
    ol.proj.get('EPSG:4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('urn:ogc:def:crs:EPSG::4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('http://www.opengis.net/gml/srs/epsg.xml#4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;

    // Reescribimos la obtención de proyección para que soporte códigos tipo EPSG:X, urn:ogc:def:crs:EPSG::X y http://www.opengis.net/gml/srs/epsg.xml#X
    ol.proj.oldGet = ol.proj.get;
    ol.proj.get = function (projectionLike) {
        if (typeof projectionLike === 'string') {
            projectionLike = projectionLike.trim();
            TC.loadProjDef({ crs: projectionLike, sync: true });
        }
        return ol.proj.oldGet.call(this, projectionLike);
    };

    // Reescritura de código para transformar las geometrías de getFeatureInfo que están en un CRS distinto
    ol.format.GMLBase.prototype.readGeometryElement = function (node, objectStack) {
        var context = /** @type {Object} */ (objectStack[0]);
        context['srsName'] = node.firstElementChild.getAttribute('srsName');
        context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
        /** @type {ol.geom.Geometry} */

        // Parche para poder leer coordenadas en EPSG:4326 con orden incorrecto (las crea QGIS, por ejemplo)
        if (this instanceof ol.format.GML2CRS84 || this instanceof ol.format.GML3CRS84) {
            if (context.srsName !== 'EPSG:4326' || !context.srsName) {
                throw new Error("Conflicto de CRS");
            }
        }
        if (!context.srsName) {
            context.srsName = this.srsName;
        }
        context.dataProjection = ol.proj.get(context.srsName);
        const geometry = ol.xml.pushParseAndPop(null,
            this.GEOMETRY_PARSERS, node, objectStack, this);
        if (geometry) {
            return /** @type {ol.geom.Geometry} */ (
                ol.format.Feature.transformWithOptions(geometry, false, context));
        } else {
            return undefined;
        }
    };

    const ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;

    // Reescritura de código para hacerlo compatible con GML generado por inspire:
    // No se puede considerar geometría cualquier cosa que tenga elementos anidados.
    ol.format.GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {
        let geometryName;
        const values = {};
        for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
            let value;
            const localName = n.localName;
            // first, check if it is simple attribute
            if (n.childNodes.length === 0
                || (n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {
                value = ol.xml.getAllTextContent(n, false);
                if (ONLY_WHITESPACE_RE.test(value)) {
                    value = undefined;
                }
            } else {
                if (asFeature) {
                    //if feature, try it as a geometry
                    value = this.readGeometryElement(n, objectStack);
                }
                if (!value) { //if not a geometry or not a feature, treat it as a complex attribute
                    value = this.readFeatureElementInternal(n, objectStack, false);
                } else if (localName !== 'boundedBy' && localName !== 'referencePoint') {
                    // boundedBy is an extent and must not be considered as a geometry
                    // flacunza: Tampoco referencePoint
                    geometryName = localName;
                }
            }

            if (values[localName]) {
                if (!(values[localName] instanceof Array)) {
                    values[localName] = [values[localName]];
                }
                values[localName].push(value);
            } else {
                values[localName] = value;
            }

            const len = n.attributes.length;
            if (len > 0) {
                values[localName] = { _content_: values[localName] };
                for (let i = 0; i < len; i++) {
                    const attName = n.attributes[i].name;
                    values[localName][attName] = n.attributes[i].value;
                }
            }
        }
        if (!asFeature) {
            return values;
        } else {
            const feature = new ol.Feature(values);
            if (geometryName) {
                feature.setGeometryName(geometryName);
            }
            const fid = node.getAttribute('fid') ||
                node.getAttributeNS(this.namespace, 'id');
            if (fid) {
                feature.setId(fid);
            }
            return feature;
        }
    };

    //////////////////////// end ol patches

    const getRGBA = function (color, opacity) {
        var result;
        if (color) {
            result = ol.color.asArray(color);
            result = result.slice();
            if (opacity !== undefined) {
                result[3] = opacity;
            }
        }
        else {
            result = [0, 0, 0, 1];
        }
        return result;
    };

    /**
     * Obtiene el objeto de opciones de una vista que restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
     * el mapa base activo.
     */
    var getResolutionOptions = function (mapWrap, layer) {
        var view = mapWrap.map.getView();
        var prevRes = view.getResolution();

        var pms = {
            projection: view.getProjection(),
            center: view.getCenter(),
            resolution: prevRes,
            enableRotation: false
        };

        if (mapWrap.parent.maxExtent) {
            pms.extent = mapWrap.parent.maxExtent;
        }

        // GLS 06/03/2019 Corregimos bug 24832, si el mapa de fondo es el mapa en blanco, asignamos las resoluciones del mapa de fondo actual
        var layerForResolutions = layer;
        if (layer.type === TC.Consts.layerType.VECTOR && mapWrap.parent.getBaseLayer()) {
            layerForResolutions = mapWrap.parent.getBaseLayer();
        }

        var res = layerForResolutions.getResolutions ? layerForResolutions.getResolutions() : [];
        var maxRes;
        var minRes;

        if (res && res.length) {
            maxRes = layerForResolutions.maxResolution || res[0];
            minRes = layerForResolutions.minResolution || res[res.length - 1];

            var minResIx = res.indexOf(minRes);
            var maxResIx = res.indexOf(maxRes);

            pms.resolutions = res.slice(maxResIx, minResIx + 1);
        }
        else {
            maxRes = layerForResolutions.maxResolution;
            minRes = layerForResolutions.minResolution;
        }
        if (minRes) {
            pms.minResolution = minRes;
            if (prevRes < minRes) {
                pms.resolution = minRes;
            }
        }
        if (maxRes) {
            pms.maxResolution = maxRes;
            if (prevRes > maxRes) {
                pms.resolution = maxRes;
            }
        }

        return pms;
    };


    TC.wrap.Map.prototype.setMap = function () {
        var self = this;
        var center = [
            (self.parent.initialExtent[0] + self.parent.initialExtent[2]) / 2,
            (self.parent.initialExtent[1] + self.parent.initialExtent[3]) / 2
        ];

        var proj4Obj = proj4(self.parent.crs);
        var addEquivalentProjections = function () {
            // Añadimos proyecciones equivalentes y transformaciones necesarias.
            var crsCode = self.parent.crs.substr(self.parent.crs.lastIndexOf(':') + 1);

            var projOptions = {
                units: proj4Obj.oProj.units,
                global: true
            };

            var equivalentProjections = [];
            if (crsCode !== '4326') { // Este código ya está metido, no lo machacamos
                projOptions.code = 'EPSG:' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));
                projOptions.code = 'urn:ogc:def:crs:EPSG::' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));

                ol.proj.addEquivalentProjections(equivalentProjections);
            }
            //var doTransform = function (fn, input, opt_output, opt_dimension) {
            //    var result = [];
            //    var dimension = opt_dimension || 2;
            //    for (var i = 0; i < input.length; i += dimension) {
            //        var transformed = Array.prototype.slice.call(fn(input.slice(i, i + dimension)));
            //        if (dimension === 3 || dimension === 4) {
            //            transformed = transformed.slice(0, 2).concat(input.slice(i + 2, (i + 2) + (dimension - 2)));
            //        }

            //        result = result.concat(transformed);
            //    }
            //    if (Array.isArray(opt_output)) {
            //        opt_output.length = 0;
            //        for (var i = 0; i < result.length; i++) {
            //            opt_output[i] = result[i];
            //        }
            //        result = opt_output;
            //    }
            //    return result;
            //};
            //var fromEPSG4326 = function (input, opt_output, opt_dimension) {
            //    return doTransform(proj4Obj.forward, input, opt_output, opt_dimension);
            //};
            //var toEPSG4326 = function (input, opt_output, opt_dimension) {
            //    return doTransform(proj4Obj.inverse, input, opt_output, opt_dimension);
            //};

            ol.proj.proj4.register(proj4);

            //ol.proj.addEquivalentTransforms(
            //    ol.proj.EPSG4326.PROJECTIONS,
            //    equivalentProjections,
            //    fromEPSG4326,
            //    toEPSG4326);
        };

        addEquivalentProjections();

        var projOptions = {
            code: self.parent.crs,
            units: proj4Obj.oProj.units
        };
        if (self.parent.crs === 'EPSG:4326') {
            projOptions.axisOrientation = 'neu';
        }
        var projection = new ol.proj.Projection(projOptions);

        var interactions = ol.interaction.defaults({ constrainResolution: true });

        var viewOptions = {
            projection: projection,
            center: center,
            enableRotation: false
        };
        if (self.parent.maxExtent) {
            var maxExtent = self.parent.maxExtent;
            viewOptions.extent = maxExtent;
            var rect = self.parent.div.getBoundingClientRect();
            var ratio = rect.width / rect.height;
            var dx = maxExtent[2] - maxExtent[0];
            var dy = maxExtent[3] - maxExtent[1];
            if (rect.width / rect.height > dx / dy) {
                viewOptions.resolution = dx / rect.width;
            }
            else {
                viewOptions.resolution = dy / rect.height;
            }
        }
        else {
            viewOptions.zoom = 2;
        }

        self.map = new ol.Map({
            target: self.parent.div,
            view: new ol.View(viewOptions),
            controls: [],
            interactions: interactions,
            pixelRatio: 1 /* 08/02/2019 GLS: 
            Establecemos el pixelRatio siempre a uno, porque OL sólo atiende al valor al principio, 
            si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso,
            click se sitúa mal, popup se sitúa entre otros efectos.
            Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                Bug 25976:Mapa situación en blanco
                Bug 25954:Canvas en blanco con zoom mayor al 100%
                Bug 23855:Mapa de situación se muestra en blanco
            */
        });

        if (!TC.Util.detectMobile()) {
            // Parche para corregir https://github.com/openlayers/openlayers/issues/2904
            // saben que tienen un bug cuando se trabaja sobre un mapa con zoom
            self.map.getEventPixel = function (event) {
                var viewportPosition = this.viewport_.getBoundingClientRect();
                var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
                eventPosition = eventPosition.clientX ? eventPosition : (eventPosition.pointerEvent ? eventPosition.pointerEvent : eventPosition);
                return [
                    (eventPosition.clientX - viewportPosition.left) * window.devicePixelRatio,
                    (eventPosition.clientY - viewportPosition.top) * window.devicePixelRatio
                ];
            };
        }

        self.map._wrap = self;
        self._promise = Promise.resolve(self.map);

        // mantenemos el ancho y alto del canvas en números enteros
        self.manageSize.call(self.map);

        // Para evitar estiramientos en canvas
        var updateSize = function () {
            self.map.updateSize();
        };
        self.parent.div.addEventListener(RESIZE, updateSize);
        self.parent.one(TC.Consts.event.MAPLOAD, updateSize);

        self.map.on(SINGLECLICK, function (e) {

            if (self.parent.view === TC.Consts.view.PRINTING) {
                return;
            }

            self.parent.workLayers.forEach(function (wl) {
                delete wl._noFeatureClicked;
            });
            var featuresInLayers = self.parent.workLayers.map(function () {
                return false;
            });
            self.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        for (var i = 0; i < self.parent.workLayers.length; i++) {
                            var wl = self.parent.workLayers[i];
                            if (wl.wrap.layer === layer) {
                                featuresInLayers[i] = true;
                                break;
                            }
                        }
                        self.parent.trigger(TC.Consts.event.FEATURECLICK, { feature: feature._wrap.parent });
                        return feature;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            for (var i = 0; i < featuresInLayers.length; i++) {
                if (!featuresInLayers[i]) {
                    self.parent.trigger(TC.Consts.event.NOFEATURECLICK, { layer: self.parent.workLayers[i] });
                }
            }
        });


        // GLS: 13/02/2019 cambiamos el orden de las suscripciones a eventos de cambio de resolución y moveend
        // para gestionar el borrado del estado inicial. Si no lo hacemos el cambio al extent inicial se registra como evento de usuario
        // porque la carga inicial del mapa con promesas nativas es más rápido que antes.
        // Bug:26001 Borrar estado inicial al entrar
        const addMoveEndListener = function () {
            self.map.on(MOVEEND, function () {
                self.parent.trigger(TC.Consts.event.ZOOM);
            });
        };
        var olView = self.map.getView();
        olView.on('change:resolution', function () {
            if (!self.map.hasListener(MOVEEND)) {
                self.map.once(MOVEEND, function () {
                    addMoveEndListener();
                });
            }

            self.parent.trigger(TC.Consts.event.BEFOREZOOM);
        }, self.parent);

        const onChangeView = function () {
            if (!self.map.hasListener(MOVEEND)) {
                self.map.un('change:view', onChangeView);
                addMoveEndListener();
            }
        };
        self.map.on('change:view', onChangeView);

        /**
         * Restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
         * el mapa base activo.
         */
        var limitZoomLevels = function (layer) {
            var prevRes = self.map.getView().getResolution();
            var prevZoom = self.map.getView().getZoom();

            var pms = getResolutionOptions(self, layer);

            var view = new ol.View(pms);
            self.map.setView(view);
            self.map.render();
        };

        self.parent.on(TC.Consts.event.BASELAYERCHANGE, function (e) {
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            if (self.parent.crs === self.parent.options.crs && !self.parent.on3DView && e.layer.type !== TC.Consts.layerType.VECTOR) {
                limitZoomLevels(e.layer);
            }
        });
        self.parent.on(TC.Consts.event.MAPLOAD, function (e) {
            limitZoomLevels(self.parent.getBaseLayer());
        });

        const olMapViewport = self.map.getViewport();

        olMapViewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
            var mapTarget = self.map.getTarget();
            var hit = false;
            var feature;

            if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {

                if (self.parent.view === TC.Consts.view.PRINTING) {
                    return;
                }

                var pixel = self.map.getEventPixel(e);
                hit = self.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
                    var result = true;
                    if (feature._wrap && !feature._wrap.parent.showsPopup && !feature._wrap.parent.options.selectable) {
                        result = false;
                    }

                    if (result && feature._wrap) {
                        self.parent.trigger(TC.Consts.event.FEATUREOVER, {
                            feature: feature._wrap.parent
                        });
                    }

                    return result;
                }, { hitTolerance: hitTolerance });
            }

            if (hit) {
                mapTarget.style.cursor = 'pointer';
            } else {
                mapTarget.style.cursor = '';
                //self.parent.trigger(TC.Consts.event.FEATUREOUT);
            }
        });
    };

    var getMetersPerUnit = function (proj, extentInDegrees) {
        var units = proj.getUnits();
        if (!units || units === ol.proj.Units.DEGREES) {
            return TC.Util.getMetersPerDegree(extentInDegrees);
        }
        return ol.proj.METERS_PER_UNIT[units];
    };

    TC.wrap.Map.prototype.getMetersPerUnit = function () {
        var self = this;
        return getMetersPerUnit(ol.proj.get(self.parent.crs), self.getExtent());
    };

    var getUnitRatio = function (options) {
        var self = this;
        options = options || {};
        var defaultCrs = self.parent.options.crs || TC.Cfg.crs;
        var defaultProj = ol.proj.get(defaultCrs);
        var newProj = ol.proj.get(options.crs);
        return getMetersPerUnit(newProj, options.extentInDegrees) / getMetersPerUnit(defaultProj, options.extentInDegrees);
    };

    var normalizeProjection = function (options) {
        var result;
        if (options.axisOrientation) {
            result = new ol.proj.Projection({
                code: options.crs,
                axisOrientation: options.axisOrientation
            });
        }
        else {
            result = ol.proj.get(options.crs);            
        }
        if (!result.getUnits()) {
            result.units_ = ol.proj.Units.DEGREES;
        }
        return result;
    };

    TC.wrap.Map.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};        
        const baseLayer = options.baseLayer || self.parent.baseLayer;
        var extent;
        if (options.extent) {
            extent = options.extent;
        }
        else {
            extent = ol.proj.transformExtent(self.getExtent(), self.parent.crs, options.crs);
        }
        const extentInDegrees = ol.proj.transformExtent(extent, options.crs, 'EPSG:4326');
        const unitRatio = getUnitRatio.call(self, {
            crs: options.crs,
            extentInDegrees: extentInDegrees
        });
        const projection = normalizeProjection(options);
        const oldView = self.map.getView();
        const viewOptions = {
            projection: projection,
            enableRotation: false
        };
        const resolutions = baseLayer.getResolutions();

        if (resolutions && resolutions.length) {
            viewOptions.resolutions = resolutions;
        }
        else {            
            viewOptions.minZoom = oldView.getMinZoom();
            viewOptions.maxZoom = oldView.getMaxZoom();
            const minResolution = baseLayer.wrap.layer.getMinResolution();
            const maxResolution = baseLayer.wrap.layer.getMaxResolution();
            var transformFactor = 1;
            if (minResolution === 0 || maxResolution === Number.POSITIVE_INFINITY) {
                const oldUnitRatio = getUnitRatio.call(self, {
                    crs: self.parent.crs,
                    extentInDegrees: extentInDegrees
                });
                transformFactor = oldUnitRatio / unitRatio;
            }
            if (minResolution === 0) {
                viewOptions.minResolution = oldView.getMinResolution() * transformFactor;
            }
            else {
                viewOptions.minResolution = minResolution;
            }
            if (maxResolution === Number.POSITIVE_INFINITY) {
                viewOptions.maxResolution = oldView.getMaxResolution() * transformFactor;
            }
            else {
                viewOptions.maxResolution = maxResolution;
            }
        }

        // GLS: transformamos también el centro     
        viewOptions.center = ol.proj.transform(self.getCenter(), self.parent.crs, options.crs);

        var newView = new ol.View(viewOptions);
        self.map.setView(newView);
        self.parent.initialExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.initialExtent, self.parent.crs, options.crs) : self.parent.options.initialExtent;
        if (self.parent.options.maxExtent) {
            self.parent.options.maxExtent = self.parent.maxExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.maxExtent, self.parent.crs, options.crs) : self.parent.options.maxExtent;
        }
        newView.fit(extent, { nearest: true });
    };

    /*
     *  insertLayer: inserts OpenLayers layer at index
     *  Parameters: OpenLayers.Layer, number
     */
    TC.wrap.Map.prototype.insertLayer = function (olLayer, idx) {
        var self = this;
        var layers = self.map.getLayers();
        var alreadyExists = false;
        for (var i = 0; i < layers.getLength(); i++) {
            if (layers.item(i) === olLayer) {
                alreadyExists = true;
                break;
            }
        }
        if (alreadyExists) {
            layers.remove(olLayer);
            layers.insertAt(idx, olLayer);
        }
        else {
            if (idx < 0) {
                layers.push(olLayer);
            }
            else {
                layers.insertAt(idx, olLayer);
            }
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            var view = self.map.getView();
            if (self.parent.crs === self.parent.options.crs) {
                if (olLayer instanceof ol.layer.Tile) {
                    var resolutions = olLayer.getSource().getResolutions();
                    view.maxResolution_ = resolutions[0];
                    view.minResolution_ = resolutions[resolutions.length - 1];
                }
            }
            else {
                // Cambiamos los límites de resolución de la capa a los de la vista. Esto lo hacemos porque su resolución está en otro CRS.
                if (olLayer instanceof ol.layer.Tile) {
                    olLayer.setMaxResolution(view.getMaxResolution());
                    olLayer.setMinResolution(view.getMinResolution());
                }
            }

            var wrap = olLayer._wrap;
            var loadingTileCount = 0;

            var beforeTileLoadHandler = function (e) {
                wrap.parent.state = TC.Layer.state.LOADING;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    self.parent.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: wrap.parent });
                }
                olLayer._loadingTileCount = olLayer._loadingTileCount + 1;
            };
            if (wrap.parent.state === TC.Layer.state.LOADING && wrap.parent.isRaster()) {
                beforeTileLoadHandler();
            }
            wrap.$events.on(TC.Consts.event.BEFORETILELOAD, beforeTileLoadHandler);

            wrap.$events.on(TC.Consts.event.TILELOAD, function (e) {
                loadingTileCount = loadingTileCount - 1;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    wrap.parent.state = TC.Layer.state.IDLE;
                    self.parent.trigger(TC.Consts.event.LAYERUPDATE, { layer: wrap.parent });
                }
            });
        }
    };

    TC.wrap.Map.prototype.removeLayer = function (olLayer) {
        this.map.removeLayer(olLayer);
    };

    TC.wrap.Map.prototype.getLayerCount = function () {
        return this.map.getLayerGroup().getLayers().getLength();
    };

    TC.wrap.Map.prototype.indexOfFirstVector = function () {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (l, i) {
            if (l instanceof ol.layer.Vector && result === -1) {
                result = i;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.getLayerIndex = function (olLayer) {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (elm, idx) {
            if (elm === olLayer) {
                result = idx;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.setLayerIndex = function (olLayer, index) {
        var layers = this.map.getLayers();
        var list = layers.getArray();
        var ix = list.indexOf(olLayer);

        if (ix > -1 && ix != index) {
            this.map.removeLayer(olLayer);
            this.insertLayer(olLayer, index);
            //layers.setAt(index, olLayer);
        }
        else {
            //no está el layer, así que no hago nada
        }

    };

    TC.wrap.Map.prototype.setBaseLayer = function (olLayer) {
        var self = this;
        return new Promise(function (resolve, reject) {
            var setLayer = function (curBl) {
                // GLS: si se llega después de una animación el valor de self.parent.getBaseLayer() ya es el definitivo y no el actual lo que provoca efectos indeseados. 
                // ir a línea 1313: paso como parámetro el baseLayer actual en el caso de animación.
                var curBl = curBl || self.parent.getBaseLayer();
                if (curBl) {
                    self.map.removeLayer(curBl.wrap.layer);
                    if (olLayer instanceof ol.layer.Image) { // Si es imagen no teselada
                        olLayer._wrap.setProjection({
                            crs: self.parent.crs
                        });
                    }

                    if (olLayer._wrap.parent.type === TC.Consts.layerType.WMTS) {
                        var layerProjectionOptions = { crs: self.parent.crs, oldCrs: olLayer.getSource().getProjection().getCode() };

                        if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                            olLayer._wrap.parent.setProjection(layerProjectionOptions);
                        }
                    }

                    //if (olLayer instanceof ol.layer.Tile) { // Si es imagen teselada
                    //    const view = self.map.getView();
                    //    const resolutions = olLayer.getSource().getResolutions();
                    //    if (resolutions) {
                    //        view.options_.resolutions = resolutions;
                    //        view.applyOptions_(view.options_);
                    //    }
                    //}
                }
                self.insertLayer(olLayer, 0);
                self.map.getControls().forEach(function (ctl) {
                    if (ctl instanceof ol.control.ZoomSlider) {
                        ctl.initSlider_();
                    }
                });
                resolve();
            };

            // Toda esta lógica antes de llamar a setLayer() es para hacer un zoom a la nueva resolución
            // cuando la nueva capa no llega a la resolución actual
            var viewOptions = getResolutionOptions(self, olLayer._wrap.parent);
            var view = self.map.getView();
            var currentResolution = view.getResolution();
            if (viewOptions.resolutions) {
                //buscamos la nueva resolución: o una que sea similar a la actual dentro de los márgenes admitidos, o la inmediata superior
                var newRes = viewOptions.resolutions
                    .sort(function (a, b) { return a - b })
                    .reduce(function (prev, elm) {
                        if (prev === 0 &&
                            (elm > currentResolution || Math.abs(1 - (currentResolution / elm)) < self.parent.options.maxResolutionError)) {
                            return elm;
                        }
                        return prev;
                    }, 0);
                if (newRes !== currentResolution) {
                    if (self.parent.isLoaded) {
                        view.animate({ resolution: newRes, duration: TC.Consts.ZOOM_ANIMATION_DURATION }, setLayer.bind(self, self.parent.getBaseLayer()));
                    }
                    else { // Primera carga, no animamos
                        view.setResolution(newRes);
                        setLayer();
                    }
                }
                else {
                    setLayer();
                }
            }
            else {
                setLayer();
            }
        });
    };

    TC.wrap.Map.prototype.setExtent = function (extent, options) {
        const self = this;
        options = options || {};

        const applyExtent = function (view, mapSize, resolve, reject) {
            var res = view.getResolutionForExtent(extent, mapSize);
            // URI: Esta logica está fusilada de la función fit de un objeto view de OL3
            if (view.constrainResolution) {
                var constrainedResolution = view.constrainResolution(res, 0, 0);
                if (constrainedResolution < res) {
                    if (constrainedResolution / res < TC.Consts.EXTENT_TOLERANCE) {
                        constrainedResolution = view.constrainResolution(
                            constrainedResolution, -1, 0);
                    }
                }
                res = constrainedResolution;
            }

            // flacunza: No animamos si la duración va a ser 0, porque a veces el zoom no se completa
            // GLS: antes de resolver la promesa validamos si existe animación
            // URI: si la animacion no existe ponemos duracion 0
            // flacunza: en caso de que animate=undefined, se anima
            const center = [((extent[0] + extent[2]) / 2), ((extent[1] + extent[3]) / 2)];
            if (options.animate === void (0) || options.animate) {
                view.animate({
                    resolution: res,
                    center: center,
                    duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, resolve);
            }
            else {
                view.setCenter(center);
                view.setResolution(res);
                resolve();
            }
        };

        const setPromise = function (extent) {
            self._setExtentPromise = new Promise(function (resolve, reject) {
                // Timeout porque OL3 no tiene evento featuresadded, por tanto cuando se activa map.options.zoomToMarkers
                // se lanza un setExtent por marcador. El timeout evita ejecuciones a lo tonto.
                clearTimeout(self._timeout);
                self._timeout = setTimeout(function () {
                    var mapSize = self.map.getSize();
                    var view = self.map.getView();

                    if (self.parent.baseLayer) {
                        self.parent.baseLayer.wrap.getLayer().then(function (olLayer) {
                            // Todo esto para evitar que haga más zoom que el admisible por la capa base
                            const res = view.getResolutionForExtent(extent, mapSize);
                            const resolutions = self.getResolutions();
                            const maxZoom = view.getMaxZoom();
                            if (maxZoom < resolutions.length - 1) {
                                resolutions.length = maxZoom + 1;
                            }

                            if (resolutions.length > 0) {
                                var minRes = Math.min.apply(self, resolutions);
                                if (minRes > res) {
                                    var factor = 0.5 * (minRes / res - 1);
                                    var dx = ol.extent.getWidth(extent) * factor;
                                    var dy = ol.extent.getHeight(extent) * factor;
                                    extent = extent.slice(0);
                                    extent[0] = extent[0] - dx;
                                    extent[1] = extent[1] - dy;
                                    extent[2] = extent[2] + dx;
                                    extent[3] = extent[3] + dy;
                                }
                            }

                            applyExtent(view, mapSize, resolve, reject);

                        });
                    }
                    else {
                        applyExtent(view, mapSize, resolve, reject);
                    }
                }, 50);
            });
        };
        Promise.resolve(self._setExtentPromise).finally(function () {
            setPromise(extent);
        });

        return self._setExtentPromise;
    };

    TC.wrap.Map.prototype.getExtent = function () {
        return this.map.getView().calculateExtent(this.map.getSize());
    };

    TC.wrap.Map.prototype.setCenter = function (coords, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const callback = function () {
                resolve();
            };

            const opts = options || {};
            const view = self.map.getView();

            if (opts.animate) {
                view.animate({
                    center: coords, duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, callback);
            }
            else {
                view.setCenter(coords);
                resolve();
            }
        });
    };

    TC.wrap.Map.prototype.getCenter = function () {
        return this.map.getView().getCenter();
    };

    TC.wrap.Map.prototype.getResolution = function () {
        return this.map.getView().getResolution();
    };

    TC.wrap.Map.prototype.setResolution = function (resolution) {
        this.getMap().then(function (olMap) {
            olMap.getView().setResolution(resolution);
        });
    };

    TC.wrap.Map.prototype.setRotation = function (rotation) {
        this.getMap().then(function (olMap) {
            olMap.getView().setRotation(rotation);
        });
    };

    TC.wrap.Map.prototype.getRotation = function () {
        return this.map.getView().getRotation();
    };

    TC.wrap.Map.prototype.getResolutions = function () {
        return this.map.getView().getResolutions() || [];
    };

    TC.wrap.Map.prototype.getCoordinateFromPixel = function (xy) {
        return this.map.getCoordinateFromPixel(xy);
    };

    TC.wrap.Map.prototype.getPixelFromCoordinate = function (coord) {
        return this.map.getPixelFromCoordinate(coord);
    };

    TC.wrap.Map.prototype.getViewport = function (options) {
        const self = this;
        var result;
        var opts = options || {
        };
        if (opts.synchronous) {
            result = self.map.getViewport();
        }
        else {
            result = new Promise(function (resolve, reject) {
                self.getMap().then(function (olMap) {
                    resolve(olMap.getViewport());
                });
            });
        }
        return result;
    };

    TC.wrap.Map.prototype.isNative = function (map) {
        return map instanceof ol.Map;
    };

    TC.wrap.Map.prototype.isGeo = function () {
        var units = this.map.getView().getProjection().getUnits();
        return !units || units === ol.proj.Units.DEGREES;
    };

    TC.wrap.Map.prototype.addPopup = function (popupCtl) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var draggable = popupCtl.options.draggable === undefined || popupCtl.options.draggable;
            TC.loadJS(
                draggable && !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    self.getMap().then(function (olMap) {
                        if (!popupCtl.popupDiv) {
                            // No popups yet
                            const popupDiv = TC.Util.getDiv();
                            popupCtl.popupDiv = popupDiv;
                            if (window.$) {
                                popupCtl.$popupDiv = $(popupDiv);
                            }
                            popupDiv.classList.add(TC.control.Popup.prototype.CLASS);
                            popupCtl.contentDiv = TC.Util.getDiv();
                            popupCtl.contentDiv.classList.add(TC.control.Popup.prototype.CLASS + '-content');
                            popupCtl.popupDiv.appendChild(popupCtl.contentDiv);
                            popupCtl.menuDiv = TC.Util.getDiv();
                            popupCtl.menuDiv.classList.add(TC.control.Popup.prototype.CLASS + '-menu');
                            popupCtl.popupDiv.appendChild(popupCtl.menuDiv);
                            self.parent.div.appendChild(popupDiv);

                            var popup = new ol.Overlay({
                                element: popupDiv,
                                positioning: ol.OverlayPositioning.BOTTOM_LEFT
                            });
                            olMap.addOverlay(popup);
                            popupCtl.wrap.popup = popup;

                            //popupCtl._firstRender.resolve();
                            //popupCtl.trigger(TC.Consts.event.CONTROLRENDER);
                            const olMapViewport = olMap.getViewport();

                            if (draggable) {
                                const container = popupCtl.popupDiv.parentElement;
                                popupCtl.popupDiv.classList.add(TC.Consts.classes.DRAGGABLE);


                                container.addEventListener('touchmove', function (e) {
                                    var parent = e.target;
                                    do {
                                        if (parent.matches('.tc-ctl-finfo-layer-content')) {
                                            e.stopPropagation();
                                            break;
                                        }
                                        parent = parent.parentElement;
                                    }
                                    while (parent);
                                });

                                // Tuneamos Draggabilly para que acepte excepciones a los asideros del elemento.
                                const drag = new Draggabilly(container, {
                                    //not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                });
                                drag.handleEvent = function (event) {
                                    if (this.options.not && event.target.matches(this.options.not)) {
                                        return;
                                    }
                                    Draggabilly.prototype.handleEvent.call(this, event);
                                };
                                drag.on('pointerDown', function (e, pointer) {
                                    var bcr = e.target.getBoundingClientRect();
                                    // Si estamos pulsando sobre una barra de scroll abortamos drag
                                    if (bcr.left + e.target.clientWidth < pointer.pageX || bcr.top + e.target.clientHeight < pointer.pageY) {
                                        drag._pointerCancel(e, pointer);
                                        return false;
                                    }
                                });
                                drag.on('dragStart', function (e, pointer) {
                                    popupCtl.setDragging(true);
                                    popupCtl._currentOffset = popup.getOffset();
                                    if (popupCtl._previousContainerPosition) {
                                        var mapSize = olMap.getSize();
                                        popup.setPosition(olMap.getCoordinateFromPixel([popupCtl._previousContainerPosition[0], mapSize[1] - popupCtl._previousContainerPosition[1]]));
                                        popupCtl._currentOffset = [0, 0];
                                        popup.setOffset(popupCtl._currentOffset);
                                        delete popupCtl._previousContainerPosition;
                                    }
                                    else {
                                        popupCtl._currentOffset = popup.getOffset();
                                    }
                                });
                                drag.on('dragEnd', function (e) {
                                    popupCtl.setDragging(false);
                                    var coord1 = olMap.getCoordinateFromPixel([0, 0]);
                                    var coord2 = olMap.getCoordinateFromPixel(popup.getOffset());
                                    var coordDelta = [coord2[0] - coord1[0], coord2[1] - coord1[1]];
                                    var position = popup.getPosition();
                                    popup.setPosition([position[0] + coordDelta[0], position[1] + coordDelta[1]]);
                                    popup.setOffset([0, 0]);
                                    popupCtl._currentOffset = [0, 0];

                                    const containerRect = container.getBoundingClientRect();
                                    popupCtl._previousContainerPosition = [containerRect.left, containerRect.bottom];
                                });
                                //drag.on('dragMove', function (e, pointer, moveVector) {
                                    //popup.setOffset([popupCtl._currentOffset[0] + moveVector.x, popupCtl._currentOffset[1] + moveVector.y]);
                                //});
                                //.drag(function (ev, dd) {
                                //    if (!ev.buttons && !Modernizr.touch) { // Evitamos que se mantenga el drag si no hay botón pulsado (p.e. en IE pulsando una scrollbar)
                                //        return false;
                                //    }
                                //    popup.setOffset([popupCtl._currentOffset[0] + dd.deltaX, popupCtl._currentOffset[1] + dd.deltaY]);
                                //}, {
                                //    not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                //    })                                
                            }

                            const mouseMoveHandler = function (e) {
                                var mapTarget = olMap.getTarget();
                                var hit = false;
                                if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {
                                    var pixel = olMap.getEventPixel(e);
                                    hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                                        var result = true;
                                        if (feature._wrap && !feature._wrap.parent.showsPopup) {
                                            result = false;
                                        }
                                        return result;
                                    },
                                        {
                                            hitTolerance: hitTolerance
                                        });
                                }
                                if (hit) {
                                    mapTarget.style.cursor = 'pointer';
                                } else {
                                    mapTarget.style.cursor = '';
                                }
                            };

                            // change mouse cursor when over marker
                            olMapViewport.removeEventListener(MOUSEMOVE, mouseMoveHandler);
                            olMapViewport.addEventListener(MOUSEMOVE, mouseMoveHandler);
                        }
                    });
                    resolve();
                }
            );
        });
    };

    TC.wrap.Map.prototype.hidePopup = function (popupCtl) {
        var self = this;
        self.parent.currentFeature = null;
        if (popupCtl.popupDiv) {
            popupCtl.popupDiv.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    TC.wrap.Map.prototype.manageSize = function () {
        const self = this;

        // Para controlar que el mapa no se vea borroso porque no encajan el width y height con los width y height de CSS
        const manageSize = function (event) {
            var pixelRatio = window.devicePixelRatio || 1;
            var canvas = event.context.canvas;
            var bounding = canvas.getBoundingClientRect();

            var idealWidth = pixelRatio * bounding.width;
            var idealHeight = pixelRatio * bounding.height;

            if (idealWidth !== bounding.width || !Number.isInteger(idealWidth)) {
                idealWidth = Math.round(idealWidth);
            }

            if (idealHeight !== bounding.height || !Number.isInteger(idealHeight)) {
                idealHeight = Math.round(idealHeight);
            }

            if (idealWidth !== bounding.width || idealHeight !== bounding.height) {
                var newSize = [idealWidth, idealHeight];
                event.target.setSize(newSize);
            }
        };

        if (!TC.Util.detectMobile()) {
            self.on(POSTCOMPOSE, manageSize);
        }
    };

    var getFormatFromName = function (name) {
        switch (name) {
            case TC.Consts.layerType.KML:
            case TC.Consts.mimeType.KML:
                return new ol.format.KMLCustom({
                    showPointNames: false
                });
            case TC.Consts.layerType.GPX:
            case TC.Consts.mimeType.GPX:
                return new ol.format.GPXCustom();
            case TC.Consts.layerType.GEOJSON:
            case TC.Consts.mimeType.GEOJSON:
            case TC.Consts.mimeType.JSON:
            case TC.Consts.format.JSON:
                return new ol.format.GeoJSON();
            case TC.Consts.format.GML2:
                return new ol.format.GML2();
            case TC.Consts.format.GML3:
                return new ol.format.GML3();
            case TC.Consts.mimeType.GML:
            case TC.Consts.format.GML:
                return new ol.format.GML();
            case TC.Consts.format.TOPOJSON:
                return new ol.format.TopoJSON();
            case TC.Consts.format.WKT:
                return new ol.format.WKT();
            default:
                return null;
        }
    };

    TC.wrap.Map.prototype.exportFeatures = function (features, options) {
        var self = this;
        options = options || {};
        var nativeStyle = createNativeStyle({
            styles: self.parent.options.styles
        });
        var olFeatures = features.map(function (elm) {
            var result = elm.wrap.feature;
            // Si la feature no tiene estilo propio le ponemos el definido por la API
            if (!result.getStyle()) {
                result.setStyle(nativeStyle);
            }
            // Miramos si tiene texto, en cuyo caso la features se clona para no contaminar la feature orignal 
            // y al clon se le añade el texto como atributo (necesario para exportar etiquetas en KML y GPX)
            const text = getNativeFeatureStyle(result).getText();
            if (text) {
                result = result.clone();
                result.setProperties({
                    name: text.getText()
                });
            }
            return result;
        });
        var format = getFormatFromName(options.format);

        if (format instanceof ol.format.KML) {
            // KML no tiene estilo para puntos aparte del de icono. Para puntos sin icono creamos uno en SVG.
            olFeatures = olFeatures
                .map(function (feature) {
                    const geom = feature.getGeometry();
                    if (geom instanceof ol.geom.Point) {
                        // Si el punto no tiene icono, creamos uno nuevo con un icono generado como data URI a partir del estilo
                        var style = getNativeFeatureStyle(feature);
                        const shape = style.getImage();
                        if (shape instanceof ol.style.RegularShape) {
                            const radius = shape.getRadius();
                            const stroke = shape.getStroke();
                            const strokeWidth = stroke.getWidth();
                            const diameter = (2 * radius) + strokeWidth + 1;
                            const position = diameter / 2;
                            const canvas = document.createElement('canvas');
                            canvas.width = diameter;
                            canvas.height = diameter;
                            const vectorContext = ol.render.toContext(canvas.getContext('2d'), {
                                size: [diameter, diameter]
                            });
                            const text = style.getText();
                            style = style.clone();
                            style.setText(); // Quitamos el texto para que no salga en el canvas
                            vectorContext.setStyle(style);
                            vectorContext.drawGeometry(new ol.geom.Point([position, position]));
                            const newFeature = new ol.Feature(geom);
                            newFeature.setProperties(feature.getProperties());
                            newFeature.setStyle(new ol.style.Style({
                                image: new ol.style.Icon({
                                    src: canvas.toDataURL('image/png')
                                }),
                                text: text
                            }));
                            return newFeature;
                        }
                    }
                    return feature;
                });
            // KML no pone etiquetas a líneas y polígonos. En esos casos ponemos un punto con la etiqueta.
            const pointsToAdd = [];
            olFeatures.forEach(function (feature) {
                var style = getNativeFeatureStyle(feature);
                const geometry = feature.getGeometry();
                const text = style.getText();
                var point;
                if (text) {
                    switch (true) {
                        case geometry instanceof ol.geom.LineString:
                            point = new ol.geom.Point(geometry.getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.Polygon:
                            point = geometry.getInteriorPoint();
                            break;
                        case geometry instanceof ol.geom.MultiLineString:
                            // Seleccionamos la línea más larga
                            const lineStrings = geometry.getLineStrings();
                            var maxLength = -1;
                            point = new ol.geom.Point(lineStrings[lineStrings
                                .map(function (line) {
                                    return line.getLength();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxLength) {
                                        maxLength = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.MultiPolygon:
                            // Seleccionamos el polígono más grande
                            const polygons = geometry.getPolygons();
                            var maxArea = -1;
                            point = polygons[polygons
                                .map(function (polygon) {
                                    return polygon.getArea();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxArea) {
                                        maxArea = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getInteriorPoint();
                            break;
                        default:
                            break;
                    }
                    if (point) {
                        const newFeature = new ol.Feature(point);
                        newFeature.setStyle(new ol.style.Style({
                            text: text.clone(),
                            image: new ol.style.Icon({
                                crossOrigin: 'anonymous',
                                src: TC.apiLocation + 'TC/css/img/transparent.gif'
                            })
                        }));
                        pointsToAdd.push(newFeature);
                    }
                }
            });
            if (pointsToAdd.length) {
                olFeatures = olFeatures.concat(pointsToAdd);
            }
        }

        if (format instanceof ol.format.GMLBase) {

            // Quitamos los espacios en blanco de los nombres de atributo en las features: no son válidos en GML.
            olFeatures = olFeatures.map(function (f) {
                return f.clone();
            });
            olFeatures.forEach(function (f) {
                const values = f.values_
                const keysToChange = [];
                for (var key in values) {
                    if (key.indexOf(' ') >= 0) {
                        keysToChange.push(key);
                    }
                }
                keysToChange.forEach(function (key) {
                    // Quitamos espacios en blanco y evitamos que empiece por un número
                    var newKey = key.replace(/ /g, '_');
                    if (/^\d/.test(newKey)) {
                        newKey = '_' + newKey;
                    }
                    if (key !== newKey) {
                        while (values[newKey] !== undefined) {
                            newKey += '_';
                        }
                    }
                    values[newKey] = values[key];
                    delete values[key];
                });
            });

            //Apañamos para que el GML sea válido. Si no lo hacemos, con IE, en ol-debug.js:36514 da un error porque node.localName no existe.
            format.featureNS = "sitna";
            format.featureType = "feature";
            var featuresNode = format.writeFeaturesNode(olFeatures, {
                featureProjection: self.parent.crs
            });

            var featureCollectionNode = ol.xml.createElementNS('http://www.opengis.net/gml',
                'FeatureCollection');
            featureCollectionNode.setAttributeNS('http://www.w3.org/2001/XMLSchema-instance',
                'xsi:schemaLocation', format.schemaLocation);
            featuresNode.removeAttribute('xmlns:xsi');
            featuresNode.removeAttribute('xsi:schemaLocation');
            featureCollectionNode.appendChild(featuresNode);
            //ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',
            //    'xsi:schemaLocation', this.schemaLocation);
            //return featureCollectionNode.outerHTML;
        }

        if (format instanceof ol.format.GPX) {
            // Queremos exportar tracks en vez de routes. OpenLayers exporta LineStrings como routes y MultiLineStrings como tracks.
            olFeatures = olFeatures.map(function (f) {
                const geom = f.getGeometry();
                if (geom instanceof ol.geom.LineString) {
                    f = f.clone();
                    f.setGeometry(new ol.geom.MultiLineString([geom.getCoordinates()]));
                }
                return f;
            });
        }

        var result = format.writeFeatures(olFeatures, {
            dataProjection: 'EPSG:4326',
            featureProjection: self.parent.crs
        });
        if (format instanceof ol.format.GPX) {
            // Este formato no procesa bien las elevaciones cuando son nulas. Hemos hecho un preproceso para transformarlas en NaN y ahora hay que eliminarlas.
            result = result.replace(/<ele>NaN<\/ele>/g, '');
        }
        return result;
    };

    var isFileDrag = function (e) {
        for (var i = 0, len = e.dataTransfer.types.length; i < len; i++) {
            if (e.dataTransfer.types[i] === 'Files') {
                return true;
            }
        }
        return false;
    };

    var handleDragEnter = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            self.getMap()._wrap.parent.div.classList.add(TC.Consts.classes.DROP);
            e.preventDefault();
            e.stopPropagation();
        }
    };

    var handleDragExit = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            var map = self.getMap()._wrap.parent;
            if (e.target === self.target) {
                map.div.classList.remove(TC.Consts.classes.DROP);
            }
        }
    };

    TC.wrap.Map.prototype.enableDragAndDrop = function (options) {
        var self = this;
        var opts = options || {};
        var ddOptions = {
            formatConstructors: [
                ol.format.KMLCustom,
                ol.format.GPXCustom,
                ol.format.GML3CRS84,
                ol.format.GML2CRS84,
                ol.format.GML3,
                ol.format.GML2,
                ol.format.GeoJSON,
                function () {
                    return new ol.format.WKT({
                        splitCollection: true
                    });
                },
                ol.format.TopoJSON
            ]
        };
        if (opts.dropTarget) {
            ddOptions.target = TC.getDiv(opts.dropTarget);
        }
        else {
            ddOptions.target = self.parent.div;
        }
        var ddInteraction = new ol.interaction.DragAndDrop(ddOptions);
        ddInteraction.on('addfeatures', function (e) {
            var featurePromises = e.features ? e.features.map(function (elm) {
                return TC.wrap.Feature.createFeature(elm);
            }) : [];
            Promise.all(featurePromises).then(function (features) {
                var li = self.parent.getLoadingIndicator();
                if (li) {
                    li.removeWait(self._featureImportWaitId);
                }
                if (features.length && !(features.some(function (feature) {
                    return !feature.geometry
                }))) {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORT, {
                        features: features, fileName: e.file.name, dropTarget: e.target.target
                    });
                }
                else {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {
                        file: e.file
                    });
                }
            });
        });
        if (opts.once) {
            ddInteraction.map_ = self.map;
        }
        else {
            self.map.addInteraction(ddInteraction);
            var dropArea = ddInteraction.target ? ddInteraction.target : self.map.getViewport();
            // Añadidos gestores de eventos para mostrar el indicador visual de drop.
            var handleDrop = function (e) {
                if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
                    var map = self.parent;
                    if (ddInteraction.target === e.target) {
                        var li = map.getLoadingIndicator();
                        if (li) {
                            self._featureImportWaitId = li.addWait();
                        }
                        e.stopPropagation();
                    }
                    else {
                        e.preventDefault();
                    }
                    map.div.classList.remove(TC.Consts.classes.DROP);
                }
            };
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragleave',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragend',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragexit',
                    handleDragExit, ddInteraction)
            );
            document.addEventListener('mouseenter', function (e) {
                if (!e.buttons) {
                    self.parent.div.classList.remove(TC.Consts.classes.DROP);
                }
            }, false);
            self.ddEnabled = true;
        }
        return ddInteraction;
    };

    TC.wrap.Map.prototype.loadFiles = function (files, options) {
        var self = this;
        var ddInteraction;
        if (self.ddEnabled) {
            self.map.getInteractions().forEach(function (elm) {
                if (elm instanceof ol.interaction.DragAndDrop) {
                    ddInteraction = elm;
                }
            });
        }
        else {
            ddInteraction = self.enableDragAndDrop({
                once: true
            });
        }

        if (ddInteraction && options) {
            var currentTarget = ddInteraction.target;
            ddInteraction.target = options.control;
            const undoTarget = function (e) {
                ddInteraction.target = currentTarget;

                self.parent.off(TC.Consts.event.FEATURESIMPORT, undoTarget);
            };
            self.parent.on(TC.Consts.event.FEATURESIMPORT, undoTarget);
        }

        var li = self.parent.getLoadingIndicator();
        if (li) {
            self._featureImportWaitId = li.addWait();
        }
        for (let i = 0, ii = files.length; i < ii; ++i) {
            const file = files.item(i);
            const reader = new FileReader();
            reader.addEventListener(ol.events.EventType.LOAD, ddInteraction.handleResult_.bind(ddInteraction, file));
            reader.readAsText(file);
        }
    };

    /*
     *  getVisibility: gets the OpenLayers layer visibility
     *  Result: boolean
     */
    TC.wrap.Layer.prototype.getVisibility = function () {
        const self = this;
        var result = false;
        if (self.layer) {
            result = self.layer.getVisible();
        }
        return result;
    };

    /*
     *  setVisibility: Sets the OpenLayers layer visibility
     *  Parameter: boolean
     */
    TC.wrap.Layer.prototype.setVisibility = function (visible) {
        const self = this;
        self.getLayer().then(function (layer) {
            layer.setVisible(visible);
        });
    };

    TC.wrap.Layer.prototype.isNative = function (layer) {
        return layer instanceof ol.layer.Layer;
    };

    TC.wrap.Layer.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};
        const layer = self.parent;
        if (layer.map) {
            const unitRatio = getUnitRatio.call(self, {
                crs: options.crs,
                extentInDegrees: ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326')
            });

            var resolutions = layer.getResolutions();
            if (resolutions && resolutions.length) {
                resolutions = resolutions.map(function (r) {
                    return r / unitRatio;
                });
                layer.wrap.layer.setMaxResolution(resolutions[0]);
                layer.wrap.layer.setMinResolution(resolutions[resolutions.length - 1]);
            }
            else {
                // de metros a grados
                if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.METERS && (!ol.proj.get(options.crs).getUnits() || ol.proj.get(options.crs).getUnits() === ol.proj.Units.DEGREES)) {

                    if (layer.minResolution) {
                        layer.minResolution = layer.minResolution / unitRatio;
                        self.layer.setMinResolution(layer.minResolution);
                    }

                    if (layer.maxResolution) {
                        layer.maxResolution = layer.maxResolution / unitRatio;
                        self.layer.setMaxResolution(layer.maxResolution);
                    }

                  // de grados a metros
                } else if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.DEGREES && ol.proj.get(options.crs).getUnits() === ol.proj.Units.METERS) {
                    var metersPerDegree = TC.Util.getMetersPerDegree(ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326'));

                    if (layer.minResolution) {
                        layer.minResolution = layer.minResolution * metersPerDegree;
                        self.layer.setMinResolution(layer.minResolution);
                    }

                    if (layer.maxResolution) {
                        layer.maxResolution = layer.maxResolution * metersPerDegree;
                        self.layer.setMaxResolution(layer.maxResolution);
                    }
                }
            }
        }
    };

    TC.wrap.layer.Raster.prototype.WmsParser = ol.format.WMSCapabilities;

    TC.wrap.layer.Raster.prototype.WmtsParser = ol.format.WMTSCapabilities;

    TC.wrap.Layer.prototype.addCommonEvents = function (layer) {
        var self = this;
        layer.on('change:visible', function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.LAYERVISIBILITY, {
                    layer: self.parent
                });
            }
        }, self.parent.map);
    };

    TC.wrap.layer.Raster.prototype.getGetMapUrl = function () {
        var result = null;
        var self = this;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                var dcpType = self.parent.capabilities.Capability.Request.GetMap.DCPType;
                for (var i = 0; i < dcpType.length; i++) {
                    if (dcpType[i].HTTP && dcpType[i].HTTP.Get) {
                        result = dcpType[i].HTTP.Get.OnlineResource;
                        break;
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = self.parent.capabilities.OperationsMetadata.GetTile.DCP.HTTP.Get[0].href;
                break;
            default:
                break;
        }
        const fragment = document.createDocumentFragment();
        const textarea = document.createElement('textarea');
        fragment.appendChild(textarea);
        textarea.innerHTML = result;
        result = textarea.textContent;
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfoFormats = function () {
        var result = null;
        var c = this.parent.capabilities;
        if (c.Capability && c.Capability.Request.GetFeatureInfo) {
            result = c.Capability.Request.GetFeatureInfo.Format;
        }
        return result;
    };

    TC.wrap.layer.Raster.infoFormatPreference = [
        'application/json',
        'application/vnd.ogc.gml/3.1.1',
        'application/vnd.ogc.gml',
        'application/vnd.esri.wms_featureinfo_xml',
        'text/html',
        'text/plain',
        'text/xml'
    ];

    TC.wrap.layer.Raster.prototype.getWMTSLayer = function () {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents) {
            for (var i = 0; i < capabilities.Contents.Layer.length; i++) {
                var layer = capabilities.Contents.Layer[i];
                for (var j = 0; j < layer.TileMatrixSetLink.length; j++) {
                    if (self.parent.options.matrixSet === layer.TileMatrixSetLink[j].TileMatrixSet) {
                        result = layer;
                        break;
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getTileMatrix = function (matrixSet) {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents && capabilities.Contents.TileMatrixSet) {
            for (var i = 0; i < capabilities.Contents.TileMatrixSet.length; i++) {
                var tms = capabilities.Contents.TileMatrixSet[i];
                if (tms.Identifier === matrixSet) {
                    result = tms.TileMatrix;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getScaleDenominators = function (node) {
        var result = [];
        var self = this;
        if (node.ScaleDenominator) {
            result = [node.ScaleDenominator, node.ScaleDenominator];
        }
        else {
            if (node.MinScaleDenominator || node.MaxScaleDenominator) {
                result = [node.MaxScaleDenominator, node.MinScaleDenominator];
            }
        }
        // Contemplamos el caso de una capa sin nombre: sus escalas válidas serán las de sus hijas.
        if (!result.length && !self.getName(node)) {
            var children = self.getLayerNodes(node);
            var max = -Infinity, min = Infinity;
            for (var i = 0, len = children.length; i < len; i++) {
                var childDenominators = self.getScaleDenominators(children[i]);
                if (childDenominators[0] > max) {
                    max = childDenominators[0];
                }
                if (childDenominators[1] < min) {
                    min = childDenominators[1];
                }
            }
            if (max > -Infinity && min < Infinity) {
                result = [max, min];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAttribution = function () {
        const self = this;
        const result = {};
        const capabilities = TC.capabilities[self.parent.url];

        if (capabilities) {
            if (capabilities.ServiceProvider) {
                result.name = capabilities.ServiceProvider.ProviderName.trim();
                result.site = capabilities.ServiceProvider.ProviderSite;
                if (result.site.href && result.site.href.trim().length > 0) {
                    result.site = result.site.href;
                }
            }
            else if (capabilities.ServiceIdentification) {
                result.name = capabilities.ServiceIdentification.Title.trim();
            }
            else {
                result.name = capabilities.Service.Title.trim();
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfo = function (name) {
        var self = this;
        var result = {};
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Capability) {
            var layerNodes = self.getAllLayerNodes();
            for (var i = 0; i < layerNodes.length; i++) {
                var l = layerNodes[i];
                if (self.parent.compareNames(self.getName(l), name)) {
                    if (l.Title) {
                        result.title = l.Title;
                    }
                    if (l.Abstract) {
                        result['abstract'] = l.Abstract;
                    }
                    result.legend = [];

                    var _process = function (value) {
                        var legend = this.getLegend(value);

                        if (legend.src)
                            result.legend.push({
                                src: legend.src, title: value.Title
                            });
                    };

                    var _traverse = function (o, func) {
                        if (o.Layer && o.Layer.length > 0) {
                            for (var i in o.Layer) {
                                //bajar un nivel en el árbol
                                _traverse(o.Layer[i], func);
                            }
                        } else {
                            func.apply(self, [o]);
                        }
                    };

                    //Obtenemos todas las leyendas de la capa o grupo de capas
                    _traverse(l, _process);

                    if (l.MetadataURL && l.MetadataURL.length) {
                        result.metadata = [];
                        for (var j = 0; j < l.MetadataURL.length; j++) {
                            var md = l.MetadataURL[j];
                            result.metadata.push({
                                format: md.Format, type: md.type, url: md.OnlineResource
                            });
                        }
                    }
                    result.queryable = l.queryable;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceType = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Capability.Request && capabilities.Capability.Request.GetMap) {
            result = TC.Consts.layerType.WMS;
        }
        else if (capabilities.OperationsMetadata && capabilities.OperationsMetadata.GetTile) {
            result = TC.Consts.layerType.WMTS;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceTitle = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Service) {
            result = capabilities.Service.Title;
        }
        else if (capabilities.ServiceIdentification) {
            result = capabilities.ServiceIdentification.Title;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getRootLayerNode = function () {
        var self = this;
        var result;
        if (self.getServiceType() === TC.Consts.layerType.WMS) {
            result = self.parent.capabilities.Capability.Layer;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getName = function (node, ignorePrefix) {
        var result = node.Name;
        if (result && ignorePrefix) {
            var idx = result.indexOf(':');
            if (idx >= 0) {
                result = result.substr(idx + 1);
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getIdentifier = function (node) {
        return node.Identifier;
    };

    TC.wrap.layer.Raster.prototype.getLayerNodes = function (node) {
        var result = node.Layer;
        if (!Array.isArray(result)) {
            if (result) {
                result = [result];
            }
            else {
                result = [];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAllLayerNodes = function () {
        var self = this;
        if (!self._layerList) {
            switch (self.getServiceType()) {
                case TC.Consts.layerType.WMS:
                    var getNodeArray = function getNodeArray(node) {
                        var r = [node];
                        var children = self.getLayerNodes(node);
                        for (var i = 0; i < children.length; i++) {
                            r = r.concat(getNodeArray(children[i]));
                        }
                        return r;
                    };
                    var root = self.getRootLayerNode();
                    self._layerList = root ? getNodeArray(root) : [];
                    break;
                case TC.Consts.layerType.WMTS:
                    self._layerList = self.parent.capabilities.Contents.Layer.slice();
                    break;
                default:
                    self._layerList = [];
                    break;
            }
        }
        return self._layerList;
    };

    TC.wrap.layer.Raster.prototype.normalizeLayerNode = function (node) {
        return node;
    };

    TC.wrap.layer.Raster.prototype.normalizeCapabilities = function (capabilities) {
        return capabilities;
    };


    TC.wrap.layer.Raster.prototype.getLegend = function (node) {
        var result = {};
        var styles = node.Style;
        if (styles && styles.length) {
            if (styles.length && styles[0].LegendURL && styles[0].LegendURL.length) {
                var legend = styles[0].LegendURL[0];

                const fragment = document.createDocumentFragment();
                const textarea = document.createElement('textarea');
                fragment.appendChild(textarea);
                textarea.innerHTML = legend.OnlineResource;
                result.src = textarea.textContent;
                // Eliminado porque GeoServer miente con el tamaño de sus imágenes de la leyenda
                //if (legend.size) {
                //    result.width = legend.size[0];
                //    result.height = legend.size[1];
                //}
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.isCompatible = function (crs) {
        var self = this;
        var result = true;
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        var names = layer.names.slice(0);
                        var _isCompatible = function _isCompatible(nodes, name, inCrs) {
                            var r = false;
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    var n = nodes[i];
                                    const itemCRS = n.CRS || n.SRS;
                                    const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                    var isIn = inCrs || crsList.indexOf(crs) >= 0;
                                    if (layer.compareNames(self.getName(n), name)) {
                                        if (isIn) {
                                            r = true;
                                        }
                                        break;
                                    }
                                    else if (_isCompatible(n.Layer, name, isIn)) {
                                        r = true;
                                        break;
                                    }
                                }
                            }
                            return r;
                        };
                        while (names.length > 0) {
                            if (!_isCompatible([layer.capabilities.Capability.Layer], names.pop())) {
                                result = false;
                                break;
                            }
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = false;
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tms = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0; i < tms.length; i++) {
                        if (tms[i].Identifier === layer.options.matrixSet) {
                            result = TC.Util.CRSCodesEqual(crs, tms[i].SupportedCRS);
                            break;
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleCRS = function () {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        const crsLists = layer.names
                            .map(function (name) {
                                return layer
                                    .getNodePath(name) // array de nodos
                                    .map(function (node) {
                                        const itemCRS = node.CRS || node.SRS || [];
                                        const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                        return Array.isArray(crsList) ? crsList : [crsList];
                                    }) // array de arrays de crs
                                    .reduce(function (prev, cur) {
                                        if (prev.length === 0) {
                                            return cur;
                                        }
                                        cur.forEach(function (elm) {
                                            if (prev.indexOf(elm) < 0) {
                                                prev[prev.length - 1] = elm;
                                            }
                                        });// array con todos los crs
                                        return prev;
                                    }, []);
                            });

                        if (crsLists.length === 1) {
                            result = crsLists[0];
                        } else {
                            const otherCrsLists = crsLists.slice(1);
                            result = crsLists[0].filter(function (elm) {
                                return otherCrsLists.every(function (crsList) {
                                    return crsList.indexOf(elm) >= 0;
                                });
                            });
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents) {
                    layer.capabilities.Contents.Layer
                        .filter(function (l) {
                            return l.Identifier === layer.layerNames;
                        })  // La capa de interés
                        .forEach(function (l) {
                            const tileMatrixSets = l.TileMatrixSetLink
                                .map(function (tmsl) {
                                    return tmsl.TileMatrixSet;
                                });
                            result = layer.capabilities.Contents.TileMatrixSet
                                .filter(function (tms) {
                                    return tileMatrixSets.indexOf(tms.Identifier) >= 0;
                                }) // TileMatrixSets asociados a la capa de interés
                                .map(function (tms) {
                                    return tms.SupportedCRS;
                                });
                        });
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleLayers = function (crs) {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    var _fnrecursive = function (item, crs, inCrs) {
                        var crsToCheck = item.CRS || item.SRS;
                        var itemCRS = Array.isArray(crsToCheck) ? crsToCheck : [crsToCheck];
                        var isIn = inCrs || itemCRS.indexOf(crs) >= 0;
                        if (isIn && item.Name) result[result.length] = item.Name;
                        if (item.Layer) {
                            for (var i = 0; i < item.Layer.length; i++) {
                                _fnrecursive(item.Layer[i], crs, isIn);
                            }
                        }
                    }
                    _fnrecursive(layer.capabilities.Capability.Layer, crs);
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tmsList = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0, ii = tmsList.length; i < ii; i++) {
                        var tms = tmsList[i];
                        if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                            var tmsIdentifier = tms.Identifier;
                            var layerList = layer.capabilities.Contents.Layer;
                            for (var j = 0, jj = layerList.length; j < jj; j++) {
                                var tmsLinkList = layerList[j].TileMatrixSetLink;
                                for (var k = 0, kk = tmsLinkList.length; k < kk; k++) {
                                    if (tmsLinkList[k].TileMatrixSet === tmsIdentifier) {
                                        result[result.length] = layerList[j].Identifier;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleMatrixSets = function (crs) {
        var self = this;
        var result = [];
        normalizeProjection({
            crs: crs
        });
        var layer = self.parent;
        if (self.getServiceType() === TC.Consts.layerType.WMTS) {
            var layerList = layer.capabilities.Contents.Layer;
            var tmsList = layer.capabilities.Contents.TileMatrixSet;
            for (var i = 0, ii = layerList.length; i < ii; i++) {
                if (layer.layerNames === layerList[i].Identifier) {
                    var tmsLinkList = layerList[i].TileMatrixSetLink;
                    for (var j = 0, jj = tmsLinkList.length; j < jj; j++) {
                        var tmsLink = tmsLinkList[j];
                        for (var k = 0, kk = tmsList.length; k < kk; k++) {
                            var tms = tmsList[k];
                            if (tms.Identifier === tmsLink.TileMatrixSet) {
                                if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                                    result[result.length] = tms.Identifier;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.setWMTSUrl = function () {
        var self = this;

        self.getLayer().then(function (l) {
            self.parent.options = self.parent.options || {};
            var urls = l.getSource().getUrls();
            self.parent.options.urlPattern = urls[urls.length - 1];
        });
    };

    TC.wrap.layer.Raster.prototype.createWMSLayer = function (url, params, options) {
        const self = this;
        var result = null;

        var source = new ol.source.ImageWMS({
            url: url,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            params: params,
            extent: TC.Cfg.initialExtent,
            ratio: TC.Cfg.imageRatio,
            imageLoadFunction: self.parent.getImageLoad.bind(self.parent)
        });

        source.on('imageloadstart', function (e) {
            self.trigger(TC.Consts.event.BEFORETILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on('imageloadend', function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on('imageloaderror', function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });


        var layerOptions = {
            visible: !!params.LAYERS.length || (options && options.method && options.method === 'POST'), //Las capas de temáticos cargadas por POST no tienen el atributo LAYERS
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }
        result = new ol.layer.Image(layerOptions);

        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    var createWmtsSource = function (options) {
        var self = this;
        var result = null;
        var sourceOptions = ol.source.WMTS.optionsFromCapabilities(self.parent.capabilities, {
            layer: options.layerNames,
            matrixSet: options.matrixSet,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            requestEncoding: options.encoding,
            format: options.format,
        });
        var https = 'https:';

        if (sourceOptions) {
            if (location.protocol === https) {
                sourceOptions.urls = sourceOptions.urls.map(function (elm) {
                    return elm.replace('http:', https);
                });
            }

            sourceOptions.crossOrigin = options.map ? options.map.options.crossOrigin : undefined;

            result = new ol.source.WMTS(sourceOptions);
            result.setTileLoadFunction(self.parent.getImageLoad.bind(self.parent));

            result.on(TILELOADSTART, function (e) {
                self.trigger(TC.Consts.event.BEFORETILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(TILELOADEND, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(TILELOADERROR, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });

            var prevFn = result.getResolutions.bind(result);
            result.getResolutions = function () {
                var resolutions = prevFn();
                var matrix = self.parent.getLimitedMatrixSet();
                //esto está mal, porque matrix podría empezar más abajo (tener recortado por ambos lados)
                if (matrix && matrix.length) {
                    var ix = matrix[0].matrixIndex;
                    resolutions = resolutions.slice(ix, matrix.length + ix);
                }

                return resolutions;
            };
        }

        return result;
    };

    TC.wrap.layer.Raster.prototype.createWMTSLayer = function (options) {
        const self = this;
        var result = null;

        var source = createWmtsSource.call(self, options);

        if (source) {
            var layerOptions = {
                source: source
            };
            if (options.minResolution) {
                layerOptions.minResolution = options.minResolution;
            }
            if (options.maxResolution) {
                layerOptions.maxResolution = options.maxResolution;
            }
            result = new ol.layer.Tile(layerOptions);
            result._wrap = self;

            self.addCommonEvents(result);

            var resolutions = source.getResolutions();
            //Este +1 tan chungo es porque, en el caso en que la resolución del mapa es igual a la máxima del layer, openLayers lo oculta
            result.setMaxResolution(resolutions[0] + 1);
            result.setMinResolution(resolutions[resolutions.length - 1]);
        }

        return result;
    };


    /*
     *  getParams: Gets the WMS layer getmap parameters
     *  Returns: object
     */
    TC.wrap.layer.Raster.prototype.getParams = function () {
        return this.layer.getSource().getParams();
    };

    /*
     *  setParams: Sets the WMS layer getmap parameters
     *  Parameter: object
     */
    TC.wrap.layer.Raster.prototype.setParams = function (params) {
        this.layer.getSource().updateParams(params);
    };

    TC.wrap.layer.Raster.prototype.setMatrixSet = function (matrixSet) {
        const self = this;
        const oldResolutions = self.layer.getSource().getResolutions();
        if (self.parent.type === TC.Consts.layerType.WMTS) {
            const newSource = createWmtsSource.call(self, TC.Util.extend({}, self.parent.options, { matrixSet: matrixSet }));
            const newResolutions = newSource.getResolutions();
            const newMaxResolution = newResolutions[0]
            const newMinResolution = newResolutions[newResolutions.length - 1];
            self.layer.setMaxResolution(newMaxResolution);
            self.layer.setMinResolution(newMinResolution);
            if (self.parent.minResolution) {
                self.parent.minResolution = newMinResolution;
            }
            if (self.parent.maxResolution) {
                self.parent.maxResolution = newMaxResolution;
            }
            self.layer.setSource(newSource);
        }
    };

    TC.wrap.layer.Raster.prototype.getResolutions = function () {
        if (this.layer.getSource) {
            var ts = this.layer.getSource();
            if (ts.getResolutions) return ts.getResolutions();
            else return [];
        }
        else {
            return [];
        }
    };

    TC.wrap.layer.Raster.prototype.setResolutions = function (resolutions) {
        if (this.layer.getSource) {
            var ts = this.layer.getSource();
            if (ts.resolutions_) {
                ts.resolutions_ = resolutions;
            }
            else if (ts.tileGrid) {
                ts.tileGrid.resolutions_ = resolutions;
            }
        }
    };

    TC.wrap.Geometry = {
        getNearest: function (point, candidates) {
            var pline = new ol.geom.LineString(candidates);
            return pline.getClosestPoint(point);
        }
    };

    // En OL3 la imagen tiene el tamaño original. Escalamos si hace falta.
    var setScaleFunction = function (imageStyle, iconWidth, olFeat) {
        if (imageStyle) {
            var setScaleForWidth = function (imgWidth) {
                var markerWidth = (olFeat && olFeat._wrap ? olFeat._wrap.parent.options.width : null) || iconWidth;
                if (markerWidth < imgWidth) {
                    var factor = markerWidth / imgWidth;
                    imageStyle.setScale(factor);
                }
            };
            var imageSize = imageStyle.getSize();
            if (imageSize) {
                setScaleForWidth(imageSize[0]);
            }
            else {
                var img = imageStyle.getImage();
                if (img.naturalWidth) {
                    setScaleForWidth(img.naturalWidth);
                }
                else {
                    const fragment = document.createDocumentFragment();
                    const img = document.createElement('img');
                    img.src = imageStyle.getSrc();
                    img.addEventListener('load', function () {
                        setScaleForWidth(this.naturalWidth);
                    });
                    fragment.appendChild(img);
                }
            }
        }
    };

    var getStyleValue = function (property, feature) {
        var result = property;
        var olFeat = feature && feature.wrap && feature.wrap.feature;
        if (typeof property === 'string') {
            var match = property.match(/^\$\{(.+)\}$/);
            if (match && olFeat) {
                // Permitimos el formato ${prop.subprop.subsubprop}
                var m = match[1].split('.');
                var r = olFeat.getProperties();
                for (var i = 0; i < m.length && r !== undefined; i++) {
                    r = r[m[i]];
                }
                if (r === undefined) {
                    r = feature.data;
                    for (var i = 0; i < m.length && r !== undefined; i++) {
                        r = r[m[i]];
                    }
                }
                result = r;
            }
        }
        else if (TC.Util.isFunction(property)) {
            result = property(feature);
        }
        return result;
    };

    // Transformación de opciones de estilo en un estilo nativo OL3.
    var createNativeStyle = function (options, olFeat) {
        var nativeStyleOptions = {
        };

        var feature;
        var isPoint, isLine, isPolygon;
        if (olFeat) {
            switch (olFeat.getGeometry().getType()) {
                case 'Point':
                case 'MultiPoint':
                    isPoint = true;
                    break;
                case 'LineString':
                case 'MultiLineString':
                    isLine = true;
                    break;
                case 'Polygon':
                case 'MultiPolygon':
                    isPolygon = true;
                    break;
            }
            if (olFeat._wrap) {
                feature = olFeat._wrap.parent;
            }
            else {
                // Si la API SITNA no ha completado su feature, creamos un mock-up para que no fallen las funciones de estilo
                feature = {
                    id: TC.wrap.Feature.prototype.getId.call({
                        feature: olFeat
                    }), // GLS añado el id de la feature para poder filtrar por la capa a la cual pertenece                    
                    features: olFeat.get('features'),
                    getData: function () {
                        return TC.wrap.Feature.prototype.getData.call({
                            feature: olFeat
                        });
                    }
                };


            }
        }
        var isCluster = feature && Array.isArray(feature.features) && feature.features.length > 1 && options.cluster;
        var styles;
        if (isCluster) {
            styles = TC.Util.extend(true, {}, TC.Cfg.styles.cluster, options.cluster.styles);
        }
        else {
            styles = options.styles || TC.Cfg.styles;
        }

        var styleOptions = {};
        if (styles.line && (isLine || !olFeat)) {
            styleOptions = styles.line;
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.line.strokeColor, feature),
                width: getStyleValue(styles.line.strokeWidth, feature),
                lineDash: styles.line.lineDash
            });
        }

        if (styles.polygon && (isPolygon || !olFeat)) {
            styleOptions = styles.polygon;
            nativeStyleOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styles.polygon.fillColor, feature), getStyleValue(styles.polygon.fillOpacity, feature))
            });
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.polygon.strokeColor, feature),
                width: getStyleValue(styles.polygon.strokeWidth, feature),
                lineDash: styles.polygon.lineDash
            });
        }

        if (styles.point && (isPoint || !olFeat)) {
            styleOptions = styles.point;
            var circleOptions = {
                radius: getStyleValue(styleOptions.radius, feature) ||
                    (getStyleValue(styleOptions.height, feature) + getStyleValue(styleOptions.width, feature)) / 4
            };
            if (styleOptions.fillColor) {
                circleOptions.fill = new ol.style.Fill({
                    color: getRGBA(getStyleValue(styleOptions.fillColor, feature), getStyleValue(styleOptions.fillOpacity, feature))
                });
            }
            if (styleOptions.strokeColor) {
                circleOptions.stroke = new ol.style.Stroke({
                    color: getStyleValue(styleOptions.strokeColor, feature),
                    width: getStyleValue(styleOptions.strokeWidth, feature),
                    lineDash: styleOptions.lineDash
                });
            }

            if (!isNaN(circleOptions.radius))
                nativeStyleOptions.image = new ol.style.Circle(circleOptions);
        }

        if (styleOptions.label) {
            nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
        }

        if (styles.marker && (isPoint || !olFeat)) {
            styleOptions = styles.marker;
            var ANCHOR_DEFAULT_UNITS = 'fraction';
            if (styleOptions.url) {
                nativeStyleOptions.image = new ol.style.Icon({
                    crossOrigin: 'anonymous',
                    anchor: styleOptions.anchor,
                    anchorXUnits: styleOptions.anchorXUnits || ANCHOR_DEFAULT_UNITS,
                    anchorYUnits: styleOptions.anchorYUnits || ANCHOR_DEFAULT_UNITS,
                    src: styleOptions.url
                });
                nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
            }
        }

        return [new ol.style.Style(nativeStyleOptions)];
    };

    const createNativeTextStyle = function (styleObj, feature) {
        if (!styleObj || !styleObj.label) {
            return;
        }

        const textOptions = {
            text: '' + getStyleValue(styleObj.label, feature),
        };
        //const olGeom = feature.wrap.feature.getGeometry();
        //if (olGeom instanceof ol.geom.LineString || olGeom instanceof ol.geom.MultiLineString) {
        //    textOptions.placement = ol.style.TextPlacement.LINE;
        //}
        if (styleObj.fontSize) {
            textOptions.font = getStyleValue(styleObj.fontSize, feature) + 'pt sans-serif';
        }
        if (styleObj.angle) {
            textOptions.rotation = -Math.PI * getStyleValue(styleObj.angle, feature) / 180;
        }
        if (styleObj.fontColor) {
            textOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styleObj.fontColor, feature), 1)
            });
        }
        if (styleObj.labelOutlineColor) {
            textOptions.stroke = new ol.style.Stroke({
                color: getRGBA(getStyleValue(styleObj.labelOutlineColor, feature), 1),
                width: getStyleValue(styleObj.labelOutlineWidth, feature)
            });
        }
        if (styleObj.labelOffset) {
            textOptions.offsetX = styleObj.labelOffset[0];
            textOptions.offsetY = styleObj.labelOffset[1];
        }
        return new ol.style.Text(textOptions);
    };

    var toHexString = function (number) {
        var result = number.toString(16);
        if (result.length === 1) {
            result = '0' + result;
        }
        return result;
    };

    var getHexColorFromArray = function (colorArray) {
        return '#' + toHexString(colorArray[0]) + toHexString(colorArray[1]) + toHexString(colorArray[2])
    };

    var getStyleFromNative = function (olStyle, olFeat) {
        var result = {
        };
        if (TC.Util.isFunction(olStyle)) {
            if (olFeat) {
                olStyle = olStyle(olFeat);
            }
        }
        if (Array.isArray(olStyle)) {
            olStyle = olStyle[0];
        }
        if (!TC.Util.isFunction(olStyle)) {
            var color;
            var stroke;
            var fill;
            var image = olStyle.getImage();
            if (image) {
                if (image instanceof ol.style.RegularShape) {
                    stroke = image.getStroke();
                    color = stroke.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.strokeColor = getHexColorFromArray(color);
                    }
                    result.strokeWidth = stroke.getWidth();
                    fill = image.getFill();
                    if (fill) {
                        color = fill.getColor();
                        if (color) {
                            color = ol.color.asArray(color);
                            result.fillColor = getHexColorFromArray(color);
                        }
                        result.fillOpacity = color[3];
                    }
                }
                else {
                    result.url = image.getSrc();
                    var size = image.getSize();
                    if (size) {
                        result.width = size[0];
                        result.height = size[1];
                        result.anchor = image.getAnchor();
                        if (result.anchor) {
                            result.anchor[0] = result.anchor[0] / result.width;
                            result.anchor[1] = result.anchor[1] / result.height;
                        }
                    }
                }
            }
            else {
                stroke = olStyle.getStroke();
                if (stroke) {
                    color = stroke.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.strokeColor = getHexColorFromArray(color);
                    }
                    result.strokeWidth = stroke.getWidth();
                    result.lineDash = stroke.getLineDash();
                }
                fill = olStyle.getFill();
                if (fill) {
                    color = fill.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.fillColor = getHexColorFromArray(color);
                    }
                    result.fillOpacity = color[3];
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Vector.prototype.getStyle = function () {
        return getStyleFromNative(this.layer.getStyle());
    };

    TC.wrap.layer.Vector.prototype.reloadSource = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const layerOptions = self.createVectorSource(self.parent, self.createStyles(self.parent));

            if (self.parent.type === TC.Consts.layerType.WFS) {
                var listenerKey = layerOptions.source.on('change', function (e) {
                    if (layerOptions.source.getState() == 'ready') {
                        ol.Observable.unByKey(listenerKey);

                        resolve();
                    }
                });
            }

            var features = self.layer.getSource().getFeatures();
            self.layer.setSource(layerOptions.source);

            if (layerOptions.style)
                self.layer.setStyle(layerOptions.style);

            if (self.parent.type != TC.Consts.layerType.WFS) {
                layerOptions.source.addFeatures(features);
                resolve();
            }
        });
    };

    TC.wrap.layer.Vector.prototype.import = function (options) {
        var self = this;
        var opts = TC.Util.extend({
        }, options);
        opts.type = options.format;

        var oldFeatures = self.layer.getSource().getFeatures();
        var layerOptions = self.createVectorSource(opts, self.createStyles(self.parent));
        self.layer.setSource(layerOptions.source);
        if (layerOptions.style) {
            self.layer.setStyle(layerOptions.style);
        }

        layerOptions.source.addFeatures(oldFeatures);
    };

    const getIcon = function (olFeat) {
        var result = null;
        var style = getNativeFeatureStyle(olFeat, true);
        if (style) {
            var img = style.getImage();
            if (img instanceof ol.style.Icon) {
                result = img.getSrc();
            }
        }
        return result;
    };

    const createFeatureFromNative = function (olFeat) {
        if (!olFeat._wrapPromise) { // Si no se ha llamado antes a esta función para esta feature
            olFeat._wrapPromise = new Promise(function (resolve, reject) {
                var options;
                var geom = olFeat.getGeometry();
                const olStyle = olFeat.getStyle();
                if (olStyle) {
                    options = getStyleFromNative(olStyle, olFeat);
                }

                const resolveFn = function (ctorName) {
                    if (ctorName) {
                        TC.loadJS(
                            !TC.feature || !TC.feature[ctorName],
                            TC.apiLocation + 'TC/feature/' + ctorName,
                            function () {
                                resolve(new TC.feature[ctorName](olFeat, options));
                            }
                        );
                    }
                    else {
                        resolve(new TC.Feature(olFeat, options));
                    }
                };

                if (geom instanceof ol.geom.Point) {
                    if (getIcon(olFeat)) {
                        resolveFn('Marker');
                    }
                    else {
                        resolveFn('Point');
                    }
                }
                else if (geom instanceof ol.geom.LineString) {
                    resolveFn('Polyline');
                }
                else if (geom instanceof ol.geom.Polygon) {
                    resolveFn('Polygon');
                }
                else if (geom instanceof ol.geom.MultiLineString) {
                    resolveFn('MultiPolyline');
                }
                else if (geom instanceof ol.geom.MultiPolygon) {
                    resolveFn('MultiPolygon');
                }
                else {
                    resolveFn();
                }
            });
        }
        return olFeat._wrapPromise;
    };

    TC.wrap.layer.Vector.prototype.createVectorSource = function (options, nativeStyle) {
        var self = this;

        var createGenericLoader = function (url, format) {
            var internalLoader = ol.featureloader.xhr(url, format);
            return function (extent, resolution, projection) {
                self.parent.state = TC.Layer.state.LOADING;
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                        layer: self.parent
                    });
                }
                internalLoader.call(this, extent, resolution, projection);
            };
        };
        var usesGenericLoader = false;

        var source;
        var vectorOptions;

        var getMimeTypeFromUrl = function (url) {
            var idx = url.indexOf('?');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
            else {
                idx = url.indexOf('#');
                if (idx >= 0) {
                    url = url.substr(0, idx);
                }
            }
            switch (url.substr(url.lastIndexOf('.') + 1).toLowerCase()) {
                case 'kml':
                    return TC.Consts.mimeType.KML;
                case 'json':
                case 'geojson':
                    return TC.Consts.mimeType.GEOJSON;
                case 'gml':
                    return TC.Consts.mimeType.GML;
                case 'gpx':
                    return TC.Consts.mimeType.GPX;
                default:
                    return null;
            }
        };

        if (Array.isArray(options.url) || options.urls) {
            var urls = options.urls || options.url;
            urls = urls.map(function (elm, idx) {
                return TC.proxify(elm);
            });
            vectorOptions = {
                url: urls,
                format: new ol.format.KMLCustom({
                    showPointNames: false
                }),
                projection: options.crs
            };
        }
        else if (options.url && options.type !== TC.Consts.layerType.WFS) {
            vectorOptions = {
                url: TC.proxify(options.url),
                projection: options.crs
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(getMimeTypeFromUrl(options.url)) || getFormatFromName(options.type);
            vectorOptions.loader = createGenericLoader(vectorOptions.url, vectorOptions.format);
            usesGenericLoader = true;
        }
        else if (options.data) {
            vectorOptions = {
                projection: options.crs,
                loader: function (extent, resolution, projection) {
                    self.parent.state = TC.Layer.state.LOADING;
                    if (self.parent.map) {
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });
                    }
                    var format = this.getFormat();
                    try {
                        var fs = format.readFeatures(options.data, {
                            featureProjection: projection
                        });
                        this.addFeatures(fs);
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                layer: self.parent, newData: data
                            });
                        }
                    }
                    catch (e) {
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, {
                                layer: self.parent, reason: e.message
                            });
                        }
                    }
                }
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(options.type);
        }
        else if (options.type == TC.Consts.layerType.WFS) {
            var outputFormat;
            var mimeType;
            switch (options.outputFormat) {
                case TC.Consts.format.JSON:
                    outputFormat = new ol.format.GeoJSON({
                        geometryName: options.geometryName
                    });
                    mimeType = 'json';
                    break;
                case TC.Consts.format.GML3:
                    outputFormat = new ol.format.GML3();
                    mimeType = TC.Consts.mimeType.GML;
                    break;
                default:
                    outputFormat = new ol.format.GML2();
                    mimeType = TC.Consts.mimeType.GML;
                    break;
            }
            vectorOptions = {
                format: outputFormat,
                loader: function (extent, resolution, projection) {
                    var sOrigin = this;
                    var serviceUrl = options.url;
                    if (serviceUrl) {
                        self.parent.state = TC.Layer.state.LOADING;
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });
                        var ajaxOptions = {};
                        var crs = projection.getCode();
                        var version = options.version || '1.1.0';
                        var url = serviceUrl;
                        var featureType = Array.isArray(options.featureType) ? options.featureType : [options.featureType];
                        if (!options.properties || (options.properties instanceof Array && !options.properties.length) || !(Object.keys(options.properties).length)) {
                            url = url + '?service=WFS&' +
                                'version=' + version + '&request=GetFeature&typename=' + featureType.join(',') + '&' +
                                'outputFormat=' + mimeType + '&srsname=' + crs;
                            if (extent[0] !== -Infinity && extent[1] !== -Infinity && extent[2] !== Infinity && extent[3] !== Infinity) {
                                url = url + '&bbox=' + extent.join(',') + ',' + crs;
                            }

                            if (options.maxFeatures)
                                url = url + "maxFeatures=" + options.maxFeatures;
                        }
                        else {
                            ajaxOptions.method = 'POST';
                            switch (mimeType) {
                                case 'json':
                                    ajaxOptions.responseType = TC.Consts.mimeType.JSON;
                                    break;
                                default:
                                    ajaxOptions.responseType = TC.Consts.mimeType.XML;
                                    break;

                            }
                            //ajaxOptions.contentType = TC.Consts.mimeType.XML;
                            //ajaxOptions.processData = false;
                            //var formatter = new ol.format.WFS();
                            //var doc = formatter.writeGetFeature({
                            //    featureNS: 'wfs',
                            //    featurePrefix: 'feature',
                            //    featureTypes: featureType,
                            //    srsName: crs
                            //});
                            //var filter = [];
                            //filter[0] = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">';
                            //if (options.properties.length > 1) {
                            //    filter[filter.length] = '<ogc:And>';
                            //}
                            //for (var j = 0; j < options.properties.length; j++) {
                            //    var prop = options.properties[j];
                            //    filter[filter.length] = '<ogc:PropertyIsEqualTo matchCase="true"><ogc:PropertyName>';
                            //    filter[filter.length] = prop.name;
                            //    filter[filter.length] = '</ogc:PropertyName><ogc:Literal>';
                            //    filter[filter.length] = prop.value;
                            //    filter[filter.length] = '</ogc:Literal></ogc:PropertyIsEqualTo>';
                            //}
                            //if (options.properties.length > 1) {
                            //    filter[filter.length] = '</ogc:And>';
                            //}
                            //filter[filter.length] = '</ogc:Filter>';
                            //filter = filter.join('');
                            //var $doc = $(doc);
                            //$doc.find('Query').each(function (idx, query) {
                            //    $(query).html(filter);
                            //});
                            //ajaxOptions.data = $('<div>').append($doc).html();
                            var gml = [];
                            gml[gml.length] = '<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" service="WFS" version="';
                            gml[gml.length] = version;
                            gml[gml.length] = '" outputFormat="';
                            gml[gml.length] = options.outputFormat;
                            if (options.maxFeatures) {
                                gml[gml.length] = '" maxFeatures="';
                                gml[gml.length] = options.maxFeatures;
                            }
                            gml[gml.length] = '" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/';
                            gml[gml.length] = version;
                            gml[gml.length] = '/wfs.xsd">';
                            for (var i = 0; i < featureType.length; i++) {
                                gml[gml.length] = '<wfs:Query typeName="feature:';
                                gml[gml.length] = featureType[i];
                                gml[gml.length] = '" srsName="';
                                gml[gml.length] = crs;
                                gml[gml.length] = '">';
                                if (options.propertynames) {
                                    var pPrefix = version === '1.1.0' ? 'wfs' : 'ogc';
                                    var _arrProperties = typeof (options.propertynames) === "string" ? options.propertynames.split(",") : options.propertynames
                                    if (options.geometryName)
                                        _arrProperties.push(options.geometryName)
                                    for (var i; i < _arrProperties.length; i++) {
                                        gml[gml.length] = '<' + pPrefix + ':PropertyName>' + _arrProperties[i].trim() + '</' + pPrefix + ':PropertyName>';
                                    }
                                }
                                gml[gml.length] = options.properties.getText();
                                gml[gml.length] = '</wfs:Query>';
                            }
                            gml[gml.length] = '</wfs:GetFeature>';

                            ajaxOptions.data = gml.join('');
                            ajaxOptions.contentType = TC.Consts.mimeType.XML;
                        }
                        ajaxOptions.url = url;
                        self._requestUrl = url;
                        TC.ajax(ajaxOptions).then(function (response) {
                            const data = response.data;
                            const feats = outputFormat.readFeatures(data);
                            const triggerLayerUpdate = function () {
                                self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                    layer: self.parent, newData: data
                                });
                            };
                            const onFeaturesAdd = function (e) {
                                if (e.layer === self.parent) {
                                    self.parent.map.off(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                                    triggerLayerUpdate();
                                }
                            };
                            if (feats.length) {
                                sOrigin.addFeatures(feats);
                                self.parent.map.on(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                            }
                            else {
                                triggerLayerUpdate();
                            }
                            self.parent.state = TC.Layer.state.IDLE;
                        });
                    }
                },
                //strategy: ol.loadingstrategy.all(),
                projection: options.crs
            };
        }

        source = new ol.source.Vector(vectorOptions);

        if (usesGenericLoader) {
            source.on(CHANGE, function (e) {
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                        layer: self.parent
                    });
                }
            });
        }

        source._tcLayer = self.parent;

        var markerStyle = options.style && options.style.marker ? options.style.marker : TC.Cfg.styles.marker;
        if (!options.style || !options.style.marker) {
            markerStyle = TC.Util.extend({}, markerStyle, {
                anchor: TC.Cfg.styles.point.anchor
            });
        }

        // Si habilitamos el clustering la fuente es especial
        if (options.cluster) {
            source = new ol.source.Cluster({
                projection: options.crs,
                distance: options.cluster.distance,
                source: source
            });

            // Animación
            if (options.cluster.animate) {
                var getCurrentCoordinates = function (fromCoords, toCoords, duration, start) {
                    var fraction = Math.min((Date.now() - start) / duration, 1);
                    var dx = (toCoords[0] - fromCoords[0]) * fraction;
                    var dy = (toCoords[1] - fromCoords[1]) * fraction;
                    return [fromCoords[0] + dx, fromCoords[1] + dy];
                };
                var animate = function (parent, child) {
                    var start = Date.now();
                    var pCoords = parent.getGeometry().getCoordinates();
                    var cCoords = child.getGeometry().getCoordinates();
                    child.setGeometry(new ol.geom.Point(pCoords));
                    var step = function step() {
                        var coords = getCurrentCoordinates(pCoords, cCoords, TC.Consts.CLUSTER_ANIMATION_DURATION, start);
                        child.setGeometry(new ol.geom.Point(coords));
                        if (coords[0] !== cCoords[0] && coords[1] !== cCoords[1]) {
                            requestAnimationFrame(step);
                        }
                        else {
                            clusterCache.splice(clusterCache.indexOf(parent), 1);
                        }
                    };
                    requestAnimationFrame(step);
                };
                var clusterCache = [];
                source.addEventListener(REMOVEFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features && features.length > 1) {
                        clusterCache.push(e.feature);
                    }
                });
                source.addEventListener(ADDFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features) {
                        var coords = features[0].getGeometry().getCoordinates();
                        if (features.length > 1) {
                            var match = clusterCache.filter(function (elm) {
                                var elmCoords = elm.getGeometry().getCoordinates();
                                return elmCoords[0] === coords[0] && elmCoords[1] === coords[1];
                            });
                            if (match.length) {
                                clusterCache.splice(clusterCache.indexOf(match[0]), 1);
                            }
                        }
                        var parent = clusterCache.filter(function (elm) {
                            var children = elm.get('features');
                            if (children && children.length > 0) {
                                var child = children.filter(function (cElm) {
                                    var cCoords = cElm.getGeometry().getCoordinates();
                                    return cCoords[0] === coords[0] && cCoords[1] === coords[1];
                                });
                                return child.length > 0;
                            }
                        });
                        if (parent.length) {
                            animate(parent[parent.length - 1], e.feature);
                        }
                    }
                });
            }
        }

        var s = source;
        do {
            s.addEventListener(ADDFEATURE, function (e) {
                var olFeat = e.feature;
                // OL3 dibuja el tamaño original del icono del marcador, lo escalamos si es necesario:
                var style = getNativeFeatureStyle(olFeat, true);
                if (style) {
                    setScaleFunction(style.getImage(), markerStyle.width, olFeat);
                }
            });
            if (TC.Util.isFunction(s.getSource)) {
                s = s.getSource();
            }
            else {
                s = null;
            }
        }
        while (s);

        source.addEventListener(ADDFEATURE, function (e) {
            const olFeat = e.feature;

            const addFeatureToLayer = function (feat) {
                var addFn;
                switch (true) {
                    case TC.feature.Point && feat instanceof TC.feature.Point:
                        addFn = self.parent.addPoint;
                        break;
                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:
                        addFn = self.parent.addPolyline;
                        break;
                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:
                        addFn = self.parent.addPolygon;
                        break;
                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:
                        addFn = self.parent.addMultiPolygon;
                        break;
                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:
                        addFn = self.parent.addMultiPolyline;
                        break;
                    default:
                        addFn = self.parent.addFeature;
                        break;
                }
                if (addFn) {
                    var _timeout;
                    addFn.call(self.parent, olFeat).then(function (f) {
                        var features = olFeat.get('features');
                        if (Array.isArray(features)) {
                            // Es una feature de fuente ol.source.Cluster
                            f.features = features.map(function (elm) {
                                return new feat.constructor(elm);
                            });
                        }

                        // Timeout porque OL3 no tiene evento featuresadded. El timeout evita ejecuciones a lo tonto.
                        clearTimeout(_timeout);
                        _timeout = setTimeout(function () {
                            self.parent.map.trigger(TC.Consts.event.FEATURESADD, {
                                layer: self.parent, features: [f]
                            });
                        }, 50);
                    });
                }
            };

            if (!olFeat._wrap || !olFeat._wrap.parent.layer) { // Solo actuar si no es una feature añadida desde la API
                createFeatureFromNative(olFeat).then(addFeatureToLayer);
            }
        });

        source.addEventListener(REMOVEFEATURE, function (e) {
            var olFeat = e.feature;
            if (olFeat._wrap) {
                var idx = self.parent.features.indexOf(olFeat._wrap.parent);
                if (idx > -1) {
                    self.parent.features.splice(idx, 1);
                    self.parent.map.trigger(TC.Consts.event.FEATUREREMOVE, {
                        layer: self.parent, feature: olFeat._wrap.parent
                    });
                }
            }
        });

        source.addEventListener(ADDFEATURE, function (e) {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(REMOVEFEATURE, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(CLEAR, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.FEATURESCLEAR, {
                    layer: self.parent
                });
            }
        });

        var layerOptions = {
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }

        // En KML conservamos el estilo que viene con el archivo, así que no entramos aquí.
        // A no ser que tenga clusters, porque OL no soporta por defecto la combinación de estilo KML con clusters.
        if (!(vectorOptions && vectorOptions.format instanceof ol.format.KML) || options.cluster) {
            layerOptions.style = nativeStyle || options.styles;
        }

        return layerOptions;
    };

    TC.wrap.layer.Vector.prototype.createStyles = function (options) {
        var self = this;

        var dynamicStyle = false;

        if (TC.Util.isFunction(options)) {
            dynamicStyle = true;
            self.styleFunction = function (olFeat) {
                return createNativeStyle(options(olFeat));
            }
        }
        else {
            options = TC.Util.extend({}, options);
            options.crs = options.crs || TC.Cfg.crs;
            options.styles = options.styles || TC.Cfg.styles;
            var isDynamicStyle = function isDynamicStyle(obj) {
                for (var key in obj) {
                    var prop = obj[key];
                    switch (typeof prop) {
                        case 'string':
                            if (/^\$\{(.+)\}$/.test(prop)) {
                                return true;
                            }
                            break;
                        case 'object':
                            if (isDynamicStyle(prop)) {
                                return true;
                            }
                            break;
                        case 'function':
                            return true;
                            break;
                        default:
                            break;
                    }
                }
                return false;
            };

            dynamicStyle = !!(options.cluster && options.cluster.styles) || isDynamicStyle(options.styles);
            self.styleFunction = function (olFeat) {
                return createNativeStyle(self.parent.options, olFeat);
            };
        }

        var nativeStyle = dynamicStyle ? self.styleFunction : self.styleFunction();

        return nativeStyle;
    };

    TC.wrap.layer.Vector.prototype.setStyles = function (options) {
        const self = this;
        self.getLayer().then(function (olLayer) {
            olLayer.setStyle(self.createStyles(options));
        });
    };

    TC.wrap.layer.Vector.prototype.createVectorLayer = function () {
        const self = this;
        var result = null;

        var options = self.parent.options;

        var layerOptions = self.createVectorSource(options, self.createStyles(options));
        layerOptions.declutter = self.parent.options.declutter || false;
        result = new ol.layer.Vector(layerOptions);
        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    TC.wrap.layer.Vector.prototype.addFeatures = function (features) {
        const self = this;
        const commit = function (l) {
            var source = l;
            while (TC.Util.isFunction(source.getSource)) {
                source = source.getSource();
            }
            source.addFeatures(features);
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatures = function () {
        var olLayer = this.getLayer();
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatures();
        }
        else {
            return [];
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatureById = function (id) {
        var olLayer = this.layer;
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatureById(id);
        }
        else {
            return null;
        }
    };

    TC.wrap.layer.Vector.prototype.removeFeature = function (feature) {
        const self = this;
        const commit = function (l) {
            if (feature.wrap.feature) {
                var source = l.getSource();
                source.removeFeature(feature.wrap.feature);
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.clearFeatures = function () {
        const self = this;
        const commit = function (l) {
            var source = l.getSource();
            if (source.clearFeatures) {
                source.clearFeatures();
            }
            else {
                source.clear();
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.setFeatureVisibility = function (feature, visible) {
        var self = this;

        var fillOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var strokeOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var displayNoneStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 0,
                fill: new ol.style.Fill(fillOptions),
                stroke: new ol.style.Stroke(strokeOptions)
            }),
            fill: new ol.style.Fill(fillOptions),
            stroke: new ol.style.Stroke(strokeOptions)
        });
        var idx = self.parent.features.indexOf(feature);
        if (idx >= 0) {
            var olFeat = feature.wrap.feature;
            self.getLayer().then(function (olLayer) {
                if (visible && olFeat._originalStyle) {
                    olFeat.setStyle(olFeat._originalStyle);
                }
                else {
                    olFeat._originalStyle = olFeat.getStyle() || olLayer.getStyle();
                    olFeat.setStyle(displayNoneStyle);
                }
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            });
        }
    };

    TC.wrap.layer.Vector.prototype.getRGBA = function (color, opacity) {
        return getRGBA(color, opacity);
    };

    TC.wrap.layer.Vector.prototype.findFeature = function (values) {
        // TODO: añadir ol.animation.zoom
    };

    TC.wrap.layer.Vector.prototype.getGetFeatureUrl = function () {
        return this._requestUrl;
    };

    TC.wrap.layer.Vector.prototype.getDescribeFeatureTypeUrl = function () {
        var self = this;
        var layer = self.parent;
        var version = layer.options.version || '1.1.0';
        var url = layer.url;
        var featureType = Array.isArray(layer.options.featureType) ? layer.options.featureType : [layer.options.featureType];
        url = url + '?service=WFS&' + 'version=' + version + '&request=DescribeFeatureType&typename=' + featureType.join(',') + '&outputFormat=XMLSCHEMA';
        return url;
    };

    TC.wrap.layer.Vector.prototype.sendTransaction = function (inserts, updates, deletes) {
        const self = this;
        const getNativeFeature = function (feat) {
            return feat.wrap.feature;
        };
        return new Promise(function (resolve, reject) {
            const olInserts = inserts.map(getNativeFeature);
            const olUpdates = updates.map(getNativeFeature);
            const olDeletes = deletes.map(getNativeFeature);
            if (inserts.length || updates.length || deletes.length) {
                self.getLayer().then(function (olLayer) {
                    var source = olLayer.getSource();
                    var format = new ol.format.WFS();
                    var options = self.parent.options;
                    var transaction = format.writeTransaction(olInserts, olUpdates, olDeletes, {
                        featurePrefix: options.featurePrefix,
                        featureNS: options.featureNS,
                        featureType: options.featureType[0]
                    });
                    var ajaxOptions = {
                        url: self.parent.url,
                        method: 'POST',
                        responseType: TC.Consts.mimeType.XML,
                        data: transaction.outerHTML
                    };
                    TC.ajax(ajaxOptions)
                        .then(function (response) {
                            const data = response.data;
                            var er = data.getElementsByTagName('ExceptionReport')[0];
                            var errorObj = {
                                reason: ''
                            };
                            if (er) {
                                var e = er.getElementsByTagName('Exception')[0];
                                if (e) {
                                    errorObj.code = e.getAttribute('exceptionCode');
                                    var texts = e.getElementsByTagName('ExceptionText');
                                    for (var i = 0, len = texts.length; i < len; i++) {
                                        errorObj.reason += '\n' + texts[i].innerHTML;
                                    }
                                }
                                reject(errorObj);
                            }
                            else {
                                var transactionResponse = format.readTransactionResponse(data);
                                resolve(transactionResponse);
                            }
                        })
                        .catch(function () {
                            reject({
                                code: '', reason: 'unknown'
                            });
                        });
                });
            }
            else {
                resolve(self.parent);
            }
        });
    };

    TC.wrap.layer.Vector.prototype.setDraggable = function (draggable, onend, onstart) {
        var self = this;

        //tiene que estar a nivel de control para poder retirarla después
        //var interaction;
        Promise.all([self.parent.map.wrap.getMap(), self.getLayer()]).then(function (olObjects) {
            const olMap = olObjects[0];
            const olLayer = olObjects[1];
            if (draggable) {
                var interactionOptions = {
                    layers: [olLayer],
                    features: new ol.Collection(olLayer.getSource().getFeatures())
                };
                self.interaction = new ol.interaction.Translate(interactionOptions);
                if (TC.Util.isFunction(onend)) {
                    self.interaction.on('translateend', function (e) {
                        if (e.features.getLength()) {
                            onend(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                if (TC.Util.isFunction(onstart)) {
                    self.interaction.on('translatestart', function (e) {
                        if (e.features.getLength()) {
                            onstart(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                olMap.addInteraction(self.interaction);
            }
            else if (self.interaction) {
                olMap.removeInteraction(self.interaction);

                // GLS: En IE no muestra la manita en el over sobre marcadores trasladables.
                if (TC.Util.detectIE() && self._handlerDraggablePointerMove && TC.Util.isFunction(self._handlerDraggablePointerMove)) {
                    olMap.un('pointermove', self._handlerDraggablePointerMove);
                    delete self._handlerDraggablePointerMove;
                }
            }
        });
    };

    TC.wrap.layer.Vector.prototype.getFeaturesInExtent = function (extent, tolerance) {
        var self = this;
        var features = this.layer.getSource().getFeatures();
        var featuresInExtent = [];

        if (tolerance) {
            var leftCorner = self.parent.map.getPixelFromCoordinate([extent[0], extent[1]]);
            var rightCorner = self.parent.map.getPixelFromCoordinate([extent[2], extent[3]]);
            leftCorner[0] -= tolerance[0] / 2;
            leftCorner[1] += tolerance[1];
            rightCorner[0] += tolerance[0] / 2;
            extent = self.parent.map.getCoordinateFromPixel(leftCorner).concat(self.parent.map.getCoordinateFromPixel(rightCorner));
        }

        for (var i = 0; i < features.length; i++) {
            var feat = features[i];

            var geometry = feat.getGeometry();
            var coordinate = geometry.getCoordinates();

            if (ol.extent.containsCoordinate(extent, coordinate)) {
                featuresInExtent.push(feat._wrap.parent);
            }
        }

        return featuresInExtent;
    };

    TC.wrap.layer.Vector.prototype.getAttribution = function () {
        return null;
    };

    TC.wrap.control.Click.prototype.register = function (map) {
        var self = this;

        self._trigger = function (e) {
            if (map.view === TC.Consts.view.PRINTING) {
                return;
            }
            var featureCount = 0;
            map.wrap.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        featureCount++;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            if (!featureCount) {
                // GLS: lanzo el evento click, para que los controles que no pueden heredar de click y definir un callback pueda suscribirse al evento
                self.parent.map.trigger(TC.Consts.event.CLICK, {
                    coordinate: e.coordinate, pixel: e.pixel
                });
                self.parent.callback(e.coordinate, e.pixel);
            }
            // Seguimos adelante si no se han pinchado featuers
            return featureCount === 0;
        };
    };

    TC.wrap.control.Click.prototype.activate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.on(SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.Click.prototype.deactivate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.un(SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.ScaleBar.prototype.render = function () {
        var self = this;
        if (!self.ctl) {
            self.ctl = new ol.control.ScaleLine({
                target: self.parent.div
            });
        }
        else {
            self.ctl.updateElement_();
        }
    };

    TC.wrap.control.ScaleBar.prototype.getText = function () {
        var self = this;
        if (self.ctl) {
            return self.ctl.renderedHTML_;
        }
    };

    TC.wrap.control.NavBar.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;
            self.zCtl = new ol.control.Zoom({
                target: div
            });
            // Ponemos para render una función modificada, para evitar que en los pinch zoom haya errores de este tipo:
            // AssertionError: Assertion failed: calculated value (1.002067782531452) ouside allowed range (0-1)

            self.zsCtl = new ol.control.ZoomSlider({
                render: function (e) {
                    if (!e.frameState || !e.frameState.viewState || olMap.getView().getMinResolution() <= e.frameState.viewState.resolution) {
                        // GLS: para evitar que el slider se configure en horizontal
                        var render = function () {
                            if (this.element.offsetWidth > this.element.offsetHeight) {
                                if (!self.requestSliderSize) {
                                    self.requestSliderSize = window.requestAnimationFrame(render.bind(this));
                                }

                                window.requestAnimationFrame(render.bind(this));
                            } else if (this.element.offsetWidth < this.element.offsetHeight) {
                                if (self.requestSliderSize) {
                                    window.cancelAnimationFrame(self.requestSliderSize);
                                    delete self.requestSliderSize;
                                }
                                ol.control.ZoomSlider.render.call(this, e);
                            }
                        };
                        render.call(this);
                    }
                }
            });
            self.zsCtl.setTarget(div);

            olMap.addControl(self.zsCtl);
            olMap.addControl(self.zCtl);

            div.querySelectorAll('button').forEach(function (button) {
                button.classList.add('tc-ctl-btn', self.parent.CLASS + '-btn');
                button.style.display = 'block';
                button.innerHTML = '';
                if (button.matches('.ol-zoom-in')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomin');
                    button.setAttribute('title', self.parent.getLocaleString('zoomIn'));
                }
                if (button.matches('.ol-zoom-out')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomout');
                    button.setAttribute('title', self.parent.getLocaleString('zoomOut'));
                }
            });

            const zoomSlider = div.querySelector('.ol-zoomslider');
            zoomSlider.classList.add(self.parent.CLASS + '-bar');
            zoomSlider.querySelector('.ol-zoomslider-thumb').classList.add(self.parent.CLASS + '-slider');

            map.on(TC.Consts.event.BASELAYERCHANGE, self.refresh.bind(self));
        });
    };

    TC.wrap.control.NavBar.prototype.refresh = function () {
        /*
        var map = this.parent.map;
        var olMap = map.wrap.map;

        olMap.removeControl(self.zsCtl);
        var res = map.getResolutions();
        self.zsCtl = new ol.control.ZoomSlider(
            {
                target: this.parent.div,
                "maxResolution": res[0],
                "minResolution": res[res.length - 1]
            });

        olMap.addControl(self.zsCtl);
        $(map.div).find('.ol-zoomslider').addClass(self.parent.CLASS + '-bar').find('.ol-zoomslider-thumb').addClass(self.parent.CLASS + '-slider');
        */
        var self = this;
        var map = self.parent.map.wrap.map;
        // Puede ser que se llame a refresh antes de que esté inicializado ol.control.ZoomSlider. En ese caso llamamos a render que lo inicializa.
        // Como render necesita un ol.MapEvent, esperamos al evento POSTRENDER.

        self.parent.renderPromise().then(function () {
            if (self.zsCtl.sliderInitialized_) {
                var res = map.getView().getResolution();
                self.zsCtl.setThumbPosition_(res);
            }
            else {
                map.once(POSTRENDER, function (e) {
                    self.zsCtl.render(e);
                });
            }
        });
    };

    TC.wrap.control.NavBarHome.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;

            self.z2eCtl = new ol.control.ZoomToExtent({
                target: div, extent: map.initialExtent, tipLabel: ''
            });

            olMap.addControl(self.z2eCtl);

            div.querySelectorAll('button').forEach(function (button) {
                button.style.display = 'block';
                button.innerHTML = '';
            });
            const homeBtn = div.querySelector('.ol-zoom-extent button');
            homeBtn.classList.add('tc-ctl-btn', self.parent.CLASS + '-btn');
            homeBtn.setAttribute('title', self.parent.getLocaleString('zoomToInitialExtent'));
        });
    };

    TC.wrap.control.NavBarHome.prototype.setInitialExtent = function (extent) {
        this.z2eCtl.extent = extent;
    };

    TC.wrap.control.Coordinates.prototype.register = function (map) {
        const self = this;
        self.map = map;

        return new Promise(function (resolve, reject) {

            self._coordsTrigger = function (e) {
                self.parent.coordsToClick(e);
            };

            map.wrap.getMap().then(function (olMap) {
                self.olMap = olMap;

                if (!self.parent.map.on3DView) {
                    var projection = olMap.getView().getProjection();
                    self.parent.crs = projection.getCode();
                    self.parent.units = projection.getUnits();
                } else {
                    self.parent.crs = self.parent.map.view3D.crs;
                    self.parent.units = TC.Consts.units.DEGREES;
                }

                self.parent.isGeo = self.parent.units === ol.proj.Units.DEGREES;

                //$(olMap.getViewport()).add(self.parent.div);
                resolve();
            });
        });
    };

    TC.wrap.control.Coordinates.prototype.onMouseMove = function (e) {
        var self = this;
        if (self.map.wrap.map) {
            var coords = self.map.wrap.map.getEventCoordinate(e);
            if (coords) {
                if (self.parent.isGeo) {
                    self.parent.latLon = coords.reverse();
                } else {
                    self.parent.xy = coords;
                }

                self.parent.update.apply(self.parent, arguments);
            }
        }
    };

    TC.wrap.control.Geolocation.prototype.register = function (map) {
        var self = this;
        self.map = map;

        self._snapTrigger = function (e) {
            if (e.dragging)
                return;

            self.initSnap(self.olMap.getEventCoordinate(e), e.pixel);
        };

        self._postcomposeTrigger = function (e) {
            self.duringTrackSnap(e);
        };

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    var getTrackingLine = function () {
        var self = this;

        return self.parent.layerTracking.features.filter(function (f) {
            return f instanceof TC.feature.Polyline;
        })[0];
    }

    TC.wrap.control.Geolocation.prototype.hasCoordinates = function () {
        var self = this;

        return self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length >= 1;
    };

    var getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {
            s: Math.floor((diff / 1000) % 60),
            m: Math.floor(((diff / (1000 * 60)) % 60)),
            h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
        };

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };
    TC.wrap.control.Geolocation.prototype.showElevationMarker = function (d) {
        var self = this;

        TC.wrap.control.ResultsPanel.prototype.showElevationMarker.call(self, {
            data: d,
            layer: self.parent.layerTrack,
            coords: self.parent.chart.coordinates
        })
    };

    TC.wrap.control.Geolocation.prototype.hideElevationMarker = function () {
        TC.wrap.control.ResultsPanel.prototype.hideElevationMarker.call(this);
    };

    TC.wrap.control.Geolocation.prototype.addWaypoint = function (position, properties) {
        var self = this;

        var waypoint = new ol.Feature({
            geometry: new ol.geom.Point([position[0], position[1], properties.ele, properties.time], ('XYZM'))
        });
        waypoint.setProperties(properties);

        self.parent.layerTracking.wrap.layer.getSource().addFeature(waypoint);
    };

    TC.wrap.control.Geolocation.prototype.addPosition = function (position, heading, m, speed, accuracy, altitudeAccuracy, altitude) {
        var self = this;

        var x = Math.round(position[0]);
        var y = Math.round(position[1]);

        var line = getTrackingLine.call(this);
        if (self.parent.layerTracking.features && line) {
            var last = line.geometry.length > 0 && line.geometry[line.geometry.length - 1];
            if (last && last.length == 0) {
                self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
            }
            else {
                var lx = Math.round(last[0]);
                var ly = Math.round(last[1]);

                if (x != lx || y != ly) {
                    self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                    line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
                }
            }

            TC.Util.storage.setSessionLocalValue(self.parent.Const.LocalStorageKey.TRACKINGTEMP, self.formattedToStorage(self.parent.layerTracking).features);
        }

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && speed != undefined && speed > 0 && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.positionChangehandler = function (geoposition) {
        const self = this;
        var accuracy, heading, speed, altitude, altitudeAccuracy;

        if (!getTrackingLine.call(this)) {
            self.parent.setTracking(false);
        }

        return new Promise(function (resolve, reject) {
            if (geoposition && geoposition.coords) {
                self.parent.layerGPS.clearFeatures();

                accuracy = (geoposition.coords.accuracy / self.parent.map.getMetersPerUnit()) || 0;
                heading = geoposition.coords.heading || geoposition[2] || 0;
                speed = geoposition.coords.speed ? geoposition.coords.speed * 3.6 : 0;
                altitude = geoposition.coords.altitude || 0;
                altitudeAccuracy = geoposition.coords.altitudeAccuracy || 0;

                if (self.parent.layerTracking) {
                    var position_ = [geoposition.coords && geoposition.coords.longitude || geoposition[0], geoposition.coords && geoposition.coords.latitude || geoposition[1]];
                    var projectedPosition = TC.Util.reproject(position_, 'EPSG:4326', self.parent.map.crs);

                    self.addPosition(projectedPosition, heading, new Date().getTime(), speed, accuracy, altitudeAccuracy, altitude);

                    var coords = getTrackingLine.call(self).geometry;
                    var len = coords.length;
                    if (len >= 2) {
                        self.parent.deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);
                    }

                    self.parent.trigger(self.parent.Const.Event.POSITIONCHANGE, {
                        pd: {
                            "position": projectedPosition,
                            "altitude": altitude,
                            "accuracy": accuracy,
                            "heading": TC.Util.radToDeg(heading),
                            "speed": speed
                        }
                    });

                    Promise.all([self.parent.layerGPS.addPoint(projectedPosition, {
                        radius: 4,
                        fillColor: '#00CED1',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWidth: 2,
                        showsPopup: false
                    }), self.parent.layerGPS.addCircle([projectedPosition, accuracy], {
                        strokeColor: '#00CED1',
                        strokeWidth: 0.4,
                        fillColor: '#ffffff',
                        fillOpacity: 0.2,
                        showsPopup: false
                    })]).then(function (features) {
                        const marker = features[0];
                        const accuracyCircle = features[1];
                        self.parent.geopositionTracking = true;

                        if (self.parent.firstPosition == false) {
                            self.parent.firstPosition = true;

                            if (!self.parent.trackCenterButton) {
                                self.parent.trackCenterButton = self.parent.div.querySelector('.' + self.parent.CLASS + '-track-center');
                                self.parent.trackCenterButton.querySelector('button').addEventListener('click', function () {
                                    self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);

                                    if (!self.parent.track.infoPanel.isVisible()) {
                                        self.parent.track.infoPanel.doVisible();
                                    }

                                    if (self.parent.track.infoPanel.isMinimized()) {
                                        self.parent.track.infoPanel.maximize();
                                    }
                                });

                                var controlContainer = self.parent.map.getControlsByClass('TC.control.ControlContainer')[0];
                                if (controlContainer) {
                                    self.parent.trackCenterButton = controlContainer.addElement({ side: controlContainer.SIDE.LEFT, htmlElement: self.parent.trackCenterButton });
                                } else {
                                    self.parent.map.div.appendChild(self.parent.trackCenterButton);
                                }

                            }
                            self.parent.trackCenterButton.classList.remove(TC.Consts.classes.HIDDEN);

                            self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);
                        }

                        resolve({
                            marker: marker, accuracy: accuracyCircle
                        });
                    });

                } else { resolve(null); }
            } else {
                resolve(null);
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.setTracking = function (tracking) {
        var self = this;

        if (tracking) {
            self.parent.firstPosition = false;
            var sessionwaypoint = [];

            var nativeTrackingFeature;

            if (self.parent.sessionTracking) {

                var JSONParser = new TC.wrap.parser.JSON();
                var features = JSONParser.parser.readFeatures(self.parent.sessionTracking);
                if (features && self.parent.storageCRS !== self.parent.map.crs) {
                    features = features.map(function (feature) {
                        var clone = feature.clone();
                        clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                        return clone;
                    });
                }

                var coordinates = features.filter(function (feature) {
                    var type = feature.getGeometry().getType().toLowerCase();
                    if (type === 'point') { sessionwaypoint.push(feature); }
                    return type === 'linestring' || type === 'multilinestring';
                })[0].getGeometry().getCoordinates();

                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(coordinates, ('XYZM')),
                    tracking: true
                });

            } else {
                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString([], ('XYZM')),
                    tracking: true
                });
            }

            if (nativeTrackingFeature) {

                TC.wrap.Feature.createFeature(nativeTrackingFeature).then(function (tcFeature) {
                    self.parent.layerTracking.addFeature(tcFeature);

                    if (tcFeature.geometry.length > 1) {
                        self.parent.map.zoomToFeatures(self.parent.layerTracking.features);
                    }

                    if (sessionwaypoint.length > 0) {
                        Promise.all(sessionwaypoint.map(function (waypoint) {
                            return TC.wrap.Feature.createFeature(waypoint);
                        })).then(function (features) {
                            if (features) {
                                features.forEach(function (feature) {
                                    self.parent.layerTracking.addFeature(feature);
                                });
                            }
                        });
                    }

                    self.parent.currentPositionWaiting = self.parent.getLoadingIndicator().addWait();

                    if (!self.currentPositionTrk) {
                        self.currentPositionTrk = [];
                    }

                    var getCurrentPositionInterval;
                    var getCurrentPositionRequest = 0;
                    var errorTimeout = 0;
                    var toast = false;
                    var options = {
                        enableHighAccuracy: true, timeout: 600000
                    };

                    function getCurrentPosition(errorCallback) {
                        var id = getCurrentPositionRequest++;
                        navigator.geolocation.getCurrentPosition(
                            function (data) {
                                clearInterval(getCurrentPositionInterval);
                                self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                                self.positionChangehandler(data).then(function (obj) {
                                    if (self.parent.geopositionTracking == true && obj && obj.marker && obj.accuracy) {
                                        self.currentPositionTrk.push(navigator.geolocation.watchPosition(self.positionChangehandler.bind(self), self.parent.onGeolocateError.bind(self.parent), options));
                                    }
                                });
                            },
                            errorCallback ? errorCallback :
                                function (error) {
                                    switch (error.code) {
                                        case error.TIMEOUT:
                                            if (errorTimeout > 10) {
                                                clearInterval(getCurrentPositionInterval);
                                                self.parent.onGeolocateError.call(self.parent, error);
                                            } else {
                                                errorTimeout++;
                                                getCurrentPosition(function () {
                                                    clearInterval(getCurrentPositionInterval);
                                                    if (!toast) {
                                                        toast = true;
                                                        self.parent.onGeolocateError.call(self.parent, error);
                                                    }
                                                });
                                            }
                                            break;
                                        default:
                                            clearInterval(getCurrentPositionInterval);
                                            self.parent.onGeolocateError.call(self.parent, error);
                                    }
                                }, {
                                timeout: 5000 + id,
                                maximumAge: 10,
                                enableHighAccuracy: true
                            }
                        );
                    }
                    getCurrentPositionInterval = setInterval(getCurrentPosition, 1000);

                    setTimeout(function () {
                        if (self.parent.layerTracking && self.parent.layerTracking.features && self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length == 0) {
                            clearInterval(getCurrentPositionInterval);

                            self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                            self.map.toast(self.parent.getLocaleString("geo.error.permission_denied"), {
                                type: TC.Consts.msgType.WARNING
                            });
                            self.parent.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
                            self.parent.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
                        }
                    }, options.timeout + 1000); // Wait extra second

                });
            }
        } else {
            self.parent.firstPosition = false;

            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }

            if (self.parent.trackCenterButton)
                self.parent.trackCenterButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    TC.wrap.control.Geolocation.prototype.activateSnapping = function () {
        var self = this;

        if (!TC.Util.detectMobile()) {
            self.olMap.on([POINTERMOVE, SINGLECLICK], self._snapTrigger);
            self.olMap.on(POSTCOMPOSE, self._postcomposeTrigger);
        }
    };
    TC.wrap.control.Geolocation.prototype.deactivateSnapping = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            if (!TC.Util.detectMobile()) {
                olMap.un([POINTERMOVE, SINGLECLICK], self._snapTrigger);
                olMap.un(POSTCOMPOSE, self._postcomposeTrigger);
            }

            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }

            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }

            if (self.snapLine) {
                delete self.snapLine;
                olMap.render();
            }
        });
    };
    TC.wrap.control.Geolocation.prototype.clear = function (layer) {
        var self = this;

        if (layer) {
            layer.clearFeatures();
        }

        attachedDTD = false;

        self.deactivateSnapping.call(self);
    };
    var vectorCtx;
    TC.wrap.control.Geolocation.prototype.duringTrackSnap = function (e) {
        var self = this;

        var vectorContext = vectorCtx = e.vectorContext;

        if (vectorContext && self.snapLine) {
            if (typeof (vectorContext.setFillStrokeStyle) === 'function')
                vectorContext.setFillStrokeStyle(null, new ol.style.Stroke({
                    color: 'rgba(197, 39, 55, 1)',
                    width: 1
                }));

            if (typeof (vectorContext.drawGeometry) === 'function')
                vectorContext.drawGeometry(self.snapLine.wrap.feature.getGeometry());
        }
    };

    TC.wrap.control.Geolocation.prototype.endSnap = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            /* cartel */
            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }
            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }
            /* línea */
            if (self.snapLine) {
                delete self.snapLine;
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.initSnap = function (coordinate, eventPixel) {
        var self = this;

        if (self.parent.layerTrack) {
            var vectorSource = self.parent.layerTrack.wrap.layer.getSource();
            var closestFeature = vectorSource.getClosestFeatureToCoordinate(coordinate);

            if (closestFeature !== null) {
                var geometry = closestFeature.getGeometry();
                var closestPoint = geometry.getClosestPoint(coordinate);

                const pixel = self.parent.map.getPixelFromCoordinate(closestPoint);
                const distance = Math.sqrt(
                    Math.pow(eventPixel[0] - pixel[0], 2) +
                    Math.pow(eventPixel[1] - pixel[1], 2));

                if (distance > self.parent.snappingTolerance) {
                    self.endSnap();
                } else {
                    var coordinates = [coordinate, [closestPoint[0], closestPoint[1]]];

                    if (!self.snapLine) self.snapLine = new TC.feature.Polyline(coordinates);
                    else self.snapLine.wrap.feature.getGeometry().setCoordinates(coordinates);

                    // información del punto
                    if (!self.snapInfoElement)
                        self.snapInfoElement = document.getElementsByClassName('tc-ctl-geolocation-track-snap-info')[0];

                    self.snapInfoElement.style.display = 'block';

                    if (!self.snapInfo) {
                        self.snapInfo = new ol.Overlay({
                            element: self.snapInfoElement,
                            offset: [5, 18]
                        });

                        self.olMap.addOverlay(self.snapInfo);
                    }

                    if (self.snapInfo.getMap() == undefined)
                        self.snapInfo.setMap(self.olMap);

                    self.snapInfo.setPosition(coordinate);

                    var data = {};
                    if (closestFeature.getGeometry().getType() != "LineString") {
                        if (closestFeature.getKeys().indexOf('name') > -1)
                            data.n = closestFeature.get('name');
                    }

                    var locale = self.parent.map.options.locale && self.parent.map.options.locale.replace('_', '-') || undefined;
                    data.x = self.map.wrap.isGeo() ? closestPoint[0].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[0]).toLocaleString(locale);
                    data.y = self.map.wrap.isGeo() ? closestPoint[1].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[1]).toLocaleString(locale);

                    if (self.map.wrap.isGeo()) {
                        data.isGeo = true;
                    }

                    var getZ = function (position) {
                        return closestPoint[position] ? (Math.round(closestPoint[position] * 100) / 100).toLocaleString(locale) : undefined;
                    };
                    var getM = function (position) {
                        return closestPoint[position] > 0 ? new Date(closestPoint[position]).toLocaleString(locale) : undefined;
                    };

                    if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZM) {
                        data.z = getZ(2);
                        data.m = getM(3);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZ) {
                        data.z = getZ(2);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYM) {
                        data.m = getM(2);
                    }

                    if (data) {
                        self.parent.getRenderedHtml(self.parent.CLASS + '-track-snapping-node', data, function (html) {
                            self.snapInfoElement.innerHTML = html;
                        });
                    }
                }
            }
        }

        self.olMap.render();
    };

    TC.wrap.control.Geolocation.prototype.drawTrackingData = function (track) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const featurePromises = [];

            const JSONParser = new TC.wrap.parser.JSON();
            const features = JSONParser.parser.readFeatures(track.data);

            features.filter(function (feature) {
                return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
            }).forEach(function (feature) {
                feature.getGeometry().setCoordinates(feature.getGeometry().getCoordinates(), track.layout);
            });

            self.activateSnapping.call(self);

            for (var i = 0, len = features.length; i < len; i++) {
                featurePromises.push(TC.wrap.Feature.createFeature(features[i]));
            }

            Promise.all(featurePromises).then(function (feats) {
                feats.forEach(function (feat) {
                    if (feat) {
                        self.parent.layerTrack.addFeature(feat);
                    }
                });
                self.parent.map.zoomToFeatures(self.parent.layerTrack.features);

                resolve();
            });
        });
    };

    TC.wrap.control.Geolocation.prototype.formattedFromStorage = function (storageData) {
        const self = this;

        if (self.parent.storageCRS !== self.parent.map.crs) {
            var features = new ol.format.GeoJSON().readFeatures(storageData);
            if (features) {
                features = features.map(function (feature) {
                    var clone = feature.clone();
                    clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                    return clone;
                });

                return new ol.format.GeoJSON().writeFeatures(features);
            }
        }

        return storageData;
    };
    TC.wrap.control.Geolocation.prototype.formattedToStorage = function (layer, removeTrackingProperty, notReproject) {
        var self = this;

        var parser = new TC.wrap.parser.JSON();
        parser = parser.parser;

        var features = layer.wrap.layer.getSource().getFeatures();
        var layout;

        features = features.map(function (feature) {
            if (feature.getGeometry() instanceof ol.geom.LineString) {
                layout = feature.getGeometry().getLayout();
            }

            if (removeTrackingProperty && feature.getProperties().tracking) {
                feature.unset("tracking");
            }

            if (!notReproject && self.parent.map.crs !== self.parent.storageCRS) {
                var clone = feature.clone();
                clone.getGeometry().transform(self.parent.map.crs, self.parent.storageCRS);

                return clone;
            }

            return feature;
        }).sort(function (a, b) {

            if (a.getGeometry() instanceof ol.geom.Point &&
                !(b.getGeometry() instanceof ol.geom.Point)) {
                return -1;
            }

            if (b.getGeometry() instanceof ol.geom.Point &&
                !(a.getGeometry() instanceof ol.geom.Point)) {
                return 2;
            }

            if (a.getProperties().name < b.getProperties().name) { return -1; }
            if (a.getProperties().name > b.getProperties().name) { return 1; }

            return 0;
        });

        return {
            features: parser.writeFeatures(features), layout: layout
        };
    };

    TC.wrap.control.Geolocation.prototype.export = function (type, li) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var features = [];

            self.parent.getTrackingData(li).then(function (data) {
                if (data) {

                    var olFeatures = new ol.format.GeoJSON().readFeatures(data.data);

                    if (olFeatures.length === 0) {
                        var geoJSON = self.parent.getTrackingData(li);
                        olFeatures = new ol.format.GeoJSON().readFeatures(geoJSON);
                    }

                    features = olFeatures.map(function (feature) {
                        var clone = feature.clone();
                        clone.getGeometry().transform(self.parent.map.crs, 'EPSG:4326');

                        if (!(clone.getGeometry() instanceof ol.geom.LineString)) {
                            return clone;
                        } else {
                            return new ol.Feature({
                                geometry: new ol.geom.MultiLineString([clone.getGeometry().getCoordinates()], ('XYZM'))
                            });
                        }
                    });
                }

                switch (type) {
                    case 'GPX':
                        resolve(features ? new ol.format.GPXCustom().writeFeatures(features) : null);
                        break;
                    case 'KML':
                        resolve(features ? new ol.format.KMLCustom().writeFeatures(features) : null);
                        break;
                }
            });
        });
    };

    var segmentsUnion = function (lineStrings) {
        var mergedIndex = [];
        var coords = [];
        if (lineStrings.length > 1) {

            if (lineStrings[0].length == 4) {
                lineStrings = lineStrings.sort(function (a, b) {
                    if (a[0][3] == b[0][3])
                        return 0;
                    else if (a[0][3] < b[0][3])
                        return -1;
                    else return 1;
                });
            }

            for (var ls = 0; ls < lineStrings.length; ls++) {
                var lineString = lineStrings[ls];
                var nextLineIndex = -1;
                var distance = Infinity;

                var last = lineString.getLastCoordinate();
                for (var nls = ls + 1; nls < lineStrings.length; nls++) {
                    var first = lineStrings[nls].getFirstCoordinate();
                    var d = Math.hypot(last[0] - first[0], last[1] - first[1]);
                    if (d < distance) {
                        nextLineIndex = nls;
                        distance = d;
                    }
                }

                if (mergedIndex.length < lineStrings.length) {
                    if (mergedIndex.indexOf(ls) == -1) {
                        mergedIndex.push(ls);
                        coords = coords.concat(lineString.getCoordinates());
                    }
                    if (mergedIndex.indexOf(nextLineIndex) == -1) {
                        mergedIndex.push(nextLineIndex);
                        coords = coords.concat(lineStrings[nextLineIndex].getCoordinates());
                    }
                }
            }

            //self.map.toast(self.parent.getLocaleString("geo.trk.simulateWarning"), { type: TC.Consts.msgType.WARNING });

            return coords;
        }

        return lineStrings[0].getCoordinates();
    };

    TC.wrap.control.Geolocation.prototype.processImportedFeatures = function (options) {
        var self = this;

        var source = self.parent.layerTrack.wrap.layer.getSource();
        var fileName = self.parent.importedFileName;
        var names = [];
        var toAdd = [];
        var toRemove = [];
        var maybeRemove = [];
        var features = source.getFeatures();

        var segments = [];
        var coord = [];

        var getName = function (feature) {
            if (feature.getProperties().hasOwnProperty("name")) {
                if (feature.getProperties().name.trim().length > 0)
                    names.push(feature.getProperties().name);
                else names.push(fileName);
            }
            else names.push(fileName);
        };

        for (var f = 0; f < features.length; f++) {
            var feature = features[f];

            if (feature instanceof TC.Feature)
                feature = features[f].wrap.feature;

            if (feature.getGeometry() instanceof ol.geom.Point) {
                coord.push(feature.getGeometry().getCoordinates());
                maybeRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.LineString) {
                // GLS: 31/01/2018 Routes (<rte>) are converted into LineString geometries, and tracks (<trk>) into MultiLineString, por tanto, las líneas las cargamos como N Rutas, no las unimos como hasta ahora: // segments.push(feature.getGeometry());                
                getName(feature);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(feature.getGeometry().getCoordinates(), feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.MultiLineString) {
                var clone = feature.clone();
                getName(clone);

                var ls = clone.getGeometry().getLineStrings();

                var coords = segmentsUnion(ls);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(coords, feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
        }

        if (segments.length > 0) {
            var coords = segmentsUnion(segments);
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coords)
            }));
        }

        if (coord.length > 0 && maybeRemove.length == features.length) {
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coord)
            }));
        }

        if (toRemove.length > 0)
            for (var i = 0; i < toRemove.length; i++)
                source.removeFeature(toRemove[i]);

        if (toAdd.length > 0) {
            var sameName = function (array, element) {
                var indices = [];
                var idx = array.indexOf(element);
                while (idx != -1) {
                    indices.push(idx);
                    idx = array.indexOf(element, idx + 1);

                    if (indices.length > 1)
                        return true;
                }

                return indices.length > 1 ? true : false;
            };

            var featureToAdd;
            var index = 0;
            var processAdd = function () {
                const promises = toAdd.map(function (ta, idx) {
                    return new Promise(function (resolve, reject) {
                        if (featureToAdd) {
                            source.removeFeature(featureToAdd);
                        }

                        var name;
                        if (names.length > idx) {
                            var name = names[idx];
                            if (sameName(names, name))
                                name = '[' + (idx + 1) + ']' + ' ' + name;
                        }

                        self.parent.importedFileName = name ? name : fileName;

                        featureToAdd = toAdd[idx];
                        source.addFeature(featureToAdd);

                        self.parent.saveTrack({
                            message: self.parent.getLocaleString('geo.trk.upload.ok', { trackName: name ? name : fileName }),
                            importedFileName: name ? name : fileName,
                            notReproject: options.notReproject
                        }).then(function (importedIndex) {
                            if (idx == 0) {
                                index = importedIndex;
                            }
                            resolve();
                        });
                    });
                });
                return Promise.all(promises);
            };
            processAdd().then(function () {

                self.parent.layerTrack.setVisibility(false);
                self.parent.layerTrack.clearFeatures();

                self.parent.trigger(self.parent.Const.Event.IMPORTEDTRACK, { index: index });

                delete self.parent.importedFileName;
                self.parent.getLoadingIndicator().removeWait(options.wait);
            });
        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(options.wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    TC.wrap.control.Geolocation.prototype.import = function (wait, data, type) {
        var self = this;
        var vectorSource;
        var listenerKey;

        if (data && data.text) {

            var layerOptions = self.parent.layerTrack.wrap.createVectorSource({
                data: data.text,
                type: type
            });
            vectorSource = layerOptions.source;

            listenerKey = vectorSource.on('change', function (e) {
                if (vectorSource.getState() == 'ready') {
                    ol.Observable.unByKey(listenerKey);
                    self.processImportedFeatures(wait);
                }
            });

            var olLayer = self.parent.layerTrack.wrap.layer;
            olLayer.setSource(vectorSource);

        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    var idRequestAnimationFrame;
    TC.wrap.control.Geolocation.prototype.simulateTrackEnd = function () {
        var self = this;

        self.parent.chartProgressClear();

        if (self.simulateMarker) {
            window.cancelAnimationFrame(idRequestAnimationFrame);
            if (self.simulateMarker.layer.wrap.layer.getSource().getFeatures().length > 0)
                self.simulateMarker.layer.removeFeature(self.simulateMarker);

            delete self.simulateMarker;
        }
    };

    TC.wrap.control.Geolocation.prototype.simulateTrack = function () {
        var self = this;

        var coordinates;
        var features = self.parent.layerTrack.wrap.layer.getSource().getFeatures();
        for (var ls = 0; ls < features.length; ls++) {
            if (features[ls].getGeometry() instanceof ol.geom.LineString) {
                coordinates = features[ls].getGeometry().getCoordinates();
                break;
            }
        }

        if (coordinates && coordinates.length > 0) {
            var first = coordinates[0];

            var setSimulateMarker = function () {
                return new Promise(function (resolve, reject) {
                    if (!self.simulateMarker) {
                        self.parent.layerTrack.addPoint(first.slice(0, 2), {
                            radius: 7,
                            fillColor: '#ff0000',
                            fillOpacity: 0.5,
                            strokeColor: '#ffffff',
                            strokeWidth: 2
                        }).then(function (f) {
                            resolve(f);
                        });
                    } else {
                        self.simulateMarker.setCoords(first.slice(0, 2));
                        resolve(self.simulateMarker);
                    }
                });
            };
            setSimulateMarker().then(function (f) {
                self.simulateMarker = f;

                var animationFrameFraction = function () {
                    var trackLength = coordinates.length;
                    var start, finish;
                    var duration;
                    var fraction;
                    var hasTime = false;

                    const toLength = function (coords) {
                        if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                            return TC.Util.reproject(coords, self.parent.map.crs, self.parent.map.options.utmCrs);
                        }

                        return coords;
                    };

                    var arCoordinates = coordinates;
                    if (arCoordinates[0].length == 4 && arCoordinates[0][3] > 0) {
                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                        hasTime = true;
                    } else {
                        arCoordinates[0][3] = Date.now();

                        for (var i = 1; i < arCoordinates.length; i++) {
                            var done;
                            arCoordinates[i][3] = 0;

                            if (i + 1 < arCoordinates.length) {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1, i + 1))).getLength();
                            } else {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1))).getLength();
                            }

                            arCoordinates[i][3] = arCoordinates[i - 1][3] + (3600000 * done / self.parent.walkingSpeed);
                        }

                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                    }

                    var trackFilm = new ol.geom.LineString(arCoordinates);
                    var timestamp = start;
                    var distance = 0;

                    if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                        distance = new ol.geom.LineString(toLength(JSON.parse(JSON.stringify(arCoordinates)))).getLength();
                    } else {
                        distance = trackFilm.getLength();
                    }

                    var done = 0;
                    var getDoneAtM = function (m) {
                        for (var i = 0; i < arCoordinates.length; i++) {
                            if (arCoordinates[i][3] > m)
                                return {
                                    d: new ol.geom.LineString(toLength(arCoordinates.slice(0, i))).getLength(),
                                    p: arCoordinates[i - 1].slice(0, 2)
                                };
                        }
                    };

                    var loopAtFraction = function () {

                        if (!self.parent.simulate_paused) {
                            var position = trackFilm.getCoordinateAtM(timestamp);
                            var d = getDoneAtM(timestamp);

                            if (fraction >= 1 || !position || !d) {
                                self.simulateTrackEnd();
                                var li = self.parent.getSelectedTrack();
                                if (li)
                                    self.parent.uiSimulate(false, li);

                                if (self.parent.hasElevation) {
                                    self.parent.chartProgressClear();
                                }

                                return;
                            } else {

                                if (self.parent.hasElevation) {
                                    self.parent.chartSetProgress(d, position, distance, (hasTime ? self.parent._getTime(arCoordinates[0][3], position[3]) : false));
                                }

                                if (self.simulateMarker) {
                                    var from = self.simulateMarker.getCoords();
                                    var to = position;
                                    var rotation = Math.atan2(to[1] - from[1], to[0] - from[0]) * 180 / Math.PI;

                                    self.simulateMarker.setCoords(position);
                                    //self.simulateMarker.setStyle({ angle: rotation });
                                }

                                if (self.parent.simulate_speed !== 1)
                                    timestamp = timestamp + (self.parent.delta * self.parent.simulate_speed);
                                else
                                    timestamp = timestamp + self.parent.delta;
                            }
                        }

                        idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);
                    };
                    idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);

                };

                const hasD3 = new Promise(function (resolve, reject) {
                    if (window.d3) {
                        resolve();
                    }
                    else {
                        TC.loadJS(!window.d3, [TC.Consts.url.D3C3], function () {
                            resolve();
                        });
                    }
                });
                hasD3.then(function () {
                    idRequestAnimationFrame = requestAnimationFrame(animationFrameFraction);
                });
            });
        }
    };

    TC.wrap.control.Geolocation.prototype.headingChangehandler = function (evt) {
        var self = this;
        if (!self.parent.track.infoOnMap) {
            self.parent.track.infoOnMap = document.createElement('div');
            const iomStyle = self.parent.track.infoOnMap.style;
            iomStyle.overFlowY = 'scroll';
            iomStyle.height = '200px';
            iomStyle.width = '200px';
            iomStyle.top = '0';
            iomStyle.left = '100px';
            iomStyle.backgroundColor = 'fuchsia';
            iomStyle.position = 'absolute';
            self.parent.map.div.appendChild(self.parent.track.infoOnMap);
        }

        self.parent.track.infoOnMap.style.display = '';

        self.heading = evt.target.getHeading();

        self.parent.track.infoOnMap.innerHTML = self.parent.track.infoOnMap.innerHTML +
            '<br> <p> salta headingChangehandler </p> <br> <p> evt.target.getHeading(): ' + self.heading + ' </p>';



        self.map.wrap.getMap().then(function (map) {
            map.getView().setRotation(-self.heading);
        });

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.orientationChangehandler = function (event) {
        var self = this;

        var view = self.map.wrap.map.getView();
        var center = view.getCenter();
        var resolution = view.getResolution();
        var beta = event.target.getBeta() || 0;
        var gamma = event.target.getGamma() || 0;

        center[0] -= resolution * gamma * 25;
        center[1] += resolution * beta * 25;

        view.setCenter(view.constrainCenter(center));

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.pulsate = function (circle) {
        var self = this;

        self.pulsated = true;

        var radius = circle.wrap.feature.getGeometry().getRadius();
        var start = new Date().getTime();

        var duration = 500;
        var listenerKey;

        var getRadius = function (elapsed) {
            switch (true) {
                case elapsed <= 50:
                    return radius;
                case elapsed > 50 && elapsed <= 100:
                    return radius * 1.02;
                case elapsed > 100 && elapsed <= 150:
                    return radius * 1.05;
                case elapsed > 150 && elapsed <= 200:
                    return radius * 1.02;
                case elapsed > 200 && elapsed <= 300:
                    return radius;
                case elapsed > 300 && elapsed <= 350:
                    return radius * 1.02;
                case elapsed > 350 && elapsed <= 400:
                    return radius * 1.05;
                case elapsed > 400 && elapsed <= 450:
                    return radius * 1.02;
                case elapsed > 450 && elapsed <= 500:
                    return radius * 1;
                default:
                    return radius;
            }
        };
        listenerKey = self.olMap.on(POSTCOMPOSE, function (event) {
            var vectorContext = event.vectorContext;
            var frameState = event.frameState;

            var elapsed = frameState.time - start;

            var f = circle.wrap.feature.getGeometry().clone();
            var r = getRadius(elapsed);
            f.setRadius(r);

            vectorContext.setFillStrokeStyle(
                new ol.style.Fill({
                    color: 'rgba(0, 0, 0, 0.1)'
                }),
                new ol.style.Stroke({
                    color: 'rgba(255, 0, 0, .8)', width: 1
                })
            );
            vectorContext.drawCircleGeometry(f);

            if (elapsed > duration) {
                ol.Observable.unByKey(listenerKey);
                return;
            }

            frameState.animate = true;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.register = function (map) {
        const self = this;
        self.map = map;

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.showElevationMarker = function (options) {
        const self = this;
        options = options || {};
        const data = options.data;
        const layer = options.layer;
        const coords = options.coords;

        if (!self.elevationMarker) {
            const elm = document.createElement('div');
            elm.style.display = 'none';
            elm.classList.add('tc-ctl-geolocation-trackMarker', 'elevation');
            self.elevationMarker = new ol.Overlay({
                element: elm,
                offset: [0, -11],
                positioning: ol.OverlayPositioning.CENTER_CENTER,
                stopEvent: false
            });
        }

        // GLS: si la capa del track está visible mostramos marcamos punto del gráfico en el mapa
        if (layer.getVisibility() && layer.getOpacity() > 0) {
            self.elevationMarker.getElement().style.display = '';
            self.olMap.addOverlay(self.elevationMarker);
            self.elevationMarker.setPosition(coords[data[0].index]);
        }

        // No centrar en el marker
        //var extent = self.map.getExtent();
        //var p = coords[data[0].index];
        //if (p[0] >= extent[0] && p[0] <= extent[2] && p[1] >= extent[1] && p[1] <= extent[3]) { }
        //else {
        //    self.map.setCenter(p.slice(0, 2), { animate: true });
        //}
    };

    TC.wrap.control.ResultsPanel.prototype.hideElevationMarker = function () {
        if (this.elevationMarker) {
            this.elevationMarker.getElement().style.display = 'none';
        }
    };

    TC.wrap.control.Coordinates.prototype.coordsActivate = function () {
        var self = this;

        self.olMap.on(SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.control.Coordinates.prototype.coordsDeactivate = function () {
        var self = this;

        self.olMap.un(SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.Parser = function () {
    };

    TC.wrap.Parser.prototype.read = function (data) {
        var result = [];
        var self = this;
        if (self.parser) {
            if (!TC.Feature) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
            }
            result = self.parser.readFeatures(data).map(function (feat) {
                return new TC.Feature(null, {
                    id: feat.getId(), data: feat.getProperties()
                });
            });
        }
        return result;
    };

    TC.wrap.parser = {
        WFS: function (options) {
            this.parser = new ol.format.WFS(options);
        },
        JSON: function (options) {
            this.parser = new ol.format.GeoJSON(options);
        }
    };
    TC.inherit(TC.wrap.parser.WFS, TC.wrap.Parser);
    TC.inherit(TC.wrap.parser.JSON, TC.wrap.Parser);

    TC.wrap.control.OverviewMap.prototype.register = function (map) {
        var self = this;

        self.parent.layer.wrap.getLayer().then(function (olLayer) {
            self.ovMap = new ol.control.OverviewMap({
                target: self.parent.div,
                collapsed: false,
                collapsible: false,
                className: self.parent.CLASS + ' ol-overviewmap',
                layers: [olLayer]
            });
            self.ovMap._wrap = self;

            /* 08/02/2019 GLS: 
                Establecemos el pixelRatio siempre a uno (aunque el control instancie un olMap internamente no admite el paso de la opción pixelRatio,
                imposible de entender, por eso lo hago directamente), porque OL sólo atiende al valor al principio,
                si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso, click se sitúa mal,
                popup se sitúa entre otros efectos.
                Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                    Bug 25976:Mapa situación en blanco
                    Bug 25954:Canvas en blanco con zoom mayor al 100%
                    Bug 23855:Mapa de situación se muestra en blanco
            */
            self.ovMap.getOverviewMap().pixelRatio_ = 1;

            // Quitamos el drag&drop añadido en OL 4.1.0 machacando el overlay
            self.ovMap.ovmap_.removeOverlay(self.ovMap.boxOverlay_);
            var box = document.createElement('DIV');
            box.className = 'ol-overviewmap-box';
            box.style.boxSizing = 'border-box';
            self.ovMap.boxOverlay_ = new ol.Overlay({
                position: [0, 0],
                positioning: ol.OverlayPositioning.BOTTOM_LEFT,
                element: box
            });
            self.ovMap.ovmap_.addOverlay(self.ovMap.boxOverlay_);

            // mantenemos el ancho y alto del canvas en números enteros
            self.manageSize.call(self.ovMap.ovmap_);

            self._boxElm = self.ovMap.boxOverlay_.getElement();

            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    var ovmMap = self.ovMap.ovmap_;
                    const drag = new Draggabilly(self._boxElm);
                    // Parcheamos Draggabilly para que respete las otras transformaciones, por ejemplo rotación.
                    drag.positionDrag = function () {
                        const style = this.element.style;
                        const newTransform = 'translate3d( ' + this.dragPoint.x +
                            'px, ' + this.dragPoint.y + 'px, 0)';
                        if (style.transform.length) {
                            const idxStart = style.transform.indexOf('translate3d');
                            if (idxStart >= 0) {
                                const idxEnd = style.transform.indexOf(')', idxStart);
                                style.transform = style.transform.replace(style.transform.substring(idxStart, idxEnd + 1), newTransform);
                            }
                            else {
                                style.transform = newTransform + ' ' + style.transform;
                            }
                        }
                        else {
                            style.transform = newTransform;
                        }
                    };
                    drag.on('pointerDown', function (e) {
                        drag.dragged = self._boxElm.cloneNode();
                        drag.dragged.classList.add(TC.Consts.classes.ACTIVE);
                        drag.dragged.style.position = 'absolute';
                        self._boxElm.insertAdjacentElement('beforebegin', drag.dragged);
                        if (map.maxExtent) {
                            var bottomLeft = ovmMap.getPixelFromCoordinate([map.maxExtent[0], map.maxExtent[1]]);
                            var topRight = ovmMap.getPixelFromCoordinate([map.maxExtent[2], map.maxExtent[3]]);
                            var mapSize = ovmMap.getSize();
                            const container = document.createElement('div');
                            container.style.position = 'absolute';
                            container.style.bottom = Math.round(mapSize[1] - bottomLeft[1]) + 'px';
                            container.style.left = Math.round(bottomLeft[0]) + 'px';
                            container.style.top = Math.round(topRight[1]) + 'px';
                            container.style.right = Math.round(mapSize[0] - topRight[0]) + 'px';
                            const viewport = ovmMap.getViewport();
                            viewport.insertBefore(container, viewport.firstElementChild);
                            drag.options.containment = container;
                        }
                    });
                    drag.on('pointerUp', function (e) {
                        drag.dragged.parentElement.removeChild(drag.dragged);
                        if (map.maxExtent) {
                            ovmMap.getViewport().removeChild(drag.options.containment);
                            drag.options.containment = null;
                        }
                    });
                    drag.on('dragMove', function (e, pointer, moveVector) {
                        drag._delta = moveVector;
                    });
                    drag.on('dragEnd', function (e, pointer) {
                        var olMap = self.ovMap.getMap();
                        var view = olMap.getView();
                        var centerPixel = ovmMap.getPixelFromCoordinate(view.getCenter());
                        var newCenter = ovmMap.getCoordinateFromPixel([centerPixel[0] + drag._delta.x, centerPixel[1] + drag._delta.y]);
                        var extent = map.getExtent();
                        var halfWidth = (extent[2] - extent[0]) / 2;
                        var halfHeight = (extent[3] - extent[1]) / 2;

                        if (newCenter[0] + halfWidth > map.maxExtent[2]) {
                            newCenter[0] = map.maxExtent[2] - halfWidth;
                        }
                        else if (newCenter[0] - halfWidth < map.maxExtent[0]) {
                            newCenter[0] = map.maxExtent[0] + halfWidth;
                        }
                        if (newCenter[1] + halfHeight > map.maxExtent[3]) {
                            newCenter[1] = map.maxExtent[3] - halfHeight;
                        }
                        else if (newCenter[1] - halfHeight < map.maxExtent[1]) {
                            newCenter[1] = map.maxExtent[1] + halfHeight;
                        }

                        drag.setPosition(0, 0);
                        delete drag._delta;
                        map.setCenter(newCenter, { animate: true });
                    });
                });

            map.wrap.getMap().then(function (olMap) {

                // Modificamos mapa para que tenga la proyección correcta
                self.reset();

                const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.HIDDEN);
                    load.classList.add(TC.Consts.classes.VISIBLE);
                });
                olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.VISIBLE);
                    load.classList.add(TC.Consts.classes.HIDDEN);
                });

                olMap.addControl(self.ovMap);

                self.parent.isLoaded = true;
                self.parent.trigger(TC.Consts.event.MAPLOAD);
            });
        });
    };

    TC.wrap.control.OverviewMap.prototype.reset = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const setLayer = function (layer, crs) {
                if (layer.type === TC.Consts.layerType.WMTS) {
                    var layerProjectionOptions = { crs: crs || self.parent.map.crs, oldCrs: layer.wrap.layer.getSource().getProjection().getCode() }; // , allowFallbackLayer: true

                    if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                        layer.setProjection(layerProjectionOptions);
                    }
                }

                layer.wrap.getLayer().then(function (olLayer) {

                    var olView = new ol.View(getResolutionOptions(self.parent.map.wrap, olLayer._wrap.parent));

                    if (olView.getResolutions()) {
                        olView.setResolution(olView.getResolutions().filter(function (res) {
                            return res > olView.getResolutionForExtent(self.parent.map.getExtent(), olMap.getSize())
                        }).reverse()[0]);

                        olMap.setView(olView);
                    } else if (olView.getProjection().getCode() !== olMap.getView().getProjection().getCode()) {
                        olMap.setView(olView);
                    }

                    // para controlar el mapa en blanco en IE en la carga inicial
                    olLayer._wrap.$events.one(TC.Consts.event.TILELOAD, function () {
                        olMap.getLayers().getArray()[0].getSource().refresh();
                    });

                    if (layer !== self.parent.layer || olMap.getLayers().getArray().indexOf(layer) === -1) {

                        self.parent.map.trigger(TC.Consts.event.OVERVIEWBASELAYERCHANGE, { oldLayer: layer !== self.parent.layer ? self.parent.layer : null, newLayer: layer });
                        olMap.getLayers().forEach(function (l) {
                            if (l instanceof ol.layer.Image || l instanceof ol.layer.Tile) {
                                olMap.removeLayer(l);
                            }
                        });

                        const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                        olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.HIDDEN);
                            load.classList.add(TC.Consts.classes.VISIBLE);
                        });
                        olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.VISIBLE);
                            load.classList.add(TC.Consts.classes.HIDDEN);
                        });

                        olMap.getLayers().insertAt(0, olLayer); // GLS: no usamos .addLayer(olLayer) para asegurar que la capa a añadir quede como fondo.
                    }

                    resolve(layer);
                });
            };

            options = options || {};
            var layer = options.layer || self.parent.layer;
            if (self.parent.map && layer && self.ovMap) {
                var olMap = self.ovMap.ovmap_;

                layer.getCapabilitiesPromise().then(function () {

                    var originalLayer = layer;

                    if (!layer.isCompatible(self.parent.map.crs) && layer.wrap.getCompatibleMatrixSets(self.parent.map.crs).length === 0) {
                        layer = layer.getFallbackLayer() || self.parent.defaultLayer;

                        layer.getCapabilitiesPromise().then(function () {
                            if (self.parent.map.on3DView && !layer.isCompatible(self.parent.map.crs)) {
                                self.parent.map.loadProjections({
                                    crsList: originalLayer.getCompatibleCRS(),
                                    orderBy: 'name'
                                }).then(function (projList) {
                                    setLayer(originalLayer, projList[0].code);
                                });
                            } else if (layer.isCompatible(self.parent.map.crs)) {
                                setLayer(layer);
                            }
                        });
                    } else {
                        setLayer(layer);
                    }
                });
            }
        });
    };

    TC.wrap.control.OverviewMap.prototype.get3DCameraLayer = function () {
        var self = this;
        var result = null;
        var camLayerId = '3DCamera';
        var ovMap;

        if (self.ovMap) {
            ovMap = self.ovMap.getOverviewMap();
            ovMap.getLayers().forEach(function (elm) {
                if (elm.get('id') === camLayerId) {
                    result = elm;
                }
            });

            if (!result) {
                var ovMap = self.ovMap.getOverviewMap();
                var fovStyle = createNativeStyle({});
                // Ponemos los cuadriláteros de fov sin relleno (por legibilidad)
                fovStyle[0].getFill().setColor([0, 0, 0, 0]);
                result = new ol.layer.Vector({
                    id: camLayerId,
                    source: new ol.source.Vector(),
                    style: fovStyle
                });
                ovMap.addLayer(result);
            }
        }
        return result;
    };

    TC.wrap.control.OverviewMap.prototype.draw3DCamera = function (options) {
        var self = this;

        if (this.parent.map.isLoaded) {
            self.is3D = !!options;
            var camLayer = self.get3DCameraLayer();
            if (camLayer) {
                var feature;
                options = options || {
                };
                var fov = options.fov;
                var source = camLayer.getSource();
                if (!fov || !fov.length) { // no vemos terreno o no estamos en vista 3D
                    source.clear();
                }
                else {
                    var features = source.getFeatures();
                    if (!features.length) {
                        feature = new ol.Feature();
                        source.addFeature(feature);
                    }
                    else {
                        feature = features[0];
                    }
                    feature.setGeometry(new ol.geom.Polygon([fov]));
                }
                var heading = (typeof options.heading === 'number') ? options.heading : 0;
                self._boxElm.style.transform = 'rotate(' + heading + 'rad)';
            }
        }
    };

    TC.wrap.control.OverviewMap.prototype.enable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(true);

            /* GLS: bug 23855: mapa de situación se muestra en blanco
                En el resize se valida el alto y el ancho y como el div padre (id = "ovmap") tiene display: none, 
                el ancho y el alto devuelven cero y por ello se muestra en blanco. 
                No vale con lanzar .trigger('resize') porque no utiliza los valores actuales del div, 
                sino los almacenados, por eso llamamos a updateSize que actualiza dichos valores.
                https://tfsapp.tracasa.es:8088/tfs/web/wi.aspx?pcguid=4819cc6e-400e-4f70-ba7c-c18a830405aa&id=23855                
            */
            self.parent.wrap.ovMap.ovmap_.updateSize();

            // Lo siguiente es para actualizar mapa de situación
            const resizeEvent = document.createEvent('HTMLEvents');
            resizeEvent.initEvent('resize', false, false);
            self.parent.map.div.dispatchEvent(resizeEvent);
        }
    };

    TC.wrap.control.OverviewMap.prototype.disable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(false);
        }
    };

    TC.wrap.control.OverviewMap.prototype.manageSize = function () {
        const self = this;

        TC.wrap.Map.prototype.manageSize.call(self);
    };

    TC.wrap.control.FeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                var result = _clickTrigger.call(self, e);
                if (result) {
                    self.parent.beforeRequest({ xy: e.pixel });
                }
                else {
                    map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self.parent });
                }
                return result;
            }
        });
    };

    var bufferElm;
    var getElementText = function (elm) {
        var text = elm.innerHTML || elm.textContent;
        bufferElm = bufferElm || document.createElement("textarea");
        bufferElm.innerHTML = text;
        return bufferElm.value;
    };

    var esriXmlParser = {
        readFeatures: function (text) {
            var result = [];
            var dom = (new DOMParser()).parseFromString(text, 'text/xml');
            if (dom.documentElement.tagName === 'FeatureInfoResponse') {
                var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
                for (var i = 0, len = fiCollections.length; i < len; i++) {
                    var fic = fiCollections[i];
                    var layerName = fic.getAttribute('layername');
                    var fInfos = fic.getElementsByTagName('FeatureInfo');
                    for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                        var fields = fInfos[j].getElementsByTagName('Field');
                        var attributes = {
                        };
                        for (var k = 0, lenk = fields.length; k < lenk; k++) {
                            var field = fields[k];
                            attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                        }
                        var feature = new ol.Feature(attributes);
                        feature.setId(layerName + '.' + TC.getUID());
                        result[result.length] = feature;
                    }
                }
            }
            return result;
        }
    };

    var addLayerToService = function (service, layer, name) {
        var path = layer.getPath(name);
        service.layers.push({
            name: name,
            title: path[path.length - 1],
            path: path.slice(1),
            features: []
        });
    };

    TC.wrap.control.FeatureInfo.prototype.getFeatureInfo = function (coords, resolution, options) {
        var self = this;
        var opts = options || {};
        var map = self.parent.map;
        map.wrap.getMap().then(function (olMap) {
            var targetServices = {};
            var auxInfo = {};
            const requestPromises = [];
            const requestDataArray = [];
            var featurePromises = [];
            var services = [];

            //var infoFormats = [];
            var layers = olMap.getLayers().getArray();

            // GLS: filtro el array de capas para quedarnos con las capas que son raster y visibles.
            layers = layers.filter(function (elem) { return elem instanceof ol.layer.Image && elem.getVisible(); });

            for (var j = 0; j < layers.length; j++) {
                var olLayer = layers[j];
                var layer = olLayer._wrap.parent;
                var source = olLayer.getSource();

                //console.log("Source: " + layer.layerNames.join(","));
                //Por qué en workLayers están el vectorial de medición, y cosas así?
                if (source.getGetFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0 && layer.names.length > 0
                    && (!opts.serviceUrl || opts.serviceUrl === layer.url)) { // Mirar si en las opciones pone que solo busque en un servicio

                    //
                    var targetService;
                    if (!targetServices[layer.url]) {
                        targetService = {
                            layers: [],
                            mapLayers: [],
                            title: layer.title,
                            request: null
                        };
                        targetServices[layer.url] = targetService;
                        auxInfo[layer.url] = {
                            source: TC.Util.extend(true, {}, source),
                            layers: []
                        };
                    }
                    else {
                        targetService = targetServices[layer.url];
                        auxInfo[layer.url].source.updateParams(TC.Util.extend(auxInfo[layer.url].source.getParams(), source.getParams()));
                    }
                    targetService.mapLayers.push(layer);

                    //var targetService = {
                    //    layers: [], mapLayers: [layer]
                    //};
                    var disgregatedNames = layer.getDisgregatedLayerNames();
                    if (opts.layerName) { // Mirar si en las opciones pone que solo busque en una capa
                        if (disgregatedNames.indexOf(opts.layerName) >= 0 && olLayer._wrap.getInfo(opts.layerName).queryable) {
                            addLayerToService(targetService, layer, opts.layerName);
                            auxInfo[layer.url].layers.push(opts.layerName);
                        }
                    }
                    else {
                        for (var i = 0; i < disgregatedNames.length; i++) {
                            var name = disgregatedNames[i];
                            if (olLayer._wrap.getInfo(name).queryable) {
                                addLayerToService(targetService, layer, name);
                            }
                            else {
                                TC.Util.consoleRegister('Capa "' + disgregatedNames[i] + '" no queryable, la eliminamos de la petición GFI');
                                disgregatedNames.splice(i, 1);
                                i = i - 1;
                            }
                        }

                        // GLS: validamos si nos queda alguna capa a la cual consultar
                        if (disgregatedNames.length > 0) {
                            auxInfo[layer.url].layers = auxInfo[layer.url].layers.concat(disgregatedNames);
                        }
                    }
                }
            }

            for (var serviceUrl in targetServices) {
                services.push(targetServices[serviceUrl]);
                var targetService = targetServices[serviceUrl];
                var source = auxInfo[serviceUrl].source;
                var layers = auxInfo[serviceUrl].layers;

                // GLS: validamos si hay capas a las cuales consultar, si no hay continuamos con el siguiente servicio
                if (!layers || (layers && layers.length === 0)) {
                    continue;
                }

                var params = source.getParams();
                source.params_.LAYERS = layers.join(',');
                var gfiURL = source.getGetFeatureInfoUrl(coords, resolution, map.crs, {
                    'QUERY_LAYERS': layers.join(','),
                    'INFO_FORMAT': params.INFO_FORMAT,
                    'FEATURE_COUNT': 1000,
                    'radius': map.options.pixelTolerance,
                    'buffer': map.options.pixelTolerance
                });

                gfiURL = gfiURL.replace(/sld_body=[a-zA-Z%0-9._]*/); // Quitamos el parámetro sld_body


                var expUrl = gfiURL;
                const requestData = {
                    serviceUrl: serviceUrl,
                    requestedFormat: params.INFO_FORMAT,
                    expandUrl: expUrl
                };
                requestDataArray.push(requestData);
                requestPromises.push(new Promise(function (resolve, reject) {
                    const mapLayer = targetService.mapLayers[0];
                    mapLayer.toolProxification.fetch(gfiURL)
                        .then(function (data) {
                            mapLayer.toolProxification.cacheHost.getAction(requestData.expandUrl).then(function (cache) {
                                requestData.originalUrl = cache.action.call(mapLayer.toolProxification, requestData.expandUrl);
                                resolve(TC.Util.extend({}, data, requestData));
                            });
                        })
                        .catch(function (error) {
                            reject(Error(error));
                        });
                }));
                TC.Util.consoleRegister("Lanzamos GFI");
            }

            if (requestPromises.length > 0) {
                Promise.all(requestPromises).then(function (responses) {
                    var someSuccess = false;
                    var featureCount = 0;
                    var featureInsertionPoints = [];
                    for (var i = 0; i < responses.length; i++) {
                        var featureInfo = responses[i];
                        var service = targetServices[requestDataArray[i].serviceUrl];
                        someSuccess = true;
                        service.text = featureInfo.responseText;
                        var format;
                        var iFormat = featureInfo.contentType;
                        if (iFormat && iFormat.indexOf(";") > -1)
                            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

                        if (!iFormat) iFormat = featureInfo.requestedFormat;

                        if (iFormat === featureInfo.requestedFormat) {
                            switch (iFormat) {
                                case 'application/json':
                                    format = new ol.format.GeoJSON();
                                    break;
                                case 'application/vnd.ogc.gml':
                                    if (featureInfo.responseText.indexOf("FeatureCollection") > -1) {
                                        format = new ol.format.WFS({
                                            gmlFormat: new ol.format.GML2({
                                                srsName: map.crs
                                            })
                                        });
                                    }
                                    else {
                                        format = new ol.format.WMSGetFeatureInfo();
                                    }
                                    break;
                                case 'application/vnd.ogc.gml/3.1.1':
                                    format = new ol.format.GML3({
                                        srsName: map.crs
                                    });
                                    break;
                                case 'application/vnd.esri.wms_featureinfo_xml':
                                    format = esriXmlParser;
                                    break;
                                default:
                                    format = null;
                                    break;
                            }

                            if (format) {
                                var features;
                                try {
                                    features = format.readFeatures(featureInfo.responseText, {
                                        featureProjection: ol.proj.get(map.crs)
                                    });
                                }
                                catch (e) {
                                    TC.error(self.parent.getLocaleString('featureInfo.error.badResponse', { url: featureInfo.serviceUrl }) + ': ' + e.message);
                                    features = [];
                                    continue;
                                };
                                featureCount = featureCount + features.length;
                                var isParentOrSame = function (layer, na, nb) {
                                    var result = false;
                                    if (na === nb) {
                                        result = true;
                                    }
                                    else {
                                        var pa = layer.getNodePath(na);
                                        var pb = layer.getNodePath(nb);
                                        if (pa.length > 0 && pb.length >= pa.length) {
                                            result = true;
                                            for (var i = 0; i < pa.length; i++) {
                                                if (layer.wrap.getName(pa[i]) !== layer.wrap.getName(pb[i])) {
                                                    result = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    return result;
                                };

                                var fakeLayers = {
                                };

                                for (var j = 0; j < features.length; j++) {
                                    var feature = features[j];
                                    if (feature instanceof ol.Feature) {
                                        var fid = feature.getId() || TC.getUID();
                                        var found = false;
                                        var layerName = fid.substr(0, fid.lastIndexOf('.'));
                                        for (var k = 0; k < service.layers.length; k++) {
                                            var l = service.layers[k];
                                            var lName = l.name.substr(l.name.indexOf(':') + 1);
                                            if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                                                found = true;
                                                if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                    featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                    featureInsertionPoints.push(l.features);
                                                }
                                                break;
                                            }
                                        }

                                        //si llegamos aquí y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                                        //esto pasa, p.ej, en cartociudad
                                        if (!found) {
                                            //así que creo un layer de palo para la respuesta del featInfo
                                            var fakeLayer;
                                            if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                                            else {
                                                fakeLayer = {
                                                    name: layerName, title: layerName, path: [layerName], features: []
                                                };
                                                fakeLayers[layerName] = fakeLayer;
                                                service.layers.push(fakeLayer);
                                            }

                                            if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                featureInsertionPoints.push(fakeLayer.features);
                                            }
                                        }
                                    }
                                }//iteración sobre las features de esta respuesta


                            }
                            else {
                                //si no hay formato reconocido y parseable, metemos un iframe con la respuesta
                                //y prau
                                //para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent

                                var compoundLayer = {
                                    name: 'layer' + TC.getUID(), title: 'Datos en el punto', features: []
                                };

                                service.layers[service.layers.length] = compoundLayer;
                                compoundLayer.features[0] = {
                                    rawUrl: featureInfo.originalUrl, expandUrl: featureInfo.expandUrl, rawContent: featureInfo.responseText, rawFormat: iFormat
                                };
                                featureCount = featureCount + 1;
                            }
                        }
                        else { // iFormat !== featureInfo.requestedFormat

                            // GLS:
                            TC.Util.consoleRegister("Respuesta GFI: lo más probable es que el servidor esté devolviendo una excepción");
                            TC.Util.consoleRegister("Lanzamos los eventos que corresponde y mostramos tostada");

                            // En este caso lo más probable es que el servidor esté devolviendo una excepción
                            self.parent.responseError({
                                message: featureInfo.responseText,
                                status: featureInfo.status
                            });
                            // GLS: misma gestión de error que en ol.js - > function (a, b, c) { // error...
                            map.toast(self.parent.getLocaleString('featureInfo.error'), {
                                type: TC.Consts.msgType.ERROR
                            });
                        }

                    }
                    if (someSuccess) {
                        var finfoPromises = featurePromises;
                        if (featurePromises.length) {
                            finfoPromises = finfoPromises.concat(new Promise(function (resolve, reject) {
                                // Si hay features cargamos el módulo de geometria para encontrar una que se interseque con el punto
                                TC.loadJS(
                                    !TC.Geometry,
                                    TC.apiLocation + 'TC/Geometry',
                                    function () {
                                        resolve();
                                    }
                                );
                            }));
                        }
                        Promise.all(finfoPromises).then(function (features) {
                            var defaultFeature;
                            features.forEach(function (feat, idx) {
                                if (feat) {
                                    feat.attributes = [];
                                    for (var key in feat.data) {
                                        var value = feat.data[key];
                                        if (typeof value !== 'object') {
                                            feat.attributes.push({
                                                name: key,
                                                value: typeof (value) == "number" ? value.toLocaleString(TC.Util.getMapLocale(self.parent.map)) : value
                                            });
                                        }
                                    }
                                    if (!defaultFeature && TC.Geometry.isInside(coords, feat.geometry)) {
                                        defaultFeature = feat;
                                    }
                                    featureInsertionPoints[idx].push(feat);
                                }
                            });

                            var services = [];
                            for (var serviceUrl in targetServices) {
                                if (targetServices.hasOwnProperty(serviceUrl)) {
                                    services.push(targetServices[serviceUrl]);
                                }
                            }

                            self.parent.responseCallback({
                                coords: coords,
                                resolution: resolution,
                                services: services,
                                featureCount: featureCount,
                                defaultFeature: defaultFeature
                            });
                        });
                    }
                },
                    function (a, b, c) { // error
                        if (services && services.length == 0) {
                            for (var serviceUrl in targetServices) {
                                services.push(targetServices[serviceUrl]);
                            }
                        }

                        self.parent.responseCallback({
                            coords: coords, resolution: resolution, services: services, featureCount: 0
                        });
                        map.toast(self.parent.getLocaleString('featureInfo.error'), {
                            type: TC.Consts.msgType.ERROR
                        });
                    });
            }
            else {

                if (map.workLayers.filter(function (layer) {
                    return layer instanceof TC.layer.Raster;
                }).length > 0) {
                    map.toast(self.parent.getLocaleString('featureInfo.notQueryableLayers'), {
                        type: TC.Consts.msgType.INFO
                    });
                }

                if (services && services.length == 0) {
                    for (var serviceUrl in targetServices) {
                        services.push(targetServices[serviceUrl]);
                    }
                }

                // GLS: nos suscribimos TC.Consts.event.BEFOREFEATUREINFO y lanzamos el mismo evento de zero resultados ya que puede darse que la resolución se lance antes del before.
                map.on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                    self.parent.responseCallback({
                        coords: coords, resolution: resolution, services: services, featureCount: 0
                    });
                });

                self.parent.responseCallback({
                    coords: coords, resolution: resolution, services: services, featureCount: 0
                });
            }
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                self.hasEligibleLayers().then(function (hasLayers) {
                    if (hasLayers) {
                        if (!self.parent._isSearching) {
                            if (e.type == SINGLECLICK && !self.parent._isDrawing && !self.parent._isSearching) {
                                _clickTrigger.call(self, e);
                            }
                        }
                    }
                });
            }

        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.hasEligibleLayers = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const map = self.parent.map;
            var ret = false;
            map.wrap.getMap().then(function (olMap) {
                olMap.getLayers().forEach(function (olLayer) {
                    var layer = olLayer._wrap.parent;
                    var source = olLayer.getSource();
                    //Por qué en workLayers están el vectorial de medición, y cosas así?
                    if (source.getGetFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0) {
                        ret = true;
                        return false;   //break del foreach
                    }
                });
                resolve(ret);
            });
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.beginDraw = function (options) {
        var self = this;
        options = options || {};
        var xy = options.xy;
        var layer = options.layer;
        var callback = options.callback;
        var geometryType = options.geometryType;
        var semaforo = false;
        if (!self.drawCtrl) {
            layer.wrap.getLayer().then(function (olLayer) {
                var olGeometryType;
                switch (geometryType) {
                    case TC.Consts.geom.POLYLINE:
                        olGeometryType = ol.geom.GeometryType.LINE_STRING;
                        break;
                    default:
                        olGeometryType = ol.geom.GeometryType.POLYGON;
                        break;
                }
                self.drawCtrl = new ol.interaction.Draw({
                    source: olLayer.getSource(),
                    type: olGeometryType
                    , style: olLayer.getStyle()
                });
                var setShowsPopup = function (wrap) {
                    wrap.parent.showsPopup = false;
                };
                olLayer.getSource().on(ADDFEATURE, function (event) {
                    if (event.feature._wrap) {
                        setShowsPopup(event.feature._wrap);
                    }
                    else {
                        event.feature._wrapPromise.then(setShowsPopup);
                    }
                });
                self.drawCtrl.handleEvent = function (event) {
                    //esta ñapa para solucionar cuando haces un primer punto y acontinuación otro muy rápido
                    if (event.type == SINGLECLICK) {
                        var points = olGeometryType === ol.geom.GeometryType.POLYGON ? this.sketchCoords_[0] : this.sketchCoords_;
                        if (semaforo && points.length == 2 && this.sketchFeature_ !== null) {// GLS: Añado la misma validación (this.sketchFeature_ !== null) que tiene el código de OL antes de invocar addToDrawing_ 
                            this.addToDrawing_(event);
                        }
                        else {
                            semaforo = true;
                        }
                    }
                    return ol.interaction.Draw.prototype.handleEvent.call(this, event);
                }
                const map = self.parent.map;
                const olMap = map.wrap.map;
                olMap.addInteraction(self.drawCtrl);
                self.drawCtrl.on('drawstart', function (event) {
                    self.parent._isDrawing = true;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                });
                self.drawCtrl.startDrawing_({
                    coordinate: xy
                });
                self.drawCtrl.on('drawend', function (event) {
                    self.parent._isDrawing = false;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                    olMap.removeInteraction(self.drawCtrl);
                    this.setActive(false);
                    self.drawCtrl = null;
                    olLayer.getSource().clear();
                    self.parent._drawToken = true;
                    setTimeout(function () {
                        self.parent._drawToken = false;
                    }, 500);
                    if (callback) {
                        TC.wrap.Feature.createFeature(event.feature, { showsPopup: false }).then(function (feat) {
                            callback(feat);
                        });
                    }
                });
            });

        }
        else {
            self.drawCtrl.setActive(true);
            self.drawCtrl.startDrawing_({
                coordinate: xy
            });
        }
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.cancelDraw = function (xy, layer, callback) {
        var self = this;
        if (self.drawCtrl && self.parent._isDrawing) {
            self.parent._isDrawing = false;
            self.drawCtrl.setActive(false);
            self.drawCtrl.source_.clear();

        }
    };

    const _checkMaxFeatures = function (numMaxfeatures, url, data) {
        return new Promise(function (resolve) {
            TC.ajax({
                url: url,
                data: data,
                cache: false,
                contentType: 'application/xml',
                responseType: 'application/xml',
                method: 'POST'
            }).then(function (response) {
                const responseData = response.data;
                if (responseData instanceof XMLDocument) {
                    var responseAsJSON = xml2json(responseData);
                    if (responseAsJSON.Exception) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.Indeterminate,
                                params: {
                                    err: responseAsJSON.Exception.exceptionCode, errorThrown: responseAsJSON.Exception.ExceptionText
                                }
                            }]
                        })
                        return;
                    }
                }
                var featFounds = parseInt(responseAsJSON.numberMatched || responseAsJSON.numberOfFeatures, 10)
                if (isNaN(featFounds) || featFounds > parseInt(numMaxfeatures, 10)) {
                    resolve({
                        errors: [{
                            key: TC.Consts.WFSErrors.NumMaxFeatures
                        }]
                    });
                    return;
                }
                else if (featFounds === 0) {
                    resolve({
                        errors: [{
                            key: TC.Consts.WFSErrors.NoFeatures
                        }]
                    });
                    return;
                }
                else
                    resolve(featFounds);

            }, function (e) {
                resolve({
                    errors: [{
                        key: TC.Consts.WFSErrors.Indeterminate,
                        params: { err: e.name, errorThrown: e.message }
                    }]
                });
                return;
            });
        });
    }

    const _makePostCall = function (url, data) {
        return new Promise(function (resolve) {
            TC.ajax({
                url: url,
                data: data,
                cache: false,
                contentType: 'application/xml',
                method: 'POST'
            }).then(function (response) {
                const responseData = response.data;
                if (responseData instanceof XMLDocument) {
                    var responseAsJSON = xml2json(responseData);
                    if (responseAsJSON.Exception) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.Indeterminate,
                                params: {
                                    err: responseAsJSON.Exception.exceptionCode, errorThrown: responseAsJSON.Exception.ExceptionText
                                }
                            }]
                        })
                        return;
                    }
                }
                resolve({ response: response });
            }, function (e) {
                resolve({
                    errors: [{
                        key: TC.Consts.WFSErrors.Indeterminate,
                        params: { err: e.name, errorThrown: e.message }
                    }]
                });
                return;
            });
        });
    }

    var WFSGetFeatureBuilder = function (map, filter, outputFormat, download) {
        const arrPromises = [];

        var services = {};

        const _getServiceTitle = function (service) {
            const mapLayer = service.mapLayers[0];
            return service.title || service.mapLayers.reduce(function (prev, cur) {
                return prev || cur.title;
            }, '') || (mapLayer.tree && mapLayer.tree.title) || mapLayer.capabilities.Service.Title;
        };


        const olMap = map.wrap.map;
        const getCRS = function () {
            if (download && (outputFormat === TC.Consts.mimeType.JSON || outputFormat === TC.Consts.mimeType.KML))
                return TC.Consts.SRSDOWNLOAD_GEOJSON_KML;
            return map.getCRS();
        };
        const _postOrDownload = function (url, data) {
            return new Promise(function (resolve) {
                if (!download) {
                    _makePostCall(url, data).then(function (response) {
                        if (response.errors && response.errors.length > 0) {
                            response.errors[0].params["serviceTitle"] = service.mapLayers.reduce(function (prev, cur) {
                                return prev || cur.title;
                            }, '') || _getServiceTitle(service);
                            resolve(response);
                        }
                        else {
                            resolve(response);
                        }
                    })
                }
                else
                    resolve({
                        url: url,
                        data: data
                    });
            });
        };
        olMap.getLayers().forEach(function (olLayer) {
            var layer = olLayer._wrap.parent;
            if (!olLayer.getVisible() || map.workLayers.indexOf(layer) < 0 || layer.type !== TC.Consts.layerType.WMS)
                return;
            var availableLayers = layer.getDisgregatedLayerNames() || layer.availableNames;
            var serviceObj = services[layer.url.toLowerCase()];
            if (!serviceObj) {
                serviceObj = services[layer.url.toLowerCase()] = {
                    layers: [], mapLayers: [layer], layerNames: []
                };
            }
            for (var i = 0; i < availableLayers.length; i++) {
                var name = availableLayers[i];
                //URI:se quita la exclusion de capas no visibles por escala
                /*if (!layer.isVisibleByScale(name) && !download)
                    continue;*/
                if (!layer.wrap.getInfo(name).queryable)
                    continue;
                serviceObj.layerNames.push(name);
                var path = layer.getPath(name);
                serviceObj.layers.push({
                    name: name,
                    title: path[path.length - 1],
                    path: path.slice(1),
                    features: []
                });
            }
            if (serviceObj.layerNames.length == 0)
                return;
            if (typeof (serviceObj.request) !== "undefined") {
                return;
            }
            serviceObj.request = serviceObj.request || layer.getWFSCapabilitiesPromise(); //WFSCapabilities.Promises(url);
            arrPromises.push(new Promise(function (resolve, reject) {
                serviceObj.request.then(function (capabilities) {
                    var service = null;
                    var errors = [];
                    for (var url in services)
                        if (services[url].request && services[url].request == serviceObj.request) {
                            service = services[url];
                        }
                    var _numMaxFeatures = null;
                    var layerList = service.layerNames;
                    if (!(layerList instanceof Array) || !layerList.length) return;//condici\u00f3n de salida
                    //comprobamos que tiene el getfeature habilitado
                    if (typeof (capabilities.Operations.GetFeature) === "undefined") {
                        errors.push({ key: TC.Consts.WFSErrors.GetFeatureNotAvailable, params: { serviceTitle: _getServiceTitle(service) } })
                        resolve({ "errors": errors });
                        return;
                    }
                    var availableLayers = [];
                    for (var i = 0; i < layerList.length; i++) {
                        //Comprbamos si la capa en el WMS tiene el mimso nombre que en el WFS
                        var layer = layerList[i].substring(layerList[i].indexOf(":") + 1);
                        //quitamos los ultimos caracteres que sean "_" , cosas de Idena
                        while (layer[layer.length - 1] === "_") {
                            layer = layer.substring(0, layer.lastIndexOf("_"));
                        }
                        if (!capabilities.FeatureTypes.hasOwnProperty(layer)) {
                            var titles = service.mapLayers[0].getPath(layer);
                            errors.push({ key: TC.Consts.WFSErrors.LayersNotAvailable, params: { serviceTitle: _getServiceTitle(service), "layerName": titles[titles.length - 1] } });
                            continue;
                        }
                        if (availableLayers.indexOf(layer) < 0)
                            availableLayers.push(layer);
                    }
                    if (availableLayers.length == 0) {
                        errors.push({ key: TC.Consts.WFSErrors.NoValidLayers, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    if (capabilities.Operations.GetFeature.CountDefault)
                        _numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
                    //comprobamos si soporta querys    
                    if (
                        (capabilities.version === "1.0.0" && !capabilities.Operations.GetFeature.Operations.hasOwnProperty("Query"))
                        ||
                        ((capabilities.version === "2.0.0" || capabilities.version === "1.1.0") && capabilities.Operations.QueryExpressions.AllowedValues.Value.indexOf("wfs:Query") < 0)
                    ) {
                        errors.push({ key: TC.Consts.WFSErrors.QueryNotAvailable, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    var url = (capabilities.Operations.GetFeature.DCPType ? capabilities.Operations.GetFeature.DCPType[1].HTTP.Post.onlineResource : capabilities.Operations.GetFeature.DCP.HTTP.Post["xlink:href"]);

                    // var url2 = service.mapLayers[0].getFeatureUrl(url);
                    service.mapLayers[0].getFeatureUrl(url).then(function (url2) {
                        if (_numMaxFeatures) {
                            _checkMaxFeatures(_numMaxFeatures, url2, TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, true, getCRS())).then(function (response) {
                                if (response.errors && response.errors.length > 0) {
                                    switch (response.errors[0].key) {
                                        case TC.Consts.WFSErrors.Indeterminate:
                                            response.errors[0].params["serviceTitle"] = service.mapLayers.reduce(function (prev, cur) {
                                                return prev || cur.title;
                                            }, '') || _getServiceTitle(service);
                                            break;
                                        case TC.Consts.WFSErrors.NumMaxFeatures:
                                            response.errors[0]["params"] = { limit: _numMaxFeatures, serviceTitle: _getServiceTitle(service) };
                                            break;
                                        case TC.Consts.WFSErrors.NoFeatures:
                                            response.errors[0]["params"] = { serviceTitle: _getServiceTitle(service) };
                                            break;
                                    }
                                    resolve(response);
                                }
                                else
                                    _postOrDownload(url2, TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {
                                        resolve(Object.assign({ service: service, errors: errors }, response));
                                    });
                            });
                        }
                        else {
                            _postOrDownload(url2, TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {
                                resolve(Object.assign({ service: service, errors: errors }, response))

                            });
                        }
                    }).catch(function (e) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.Indeterminate,
                                params: { err: e.name, errorThrown: e.message, serviceTitle: _getServiceTitle(service) }
                            }]
                        });
                    });
                }, function (e) {
                    var service = null;
                    for (var title in services)
                        if (services[title].request && services[title].request === serviceObj.request) {
                            service = services[title];
                        }
                    resolve({ errors: [{ key: TC.Consts.WFSErrors.GetCapabilities, params: { err: e.name, serviceTitle: _getServiceTitle(service) } }] });
                });
            }));
        });
        return arrPromises;
    };
    TC.WFSGetFeatureBuilder = WFSGetFeatureBuilder;

    var readFeaturesFromResponse = function (map, data, contentType) {
        var format;
        var iFormat = contentType;
        if (iFormat && iFormat.indexOf(";") > -1)
            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

        if (!iFormat) iFormat = data.requestedFormat;
        switch (iFormat) {
            case 'application/json':
                format = new ol.format.GeoJSON();
                break;
            case 'application/vnd.ogc.gml':
                if (data.responseText.indexOf("FeatureCollection") > -1)
                    format = new ol.format.WFS({
                        gmlFormat: new ol.format.GML2({
                            srsName: map.crs
                        })
                    });
                else
                    format = new ol.format.WMSGetFeatureInfo();
                break;
            case 'application/vnd.ogc.gml/3.1.1':
                format = new ol.format.GML3({
                    srsName: map.crs
                });
                break;
            case "text/xml":
            case "application/xml":
                //posible error
                var jqXHR = xml2json(data);
                if (jqXHR.ServiceException)
                    TC.error(jqXHR.ServiceException);
                format = null;
                break;
            default:
                format = null;
                break;
        }
        if (format) {
            return format.readFeatures(data, {
                featureProjection: ol.proj.get(map.crs)
            });
        }
        else {
            return null;
            ////si no hay formato reconocido y parseable, metemos un iframe con la respuesta
            ////y prau
            ////para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent
            //var l = service.layers[0];
            //l.features.push({
            //    error: response.responseText
            //});
        }
    };
    var featureToServiceDistributor = function (features, service) {
        var featurePromises = [];
        var featureInsertionPoints = [];
        var isParentOrSame = function (layer, na, nb) {
            var result = false;
            if (na === nb || (na.indexOf(nb) === 0)) {
                result = true;
            }
            else {
                var pa = layer.getPath(na);
                var pb = layer.getPath(nb);
                if (pa.length > 0 && pb.length >= pa.length) {
                    result = true;
                    for (var i = 0; i < pa.length; i++) {
                        if (pa[i] !== pb[i]) {
                            result = false;
                            break;
                        }
                    }
                }
            }
            return result;
        };
        for (var j = 0; j < features.length; j++) {
            var feature = features[j];
            if (feature instanceof ol.Feature) {
                var fid = feature.getId() || TC.getUID();
                var found = false;
                var layerName = fid.substr(0, fid.lastIndexOf('.'));
                for (var k = 0; k < service.layers.length; k++) {
                    var l = service.layers[k];
                    var lName = l.name.substr(l.name.indexOf(':') + 1);
                    if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                        found = true;
                        featurePromises.push(TC.wrap.Feature.createFeature(feature));

                        featureInsertionPoints[feature.id_] = (l.features);
                        break;
                    }
                }

                //si llegamos aqu\u00ed y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                //esto pasa, p.ej, en cartociudad
                if (!found) {
                    //as\u00ed que creo un layer de palo para la respuesta del featInfo
                    var fakeLayer;
                    if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                    else {
                        fakeLayer = {
                            name: layerName, title: layerName, features: []
                        };
                        fakeLayers[layerName] = fakeLayer;
                        service.layers.push(fakeLayer);
                    }

                    if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                        featurePromises.push(TC.wrap.Feature.createFeature(feature));
                        featureInsertionPoints.push(fakeLayer.features);
                    }
                }
            }
        }//iteraci\u00f3n sobre las features de esta respuesta

        return new Promise(function (resolve, reject) {
            Promise.all(featurePromises).then(function (features) {
                features.forEach(function (feat) {
                    feat.attributes = [];
                    //feat.showsPopup = false;
                    for (var key in feat.data) {
                        var value = feat.data[key];
                        if (typeof value !== 'object') {
                            feat.attributes.push({
                                name: key, value: value
                            });
                        }
                    }
                    featureInsertionPoints[feat.id].push(feat);
                });
                resolve({
                    service: service
                })
            });
        });
    }

    TC.wrap.control.GeometryFeatureInfo.prototype.getFeaturesByGeometry = function (feature, xy) {

        var self = this;
        var map = self.parent.map;
        self.parent.filterFeature = feature;
        feature.layer = self.parent.filterLayer;

        map.wrap.getMap().then(function (olMap) {

            var olGeometry = feature.wrap.feature.getGeometry();
            var stride = olGeometry.stride;
            var flatCoordinates = olGeometry.getFlatCoordinates();
            //calcular el punto mas alto
            if (!xy) {
                var bestPoint = null;
                for (var i = 1, len = flatCoordinates.length; i < len; i += stride) {
                    if (!bestPoint || bestPoint[1] < flatCoordinates[i]) {
                        bestPoint = [flatCoordinates[i - 1], flatCoordinates[i]];
                    }
                }
                xy = olMap.getPixelFromCoordinate(new ol.geom.Point(bestPoint).getCoordinates());
            }

            self.parent.beforeRequest({ xy: xy });

            var arrRequests = WFSGetFeatureBuilder(map, new TC.filter.intersects(feature, map.crs), TC.Consts.format.JSON);

            const arrPromises = [];
            Promise.all(arrRequests).then(function (responses) {
                var targetServices = [];
                var featureCount = 0;
                var hayError = false;

                for (var i = 0; i < responses.length; i++) {
                    const responseObj = responses[i];
                    if (!responseObj) continue;
                    arrPromises[arrPromises.length] = new Promise(function (resolve, reject) {
                        if (responseObj.errors && responseObj.errors.length) {
                            for (var j = 0; j < responseObj.errors.length; j++) {
                                var errorMsg, errorType = TC.Consts.msgType.WARNING;
                                hayError = true;
                                var error = responseObj.errors[j];
                                switch (error.key) {
                                    case TC.Consts.WFSErrors.NumMaxFeatures:
                                        errorMsg = self.parent.getLocaleString("wfs.tooManyFeatures", error.params);
                                        break;
                                        /*case TC.Consts.WFSErrors.NoLayers:
                                            errorMsg = self.parent.getLocaleString('noLayersLoaded');*/
                                        break;
                                    case TC.Consts.WFSErrors.GetCapabilities:
                                        errorMsg = self.parent.getLocaleString('wfsGFI.inValidService', error.params);
                                        break;
                                    case TC.Consts.WFSErrors.NoFeatures:
                                        //si no hay features nos callamos. Quizas en un futuro se muestre una alerta
                                        hayError = false;
                                        continue;
                                        break;
                                    case TC.Consts.WFSErrors.Indeterminate:
                                        errorMsg = self.parent.getLocaleString("wfs.IndeterminateError");
                                        TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                                        errorType = TC.Consts.msgType.ERROR;
                                        break;
                                    default:
                                        errorMsg = self.parent.getLocaleString("wfsGFI." + error.key, error.params);
                                        break;
                                }

                                map.toast(errorMsg, { type: errorType });
                            }
                            if (!responseObj.response) {
                                resolve();
                            }
                        }
                    });

                    // Puede no haber response porque la URL no es correcta, metemos un condicional
                    var featuresFound = responseObj.response ? readFeaturesFromResponse(map, responseObj.response.data, responseObj.response.contentType) : [];
                    //ahora se distribuye la features por servicio y capa
                    arrPromises[arrPromises.length - 1] = featureToServiceDistributor(featuresFound, responseObj.service);
                    if (responseObj.service) {
                        targetServices.push(responseObj.service);
                    }
                    featureCount = featureCount + featuresFound.length;
                }
                Promise.all(arrPromises).then(function () {
                    self.parent.responseCallback({
                        xy: xy || null, services: targetServices, featureCount: featureCount
                    });
                });
            }, function (e) {
                self.parent.responseCallback({});
            })
        });
    };

    TC.wrap.control.Popup.prototype = function () {
        this.popup = null;
    };

    TC.Consts.event.PANANIMATIONSTART = 'pananimationstart.tc';
    TC.Consts.event.PANANIMATIONEND = 'pananimationend.tc';
    TC.wrap.control.Popup.prototype.fitToView = function () {
        var self = this;
        var map = self.parent.map;
        var olMap = self.parent.map.wrap.map;

        var popupBoundingRect = self.parent.popupDiv.getBoundingClientRect();
        var mapBoundingRect = map.div.getBoundingClientRect();

        var topLeft = olMap.getCoordinateFromPixel([popupBoundingRect.left - mapBoundingRect.left, popupBoundingRect.top - mapBoundingRect.top]);
        var bottomRight = olMap.getCoordinateFromPixel([popupBoundingRect.right - mapBoundingRect.left, popupBoundingRect.bottom - mapBoundingRect.top]);
        var west = topLeft[0];
        var north = topLeft[1];
        var east = bottomRight[0];
        var south = bottomRight[1];

        var popupExt = [west, south, east, north];
        var mapExt = map.getExtent();

        if (!ol.extent.containsExtent(mapExt, popupExt)) {
            var overflows = {
                left: Math.max(mapExt[0] - popupExt[0], 0),
                bottom: Math.max(mapExt[1] - popupExt[1], 0),
                right: Math.max(popupExt[2] - mapExt[2], 0),
                top: Math.max(popupExt[3] - mapExt[3], 0)
            };

            if (self.parent.dragged) {
                // Movemos el popup
                var newPos = self.popup.getPosition();
                if (overflows.right) {
                    newPos[0] = newPos[0] - overflows.right;
                }
                else if (overflows.left) {
                    newPos[0] = newPos[0] + overflows.left;
                }
                if (overflows.top) {
                    newPos[1] = newPos[1] - overflows.top;
                }
                else if (overflows.bottom) {
                    newPos[1] = newPos[1] + overflows.bottom;
                }
                var newPixelPos = olMap.getPixelFromCoordinate(newPos);
                newPixelPos[1] = olMap.getSize()[1] - newPixelPos[1];
                self.parent._previousContainerPosition = newPixelPos;
                self.popup._oldUpdatePixelPosition(newPos);
            }
            else {
                if (self.parent.isVisible()) {
                    // Movemos el mapa
                    var view = olMap.getView();
                    var ct = view.getCenter().slice();

                    if (overflows.top) ct[1] += overflows.top;
                    else if (overflows.bottom) ct[1] -= overflows.bottom;
                    if (overflows.right) ct[0] += overflows.right;
                    else if (overflows.left) ct[0] -= overflows.left;

                    view.animate({
                        center: ct, easing: function (percent) {
                            if (percent === 0) self.parent.map.trigger(TC.Consts.event.PANANIMATIONSTART);
                            if (percent === 1) self.parent.map.trigger(TC.Consts.event.PANANIMATIONEND);
                            return percent;
                        }
                    });
                }
            }
        }
    };

    TC.wrap.control.Popup.prototype.setDragged = function (dragged) {
        var popup = this.popup;
        //var view = popup.getMap().getView();
        //var onViewChange = function () {
        //    console.log(this.getCenter());
        //};
        if (dragged) {
            // Parcheamos funciones para que el popup no se mueva cuando cambiamos el extent del mapa
            if (!popup._oldUpdatePixelPosition) {
                popup._oldUpdatePixelPosition = popup.updatePixelPosition;
                popup.updatePixelPosition = function () {
                };
            }
            if (!popup._newHandleOffsetChanged) {
                popup._newHandleOffsetChanged = function () {
                    this._oldUpdatePixelPosition();
                };
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup.handleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup._newHandleOffsetChanged, popup);
            }
            //view.on(['change:center','change:resolution'], onViewChange);
        }
        else {
            // Redefinimos las propiedades de posicionamiento porque al arrastrarlo, las hemos modificado.
            const containerStyle = popup.getElement().parentElement.style;
            containerStyle.setProperty('top', popup.rendered.top_);
            containerStyle.setProperty('bottom', popup.rendered.bottom_);
            containerStyle.setProperty('left', popup.rendered.left_);
            containerStyle.setProperty('right', popup.rendered.right_);

            delete this.parent._previousContainerPosition;
            // Deshacemos parcheo
            if (popup._oldUpdatePixelPosition) {
                popup.updatePixelPosition = popup._oldUpdatePixelPosition;
                delete popup._oldUpdatePixelPosition;
            }
            if (popup._newHandleOffsetChanged) {
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup._newHandleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup.handleOffsetChanged, popup);
                delete popup._newHandleOffsetChanged;
            }
            //view.un(['change:center', 'change:resolution'], onViewChange);
        }
    };

    TC.wrap.Feature.prototype.getLegend = function () {
        var self = this;
        var result = {
        };
        var style = getNativeFeatureStyle(self.feature, true);
        if (style) {
            var image = style.getImage();
            if (image) {
                if (image instanceof ol.style.Icon) {
                    result.src = image.getSrc();
                    var scale = image.getScale();
                    if (scale) {
                        result.scale = scale;
                        var img = image.getImage();
                        if (img.width) {
                            result.width = img.width * scale;
                            result.height = img.height * scale;
                        }
                    }
                }
                else if (image instanceof ol.style.Circle) {
                    result.src = image.canvas_.toDataURL();
                }
                if (self.parent.options.radius) {
                    result.height = result.width = self.parent.options.radius * 2;
                }
                else {
                    result.width = result.width || self.parent.options.width;
                    result.height = result.height || self.parent.options.height;
                }
            }
            else {
                // No image, find stroke and fill
                var stroke = style.getStroke();
                var fill = style.getFill();
                if (stroke) {
                    var strokeColor = stroke.getColor();
                    if (strokeColor) {
                        result.strokeColor = ol.color.asString(strokeColor);
                    }
                    var strokeWidth = stroke.getWidth();
                    if (strokeWidth) {
                        result.strokeWidth = strokeWidth;
                    }
                }
                if (fill) {
                    var fillColor = fill.getColor();
                    if (fillColor) {
                        result.fillColor = ol.color.asString(fillColor);
                    }
                }
            }
        }

        return result;
    };

    var createNativeFeature = function (geometryName) {
        const result = new ol.Feature();
        if (geometryName) {
            result.setGeometryName(geometryName);
        }
        return result;
    };

    TC.wrap.Feature.prototype.createPoint = function (coords, options) {
        const self = this;
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        self.feature.setStyle(createNativeStyle({ styles: { point: options } }));
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMarker = function (coords, options) {
        const self = this;

        var iconUrl = TC.Util.getPointIconUrl(options);
        if (iconUrl) {
            options.url = iconUrl;
            self.feature = createNativeFeature(options.geometryName);
            self.feature._wrap = self;
            self.parent.setCoords(coords);
            self.feature.setStyle(createNativeStyle({ styles: { marker: options } }));
            self.setData(self.parent.data);
        }
        else {
            self.createPoint(coords, options);
        }
    };

    TC.wrap.Feature.prototype.createPolyline = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        self.feature.setStyle(createNativeStyle({ styles: { line: options } }));
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createPolygon = function (coords, options) {
        const self = this;
        options = options || {};
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (options.strokeColor || options.strokeWidth || options.fillColor || options.fillOpacity) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }));
        }
        self.setData(self.parent.data);
    };


    TC.wrap.Feature.prototype.createMultiPolyline = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        self.feature.setStyle(createNativeStyle({ styles: { line: options } }));
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMultiPolygon = function (coords, options) {
        const self = this;
        options = options || {};
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (options.strokeColor || options.strokeWidth || options.fillColor || options.fillOpacity) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createCircle = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (options) {
            self.feature.setStyle(
                new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: options.strokeColor,
                        width: options.strokeWidth,
                        lineDash: options.lineDash
                    }),
                    fill: new ol.style.Fill({
                        color: getRGBA(options.fillColor, options.fillOpacity)
                    })
                })
            );
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.createFeature = function (olFeat, options) {
        return new Promise(function (resolve, reject) {
            var olGeometry = olFeat.getGeometry();
            options = options || {};
            options.id = olFeat.getId();

            // geometría
            var geomStr;
            switch (true) {
                case olGeometry instanceof ol.geom.Point:
                    var olStyle = olFeat.getStyle();
                    if (TC.Util.isFunction(olStyle)) {
                        olStyle = olStyle(olFeat);
                    }
                    var olStyles = olStyle ? (Array.isArray(olStyle) ? olStyle : [olStyle]) : [];
                    for (var i = 0, len = olStyles.length; i < len; i++) {
                        olStyle = olStyles[i];
                        if (olStyle.getImage() instanceof ol.style.Icon) {
                            geomStr = 'Marker';
                            break;
                        }
                    }
                    geomStr = geomStr || 'Point';
                    break;
                case olGeometry instanceof ol.geom.LineString:
                    geomStr = 'Polyline';
                    break;
                case olGeometry instanceof ol.geom.Polygon:
                    geomStr = 'Polygon';
                    break;
                case olGeometry instanceof ol.geom.MultiLineString:
                    geomStr = 'MultiPolyline';
                    break;
                case olGeometry instanceof ol.geom.MultiPolygon:
                    geomStr = 'MultiPolygon';
                    break;
                default:
                    break;
            }
            if (geomStr) {
                TC.loadJS(
                    !TC.feature || (TC.feature && !TC.feature[geomStr]),
                    [TC.apiLocation + 'TC/feature/' + geomStr],
                    function () {
                        var feat = new TC.feature[geomStr](olFeat, options);
                        feat.data = feat.wrap.getData();
                        resolve(feat);
                    }
                );
            }
            else {
                TC.loadJS(
                    !TC.Feature,
                    [TC.apiLocation + 'TC/Feature'],
                    function () {
                        var feat = new TC.Feature(olFeat, options);
                        feat.data = feat.wrap.getData();
                        resolve(feat);
                    }
                );
            }
        });
    };

    TC.wrap.Feature.prototype.cloneFeature = function () {
        return this.feature.clone();
    };

    TC.wrap.Feature.prototype.getStyle = function () {
        var self = this;
        var result = {};
        var olStyle = self.feature.getStyle();
        if (TC.Util.isFunction(olStyle)) {
            olStyle = olStyle(self.feature);
        }
        var olStyles = olStyle ? (Array.isArray(olStyle) ? olStyle : [olStyle]) : [];

        const getFill = function (style, obj) {
            if (style) {
                const fill = style.getFill();
                if (fill) {
                    obj.fillColor = fill.getColor();
                    if (Array.isArray(obj.fillColor)) {
                        obj.fillOpacity = obj.fillColor[3];
                    }
                }
            }
        };
        const getStroke = function (style, obj) {
            if (style) {
                const stroke = style.getStroke();
                if (stroke) {
                    obj.strokeColor = stroke.getColor();
                    obj.strokeWidth = stroke.getWidth();
                }
            }
        };

        for (var i = 0, len = olStyles.length; i < len; i++) {
            olStyle = olStyles[i];
            getFill(olStyle, result);
            getStroke(olStyle, result);
            const image = olStyle.getImage();
            if (image instanceof ol.style.Icon) {
                result.url = image.getSrc();
                const size = image.getSize();
                const scale = image.getScale() || 1;
                if (size) {
                    result.width = size[0] * scale;
                    result.height = size[1] * scale;
                }
                var anchor = image.getAnchor();
                if (anchor) {
                    result.anchor = [anchor[0] * scale, anchor[1] * scale];
                    if (size) {
                        // getAnchor devuelve los valores en pixels, hay que transformar a fracción
                        result.anchor[0] = result.anchor[0] / result.width;
                        result.anchor[1] = result.anchor[1] / result.height;
                    }
                }
            }
            else {
                getFill(image, result);
                getStroke(image, result);
            }
            var text = olStyle.getText();
            if (text) {
                result.label = text.getText();
                var font = text.getFont();
                if (font) {
                    // A 96dpi 3pt = 4px
                    result.fontSize = parseInt(font.match(/\d+pt/)) || parseInt(font.match(/\d+px/)) * 0.75;
                }
                var rotation = text.getRotation();
                if (rotation) {
                    result.angle = -180 * rotation / Math.PI;
                }
                result.labelOffset = [text.getOffsetX(), text.getOffsetY()];
                fill = text.getFill();
                if (fill) {
                    result.fontColor = fill.getColor();
                }
                stroke = text.getStroke();
                if (stroke) {
                    result.labelOutlineColor = stroke.getColor();
                    result.labelOutlineWidth = stroke.getWidth();
                }
            }
        }
        TC.Util.extend(self.parent.options, result);
        return result;
    };

    TC.wrap.Feature.prototype.getGeometry = function () {
        var result;
        var self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            if (geom) {
                if (geom.getCoordinates) {
                    result = geom.getCoordinates();
                }
                else if (geom instanceof ol.geom.Circle) {
                    result = [geom.getCenter(), geom.getRadius()];
                }
            }
        }
        return result;
    };

    TC.wrap.Feature.prototype.setGeometry = function (geometry) {
        const self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            var ctor;
            var point,
                points,
                ringsOrPolylines,
                polygons,
                isMultiPolygon,
                isPolygonOrMultiLineString,
                isLineString;
            // punto: array de números
            // línea o anillo: array de puntos
            // multilínea o polígono: array de líneas o anillos
            // multipolígono: array de polígonos
            // Por tanto podemos recorrer los tipos en un switch sin breaks
            switch (true) {
                case (TC.feature.MultiPolygon && self.parent instanceof TC.feature.MultiPolygon):
                    isMultiPolygon = true;
                    ctor = ol.geom.MultiPolygon;
                    polygons = geometry;
                    if (Array.isArray(polygons)) {
                        ringsOrPolylines = geometry[0];
                    }
                case (TC.feature.Polygon && self.parent instanceof TC.feature.Polygon || TC.feature.MultiPolyline && self.parent instanceof TC.feature.MultiPolyline):
                    isPolygonOrMultiLineString = true;
                    ctor = ctor || ((TC.feature.Polygon && self.parent instanceof TC.feature.Polygon) ? ol.geom.Polygon : ol.geom.MultiLineString);
                    ringsOrPolylines = isMultiPolygon ? ringsOrPolylines : geometry;
                    if (Array.isArray(ringsOrPolylines)) {
                        points = ringsOrPolylines[0];
                    }
                case (TC.feature.Polyline && self.parent instanceof TC.feature.Polyline):
                    isLineString = true;
                    ctor = ctor || ol.geom.LineString;
                    points = isPolygonOrMultiLineString ? points : geometry;
                    if (Array.isArray(points)) {
                        point = points[0];
                    }
                case (TC.feature.Point && self.parent instanceof TC.feature.Point):
                    ctor = ctor || ol.geom.Point;
                    point = isLineString ? point : geometry;
                    if (Array.isArray(point) && typeof point[0] === 'number' && typeof point[1] === 'number') {
                        var layout;
                        switch (point.length) {
                            case 3:
                                layout = ol.geom.GeometryLayout.XYZ;
                                break;
                            case 4:
                                layout = ol.geom.GeometryLayout.XYZM;
                                break;
                            default:
                                layout = ol.geom.GeometryLayout.XY;
                                break;
                        }
                        if (geom) {
                            geom.setCoordinates(geometry, layout);
                        }
                        else {
                            geom = new ctor(geometry, layout);
                            self.feature.setGeometry(geom);
                        }
                    }
                    break;
                case (TC.feature.Circle && self.parent instanceof TC.feature.Circle):
                    if (Array.isArray(geometry) &&
                        Array.isArray(geometry[0])
                        && typeof geometry[0][0] === 'number' && typeof geometry[0][1] === 'number'
                        && typeof geometry[1] === 'number') {
                        var layout;
                        switch (geometry[0].length) {
                            case 3:
                                layout = ol.geom.GeometryLayout.XYZ;
                                break;
                            case 4:
                                layout = ol.geom.GeometryLayout.XYZM;
                                break;
                            default:
                                layout = ol.geom.GeometryLayout.XY;
                                break;
                        }
                        if (geom) {
                            geom.setCenterAndRadius(geometry[0], geometry[1], layout);
                        }
                        else {
                            geom = new ol.geom.Circle(geometry[0], geometry[1], layout);
                            self.feature.setGeometry(geom);
                        }
                    }
                    break;
            }
        }
    };

    TC.wrap.Feature.prototype.getId = function () {
        var result;
        var self = this;
        if (self.feature) {
            result = self.feature.getId();
        };
        return result;
    };

    TC.wrap.Feature.prototype.setId = function (id) {
        var self = this;
        if (self.feature) {
            self.feature.setId(id);
        };
    };

    const getPolygonLength = function (polygon, options) {
        const self = this;
        var result = 0;
        polygon.getLinearRings().forEach(function (ring) {
            coordinates = ring.getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            const newRing = polygon.getLinearRing(0);
            result = result + ol.geom.flat.linearRingLength(newRing.flatCoordinates, 0, newRing.flatCoordinates.length, newRing.stride);
        });
        return result;
    };

    const getLineStringLength = function (lineString, options) {
        const self = this;
        coordinates = lineString.getCoordinates();
        if (options.crs) {
            coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
        }
        const line = new ol.geom.LineString(coordinates);
        return line.getLength();
    };

    TC.wrap.Feature.prototype.getLength = function (options) {
        const self = this;
        options = options || {};
        var result = 0;

        const geom = self.feature.getGeometry();
        var coordinates;
        switch (true) {
            case geom instanceof ol.geom.Polygon:
                result = getPolygonLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.LineString:
                result = getLineStringLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getPolygons().forEach(function (polygon) {
                    result = result + getPolygonLength.call(self, polygon, options);
                });
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getLineStrings().forEach(function (lineString) {
                    result = result + getLineStringLength.call(self, lineString, options);
                });
                break;
        }

        return result;
    };

    TC.wrap.Feature.prototype.getArea = function (options) {
        const self = this;
        options = options || {};

        const geom = self.feature.getGeometry();
        var coordinates;
        if (geom instanceof ol.geom.Polygon) {
            coordinates = geom.getLinearRing(0).getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            return polygon.getArea();
        }
    };

    const getNativeFeatureStyle = function (feature, readonly) {
        var style = feature.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(feature);
        }
        if (Array.isArray(style)) {
            style = style[style.length - 1];
        }
        if (!style && !readonly) {
            style = new ol.style.Style();
            feature.setStyle(style);
        }
        return style;
    };

    const getNativeLayerStyle = function (feature) {
        var style = this.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(feature);
        }
        if (Array.isArray(style)) {
            style = style[style.length - 1];
        }
        if (!style) {
            style = new ol.style.Style();
        }
        return style;
    };

    TC.wrap.Feature.prototype.setStyle = function (options) {
        const self = this;
        const olFeat = self.feature;
        if (options === null) {
            olFeat.setStyle(null);
            return;
        }
        const feature = self.parent;
        const geom = olFeat.getGeometry();
        var style = getNativeFeatureStyle(olFeat);
        var layerStyle;
        if (feature.layer) {
            layerStyle = getNativeLayerStyle.call(feature.layer.wrap.layer, feature.wrap.feature);
        }
        if (geom instanceof ol.geom.Point || geom instanceof ol.geom.MultiPoint) {

            var imageStyle;
            if (options.anchor || options.url || options.cssClass) { // Marcador
                imageStyle = style.getImage();
                const iconOptions = {};
                if (imageStyle instanceof ol.style.Icon) {
                    iconOptions.src = options.url || TC.Util.getBackgroundUrlFromCss(options.cssClass) || imageStyle.getSrc();

                    if (options.width && options.height) {
                        iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                    }
                    else {
                        iconOptions.size = imageStyle.getSize();
                    }
                    iconOptions.anchor = getStyleValue(options.anchor, feature) || imageStyle.getAnchor().map(function (elm, idx) {
                        return elm / iconOptions.size[idx];
                    });
                }
                else {
                    iconOptions.src = TC.Util.getPointIconUrl(options);
                    iconOptions.anchor = getStyleValue(options.anchor, feature);
                    iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                };
                if (options.angle) {
                    iconOptions.angle = options.angle;
                }

                imageStyle = new ol.style.Icon(iconOptions);
            }
            else if (!(style.getImage()) && style.getText()) { // Etiqueta

                if (options.label !== undefined) {
                    style = getNativeFeatureStyle(olFeat);
                    if (options.label.length) {
                        style.setText(createNativeTextStyle(options, feature));
                    }
                    else {
                        style.setText();
                    }
                } else {
                    style.setText();
                }
            }
            else { // Punto sin icono
                imageStyle = style.getImage();
                if (!imageStyle) {
                    imageStyle = new ol.style.Circle();
                }
                const circleOptions = {
                    radius: getStyleValue(options.radius, feature) ||
                        (getStyleValue(options.height, feature) + getStyleValue(options.width, feature)) / 4
                };
                if (isNaN(circleOptions.radius)) {
                    circleOptions.radius = imageStyle.getRadius();
                }
                if (options.fillColor) {
                    circleOptions.fill = new ol.style.Fill({
                        color: getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature))
                    });
                }
                else {
                    circleOptions.fill = imageStyle.getFill();
                }
                circleOptions.stroke = imageStyle.getStroke();
                const layerStroke = layerStyle && layerStyle.getStroke();
                if (options.strokeColor || options.strokeWidth) {
                    if (!circleOptions.stroke) {
                        circleOptions.stroke = new ol.style.Stroke();
                    }
                    if (options.strokeColor) {
                        circleOptions.stroke.setColor(getStyleValue(options.strokeColor, feature));
                    }
                    else {
                        const strokeColor = circleOptions.stroke.getColor() || (layerStroke && layerStroke.getColor() || TC.Cfg.styles.point.strokeColor);
                        circleOptions.stroke.setColor(getStyleValue(strokeColor, feature));
                    }
                    if (options.strokeWidth) {
                        circleOptions.stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                    }
                    else {
                        const strokeWidth = circleOptions.stroke.getWidth() || (layerStroke && layerStroke.getWidth() || TC.Cfg.styles.point.strokeWidth);
                        circleOptions.stroke.setWidth(getStyleValue(strokeWidth, feature));
                    }
                }
                imageStyle = new ol.style.Circle(circleOptions);
            }
            style.setImage(imageStyle);
        }
        else {
            var stroke = style.getStroke();
            var strokeChanged = false;
            if (!stroke) {
                stroke = new ol.style.Stroke();
            }
            if (options.strokeColor) {
                stroke.setColor(getStyleValue(options.strokeColor, feature));
                strokeChanged = true;
            }
            if (options.strokeWidth) {
                stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                strokeChanged = true;
                style.setStroke(stroke);
            }
            if (options.lineDash) {
                stroke.setLineDash(options.lineDash)
                strokeChanged = true;
                style.setStroke(stroke);
            }
            if (strokeChanged) {
                style.setStroke(stroke);
            }
            if (geom instanceof ol.geom.Polygon || geom instanceof ol.geom.MultiPolygon) {
                if (options.fillColor || options.fillOpacity) {
                    var fill = style.getFill() || new ol.style.Fill();
                    fill.setColor(getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature)));
                    style.setFill(fill);
                }
            }
        }

        if (options.label !== undefined) {
            style = getNativeFeatureStyle(olFeat);
            if (options.label.length) {
                style.setText(createNativeTextStyle(options, feature));
            }
            else {
                style.setText();
            }
        }

        olFeat.changed();
    };

    TC.wrap.Feature.prototype.toggleSelectedStyle = function (condition) {
        const self = this;
        const feature = self.feature;
        const setStyle = condition === undefined ? !feature._originalStyle : condition;
        if (setStyle) {
            setSelectedStyle(feature);
        }
        else {
            removeSelectedStyle(feature);
        }
    };

    TC.wrap.Feature.prototype.getInnerPoint = function (options) {
        var result;
        var opts = options || {};
        // Funciones para hacer clipping con el extent actual. Así nos aseguramos de que el popup sale en un punto visible actualmente.
        var feature = this.feature;
        var geometry = feature.getGeometry();

        const clipCoord = function (coord) {
            const clipBox = opts.clipBox;
            coord[0] = Math.min(Math.max(coord[0], clipBox[0]), clipBox[2]);
            coord[1] = Math.min(Math.max(coord[1], clipBox[1]), clipBox[3]);
        };
        const clipPolygon = function (geom) {
            if (opts.clipBox) {
                geom[0].forEach(clipCoord);
            }
        };
        const clipPolyline = function (geom) {
            const clipBox = opts.clipBox;
            if (clipBox) {
                for (var i = geom.length - 1; i >= 0; i--) {
                    const coord = geom[i];
                    const x = coord[0];
                    const y = coord[1];
                    if (x < clipBox[0] || x > clipBox[2] || y < clipBox[1] || y > clipBox[3]) {
                        geom.splice(i, 1);
                    }
                }
            }
        };

        result = geometry.getFirstCoordinate();
        switch (geometry.getType()) {
            case ol.geom.GeometryType.MULTI_POLYGON:
                var area = 0;
                geometry = geometry.getPolygons().reduce(function (prev, cur) {
                    const curArea = cur.getArea();
                    const result = curArea > area ? cur : prev;
                    area = curArea;
                    return result;
                });
            case ol.geom.GeometryType.POLYGON:
                var isInsideRing = function (point, ring) {
                    var result = false;
                    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                        var xi = ring[i][0], yi = ring[i][1];
                        var xj = ring[j][0], yj = ring[j][1];
                        var intersect = ((yi > point[1]) != (yj > point[1])) &&
                            (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                        if (intersect) result = !result;
                    }
                    return result;
                };
                var coords = geometry.getCoordinates();
                clipPolygon(coords);
                geometry = new ol.geom.Polygon(coords);
                result = geometry.getInteriorPoint().getCoordinates();
                var rings = geometry.getLinearRings();
                // Miramos si el punto está dentro de un agujero
                for (var i = 1; i < rings.length; i++) {
                    if (isInsideRing(result, rings[i].getCoordinates())) {
                        result = geometry.getClosestPoint(result);
                        break;
                    }
                }
                break;
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                var length = 0;
                geometry = geometry.getLineStrings().reduce(function (prev, cur) {
                    const curLength = cur.getLength();
                    const result = curLength > length ? cur : prev;
                    length = curLength;
                    return result;
                });
            case ol.geom.GeometryType.LINE_STRING:
                var centroid = [0, 0];
                var coords = geometry.getCoordinates();
                clipPolyline(coords);
                geometry = new ol.geom.LineString(coords);
                for (var i = 0; i < coords.length; i++) {
                    centroid[0] += coords[i][0];
                    centroid[1] += coords[i][1];
                }
                centroid[0] /= coords.length;
                centroid[1] /= coords.length;
                result = geometry.getClosestPoint(centroid);
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.Feature.prototype.showPopup = function (popupCtl) {
        var self = this;
        var map = popupCtl.map;
        if (map) {
            var feature = self.feature;
            if (feature) {
                map.currentFeature = self.parent;
                var currentExtent = map.getExtent();

                self._innerCentroid = self.getInnerPoint({ clipBox: currentExtent });

                popupCtl.contentDiv.innerHTML = self.parent.getInfo({ locale: map.options.locale });
                popupCtl.menuDiv.innerHTML = '';
                if (popupCtl.options.closeButton || popupCtl.options.closeButton === undefined) {
                    const btn = document.createElement('div');
                    btn.classList.add(popupCtl.CLASS + '-close');
                    btn.setAttribute('title', popupCtl.getLocaleString('close'));
                    popupCtl.menuDiv.appendChild(btn);
                    btn.addEventListener(TC.Consts.event.CLICK, function () {
                        popupCtl.hide();
                    });
                    popupCtl.contentDiv.classList.add(popupCtl.CLASS + '-has-btn');
                    // En OL2 los featureInfo en versión "baraja de cartas" salen sin tamaño.
                    // Para evitar esto, la clase tc-ctl-finfo tiene ancho y alto establecidos.
                    // Pero eso hace que en el popup salgan barras de scroll, porque contentDiv se crea demasiado pequeño.
                    // Rehacemos el tamaño de tc-ctl-finfo para eliminarlas.
                    const finfo = popupCtl.contentDiv.querySelector('.tc-ctl-finfo');
                    if (finfo) {
                        finfo.width = 'auto';
                        finfo.height = 'auto';
                    }
                }

                var options = self.parent.options;
                if (TC.Util.isEmptyObject(options) && self.parent.layer &&
                    self.parent.layer.options && self.parent.layer.options.styles) {

                    switch (self.parent.CLASSNAME) {
                        case "TC.feature.Point":
                            options = self.parent.layer.options.styles.point;

                            // 11/03/2019 Al crear las features del API desde las features nativas, 
                            // se valida si la feature tiene icono para definir si es punto o marcador
                            // el problema viene cuando la feature no tiene estilo propio sino que lo obtiene de la capa,
                            // en esos casos se define como punto lo que es un marcador y cuando llegamos aquí no se accede a las
                            // opciones de marcador sino de punto.
                            if (!options || TC.Util.isEmptyObject(options)) {
                                options = self.parent.layer.options.styles.marker;
                            }
                            break;
                        case "TC.feature.Marker":
                            options = self.parent.layer.options.styles.marker;
                            break;
                        case "TC.feature.Circle":
                            options = self.parent.layer.options.styles.circle;
                            break;
                        case "TC.feature.MultiPolygon":
                        case "TC.feature.Polygon":
                            options = self.parent.layer.options.styles.polygon;
                            break;
                        case "TC.feature.MultiPolyline":
                        case "TC.feature.Polyline":
                            options = self.parent.layer.options.styles.line;
                            break;
                    }
                }

                // Calcular anchor
                var anchor;
                if (options.anchor) {
                    anchor = getStyleValue(options.anchor, self.parent);
                }
                else {
                    var style;
                    var f = feature._wrap.parent;
                    for (var i = 0; i < map.workLayers.length; i++) {
                        var layer = map.workLayers[i];
                        if (!layer.isRaster()) {
                            if (layer.features.indexOf(f) >= 0) {
                                style = layer.wrap.styleFunction(feature);
                                break;
                            }
                        }
                    }
                    if (Array.isArray(style)) {
                        const image = style[0].getImage();
                        anchor = !image || image instanceof ol.style.Icon ? [0.5, 0] : [0.5, 0.5];
                    }
                }
                const offset = [0, 0];
                if (anchor) {
                    if (options.height) {
                        offset[1] = -(getStyleValue(options.height, self.parent) || 0) * anchor[1];
                    }
                    else {
                        var fStyle = getNativeFeatureStyle(feature, true);
                        if (fStyle) {
                            const image = fStyle.getImage();
                            if (image instanceof ol.style.Icon) {
                                offset[1] = image.getImageSize()[1] * -image.getScale();
                            }
                        }
                    }
                }
                popupCtl.wrap.setDragged(false);
                popupCtl.wrap.popup.setOffset(offset);
                popupCtl.wrap.popup.setPosition(self._innerCentroid);
                popupCtl.popupDiv.classList.add(TC.Consts.classes.VISIBLE);
            } else {
                map.wrap.hidePopup(popupCtl);
            }
        }
    };

    TC.wrap.Feature.prototype.isNative = function (feature) {
        return feature instanceof ol.Feature;
    };

    TC.wrap.Feature.prototype.getPath = function () {
        var result = [];
        var self = this;
        if (self.feature && self.feature._folders) {
            result = self.feature._folders;
        }
        return result;
    };

    TC.wrap.Feature.prototype.getBounds = function () {
        var result = null;
        var self = this;
        if (self.feature) {
            result = self.feature.getGeometry().getExtent();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getTemplate = function () {
        var result = null;
        var self = this;
        var style = self.feature.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(self.feature);
        }
        if (Array.isArray(style)) {
            for (var i = 0; i < style.length; i++) {
                if (style[i]._balloon) {
                    var s = style[i]._balloon.getText();
                    if (s) {
                        style = style[i]._balloon;
                        break;
                    }
                }
            }
        }
        if (style && !Array.isArray(style) && style.getText) {
            result = style.getText();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getData = function () {
        var self = this;
        var result = self.feature.getProperties();
        // En caso de clusters
        if (Array.isArray(result.features)) {
            if (result.features.length === 1) {
                result = result.features[0].getProperties();
            }
            else {
                result = result.features.length + ' elementos';
            }
        }
        var geometryName = self.feature.getGeometryName();
        if (result[geometryName]) {
            delete result[geometryName];
        }
        return result;
    };

    TC.wrap.Feature.prototype.setData = function (data) {
        this.feature.setProperties(data);
    };

    TC.wrap.Feature.prototype.clearData = function () {
        const feature = this.feature;
        const geometryName = feature.getGeometryName();
        feature.getKeys().forEach(function (key) {
            if (key !== geometryName) {
                feature.unset(key);
            }
        });
    };

    TC.wrap.control.Draw.prototype.mouseMoveHandler = function (evt) {
        const self = this;
        if (self.sketch) {
            self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());
        }
    };

    TC.wrap.control.Draw.prototype.mouseOverHandler = function (evt) {
        const self = this;
        if (self.sketch && self.hoverCoordinate) {
            self.pushCoordinate(self.hoverCoordinate);
            self.hoverCoordinate = null;
        }
    };

    TC.wrap.control.Draw.prototype.clickHandler = function (evt) {
        const self = this;
        if (self.parent.map.view === TC.Consts.view.PRINTING) {
            return;
        }
        if (self._mdPx) { // No operamos si el clic es consecuencia es en realidad un drag
            const dx = self._mdPx[0] - evt.clientX;
            const dy = self._mdPx[1] - evt.clientY;
            if (dx * dx + dy * dy > self.interaction.squaredClickTolerance_) {
                return;
            }
        }
        if (self.sketch) {
            var coords = self.sketch.getGeometry().getCoordinates();
            self.parent.trigger(TC.Consts.event.POINT, {
                point: coords[coords.length - 1]
            });
        }
    };

    TC.wrap.control.Draw.prototype.mousedownHandler = function (evt) {
        const self = this;
        self._mdPx = [evt.clientX, evt.clientY];
    };

    TC.wrap.control.Draw.prototype.getMeasureData = function () {
        var self = this;

        var formatLength = function (line, data) {
            line = new ol.geom.LineString(TC.Util.reproject(line.getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs));
            data.length = line.getLength();
        };

        var formatArea = function (polygon, data) {
            polygon = new ol.geom.Polygon([TC.Util.reproject(polygon.getLinearRing(0).getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs)]);
            data.area = polygon.getArea();
            var ring = polygon.getLinearRing(0);
            data.perimeter = ol.geom.flat.linearRingLength(ring.flatCoordinates, 0, ring.flatCoordinates.length, ring.stride);
        };

        var result = {
            units: ol.proj.Units.METERS
        };
        if (this.sketch) {
            var geom = (this.sketch.getGeometry());
            if (geom instanceof ol.geom.Polygon) {
                formatArea(geom, result);
            }
            else if (geom instanceof ol.geom.LineString) {
                formatLength(geom, result);
            }
        }

        return result;
    };

    // Función para reproyectar el dibujo actual
    const drawProjectionChangeHandler = function (ctl, e) {
        if (ctl.sketch) {
            const oldProj = e.oldValue.getProjection();
            const newProj = e.target.get(e.key).getProjection();
            if (oldProj.getCode() !== newProj.getCode()) {
                const geom = ctl.sketch.getGeometry();
                geom.transform(oldProj, newProj);
                ctl.interaction.sketchPoint_.getGeometry().transform(oldProj, newProj);
                const flatCoordinates = [];
                var sketchCoords;
                if (ctl.interaction.getMode() === 'Polygon') {
                    sketchCoords = ctl.interaction.sketchCoords_[0];
                }
                else {
                    sketchCoords = ctl.interaction.sketchCoords_;
                }
                ol.geom.flat.deflateCoordinates(flatCoordinates, 0, sketchCoords, geom.stride);
                const transformFn = ol.proj.getTransform(oldProj, newProj);
                transformFn(flatCoordinates, flatCoordinates, geom.stride);
                sketchCoords = ol.geom.flat.inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, geom.stride);
                if (ctl.interaction.getMode() === 'Polygon') {
                    ctl.interaction.sketchCoords_ = [sketchCoords];
                }
                else {
                    ctl.interaction.sketchCoords_ = sketchCoords;
                }
            }
        }
    };

    TC.wrap.control.Draw.prototype.activate = function (mode) {
        var self = this;

        var type;
        switch (mode) {
            case TC.Consts.geom.POLYGON:
                type = ol.geom.GeometryType.POLYGON;
                break;
            case TC.Consts.geom.POINT:
                type = ol.geom.GeometryType.POINT;
                break;
            default:
                type = ol.geom.GeometryType.LINE_STRING;
                break;
        }
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (layer) {
                    layer.wrap.getLayer().then(function (olLayer) {

                        if (!self.viewport) self.viewport = olMap.getViewport();

                        if (self.interaction) {
                            olMap.removeInteraction(self.interaction);
                            if (self._mousedownHandler) {
                                self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                                self._mousedownHandler = null;
                            }
                            if (self._clickHandler) {
                                self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                                self._clickHandler = null;
                            }
                            if (self._mouseMoveHandler && self._mouseOverHandler) {
                                self.viewport.removeEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.removeEventListener(MOUSEOVER, self._mouseOverHandler);
                            }
                        }

                        if (self.snapInteraction) {
                            olMap.removeInteraction(self.snapInteraction);
                        }

                        if (mode) {
                            self._mousedownHandler = self.mousedownHandler.bind(self);
                            self._clickHandler = self.clickHandler.bind(self);
                            self.viewport.addEventListener('mousedown', self._mousedownHandler);
                            self.viewport.addEventListener(TC.Consts.event.CLICK, self._clickHandler);
                            if (self.parent.measure) {
                                self._mouseMoveHandler = self.mouseMoveHandler.bind(self);
                                self._mouseOverHandler = self.mouseOverHandler.bind(self);
                                self.viewport.addEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.addEventListener(MOUSEOVER, self._mouseOverHandler);
                            }

                            var drawOptions = {
                                type: type,
                                snapTolerance: 0,
                                condition: function () {
                                    if (ol.events.condition.shiftKeyOnly(arguments[0])) {
                                        hole = olMap.forEachFeatureAtPixel(olMap.getPixelFromCoordinate(arguments[0].coordinate), function (feature) {
                                            if (ol.geom.GeometryType.POLYGON == feature.getGeometry().getType() ||
                                                ol.geom.GeometryType.MULTI_POLYGON == feature.getGeometry().getType()) {
                                                return feature;
                                            }
                                            return null;
                                        },
                                            {
                                                hitTolerance: hitTolerance
                                            });
                                    }

                                    if (self.parent.map.view === TC.Consts.view.PRINTING) {
                                        return null;
                                    }

                                    return true;
                                }
                            };
                            if (olLayer) {
                                drawOptions.source = olLayer.getSource();
                            }
                            switch (mode) {
                                case TC.Consts.geom.RECTANGLE:
                                    drawOptions.style = createNativeStyle({
                                        styles: { line: self.parent.styles.line }
                                    });
                                    drawOptions.type = ol.geom.GeometryType.LINE_STRING;
                                    drawOptions.maxPoints = 2;
                                    drawOptions.geometryFunction = function (coordinates, geometry) {
                                        const start = coordinates[0];
                                        const end = coordinates[1];
                                        const newCoords = [[start, [start[0], end[1]], end, [end[0], start[1]], start]];
                                        if (geometry) {
                                            geometry.setCoordinates(newCoords);
                                        }
                                        else {
                                            geometry = new ol.geom.Polygon(newCoords);
                                        }
                                        return geometry;
                                    };
                                    break;
                                case TC.Consts.geom.POLYGON:
                                    drawOptions.style = createNativeStyle({
                                        styles: { polygon: self.parent.styles.polygon }
                                    });
                                    break;
                                case TC.Consts.geom.POINT:
                                    drawOptions.style = createNativeStyle({
                                        styles: { point: self.parent.styles.point }
                                    });
                                    break;
                                default:
                                    drawOptions.style = createNativeStyle({
                                        styles: { line: self.parent.styles.line }
                                    });
                                    break;
                            }

                            self.interaction = new ol.interaction.Draw(drawOptions);

                            self.interaction.on('drawstart', function (evt) {
                                self.sketch = evt.feature;
                                self.parent.trigger(TC.Consts.event.DRAWSTART);
                            }, this);

                            self.interaction.on('drawend', function (evt) {
                                evt.feature.setStyle(evt.target.overlay_.getStyle().map(function (style) {
                                    return style.clone();
                                }));
                                if (self.parent.measure) {
                                    self.parent.trigger(TC.Consts.event.MEASURE, self.getMeasureData());
                                }
                                createFeatureFromNative(self.sketch).then(function (feat) {
                                    self.parent.trigger(TC.Consts.event.DRAWEND, { feature: feat });
                                    self.sketch = null;
                                });
                            }, this);

                            self._projectionChangeHandler = function (e) {
                                drawProjectionChangeHandler(self, e);
                            };
                            olMap.on('change:view', self._projectionChangeHandler);

                            olMap.addInteraction(self.interaction);

                            if (self.parent.snapping) {
                                var snapOptions = {};
                                if (olLayer) {
                                    snapOptions.source = olLayer.getSource();
                                }
                                else if (self.parent.snapping instanceof TC.Layer) {
                                    snapOptions.source = self.parent.snapping.wrap.layer.getSource();
                                }
                                self.snapInteraction = new ol.interaction.Snap(snapOptions);
                                olMap.addInteraction(self.snapInteraction);
                            }
                        }

                        self.redoStack = [];
                    });
                }
            });
        }
    };

    TC.wrap.control.Draw.prototype.deactivate = function () {
        var self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (self.viewport) {
                    if (self._mousedownHandler) {
                        self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                        self._mousedownHandler = null;
                    }
                    if (self._clickHandler) {
                        self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                        self._clickHandler = null;
                    }
                }
                if (layer && !self.parent.persistent) {
                    layer.clearFeatures();
                }
                if (self.interaction) {
                    olMap.removeInteraction(self.interaction);
                    self.interaction = null;
                }
                olMap.un('change:view', self._projectionChangeHandler);
            });
        }
    };

    //El valor devuelto es lo que va al stack de redo
    TC.wrap.control.Draw.prototype.popCoordinate = function () {
        var self = this;
        var result = null;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                }
                else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                if (coords.length > 1) {

                    var puntos;
                    if (geom instanceof ol.geom.Polygon)
                        puntos = self.interaction.sketchCoords_[0];
                    else if (geom instanceof ol.geom.LineString)
                        puntos = self.interaction.sketchCoords_;

                    /*
                    Al menos con linestring, no necesariamente hay que quitar el último
                    Porque OL mete en coordinates del sketchFeature_ tanto el último marcado como el que flota detrás del cursor
                    Para comprobar que realmente es ése, podemos contrastarlo con self.interaction.sketchPoint_.getGeometry().getCoordinates()
                    */
                    var flyingPointContained = false;
                    if (self.interaction.sketchPoint_) {
                        var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                        for (var i = 0; i < coords.length; i++) {
                            if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                                flyingPointContained = true;
                                break;
                            }
                        }
                    }

                    var index;
                    if (flyingPointContained) index = puntos.length - 2;
                    else index = puntos.length - 1;

                    result = puntos[index];
                    puntos.splice(index, 1);

                    if (geom instanceof ol.geom.Polygon) {
                        geom.setCoordinates([puntos]);
                        self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    }
                    else {
                        geom.setCoordinates(puntos);
                    }


                    feature.setGeometry(geom);
                }
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.pushCoordinate = function (coord) {
        var self = this;
        var result = false;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                } else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                //coords.push(coord);

                var puntos;
                if (geom instanceof ol.geom.Polygon) {
                    puntos = self.interaction.sketchCoords_[0];
                    //self.interaction.sketchCoords_[0].push(coord);
                    //geom.setCoordinates([fullCoords], ol.geom.GeometryLayout.XY);
                } else if (geom instanceof ol.geom.LineString) {

                    puntos = self.interaction.sketchCoords_;
                }

                //Si hay punto volador, hay que meter la coordenada justo antes
                var flyingPointContained = false;
                if (self.interaction.sketchPoint_) {
                    var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                    for (var i = 0; i < coords.length; i++) {
                        if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                            flyingPointContained = true;
                            break;
                        }
                    }
                }


                if (flyingPointContained) index = puntos.length - 1;
                else index = puntos.length;
                puntos.splice(index, 0, coord);

                if (geom instanceof ol.geom.LineString)
                    geom.setCoordinates(puntos, ol.geom.GeometryLayout.XY);
                else {
                    geom.setCoordinates([puntos], ol.geom.GeometryLayout.XY);
                    self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    //feature.setGeometry(geom);
                }


                result = true;
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.undo = function () {
        var self = this;
        var result = false;

        var coord = self.popCoordinate();
        if (coord) {
            self.redoStack.push(coord);
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.redo = function () {
        var self = this;
        var result = false;

        if (self.redoStack.length > 0) {
            self.pushCoordinate(self.redoStack.pop());
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.end = function () {
        var self = this;
        if (self.interaction && self.interaction.sketchFeature_)
            self.interaction.finishDrawing();
    };

    TC.wrap.control.Draw.prototype.setStyle = function (style) {
        const self = this;
        if (self.interaction) {
            self.interaction.overlay_.setStyle(createNativeStyle({
                styles: style
            }));
        }
    };

    TC.wrap.control.CacheBuilder.prototype.getRequestSchemas = function (options) {
        var self = this;
        var extent = options.extent;
        var layers = options.layers;
        var result = new Array(layers.length);
        for (var i = 0, len = result.length; i < len; i++) {
            var layer = layers[i];
            var schema = {
                layerId: layer.id
            };
            var olSource = layer.wrap.layer.getSource();
            if (olSource.getUrls) {
                schema.url = olSource.getUrls()[0];
            }
            if (olSource.getTileGrid) {
                var tileGrid = olSource.getTileGrid();
                var resolutions = tileGrid.getResolutions();
                var matrixIds = tileGrid.getMatrixIds();
                var node = layer.getLayerNodeByName(layer.layerNames);
                var tmsLimits = null;
                for (var j = 0, llen = node.TileMatrixSetLink.length; j < llen; j++) {
                    var tmsl = node.TileMatrixSetLink[j];
                    if (tmsl.TileMatrixSet === layer.matrixSet) {
                        tmsLimits = tmsl.TileMatrixSetLimits;
                        break;
                    }
                }
                schema.tileMatrixLimits = [];
                for (var j = 0, rlen = resolutions.length; j < rlen; j++) {
                    var origin = tileGrid.getOrigin(j);
                    var tileSize = tileGrid.getTileSize(j);
                    var resolution = resolutions[j];
                    var unitsPerTile = tileSize * resolution;
                    var tml = {
                        mId: matrixIds[j],
                        res: resolution,
                        origin: origin,
                        tSize: tileSize,
                        cl: Math.floor((extent[0] - origin[0]) / unitsPerTile),
                        cr: Math.floor((extent[2] - origin[0]) / unitsPerTile),
                        rt: Math.floor((origin[1] - extent[3]) / unitsPerTile),
                        rb: Math.floor((origin[1] - extent[1]) / unitsPerTile)
                    }
                    if (tmsLimits) {
                        var tmsLimit = tmsLimits[j];
                        if (tmsLimit) {
                            tml.cl = Math.max(tml.cl, tmsLimit.MinTileCol);
                            tml.cr = Math.min(tml.cr, tmsLimit.MaxTileCol);
                            tml.rt = Math.max(tml.rt, tmsLimit.MinTileRow);
                            tml.rb = Math.min(tml.rb, tmsLimit.MaxTileRow);
                        }
                    }
                    if (tml.cl <= tml.cr && tml.rt <= tml.rb) {
                        schema.tileMatrixLimits.push(tml);
                    }
                }
            }
            result[i] = schema;
        }
        return result;
    };

    TC.wrap.control.CacheBuilder.prototype.getGetTilePattern = function (layer) {
        var result = "";
        var olSource = layer.wrap.layer.getSource();
        if (olSource.getUrls) {
            result = olSource.getUrls()[0];
        }
        if (layer.options.encoding !== TC.Consts.WMTSEncoding.RESTFUL) {
            if (result.indexOf('?') < 0) {
                result = result + '?';
            }
            if (result.indexOf('?') === result.length - 1) {
                result = result + 'layer=' + layer.layerNames + '&style=default&tilematrixset=' + encodeURIComponent(layer.matrixSet) +
                    '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + encodeURIComponent(layer.format) +
                    '&TileMatrix={TileMatrix}&TileCol={TileCol}&TileRow={TileRow}';
            }
        }
        return result;
    };

    const createHaloStroke1 = function (width) {
        return new ol.style.Stroke({
            color: '#ffffff',
            width: width + 4,
        });
    };

    const createHaloStroke2 = function (width) {
        return new ol.style.Stroke({
            color: '#000000',
            width: width + 6,
        });
    };

    const addHaloToStyle = function (style) {
        if (style === undefined) {
            style = [];
        }
        if (style instanceof ol.style.Style) {
            style = [style];
        }
        style = style.slice();
        const mainStyle = style[0];
        if (mainStyle) {
            const image = mainStyle.getImage();
            var strokeWidth;
            if (image instanceof ol.style.RegularShape) {
                strokeWidth = image.getStroke().getWidth();
                const radius = image.getRadius();
                const haloPart1 = mainStyle.clone();
                haloPart1.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(haloPart1);
                const haloPart2 = mainStyle.clone();
                haloPart2.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke2(strokeWidth)
                }));
                style.unshift(haloPart2);
            }
            const stroke = mainStyle.getStroke();
            if (stroke) {
                strokeWidth = stroke.getWidth();
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke2(strokeWidth)
                }));
            }
            return style;
        }
        return null;
    };

    const createSelectedStyle = function (feat) {
        feat._originalStyle = feat._originalStyle || feat.getStyle();
        if (TC.Util.isFunction(feat._originalStyle)) {
            return function (f, r) {
                return addHaloToStyle(feat._originalStyle(f, r));
            };
        }
        return addHaloToStyle(feat._originalStyle);
    };

    const setSelectedStyle = function (feat) {
        updateSelectedStyle.call(feat);
        feat.changed();
        ol.events.listen(feat, CHANGE, updateSelectedStyle, feat);
    };

    const removeSelectedStyle = function (feat) {
        ol.events.unlisten(feat, CHANGE, updateSelectedStyle, feat);
        if (feat._originalStyle) {
            feat.setStyle(null);
            feat.setStyle(feat._originalStyle);
        }
        feat._originalStyle = null;
    };

    const updateSelectedStyle = function () {
        this.style_ = createSelectedStyle(this);
        this.styleFunction_ = !this.style_ ? undefined : ol.Feature.createStyleFunction(this.style_);
    };

    TC.wrap.control.Modify.prototype.activate = function () {
        const self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.layer.wrap.getLayer()]).then(function (olObjects) {
                const olMap = olObjects[0];
                const olLayer = olObjects[1];
                if (self.selectInteraction) {
                    olMap.removeInteraction(self.selectInteraction);
                }
                var select = new ol.interaction.Select({
                    layers: [olLayer],
                    hitTolerance: hitTolerance
                });
                self.selectInteraction = select;
                olMap.addInteraction(select);
                var getWrapperFeature = function (elm) {
                    return elm._wrap.parent;
                };
                select.on('select', function (event) {
                    if (event.selected.length > 0) {
                        self.parent.trigger(TC.Consts.event.FEATURESSELECT, { ctrl: self, features: event.selected.map(getWrapperFeature) });
                    }
                    if (event.deselected.length > 0) {
                        if (event.selected.length == 0) {
                            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, features: event.deselected.map(getWrapperFeature) });
                        }
                    }
                });
                if (self.modifyInteraction) {
                    olMap.removeInteraction(self.modifyInteraction);
                }
                var modify = new ol.interaction.Modify({
                    features: select.getFeatures()
                });
                modify.on('modifyend', function (e) {
                    e.features.forEach(function (feature) {
                        feature._wrap.parent.geometry = feature._wrap.getGeometry();
                        self.parent.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature._wrap.parent, layer: self.parent.layer });
                    });
                });
                self.modifyInteraction = modify;
                olMap.addInteraction(modify);

                if (self.snapInteraction) {
                    olMap.removeInteraction(self.snapInteraction);
                }
                if (self.parent.snapping) {
                    self.snapInteraction = new ol.interaction.Snap({
                        source: olLayer.getSource()
                    });
                    olMap.addInteraction(self.snapInteraction);
                }

                if (!self._onMouseMove) {
                    self._onMouseMove = function (e) {
                        const mapTarget = olMap.getTarget();
                        var hit = false;
                        var feature;

                        var pixel = olMap.getEventPixel(e);
                        hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                            if (layer === self.parent.layer.wrap.layer) {
                                return true;
                            }
                            return false;
                        },
                            {
                                hitTolerance: hitTolerance
                            });

                        if (hit) {
                            mapTarget.style.cursor = 'pointer';
                        } else {
                            mapTarget.style.cursor = '';
                            //self.parent.trigger(TC.Consts.event.FEATUREOUT);
                        }
                    };
                }

                olMap.getViewport().addEventListener(MOUSEMOVE, self._onMouseMove);
            });
        }
    };

    TC.wrap.control.Modify.prototype.deactivate = function () {
        const self = this;
        if (self.modifyInteraction) {
            self.modifyInteraction.setActive(false);
            self.selectInteraction.setActive(false);
            self.parent.map.wrap.getMap().then(function (olMap) {
                olMap.getViewport().removeEventListener(MOUSEMOVE, self._onMouseMove);
                olMap.removeInteraction(self.modifyInteraction);
                olMap.removeInteraction(self.selectInteraction);
                self.modifyInteraction = null;
                self.selectInteraction = null;
            });
        }
    };

    TC.wrap.control.Modify.prototype.getSelectedFeatures = function () {
        var self = this;
        var result = [];
        if (self.selectInteraction) {
            self.selectInteraction.getFeatures().forEach(function (elm) {
                result[result.length] = elm._wrap.parent;
            });
        }
        return result;
    };

    TC.wrap.control.Modify.prototype.setSelectedFeatures = function (features) {
        var self = this;
        if (self.selectInteraction) {
            var source = self.selectInteraction.featureOverlay_.getSource();
            source.clear();
            source.addFeatures(features.map(function (elm) {
                return elm.wrap.feature;
            }));
        }
    };

    TC.wrap.control.Modify.prototype.unselectFeatures = function (features) {
        features = features || [];
        const self = this;
        const selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
        if (selectedFeatures) {
            const unselectedFeatures = [];
            selectedFeatures.getArray().slice().forEach(function (olFeature) {
                if (!features.length || features.indexOf(olFeature) >= 0) {
                    selectedFeatures.remove(olFeature);
                    unselectedFeatures[unselectedFeatures.length] = olFeature._wrap.parent;
                }
            });
            if (unselectedFeatures.length) {
                self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { features: unselectedFeatures });
            }
        }
    };

    TC.wrap.control.Edit.prototype.activate = function (mode) {
        var self = this;
        self.cancel(true);
        //if (!self.session) {
        //    self.session = {
        //        features: []
        //        , featuresAdded: []
        //        , featuresRemoved: []
        //        , featuresModified: []
        //    };
        //}
        if (mode === TC.Consts.editMode.SELECT) {
            TC.wrap.control.Modify.prototype.activate.call(self);
        }
    };

    TC.wrap.control.Edit.prototype.deactivate = function () {
        var self = this;
        TC.wrap.control.Modify.prototype.deactivate.call(self);

        if (self.drawInteraction) {
            self.drawInteraction.abortDrawing_();
            self.drawInteraction.setActive(false);
            //self.drawInteraction.destroy();
            self.parent.map.wrap.getMap().then(function (olMap) {
                olMap.removeInteraction(self.drawInteraction);
                self.drawInteraction = null;
            });
            //    self.control.layer.events.un("sketchcomplete");
            //    self.control.deactivate();
            //    self.control.destroy();
            //    self.control = null;
        }
        self.parent.trigger(TC.Consts.event.CONTROLDEACTIVATE, { ctrl: self });
        //self.session = null;        
    };

    TC.wrap.control.Edit.prototype.cancel = function (deactivate, cancelTxt) {
        var self = this;
        self.points = [];
        self.histPoints = [];
        var layer = (self.control && self.control.layer) || (self.modifyInteraction && self.modifyInteraction.layer);
        //if (!self.session || ((self.modifyInteraction && self.modifyInteraction.modified) || (self.session.featuresAdded && self.session.featuresAdded.length)) && cancelTxt && !confirm(cancelTxt))
        //    return;
        if (self.selectInteraction) {
            var features = self.selectInteraction.getFeatures();
            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, feature: features.get(0) });
            features.clear();
            self.selectInteraction.setActive(false);
        }
        //if (self.drawInteraction) {
        //    self.drawInteraction.abortDrawing_();
        //    if (deactivate) {
        //        self.drawInteraction.setActive(false);
        //    }
        //}
        //if(self.modifyInteraction)
        //{
        //    if (self.modifyInteraction.feature)
        //        self.modifyInteraction.unselectFeature(self.modifyInteraction.feature);
        //    if (deactivate)
        //    {
        //        self.modifyInteraction.deactivate();
        //    }   
        //}
        ////if (self.session.featuresAdded && self.session.featuresAdded.length > 0) {
        ////    layer.removeFeatures(self.session.featuresAdded);
        ////    self.session.featuresAdded = [];
        ////}
        //self.parent.trigger(TC.Consts.event.EDITIONCANCEL, { ctrl: self });
        ////no se por que hostias se cambia el renderIntent a las features
        //layer.features.forEach(function (feat) {
        //    feat.renderIntent = "";
        //});    
        //layer.removeAllFeatures();
        //layer.addFeatures(self.session.features);        
        //self.clearSession();
    };

    TC.wrap.control.Edit.prototype.getSelectedFeatures = function () {
        return TC.wrap.control.Modify.prototype.getSelectedFeatures.call(this);
    };

    TC.wrap.control.Edit.prototype.setSelectedFeatures = function (features) {
        TC.wrap.control.Modify.prototype.setSelectedFeatures.call(this, features);
    };

    TC.wrap.control.Edit.prototype.deleteFeatures = function (features) {
        var self = this;
        if (Array.isArray(features)) {
            var olFeatures = features.map(function (elm) {
                return elm.wrap.feature;
            });
            self.parent.layer.wrap.getLayer().then(function (olLayer) {
                var selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
                for (var i = 0, len = olFeatures.length; i < len; i++) {
                    var olFeature = olFeatures[i];
                    if (selectedFeatures) {
                        selectedFeatures.remove(olFeature);
                        self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { feature: olFeature._wrap.parent });
                    }
                    olLayer.getSource().removeFeature(olFeature);
                    self.parent.trigger(TC.Consts.event.FEATUREREMOVE, { feature: olFeature._wrap.parent });
                }
            });
        }
    };

    //TC.wrap.control.Edit.prototype.clearSession = function () {
    //    var self = this;
    //    delete self.session;
    //};

    TC.wrap.Feature.prototype.toGML = function (version, srsName) {
        var parser = new ol.format.GML({
            srsName: srsName
        });
        var xml = parser.writeGeometryNode(this.feature.getGeometry());
        //reemplazo todos los <loquesea por <gml:loquesea y </loquesea por </gml:loquesea
        return new XMLSerializer().serializeToString(xml.firstChild).replace(/\<\/?\w/gm, function (str) { var pos = str.indexOf("/") > 0 ? str.indexOf("/") + 1 : 1; return str.substring(0, pos) + "gml:" + str.substring(pos) })
        //return new XMLSerializer().serializeToString(xml.firstChild).replace(/\</gm, "<gml:");
    };


    TC.wrap.Feature.prototype.toGeoJSON = function () {
        var parser = new ol.format.GeoJSON();
        return parser.writeGeometry(this.feature.getGeometry());
    };

    TC.wrap.Geometry.write = function (options) {
        options = options || {};
        var geometry;
        switch (options.format) {
            default:
                options.parser = new ol.format.GeoJSON();
        };
        switch (options.type) {
            case TC.Consts.geom.POLYLINE:
                geometry = new ol.geom.LineString(options.coordinates);
                break;
            case TC.Consts.geom.POLYGON:
                geometry = new ol.geom.Polygon(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOINT:
                geometry = new ol.geom.MultiPoint(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYLINE:
                geometry = new ol.geom.MultiLineString(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYGON:
                geometry = new ol.geom.MultiPolygon(options.coordinates);
                break;
            case TC.Consts.geom.POINT:
            default:
                geometry = new ol.geom.Point(options.coordinates);
                break;
        };
        return options.parser.writeGeometry(geometry);
    };

    TC.wrap.Geometry.toGeoJSON = function (options) {
        return TC.wrap.Geometry.write(options);
    };

    return ol;
});

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Attribution = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self.apiAttribution = '';
    self.mainDataAttribution = null;
    self.dataAttributions = [];
    if (self.options.dataAttributions) {
        self.dataAttributions = self.options.dataAttributions instanceof Array ? self.options.dataAttributions : [self.options.dataAttributions];
    }
};

TC.inherit(TC.control.Attribution, TC.Control);

(function () {
    var ctlProto = TC.control.Attribution.prototype;

    ctlProto.CLASS = 'tc-ctl-attrib';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Attribution.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div><span>&copy; ").f(ctx.get(["api"], false), ctx, "h", ["s"]).w("</span>").x(ctx.get(["mainData"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["otherData"], false), ctx, { "block": body_5 }, {}).w("<div class=\"tc-ctl-attrib-other ").x(ctx.get(["isCollapsed"], false), ctx, { "block": body_6 }, {}).w("\">").s(ctx.get(["otherData"], false), ctx, { "block": body_7 }, {}).w("</div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" - ").h("i18n", ctx, {}, { "$key": "data" }).w(":").x(ctx.getPath(false, ["mainData", "site"]), ctx, { "else": body_2, "block": body_4 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.x(ctx.getPath(false, ["mainData", "name"]), ctx, { "block": body_3 }, {}); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<span> &copy; ").f(ctx.getPath(false, ["mainData", "name"]), ctx, "h").w("</span>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<span> &copy; <a href=\"").f(ctx.getPath(false, ["mainData", "site"]), ctx, "h").w("\" target=\"_blank\">").f(ctx.getPath(false, ["mainData", "name"]), ctx, "h").w("</a></span>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w(" - <span class=\"tc-ctl-attrib-cmd\">").h("i18n", ctx, {}, { "$key": "others" }).w("...</span>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w(" tc-collapsed "); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.x(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "site"]), ctx, { "else": body_8, "block": body_9 }, {}).h("sep", ctx, { "block": body_10 }, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<span>&copy; ").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "name"]), ctx, "h").w("</span>"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("<span>&copy; <a href=\"").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "site"]), ctx, "h").w("\" target=\"_blank\">").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "name"]), ctx, "h").w("</a></span>"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.w(", "); } body_10.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.apiAttribution = self.map.options.attribution || self.apiAttribution;

        var addData = function (obj) {
            if (obj) {
                // TODO: sanitizer
                var attr = obj.getAttribution();
                if (attr) {
                    if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                        self.mainDataAttribution = {
                            name: 'IDENA',
                            site: 'http://idena.navarra.es/'
                        };
                    }
                    else {
                        var textExists = false;
                        for (var i = 0; i < self.dataAttributions.length; i++) {
                            if (attr.name === self.dataAttributions[i].name) {
                                textExists = true;
                                break;
                            }
                        }
                        if (!textExists) {
                            self.dataAttributions.push(attr);
                        }
                    }
                }
            }
        };

        var removeData = function (obj) {
            if (obj) {

                var checkRemoveData = function () {
                    if (obj.map.workLayers.length > 0) {
                        var _wl = obj.map.workLayers.slice().reverse();
                        for (var i = 0; i < _wl.length; i++) {
                            if (_wl[i].url == obj.url && _wl[i].getVisibility())
                                return false;
                        }

                        return true;
                    }

                    return true;
                };

                if (obj instanceof TC.Layer ? checkRemoveData() : true) {
                    // TODO: sanitizer
                    var attr = obj.getAttribution();

                    if (attr) {
                        var index = self.dataAttributions.reduce(function (prev, cur, idx) {
                            if (cur.name === attr.name) {
                                return idx;
                            }
                            return prev;
                        }, -1);

                        const checkIsSameAttribution = function (toCheckName) {
                            return (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) &&
                                (/IDENA/.test(toCheckName) || /Tracasa Instrumental/.test(toCheckName)) ||
                                    (attr.name === toCheckName);
                        };

                        // Validamos si las atribuciones a borrar son también del mapa base
                        if (self.map.baseLayer && self.map.baseLayer.wrap.getAttribution() && checkIsSameAttribution(self.map.baseLayer.wrap.getAttribution().name)) {
                            return;
                        } else {
                            // Validamos si las atribuciones a borrar son también de alguna de las capas raster cargadas
                            if (self.map.workLayers.filter(function (layer) {
                                return layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS;
                            }).some(function (layer) {
                                var workLayerAttribution = layer.wrap.getAttribution();
                                return workLayerAttribution && checkIsSameAttribution(workLayerAttribution.name);
                            })) {
                                return;
                            }
                        }

                        if (index > -1) {
                            self.dataAttributions.splice(index, 1);
                        } else if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                            self.mainDataAttribution = null;
                        }
                    }
                }
            }
        };

        self.render();

        map.loaded(function () {
            if (map.baseLayer.wrap.getAttribution) {
                addData(map.baseLayer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (!layer.isBase && layer.wrap.getAttribution) {
                addData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.BEFOREBASELAYERCHANGE + " " + TC.Consts.event.OVERVIEWBASELAYERCHANGE, function (e) {
            const type = e.type;
            const newLayer = e.newLayer;
            const oldLayer = e.oldLayer;
            if (TC.Consts.event.OVERVIEWBASELAYERCHANGE.indexOf(type) > -1) {
                self.ignoreLayer = newLayer;
            }

            if (oldLayer && oldLayer.wrap.getAttribution) {
                removeData(oldLayer.wrap);
            }

            if (newLayer && newLayer.wrap.getAttribution) {
                addData(newLayer.wrap);
            }

            self.render();
        });

        map.on(TC.Consts.event.LAYERREMOVE, function (e) {
            const layer = e.layer;
            if (layer.wrap.getAttribution) {
                removeData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERADD, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                addData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERREMOVE, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                removeData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
            const layer = e.layer;
            if (self.ignoreLayer === layer) {
                return;
            }

            if (layer.wrap.getAttribution) {
                if (layer.getVisibility()) {
                    addData(layer.wrap);
                } else {
                    removeData(layer.wrap);
                }
                self.render();
            }
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(self.renderData({
            api: self.apiAttribution,
            mainData: self.mainDataAttribution,
            otherData: self.dataAttributions,
            isCollapsed: self.div.querySelector('.' + self.CLASS + '-other') ? self.div.querySelector('.' + self.CLASS + '-other').classList.contains(TC.Consts.classes.COLLAPSED) : true
        }, function () {
            const cmd = self.div.querySelector('.' + self.CLASS + '-cmd');
            cmd && cmd.addEventListener(TC.Consts.event.CLICK, function () {
                self.toggleOtherAttributions();
            });

            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto.toggleOtherAttributions = function () {
        const self = this;
        const other = self.div.querySelector('.' + self.CLASS + '-other');
        other.classList.toggle(TC.Consts.classes.COLLAPSED);
    };
})();

TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

(function () {

    TC.control.BasemapSelector = function () {
        var self = this;
        //options = options || {};

        TC.control.MapContents.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.tc-modal-close)', function (e) {

            if (e.target.classList.contains(self._cssClasses.LOAD_CRS_BUTTON)) {
                self.loadFallbackProjections();
                return;
            }

            TC.Util.closeModal();
            const btn = e.target;
            const crs = btn.dataset.crsCode;

            // dependerá del que esté activo
            const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
            dialog.classList.add(TC.Consts.classes.HIDDEN);

            const layer = self.getLayer(dialog.dataset.layerId);
            if (layer) {
                if (crs) {
                    TC.loadProjDef({
                        crs: crs,
                        callback: function () {
                            self.map.setProjection({
                                crs: crs,
                                baseLayer: layer
                            });
                        }
                    });
                }
                else {
                    const fallbackLayer = self.getFallbackLayer(btn.dataset.fallbackLayerId);
                    if (fallbackLayer) {
                        self.map.setBaseLayer(fallbackLayer);
                    }
                }
            }
        }));
    };

    TC.inherit(TC.control.BasemapSelector, TC.control.MapContents);

    var ctlProto = TC.control.BasemapSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-bms';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/BasemapSelector.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/BasemapSelectorNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/BasemapSelectorDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "backgroundMaps" }).w("</h2><div class=\"tc-ctl-bms-tree\"><form><ul class=\"tc-ctl-bms-branch\">").s(ctx.get(["baseLayers"], false), ctx, { "block": body_1 }, {}).s(ctx.get(["dialogMore"], false), ctx, { "block": body_2 }, {}).w("</ul></form></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-bms-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<li class=\"tc-ctl-bms-node\"><label class=\"tc-ctl-bms-more-node\" title=\"").h("i18n", ctx, {}, { "$key": "moreBackgroundMaps" }).w("\"><input type=\"radio\" name=\"bms\" value=\"moreLayers\"><span></span></label></li>"); } body_2.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-bms-node\" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\" ><label").x(ctx.get(["legend"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["thumbnail"], false), ctx, { "block": body_2 }, {}).w("><input type=\"radio\" name=\"bms\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["mustReproject"], false), ctx, { "block": body_3 }, {}).w("><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" style=\"background-image: url(").f(ctx.getPath(false, ["legend", "src"]), ctx, "h").w(")\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" style=\"background-image: url(").f(ctx.get(["thumbnail"], false), ctx, "h").w(")\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" class=\"tc-disabled\""); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-bms-more-dialog tc-modal tc-hidden\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "backgroundMaps" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div><div class=\"tc-ctl-bms-crs-dialog tc-modal tc-hidden\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "baseLayerNotCompatible" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "baseLayerNotCompatible.instructions|h" }).w("</p><ul class=\"tc-ctl-bms-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const getClosestParent = function (elm, selector) {
        while (elm && !elm.matches(selector)) {
            elm = elm.parentElement;
        }
        return elm;
    };

    const changeInputRadioBaseMap = function (e, callback) {
        const self = this;
        var flagToCallback = true;

        var radio = e.target;

        var layer = self.getLayer(getClosestParent(radio, 'li').dataset.layerId);

        if (self.options.dialogMore && getClosestParent(radio, '.' + self.CLASS + '-more-dialog')) {
            const radios = self.div.querySelectorAll('input[type=radio]');
            for (var i = 0, len = radios.length; i < len; i++) {
                const bmsLayer = self.getLayer(getClosestParent(radios[i], 'li').dataset.layerId);
                if (bmsLayer) {
                    switch (true) {
                        case bmsLayer.id === layer.id:
                            layer = bmsLayer;
                            break;
                    }
                }
            };
        }

        if (layer != self.map.getBaseLayer()) {
            if (layer.mustReproject) {

                if (self.map.on3DView) {
                    if (!layer.getFallbackLayer()) {
                        self._currentSelection.checked = true;
                        e.stopPropagation();
                        return;
                    } else if (layer.getFallbackLayer()) {
                        const fallbackLayer = layer.getFallbackLayer();
                        if (fallbackLayer) {
                            fallbackLayer._capabilitiesPromise.then(function () {
                                if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                    self.map.setBaseLayer(layer);
                                }
                            });
                        }

                        flagToCallback = true;
                    }
                } else {
                    // provisonal
                    if (self._currentSelection) {
                        self._currentSelection.checked = true;
                    }

                    // Buscamos alternativa
                    const dialogOptions = {
                        layer: layer
                    };
                    const fallbackLayer = layer.getFallbackLayer();
                    if (fallbackLayer) {
                        fallbackLayer._capabilitiesPromise.then(function () {
                            if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                dialogOptions.fallbackLayer = fallbackLayer;
                            }
                            self.showProjectionChangeDialog(dialogOptions);
                        });
                    }
                    else {
                        self.showProjectionChangeDialog(dialogOptions);
                    }
                    //layer.getCompatibleCRS({ normalized: true });
                    flagToCallback = false;
                }

            }
            else {

                if (layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS && layer.getProjection() !== self.map.crs) {
                    layer.setProjection({ crs: self.map.crs });
                }

                self.map.setBaseLayer(layer);
            }
        }

        if (this._currentSelection) {
            this._currentSelection.checked = true;
        }


        if (callback) {
            callback(flagToCallback);
        }
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapContents.prototype.register.call(self, map);

        if (self.options.dialogMore) {
            map.on(TC.Consts.event.VIEWCHANGE, function () {
                self._getMoreBaseLayers();
            });
        }

        map.on(TC.Consts.event.BASELAYERCHANGE + ' ' + TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.VIEWCHANGE, function (e) {
            self.update(self.div, e.layer);
        });


        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {

            if (e.target.value === "moreLayers") {
                self.showMoreLayersDialog();
            } else {
                changeInputRadioBaseMap.call(self, e);
            }

            e.stopPropagation();
        }));

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.control.MapContents.prototype.render.call(self, callback, self.options);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;

            if (self.options.dialogMore) {
                const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

                dialog.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {
                    changeInputRadioBaseMap.call(self, e, function (close) {
                        if (close) {
                            TC.Util.closeModal();
                        }
                    });

                    e.stopPropagation();
                }));
            }
        });

        return result;
    };

    ctlProto.update = function (div, baseLayer) {
        const self = this;

        div = div || self.div;

        div.querySelector('ul.' + self.CLASS + '-branch').querySelectorAll('li').forEach(function (li) {
            const layer = self.getLayer(li.dataset.layerId);
            if (layer) {
                const curBaseLayer = baseLayer || self.map.baseLayer;
                const radio = li.querySelector('input[type=radio]');
                const checked = curBaseLayer && (curBaseLayer === layer || curBaseLayer.id === layer.id ||
                    (layer.getFallbackLayer && (curBaseLayer === layer.getFallbackLayer() || (layer.getFallbackLayer() && curBaseLayer.id === layer.getFallbackLayer().id))));

                if (self.map.on3DView && layer.mustReproject && layer.fallbackLayer && layer.getFallbackLayer) {
                    layer.getFallbackLayer().getCapabilitiesPromise().then(function () {
                        var mustReproject = !layer.getFallbackLayer().isCompatible(self.map.getCRS());

                        radio.checked = checked;
                        if (mustReproject) {
                            radio.classList.add(TC.Consts.classes.DISABLED);
                            li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                        }
                        else {
                            radio.classList.remove(TC.Consts.classes.DISABLED);
                            li.removeAttribute('title');
                        }
                    });
                } else {
                    radio.checked = checked;
                    if (layer.mustReproject) {
                        radio.classList.add(TC.Consts.classes.DISABLED);
                        li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                    }
                    else {
                        radio.classList.remove(TC.Consts.classes.DISABLED);
                        li.removeAttribute('title');
                    }
                }

                if (checked) {
                    self._currentSelection = radio;
                }
            }
        });

        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        const self = this;        
        if (layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            var template = self.CLASS + '-node';
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(template, self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        var uid = newLi.dataset.layerUid;
                        const ul = self.div.querySelector('.' + self.CLASS + '-branch');
                        const currentLi = ul.querySelector('li[data-layer-uid="' + uid + '"]');
                        if (currentLi) {
                            currentLi.innerHTML = newLi.innerHTML;
                        }
                        else {
                            newLi.dataset.layerId = layer.id;

                            // Insertamos elemento en el lugar correcto, según indica la colección baseLayers
                            var idx = self.map.baseLayers.filter(function (baseLayer) {
                                // Buscamos capas que deban mostrarse o capas que están siendo fallbacks de capas que deben mostrarse
                                return !baseLayer.stealth;
                            }).map(function (baseLayer) {
                                return baseLayer.id;
                            }).indexOf(layer.id);

                            const lis = ul.querySelectorAll('li');
                            if (idx < 0 || idx >= lis.length) {
                                ul.appendChild(newLi);
                            }
                            else {
                                ul.insertBefore(newLi, lis[idx]);
                            }
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // no hace nada
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        if (layer.isBase) {
            const lis = self.div.querySelector('.' + self.CLASS + '-branch').querySelectorAll('li');
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.dataset.layerId === layer.id) {
                    li.parentElement.removeChild(li);
                    break;
                }
            }
        }
    };

    ctlProto.onErrorLayer = function (layer) {
        const self = this;

        if (layer.isBase && !layer.options.stealth) {
            self.map.toast(self.getLocaleString('baseLayerNotAvailable', { mapName: layer.title }), { type: TC.Consts.msgType.ERROR });
        }
    };

    ctlProto.getFallbackLayer = function (id) {
        const self = this;
        const filterFn = function (layer) {
            return layer.fallbackLayer && layer.fallbackLayer.id === id;
        };
        var result = self.map.baseLayers.filter(filterFn)[0].fallbackLayer;
        if (!result && self._moreBaseLayers) {
            result = self._moreBaseLayers.filter(filterFn)[0].fallbackLayer;
        }
        return result;
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        options = options || {};
        const layer = options.layer;
        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.classList.add(TC.Consts.classes.LOADING);
        const blCRSList = layer.getCompatibleCRS();

        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        dialog.dataset.layerId = layer.id;
        const ul = dialog.querySelector('ul.' + self.CLASS + '-crs-list');
        ul.innerHTML = '';
        self.map.loadProjections({
            crsList: self.map.getCompatibleCRS({
                layers: self.map.workLayers.concat(layer),
                includeFallbacks: true
            }),
            orderBy: 'name'
        }).then(function (projList) {
            var hasFallbackCRS = false;
            const fragment = document.createDocumentFragment();
            projList
                .forEach(function (projObj) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');

                    if (blCRSList.filter(function (crs) {
                        return TC.Util.CRSCodesEqual(crs, projObj.code)
                    }).length === 0) {
                        // Es un CRS del fallback
                        hasFallbackCRS = true;

                        button.innerHTML = projObj.name + ' (' + projObj.code + ')';
                        if (options.layer.fallbackLayer) {
                            button.dataset.fallbackLayerId = options.layer.fallbackLayer.id;
                        }
                        button.dataset.crsCode = projObj.code;
                        button.classList.add(TC.Consts.classes.WARNING);
                        li.classList.add(TC.Consts.classes.HIDDEN);
                    } else {
                        button.innerHTML = self.getLocaleString('changeMapToCrs', { crs: projObj.name + ' (' + projObj.code + ')' });
                        button.dataset.crsCode = projObj.code;
                    }

                    li.appendChild(button);
                    fragment.appendChild(li);
                });

            if (options.fallbackLayer) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.innerHTML = self.getLocaleString('reprojectOnTheFly');
                button.dataset.fallbackLayerId = options.fallbackLayer.id;
                li.appendChild(button);
                fragment.appendChild(li);
            }

            if (hasFallbackCRS) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                li.appendChild(button);
                fragment.appendChild(li);
            }
            ul.appendChild(fragment);

            modalBody.classList.remove(TC.Consts.classes.LOADING);
        });
        dialog.querySelector('.' + self.CLASS + '-name').innerHTML = layer.title || layer.name;
        TC.Util.showModal(dialog);
    };

    ctlProto.showMoreLayersDialog = function () {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

        dialog.classList.toggle(TC.Consts.classes.THREED, !!self.map.on3DView);

        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.innerHTML = '';
        modalBody.classList.add(TC.Consts.classes.LOADING);
        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        TC.Util.showModal(dialog, {
            closeCallback: function () {
                // no hay selección, vuelvo a seleccionar el mapa de fondo actual del mapa.
                this._currentSelection.checked = true;
                this.update();
            }.bind(self)
        });

        dialog.querySelector('.tc-modal-window').classList.add(self.CLASS + '-more-dialog');

        self._getMoreBaseLayers().then(function () {

            self.getRenderedHtml(self.CLASS, { baseLayers: self._moreBaseLayers }, function (html) {
                modalBody.innerHTML = html;
                modalBody.classList.remove(TC.Consts.classes.LOADING);
                modalBody.querySelectorAll('li').forEach(function (li, idx) {
                    li.dataset.layerId = self._moreBaseLayers[idx].id;
                });

                self.update(modalBody);
            });
        });
    };

    ctlProto.getLayer = function (id) {
        const self = this;
        return self.map && (self.map.getLayer(id) || (self._moreBaseLayers && self._moreBaseLayers.filter(function (layer) {
            return layer.id === id;
        })[0]));
    };

    const getTo3DVIew = function (baseLayer) {
        const self = this;

        return new Promise(function (resolve, reject) {
            Promise.all([
                baseLayer.getCapabilitiesPromise(),
                baseLayer.getFallbackLayer() ? baseLayer.getFallbackLayer().getCapabilitiesPromise() : Promise.resolve()
            ]).then(function () {
                resolve();
            });
        });
    };

    ctlProto._getMoreBaseLayers = function () {
        const self = this;

        if (!self._moreBaseLayers && !self._moreBaseLayersPromise) {

            self._moreBaseLayersPromise = new Promise(function (resolve, reject) {

                // GLS: Carlos no quiere que se muestren los respectivos dinámicos así que los filtro.
                var noDyn = TC.Cfg.availableBaseLayers.filter(function (l) {
                    return TC.Cfg.availableBaseLayers.filter(function (l) {
                        return l.fallbackLayer
                    }).map(function (l) {
                        return l.fallbackLayer
                    }).indexOf(l.id) == -1
                }).map(function (baseLayer) {
                    if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                        return new TC.layer.Raster(baseLayer);
                    } else if (baseLayer.type == TC.Consts.layerType.VECTOR) {
                        return new TC.layer.Vector(baseLayer);
                    }
                });

                Promise.all(noDyn).then(function (baseLayers) {
                    self._moreBaseLayers = new Array(baseLayers.length);

                    var numToAdd = baseLayers.length;

                    const resolvePromise = function () {
                        self._moreBaseLayers = self._moreBaseLayers.filter(function (baseLayer) {
                            return baseLayer !== null;
                        });

                        resolve(self._moreBaseLayers);
                    };
                    const addLayer = function (i) {
                        const baseLayer = this;

                        baseLayer.map = self.map;
                        baseLayer.isBase = baseLayer.options.isBase = true;

                        if (baseLayer.type === TC.Consts.layerType.WMTS) {
                            var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                            baseLayer.mustReproject = !matrixSet;
                        } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                            baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                        }

                        if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                            baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());
                        }

                        self._moreBaseLayers.splice(i, 1, baseLayer);
                        numToAdd--;

                        if (numToAdd === 0) {
                            resolvePromise();
                        }
                    };

                    baseLayers.forEach(function (baseLayer, i) {
                        if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                            var promise = self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                            promise.then(
                                addLayer.bind(baseLayer, i),
                                function (fail) {
                                    self._moreBaseLayers.splice(i, 1, null);
                                    numToAdd--;

                                    if (numToAdd === 0) {
                                        resolvePromise();
                                    }
                                });
                        } else {
                            addLayer.call(baseLayer, i);
                        }
                    });
                });
            });

        } else if (self._moreBaseLayers) {

            return new Promise(function (resolve, reject) {
                Promise.all(self._moreBaseLayers.filter(function (baseLayer) {
                    return baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS;
                }).map(function (baseLayer) {
                    return self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                })).then(function () {

                    self._moreBaseLayers = self._moreBaseLayers.map(function (baseLayer) {

                        if (baseLayer.type === TC.Consts.layerType.WMTS) {
                            var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                            baseLayer.mustReproject = !matrixSet;
                        } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                            baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                        }
                        if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                            baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());

                            return baseLayer;
                        }

                        return baseLayer;
                    });

                    resolve(self._moreBaseLayers);
                });
            });
        }

        return self._moreBaseLayersPromise;
    };
})();

TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

(function () {

    TC.Consts.classes.CONNECTION_OFFLINE = TC.Consts.classes.CONNECTION_OFFLINE || 'tc-conn-offline';
    TC.Consts.classes.CONNECTION_WIFI = TC.Consts.classes.CONNECTION_WIFI || 'tc-conn-wifi';
    TC.Consts.classes.CONNECTION_MOBILE = TC.Consts.classes.CONNECTION_MOBILE || 'tc-conn-mobile';
    TC.Consts.classes.OFFLINE = TC.Consts.classes.OFFLINE || 'tc-offline';

    var ALREADY_EXISTS = 'already_exists';

    var manifestUrlList;
    var requestManifest = function () {
        return new Promise(function (resolve, reject) {
            if (manifestUrlList && manifestUrlList.length) {
                resolve(manifestUrlList);
            }
            else {
                var manifestFile = document.documentElement.getAttribute('manifest') || 'manifest.appcache';
                if (manifestFile) {
                    TC.ajax({
                        url: manifestFile,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (response) {
                        var data = response.data;
                        TC.loadJS(
                            !window.hex_md5,
                            [TC.apiLocation + TC.Consts.url.HASH],
                            function () {
                                var hash = hex_md5(data);
                                var idxEnd = data.indexOf('NETWORK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('FALLBACK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('SETTINGS:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                var lines = data.split(/[\n\r]/).filter(function (elm) {
                                    return elm.length > 0 && elm.indexOf('#') !== 0 && elm !== 'CACHE:';
                                });
                                // Eliminamos la primera línea porque siempre es CACHE MANIFEST
                                lines.shift();
                                resolve({
                                    hash: hash,
                                    urls: lines
                                });
                            }
                        );
                    }).catch(function () {
                        reject();
                    });
                }
                else {
                    reject();
                }
            }
        });
    };

    TC.control.CacheBuilder = function () {
        var self = this;

        TC.control.SWCacheClient.apply(this, arguments);

        var cs = self._classSelector = '.' + self.CLASS;
        self._selectors = {
            DRAW: cs + '-draw',
            DRAWING: cs + '-drawing',
            PROGRESS: cs + '-progress',
            NEW: cs + '-new',
            LIST: cs + '-list',
            LISTITEM: cs + '-list > li',
            OKBTN: cs + '-btn-ok',
            NEWBTN: cs + '-btn-new',
            SAVEBTN: '.tc-btn-save',
            CANCELBTN: '.tc-btn-cancel',
            EDITBTN: '.tc-btn-edit',
            VIEWBTN: '.tc-btn-view',
            DELETEBTN: '.tc-btn-delete',
            TILECOUNT: cs + '-tile-count',
            NAMETB: cs + '-txt-name',
            TEXTBOX: 'input.tc-textbox',
            EXIT: cs + '-link-exit',
            OFFPANEL: cs + '-off-panel',
            BLLIST: cs + '-bl-list',
            BLLISTITEM: cs + '-bl-list > li',
            BLLISTTEXT: cs + '-bl-panel-txt',
            RNGMAXRES: cs + '-rng-maxres',
            SEARCH: cs + '-map-available-srch',
            EMPTYLIST: cs + '-map-available-empty',
            OFFLINEHIDDEN: '[data-no-cb]'
        };

        self.storedMaps = [];

        const mapDefString = TC.Util.getParameterByName(self.MAP_DEFINITION_PARAM_NAME);
        const extentString = TC.Util.getParameterByName(self.MAP_EXTENT_PARAM_NAME);
        self.mapIsOffline = !!mapDefString;
        if (mapDefString) {
            self.currentMapDefinition = JSON.parse(window.atob(decodeURIComponent(mapDefString)));
        }
        if (extentString) {
            self.currentMapExtent = getExtentFromString(extentString);
        }

        // Comprobación de disponibilidad de localStorage
        try {
            self.localStorage = window.localStorage;
            const key = "__delete_me__";
            self.localStorage.setItem(key, key);
            self.localStorage.removeItem(key);
        }
        catch (e) {
            self.localStorage = null;
            TC.error(self.getLocaleString('couldNotAccessLocalStorage'));
        }

        // Carga de mapas guardados
        if (self.localStorage) {
            for (var i = 0, len = self.localStorage.length; i < len; i++) {
                var key = self.localStorage.key(i);
                if (key.indexOf(self.LOCAL_STORAGE_KEY_PREFIX) === 0 && key !== self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash') {
                    // Es un nombre de mapa y no es el hash de integridad de la cache root
                    var values = self.localStorage.getItem(key).split(" ");
                    var extent = getExtentFromString(values.shift());
                    var name = values.join(" ");
                    var map = {
                        name: name,
                        extent: extent,
                        url: decodeURIComponent(key.substr(self.LOCAL_STORAGE_KEY_PREFIX.length))
                    }
                    self.storedMaps.push(map);
                }
            }
            self.storedMaps.sort(function (a, b) {
                if (a.name > b.name) {
                    return 1;
                }
                if (a.name < b.name) {
                    return -1;
                }
                return 0;
            });
        }

        var options = TC.Util.extend({}, len > 1 ? arguments[1] : arguments[0]);
        self._dialogDiv = TC.Util.getDiv(options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        if (self.mapIsOffline) {
            document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                elm.classList.add(TC.Consts.classes.HIDDEN);
            })
        }

        TC.Control.apply(self, arguments);
        self.wrap = new TC.wrap.control.CacheBuilder(self);

        self.isDownloading = false;
        self.baseLayers = [];

        self.options.avgTileSize = self.options.avgTileSize || TC.Cfg.avgTileSize;
        self.requestSchemas = [];
        self.minResolution = 0;
        self.currentMap = null;

        self._loadedCount = 0;

        // Actualización del enlace al modo online
        // Parche para detectar cambios en el hash. Lo usamos para actualizar los enlaces a los idiomas
        var pushState = history.pushState;
        history.pushState = function (state) {
            var result;
            //if (typeof history.onpushstate == "function") {
            //    history.onpushstate({ state: state });
            //}
            result = pushState.apply(history, arguments);
            if (self._offlinePanelDiv) {
                const params = TC.Util.getQueryStringParams();
                delete params[self.MAP_DEFINITION_PARAM_NAME];
                delete params[self.MAP_EXTENT_PARAM_NAME];
                delete params[self.SERVICE_WORKER_FLAG];
                var newParams = TC.Util.getParamString(params);
                if (newParams.length) {
                    newParams = '?' + newParams;
                }
                const href = location.pathname + newParams + location.hash;
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).setAttribute('href', href);
            }
            return result;
        }

        // Detección de estado de conexión
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {};
        var onlineHandler = function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.remove(
                    TC.Consts.classes.CONNECTION_OFFLINE,
                    TC.Consts.classes.CONNECTION_MOBILE,
                    TC.Consts.classes.CONNECTION_WIFI);

                var type = connection.type;
                switch (type) {
                    case 1:
                    case 2:
                    case undefined:
                        panel.classList.add(TC.Consts.classes.CONNECTION_WIFI);
                        break;
                    default:
                        panel.classList.add(TC.Consts.classes.CONNECTION_MOBILE);
                        break;
                }
            }
        };
        if (connection.addEventListener) {
            connection.addEventListener('typechange', onlineHandler);
        }
        window.addEventListener('online', onlineHandler);
        window.addEventListener('offline', function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE, TC.Consts.classes.CONNECTION_WIFI);
            }
        });
    };

    TC.inherit(TC.control.CacheBuilder, TC.control.SWCacheClient);

    var ctlProto = TC.control.CacheBuilder.prototype;

    ctlProto.CLASS = 'tc-ctl-cbuild';
    ctlProto.MAP_DEFINITION_PARAM_NAME = "map-def";
    ctlProto.MAP_EXTENT_PARAM_NAME = "map-extent";
    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.map.";
    ctlProto.ROOT_CACHE_NAME = "root";
    ctlProto.SERVICE_WORKER_FLAG = 'sw';
    ctlProto._states = {
        READY: 'ready',
        EDIT: 'editing',
        DOWNLOADING: 'downloading',
        DELETING: 'deleting'
    };
    ctlProto._actions = {
        CREATE: 'create',
        DELETE: 'delete'
    };
    ctlProto.offlineControls = [
        'attribution',
        'basemapSelector',
        'cacheBuilder',
        'click',
        'coordinates',
        'draw',
        'edit',
        'geolocation',
        'loadingIndicator',
        'measure',
        'navBar',
        'popup',
        'print',
        'scale',
        'scaleBar',
        'scaleSelector',
        'state',
        'fullScreen'
    ];

    TC.Consts.event.MAPCACHEDOWNLOAD = TC.Consts.event.MAPCACHEDOWNLOAD || 'mapcachedownload.tc';
    TC.Consts.event.MAPCACHEDELETE = TC.Consts.event.MAPCACHEDELETE || 'mapcachedelete.tc';
    TC.Consts.event.MAPCACHEPROGRESS = TC.Consts.event.MAPCACHEPROGRESS || 'mapcacheprogress.tc';
    TC.Consts.event.MAPCACHEERROR = TC.Consts.event.MAPCACHEERROR || 'mapcacheerror.tc';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/CacheBuilder.html";
        ctlProto.template[ctlProto.CLASS + '-map-node'] = TC.apiLocation + "TC/templates/CacheBuilderMapNode.html";
        ctlProto.template[ctlProto.CLASS + '-bl-node'] = TC.apiLocation + "TC/templates/CacheBuilderBaseLayerNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CacheBuilderDialog.html";
        ctlProto.template[ctlProto.CLASS + '-off-panel'] = TC.apiLocation + "TC/templates/CacheBuilderOfflinePanel.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "offlineMaps" }).w("</h2><div class=\"tc-ctl-cbuild-content\"><div class=\"tc-ctl-cbuild-draw tc-hidden\"></div><i class=\"tc-ctl-cbuild-map-search-icon\"></i><input type=\"search\" list=\"").f(ctx.get(["listId"], false), ctx, "h").w("\" class=\"tc-ctl-cbuild-map-available-srch tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "cb.filter.plhr" }).w("\"").x(ctx.get(["storedMaps"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" maxlength=\"200\" /> <ul id=\"").f(ctx.get(["listId"], false), ctx, "h").w("\" class=\"tc-ctl-cbuild-list\"><li class=\"tc-ctl-cbuild-map-available-empty\"").x(ctx.get(["storedMaps"], false), ctx, { "block": body_3 }, {}).w("><span>").h("i18n", ctx, {}, { "$key": "cb.noMaps" }).w("</span></li><li class=\"tc-ctl-cbuild-map-not\" hidden><span>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</span></li>").s(ctx.get(["storedMaps"], false), ctx, { "block": body_4 }, {}).w("</ul><div class=\"tc-ctl-cbuild-new\"><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-new\" disabled title=\"").h("i18n", ctx, {}, { "$key": "newofflinemap" }).w("\">").h("i18n", ctx, {}, { "$key": "newOfflineMap" }).w("</button></div><div class=\"tc-ctl-cbuild-drawing tc-hidden\"><div class=\"tc-ctl-cbuild-tile-cmd\"><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-cancel-draw\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div><div class=\"tc-ctl-cbuild-progress tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "cb.DownloadingMap|s" }).w(": <span class=\"tc-ctl-cbuild-progress-count\"></span></p><div class=\"tc-ctl-cbuild-progress-bar\"><div class=\"tc-ctl-cbuild-progress-ratio\" style=\"width:0\"></div></div><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-cancel-dl\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" disabled"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk; } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" hidden"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.p("tc-ctl-cbuild-map-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_4.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-map-node'] = function () { dust.register(ctlProto.CLASS + '-map-node', body_0); function body_0(chk, ctx) { return chk.w("<li data-extent=\"").f(ctx.get(["extent"], false), ctx, "h").w("\"><span><a href=\"").f(ctx.get(["url"], false), ctx, "h").w("\" title=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</a></span><input class=\"tc-textbox tc-hidden\" type=\"text\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\" /><button class=\"tc-btn-save tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "save" }).w("\"></button><button class=\"tc-btn-cancel tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\"></button><button class=\"tc-btn-edit\" title=\"").h("i18n", ctx, {}, { "$key": "editMapName" }).w("\">").h("i18n", ctx, {}, { "$key": "editMapName" }).w("</button><button class=\"tc-btn-view\" title=\"").h("i18n", ctx, {}, { "$key": "viewMapExtent" }).w("\">").h("i18n", ctx, {}, { "$key": "viewMapExtent" }).w("</button><button class=\"tc-btn-delete\" title=\"").h("i18n", ctx, {}, { "$key": "deleteMap" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteMap" }).w("</button></li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-bl-node'] = function () { dust.register(ctlProto.CLASS + '-bl-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-cbuild-bl-node\" data-layer-uid=\"").f(ctx.get(["id"], false), ctx, "h").w("\"><label style=\"background-size: 100% 100%; background-image: url(").f(ctx.get(["thumbnail"], false), ctx, "h").w(")\"><input type=\"checkbox\" name=\"cbbl\" value=\"").f(ctx.get(["id"], false), ctx, "h").w("\" disabled><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label></li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-cbuild-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "newOfflineMap" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><input type=\"text\" class=\"tc-ctl-cbuild-txt-name\" placeholder=\"").h("i18n", ctx, {}, { "$key": "nameRequired" }).w("\" required /><div class=\"tc-ctl-cbuild-bl-panel\"><h4>").h("i18n", ctx, {}, { "$key": "availableOfflineMaps" }).w("</h4><p class=\"tc-ctl-cbuild-bl-panel-txt\">").h("i18n", ctx, {}, { "$key": "selectAtLeastOne" }).w("</p><ul class=\"tc-ctl-cbuild-bl-list\"></ul></div><div class=\"tc-ctl-cbuild-res-panel\"><h4>").h("i18n", ctx, {}, { "$key": "maxRes" }).w("</h4><div class=\"tc-ctl-cbuild-res\"></div><input type=\"range\" class=\"tc-ctl-cbuild-rng-maxres\" disabled value=\"0\" title=\"").h("i18n", ctx, {}, { "$key": "maxRes" }).w("\"></div><div class=\"tc-ctl-cbuild-tile-count\"></div></div><div class=\"tc-modal-footer\"><button class=\"tc-button tc-modal-close tc-ctl-cbuild-btn-ok\" disabled>").h("i18n", ctx, {}, { "$key": "ok" }).w("</button><button type=\"button\" class=\"tc-button tc-modal-close tc-ctl-cbuild-btn-cancel\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-off-panel'] = function () { dust.register(ctlProto.CLASS + '-off-panel', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-cbuild-off-panel tc-conn-wifi\"><span>").h("i18n", ctx, {}, { "$key": "offlineMap" }).w("</span> <a href=\"\" class=\"tc-ctl-cbuild-link-exit\" title=\"").h("i18n", ctx, {}, { "$key": "returnToOnlineMaps" }).w("\"><span>").h("i18n", ctx, {}, { "$key": "returnToOnlineMaps" }).w("</span></a></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const getExtentFromString = function (str) {
        return decodeURIComponent(str).split(',').map(function (elm) {
            return parseFloat(elm);
        });
    };

    const setDownloadingState = function (ctl) {
        ctl._state = ctl._states.DOWNLOADING;
        TC.Util.closeModal();
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.remove(TC.Consts.classes.HIDDEN);
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = true;
        ctl.layer.clearFeatures();
        ctl.boxDraw.cancel();
    };

    const setDeletingState = function (ctl) {
        ctl._state = ctl._states.DELETING;
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        ctl.div.querySelectorAll(ctl._selectors.LISTITEM).forEach(function (li) {
            li.classList.add(TC.Consts.classes.DISABLED);
        });
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = false;
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = '';
        ctl.boxDraw.cancel();
    };

    const setNameEditingState = function (ctl, li) {
        li.querySelector('span').classList.add(TC.Consts.classes.HIDDEN);
        const textbox = li.querySelector(ctl._selectors.TEXTBOX);
        textbox.classList.remove(TC.Consts.classes.HIDDEN);
        textbox.value = li.querySelector('span a').innerHTML;
        textbox.focus();
        li.querySelector(ctl._selectors.SAVEBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.add(TC.Consts.classes.HIDDEN);
    };

    const setNameReadyState = function (ctl, li) {
        li.querySelector('span').classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.TEXTBOX).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.SAVEBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.remove(TC.Consts.classes.HIDDEN);
    };

    var formatNumber = function (number) {
        return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
    };

    var updateResolutions = function (ctl, options) {
        var opts = options || {};
        const resDiv = ctl._dialogDiv.querySelector(ctl._classSelector + '-res');
        const range = ctl._dialogDiv.querySelector(ctl._selectors.RNGMAXRES);
        var resolutions = ctl.getResolutions();
        var resText, resLevel, resLeft;
        if (resolutions.length) {
            range.setAttribute('max', resolutions.length - 1);
            if (ctl.minResolution) {
                // Si ya había resolución previa y no se ha tocado el slider, se actualiza su valor
                if (opts.rangeValue === undefined) {
                    for (var i = 0, len = resolutions.length; i < len; i++) {
                        if (ctl.minResolution >= resolutions[i]) {
                            range.value = i;
                            break;
                        }
                    }
                }
            }
            else {
                if (opts.rangeValue === undefined) {
                    // Si no había resolución previa se selecciona un valor inicial igual a la resolución actual
                    const currentResolution = ctl.map.getResolution();
                    range.value = resolutions.filter(r => r > currentResolution).length;
                }
            }
            resLevel = parseInt(range.value);
            var resValue = Math.floor(new Number(resolutions[resLevel]) * 1000) / 1000;
            resText = ctl.getLocaleString('metersPerPixel', {
                value: resValue.toLocaleString((ctl.map ? ctl.map.options.locale : TC.Cfg.locale).replace('_', '-'))
            });
            resLeft = (resLevel + 1) * 100 / (resolutions.length + 1) + '%';
            range.disabled = false;
            ctl.minResolution = resolutions[range.value];
        }
        else {
            resLevel = 0;
            resText = '';
            range.value = 0;
            resLeft = '0';
            ctl.minResolution = 0;
            range.disabled = true;
        }
        resDiv.style.left = resLeft;
        resDiv.innerHTML = resText;
    };

    const findTileMatrixLimits = function (schema, resolution) {
        var result = null;
        for (var i = 0, len = schema.tileMatrixLimits.length; i < len; i++) {
            result = schema.tileMatrixLimits[i];
            if (result.res <= resolution) {
                break;
            }
        }
        return result;
    };

    const updateThumbnails = function (ctl) {
        ctl._dialogDiv.querySelectorAll(ctl._classSelector + '-bl-node input[type=checkbox]').forEach(function (cb, idx) {
            if (cb.checked) {
                var schema = ctl.requestSchemas.filter(function (elm) {
                    return elm.layerId === cb.value;
                })[0];
                if (schema) {
                    var tml = findTileMatrixLimits(schema, ctl.minResolution);
                    if (tml) {
                        var tmKey = '{TileMatrix}';
                        var trKey = '{TileRow}';
                        var tcKey = '{TileCol}';
                        var url = schema.url;
                        if (url.indexOf(tmKey) < 0) {
                            // Caso KVP
                            var qsIdx = url.indexOf('?');
                            if (qsIdx >= 0) {
                                url = url.substr(0, qsIdx);
                            }
                            for (var j = 0, lenj = ctl.baseLayers.length; j < lenj; j++) {
                                var l = ctl.baseLayers[j];
                                if (l.id === schema.layerId) {
                                    url = url + '?layer=' + l.layerNames + '&style=default&tilematrixset=' + l.matrixSet +
                                        '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + l.format +
                                        '&TileMatrix=' + tmKey + '&TileRow=' + trKey + '&TileCol=' + tcKey;
                                    break;
                                }
                            }
                        }
                        while (cb && cb.tagName !== 'LABEL') {
                            cb = cb.parentElement;
                        }
                        if (cb) {
                            cb.style.backgroundSize = 'auto';
                            cb.style.backgroundPosition = 'left bottom';
                            cb.style.backgroundImage = 'url(' + url.replace('{TileMatrix}', tml.mId).replace(trKey, tml.rt).replace(tcKey, tml.cl) + ')';
                        }
                    }
                }
            }
        });
    };

    const formatSize = function (ctl, size) {
        var result;
        if (size < 1) {
            result = ctl.getLocaleString('lessThan1Mb');
        }
        else {
            result = ctl.getLocaleString('approxXMb', { quantity: formatNumber(size) });
        }
        return result;
    };

    const showEstimatedMapSize = function (ctl) {
        var text = '';
        ctl.tileCount = 0;
        for (var i = 0, ii = ctl.requestSchemas.length; i < ii; i++) {
            var schema = ctl.requestSchemas[i];
            for (var j = 0, jj = schema.tileMatrixLimits.length; j < jj; j++) {
                var tml = schema.tileMatrixLimits[j];
                ctl.tileCount += (tml.cr - tml.cl + 1) * (tml.rb - tml.rt + 1);
                if (tml.res < ctl.minResolution) {
                    break;
                }
            }
        }
        if (ctl.tileCount) {
            ctl.estimatedMapSize = Math.round(ctl.tileCount * ctl.options.avgTileSize / 1048576);
            text = ctl.getLocaleString('xTiles', { quantity: formatNumber(ctl.tileCount) }) + ' (' + formatSize(ctl, ctl.estimatedMapSize) + ')';
        }
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = text;
    };

    const getListElementByMapName = function (ctl, name) {
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.innerHTML === name) {
                return li;
            }
        }
        return null;
    };

    const getListElementByMapUrl = function (ctl, url) {
        var hashIdx = url.indexOf('#');
        if (hashIdx >= 0) {
            url = url.substr(0, hashIdx);
        }
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.getAttribute('href') === url) {
                return li;
            }
        }
        return null;
    };

    var saveMapToStorage = function (ctl, map) {
        var result = false;
        if (ctl.localStorage) {
            ctl.localStorage.setItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(map.url), map.extent + " " + map.name);
            result = true;
        }
        return result;
    };

    var removeMapFromStorage = function (ctl, url) {
        var result = false;
        if (ctl.localStorage) {
            ctl.localStorage.removeItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(url));
            result = true;
        }
        return result;
    };

    const addMap = function (ctl) {
        const map = ctl.currentMap;
        if (saveMapToStorage(ctl, map)) {
            ctl.getRenderedHtml(ctl.CLASS + '-map-node', { name: map.name, url: map.url }, function (html) {
                const parser = new DOMParser();
                ctl.div.querySelector(ctl._selectors.LIST).appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).setAttribute('hidden', 'hidden');
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = false;
            });
            ctl.storedMaps.push(map);
        }
    };

    const removeMap = function (ctl, url) {
        const map = ctl.findStoredMap({ url: url });
        if (map) {
            if (removeMapFromStorage(ctl, url)) {
                const li = getListElementByMapName(ctl, map.name);
                if (li) {
                    li.parentElement.removeChild(li);
                }
            }
            var idx = ctl.storedMaps.indexOf(map);
            ctl.storedMaps.splice(idx, 1);
            if (!ctl.storedMaps.length) {
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = true;
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).removeAttribute('hidden');
            }

            return map.name;
        }

        return null;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            var renderObject = { storedMaps: self.storedMaps, listId: self.CLASS + '-list-' + TC.getUID() };
            self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
                self._dialogDiv.innerHTML = html;
                self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener(TC.Consts.event.CLICK, function (e) {
                    e.preventDefault();
                    this.selectionStart = 0;
                    this.selectionEnd = this.value.length;
                    this.focus();

                });
            }).then(function () {
                self.renderData(renderObject, function () {
                    self._dialogDiv.querySelector(self._selectors.OKBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.generateCache();
                    });
                    self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener('input', function () {
                        self._updateReadyState();
                    });
                    self.div.querySelector(self._selectors.NEWBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.setEditState();
                    });
                    self.div.querySelector(self._classSelector + '-btn-cancel-draw').addEventListener(TC.Consts.event.CLICK, function () {
                        self.setReadyState();
                    });

                    self.div.querySelector(self._classSelector + '-btn-cancel-dl').addEventListener(TC.Consts.event.CLICK, function () {
                        self.cancelCacheRequest();
                    });

                    const list = self.div.querySelector(self._selectors.LIST);
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.DELETEBTN, function (e) {
                        self.startDeleteMap(e.target.parentElement.querySelector('a').innerHTML);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.EDITBTN, function (e) {
                        setNameEditingState(self, e.target.parentElement);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.CANCELBTN, function (e) {
                        const li = e.target.parentElement;
                        li.querySelector(self._selectors.TEXTBOX).value = li.querySelector('a').innerHTML;
                        setNameReadyState(self, li);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.SAVEBTN, function (e) {
                        const li = e.target.parentElement;
                        setNameReadyState(self, li);
                        const anchor = li.querySelector('a');
                        const oldName = anchor.innerHTML;
                        const newName = li.querySelector(self._selectors.TEXTBOX).value;
                        const map = self.findStoredMap({ url: anchor.getAttribute('href') });
                        if (map) {
                            map.name = newName;
                            anchor.innerHTML = newName;
                            anchor.setAttribute('title', newName);
                            saveMapToStorage(self, map);
                        }
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.VIEWBTN, function (e) {
                        const btn = e.target;
                        var showExtent = !btn.classList.contains(TC.Consts.classes.ACTIVE);
                        const viewBtn = self.div.querySelector(self._selectors.VIEWBTN);
                        viewBtn.classList.remove(TC.Consts.classes.ACTIVE);
                        viewBtn.parentElement.classList.remove(TC.Consts.classes.ACTIVE);
                        const mapName = btn.parentElement.querySelector('a').innerHTML;
                        if (mapName) {
                            var map = self.findStoredMap({ name: mapName });
                            if (map) {
                                var extent = getExtentFromString(map.extent);
                                self.layer.clearFeatures();
                                if (showExtent) {
                                    self.layer.addPolygon(
                                        [
                                            [
                                                [extent[0], extent[1]],
                                                [extent[0], extent[3]],
                                                [extent[2], extent[3]],
                                                [extent[2], extent[1]]
                                            ]
                                        ]
                                        , {
                                            showsPopup: false
                                        }).then(function () {
                                            self.layer.map.zoomToFeatures(self.layer.features);
                                        });
                                    btn.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.parentElement.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.setAttribute('title', self.getLocaleString('removeMapExtent'));
                                }
                            }
                        }
                    }));

                    var _filter = function (searchTerm) {
                        searchTerm = searchTerm.toLowerCase();
                        //tc-ctl-cbuild-map-available-empty
                        const lis = self.div.querySelectorAll(self._selectors.LISTITEM);
                        lis.forEach(function (li) {
                            li.style.display = 'none';
                        });
                        const mapLis = [];
                        lis.forEach(function (li) {
                            if (li.matches('li:not([class]),li.' + TC.Consts.classes.ACTIVE)) {
                                mapLis.push(li);
                            }
                        });

                        if (searchTerm.length === 0) {
                            mapLis.forEach(function (li) {
                                li.style.removeProperty('display');
                            });
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'visible';
                        } else {
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'hidden';
                            var r = new RegExp(searchTerm, 'i');
                            mapLis.forEach(function (li) {
                                li.style.display = r.test(li.querySelector('a').textContent) ? '' : 'none';
                            });

                            if (!mapLis.some(function (li) {
                                return !li.hidden;
                            })) {
                                lis.forEach(function (li) {
                                    if (li.matches('[class^="tc-ctl-cbuild-map-not"]')) {
                                        li.style.removeProperty('display');
                                    }
                                });
                            }
                        }
                    };

                    const trackSearch = self.div.querySelector(self._selectors.SEARCH);
                    const searchListener = function () {
                        _filter(this.value.toLowerCase().trim());
                    };
                    trackSearch.addEventListener('keyup', searchListener);
                    trackSearch.addEventListener('search', searchListener);

                    self._dialogDiv.querySelector(self._selectors.BLLIST).addEventListener('change', TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
                        const checkbox = e.target;
                        if (checkbox.checked) {
                            self.baseLayers.push(self.map.getLayer(checkbox.value));
                        }
                        else {
                            for (var i = 0, ii = self.baseLayers.length; i < ii; i++) {
                                const bl = self.baseLayers[i];
                                if (bl.id === checkbox.value) {
                                    self.baseLayers.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        self.updateRequestSchemas();
                        updateResolutions(self);
                        updateThumbnails(self);
                        self._updateReadyState();
                        showEstimatedMapSize(self);
                    }));

                    const range = self._dialogDiv.querySelector(self._selectors.RNGMAXRES);
                    const rangeListener = function (e) {
                        updateResolutions(self, {
                            rangeValue: e.target.value
                        });
                        updateThumbnails(self);
                        showEstimatedMapSize(self);
                    };
                    range.addEventListener('input', rangeListener);
                    range.addEventListener('change', rangeListener);

                    const li = getListElementByMapUrl(self, location.href);
                    if (li) {
                        li.classList.add(TC.Consts.classes.ACTIVE);
                    }

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }
                })
                    .then(function () {
                        resolve();
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            });

            // Control para evitar que se cancele una descarga de cache al salir de la página
            window.addEventListener('beforeunload', function (e) {
                if (self.isDownloading) {
                    var msg = self.getLocaleString('cb.mapDownloading.warning');
                    e.returnValue = msg;
                    return msg;
                }
            }, true);
        }));
    };

    ctlProto.register = function (map) {
        var self = this;

        const result = TC.control.SWCacheClient.prototype.register.call(self, map);

        if (navigator.serviceWorker) {
            navigator.serviceWorker.ready.then(function () {
                navigator.serviceWorker.addEventListener('message', function (event) {
                    switch (event.data.event) {
                        case 'progress':
                            self.trigger(TC.Consts.event.MAPCACHEPROGRESS, { url: event.data.name, loaded: event.data.count, total: event.data.total });
                            break;
                        case 'cached':
                            self.trigger(TC.Consts.event.MAPCACHEDOWNLOAD, { url: event.data.name });
                            break;
                        case 'deleted':
                            self.trigger(TC.Consts.event.MAPCACHEDELETE, { url: event.data.name });
                            break;
                        case 'error':
                            if (event.data.action === self._actions.CREATE) {
                                TC.error(self.getLocaleString('cb.resourceDownload.error', { url: event.data.url }));
                            }
                            break;
                        default:
                            break;
                    }
                });
            });

            if (navigator.onLine) {
                // Cacheamos mediante service worker las URLs del manifiesto
                requestManifest().then(function (obj) {
                    const hashStorageKey = self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash';
                    var hash;
                    if (self.localStorage) {
                        hash = self.localStorage.getItem(hashStorageKey);
                    }
                    if (hash !== obj.hash) {
                        self.cacheUrlList(obj.urls);
                        self.one(TC.Consts.event.MAPCACHEDOWNLOAD, function () {
                            const firstLoad = !hash;
                            if (self.localStorage) {
                                self.localStorage.setItem(hashStorageKey, obj.hash);
                            }
                            if (!firstLoad) {
                                TC.confirm(self.getLocaleString('newAppVersionAvailable'), function () {
                                    location.reload();
                                });
                            }
                        });
                    }
                });
            }
        }

        if (self.mapIsOffline) {
            map.div.classList.add(TC.Consts.classes.OFFLINE);

            // Si no está especificado, el panel de aviso offline se cuelga del div del mapa
            self._offlinePanelDiv = TC.Util.getDiv(self.options.offlinePanelDiv);
            if (!self.options.offlinePanelDiv) {
                map.div.appendChild(self._offlinePanelDiv);
            }
            self.getRenderedHtml(self.CLASS + '-off-panel', null, function (html) {
                self._offlinePanelDiv.innerHTML = html;
                if (!navigator.onLine) {
                    const offPanel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                    offPanel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                    offPanel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE, TC.Consts.classes.CONNECTION_WIFI);
                }
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).addEventListener(TC.Consts.event.CLICK, function (e) {
                    TC.confirm(self.getLocaleString('offlineMapExit.confirm'),
                        null,
                        function () {
                            e.preventDefault();
                        });
                });
            });
        }

        const drawId = self.getUID();
        const layerId = self.getUID();
        self.layerPromise = map.addLayer({
            id: layerId,
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            styles: {
                line: map.options.styles.line
            }
        });
        self.layer = null;
        Promise.all([
            self.layerPromise,
            self.renderPromise(),
            map.addControl('draw', {
                id: drawId,
                div: self.div.querySelector(self._selectors.DRAW),
                mode: TC.Consts.geom.RECTANGLE,
                persistent: false
            })
        ]).then(function (objects) {
            const layer = self.layer = objects[0];
            const boxDraw = self.boxDraw = objects[2];
            boxDraw.setLayer(layer);
            boxDraw
                .on(TC.Consts.event.DRAWSTART, function (e) {
                    self.map.toast(self.getLocaleString('clickOnDownloadAreaOppositeCorner'), { type: TC.Consts.msgType.INFO });
                })
                .on(TC.Consts.event.DRAWEND, function (e) {
                    var points = e.feature.geometry[0];
                    var pStart = points[0];
                    var pEnd = points[2];
                    var minx = Math.min(pStart[0], pEnd[0]);
                    var maxx = Math.max(pStart[0], pEnd[0]);
                    var miny = Math.min(pStart[1], pEnd[1]);
                    var maxy = Math.max(pStart[1], pEnd[1]);
                    self.setExtent([minx, miny, maxx, maxy]);
                    const checkboxes = self._dialogDiv.querySelectorAll('input[type=checkbox]');
                    checkboxes.forEach(function (checkbox) {
                        // Comprobamos que la extensión del mapa está disponible a alguna resolución
                        const layer = self.map.getLayer(checkbox.value);
                        var li = checkbox;
                        while (li && li.tagName !== 'LI') {
                            li = li.parentElement;
                        }
                        const tml = self.wrap.getRequestSchemas({
                            extent: self.extent,
                            layers: [layer]
                        })[0].tileMatrixLimits;

                        li.classList.toggle(TC.Consts.classes.HIDDEN, !tml.length);
                    });
                    const visibleLi = self._dialogDiv.querySelector(self._selectors.BLLISTITEM + ':not(.' + TC.Consts.classes.HIDDEN + ')');
                    self._dialogDiv.querySelector(self._selectors.BLLISTTEXT).innerHTML = self.getLocaleString(visibleLi ? 'selectAtLeastOne' : 'cb.noMapsAtSelectedExtent');

                    updateThumbnails(self);
                    showEstimatedMapSize(self);
                    TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-dialog'), {
                        openCallback: function () {
                            checkboxes.forEach(function (cb) {
                                cb.disabled = false;
                            });
                            var time;
                            if (Date.prototype.toLocaleString) {
                                var opt = {};
                                opt.year = opt.month = opt.day = opt.hour = opt.minute = opt.second = 'numeric';
                                time = new Date().toLocaleString(self.map.options.locale.replace('_', '-'), opt);
                            }
                            else {
                                time = new Date().toString();
                            }
                            self._dialogDiv.querySelector(self._selectors.NAMETB).value = time;
                            self._updateReadyState();
                        },
                        closeCallback: function () {
                            checkboxes.forEach(function (cb) {
                                cb.disabled = true;
                            });
                            self.boxDraw.layer.clearFeatures();
                        }
                    });
                });

            map.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                if (boxDraw === e.control) {
                    if (self._state === self._states.EDITING) {
                        self.setReadyState();
                    }
                }
            });

        });

        var addRenderedListNode = function (layer) {
            var result = false;
            const blList = self._dialogDiv.querySelector(self._selectors.BLLIST);
            const isLayerAdded = function () {
                return !!blList.querySelector('li[data-layer-uid="' + layer.id + '"]');
            };
            var isValidLayer = layer.type === TC.Consts.layerType.WMTS && !layer.mustReproject;
            if (TC.Util.detectSafari() && TC.Util.detectIOS()) {
                isValidLayer = isValidLayer && TC.Util.isSameOrigin(layer.url);
            }
            if (isValidLayer && !isLayerAdded()) {
                result = true;
                self.getRenderedHtml(self.CLASS + '-bl-node', layer, function (html) {
                    if (!isLayerAdded()) {
                        const parser = new DOMParser();
                        blList.appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                    }
                });
            }
            return result;
        };

        map
            .on(TC.Consts.event.LAYERADD, function (e) {
                if (e.layer.isBase && self.mapIsOffline) {
                    // Capamos las resoluciones de la capa
                    const resolutions = e.layer.getResolutions();
                    if (resolutions) {
                        const cachedResolutions = resolutions.filter(r => r >= self.currentMapDefinition.res);
                        if (cachedResolutions.length) {
                            e.layer.setResolutions(cachedResolutions);
                        }
                    }
                }
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    addRenderedListNode(e.layer);
                });
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    const layer = e.layer;
                    if (layer.type === TC.Consts.layerType.WMTS) {
                        const li = self._dialogDiv
                            .querySelector(self._selectors.BLLIST)
                            .querySelector('li[data-layer-uid="' + layer.id + '"]');
                        li.parentElement.removeChild(li);
                    }
                });
            });

        map.ready(function () {
            if (self.mapIsOffline) {
                // Deshabilitamos los controles que no son usables en modo offline
                var offCtls = [];
                var i, len;
                for (i = 0, len = self.offlineControls.length; i < len; i++) {
                    var offCtl = self.offlineControls[i];
                    offCtl = offCtl.substr(0, 1).toUpperCase() + offCtl.substr(1);
                    offCtls = offCtls.concat(map.getControlsByClass('TC.control.' + offCtl));
                }

                for (i = 0, len = map.controls.length; i < len; i++) {
                    var ctl = map.controls[i];
                    if (offCtls.indexOf(ctl) < 0) {
                        ctl.disable();
                    }
                }

                document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
            }
        });

        map.loaded(function () {

            self.layerPromise.then(function (layer) {
                map.putLayerOnTop(layer);
            });

            self.renderPromise().then(function () {
                self.div.querySelector(self._selectors.NEWBTN).disabled = false;
                for (var i = 0, len = map.baseLayers.length; i < len; i++) {
                    addRenderedListNode(map.baseLayers[i]);
                }
            });

            if (self.mapIsOffline) {
                const mapDef = self.currentMapDefinition;
                const isSameLayer = function (layer, mapDefLayer) {
                    const layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                    return (layerUrl === mapDef.url[mapDefLayer.urlIdx] && layer.layerNames === mapDefLayer.id && layer.matrixSet === mapDef.tms[mapDefLayer.tmsIdx]);
                };
                // Añadimos al mapa las capas guardadas que no están por defecto
                const missingLayers = map.options.availableBaseLayers
                    .filter((abl) => abl.type === TC.Consts.layerType.WMTS) // Capas cacheables
                    .filter((abl) => { // Que estén en el mapa sin conexión
                        return mapDef.layers.some((l) => isSameLayer(abl, l));
                    })
                    .filter((abl) => { // Que no estén en las capas por defecto
                        return !map.baseLayers.some((l) => l.id === abl.id);
                    });
                Promise.all(missingLayers.map((layer) => {
                    return map.addLayer(TC.Util.extend({}, layer, { isBase: true }));
                })).finally(function () {
                    // Obtenemos las capas cacheadas
                    const cachedLayers = [];
                    for (var i = 0, ii = mapDef.layers.length; i < ii; i++) {
                        for (var j = 0, jj = map.baseLayers.length; j < jj; j++) {
                            const baseLayer = map.baseLayers[j];
                            if (baseLayer.type === TC.Consts.layerType.WMTS && isSameLayer(baseLayer, mapDef.layers[i])) {
                                cachedLayers.push(baseLayer);
                                break;
                            }
                        }
                    }
                    if (cachedLayers.length) {
                        map.setBaseLayer(cachedLayers[0], function () {
                            // Quitamos las capas no disponibles (la capa en blanco la mantenemos)
                            for (var i = map.baseLayers.length - 1; i >= 0; i--) {
                                const baseLayer = map.baseLayers[i];
                                if (baseLayer.type !== TC.Consts.layerType.VECTOR && !cachedLayers.includes(baseLayer)) {
                                    map.removeLayer(baseLayer);
                                }
                            }

                            map.setExtent(self.currentMapExtent, { animate: false });
                        });
                    }
                });
            }
        });

        self
            .on(TC.Consts.event.MAPCACHEDOWNLOAD, function (e) {
                self.isDownloading = false;
                const removeHash = function (url) {
                    const hashIdx = url.indexOf('#');
                    return (hashIdx >= 0) ? url.substr(0, hashIdx) : url;
                }
                const url = removeHash(e.url);
                const li = getListElementByMapUrl(self, url);
                if (li && !self.serviceWorkerEnabled) {
                    // Se ha descargado un mapa cuando se quería borrar. Pasa cuando la cache ya estaba borrada pero la entrada en localStorage no.
                    li.classList.remove(TC.Consts.classes.DISABLED);
                    TC.alert(self.getLocaleString('cb.delete.error'));
                }
                else {
                    if (self.currentMap && url === self.currentMap.url) {
                        addMap(self);
                        map.toast(self.getLocaleString('mapDownloaded', { mapName: self.currentMap.name }));
                    }
                }
                self.currentMap = null;
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEDELETE, function (e) {
                self.isDownloading = false;
                var mapName = removeMap(self, e.url) || (self.currentMap && self.currentMap.name);
                self.currentMap = null;
                if (mapName) {
                    map.toast(self.getLocaleString('mapDeleted', { mapName: mapName }));
                }
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEPROGRESS, function (e) {
                var total = e.total;
                if (!total && self.requestSchemas) {
                    total = self.requestSchemas[0].tileCount;
                }
                var loaded = e.loaded;
                if (loaded) {
                    self._loadedCount = loaded;
                }
                else {
                    self._loadedCount += 1;
                    loaded = self._loadedCount;
                }
                self.showDownloadProgress(loaded, total);
            })
            .on(TC.Consts.event.MAPCACHEERROR, function (e) {
                self.isDownloading = false;
                self.setReadyState();
                var msg = self.getLocaleString('cb.mapCreation.error');
                var handleError = true;
                switch (e.reason) {
                    case 'quota':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonQuota');
                        break;
                    case 'resource':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonResource');
                        break;
                    case 'manifest':
                        if (e.status == '410') {
                            removeMap(self, e.url);
                        }
                        handleError = false;
                        break;
                    case ALREADY_EXISTS:
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonAlreadyExists');
                        break;
                    default:
                        break;
                }
                if (handleError) {
                    if (TC.Util.detectIE()) {
                        TC.error(msg);
                        TC.alert(self.getLocaleString('cb.mapCreation.error.reasonEdge'));
                    }
                    else {
                        TC.alert(msg);
                    }
                }
                self.currentMap = null;
            });

        return result;
    };

    ctlProto.setExtent = function (extent) {
        var self = this;
        if (Array.isArray(extent) && extent.length >= 4) {
            self.extent = extent;
            self.updateRequestSchemas();
        }
    };

    ctlProto._updateReadyState = function () {
        const self = this;
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled =
            !self.extent ||
            self._dialogDiv.querySelector(self._selectors.NAMETB).value.length === 0 ||
            self._dialogDiv.querySelector(self._selectors.RNGMAXRES).disabled;
    };

    ctlProto.setReadyState = function () {
        const self = this;
        self._state = self._states.READY;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        self.div.querySelectorAll(self._selectors.LISTITEM).forEach(function (li) {
            li.classList.remove(TC.Consts.classes.DISABLED);
        });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = false;
        self._dialogDiv.querySelector(self._selectors.TILECOUNT).innerHTML = '';
        self.extent = null;
        self._loadedCount = 0;
        if (self.boxDraw) {
            self.boxDraw.cancel();
        }
    };

    ctlProto.setEditState = function () {
        const self = this;
        self._state = self._states.EDITING;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.DRAWING).classList.remove(TC.Consts.classes.HIDDEN);
        self.map.toast(self.getLocaleString('clickOnDownloadAreaFirstCorner'), { type: TC.Consts.msgType.INFO });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = true;
        self._dialogDiv.querySelector(self._selectors.NAMETB).value = '';
        self.boxDraw.activate();
    };

    ctlProto.generateCache = function () {
        const self = this;
        const options = {
            mapName: self._dialogDiv.querySelector(self._selectors.NAMETB).value
        };
        if (self.findStoredMap({ name: options.mapName })) {
            TC.alert(self.getLocaleString('cb.mapNameAlreadyExists.error', options));
        }
        else {
            var startRequest = function () {
                self.div.querySelector(self._classSelector + '-name').innerHTML = options.mapName;
                self.map.toast(self.getLocaleString('downloadingMap', { mapName: options.mapName }));
                setDownloadingState(self);
                self.requestCache(options);
            };

            // Usamos Storage API si existe
            if (navigator.storage && navigator.storage.estimate) {
                navigator.storage.estimate().then(function (estimate) {
                    const availableMB = (estimate.quota - estimate.usage) / 1048576;
                    if (self.estimatedMapSize < availableMB) {
                        startRequest();
                    }
                    else {
                        TC.confirm(self.getLocaleString('cb.mapCreation.warning.reasonSize', {
                            mapName: options.mapName,
                            mapSize: formatSize(self, self.estimatedMapSize),
                            availableStorage: formatSize(self, Math.round(availableMB))
                        }), startRequest);
                    }
                });
            }
            else {
                startRequest();
            }
        }
    };

    ctlProto.cacheUrlList = function (urlList, options) {
        var self = this;
        var opts = options || {};
        self.createCache(opts.name || (self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME), {
            urlList: urlList,
            silent: opts.silent
        });
    };

    ctlProto.requestCache = function (options) {
        var self = this;
        var opts = options || {};
        if (self.map) {
            var extent = opts.extent || self.extent || self.map.getExtent();
            self.updateRequestSchemas({ extent: extent });

            if (self.requestSchemas) {
                var filterTml = function (elm, i, arr) {
                    var result = elm.res >= self.minResolution;
                    if (!result && i > 0) {
                        result = arr[i - 1].res > self.minResolution;
                    }
                    return result;
                };
                var trimTml = function (tml) {
                    return {
                        mId: tml.mId,
                        cl: tml.cl,
                        cr: tml.cr,
                        rt: tml.rt,
                        rb: tml.rb
                    };
                };
                // Solo mantenemos los esquemas hasta el nivel de resolución mínima o el inmediatamente inferior a ella si no lo tiene
                var requestSchemas = self.requestSchemas.map(function (schema) {
                    return {
                        layerId: schema.layerId,
                        tileMatrixLimits: schema.tileMatrixLimits.filter(filterTml)
                    };
                });
                // Actualizamos el extent para que coincida con las teselas del último nivel de los esquemas
                // También eliminamos del esquema todo lo irrelevante para la petición
                var intersectionExtent = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (var i = 0, len = requestSchemas.length; i < len; i++) {
                    var rs = requestSchemas[i];
                    var tml = rs.tileMatrixLimits[rs.tileMatrixLimits.length - 1];
                    var unitsPerTile = tml.res * tml.tSize;
                    intersectionExtent[0] = Math.min(intersectionExtent[0], tml.origin[0] + unitsPerTile * tml.cl);
                    intersectionExtent[1] = Math.min(intersectionExtent[1], tml.origin[1] - unitsPerTile * (tml.rb + 1));
                    intersectionExtent[2] = Math.max(intersectionExtent[2], tml.origin[0] + unitsPerTile * (tml.cr + 1));
                    intersectionExtent[3] = Math.max(intersectionExtent[3], tml.origin[1] - unitsPerTile * tml.rt);
                    rs.tileMatrixLimits = rs.tileMatrixLimits.map(trimTml);
                }


                // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                var precision = Math.pow(10, self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION);
                intersectionExtent = intersectionExtent.map(function (elm, idx) {
                    var round = (idx < 3) ? Math.ceil : Math.floor;
                    return round(elm * precision) / precision;
                });

                var mapDefinition = {
                    bBox: intersectionExtent,
                    res: Math.floor(self.minResolution * 1000) / 1000, // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                    url: [],
                    tms: [],
                    format: [],
                    layers: new Array(self.baseLayers.length)
                };
                for (var i = 0, len = self.baseLayers.length; i < len; i++) {
                    var layer = self.baseLayers[i];
                    var layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                    var urlIdx = mapDefinition.url.indexOf(layerUrl);
                    if (urlIdx < 0) {
                        urlIdx = mapDefinition.url.push(layerUrl) - 1;
                    }
                    var tmsIdx = mapDefinition.tms.indexOf(layer.matrixSet);
                    if (tmsIdx < 0) {
                        tmsIdx = mapDefinition.tms.push(layer.matrixSet) - 1;
                    }
                    var shortFormat = layer.format.substr(layer.format.indexOf('/') + 1);
                    var formatIdx = mapDefinition.format.indexOf(shortFormat);
                    if (formatIdx < 0) {
                        formatIdx = mapDefinition.format.push(shortFormat) - 1;
                    }
                    mapDefinition.layers[i] = {
                        urlIdx: urlIdx,
                        id: layer.layerNames,
                        tmsIdx: tmsIdx,
                        formatIdx: formatIdx
                    };
                }

                var params = TC.Util.getQueryStringParams();
                var e = params[self.MAP_EXTENT_PARAM_NAME] = intersectionExtent.toString();
                params[self.MAP_DEFINITION_PARAM_NAME] = btoa(JSON.stringify(mapDefinition));
                if (self.serviceWorkerEnabled) {
                    params[self.SERVICE_WORKER_FLAG] = 1;
                }
                var u = location.origin + location.pathname.substr(0, location.pathname.lastIndexOf('/') + 1) + '?' + TC.Util.getParamString(params);
                self.currentMap = { name: opts.mapName, extent: e, url: u };
                self.isDownloading = true;

                // Guardado mediante service workers
                if (self.serviceWorkerEnabled) {
                    const urlList = [];
                    for (var i = 0, len = requestSchemas.length; i < len; i++) {
                        var schema = requestSchemas[i];
                        var urlPattern = null;
                        for (var j = 0, lenj = self.baseLayers.length; j < lenj; j++) {
                            var l = self.baseLayers[j];
                            if (l.id === schema.layerId) {
                                urlPattern = self.wrap.getGetTilePattern(l);
                                if (l.getFallbackLayer) {
                                    // Esto se usa para meter en almacenamiento local el capabilities de la capa de fallback y evitar errores cuando no haya red
                                    l.getFallbackLayer();
                                }
                                if (l.thumbnail) {
                                    urlList.push(l.thumbnail);
                                }
                                break;
                            }
                        }
                        if (urlPattern) {
                            for (var k = 0, lenk = schema.tileMatrixLimits.length; k < lenk; k++) {
                                var tml = schema.tileMatrixLimits[k];
                                for (var r = tml.rt; r <= tml.rb; r++) {
                                    for (var c = tml.cl; c <= tml.cr; c++) {
                                        urlList.push(urlPattern.replace('{TileMatrix}', tml.mId).replace('{TileCol}', c).replace('{TileRow}', r));
                                    }
                                }
                            }
                        }
                    }
                    urlList.push(u);
                    self.cacheUrlList(urlList, { name: u });
                }
            }
        }
    }

    ctlProto.cancelCacheRequest = function () {
        var self = this;
        if (self.currentMap) {
            self.deleteCache(self.currentMap.url).then(function (obj) {
                if (!obj) {
                    self.currentMap = null;
                }
            });
        }
        self.isDownloading = false;
        self.setReadyState();
    };

    ctlProto.deleteMap = function (name) {
        var self = this;

        var map = self.findStoredMap({ name: name });
        if (map) {
            self.deleteCache(map.url);
        }
    };

    ctlProto.startDeleteMap = function (name) {
        const self = this;
        if (navigator.onLine) {
            if (name) {
                var confirmText = self.getLocaleString('cb.delete.confirm', { mapName: name });
                if (!self.serviceWorkerEnabled) {
                    confirmText = confirmText + " " + self.getLocaleString('cb.delete.confirm.connect.warning');
                }
                if (confirm(confirmText)) {
                    if (navigator.onLine) {
                        setDeletingState(self);
                        self.deleteMap(name);
                    } else {
                        TC.alert(self.getLocaleString('cb.delete.conn.alert'));
                    }
                }
            }
        } else {
            TC.alert(self.getLocaleString('cb.delete.conn.alert'));
        }
    };

    ctlProto.findStoredMap = function (options) {
        var self = this;
        return self.storedMaps.filter(function (elm) {
            var result = true;
            if (options.name && options.name !== elm.name) {
                result = false;
            }
            if (result && options.url && options.url !== elm.url) {
                result = false;
            }
            return result;
        })[0];
    };

    ctlProto.showDownloadProgress = function (current, total) {
        const self = this;
        const cs = self._classSelector;
        const count = self.div.querySelector(cs + '-progress-count');
        if (total) {
            var percent = Math.min(Math.round(current * 100 / total), 100);
            var percentString = percent + '%';
            self.div.querySelector(cs + '-progress-ratio').style.width = percentString;
            count.innerHTML = percentString;
        }
        else {
            self.div.querySelector(cs + '-progress-bar').classList.add(TC.Consts.classes.HIDDEN);
            count.innerHTML = self.getLocaleString('xFiles', { quantity: current });
        }
    };

    ctlProto.updateRequestSchemas = function (options) {
        var self = this;
        var opts = options || {};
        opts.extent = opts.extent || self.extent;
        opts.layers = opts.layers || self.baseLayers;
        self.requestSchemas = self.wrap.getRequestSchemas(opts);
        return self.requestSchemas;
    };

    ctlProto.getResolutions = function () {
        const self = this;
        var result = [];

        const resolutionMapper = function (tml) {
            return tml.res;
        };
        // Obtenemos un array de resoluciones por cada esquema de cada capa
        const allResolutions = self.requestSchemas.map(function (schema) {
            return schema.tileMatrixLimits.map(resolutionMapper);
        });

        // "Hacemos la cremallera" con los arrays de resoluciones de todas las capas y añadimos resoluciones al array de resultados
        result = result.concat.apply(result, allResolutions);
        result.sort(function (a, b) {
            return b - a;
        });
        return result;
    };

})();

TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.ControlContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;
};

TC.inherit(TC.control.ControlContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.ControlContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-cctr';
    ctlProto.SIDE = {
        LEFT: "left",
        RIGHT: "right"
    };

    ctlProto.template = {};
    if (TC.isDebug) {        
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ControlContainer.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/ControlContainerNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.write("<ul class=\"tc-ctl-cctr-left\">").section(ctx.get("controls"), ctx, { "block": body_1 }, null).write("</ul><ul class=\"tc-ctl-cctr-right\">").section(ctx.get("controls"), ctx, { "block": body_3 }, null).write("</ul>"); } function body_1(chk, ctx) { return chk.helper("eq", ctx, { "block": body_2 }, { "key": ctx.get("side"), "value": "left" }); } function body_2(chk, ctx) { return chk.write("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").reference(ctx.get("index"), ctx, "h").write("\"><div></div></li>"); } function body_3(chk, ctx) { return chk.helper("eq", ctx, { "block": body_4 }, { "key": ctx.get("side"), "value": "right" }); } function body_4(chk, ctx) { return chk.write("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").reference(ctx.get("index"), ctx, "h").write("\"><div></div></li>"); } return body_0; };        
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").f(ctx.get(["index"], false), ctx, "h").w("\"><div></div></li>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.onRenderPromise = function () {
        const self = this;

        var bufferPromises = new Array(self.ctlCount);

        Object.keys(self.controlOptions).forEach(function (key, i) {
            var ctl = self.controlOptions[key];            
            bufferPromises[i] = self.map.addControl(key, TC.Util.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i).querySelector('div')
            }, ctl.options));
        });

        Promise.all(bufferPromises).then(function () {
            for (var i = 0, len = arguments.length; i < len; i++) {
                var ctl = arguments[i];
                ctl.containerControl = self;
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({
            controls: Object.keys(self.controlOptions).map(function (key, i) {
                return TC.Util.extend(self.controlOptions[key], { index: i });
            })
        }));
    };

    ctlProto.addControl = function (control, options) {
        const self = this;
        options.side = options.side || self.SIDE.LEFT;

        return new Promise(function (resolve, reject) {
            self.getRenderedHtml(self.CLASS + '-node', { index: ++self.ctlCount }, function (html) {
                var template = document.createElement('template');
                template.innerHTML = html.trim();

                self.div.querySelector('ul.' + self.CLASS + '-' + options.side).appendChild(template.content ? template.content.firstChild : template.firstChild);
                self.map.addControl(control, TC.Util.extend({
                    id: self.getUID(),
                    div: self.div.querySelector('.' + self.CLASS + '-elm-' + self.ctlCount).querySelector('div')
                }, options)).then(function (ctrl) {
                    resolve(ctrl);
                });
            });
        });
    };

    ctlProto.addElement = function (options) {
        const self = this;

        options.side = options.side || self.SIDE.LEFT;

        var li = document.createElement('li');
        li.setAttribute('class', (self.CLASS + '-elm ') + (self.CLASS + '-elm-' + self.ctlCount++ + ' '));

        self.div.querySelector('ul.' + self.CLASS + '-' + options.side).appendChild(li);

        var addedElement = li.appendChild(options.htmlElement);
        addedElement.setAttribute('class', addedElement.getAttribute('class') + ' tc-ctl');
        return addedElement;
    };
})();

TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

TC.control.Coordinates = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.crs = '';
    self.xy = [0, 0, 0];
    self.latLon = [0, 0, 0];
    self.x = 0;
    self.y = 0;
    self.lat = 0;
    self.lon = 0;
    self.units = TC.Consts.units.METERS;
    self.isGeo = false;

    TC.control.ProjectionSelector.apply(self, arguments);

    TC.Util.extend(self._cssClasses, {
        CRS: self.CLASS + '-crs',
        GEOCRS: self.CLASS + '-geocrs',
        X: self.CLASS + '-x',
        Y: self.CLASS + '-y',
        LAT: self.CLASS + '-lat',
        LON: self.CLASS + '-lon',
        ELEVATION: self.CLASS + '-elevation',
        THREEDMARKER: self.CLASS + '-threed'
    });

    self.geoCrs = self.options.geoCrs || TC.Cfg.geoCrs;
    self.wrap = new TC.wrap.control.Coordinates(self);
};

TC.inherit(TC.control.Coordinates, TC.control.ProjectionSelector);

(function () {
    var ctlProto = TC.control.Coordinates.prototype;

    ctlProto.CLASS = 'tc-ctl-coords';

    var _dataKeys = {
        PROJCODE: 'tcProjCode'
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Coordinates.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CoordinatesDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div>CRS: <span class=\"tc-ctl-coords-crs\">").f(ctx.get(["crs"], false), ctx, "h").w("</span><button class=\"tc-ctl-coords-crs\" title=\"").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("\">").f(ctx.get(["crs"], false), ctx, "h").w("</button></div><div class=\"tc-ctl-coords-xy\">").x(ctx.get(["isGeo"], false), ctx, { "else": body_1, "block": body_3 }, {}).w("</div>").x(ctx.get(["showGeo"], false), ctx, { "block": body_5 }, {}).w("<span class=\"close\"></span>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("x: <span class=\"tc-ctl-coords-x\">").f(ctx.get(["x"], false), ctx, "h").w("</span> y: <span class=\"tc-ctl-coords-y\">").f(ctx.get(["y"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("z: <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-coords-lat\">").f(ctx.get(["lat"], false), ctx, "h").w("</span> ").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-coords-lon\">").f(ctx.get(["lon"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_4 }, {}); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<div class=\"tc-ctl-coords-alt\"><div class=\"tc-ctl-coords-xy\">").h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-coords-lat\">").f(ctx.get(["lat"], false), ctx, "h").w("</span> ").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-coords-lon\">").f(ctx.get(["lon"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_6 }, {}).w("</div></div>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_6.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-coords-crs-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "coords.currentProjection|h" }).w("</p><p class=\"tc-ctl-coords-no-change\">").h("i18n", ctx, {}, { "$key": "coords.noCrs.warning|s" }).w("</p><div class=\"tc-ctl-coords-change\"><p>").h("i18n", ctx, {}, { "$key": "coords.instructions|s" }).w("</p><p class=\"tc-msg-warning tc-hidden\">").h("i18n", ctx, {}, { "$key": "coords.instructions.warning|s" }).w("</p></div><ul class=\"tc-ctl-coords-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        self.crs = self.map.crs;

        self.clear();

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            if (view === TC.Consts.view.PRINTING) {
                return;
            }

            const _3dContainerListener = function (e) {
                if (!self.isPointerOver(e)) {
                    self.clear();
                }
            };

            if (view === TC.Consts.view.THREED) {
                self.isGeo = true;
                self.units = TC.Consts.units.DEGREES;
                self.crs = self.map.view3D.crs;

                self.map.view3D.container.addEventListener('mouseout', _3dContainerListener);

                /* provisional: faltaría el off cuando pasemos a default*/
                self.map.view3D.on(TC.Consts.event.MOUSEMOVE, function (coords) {
                    if (coords) {
                        if (TC.Util.detectMobile()) { // si estamos en móvil añadimos marcador al mapa 3D                            

                            self.clear();

                            self.coordsToClick({ coordinate: [coords.lon, coords.lat, coords.ele], cssClass: self._cssClasses.THREEDMARKER });
                        }

                        self.latLon = [coords.lat, coords.lon];
                        if (coords.ele > 0) {
                            var locale = TC.Util.getMapLocale(self.map);
                            self.latLon.push(coords.ele.toLocaleString(locale) + "m");
                        }

                        self.update();
                    } else {
                        self.clear();
                    }
                });

            } else if (view === TC.Consts.view.DEFAULT) {
                self.isGeo = self.map.wrap.isGeo();
                self.units = TC.Consts.units.METERS;
                self.crs = self.map.crs;

                if (self.map.view3D) {
                    self.map.view3D.container.removeEventListener('mouseout', _3dContainerListener);
                }                
            }

            if (self.map.view3D) {
                self.geoCrs = self.map.view3D.crs;
                self.render();
            }            
        });

        map.loaded(function () {
            // Se espera antes de registrar el control a que se cargue el mapa para evitar que muestre valores extraños
            self.wrap.register(map).then(function () {
                self.render(function () {
                    //self.update();
                    self.clear();
                });
            });

            if (TC.Util.detectMobile()) {
                self.renderPromise().then(function () {
                    self.getLayer();
                    self.activateCoords();
                });                
            }

            map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                if (!map.on3DView) {
                    self.isGeo = map.wrap.isGeo();
                    self.crs = e.crs;
                    self.render();
                }                
            });

            self.map.wrap.getViewport().then(function (viewport) {
                self.renderPromise().then(function () {
                    viewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
                        if (self.map.on3DView) {
                            return;
                        }

                        self.onMouseMove(e);
                    });
                    viewport.addEventListener(TC.Consts.event.MOUSELEAVE, function (e) {
                        self.onMouseLeave(e);
                    });
                });                
            });
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.renderData.call(self, {
                x: self.x,
                y: self.y,
                lat: self.lat,
                lon: self.lon,
                ele: self.isGeo && self.latLon.length > 2 ? self.latLon[2] : (!self.isGeo && self.xy.length > 2 ? self.xy[2] : null),
                crs: self.crs,
                geoCrs: self.geoCrs,
                isGeo: self.isGeo,
                showGeo: !self.isGeo && self.options.showGeo
            }, function () {
                self.div.querySelector('button.' + self._cssClasses.CRS).addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.showProjectionChangeDialog();
                });

                //self.div.addEventListener('mousemove', function (e) {
                //    self.setVisibility([e.clientX, e.clientY]);
                //});

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            });
        }));
    };

    ctlProto.onMouseMove = function (e) {
        this.wrap.onMouseMove(e);
    };

    ctlProto.onMouseLeave = function (e) {
        const self = this;
        setTimeout(function () {
            if (!self.isPointerOver(e)) {
                self.div.style.visibility = 'hidden';
                self.clear();
            }
        }, 200);
    };

    ctlProto.isPointerOver = function (e) {
        var self = this;

        var clientRect = self.div.getBoundingClientRect();
        return (clientRect.left <= e.clientX &&
            clientRect.left + clientRect.width >= e.clientX &&
            clientRect.top <= e.clientY &&
            clientRect.top + clientRect.height >= e.clientY);
    };

    ctlProto.formatCoord = function (x, nDecimales) {
        var result;
        result = x.toFixed(nDecimales);
        if (nDecimales <= 3) {
            result = result.replace(/\B(?=(\d{3})+(?!\d))/g, "|");
        }
        result = result.replace(".", ",").replace(/\|/g, ".");
        return result;
    };

    ctlProto.update = function () {
        const self = this;

        if (!self.isGeo && self.options.showGeo) {
            self.latLon = TC.Util.reproject(self.xy, self.crs, self.geoCrs).reverse();
        }

        if (!self.isGeo) {
            self.x = self.formatCoord(self.xy[0], TC.Consts.METER_PRECISION);
            self.y = self.formatCoord(self.xy[1], TC.Consts.METER_PRECISION);
        }

        if (self.isGeo || self.options.showGeo) {
            self.lat = self.formatCoord(self.latLon[0], TC.Consts.DEGREE_PRECISION);
            self.lon = self.formatCoord(self.latLon[1], TC.Consts.DEGREE_PRECISION);
        }

        self.render(function () {
            const closeSpan = self.div.querySelector('span.close');
            if (TC.Util.detectMobile()) {
                closeSpan.addEventListener('click', function () {
                    self.div.classList.add(TC.Consts.classes.HIDDEN);
                    self.clear();
                });

                closeSpan.style.display = '';
            }
            else {
                self.div.classList.remove(TC.Consts.classes.HIDDEN);
                self.div.style.visibility = 'visible';
                closeSpan.style.display = 'none';
            }
        });
    };

    ctlProto.clear = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.div.style.visibility = 'hidden';

        delete self.currentCoordsMarker;
        self.getLayer().then(function (layer) {
            layer.clearFeatures();
        });
    };

    ctlProto.deactivateCoords = function () {
        var self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.clear();

        self.wrap.coordsDeactivate();
    };

    ctlProto.activateCoords = function () {
        var self = this;

        self.wrap.coordsActivate();
    };

    ctlProto.getCoords = function () {
        var self = this;
        // si hay visible un popup, establecemos la posición de la cruz en el punto en el cual se ha abierto el popup
        var popup = self.map.getControlsByClass(TC.control.Popup);
        if (popup && popup.length > 0 && popup[0].isVisible()) {
            self.coordsToPopup(popup[0]);
        }
        else { // si no hay popup, calculamos el centro del mapa                
            self.updateCoordsCtrl([(self.map.getExtent()[0] + self.map.getExtent()[2]) / 2, (self.map.getExtent()[1] + self.map.getExtent()[3]) / 2]);

            self.coordsToClick.call(self, { coordinate: self.xy });
        }
    };

    ctlProto.coordsToPopup = function (popup) {
        var self = this;

        if (popup) {
            self.updateCoordsCtrl(popup.wrap.popup.getPosition());
        }
    };

    ctlProto.updateCoordsCtrl = function (position) {
        var self = this;

        if (position) {
            if (!self.isGeo) {
                self.x = position[0];
                self.y = position[1];
                self.xy = [self.x, self.y];

                if (position.length > 2) {
                    self.xy.push(position[2]);
                }
            }
            if (self.isGeo || self.options.showGeo) {
                self.lat = position[0];
                self.lon = position[1];
                self.latLon = [self.lat, self.lon];

                if (position.length > 2) {
                    self.latLon.push(position[2]);
                }
            }

            self.update();
        }
    };

    // Establece la posición de la cruz en la posición recibida
    //var animationTimeout;
    ctlProto.coordsToClick = function (e) {
        var self = this;

        // Si streetView está activo, no responde al click
        if (!self.map.div.classList.contains('tc-ctl-sv-active ' + TC.Consts.classes.COLLAPSED)) {

            var coordsBounding = self.div.getBoundingClientRect();
            if ((coordsBounding.left <= e.clientX && e.clientX <= coordsBounding.right && coordsBounding.top <= e.clientY && e.clientY <= coordsBounding.bottom)) {
                self.div.classList.add(TC.Consts.classes.HIDDEN);
                self.clear();

                return;
            }

            self.div.classList.remove('tc-fading');
            setTimeout(function () {
                self.div.classList.add('tc-fading');
            }, 10);

            self.updateCoordsCtrl(e.coordinate);

            if (!self.map.on3DView) {
                self.coordsMarkerAdd(e.coordinate, e.cssClass);
            }

            self.div.classList.remove(TC.Consts.classes.HIDDEN);
            //self.div.style.visibility = 'visible';

            //self.div.style.opacity = '0.7';

            //animationTimeout = setTimeout(function () {
            //    $(self.div).animate({ opacity: 0 }, 3000, "linear",
            //        function () {
            //            self.clear();
            //        });
            //}, 5000);
        }
    };

    ctlProto.coordsMarkerAdd = function (position, cssClass) {
        var self = this;

        if (!self.currentCoordsMarker) {
            self.getLayer().then(function (layer) {
                layer.addMarker(position, { title: 'Coord', showsPopup: false, cssClass: cssClass || TC.Consts.classes.POINT, anchor: [0.5, 0.5] })
                    .then(function (marker) {
                        self.currentCoordsMarker = marker;
                    });
            });
        } else {
            self.currentCoordsMarker.setCoords(position);
        }
    };

    ctlProto.getLayer = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer == undefined) {
                self.map.addLayer({
                    id: self.getUID(),
                    type: TC.Consts.layerType.VECTOR,
                    stealth: true,
                    title: 'Coordenadas',
                }).then(function (layer) {
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);
                    resolve(self.layer);
                });
            } else {
                resolve(self.layer);
            }
        });
    };

})();
TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.DataLoader = function () {
    const self = this;

    TC.control.TabContainer.apply(self, arguments);

    self.controlOptions = [
        {
            name: 'externalWMS',
            title: 'addWMS',
            options: {
                suggestions: self.options.wmsSuggestions
            }
        },
        {
            name: 'fileImport',
            options: {
                enableDragAndDrop: self.options.enableDragAndDrop
            }
        }
    ];
    self.defaultSelection = 0;
};

TC.inherit(TC.control.DataLoader, TC.control.TabContainer);

(function () {
    var ctlProto = TC.control.DataLoader.prototype;

    ctlProto.register = function (map) {
        const self = this;
        self.title = self.getLocaleString('addMaps');
        return TC.control.TabContainer.prototype.register.call(self, map);
    };

})();

TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

TC.control.Download = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self._hiddenElms = [];

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }    
};

TC.inherit(TC.control.Download, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Download.prototype;

    ctlProto.CLASS = 'tc-ctl-download';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Download.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/DownloadDialog.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "download" }).w(" </h2><div class=\"tc-ctl-tctr tc-ctl-tctr-select\"><form><label class=\"tc-ctl-tctr-tab tc-ctl-download-image\" style=\"width:calc(100%/2 - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"image\" /><span>").h("i18n", ctx, {}, { "$key": "dl.export.map" }).w("</span></label><label class=\"tc-ctl-tctr-tab tc-ctl-download-data\" style=\"width:calc(100%/2 - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"data\" /><span>").h("i18n", ctx, {}, { "$key": "dl.export.vector" }).w("</span></label></form></div><div class=\"tc-ctl tc-ctl-tctr-elm tc-ctl-tctr-elm-image tc-group tc-ctl-download-cnt tc-ctl-download-image tc-collapsed\"><div><label>").h("i18n", ctx, {}, { "$key": "format" }).w(":</label><select id=\"download-format-image\" class=\"tc-combo\"><option value=\"image/png\">PNG</option><option value=\"image/jpeg\">JPEG</option></select><div class=\"tc-ctl-download-div\"><input id=\"tc-ctl-download-image-qr\" class=\"tc-hidden\" type=\"checkbox\" checked style=\"display:none;\" /><label for=\"tc-ctl-download-image-qr\" class=\"tc-ctl-download-image-qr-label\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCodeToImage" }).w("\">").h("i18n", ctx, {}, { "$key": "appendQRCode" }).w("</label></div><div class=\"tc-group tc-group tc-ctl-download-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-ctl-download-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "downloadImageFromCurrentMap" }).w("\" name=\"descargar\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button></div><div class=\"tc-ctl-download-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div></div><div class=\"tc-ctl tc-ctl-tctr-elm tc-ctl-tctr-elm-data tc-group tc-ctl-download-cnt tc-collapsed\"><div><label>").h("i18n", ctx, {}, { "$key": "format" }).w(":</label><select id=\"download-format\" class=\"tc-combo\"><option value=\"GML32\">GML</option><option value=\"application/json\">GeoJSON</option><option value=\"application/vnd.google-earth.kml+xml\">KML (Google Earth)</option><option value=\"shape-zip\">Shape (ESRI)</option></select><div class=\"tc-ctl-download-div\"><i class=\"tc-ctl-download-help icon-question-sign\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "showDownloadHelp" }).w("\"></i></div><div class=\"tc-group tc-group tc-ctl-download-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-ctl-download-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "downloadLayersFromCurrentExtent" }).w("\" name=\"descargar\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button></div><div class=\"tc-alert alert-warning tc-hidden\"><p id=\"zoom-msg\"><strong>").h("i18n", ctx, {}, { "$key": "tooManyFeatures" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "tooManyFeatures.instructions" }).w("</p><p id=\"layers-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noLayersLoaded" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noLayersLoaded.instructions" }).w("</p><p id=\"url-msg\"><strong>").h("i18n", ctx, {}, { "$key": "tooManySelectedLayers" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "tooManySelectedLayers.instructions" }).w("</p><p id=\"noFeatures-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noData" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noData.instructions" }).w("</p><p id=\"novalid-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noValidService" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noValidService.instructions" }).w("</p></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-download-help-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "downloadData" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "dl.instructions.1|s" }).w("</p><ul><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.2|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.3|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.4|s" }).w("<ul><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.5|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.6|s" }).w("</li></ul></li></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, function () {

                const cs = '.tc-ctl-tctr';
                self._selectors = {
                    TAB: cs + '-tab',
                    RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
                    ELEMENT: cs + '-elm'
                };

                const clickHandler = function (e) {
                    var tab = this;
                    while (tab && !tab.matches(self._selectors.TAB)) {
                        tab = tab.parentElement;
                    }
                    if (tab) {
                        const checkbox = tab.querySelector(self._selectors.RADIOBUTTON);
                        const newValue = checkbox.value;
                        const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                        if (self._oldValue === newValue && self.options.deselectable) {
                            setTimeout(function () {
                                checkbox.checked = false;
                            }, 0);
                            self._oldValue = null;
                            self._activeElm = null;
                            elms.forEach(function (elm) {
                                self._hiddenElms.push(elm);
                            });
                        }
                        else {
                            elms.forEach(function (elm) {
                                if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                                    self._activeElm = elm;
                                }
                                else {
                                    self._hiddenElms.push(elm);
                                }
                            });
                            self._oldValue = newValue;
                        }

                        self._hiddenElms.forEach(function (elm) {
                            elm.classList.add(TC.Consts.classes.COLLAPSED);
                        });
                        if (self._activeElm) {
                            self._activeElm.classList.remove(TC.Consts.classes.COLLAPSED);
                        }
                        checkbox.checked = true;
                    }
                };

                self.div.querySelectorAll('span').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, clickHandler);
                });
                if (callback) {
                    callback();
                }
            });
        });
    };

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        /**
         * Descarga las features de las capas de trabajo actualmente seleccionadas. Comprueba que el número de features a descargar
         * no excede el límite impuesto por el servidor.
         */       

        var _download = function () {
            var wait = self.map.getLoadingIndicator().addWait();

            var format = '';
            if (self._activeElm) {
                format = self._activeElm.querySelector('select').value;
            }
            if (format.indexOf('image') > -1) {
                const doneQR = new Promise(function (resolve, reject) {
                    var canvas = self.map.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
                    var newCanvas = TC.Util.cloneCanvas(canvas);

                    var sb = self.map.getControlsByClass(TC.control.ScaleBar);
                    if (sb) {
                        self.drawScaleBarIntoCanvas({ canvas: newCanvas, fill: true });
                    }

                    if (self._activeElm.querySelector('#' + self.CLASS + '-image-qr:checked')) {
                        const codeContainerId = 'qrcode';
                        var codeContainer = document.getElementById(codeContainerId);
                        if (codeContainer) {
                            codeContainer.innerHTML = '';
                        }
                        else {
                            codeContainer = document.createElement('div');
                            codeContainer.setAttribute('id', codeContainerId);
                            document.body.appendChild(codeContainer);
                        }

                        codeContainer.style.top = '-200px';
                        codeContainer.style.left = '-200px';
                        codeContainer.style.position = 'absolute';

                        self.makeQRCode(codeContainer, 87, 87).then(function (qrCodeBase64) {
                            if (qrCodeBase64) {
                                var ctx = newCanvas.getContext("2d");
                                ctx.fillStyle = "#ffffff";
                                ctx.fillRect(newCanvas.width - 91, newCanvas.height - 91, 91, 91);

                                TC.Util.addToCanvas(newCanvas, qrCodeBase64, { x: newCanvas.width - 88, y: newCanvas.height - 88 }).then(function (mapCanvas) {
                                    resolve(mapCanvas);
                                });
                            } else {
                                TC.error(self.getLocaleString('dl.export.map.error') + ': ' + 'QR');
                                self.map.getLoadingIndicator().removeWait(wait);
                            }
                        });
                    } else {
                        resolve(newCanvas);
                    }
                });

                doneQR.then(function (_canvas) {
                    try {
                        const res = _canvas.toDataURL(format);
                        TC.Util.downloadDataURI(window.location.hostname + '_' + TC.Util.getFormattedDate(new Date().toString(), true) + '.' + format.split('/')[1], format, res);
                    } catch (e) {
                        TC.error(self.getLocaleString('dl.export.map.error') + ': ' + e.message);
                    }

                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
            else {
                var extent = self.map.getExtent();
                
                var arrPromises = TC.WFSGetFeatureBuilder(self.map, new TC.filter.bbox(extent, self.map.getCRS()), format, true);
                Promise.all(arrPromises).then(function (responseArray) {

                    var responses = responseArray.filter(function (item) { return item != null });
                    if (responses.length === 0) {
                        _showAlertMsg({ key: TC.Consts.WFSErrors.NoLayers }, wait);
                        return;
                    }
                    var arrDownloads = [];
                    for (var i = 0; i < responses.length; i++) {
                        //errores del WFS
                        if (responses[i].errors && responses[i].errors.length) {
                            for (var j = 0; j < responses[i].errors.length; j++) {
                                var error = responses[i].errors[j];
                                _showAlertMsg(error, wait);
                            }
                            continue;
                        }
                        var data = responses[i].data;
                        var url = responses[i].url;
                        if (data && url)
                            arrDownloads.push({ url: url + "?download=zip", data: data });
                    }

                    TC.Util.downloadFileForm(arrDownloads);
                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
        };

        /**
         * Comprueba si hay capas visibles en el panel de capas cargadas.
         */
        var _getVisibleLayers = function () {
            var visibleLayers = [];
            for (var i = 0; i < self.map.workLayers.length; i++) {
                var layer = self.map.workLayers[i];
                if (layer.type === TC.Consts.layerType.WMS) {
                    if (layer.getVisibility() && layer.names.length > 0) {
                        visibleLayers.push(layer);
                    }
                }
            }
            return visibleLayers;
        };

        var _showAlertMsg = function (error, wait) {
            const alert = self.div.querySelector('.alert-warning:not(.' + self.CLASS + '-alert)');
            var errorMsg;
            switch (error.key) {
                case TC.Consts.WFSErrors.NumMaxFeatures:
                    errorMsg = alert.querySelector("#zoom-msg").innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NoLayers:
                    errorMsg = self.getLocaleString('noLayersLoaded');
                    break;
                case TC.Consts.WFSErrors.GetCapabilities:
                    errorMsg = alert.querySelector("#novalid-msg").innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NoFeatures:
                    errorMsg = alert.querySelector("#noFeatures-msg").innerHTML;
                    break;
                case TC.Consts.WFSErrors.Indeterminate:
                    errorMsg = self.getLocaleString("wfs.IndeterminateError");
                    self.map.toast(errorMsg, { type: TC.Consts.msgType.ERROR });
                    TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                    self.map.getLoadingIndicator().removeWait(wait);
                    return
                    break;
                default:
                    errorMsg = self.getLocaleString("wfs." + error.key, error.params);
                    break;
            }
            self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

            self.map.getLoadingIndicator().removeWait(wait);
        };

        var _showHelp = function (evt) {
            evt.stopPropagation();
            TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-help-dialog'));
        };

        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-btn', _download));
        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-help', _showHelp));

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector("#" + self.CLASS + "-image-qr", function (e) {
            if (e.target.checked) {
                self.generateLink();
            } else {
                self.div.querySelector('.' + self.CLASS + '-alert').classList.add(TC.Consts.classes.HIDDEN);
            }
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {            
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;
        const alert = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.getElementById(self.CLASS + '-image-qr').checked) {
            alert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
        } else {
            alert.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}
if (!TC.Feature || !TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}
if (!TC.Feature || !TC.feature.Polyline) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polyline');
}
if (!TC.Feature || !TC.feature.Polygon) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polygon');
}

TC.Consts.event.DRAWSTART = 'drawstart.tc';
TC.Consts.event.DRAWEND = 'drawend.tc';
TC.Consts.event.DRAWCANCEL = 'drawcancel.tc';
TC.Consts.event.DRAWUNDO = 'drawundo.tc';
TC.Consts.event.DRAWREDO = 'drawredo.tc';
TC.Consts.event.MEASURE = 'measure.tc';
TC.Consts.event.MEASUREPARTIAL = 'measurepartial.tc';
TC.Consts.event.STYLECHANGE = 'stylechange.tc';
TC.Consts.event.CHANGE = 'change';

(function () {

    const formatColor = function (color) {
        const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
        if (match && match.length) {
            return '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
        }
        return color;
    };

    TC.control.Draw = function () {
        var self = this;

        TC.Control.apply(self, arguments);

        if (!TC.browserFeatures.inputTypeColor() && !window.CP) {
            TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
            TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
        }

        self._classSelector = '.' + self.CLASS;

        self._pointClass = self.CLASS + '-point';
        self._lineClass = self.CLASS + '-line';
        self._polygonClass = self.CLASS + '-polygon';

        self.history = [];
        self.historyIndex = 0;
        self.exportsState = true;

        self
            .on(TC.Consts.event.DRAWSTART, function (e) {
                self.resetValues();
            })
            .on(TC.Consts.event.POINT, function (e) {
                if (self.layer && !self.persistent && self.layer.features && self.layer.features.length > 0) {
                    self.layer.clearFeatures();
                }

                self.history.length = self.historyIndex;
                self.history[self.historyIndex++] = e.point;

                setDrawState(self);
            })
            .on(TC.Consts.event.DRAWEND, function (e) {
                setFeatureAddReadyState(self);

                e.feature.setId(TC.getUID(self.getLocaleString('sketch') + '.'));

                if (self.callBack) {
                    self.callBack(e.feature);
                }
            });

        self._layerPromise = null;
    };

    TC.inherit(TC.control.Draw, TC.Control);

    var ctlProto = TC.control.Draw.prototype;

    ctlProto.CLASS = 'tc-ctl-draw';

    var setDrawState = function (ctl) {
        ctl._endBtn.disabled =
            ctl.historyIndex === 0 ||
            (ctl.mode === TC.Consts.geom.POLYGON && ctl.historyIndex < 3) ||
            (ctl.mode === TC.Consts.geom.POLYLINE && ctl.historyIndex < 2);
        ctl._redoBtn.disabled = ctl.history.length === ctl.historyIndex;
        ctl._undoBtn.disabled = ctl.historyIndex === 0;
    };

    var setFeatureAddReadyState = function (ctl) {
        ctl.resetValues();
        ctl._endBtn.disabled = true;
        ctl._cancelBtn.disabled = false;
    };

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Draw.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-draw-tools\"><button class=\"tc-ctl-btn tc-ctl-draw-btn-new\" title=\"").f(ctx.get(["tooltip"], false), ctx, "h").w("\">").h("i18n", ctx, {}, { "$key": "new" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-undo\" disabled title=\"").h("i18n", ctx, {}, { "$key": "undo" }).w("\">").h("i18n", ctx, {}, { "$key": "undo" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-redo\" disabled title=\"").h("i18n", ctx, {}, { "$key": "redo" }).w("\">").h("i18n", ctx, {}, { "$key": "redo" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-end\" disabled title=\"").h("i18n", ctx, {}, { "$key": "end" }).w("\">").h("i18n", ctx, {}, { "$key": "end" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-cancel\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div>").x(ctx.get(["styleTools"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-draw-style\">").h("i18n", ctx, {}, { "$key": "strokeColor" }).w("<input type=\"color\" class=\"tc-ctl-col tc-ctl-draw-str-c\" value=\"").f(ctx.get(["strokeColor"], false), ctx, "h").w("\" title=\"").h("i18n", ctx, {}, { "$key": "selectColor" }).w("\" />").h("i18n", ctx, {}, { "$key": "strokeWidth" }).w("<div class=\"tc-ctl-draw-str-w-watch\" style=\"border-bottom-width:").f(ctx.get(["strokeWidth"], false), ctx, "h").w("px;\"> </div><input type=\"number\" class=\"tc-ctl-draw-str-w tc-textbox\" value=\"").f(ctx.get(["strokeWidth"], false), ctx, "h").w("\" min=\"1\" max=\"15\" /></div>"); } body_1.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        var self = this;
        var strToolTip;
        var strokeColor;
        var strokeWidth;
        switch (self.options.mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                strToolTip = self.getLocaleString('drawLine');
                self.div.classList.add(self._lineClass);
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                strToolTip = self.getLocaleString('drawPolygon');
                self.div.classList.add(self._polygonClass);
                strokeColor = TC.Cfg.styles.polygon.strokeColor;
                strokeWidth = TC.Cfg.styles.polygon.strokeWidth;
                break;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                strToolTip = self.getLocaleString('drawPoint');
                self.div.classList.add(self._pointClass);
                strokeColor = TC.Cfg.styles.point.strokeColor;
                strokeWidth = TC.Cfg.styles.point.strokeWidth;
                break;
            default:
                strToolTip = self.getLocaleString('draw');
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
        }
        const renderObject = {
            tooltip: strToolTip,
            strokeColor: formatColor(strokeColor),
            strokeWidth: strokeWidth,
            styleTools: self.options.styleTools
        };
        return self._set1stRenderPromise(self.renderData(renderObject, function () {
            if (!TC.browserFeatures.inputTypeColor()) {
                // El navegador no soporta input[type=color], usamos polyfill
                const input = self.div.querySelector('input[type=color]');
                if (input) {
                    input.style.backgroundColor = input.value;
                    input.style.color = 'transparent';
                    const picker = new CP(input, 'click', document.body);

                    input.onclick = function (e) {
                        e.preventDefault();
                    };

                    // Evitamos que salga el teclado virtual en iOS
                    input.onfocus = function (e) {
                        this.blur();
                    };

                    input.onchange = function (e) {
                        this.style.backgroundColor = this.value;
                    };

                    self.map.loaded(function () {
                        picker.on("change", function (color) {
                            self.setStrokeColor('#' + color);
                        });
                    });
                }
            }
            self.reset = true;
            self.callBack = null;
            self.measure = false;
            self._cancelClick = false;

            self.mode = self.options.mode || TC.Consts.geom.POLYLINE;

            if (self.options.measure)
                self.measure = self.options.measure
            if (TC.Util.isFunction(self.options.callback))
                self.callBack = self.options.callback;
            if (self.options.persistent === undefined) {
                self.persistent = true;
            }
            else {
                self.persistent = self.options.persistent;
            }

            self.wrap = new TC.wrap.control.Draw(self);

            self._newBtn = self.div.querySelector(self._classSelector + '-btn-new');
            self._newBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.new();
            });

            self._cancelBtn = self.div.querySelector(self._classSelector + '-btn-cancel');
            self._cancelBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.cancel();
            });

            self._endBtn = self.div.querySelector(self._classSelector + '-btn-end');
            self._endBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.end();
            });

            self._undoBtn = self.div.querySelector(self._classSelector + '-btn-undo');
            self._undoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.undo();
            });

            self._redoBtn = self.div.querySelector(self._classSelector + '-btn-redo');
            self._redoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.redo();
            });

            if (self.options.styleTools) {
                self._strokeColorPicker = self.div.querySelector(self._classSelector + '-str-c');
                self._strokeColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeColor(e.target.value);
                });

                self._strokeWidthSelector = self.div.querySelector(self._classSelector + '-str-w');
                self._strokeWidthSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeWidth(e.target.value);
                });
                self._strokeWidthWatch = self.div.querySelector(self._classSelector + '-str-w-watch');
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.map.on(TC.Consts.event.VIEWCHANGE, function () {
            if (self.map.view === TC.Consts.view.PRINTING) {
                self.end();

                // No lanzo el evento porque da error al no llegar una feature
                // self.trigger(TC.Consts.event.DRAWEND);
            }
        });

        const setStyles = function () {
            self.styles = {};
            TC.Util.extend(true, self.styles, self.options.styles || self.layer.options.styles);
        };

        self._layerPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                if (self.options.layer) {
                    self.setLayer(self.options.layer);
                    resolve(self.layer);
                    setStyles();
                }
                else {
                    // Si self.options.layer === false se instancia el control sin capa asociada
                    if (self.options.layer === false) {
                        self.setLayer(null);
                        resolve(null);
                    }
                    else {
                        map.addLayer({
                            id: self.getUID(),
                            title: 'DrawControl',
                            stealth: true,
                            type: TC.Consts.layerType.VECTOR,
                            styles: {
                                point: map.options.styles.point,
                                line: map.options.styles.line,
                                polygon: map.options.styles.polygon
                            }
                        }).then(function (layer) {
                            map.putLayerOnTop(layer);
                            self.setLayer(layer);
                            resolve(self.layer);
                            setStyles();
                        });
                    }
                }
            });
        });

        return result;
    };

    ctlProto.new = function () {
        var self = this;
        if (self.layer && !self.persistent) {
            self.layer.clearFeatures();
        }
        self._cancelBtn.disabled = false;
        self.setMode(self.mode, true);
        return self;
    };

    ctlProto.undo = function () {
        var self = this;
        var result = self.wrap.undo();
        if (result) {
            self.historyIndex--;
            setDrawState(self);

            if (self.historyIndex <= 0) {
                self.resetValues();
            }
            self.trigger(TC.Consts.event.DRAWUNDO);
        }

        return result;
    };

    ctlProto.redo = function () {
        var self = this;
        var result = this.wrap.redo();
        if (result) {
            self.historyIndex++;
            setDrawState(self);
            self.trigger(TC.Consts.event.DRAWREDO);
        }
        return result;
    };

    ctlProto.cancel = function () {
        var self = this;
        self._cancelClick = true;
        this.setMode(null, false);
        self.resetValues();
        setFeatureAddReadyState(self);
        self._cancelBtn.disabled = true;
        self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        return self;
    };

    ctlProto.activate = function () {
        var self = this;
        self._newBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._cancelBtn.disabled = false;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
        self.div.classList.remove(self._pointClass, self._lineClass, self._polygonClass);
        switch (self.mode) {
            case TC.Consts.geom.POINT:
                self.div.classList.add(self._pointClass);
                break;
            case TC.Consts.geom.POLYLINE:
                self.div.classList.add(self._lineClass);
                break;
            case TC.Consts.geom.POLYGON:
                self.div.classList.add(self._polygonClass);
                break;
            default:
                break;
        }

    };

    ctlProto.deactivate = function () {
        var self = this;
        if (self._newBtn) {
            self._newBtn.classList.remove(TC.Consts.classes.ACTIVE);
        }
        if (self._cancelBtn) {
            self._cancelBtn.disabled = true;
        }
        TC.Control.prototype.deactivate.call(self, !self._cancelClick);
        if (self.wrap) {
            self.wrap.deactivate();
        }
        self.resetValues();
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        self._cancelClick = false;
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        self.resetValues();
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        self.resetValues();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            if (self.layer) {
                self.layer.map.putLayerOnTop(self.layer);
            }
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.setStyle = function (style) {
        const self = this;
        if (style) {
            TC.Util.extend(self.style, style);
        }
        else {
            switch (self.options.mode) {
                case TC.Consts.geom.POLYLINE:
                case TC.Consts.geom.MULTIPOLYLINE:
                    style = { line: self.styles.line };
                    break;
                case TC.Consts.geom.POLYGON:
                case TC.Consts.geom.MULTIPOLYGON:
                    style = { polygon: self.styles.polygon };
                    break;
                case TC.Consts.geom.POINT:
                case TC.Consts.geom.MULTIPOINT:
                    style = { point: self.styles.point };
                    break;
                default:
                    style = {};
                    break;
            }
        }
        if (self.isActive) {
            self.wrap.setStyle(style);
        }
    };

    ctlProto.getModeStyle = function(mode) {
        const self = this;
        mode = mode || self.options.mode;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                return self.styles.line;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                return self.styles.polygon;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                return self.styles.point;
            default:
                return null;
                break;
        }
    };

    ctlProto.setStrokeColorWatch = function (color) {
        const self = this;
        if (self.options.styleTools) {
            if (color === undefined) {
                color = self.getModeStyle().strokeColor;
            }
            const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (match && match.length) {
                color = '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
            }
            self._strokeColorPicker.value = color;
            if (!TC.browserFeatures.inputTypeColor()) {
                const input = self._strokeColorPicker;
                input.style.backgroundColor = color;
                input.blur();
            }
        }
        return self;
    };

    ctlProto.setStrokeColor = function (color) {
        const self = this;
        const style = self.getModeStyle();
        if (style) {
            style.strokeColor = color;
        }

        // Resetea el estilo
        if (self.isActive) {
            self.setStyle();
        }

        self.setStrokeColorWatch(color);
        self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeColor', value: color });
        return self;
    };

    ctlProto.setStrokeWidthWatch = function (width) {
        const self = this;
        if (self.options.styleTools) {
            if (width === undefined) {
                width = self.getModeStyle().strokeWidth;
            }
            width = parseInt(width, 10);
            if (width !== Number.NaN) {
                self._strokeWidthSelector.value = width;
                self._strokeWidthWatch.style.borderBottomWidth = width + 'px';
            }
        }
        return self;
    };

    ctlProto.setStrokeWidth = function(width) {
        const self = this;
        width = parseInt(width, 10);
        if (width !== Number.NaN) {
            const style = self.getModeStyle();
            if (style) {
                style.strokeWidth = width;
            }

            // Resetea el estilo
            if (self.isActive) {
                self.setStyle();
            }

            self.setStrokeWidthWatch(width);
            self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeWidth', value: width });
        }
        return self;
    };

    ctlProto.getLayer = function() {
        return this._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        if (self.map) {
            if (typeof (layer) === "string") {
                self.layer = self.map.getLayer(layer);
            }
            else {
                self.layer = layer;
            }
        }
    };

    ctlProto.resetValues = function () {
        const self = this;
        self.history.length = 0;
        self.historyIndex = 0;
        setDrawState(self);
        return self;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.getLayer().then(function (layer) {
            layer.importState(state.layer);
        });
    };
})();
TC.control = TC.control || {};

if (!TC.control.Measure) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Measure');
}

TC.control.DrawMeasureModify = function () {
    var self = this;

    TC.control.Measure.apply(self, arguments);

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]'
    };

    self.persistentDrawControls = true;

    self.renderPromise().then(function () {
        self._1stCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-1-t');
        self._2ndCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-2-t');
        self._1stCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-1-v');
        self._2ndCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-2-v');
        self._elevationText = self.div.querySelector('.tc-ctl-meas-val-coord-ele-t');
        self._elevationValue = self.div.querySelector('.tc-ctl-meas-val-coord-ele-v');
    });

    if (self.options.displayElevation) {        
        self.elevationProfileActive = true;
        TC.loadJS(
            !TC.tool || !TC.tool.Elevation,
            TC.apiLocation + 'TC/tool/Elevation',
            function () {
                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                self.elevation = new TC.tool.Elevation(elevationOptions);
            }
        );
    }
};

TC.inherit(TC.control.DrawMeasureModify, TC.control.Measure);

(function () {
    var ctlProto = TC.control.DrawMeasureModify.prototype;

    ctlProto.CLASS = 'tc-ctl-dmm';

    var _dataKeys = {
        VALUE: 'tcValue'
    };


    TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';
    TC.Consts.event.FEATURESSELECT = TC.Consts.event.FEATURESSELECT || "featuresselect.tc";

    const elevationProfileCache = [];

    const getElevationProfileFromCache = function (feature) {
        return elevationProfileCache.filter(function (elm) {
            return elm.feature === feature;
        })[0];
    };

    const cacheElevationProfile = function (feature, data) {
        var result = getElevationProfileFromCache(feature);
        if (!result) {
            result = {
                feature: feature
            };
            elevationProfileCache.push(result);
        }
        result.data = data;
        return result;
    };

    const removeElevationProfileFromCache = function (feature) {
        const featIdx = elevationProfileCache.reduce(function (prev, cur, idx) {
            if (cur.feature === feature) {
                return idx;
            }
            return prev;
        }, -1);
        if (featIdx >= 0) {
            elevationProfileCache.splice(featIdx, 1);
        }
    };

    const clearElevationProfileCache = function () {
        elevationProfileCache.length = 0;
    };

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/DrawMeasureModify.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/DrawMeasureModifyDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "drawAndMeasure" }).w("</h2><div class=\"tc-ctl-meas-select\"><form><label class=\"tc-ctl-meas-btn-pt\"><input type=\"radio\" name=\"mode\" value=\"point\" /><span>").h("i18n", ctx, {}, { "$key": "points" }).w("</span></label><label class=\"tc-ctl-meas-btn-len\"><input type=\"radio\" name=\"mode\" value=\"polyline\" /><span>").h("i18n", ctx, {}, { "$key": "lines" }).w("</span></label><label class=\"tc-ctl-meas-btn-area\"><input type=\"radio\" name=\"mode\" value=\"polygon\" /><span>").h("i18n", ctx, {}, { "$key": "polygons" }).w("</span></label></form></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-pt tc-hidden\"><div class=\"tc-ctl-meas-point\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "search.list.coordinates" }).w(" <span class=\"tc-ctl-meas-val-coord\"><span class=\"tc-ctl-meas-val-coord-1-t\"></span> <span class=\"tc-ctl-meas-val-coord-1-v\"></span> <span class=\"tc-ctl-meas-val-coord-2-t\"></span> <span class=\"tc-ctl-meas-val-coord-2-v\"></span> <span class=\"tc-ctl-meas-val-coord-ele-t\"></span> <span class=\"tc-ctl-meas-val-coord-ele-v\"></span></span></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-len tc-hidden\"><div class=\"tc-ctl-meas-line\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "2dLength" }).w(": <span class=\"tc-ctl-meas-val-len\"></span><button class=\"tc-ctl-meas-prof-btn tc-active\" title=\"").h("i18n", ctx, {}, { "$key": "deactivateElevationProfile" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.chart.chpe" }).w("</button></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-area tc-hidden\"><div class=\"tc-ctl-meas-polygon\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "area" }).w(": <span class=\"tc-ctl-meas-val-area\"></span>, ").h("i18n", ctx, {}, { "$key": "2dPerimeter" }).w(": <span class=\"tc-ctl-meas-val-peri\"></span></div></div><div class=\"tc-ctl-dmm-tool\"><div class=\"tc-ctl-dmm-mod\"></div><div class=\"tc-ctl-dmm-cmd\"><button class=\"tc-ctl-dmm-btn-clr\" disabled title=\"").h("i18n", ctx, {}, { "$key": "deleteAll" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteAll" }).w("</button><button class=\"tc-ctl-dmm-btn-dl\" disabled title=\"").h("i18n", ctx, {}, { "$key": "download" }).w("\">").h("i18n", ctx, {}, { "$key": "download" }).w("...</button></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "downloadSketch" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").s(ctx.get(["elevation"], false), ctx, { "block": body_1 }, {}).w("<div class=\"tc-ctl-dmm-dialog-dl\"><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-kml\" data-format=\"KML\" title=\"KML\">KML</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-gml\" data-format=\"GML\" title=\"GML\">GML</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-geojson\" data-format=\"GeoJSON\" title=\"GeoJSON\">GeoJSON</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-wkt\" data-format=\"WKT\" title=\"WKT\">WKT</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-gpx\" data-format=\"GPX\" title=\"GPX\">GPX</button></div></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog-elev\"><input id=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" type=\"checkbox\" checked /><label for=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" class=\"tc-ctl-ftools-dialog-elev-label\">").h("i18n", ctx, {}, { "$key": "includeElevations" }).w("</label></div>").x(ctx.get(["resolution"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog-ip\"><h4>").h("i18n", ctx, {}, { "$key": "interpolateCoordsFromElevProfile" }).w("</h4><label><input type=\"radio\" name=\"ip-coords\" value=\"0\" checked /><span>").h("i18n", ctx, {}, { "$key": "no" }).w("</span></label><label><input type=\"radio\" name=\"ip-coords\" value=\"1\"/><span>").h("i18n", ctx, {}, { "$key": "yes" }).w("</span></label><div class=\"tc-ctl-dmm-dialog-ip-m tc-hidden\">").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.1" }).w("<input type=\"number\" min=\"1\" step=\"1\" class=\"tc-textbox\" value=\"").f(ctx.get(["resolution"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.2" }).w("</div></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        const promise = self._set1stRenderPromise(TC.control.Measure.prototype.render.call(self, function () {
            self._clearBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-clr');
            self._clearBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                TC.confirm(self.getLocaleString('deleteAll.confirm'), function () {
                    self.clear();
                });
            });
            self._downloadBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-dl');
            self._downloadBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showSketchDownloadDialog();
            });

            self._elevProfileBtn = self.div.querySelector('.tc-ctl-meas-prof-btn');
            self._elevProfileBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.elevationProfileActive ? self.deactivateElevationProfile() : self.activateElevationProfile();
            });

            if (!self.options.displayElevation) {
                self._elevProfileBtn.style.display = 'none';
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));

        const renderOptions = {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        };
        self.getRenderedHtml(self.CLASS + '-dialog', renderOptions, function (html) {
            const endExport = function (format) {
                TC.Util.closeModal();
                const exportOptions = {
                    fileName: self.getLocaleString('sketch').toLowerCase().replace(' ', '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true),
                    format: format
                };
                const includeElevation = self.options.displayElevation ? self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked : false;
                if (includeElevation) {
                    const interpolateCoords = self._dialogDiv.querySelector('input[type=radio][name=ip-coords]:checked').value === "1";
                    const li = self.map.getLoadingIndicator();
                    const waitId = li && li.addWait();

                    const elevOptions = {
                        crs: self.map.crs,
                        features: self.layer.features.map(function (feat) {
                            // Solo mantenemos las features de las que hay que obtener elevación:
                            // - Las que no tienen elevación
                            // - Cuando hay interpolación, todas las líneas y los polígonos
                            if (feat.getGeometryStride() >= 3) {
                                if (!interpolateCoords || (TC.feature.Point && feat instanceof TC.feature.Point)) {
                                    return null;
                                }
                            }
                            return feat.clone();
                        }),
                        maxCoordQuantity: self.options.displayElevation.maxCoordQuantity,
                        sampleNumber: 0 // No queremos determinar el número de muestras
                    };
                    if (interpolateCoords) {
                        elevOptions.resolution = parseFloat(self._dialogDiv.querySelector('.' + self.CLASS + '-dialog-ip-m input[type=number]').value) || self.options.displayElevation.resolution;
                    }
                    self.elevation.setGeometry(elevOptions)
                        .then(function (features) {
                            // Volvemos a añadir las features de las que no hemos pedido elevación
                            features.forEach(function (feat, idx) {
                                if (!feat) {
                                    features[idx] = self.layer.features[idx];
                                }
                            });
                            self.map.exportFeatures(features, exportOptions);
                        })
                        .catch(function (error) {
                            if (error.message === TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED) {
                                TC.alert(self.getLocaleString('tooManyCoordinatesForElevation.warning'));
                                return;
                            }
                            TC.error(self.getLocaleString('elevation.error'));
                        })
                        .finally(function () {
                            li && li.removeWait(waitId);
                        });
                }
                else {
                    var features;
                    if (self.options.displayElevation && !includeElevation) { // Hay que quitar elevaciones
                        features = self.layer.features
                            .map(function (feat) {
                                var f = feat.clone();
                                if (f.getGeometryStride() > 2) {
                                    f.getCoordsArray().forEach(function (coord) {
                                        coord.length = 2;
                                    });
                                    f.setCoords(f.geometry);
                                }
                                return f;
                            });
                    }
                    else {
                        features = self.layer.features;
                    }
                    self.map.exportFeatures(features, exportOptions);
                }
            };
            self._dialogDiv.innerHTML = html;
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.ELEVATION_CHECKBOX, function (e) {
                self.showSketchDownloadDialog(); // Recalculamos todo el aspecto del diálogo de descarga
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio][name=ip-coords]', function (e) {
                const ipMessage = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog-ip-m');
                ipMessage.classList.toggle(TC.Consts.classes.HIDDEN, e.target.value === '0');
            }));
            self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button[data-format]', function (e) {
                const format = e.target.dataset.format;
                if (format === TC.Consts.format.GPX) {
                    if (self.layer.features.some(function (feature) {
                        return TC.feature.Polygon && feature instanceof TC.feature.Polygon;
                    })) {
                        TC.confirm(self.getLocaleString('gpxNotCompatible.confirm'), function () {
                            endExport(format);
                        });
                    }
                    else {
                        endExport(format);
                    }
                }
                else {
                    endExport(format);
                }
            }));
        });

        return promise;
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.control.Measure.prototype.register.call(self, map).then(function () {
                const drawPointsId = self.getUID();
                const modifyId = self.getUID();

                Promise.all([self.layerPromise, self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    layer.title = self.getLocaleString('sketch');

                    self._modifyPromise = map.addControl('modify', {
                        id: modifyId,
                        div: self.div.querySelector('.' + self.CLASS + '-mod'),
                        layer: layer
                    });

                    self._modifyPromise.then(function (modify) {

                        self.modify = modify;
                        modify
                            .on(TC.Consts.event.FEATURESSELECT, function (e) {
                                if (self.resultsPanelChart && !e.features.some(function (feature) {
                                    return self.resultsPanelChart.currentFeature === feature;
                                })) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                const feature = e.features[e.features.length - 1];
                                if (feature) {
                                    self.showMeasures(self.getFeatureMeasureData(feature));
                                    const style = feature._originalStyle || feature.getStyle();
                                    switch (true) {
                                        case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                            self.displayMode(TC.Consts.geom.POLYGON);
                                            self.drawPolygons
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                            self.displayMode(TC.Consts.geom.POLYLINE);
                                            self.drawLines
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            const profile = getElevationProfileFromCache(feature);
                                            if (profile) {
                                                self.resultsPanelChart.setCurrentFeature(feature);
                                                self.renderElevationChart(profile.data);
                                            }
                                            break;
                                        case TC.feature.Point && feature instanceof TC.feature.Point:
                                            self.displayMode(TC.Consts.geom.POINT);
                                            self.drawPoints
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        default:
                                            break;
                                    }
                                    self.modify
                                        .setFontColorWatch(style.fontColor)
                                        .setFontSizeWatch(style.fontSize);
                                }
                            })
                            .on(TC.Consts.event.FEATURESUNSELECT, function (e) {
                                const features = self.modify.getSelectedFeatures();
                                if (!features.length) {
                                    self.resetDrawWatches();
                                }
                                self.resetElevationProfile();
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.close();
                                }
                            })
                            .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                                if (e.layer === self.layer) {
                                    removeElevationProfileFromCache(e.feature);
                                    const setMeasures = function (feature) {
                                        const measureData = self.getFeatureMeasureData(feature);
                                        self.showMeasures(measureData);
                                        self.setFeatureMeasureData(feature);
                                    };
                                    setMeasures(e.feature);

                                    // Si es un punto metemos la elevación en la geometría (porque la mostramos en las medidas)
                                    if (self.options.displayElevation && TC.feature.Point && e.feature instanceof TC.feature.Point) {
                                        self.elevation.setGeometry({
                                            features: [e.feature],
                                            crs: self.map.crs
                                        }).then(function (features) {
                                            setMeasures(features[0]);
                                        });
                                    }

                                    const popups = self.map.getControlsByClass('TC.control.Popup');
                                    popups.forEach(function (pu) {
                                        if (pu.isVisible() && pu.currentFeature === e.feature) {
                                            pu.hide();
                                        }
                                    });
                                }
                            });

                        map
                            .on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                                const control = e.control;
                                if (control === self.modify) {
                                    self.resetDrawWatches();
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.setCurrentFeature(null);
                                        self.resultsPanelChart.close();
                                    }
                                }
                                else if (control === self.drawLines) {
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.close();
                                    }
                                }
                            })
                            .on(TC.Consts.event.FEATURECLICK, function (e) {
                                const feature = e.feature;
                                // No queremos que se muestre el perfil de la feature ya dibujada si estamos dibujando o seleccionando otra
                                if (!(map.activeControl instanceof TC.control.Draw || map.activeControl instanceof TC.control.Modify)) {
                                    if (TC.feature.Polyline && feature instanceof TC.feature.Polyline && self.layer.features.indexOf(feature) >= 0) {
                                        if (self.elevationProfileActive) {
                                            if (self.resultsPanelChart) {
                                                self.resultsPanelChart.setCurrentFeature(feature);
                                            }
                                            map.getControlsByClass('TC.control.Popup').forEach(function (ctl) {
                                                if (ctl.currentFeature === feature) {
                                                    ctl.hide();
                                                }
                                            });
                                        }
                                        const profile = getElevationProfileFromCache(feature);
                                        if (self.resultsPanelChart && self.resultsPanelChart.isMinimized()) {
                                            self.resultsPanelChart.maximize();
                                        }
                                        if (profile) {
                                            self.renderElevationChart(profile.data);
                                        }
                                        else {
                                            self.displayElevationProfile(feature.geometry);
                                        }
                                    }
                                }
                            });
                    });

                    self._drawLinesPromise.then(function (drawLines) {
                        drawLines
                            .on(TC.Consts.event.DRAWSTART, function () {
                                //self.resetElevationProfile();
                                if (self.resultsPanelChart && self.resultsPanelChart.currentFeature) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                self.resetValues();
                            })
                            .on(TC.Consts.event.DRAWUNDO + ' ' + TC.Consts.event.DRAWREDO, function () {
                                const drawLines = this;
                                self.displayElevationProfile(drawLines.history.slice(0, drawLines.historyIndex));
                            })
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.currentFeature = e.feature;
                                }
                            })
                            .on(TC.Consts.event.POINT, function (e) {
                                const drawLines = this;
                                const coords = drawLines.history.slice(0, drawLines.historyIndex);
                                const lastCoord = coords[coords.length - 1];
                                if (lastCoord[0] !== e.point[0] || lastCoord[1] !== e.point[1]) {
                                    coords.push(e.point);
                                }
                                self.displayElevationProfile(coords);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._drawPolygonsPromise.then(function (drawPolygons) {
                        drawPolygons
                            .on(TC.Consts.event.DRAWSTART, function () {
                                self.resetValues();
                            })
                            //.on(TC.Consts.event.DRAWEND, function (e) {
                            //    if (self.options.displayElevation) {
                            //        self.elevation.setGeometry({
                            //            features: [e.feature],
                            //            crs: self.map.crs
                            //        });
                            //    }
                            //})
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._drawPointsPromise = map.addControl('draw', {
                        id: drawPointsId,
                        div: self.div.querySelector('.' + TC.control.Measure.prototype.CLASS + '-point'),
                        mode: TC.Consts.geom.POINT,
                        persistent: self.persistentDrawControls,
                        styleTools: true,
                        layer: self.layer
                    });

                    self._drawPointsPromise.then(function (drawPoints) {

                        drawPoints.containerControl = self;
                        self.drawControls.push(drawPoints);
                        self.drawPoints = drawPoints;

                        self.resetValues();

                        drawPoints
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                const updateChanges = function (feat) {
                                    self.showMeasures({ coords: feat.geometry, units: map.wrap.isGeo() ? 'degrees' : 'm' });
                                    self.setFeatureMeasureData(feat);
                                };
                                updateChanges(e.feature);
                                if (self.options.displayElevation) {
                                    self.elevation.setGeometry({
                                        features: [e.feature],
                                        crs: self.map.crs
                                    }).then(function (features) {
                                        updateChanges(features[0]);
                                    })
                                }
                            })
                            .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                // Alerta de condición de carrera si no ponemos un timeout:
                                // 1- Se llama a cancel de un control Draw.
                                // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                // 4- Se llama a cancel desde aquí.
                                // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                setTimeout(function () {
                                    self.cancel();
                                }, 100);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                        // Desactivamos el método exportState que ya se encarga el control padre de ello
                        drawPoints.exportsState = false;
                    });

                    self.setMode(self.options.mode);

                    map
                        .on(TC.Consts.event.FEATUREADD, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                self.setFeatureMeasureData(feature);
                                
                                self._modifyPromise.then(function (modify) {
                                    modify.displayLabelText(feature.getStyle().label);
                                });
                                self._clearBtn.disabled = false;
                                self._downloadBtn.disabled = false;
                            }
                        })
                        .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                if (self.layer.features.length === 0) {
                                    self._clearBtn.disabled = true;
                                    self._downloadBtn.disabled = true;
                                    self.resetValues();
                                    clearElevationProfileCache();
                                }
                                else if (feature) {
                                    removeElevationProfileFromCache(feature);
                                }
                            }
                        })
                        .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                            const control = e.control;
                            if (control.setCurrentFeature) {
                                control.setCurrentFeature(null);
                            }
                        });

                    resolve(self);
                });

            }).catch(function (error) {
                reject(error);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self._activeMode = self.div.querySelector('.tc-ctl-meas-pt');
        }
        if (self.modify) {
            self.modify.div.classList.remove(TC.Consts.classes.COLLAPSED);
        }
        return TC.control.Measure.prototype.displayMode.call(self, mode);
    };

    ctlProto.setMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self.drawPoints.activate();
        }
        return TC.control.Measure.prototype.setMode.call(self, mode);
    };

    ctlProto.setFeatureMeasureData = function (feature) {
        const self = this;
        const data = {};
        switch (true) {
            case TC.feature.Point && feature instanceof TC.feature.Point:
                const firstCoordText = self._1stCoordText.innerHTML;
                const secondCoordText = self._2ndCoordText.innerHTML;
                const elevationText = self._elevationText.innerHTML;
                if (self._1stCoordValue.textContent.trim().length > 0 && self._2ndCoordValue.textContent.trim().length > 0) {
                    data.CRS = self.map.crs;
                    data[firstCoordText.substr(0, firstCoordText.indexOf(':'))] = parseFloat(self._1stCoordValue.dataset.value);
                    data[secondCoordText.substr(0, secondCoordText.indexOf(':'))] = parseFloat(self._2ndCoordValue.dataset.value);
                    if (elevationText) {
                        data[self.getLocaleString('ele')] = parseFloat(self._elevationValue.dataset.value);
                    }
                    feature.setData(data);
                }
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                if (self._len.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('2dLength')] = self._len.innerHTML;
                    feature.setData(data);
                }
                break;
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                if (self._area.innerHTML.trim() !== self.NOMEASURE && self._peri.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('area')] = self._area.innerHTML;
                    data[self.getLocaleString('2dPerimeter')] = self._peri.innerHTML;
                    feature.setData(data);
                }
                break;
            default:
                break;
        }
        return self;
    };

    ctlProto.getFeatureMeasureData = function (feature) {
        const self = this;
        const result = {
            units: 'm'
        };
        const measureOptions = {};
        if (self.map.wrap.isGeo()) {
            measureOptions.crs = TC.Cfg.utmCrs;
        }
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                result.area = feature.getArea(measureOptions);
                result.perimeter = feature.getLength(measureOptions);
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                result.length = feature.getLength(measureOptions);
                const profile = getElevationProfileFromCache(feature);
                if (profile) {
                    self.renderElevationChart(profile.data);
                }
                else {
                    self.displayElevationProfile(feature.geometry);
                }
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
                result.coords = feature.geometry;
                break;
            default:
                break;
        }
        return result;
    };

    ctlProto.showMeasures = function (options) {
        const self = this;
        TC.control.Measure.prototype.showMeasures.call(self, options);
        options = options || {};
        var units = options.units;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.coords) {
            var precision;
            var coord1, coord2;
            if (options.units === 'm') {
                precision = TC.Consts.METER_PRECISION;
                coord1 = options.coords[0];
                coord2 = options.coords[1];
                self._1stCoordText.innerHTML = 'x: ';
                self._2ndCoordText.innerHTML = 'y: ';
            }
            else {
                precision = TC.Consts.DEGREE_PRECISION;
                coord1 = options.coords[1];
                coord2 = options.coords[0];
                self._1stCoordText.innerHTML = 'lat: ';
                self._2ndCoordText.innerHTML = 'lon: ';
            }
            const factor = Math.pow(10, precision);
            const round = function (val) {
                return Math.round(val * factor) / factor;
            }
            self._1stCoordValue.innerHTML = TC.Util.formatNumber(coord1.toFixed(precision), locale);
            self._1stCoordValue.dataset.value = round(coord1);
            self._2ndCoordValue.innerHTML = TC.Util.formatNumber(coord2.toFixed(precision), locale);
            self._2ndCoordValue.dataset.value = round(coord2);
            if (options.coords.length > 2) {
                const elevation = Math.round(options.coords[2]);
                self._elevationText.innerHTML = self.getLocaleString('ele').toLowerCase() + ': ';
                self._elevationValue.innerHTML = TC.Util.formatNumber(elevation.toFixed(TC.Consts.METER_PRECISION), locale) + ' m';
                self._elevationValue.dataset.value = elevation;
            }
            else {
                self._elevationText.innerHTML = '';
                self._elevationValue.innerHTML = '';
                self._elevationValue.dataset.value = '';
            }
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        TC.control.Measure.prototype.resetValues.call(self);

        if (self._1stCoordText) {
            self._1stCoordText.innerHTML = self.NOMEASURE;
            self._2ndCoordText.innerHTML = '';
            self._1stCoordValue.innerHTML = '';
            self._1stCoordValue.dataset.value = '';
            self._2ndCoordValue.innerHTML = '';
            self._2ndCoordValue.dataset.value = '';
            self._elevationText.innerHTML = '';
            self._elevationValue.innerHTML = '';
            self._elevationValue.dataset.value = '';
        }
        return self;
    };

    ctlProto.resetDrawWatches = function () {
        const self = this;
        self.drawControls.forEach(function (ctl) {
            ctl
                .setStrokeColorWatch()
                .setStrokeWidthWatch();
        });
    };

    ctlProto.clear = function () {
        const self = this;
        self.resetValues();
        self.layer.clearFeatures();
        if (self.modify.isActive) {
            self.modify.deactivate();
        }
        if (self.options.displayElevation) {
            self.resetElevationProfile();
            if (self.resultsPanelChart) {
                self.resultsPanelChart.close();
            }
        }
        self._clearBtn.disabled = true;
        self._downloadBtn.disabled = true;
        return self;
    };

    ctlProto.showSketchDownloadDialog = function (options) {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog');
        const hasPoints = self.layer.features.some(function (feature) {
            return (TC.feature.Point && feature instanceof TC.feature.Point) ||
                (TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint);
        });
        const hasLines = self.layer.features.some(function (feature) {
            return (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
                (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
        });
        const hasPolygons = self.layer.features.some(function (feature) {
            return (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
                (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);
        });

        if (self.options.displayElevation) {
            // Si no hay líneas o polígonos, no es necesario preguntar si queremos interpolar
            const ipDiv = dialog.querySelector('.' + self.CLASS + '-dialog-ip');
            ipDiv.classList.toggle(TC.Consts.classes.HIDDEN, !self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked || (!hasLines && !hasPolygons));
        }

        // Si no hay líneas o puntos, no es necesario mostrar el botón de GPX
        const gpxButton = dialog.querySelector('button[data-format=GPX]');
        gpxButton.classList.toggle(TC.Consts.classes.HIDDEN, !(hasLines || hasPoints));

        TC.Util.showModal(dialog, options);
        return self;
    };

    ctlProto.onStyleChange = function (e) {
        const self = this;
        var featureCtor;
        switch (e.target.mode) {
            case TC.Consts.geom.POLYGON:
                featureCtor = TC.feature.Polygon;
                break;
            case TC.Consts.geom.POLYLINE:
                featureCtor = TC.feature.Polyline;
                break;
            case TC.Consts.geom.POINT:
                featureCtor = TC.feature.Point;
                break;
            default:
                break;
        }
        if (featureCtor) {
            self.modify.getSelectedFeatures().forEach(function (feature) {
                if (feature instanceof featureCtor) {
                    const styleOptions = {};
                    styleOptions[e.property] = e.value;
                    //feature._originalStyle[e.property] = e.value;
                    feature.setStyle(styleOptions);
                    //clearTimeout(feature._selectionStyleTimeout);
                    //feature._selectionStyleTimeout = setTimeout(function () {
                    //    feature.setStyle(self.modify.styleFunction(feature));
                    //}, self.options.styleChangeDisplayTimeout || 1000);
                }
            });
        }
    }

    ctlProto.displayElevationProfile = function (coords) {
        const self = this;
        if (coords.length === 1) {
            // Espera una línea, metemos un segundo punto
            coords = coords.slice();
            coords.push(coords[0]);
        }
        const li = self.map.getLoadingIndicator();
        const waitId = li && li.addWait();
        self.elevation.getElevation({
            crs: self.map.crs,
            coordinates: coords
        }).then(
            function (elevCoords) {
                li && li.removeWait(waitId);
                var distance = 0.0;
                var maxElevation = Number.NEGATIVE_INFINITY;
                var minElevation = Number.POSITIVE_INFINITY;
                const profile = elevCoords
                    .map(function (point, idx, arr) {
                        const prev = idx === 0 ? point : arr[idx - 1];
                        const dx = point[0] - prev[0];
                        const dy = point[1] - prev[1];
                        distance += Math.sqrt(dx * dx + dy * dy);
                        var ele = point[2];
                        if (typeof ele === 'number') {
                            maxElevation = Math.max(ele, maxElevation);
                            minElevation = Math.min(ele, minElevation);
                        }
                        return [distance, ele];
                    });

                self.elevationProfileData = {
                    x: profile.map(function (elm) {
                        return elm[0];
                    }),
                    ele: profile.map(function (elm) {
                        return elm[1];
                    }),
                    coords: elevCoords
                };
                const elevationGainOptions = {
                    coords: elevCoords
                };
                if (typeof self.options.displayElevation === 'object') {
                    elevationGainOptions.hillDeltaThreshold = self.options.displayElevation.hillDeltaThreshold;
                }
                TC.Util.extend(self.elevationProfileData, TC.tool.Elevation.getElevationGain(elevationGainOptions));

                // Cacheamos el perfil
                const matchingFeature = self.layer.features
                    .filter(function (feat) {
                        return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
                    })
                    .filter(function (line) {
                        for (var i = 0, len = line.geometry.length; i < len; i++) {
                            const coord = coords[i];
                            const lineCoord = line.geometry[i];
                            if (!coord || coord[0] !== lineCoord[0] || coord[1] !== lineCoord[1]) {
                                return false;
                            }
                        }
                        return true;
                    })[0];
                if (matchingFeature) {
                    cacheElevationProfile(matchingFeature, self.elevationProfileData);
                }

                if (self.resultsPanelChart) {
                    self.renderElevationChart();
                }
                else {
                    self.createChartPanel().then(function (resultsPanelChart) {
                        self.resultsPanelChart.renderPromise().then(function () {
                            self.renderElevationChart();
                        });
                    });
                }
            },
            function (error) {
                self.resetElevationProfile();
                li && li.removeWait(waitId);
            });

    };

    ctlProto.createChartPanel = function () {
        const self = this;

        const resultsPanelOptions = {
            id: self.getUID(),
            content: "chart",
            titles: {
                main: self.getLocaleString("geo.trk.chart.chpe"),
                max: self.getLocaleString("geo.trk.chart.chpe")
            },
            chart: {
                ctx: self,
                onmouseout: ctlProto.removeElevationTooltip,
                tooltip: ctlProto.getElevationTooltip
            }
        };

        return new Promise(function (resolve, reject) {
            var addControlPromise;
            const addResultsPanelChart = function (controlContainer) {
                resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                addControlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
            };

            if (self.options.displayElevation.displayOn) {
                var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayElevation.displayOn[0].toUpperCase() + self.options.displayElevation.displayOn.substring(1))[0];
                if (!controlContainer) {
                    self.map.addControl(self.options.displayElevation.displayOn).then(addResultsPanelChart);
                } else {
                    addResultsPanelChart(controlContainer);
                }
            } else {
                resultsPanelOptions.div = document.createElement('div');
                self.map.div.appendChild(resultsPanelOptions.div);
                addControlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
            }

            addControlPromise.then(function (resultsPanelChart) {
                resultsPanelChart.caller = self;
                self.resultsPanelChart = resultsPanelChart;
                self._decorateChartPanel();
                resolve(resultsPanelChart);
            });
        });
    };

    ctlProto._decorateChartPanel = function () {
        const self = this;
        self.resultsPanelChart.setCurrentFeature = function (feature) {
            const that = this;
            if (that.currentFeature) {
                that.currentFeature.toggleSelectedStyle(false);
            }
            that.currentFeature = feature;
            if (feature) {
                feature.toggleSelectedStyle(true);
            }
        };
    };

    ctlProto.renderElevationChart = function (profileData) {
        const self = this;
        self.elevationProfileData = profileData || self.elevationProfileData;
        if (self.resultsPanelChart && self.elevationProfileActive) {
            self.resultsPanelChart.openChart(self.elevationProfileData);
            if (!self.resultsPanelChart.isMinimized()) {
                self.resultsPanelChart.show();
            }
        }
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.resultsPanelChart.wrap.showElevationMarker({
            data: d,
            layer: self.layer,
            coords: self.elevationProfileData.coords
        });

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.resultsPanelChart.wrap.hideElevationMarker();
    }

    ctlProto.activateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = true;
        self._elevProfileBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('deactivateElevationProfile'));
        var profileDrawn = false;
        if (self.drawLines.historyIndex > 1) {
            self.displayElevationProfile(self.drawLines.history.slice(0, self.drawLines.historyIndex));
            profileDrawn = true;
        }
        else {
            const features = self.modify.getActiveFeatures().filter(function (feat) {
                return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
            });
            if (features.length) {
                const feature = features[features.length - 1];
                self.displayElevationProfile(feature.geometry);
                profileDrawn = true;
            }
        }
        if (!profileDrawn) {
            self.resetElevationProfile();
        }
        if (self.resultsPanelChart) {
            self.resultsPanelChart.show();
        }
    };

    ctlProto.deactivateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = false;
        self._elevProfileBtn.classList.remove(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('activateElevationProfile'));
        self.resetElevationProfile();
        if (self.resultsPanelChart) {
            self.resultsPanelChart.close();
        }
    };

    ctlProto.resetElevationProfile = function () {
        const self = this;
        if (self.options.displayElevation && self.resultsPanelChart) {
            self.elevationProfileData = {
                x: [0],
                ele: [0],
                coords: [0, 0, 0],
                upHill: 0,
                downHill: 0
            };
            self.resultsPanelChart.openChart(self.elevationProfileData);
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

TC.Consts.editMode = {
    SELECT: 'select',
    ADDPOINT: 'addpoint',
    ADDLINE: 'addline',
    ADDPOLYGON: 'addpolygon'
};
TC.Consts.editStyles = {
    NEW: 'temporary',
    SELECTED: 'select',
    DEFAULT: 'default'
};

TC.Consts.event.POINT = 'point.tc';
TC.Consts.event.BEFOREFEATUREMODIFY = "beforefeaturemodify.tc";
TC.Consts.event.FEATUREMODIFY = "featuremodify.tc";
TC.Consts.event.FEATURESSELECT = "featureselect.tc";
TC.Consts.event.FEATURESUNSELECT = "featureunselect.tc";

(function () {
    var newFeatureIdNumber = 0;
    var getNewFeatureId = function () {
        return "NewFeature." + newFeatureIdNumber++;
    };

    var storeFeature = function (key, feature) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                var obj;
                var geometryType;
                switch (true) {
                    case feature instanceof TC.feature.Polygon:
                        geometryType = TC.Consts.geom.POLYGON;
                        break;
                    case feature instanceof TC.feature.Polyline:
                        geometryType = TC.Consts.geom.POLYLINE;
                        break;
                    case feature instanceof TC.feature.Point:
                        geometryType = TC.Consts.geom.POINT;
                        break;
                    case feature instanceof TC.feature.MultiPolygon:
                        geometryType = TC.Consts.geom.MULTIPOLYGON;
                        break;
                    case feature instanceof TC.feature.MultiPolyline:
                        geometryType = TC.Consts.geom.MULTIPOLYLINE;
                        break;
                }
                obj = {
                    id: feature.id || feature.provId,
                    attributes: feature.data,
                    type: geometryType,
                    geometry: feature.geometry,
                }
                localforage.setItem(key, obj)
                    .then(function () {
                        resolve({ feature: feature });
                    })
                    .catch(function (error) {
                        reject({ feature: feature, error: error });
                    });
            });
        });
    };

    var deleteFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.removeItem(key)
                    .then(function () {
                        resolve(key);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            });
        });
    };

    var readFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(key)
                    .then(function (value) {
                        resolve({
                            key: key,
                            feature: value
                        });
                    })
                    .catch(function (error) {
                        reject(error);
                    });
            });
        });
    };

    var getStoragePrefix = function (ctl, layerId) {
        return ctl.LOCAL_STORAGE_KEY_PREFIX + (layerId || ctl.layer.id);
    };

    var getAddedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_ADDED_KEY_PREFIX;
    };

    var getModifiedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_MODIFIED_KEY_PREFIX;
    };

    var getRemovedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_REMOVED_KEY_PREFIX;
    };

    var setFeatureSelectReadyState = function (ctl) {
        ctl._deleteBtn.disabled = true;
        ctl._joinBtn.disabled = true;
        ctl._splitBtn.disabled = true;
    }

    var complexGeometryFilter = function (elm) {
        var result = false;
        if ((TC.feature.MultiPolygon && elm instanceof TC.feature.MultiPolygon) ||
            (TC.feature.MultiPolyline && elm instanceof TC.feature.MultiPolyline)) {
            if (elm.geometry.length > 1) {
                result = true;
            }
        }
        return result;
    };

    var setFeatureSelectedState = function (ctl, features) {
        ctl._deleteBtn.disabled = features.length === 0;
        ctl._joinBtn.disabled = features.length < 2;
        ctl._splitBtn.disabled = features.filter(complexGeometryFilter).length === 0;
    }

    var setSaveButtonsState = function (ctl, disabled) {
        ctl._saveBtn.disabled = disabled;
        ctl._discardBtn.disabled = disabled;
        self.checkedOut = !disabled;
    };

    var setChangedState = function (ctl, isChanged) {
        if (typeof isChanged !== 'undefined') {
            setSaveButtonsState(ctl, !isChanged);
        }
        else {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                var storagePrefix = getStoragePrefix(ctl);
                localforage.keys().then(function (keys) {
                    if (keys) {
                        var disabled = true;
                        for (var i = 0, len = keys.length; i < len; i++) {
                            if (keys[i].indexOf(storagePrefix) === 0) {
                                disabled = false;
                                break;
                            }
                        }
                        setSaveButtonsState(ctl, disabled);
                    }
                });
            });
        }
    };

    var addChangesLayer = function (ctl, layer) {
        return new Promise(function (resolve, reject) {
            var changesLayer = ctl._changesLayers[layer.id];
            if (changesLayer) {
                resolve(changesLayer);
            }
            else {
                changesLayer = ctl._changesLayers[layer.id] = new TC.layer.Vector({
                    id: TC.getUID(),
                    title: layer.title + ' - cambios pendientes',
                    stealth: true,
                    styles: ctl.getChangesLayerStyle(layer)
                });
                var idx = ctl.map.layers.indexOf(layer);
                ctl.map.insertLayer(changesLayer, idx + 1, function () {
                    resolve(changesLayer);
                });
            }
        });
    };

    /* Creamos el constructor, llamando al constructor del padre */
    TC.control.Edit = function () {
        var self = this;

        TC.control.SWCacheClient.apply(this, arguments);

        self._classSelector = '.' + self.CLASS;

        self.wrap = new TC.wrap.control.Edit(self);
        self.layer = null;
        self.checkedOut = false;
        //self.feature = self.options.feature ? self.options.feature : null;
        self.callback = TC.Util.isFunction(arguments[2]) ? arguments[2] : (self.options.callback ? self.options.callback : null);
        self.multi = self.options.multi ? self.options.multi : false;
        self.eraseActionConfirmTxt = self.options.eraseText ? self.options.eraseText : "¿Está seguro de eliminar esta(s) geometría(s)?";
        self.cancelActionConfirmTxt = self.options.cancelText ? self.options.eraseText : "Si continua todos los cambios se perderán. ¿Desea continuar?";
        self.styles = self.options.styles;
        self.features = {};
        self.attributeEditor = null;
        self.pointDraw = null;
        self.lineDraw = null;
        self.polygonDraw = null;
        self.snapping = (typeof self.options.snapping === 'boolean') ? self.options.snapping : true;
        self._changesLayers = {};
        self._showsChanges = (typeof self.options.showChanges === 'boolean') ? self.options.showChanges : true;
        if (TC.Util.isFunction(self.options.getChangesLayerStyleFunction)) {
            self.getChangesLayerStyleFunction = self.getChangesLayerStyle;
        }

        self
            .on(TC.Consts.event.FEATUREADD, function (e) {
                var feat = e.feature;
                feat.provId = getNewFeatureId();
                var changesLayer = self._changesLayers[self.layer.id];
                self.features[self.layer.id].added.push(feat);
                changesLayer.addFeature(feat);
                storeFeature(getAddedStoragePrefix(self) + feat.provId, feat).then(function () {
                    setChangedState(self, true);
                    TC.toast("Adición guardada");
                }, function () {
                    TC.error("Fallo al guardar adición");
                });
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                var feat = e.feature;
                var fid = feat.provId || feat.id;
                var storeSuccess = function () {
                    setChangedState(self);
                    TC.toast("Eliminación guardada");
                };
                var storeFailure = function () {
                    TC.error("Fallo al guardar eliminación");
                };
                var changesLayer = self._changesLayers[self.layer.id];
                var features = self.features[self.layer.id];
                var idx = features.added.indexOf(feat);
                if (idx < 0) {
                    var removedStoragePrefix = getRemovedStoragePrefix(self);
                    idx = features.modified.indexOf(feat);
                    if (idx < 0) {
                        idx = features.removed.indexOf(feat);
                        if (idx < 0) {
                            features.removed.push(feat);
                            changesLayer.addFeature(feat);
                            storeFeature(removedStoragePrefix + feat.id, feat).then(storeSuccess, storeFailure);
                        }
                    }
                    else {
                        features.modified.splice(idx, 1);
                        features.removed.push(feat);
                        deleteFeature(getModifiedStoragePrefix(self) + feat.id).then(function () {
                            storeSuccess();
                            storeFeature(removedStoragePrefix + feat.id, feat).then(storeSuccess, storeFailure);
                        }, storeFailure);
                    }
                }
                else {
                    changesLayer.removeFeature(feat);
                    features.added.splice(idx, 1);
                    deleteFeature(getAddedStoragePrefix(self) + fid).then(storeSuccess, storeFailure);
                }
            })
            .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                var feat = e.feature;
                var fid = feat.provId || feat.id;
                var storeSuccess = function () {
                    setChangedState(self, true);
                    TC.toast("Modificación guardada");
                };
                var storeFailure = function () {
                    TC.error("Fallo al guardar modificación");
                };
                var changesLayer = self._changesLayers[self.layer.id];
                var features = self.features[self.layer.id];
                var idx = features.added.indexOf(feat);
                if (idx < 0) {
                    idx = features.modified.indexOf(feat);
                    if (idx < 0) {
                        changesLayer.addFeature(feat);
                        features.modified.push(feat);
                    }
                    storeFeature(getModifiedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                }
                else {
                    storeFeature(getAddedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                }
            })
            .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATUREMODIFY, function (e) {
                if (self.serviceWorkerEnabled && navigator.onLine) {
                    var gfUrl = self.layer.wrap.getGetFeatureUrl();
                    var dftUrl = self.layer.wrap.getDescribeFeatureTypeUrl();
                    if (gfUrl && dftUrl) {
                        self.createCache(self.LOCAL_STORAGE_KEY_PREFIX + self.layer.id, {
                            urlList: [gfUrl, dftUrl]
                        });
                    }
                }
            })
            //.on(TC.Consts.event.MEASURE + ' ' + TC.Consts.event.MEASUREPARTIAL, function (e) {
            //    var precision = e.units === 'm' ? 0 : 3;
            //    if (e.area) {
            //        self._$area.html(e.area.toFixed(precision).replace('.', ',') + ' ' + e.units + '&sup2;');
            //    }
            //    if (e.perimeter) {
            //        self._$peri.html(e.perimeter.toFixed(precision).replace('.', ',') + ' ' + e.units);
            //    }
            //    if (e.length) {
            //        self._$len.html(e.length.toFixed(precision).replace('.', ',') + ' ' + e.units);
            //    }
            //})
            //.on(TC.Consts.event.MEASURE, function (e) {
            //    self._pointHistoryIdx = 0;
            //    self.history.length = self._pointHistoryIdx;
            //    self._$undoBtn.prop('disabled', true);
            //    self._$redoBtn.prop('disabled', true);
            //})
            .on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                //self._$area.html('-');
                //self._$peri.html('-');
                //self._$len.html('-');
            })
            .on(TC.Consts.event.FEATURESSELECT, function (e) {
                
                var features = self.getSelectedFeatures();
                setFeatureSelectedState(self, features);
                if (features.length) {
                    features[0].showPopup(self.attributeEditor);
                }
            })
            .on(TC.Consts.event.FEATURESUNSELECT, function (e) {
                setFeatureSelectedState(self, self.getSelectedFeatures());
            });
            //.on(TC.Consts.event.EDITIONSAVE, function (e) {
            //    if (self.callback)
            //        self.callback(e.added, e.removed, e.modified);
            //});
    };

    TC.inherit(TC.control.Edit, TC.control.SWCacheClient);

    var ctlProto = TC.control.Edit.prototype;

    ctlProto.CLASS = 'tc-ctl-edit';
    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.edit.";
    ctlProto.LOCAL_STORAGE_ADDED_KEY_PREFIX = ".added.";
    ctlProto.LOCAL_STORAGE_MODIFIED_KEY_PREFIX = ".modified.";
    ctlProto.LOCAL_STORAGE_REMOVED_KEY_PREFIX = ".removed.";

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Edit.html";
        ctlProto.template[ctlProto.CLASS + '-attr'] = TC.apiLocation + "TC/templates/EditAttributes.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "featureEdit" }).w("</h2><div class=\"tc-ctl-edit-layer\"><select class=\"tc-combo tc-ctl-edit-layer-sel\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "selectLayerToEdit" }).w("</option>").s(ctx.get(["layers"], false), ctx, { "block": body_1 }, {}).w("</select><input type=\"checkbox\" id=\"tc-ctl-edit-view-changes-cb\"").x(ctx.get(["showChanges"], false), ctx, { "block": body_2 }, {}).w(" /><label class=\"tc-ctl-edit-view-changes\" for=\"tc-ctl-edit-view-changes-cb\">").h("i18n", ctx, {}, { "$key": "highlightUnsyncedChanges" }).w("</label></div><div class=\"tc-ctl-edit-mode\"><form><label class=\"tc-ctl-edit-btn-select\" title=\"").h("i18n", ctx, {}, { "$key": "select" }).w("\"><input type=\"radio\" name=\"mode\" value=\"select\" /><span>").h("i18n", ctx, {}, { "$key": "select" }).w("</span></label><label class=\"tc-ctl-edit-btn-point\" title=\"").h("i18n", ctx, {}, { "$key": "newPoint" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addpoint\" /><span>").h("i18n", ctx, {}, { "$key": "newPoint" }).w("</span></label><label class=\"tc-ctl-edit-btn-line\" title=\"").h("i18n", ctx, {}, { "$key": "newLine" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addline\" /><span>").h("i18n", ctx, {}, { "$key": "newLine" }).w("</span></label><label class=\"tc-ctl-edit-btn-polygon\" title=\"").h("i18n", ctx, {}, { "$key": "newPolygon" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addpolygon\" /><span>").h("i18n", ctx, {}, { "$key": "newPolygon" }).w("</span></label></form></div><div class=\"tc-ctl-edit-select tc-hidden\"><button class=\"tc-ctl-btn tc-ctl-edit-btn-delete\" disabled title=\"").h("i18n", ctx, {}, { "$key": "delete" }).w("\">").h("i18n", ctx, {}, { "$key": "delete" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-join\" disabled title=\"").h("i18n", ctx, {}, { "$key": "joinGeometries.tooltip" }).w("\">").h("i18n", ctx, {}, { "$key": "joinGeometries" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-split\" disabled title=\"").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("\">").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-cancel\" disabled title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div><div class=\"tc-ctl-edit-point tc-hidden\"></div><div class=\"tc-ctl-edit-line tc-hidden\"></div><div class=\"tc-ctl-edit-polygon tc-hidden\"></div><div class=\"tc-ctl-edit-save\"><button class=\"tc-button tc-icon-button tc-ctl-edit-btn-save\" disabled title=\"").h("i18n", ctx, {}, { "$key": "syncChanges" }).w("\">").h("i18n", ctx, {}, { "$key": "syncChanges" }).w("</button><button class=\"tc-button tc-icon-button tc-ctl-edit-btn-discard\" disabled title=\"").h("i18n", ctx, {}, { "$key": "discardChanges" }).w("\">").h("i18n", ctx, {}, { "$key": "discardChanges" }).w("</button></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["id"], false), ctx, "h").w("\">").f(ctx.get(["title"], false), ctx, "h").w("</option>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" checked"); } body_2.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-attr'] = function () {
            dust.register(ctlProto.CLASS + '-attr', body_0); var blocks = { "inputText": body_27, "inputNumber": body_28, "inputCheckbox": body_29, "inputDate": body_31, "inputTime": body_32, "inputDatetime": body_33 }; function body_0(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<div class=\"tc-ctl-edit-attr\"><h3>").h("i18n", ctx, {}, { "$key": "attributeEdit" }).w("</h3><div class=\"tc-ctl-edit-attr-body\"><table><tbody>").s(ctx.get(["data"], false), ctx, { "block": body_1 }, {}).w("</tbody></table></div><div class=\"tc-ctl-edit-attr-footer\"><button class=\"tc-button tc-ctl-edit-btn-attr-ok\">").h("i18n", ctx, {}, { "$key": "ok" }).w("</button><button class=\"tc-button tc-ctl-edit-btn-attr-cancel\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<tr><th>").f(ctx.get(["name"], false), ctx, "h").w("</th><td>").x(ctx.get(["readOnly"], false), ctx, { "else": body_2, "block": body_34 }, {}).w("</td></tr>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.x(ctx.get(["availableValues"], false), ctx, { "block": body_3 }, {}).h("select", ctx, { "block": body_5 }, { "key": ctx.get(["type"], false) }); } body_2.__dustBody = !0; function body_3(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<select class=\"tc-combo\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\"><option value=\"\"></option>").s(ctx.get(["availableValues"], false), ctx, { "block": body_4 }, {}).w("</select>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<option value=\"").f(ctx.getPath(true, []), ctx, "h").w("\">").f(ctx.getPath(true, []), ctx, "h").w("</option>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.h("none", ctx, { "block": body_6 }, {}).h("eq", ctx, { "block": body_7 }, { "value": "int" }).h("eq", ctx, { "block": body_8 }, { "value": "integer" }).h("eq", ctx, { "block": body_9 }, { "value": "double" }).h("eq", ctx, { "block": body_10 }, { "value": "boolean" }).h("eq", ctx, { "block": body_11 }, { "value": "date" }).h("eq", ctx, { "block": body_12 }, { "value": "time" }).h("eq", ctx, { "block": body_13 }, { "value": "dateTime" }).h("eq", ctx, { "block": body_14 }, { "value": "byte" }).h("eq", ctx, { "block": body_15 }, { "value": "long" }).h("eq", ctx, { "block": body_16 }, { "value": "negativeInteger" }).h("eq", ctx, { "block": body_17 }, { "value": "nonNegativeInteger" }).h("eq", ctx, { "block": body_18 }, { "value": "nonPositiveInteger" }).h("eq", ctx, { "block": body_19 }, { "value": "positiveInteger" }).h("eq", ctx, { "block": body_20 }, { "value": "short" }).h("eq", ctx, { "block": body_21 }, { "value": "unsignedLong" }).h("eq", ctx, { "block": body_22 }, { "value": "unsignedInt" }).h("eq", ctx, { "block": body_23 }, { "value": "unsignedShort" }).h("eq", ctx, { "block": body_24 }, { "value": "unsignedByte" }).h("eq", ctx, { "block": body_25 }, { "value": "float" }).h("eq", ctx, { "block": body_26 }, { "value": "decimal" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputText"), ctx, {}, {}); } body_6.__dustBody = !0; function body_7(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_8.__dustBody = !0; function body_9(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_9.__dustBody = !0; function body_10(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputCheckbox"), ctx, {}, {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputDate"), ctx, {}, {}); } body_11.__dustBody = !0; function body_12(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputTime"), ctx, {}, {}); } body_12.__dustBody = !0; function body_13(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputDatetime"), ctx, {}, {}); } body_13.__dustBody = !0; function body_14(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_14.__dustBody = !0; function body_15(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_15.__dustBody = !0; function body_16(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_16.__dustBody = !0; function body_17(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_17.__dustBody = !0; function body_18(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_18.__dustBody = !0; function body_19(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_19.__dustBody = !0; function body_20(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_20.__dustBody = !0; function body_21(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_21.__dustBody = !0; function body_22(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_22.__dustBody = !0; function body_23(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_23.__dustBody = !0; function body_24(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_24.__dustBody = !0; function body_25(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_25.__dustBody = !0; function body_26(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_26.__dustBody = !0; function body_27(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"text\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_27.__dustBody = !0; function body_28(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"number\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_28.__dustBody = !0; function body_29(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"checkbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["value"], false), ctx, { "block": body_30 }, {}).w("/>"); } body_29.__dustBody = !0; function body_30(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w(" checked"); } body_30.__dustBody = !0; function body_31(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"date\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_31.__dustBody = !0; function body_32(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"time\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_32.__dustBody = !0; function body_33(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"datetime\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_33.__dustBody = !0; function body_34(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.f(ctx.get(["value"], false), ctx, "h"); } body_34.__dustBody = !0; return body_0
        };
    }

    /* Extendemos el método register. 
       La lógica del control suele definirse aquí. */
    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.SWCacheClient.prototype.register.call(self, map);

        const drawPointsId = self.getUID();
        const drawLinesId = self.getUID();
        const drawPolygonsId = self.getUID();

        map.addControl('popup', { closeButton: true }).then(function (ctl) {
            self.attributeEditor = ctl;
        });

        map
            .on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    var features = self.features[layer.id] = self.features[layer.id] || {
                        added: [],
                        modified: [],
                        removed: []
                    };
                    addChangesLayer(self, layer).then(function (changesLayer) {
                        if (self.layer !== layer) {
                            changesLayer.setVisibility(false);
                        }
                        var storagePrefix = getStoragePrefix(self, layer.id);
                        var addedStoragePrefix = getAddedStoragePrefix(self, layer.id);
                        var modifiedStoragePrefix = getModifiedStoragePrefix(self, layer.id);
                        var removedStoragePrefix = getRemovedStoragePrefix(self, layer.id);
                        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                            //var li = map.getLoadingIndicator();
                            var uid = TC.getUID();
                            localforage.keys().then(function (keys) {
                                if (keys) {
                                    for (var i = 0, len = keys.length; i < len; i++) {
                                        var key = keys[i];
                                        if (key.indexOf(storagePrefix) === 0) {
                                            //li && li.addWait(uid);
                                            readFeature(key).then(function (obj) {
                                                var id;
                                                var k = obj.key;
                                                if (k.indexOf(removedStoragePrefix) === 0) {
                                                    id = k.substr(removedStoragePrefix.length);
                                                    var feature = layer.getFeatureById(id);
                                                    layer.removeFeature(feature);
                                                    changesLayer.addFeature(feature);
                                                    features.removed.push(feature);
                                                    //li && li.removeWait(uid);
                                                }
                                                else if (k.indexOf(modifiedStoragePrefix) === 0) {
                                                    id = k.substr(modifiedStoragePrefix.length);
                                                    var feature = layer.getFeatureById(id);
                                                    if (feature) {
                                                        changesLayer.addFeature(feature);
                                                        features.modified.push(feature);
                                                        feature.wrap.setGeometry(obj.feature.geometry);
                                                        feature.setData(obj.feature.attributes);
                                                        //li && li.removeWait(uid);
                                                    }
                                                }
                                                else if (k.indexOf(addedStoragePrefix) === 0) {
                                                    id = k.substr(addedStoragePrefix.length);
                                                    var idNumber = parseInt(id.substr(id.lastIndexOf('.') + 1));
                                                    newFeatureIdNumber = Math.max(newFeatureIdNumber, idNumber + 1);
                                                    var addPromise;
                                                    switch (obj.feature.type) {
                                                        case TC.Consts.geom.POINT:
                                                            addPromise = layer.addPoint(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.POLYLINE:
                                                            addPromise = layer.addPolyline(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.POLYGON:
                                                            addPromise = layer.addPolygon(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.MULTIPOLYLINE:
                                                            addPromise = layer.addMultiPolyline(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.MULTIPOLYGON:
                                                            addPromise = layer.addMultiPolygon(obj.feature.geometry);
                                                            break;
                                                        default:
                                                            break;
                                                    };
                                                    addPromise.then(function (feat) {
                                                        //feat.setStyle(TC.Util.extend({}, layer.styles.line, layer.styles.polygon));
                                                        changesLayer.addFeature(feat);
                                                        features.added.push(feat);
                                                        feat.provId = id;
                                                        feat.setData(obj.feature.attributes);
                                                        //li && li.removeWait(uid);
                                                    });
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        });
                    });
                    //map.off(TC.Consts.event.LAYERUPDATE, layerUpdateHandler);
                }
            })
            .on(TC.Consts.event.LAYERADD, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    self.features[layer.id] = self.features[layer.id] || {
                        added: [],
                        modified: [],
                        removed: []
                    };
                    const option = document.createElement('option');
                    option.setAttribute('value', layer.id);
                    option.innerHTML = layer.title || layer.id;
                    self._layerSelect.appendChild(option);
                }
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    var option = self._layerSelect.querySelector('option[value=' + layer.id + ']');
                    if (option.selected) {
                        self.setLayer(null);
                    }
                    option.parentElement.removeChild(option);
                }
            })
            .on(TC.Consts.event.POPUP, function (e) {
                if (e.control === self.attributeEditor) {
                    var feature = e.control.currentFeature;
                    var attributes = self.attributes.slice();
                    var attributeTypes = {};
                    var jfa = self._joinedFeatureAttributes || [];
                    for (var i = 0, ii = attributes.length; i < ii; i++) {
                        var attr
                        var data = feature.getData() || {};
                        var attributeObj = attributes[i];
                        attributeObj.value = data[attributeObj.name];
                        if (attributeObj.name === 'id') {
                            attributeObj.readOnly = true;
                        }
                        attributeObj.availableValues = [];
                        for (var j = 0, jj = jfa.length; j < jj; j++) {
                            var val = jfa[j][attributeObj.name];
                            if (val !== undefined && val !== '') {
                                attributeObj.availableValues[attributeObj.availableValues.length] = val;
                            }
                        }
                        attributeTypes[attributeObj.name] = attributeObj.type;
                    }
                    attributes.sort(function (a, b) {
                        if (a.readOnly ? !b.readOnly : b.readOnly) { //XOR
                            return !a.readOnly - !b.readOnly; // Primero readOnly
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        if (a.name < b.name) {
                            return -1;
                        }
                        return 0;
                    });
                    self.getRenderedHtml(self.CLASS + '-attr', { data: attributes }, function (html) {
                        const contentDiv = self.attributeEditor.contentDiv;
                        contentDiv.innerHTML = html;
                        const inputs = contentDiv.querySelectorAll('input');
                        const selects = contentDiv.querySelectorAll('select');
                        inputs.forEach(function (elm) {
                            elm.addEventListener('input', function (e) {
                                const input = e.target;
                                for (var i = 0, len = selects.length; i < len; i++) {
                                    const select = selects[i];
                                    if (select.matches('[name=' + e.target.getAttribute('name') + ']') && select.value !== input.value) {
                                        select.value = '';
                                        break;
                                    }
                                }
                            });
                        });
                        selects.forEach(function (elm) {
                            elm.addEventListener('change', function (e) {
                                const select = e.target;
                                for (var i = 0, len = inputs.length; i < len; i++) {
                                    const input = inputs[i];
                                    if (input.matches('[name=' + select.getAttribute('name') + ']')) {
                                        input.value = select.value;
                                        break;
                                    }
                                }
                            });
                        });
                        contentDiv.querySelector('.' + self.CLASS + '-btn-attr-ok').addEventListener('click', function () {
                            var data = {};
                            inputs.forEach(function (input) {
                                var name = input.getAttribute('name');
                                var value = input.value;
                                switch (attributeTypes[name]) {
                                    case 'int':
                                    case 'integer':
                                    case 'byte':
                                    case 'long':
                                    case 'negativeInteger':
                                    case 'nonNegativeInteger':
                                    case 'nonPositiveInteger':
                                    case 'positiveInteger':
                                    case 'short':
                                    case 'unsignedLong':
                                    case 'unsignedInt':
                                    case 'unsignedShort':
                                    case 'unsignedByte':
                                        value = parseInt(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'double':
                                    case 'float':
                                    case 'decimal':
                                        value = parseFloat(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'date':
                                    case 'time':
                                    case 'dateTime':
                                        data[name] = new Date(value);
                                        break;
                                    case 'boolean':
                                        data[name] = !!value;
                                        break;
                                    case undefined:
                                        break;
                                    default:
                                        data[name] = value;
                                        break;
                                }
                            });
                            feature.setData(data);
                            self.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature, layer: self.layer });
                            self.attributeEditor.hide();
                        });
                        contentDiv.querySelector('.' + self.CLASS + '-btn-attr-cancel').addEventListener('click', function () {
                            self.attributeEditor.hide();
                        });
                    });
                }
            });



        map.loaded(function () {
            if (self.options.layer) {
                self.setLayer(self.options.layer);
            }
            else {
                var wfsLayers = map.workLayers.filter(function (elm) {
                    return elm.type === TC.Consts.layerType.WFS && !elm.options.stealth;
                });
                if (wfsLayers.length === 1) {
                    self.setLayer(wfsLayers[0].id);
                }
                else {
                    self.setLayer(null);
                }
            }

            self.showChanges(self._showsChanges);

            self.renderPromise().then(function () {
                var DRAW = 'draw';
                Promise.all([
                    map.addControl(DRAW, {
                        id: drawPointsId,
                        div: self.div.querySelector('.' + self.CLASS + '-point'),
                        mode: TC.Consts.geom.POINT,
                        layer: false
                    }),
                    map.addControl(DRAW, {
                        id: drawLinesId,
                        div: self.div.querySelector('.' + self.CLASS + '-line'),
                        mode: TC.Consts.geom.POLYLINE,
                        layer: false
                    }),
                    map.addControl(DRAW, {
                        id: drawPolygonsId,
                        div: self.div.querySelector('.' + self.CLASS + '-polygon'),
                        mode: TC.Consts.geom.POLYGON,
                        layer: false
                    })
                ]).then (function (controls) {
                    self.pointDraw = controls[0];
                    self.lineDraw = controls[1];
                    self.polygonDraw = controls[2];

                    var drawendHandler = function (e) {
                        //var styleObj = {};
                        var feature = e.feature;
                        var featConstructor;
                        switch (self.geometryType) {
                            case TC.Consts.geom.POINT:
                                featConstructor = TC.feature.Point;
                                //TC.Util.extend(styleObj, self.layer.styles.point);
                                break;
                            case TC.Consts.geom.POLYLINE:
                                featConstructor = TC.feature.Polyline;
                                //TC.Util.extend(styleObj, self.layer.styles.line);
                                break;
                            case TC.Consts.geom.POLYGON:
                                featConstructor = TC.feature.Polygon;
                                //TC.Util.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                            case TC.Consts.geom.MULTIPOLYLINE:
                                featConstructor = TC.feature.MultiPolyline;
                                //TC.Util.extend(styleObj, self.layer.styles.line);
                                break;
                            case TC.Consts.geom.MULTIPOLYGON:
                                featConstructor = TC.feature.MultiPolygon;
                                //TC.Util.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                            default:
                                //TC.Util.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                        }
                        if (featConstructor) {
                            feature = new featConstructor(feature.geometry, { geometryName: self.layer.options.geometryName });
                        }
                        //feature.setStyle(styleObj);
                        self.layer.addFeature(feature);
                        self.trigger(TC.Consts.event.FEATUREADD, { feature: feature });
                    };
                    var drawcancelHandler = function () {
                        self.cancel();
                    };
                    self.pointDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.lineDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.polygonDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    if (self.options.modes && Array.isArray(self.options.modes) && self.options.modes.length == 1) {
                        self.setMode(self.options.modes[0], null);
                    }
                });
            });
        });
        //self.miEvent = map.on(TC.Consts.event.FEATURESADD + ".HasFeatures", function (e) {
        //    if (e.layer == self.layer) {
        //        self.miEvent = map.off(TC.Consts.event.FEATURESADD + ".HasFeatures");
        //    }
        //});

        //if (!self.layer || self.layer.features.length==0)
        //self._$resetBtn.prop('disabled', true);
        //self._deleteBtn.disabled = true;

        return result;
    };

    ctlProto.render = function (callback) {
        var self = this;
        var editLayers = [];
        if (self.map) {
            for (var i = 0, len = self.map.workLayers.length; i < len; i++) {
                var wl = self.map.workLayers[i];
                if (wl.type === TC.Consts.layerType.WFS && !wl.options.stealth) {
                    editLayers.push({
                        id: wl.id,
                        title: wl.title || wl.id
                    });
                }
            }
        }
        return self._set1stRenderPromise(TC.Control.prototype.renderData.call(self, { layers: editLayers, showChanges: self.showChanges }, function () {

            self._layerDiv = self.div.querySelector(self._classSelector + '-layer');
            self._layerSelect = self._layerDiv.querySelector(self._classSelector + '-layer-sel');
            self._layerSelect.addEventListener('change', function (e) {
                self.setLayer(self._layerSelect.value);
            });

            self._layerDiv.querySelector('#' + self.CLASS + '-view-changes-cb').addEventListener('change', function (e) {
                self.showChanges(e.target.checked);
            });

            //self._$len = self._$div.find(self._classSelector + '-val-len');
            //self._$area = self._$div.find(self._classSelector + '-val-area');
            //self._$peri = self._$div.find(self._classSelector + '-val-peri');

            self._cancelBtn = self.div.querySelector(self._classSelector + '-btn-cancel');
            self._cancelBtn.addEventListener('click', function () {
                self.cancel();
            });

            self._deleteBtn = self.div.querySelector(self._classSelector + '-btn-delete');
            self._deleteBtn.addEventListener('click', function () {
                TC.confirm(self.eraseActionConfirmTxt, function () {
                    self.deleteFeatures(self.getSelectedFeatures());
                });
            });
            self._joinBtn = self.div.querySelector(self._classSelector + '-btn-join');
            self._joinBtn.addEventListener('click', function () {
                self.joinFeatures(self.getSelectedFeatures());
            });
            self._splitBtn = self.div.querySelector(self._classSelector + '-btn-split');
            self._splitBtn.addEventListener('click', function () {
                self.splitFeatures(self.getSelectedFeatures());
            });
            self._saveBtn = self.div.querySelector(self._classSelector + '-btn-save');
            self._saveBtn.addEventListener('click', function () {
                self.applyEdits();
            });
            self._discardBtn = self.div.querySelector(self._classSelector + '-btn-discard');
            self._discardBtn.addEventListener('click', function () {
                self.discardEdits();
            });
            //control de renderizado enfunción del modo de edicion        
            if (self.options.modes && Array.isArray(self.options.modes) && self.options.modes.length > 0) {
                for (var m in TC.Consts.editMode)
                    if (typeof m === 'string' && self.options.modes.indexOf(TC.Consts.editMode[m]) < 0) {
                        const label = self.div.querySelector("label" + self._classSelector + "-btn-" + TC.Consts.editMode[m]);
                        label.parentElement.removeChild(label);
                        const div = self.div.querySelector("div" + self._classSelector + "-" + TC.Consts.editMode[m]);
                        div.parentElement.removeChild(div);
                    }
                if (self.options.modes.length === 1) {
                    var mode = self.options.modes[0];
                    self.div.querySelector("label" + self._classSelector + "-btn-" + mode).style.display = 'none';
                }


            }
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.addEventListener('change', function () {
                    var newMode = this.value;
                    var mode = self.mode === newMode ? undefined : newMode;
                    self.setMode(mode);
                });
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        self.layer = map.getLayer(layer);
        self.setMode(null);
        var rbSelector = 'input[type=radio][name=mode]';
        if (self.layer) {
            addChangesLayer(self, self.layer).then(function (changesLayer) {
                for (var key in self._changesLayers) {
                    var cl = self._changesLayers[key];
                    cl.setVisibility(self._showsChanges && cl === changesLayer);
                }
            });

            self.layer.describeFeatureType().then(function (attributes) {
                // recogemos los atributos no geométricos y definimos la geometría
                self.attributes = attributes.filter(function (elm) {
                    switch (elm.type) {
                        case 'gml:LinearRingPropertyType':
                        case 'gml:PolygonPropertyType':
                            self.geometryType = TC.Consts.geom.POLYGON;
                            return false;
                        case 'gml:MultiPolygonPropertyType':
                        case 'gml:MultiSurfacePropertyType':
                            self.geometryType = TC.Consts.geom.MULTIPOLYGON;
                            return false;
                        case 'gml:LineStringPropertyType':
                            self.geometryType = TC.Consts.geom.POLYLINE;
                            return false;
                        case 'gml:MultiLineStringPropertyType':
                            self.geometryType = TC.Consts.geom.MULTIPOLYLINE;
                            return false;
                        case 'gml:PointPropertyType':
                        case 'gml:MultiPointPropertyType':
                            self.geometryType = TC.Consts.geom.POINT;
                            return false;
                        case 'gml:BoxPropertyType':
                            self.geometryType = TC.Consts.geom.RECTANGLE;
                            return false;
                        case 'gml:GeometryCollectionPropertyType':
                        case 'gml:GeometryAssociationType':
                            return false;
                        default:
                            return true;
                    }
                });
                for (var i = 0, len = self.attributes.length; i < len; i++) {
                    var attr = self.attributes[i];
                    attr.type = attr.type.substr(attr.type.indexOf(':') + 1);
                }
                self.renderPromise().then(function () {
                    setChangedState(self);
                    self.div.querySelector(self._classSelector + '-layer-sel').value = self.layer.id;

                    const rbList = self.div.querySelectorAll(rbSelector);
                    var selector;
                    switch (self.geometryType) {
                        case TC.Consts.geom.POINT:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDPOINT + ']';
                            break;
                        case TC.Consts.geom.POLYLINE:
                        case TC.Consts.geom.MULTIPOLYLINE:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDLINE + ']';
                            break;
                        case TC.Consts.geom.POLYGON:
                        case TC.Consts.geom.MULTIPOLYGON:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDPOLYGON + ']';
                            break;
                        default:
                            selector = '[value]'
                            break;
                    }
                    rbList.forEach(function (rb) {
                        rb.disabled = !rb.matches(selector);
                    });
                });
            });
        }
        else {
            self.renderPromise().then(function () {
                setChangedState(self, false);
                const rbList = self.div.querySelectorAll(rbSelector);
                rbList.forEach(function (rb) {
                    rb.disabled = true;
                    rb.checked = false;
                });
            });
            self.layer = null;
        }
    };

    ctlProto.setMode = function (mode) {
        var self = this;
        self.mode = mode;
        setFeatureSelectReadyState(self);

        var activateDraw = function (draw) {
            if (draw) {
                if (self.snapping) {
                    draw.snapping = self.layer;
                }
                draw.activate();
            }
        };

        var active;
        var hiddenList;
        switch (mode) {
            case TC.Consts.editMode.SELECT:
                active = self.div.querySelector(self._classSelector + '-select');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                self.activate();
                break;
            case TC.Consts.editMode.ADDPOINT:
                active = self.div.querySelector(self._classSelector + '-point');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                activateDraw(self.pointDraw);
                break;
            case TC.Consts.editMode.ADDLINE:
                active = self.div.querySelector(self._classSelector + '-line');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-polygon');
                activateDraw(self.lineDraw);
                break;
            case TC.Consts.editMode.ADDPOLYGON:
                active = self.div.querySelector(self._classSelector + '-polygon');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-line');
                activateDraw(self.polygonDraw);
                break;
            default:
                active = null;
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                if (self.isActive) {
                    self.deactivate();
                }
                if (self.pointDraw && self.pointDraw.isActive) {
                    self.pointDraw.deactivate();
                }
                if (self.lineDraw && self.lineDraw.isActive) {
                    self.lineDraw.deactivate();
                }
                if (self.polygonDraw && self.polygonDraw.isActive) {
                    self.polygonDraw.deactivate();
                }
                break;
        }

        var radio;
        if (mode) {
            const radio = self.div.querySelector('input[type=radio][name=mode][value=' + mode + ']');
            radio.checked = true;
        }
        else {
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.checked = false;
            });
        }
        if (active) {
            active.classList.remove(TC.Consts.classes.HIDDEN);
        }
        hiddenList.forEach(function (hidden) {
            hidden.classList.add(TC.Consts.classes.HIDDEN);
        });
    };

    ctlProto.showChanges = function (show) {
        var self = this;
        self._showsChanges = show;
        for (var key in self._changesLayers) {
            var cl = self._changesLayers[key];
            cl.setVisibility(show && self.layer && key === self.layer.id);
        }
    };

    ctlProto.cancel = function () {
        var self = this;
        if (self.options.modes && Array.isArray(self.options.modes) && self.options.modes.length == 1) {
            self.setMode(self.options.modes[0], null);
        }
        else {
            self.setMode(null, false);
        }
        self.wrap.cancel(true, self.cancelActionConfirmTxt);
    };

    ctlProto.onFeatureClick = function (e) {
        if (!self.activeControl || !self.activeControl.isExclusive()) {
            e.feature.show();
        }
    };
    
    ctlProto.activate = function (options) {
        //window.meas.deactivate();
        var self = this;
        TC.Control.prototype.activate.call(self);
        var opts = options || {};
        self._cancelBtn.disabled = false;
        self.wrap.activate(opts.mode ? opts.mode : self.mode);
        TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;
        TC.Control.prototype.deactivate.call(self);
        //self.features = {
        //    added: []
        //    , removed: []
        //};
        self.wrap.cancel(true);
        self._cancelBtn.disabled = true;
        self.wrap.deactivate();
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.joinFeatures = function (features) {
        var self = this;
        if (self.geometryType === TC.Consts.geom.MULTIPOLYLINE ||
            self.geometryType === TC.Consts.geom.MULTIPOLYGON ||
            self.geometryType === TC.Consts.geom.MULTIPOINT) {
            self._joinedFeatureAttributes = [];
            if (features.length > 1) {
                var geometries = features.map(function (elm) {
                    self._joinedFeatureAttributes[self._joinedFeatureAttributes.length] = elm.getData();
                    return elm.geometry;
                });
                var newGeometry = geometries.reduce(function (a, b) {
                    return a.concat(b);
                });
                var newFeature = new features[0].constructor(newGeometry);
                for (var i = 0, len = features.length; i < len; i++) {
                    var feature = features[i];
                    self.layer.removeFeature(feature);
                    self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
                }
                self.layer.addFeature(newFeature).then(function (feat) {
                    self.setSelectedFeatures([newFeature]);
                    self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
                    feat.showPopup(self.attributeEditor);
                });
            }
            setFeatureSelectedState(self, [newFeature]);
        }
    };

    ctlProto.splitFeatures = function (features) {
        var self = this;
        var complexFeatures = features.filter(complexGeometryFilter);
        var geometries = complexFeatures.map(function (elm) {
            return elm.geometry;
        });
        var newFeatures = [];
        for (var i = 0, ii = complexFeatures.length; i < ii; i++) {
            var feature = complexFeatures[i];
            var data = feature.getData();
            var geometry = geometries[i];
            for (var j = 0, jj = geometry.length; j < jj; j++) {
                newFeatures[newFeatures.length] = new feature.constructor([geometry[j]], { data: data });
            }
        }
        for (var i = 0, len = complexFeatures.length; i < len; i++) {
            var feature = complexFeatures[i];
            self.layer.removeFeature(feature);
            self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
        }
        var newFeatPromises = new Array(newFeatures.length);
        for (var i = 0, len = newFeatures.length; i < len; i++) {
            const promise = newFeatPromises[i] = self.layer.addFeature(newFeatures[i]);
            promise.then(function (feat) {
                self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
            });
        }
        Promise.all(newFeatPromises).then(function() {
            self.setSelectedFeatures(newFeatures);
        });
        setFeatureSelectedState(self, newFeatures);
    };

    ctlProto.deleteFeatures = function (features) {
        var self = this;
        self.wrap.deleteFeatures(features);
        if (self.layer.features.length === 0) {
            self._deleteBtn.disabled = true;
        }
    };

    ctlProto.applyEdits = function () {
        var self = this;
        if (self.layer) {
            var features = self.features[self.layer.id];
            self.layer.applyEdits(features.added, features.modified, features.removed).then(function () {
                // Las acciones a realizar a partir de este punto son las mismas que al descartar una edición
                self.discardEdits();
                self.map.toast('Cambios sincronizados con éxito con el servidor');
            },
            function (obj) {
                TC.error("Error [" + obj.code + "] al guardar cambios: " + obj.reason);
            });
        }
    };

    ctlProto.discardEdits = function () {
        var self = this;
        self._joinedFeatureAttributes = [];
        var storagePrefix = getStoragePrefix(self);
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
            localforage.keys().then(function (keys) {
                if (keys) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var key = keys[i];
                        if (key.indexOf(storagePrefix) === 0) {
                            localforage.removeItem(key);
                        }
                    }
                    if (self.layer) {
                        var features = self.features[self.layer.id];
                        features.added.length = 0;
                        features.modified.length = 0;
                        features.removed.length = 0;
                        self.setSelectedFeatures([]);
                        self.attributeEditor.hide();
                        var changesLayer = self._changesLayers[self.layer.id];
                        changesLayer.clearFeatures();
                        self.deleteCache(storagePrefix).then(function () {
                            self.layer.refresh();
                        });
                    }
                    setChangedState(self, false);
                }
            });
        });
    };

    //ctlProto.setFeature = function (feature) {
    //    var self = this;
    //    self.feature = feature;
    //}

    ctlProto.getSelectedFeatures = function () {
        return this.wrap.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        return this.wrap.setSelectedFeatures(features);
    };

    ctlProto.getLayer = function () {
        var self = this;
        return self.layer;
    };

    ctlProto.getChangesLayerStyle = function (layer) {
        var getNegativeColor = function (color) {
            var str;
            var rgba = layer.wrap.getRGBA(color);
            for (var i = 0; i < 3; i++) {
                rgba[i] = 255 - rgba[i];
            }
            str = (rgba[0] * 65536 + rgba[1] * 256 + rgba[2]).toString(16);
            if (str.length === 4) {
                str = '00' + str;
            }
            else if (str.length === 5) {
                str = '0' + str;
            }
            return '#' + str;
        };

        var dash = [1, 3];
        var result = TC.Util.extend(true, {}, layer.options.styles);
        if (result.point) {
            result.point.strokeColor = getNegativeColor(result.point.strokeColor);
            result.point.lineDash = dash;
        }
        if (result.line) {
            result.line.strokeColor = getNegativeColor(result.line.strokeColor);
            result.line.lineDash = dash;
        }
        if (result.polygon) {
            result.polygon.strokeColor = getNegativeColor(result.polygon.strokeColor);
            result.polygon.lineDash = dash;
        }

        return result;
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ExternalWMS = function (options) {
    const self = this;
    self.count = 0;
    self._addedUrls = [];

    TC.Control.apply(self, arguments);

    self.allowReprojection = typeof self.options.allowReprojection === 'boolean' ? self.options.allowReprojection : true;
};

TC.inherit(TC.control.ExternalWMS, TC.Control);

(function () {
    var ctlProto = TC.control.ExternalWMS.prototype;

    ctlProto.CLASS = 'tc-ctl-xwms';

    /**
     * Marca como seleccionadas aquellas opciones del desplegable correspondientes a servicios WMS ya añadidos al TOC.
     */
    ctlProto.markServicesAsSelected = function (options) {
        if (options.length > 0) {
            const selectedOption = options[0];
            selectedOption.disabled = true;
            selectedOption.classList.add('tc-ctl-xwms-option-selected');
        }
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('select', function (evt) {
            if (evt.target.value !== '') {
                var url = evt.target.value;
                if (url.indexOf('//') === 0) {
                    url = location.protocol + url;
                }
                self.div.querySelector('input').value = url;
                evt.target.value = '';
            }
        }));

        /**
         * Borra parámetros no necesarios de la URL del servicio WMS.
         */
        var _removeParamsFromUrl = function (url, unwantedParams) {
            for (var i = 0; i < unwantedParams.length; i++) {
                url = TC.Util.removeURLParameter(url, unwantedParams[i]);
            }
            if (url.match(/\?$/)) {
                url = url.substr(0, url.length - 1);
            }
            return url;
        }

        const addWMS = function () {
            var url = self.div.querySelector('input').value.trim();

            if (!url) {
                TC.alert(self.getLocaleString('typeAnAddress'));
            }
            else if (!/^((https?|ftp):)?(\/\/)?(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(url)) {
                TC.alert(self.getLocaleString('typeAValidAddress'));
            }
            else {
                if (self._addedUrls.some(function (addedUrl) {
                    return addedUrl.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')
                })) {
                    TC.alert(self.getLocaleString('serviceAlreadyAdded'));
                }
                else {
                    var loadingCtrl = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];
                    loadingCtrl.show();
                    var params = TC.Util.getQueryStringParams(url);

                    if (!/https?:\/\/|\/\//i.test(url)) {
                        url = "//" + url;
                    }

                    //Extraemos sólo los parámetros adicionales
                    var unwantedParams = ["version", "service", "request"];
                    var urlWithoutParams = _removeParamsFromUrl(url, Object.keys(params));

                    for (var item in params) {
                        if (unwantedParams.indexOf(item.toLowerCase()) >= 0) {
                            delete params[item];
                        }
                    }

                    const addButton = self.div.querySelector('button');
                    addButton.disabled = true;

                    var obj = {
                        id: 'xwms' + (++self.count),
                        //"title": "Servicio externo",
                        type: 'WMS',
                        url: urlWithoutParams,
                        hideTree: false,
                        queryParams: params
                    };
                    //URI: recorremos las opciones buscando el servicio que se va a agregar a ver si tiene parametro layerNames
                    for (var i = 0; i < self.options.suggestions.length; i++) {
                        var _current = self.options.suggestions[i].items.filter(function (item, i) {
                            return item.url === url;
                        });
                        if (_current.length > 0 && _current[0].layerNames) {
                            obj["layerNames"] = _current[0].layerNames;
                            break;
                        }
                    }

                    var layer = new TC.layer.Raster(obj);
                    layer.getCapabilitiesPromise().then(function (cap) {
                        if (typeof (cap.Capability) === 'undefined') {
                            TC.alert(self.getLocaleString('noLayersFoundInService'));
                            loadingCtrl.hide();
                            addButton.disabled = false;
                            return;
                        } else {
                            var root = cap.Capability.Layer;
                            if (root.CRS && root.CRS.indexOf(self.map.crs) == -1 && !self.allowReprojection) {
                                //no soportado. avisar y fallar
                                TC.alert(self.getLocaleString('serviceSrsNotCompatible'));
                                loadingCtrl.hide();
                                addButton.disabled = false;
                                return;
                            }

                            self.map.trigger(TC.Consts.event.EXTERNALSERVICEADDED, { layer: layer });
                            self.div.querySelector('input').value = '';

                            const selectedOptions = [];
                            self.div.querySelectorAll('select option').forEach(function (option) {
                                if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                                    selectedOptions.push(option);
                                }
                            });
                            self.markServicesAsSelected(selectedOptions);
                            self._addedUrls.push(url);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        }
                    },
                        function (error) {
                            TC.alert(self.getLocaleString('serviceCouldNotBeLoaded') + ":\n" + error);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        });
                }
            }
        };

        self.renderPromise().then(() => {
            self.div.querySelector('input').addEventListener('keyup', (e) => {
                if (e.key && e.key.toLowerCase() === "enter" && self.div.querySelector('input').value.trim().length > 0) {
                    addWMS();
                }
            });
        });       

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('button[name="agregar"]', addWMS));

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (layer && !layer.isBase) {
                var url = layer.url;

                if (url) {
                    self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];
                    if (self.div.querySelectorAll('select option').length === 0 && url && self.pending_markServicesAsSelected.indexOf(url) === -1) {
                        self.pending_markServicesAsSelected.push(url);
                    }

                    const selectedOptions = [];
                    self.div.querySelectorAll('select option').forEach(function (option) {
                        if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                            selectedOptions.push(option);
                        }
                    });
                    self.markServicesAsSelected(selectedOptions);
                    self._addedUrls.push(url);
                }
            }
        });

        return result;
    };

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ExternalWMS.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["title"], false), ctx, { "block": body_1 }, {}).w("<div><div class=\"tc-group tc-ctl-xwms-cnt\"> <select id=\"add-wms-select\" class=\"tc-combo\" title=\"WMS (Web Map Service)\"><option value=\"\">WMS</option>").s(ctx.get(["suggestions"], false), ctx, { "block": body_2 }, {}).w("</select><input type=\"url\" class=\"tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "writeAddressOrSelect" }).w("\" /></div><div class=\"tc-group tc-group tc-ctl-xwms-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "addService.title" }).w("\" name=\"agregar\">").h("i18n", ctx, {}, { "$key": "addService" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "addMaps" }).w("</h2>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.x(ctx.get(["group"], false), ctx, { "block": body_3 }, {}).s(ctx.get(["items"], false), ctx, { "block": body_4 }, {}).x(ctx.get(["group"], false), ctx, { "block": body_5 }, {}); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<optgroup label=\"").f(ctx.get(["group"], false), ctx, "h").w("\">"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["url"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</option>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("\t</optgroup>"); } body_5.__dustBody = !0; return body_0
        };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(self.options, function () {
            self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];

            self.pending_markServicesAsSelected.forEach(function (elemUrl) {
                const selectedOptions = [];
                self.div.querySelectorAll('select option').forEach(function (option) {
                    if (TC.Util.addProtocol(option.value) === TC.Util.addProtocol(elemUrl)) {
                        selectedOptions.push(option);
                    }
                });

                self.markServicesAsSelected(selectedOptions);
                self._addedUrls.push(elemUrl);
            });

            self.pending_markServicesAsSelected = [];
        }));
    };


})();
TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}

(function () {
    TC.control.FeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.FeatureInfo(self);

        TC.Consts.classes.FROMLEFT = 'tc-fromleft';
        TC.Consts.classes.FROMRIGHT = 'tc-fromright';

        if (self.options.displayElevation) {
            TC.loadJS(
                !TC.tool || !TC.tool.Elevation,
                TC.apiLocation + 'TC/tool/Elevation',
                function () {
                    const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                    self.elevation = new TC.tool.Elevation(elevationOptions);
                }
            );
        }
    };

    TC.inherit(TC.control.FeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.FeatureInfo.prototype;

    var roundCoordinates = function roundCoordinates(obj, precision) {
        var result;
        var n = 20;
        if (Array.isArray(obj)) {
            result = obj.slice();
            for (var i = 0, len = result.length; i < len; i++) {
                result[i] = roundCoordinates(result[i]);
            }
        }
        else if (typeof obj === "number") {
            result = Math.round(obj.toFixed(precision));
        }
        else {
            result = obj;
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        // Le ponemos un padre al div. Evitamos con esto que se añada el div al mapa (no es necesario, ya que es un mero buffer)
        document.createElement('div').appendChild(self.div);

        return result;
    };

    ctlProto.callback = function (coords, xy) {
        var self = this;

        if (self.elevation) {
            self.querying = true;

            self.elevationRequest = self.elevation.getElevation({
                crs: self.map.crs,
                coordinates: coords
            });
        }

        if (self.map && self.filterLayer) {
            //aquí se pone el puntito temporal
            var title = self.getLocaleString('featureInfo');
            var markerOptions = TC.Util.extend({}, self.map.options.styles.marker, self.markerStyle, { title: title, set: title, showsPopup: false });
            self.filterLayer.clearFeatures();
            self.filterFeature = null;
            self.filterLayer.addMarker(coords, markerOptions).then(function (marker) {
                ////cuando se queda el puntito es porque esto sucede tras el cierre de la popup
                ////o sea
                ////lo normal es que primero se ejecute esto, y luego se procesen los eventos FEATUREINFO o NOFEATUREINFO
                ////pero en el caso raro (la primera vez), ocurre al revés. Entonces, ya se habrá establecido lastFeatureCount (no será null)
                //if (self.lastFeatureCount === null) {
                //    self.map.putLayerOnTop(self.filterLayer);
                //    self.filterFeature = marker;
                //}
                //else {
                //    self.filterLayer.clearFeatures();
                //}
                self.map.putLayerOnTop(self.filterLayer);
                self.querying = true;
                self.filterFeature = marker;

                var visibleLayers = false;
                for (var i = 0; i < self.map.workLayers.length; i++) {
                    var layer = self.map.workLayers[i];
                    if (layer.type === TC.Consts.layerType.WMS) {
                        if (layer.getVisibility() && layer.names.length > 0) {
                            visibleLayers = true;
                            break;
                        }
                    }
                }
                var resolution = self.map.getResolution();
                if (visibleLayers) {
                    self.wrap.getFeatureInfo(coords, resolution);
                }
                else {
                    self.querying = false;
                    // Metemos setTimeout para salirnos del hilo. Sin él se corre el riesgo de que se ejecute esto antes del evento BEFOREFEATUREINFO
                    setTimeout(function () {
                        self.responseCallback({ coords: coords });
                    });
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        const self = this;

        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);

        if (self.filterFeature) {
            var services = options.services;

            // Eliminamos capas sin resultados
            if (services) {
                for (var i = 0; i < services.length; i++) {
                    var service = services[i];
                    for (var j = 0; j < service.layers.length; j++) {
                        if (!service.layers[j].features.length) {
                            service.layers.splice(j, 1);
                            j = j - 1;
                        }
                    }
                    if (!service.layers.length) {
                        services.splice(i, 1);
                        i = i - 1;
                    }
                }
            }

            self.info.defaultFeature = options.defaultFeature;

            var locale = self.map.options.locale || TC.Cfg.locale;
            options.isGeo = self.map.wrap.isGeo();
            if (self.elevationRequest) {
                options.displayElevation = true;
            }
            if (options.coords) {
                options.crs = self.map.crs;
                options.coords = options.coords.map(function (value) {
                    return TC.Util.formatNumber(value.toFixed(options.isGeo ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION), locale);
                });
            }
            if ((services && services.length) || self.elevationRequest) {
                self.renderData(options, function () {
                    self.insertLinks();

                    if (self.sharedFeatureInfo) {
                        self.div.querySelectorAll('ul.' + self.CLASS + '-services li').forEach(function (li) {
                            li.classList.add(TC.Consts.classes.CHECKED);
                        })
                        var sharedFeature;
                        var featureObj = self.sharedFeatureInfo;
                        for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                            var service = self.info.services[i];
                            if (service.mapLayers.some(function (ml) { return ml.url === featureObj.s })) {
                                for (var j = 0, jj = service.layers.length; j < jj; j++) {
                                    var layer = service.layers[j];
                                    if (layer.name === featureObj.l) {
                                        for (var k = 0, kk = layer.features.length; k < kk; k++) {
                                            var feature = layer.features[k];
                                            if (feature.id === featureObj.f) {
                                                sharedFeature = feature;
                                                var hash = hex_md5(JSON.stringify({
                                                    data: feature.getData(),
                                                    geometry: roundCoordinates(feature.geometry, TC.Consts.DEGREE_PRECISION) // Redondeamos a la precisión más fina (grado)
                                                }));
                                                if (featureObj.h !== hash) {
                                                    TC.alert(self.getLocaleString('finfo.featureChanged.warning'));
                                                }
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                        if (sharedFeature) {
                            self.highlightedFeature = sharedFeature;
                            self.map.addLayer({
                                id: self.getUID(),
                                type: TC.Consts.layerType.VECTOR,
                                title: self.getLocaleString('foi'),
                                stealth: true
                            }).then(function (layer) {
                                self.sharedFeatureLayer = layer;
                                self.filterLayer.clearFeatures();
                                self.filterFeature = null;
                                layer.addFeature(sharedFeature);
                                self.map.zoomToFeatures([sharedFeature]);
                            });
                        }
                        delete self.sharedFeatureInfo;
                    }
                    else {
                        self.displayResults();
                    }
                });
            }
            else {
                self.resultsLayer.clearFeatures();
                self.filterLayer.clearFeatures();
                self.filterFeature = null;
            }
        }
    };

    ctlProto.displayResultsCallback = function () {
        const self = this;
        TC.control.FeatureInfoCommons.prototype.displayResultsCallback.call(self);

        if (self.elevationRequest) {
            const ctl = self.getDisplayControl();
            self.getDisplayTarget().querySelector(`.${self.CLASS}-elev`).classList.add(TC.Consts.classes.HIDDEN);
            self.elevationRequest.then(function (elevationCoords) {
                if (ctl.currentFeature) {
                    const currentCoords = ctl.currentFeature.geometry;
                    if (currentCoords[0] === elevationCoords[0][0] && currentCoords[1] === elevationCoords[0][1]) {
                        const elevationValue = elevationCoords.length ? elevationCoords[0][2] : null;
                        self.displayElevation(elevationValue);
                    }
                }
                self.elevationRequest = null;
            });
        }
    };

    ctlProto.displayElevation = function (value) {
        const self = this;
        const locale = self.map.options.locale || TC.Cfg.locale;
        const elevationString = value === null ? '-' : TC.Util.formatNumber(Math.round(value), locale) + ' m';
        const elevationDisplay = self.getDisplayTarget().querySelector(`.${self.CLASS}-elev`);
        elevationDisplay.classList.toggle(TC.Consts.classes.HIDDEN, value === null);
        elevationDisplay.querySelector(`.${self.CLASS}-coords-val`).innerHTML = elevationString;
    };

    ctlProto.loadSharedFeature = function (featureObj) {
        // Función para dar compatibilidad hacia atrás, ahora las features se comparten por URL
        const self = this;
        if (featureObj) {
            //buscamos si la feature compartida pertenece a alguna de las capas añadidas
            if (self.map.workLayers.filter(function (item, i) {
                return item.type === TC.Consts.layerType.WMS && item.url === featureObj.s && item.getDisgregatedLayerNames().indexOf(featureObj.l) >= 0
            }).length === 0) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
                return;
            }
            self.sharedFeatureInfo = featureObj;
            TC.loadJS(
                !window.hex_md5,
                [TC.apiLocation + TC.Consts.url.HASH],
                function () {
                    // Creamos una consulta getFeatureInfo ad-hoc, con la resolución a la que estaba la consulta original.
                    const coords = [-100, -100];
                    self.beforeRequest({ xy: coords }); // xy negativo para que no se vea el marcador, ya que no sabemos dónde ponerlo.
                    //aquí se pone el puntito temporal
                    self.filterLayer.clearFeatures();
                    self.filterFeature = null;
                    self.filterLayer.addMarker(coords).then(function (marker) {
                        self.filterFeature = marker;
                        self.wrap.getFeatureInfo(featureObj.xy, featureObj.r, {
                            serviceUrl: featureObj.s,
                            layerName: featureObj.l,
                            featureId: featureObj.f
                        });
                    });
                }
            );
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';

TC.control.FeatureTools = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self.layer = null;
    self.exportsState = true;

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]',
        INTERPOLATION_RADIO: 'input[type=radio][name=finfo-ip-coords]',
        INTERPOLATION_DISTANCE: cs + '-dialog-ip-m'
    };

    if (self.options.displayElevation) {
        TC.loadJS(
            !TC.tool || !TC.tool.Elevation,
            TC.apiLocation + 'TC/tool/Elevation',
            function () {
                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                self.elevation = new TC.tool.Elevation(elevationOptions);
            }
        );
    }

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
};

TC.inherit(TC.control.FeatureTools, TC.Control);

(function () {
    var ctlProto = TC.control.FeatureTools.prototype;

    ctlProto.CLASS = 'tc-ctl-ftools';

    ctlProto.TITLE_SEPARATOR = ' • ';
    ctlProto.FILE_TITLE_SEPARATOR = '__';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/FeatureTools.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/FeatureToolsDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools\"><button class=\"tc-ctl-ftools-dl-btn\" title=\"").h("i18n", ctx, {}, { "$key": "download" }).w("\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button><button class=\"tc-ctl-ftools-share-btn\" title=\"").h("i18n", ctx, {}, { "$key": "share" }).w("\">").h("i18n", ctx, {}, { "$key": "share" }).w("</button><button class=\"tc-ctl-ftools-zoom-btn\" title=\"").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("\">").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("</button><button class=\"tc-ctl-ftools-del-btn\" title=\"").h("i18n", ctx, {}, { "$key": "deleteFeature" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteFeature" }).w("</button></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog tc-ctl-ftools-dl-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "feature" }).w(" - ").h("i18n", ctx, {}, { "$key": "download" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").s(ctx.get(["elevation"], false), ctx, { "block": body_1 }, {}).w("<div class=\"tc-ctl-ftools-dialog-dl\"><div><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-kml\" data-format=\"KML\" title=\"KML\">KML</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-gml\" data-format=\"GML\" title=\"GML\">GML</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-geojson\" data-format=\"GeoJSON\" title=\"GeoJSON\">GeoJSON</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-wkt\" data-format=\"WKT\" title=\"WKT\">WKT</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-gpx\" data-format=\"GPX\" title=\"GPX\">GPX</button></div></div></div></div></div><div class=\"tc-ctl-ftools-dialog tc-ctl-ftools-share-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "feature" }).w(" - ").h("i18n", ctx, {}, { "$key": "share" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><div class=\"tc-ctl-ftools-share-dialog-ctl\"></div></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog-elev\"><input id=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" type=\"checkbox\"><label for=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" class=\"tc-ctl-ftools-dialog-elev-label\">").h("i18n", ctx, {}, { "$key": "includeElevations" }).w("</label></div>").x(ctx.get(["resolution"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog-ip tc-hidden\"><h4>").h("i18n", ctx, {}, { "$key": "interpolateCoordsFromElevProfile" }).w("</h4><label><input type=\"radio\" name=\"finfo-ip-coords\" value=\"0\" checked /><span>").h("i18n", ctx, {}, { "$key": "no" }).w("</span></label><label><input type=\"radio\" name=\"finfo-ip-coords\" value=\"1\"/><span>").h("i18n", ctx, {}, { "$key": "yes" }).w("</span></label><div class=\"tc-ctl-ftools-dialog-ip-m tc-hidden\">").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.1" }).w("<input type=\"number\" min=\"1\" step=\"1\" class=\"tc-textbox\" value=\"").f(ctx.get(["resolution"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.2" }).w("</div></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        map
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                self.currentDisplay = e.control;              // caso feature compartida
                if (self.currentDisplay.caller || (!self.currentDisplay.caller && self.currentDisplay.currentFeature)) {
                    self.highlightedFeature = !(!self.currentDisplay.caller && self.currentDisplay.currentFeature) ? self.currentDisplay.caller.highlightedFeature : self.currentDisplay.currentFeature;
                    if (self.highlightedFeature) {
                        self.highlightedFeature.showsPopup = true;
                    }

                    self.addUI(self.currentDisplay);
                }                
            })
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.currentDisplay = null;
            })
            .on(TC.Consts.event.FEATUREADD, function (e) {
                const feature = e.feature;
                if (self.currentDisplay && self.currentDisplay.caller && feature === self.currentDisplay.caller.highlightedFeature) {
                    self.highlightedFeature = feature;
                    self.highlightedFeature.showsPopup = true;
                }
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                const feature = e.feature;
                if (feature === self.highlightedFeature) {
                    const highlightedFeature = feature.clone();
                    highlightedFeature.showsPopup = true;
                    // Si la feature se eliminó por un cierre de popup provocado por la apertura de otro, 
                    // reasignamos la feature nueva al popup, ya que este está apuntando a una feature que ya no está en el mapa.
                    map.getControlsByClass('TC.control.Popup').concat(map.getControlsByClass('TC.control.ResultsPanel')).forEach(function (ctl) {
                        if (ctl.currentFeature === self.highlightedFeature) {
                            ctl.currentFeature = highlightedFeature;
                        }
                    });
                    self.getHighlightLayer().then(function (layer) {
                        layer.addFeature(highlightedFeature);
                    });
                }
            });

        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                self.map.addControl('share', {
                    id: self.getUID(),
                    div: self._dialogDiv.querySelector('.tc-modal-body .' + self.CLASS + '-share-dialog-ctl'),
                    includeControls: false // Establecemos el control para que no exporte estados de controles, así no se comparte la feature dos veces
                }).then(function (ctl) {
                    self._shareCtl = ctl;
                    resolve(self);
                }).catch(function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
            });
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        }, function (html) {
            self._dialogDiv.innerHTML = html;
            self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button[data-format]', function (e) {
                TC.Util.closeModal();
                const li = self.map.getLoadingIndicator();
                const waitId = li && li.addWait();

                const shareOptions = {};
                if (self.options.displayElevation && self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked) {
                    const interpolateCoords = self._dialogDiv.querySelector(self._selectors.INTERPOLATION_RADIO + ':checked').value === "1";
                    shareOptions.elevation = {
                        resolution: interpolateCoords ? parseFloat(self._dialogDiv.querySelector(self._selectors.INTERPOLATION_DISTANCE + ' input[type=number]').value) || self.options.displayElevation.resolution : 0
                    };
                }
                prepareFeatureToShare(self, shareOptions)
                    .then(
                    function (feature) {
                        self.map.exportFeatures([feature], {
                            fileName: self._getFeatureFilename(feature),
                            format: e.target.dataset.format
                        });
                    },
                    function (error) {
                        if (TC.tool.Elevation && error.message === TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED) {
                            TC.alert(self.getLocaleString('tooManyCoordinatesForElevation.warning'));
                            return;
                        }
                        TC.error(self.getLocaleString('elevation.error'));
                    }
                    )
                    .finally(function () {
                        li && li.removeWait(waitId);
                    });
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.ELEVATION_CHECKBOX, function (e) {
                self.showDownloadDialog(); // Recalculamos todo el aspecto del diálogo de descarga
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.INTERPOLATION_RADIO, function (e) {
                const idDiv = self._dialogDiv.querySelector(self._selectors.INTERPOLATION_DISTANCE);
                idDiv.classList.toggle(TC.Consts.classes.HIDDEN, e.target.value === '0');
            }));

            self.trigger(TC.Consts.event.CONTROLRENDER);
            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.addUI = function (ctl) {
        const self = this;
        const menuContainer = ctl.getMenuElement();
        // Nos aseguramos de que el se decora el control una sola vez
        const menuIsMissing = function () {
            return menuContainer && !menuContainer.querySelector('.' + self.CLASS);
        };
        if (menuIsMissing()) {
            // Añadimos los botones de herramientas
            self.getRenderedHtml(self.CLASS, null, function (html) {
                if (menuIsMissing()) {
                    const parser = new DOMParser();
                    const tools = parser.parseFromString(html, 'text/html').body.firstChild;
                    menuContainer.appendChild(tools);

                    self.updateUI(ctl);

                    if (!self.map.options.stateful) {
                        // Compartir no funciona sin estado
                        const shareBtn = tools.querySelector('.' + self.CLASS + '-share-btn');
                        shareBtn.parentElement.removeChild(shareBtn);
                    }
                    self._setToolButtonHandlers(tools);
                    self._decorateDisplay(ctl.getContainerElement());
                }
            });
        }
        else {
            self.updateUI(ctl);
        }
    };

    ctlProto._decorateDisplay = function (container) {
        const self = this;        

        if (self.highlightedFeature) {

            // Añadimos un zoom a la feature al pulsar en la tabla
            const attributeTable = container.querySelector('table.tc-attr');
            if (attributeTable) {
                attributeTable.addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.zoomToCurrentFeature();
                });

                attributeTable.querySelectorAll('a').forEach(function (a) {
                    a.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.stopPropagation(); // No queremos zoom si pulsamos en un enlace
                    });
                });

                attributeTable.classList.add(self.CLASS + '-zoom');
                attributeTable.setAttribute('title', self.getLocaleString('clickToCenter'));
            }                        

            // Añadimos botón de imprimir
            TC.loadJS(
                !TC.control.Print,
                [TC.apiLocation + 'TC/control/Print'],
                function () {
                    var printTitle = "";

                    if (self.highlightedFeature) {
                        printTitle = self.highlightedFeature.id;

                        if (self.highlightedFeature.showsPopup === true) {
                            new TC.control.Print({
                                target: container,
                                title: printTitle
                            });
                        }
                    }
                });
        }        
    };

    ctlProto.updateUI = function (ctl) {
        const self = this;
        const uiDiv = ctl.getMenuElement().querySelector('.' + self.CLASS);
        uiDiv.classList.remove(TC.Consts.classes.ACTIVE);
        clearTimeout(self._uiUpdateTimeout);
        self._uiUpdateTimeout = setTimeout(function () {
            const currentFeature = self.getCurrentFeature();
            uiDiv.classList.toggle(TC.Consts.classes.ACTIVE, !!(currentFeature && currentFeature.showsPopup));
        }, 100);
    };

    ctlProto._setToolButtonHandlers = function (container) {
        const self = this;

        // Evento para mostrar diálogo modal de descarga
        container.querySelector('.' + self.CLASS + '-dl-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.showDownloadDialog();
        });

        if (self.map.options.stateful) {
            // Evento para mostrar diálogo modal de compartir
            container.querySelector('.' + self.CLASS + '-share-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showShareDialog();
            });
        }

        // Evento para hacer zoom
        container.querySelector('.' + self.CLASS + '-zoom-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.zoomToCurrentFeature();
        });

        // Evento para borrar la feature
        container.querySelector('.' + self.CLASS + '-del-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.removeCurrentFeature();
        });
    };

    ctlProto.getHighlightLayer = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer) {
                resolve(self.layer);
            }
            else {
                self.map.addLayer({
                    id: self.getUID(),
                    title: self.CLASS + ': Highlighted features layer',
                    type: TC.Consts.layerType.VECTOR,
                    stealth: true
                }).then(function (layer) {
                    if (!self.layer) {
                        self.layer = layer;
                    }
                    resolve(self.layer);
                });
            }
        });
    };

    ctlProto.showDownloadDialog = function () {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog');
        const feature = self.getCurrentFeature();
        const isLine = (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
            (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
        const isPolygon = (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
            (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);

        if (self.options.displayElevation) {
            // Si no es una línea o polígono, no es necesario preguntar si queremos interpolar
            const ipDiv = dialog.querySelector('.' + self.CLASS + '-dialog-ip');
            ipDiv.classList.toggle(TC.Consts.classes.HIDDEN, !self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked || (!isLine && !isPolygon));
        }
        // Si es un polígono, no es necesario mostrar el botón de GPX
        const gpxBtn = dialog.querySelector('button[data-format=GPX]');
        gpxBtn.classList.toggle(TC.Consts.classes.HIDDEN, isPolygon);

        TC.Util.showModal(self._dialogDiv.querySelector('.' + self.CLASS + '-dl-dialog'));
    };

    ctlProto.showShareDialog = function () {
        const self = this;
        TC.Util.showModal(self._dialogDiv.querySelector('.' + self.CLASS + '-share-dialog'), {
            openCallback: function () {
                self.onShowShareDialog();
            },
            closeCallback: function () {
                self._shareCtl.featureToShare = null;
            }
        });
    };

    ctlProto.getCurrentFeature = function () {
        const self = this;
        return self.currentDisplay && ((self.currentDisplay.caller && self.currentDisplay.caller.highlightedFeature) ||
            self.currentDisplay.currentFeature);
    };

    ctlProto.zoomToCurrentFeature = function () {
        const self = this;
        if (self.map) {
            self.map.zoomToFeatures([self.getCurrentFeature()], { animate: true });
        }
    };

    ctlProto.removeCurrentFeature = function () {
        const self = this;
        const currentFeature = self.getCurrentFeature();
        const removeFeature = function () {
            self.highlightedFeature = null;
            if (currentFeature && currentFeature.layer) {
                currentFeature.layer.removeFeature(currentFeature);
            }
        };
        const closeDisplay = function () {
            if (self.currentDisplay) {
                self.currentDisplay.close ? self.currentDisplay.close() : self.currentDisplay.hide();
            }
        };
        // No pedimos confirmación para borrar si es un resalte de GFI o una de las features añadidas por FeatureTools.
        if ((self.currentDisplay && self.currentDisplay.caller && self.currentDisplay.caller.highlightedFeature === currentFeature) ||
            currentFeature.layer === self.layer) {
            removeFeature();
            closeDisplay();
        }
        else {
            TC.confirm(self.getLocaleString('deleteFeature.confirm'), function () {
                removeFeature();
                closeDisplay();
            });
        }
    };

    const prepareFeatureToShare = function (ctl, options) {
        options = options || {};
        return new Promise(function (resolve, reject) {
            const currentFeature = ctl.getCurrentFeature();
            if (currentFeature) {
                const feature = currentFeature.clone();
                feature.setId(currentFeature.id);
                feature.layer = currentFeature.layer;
                if (options.elevation) {
                    var mustGetElevations = true;
                    if (!options.elevation.resolution && feature.getGeometryStride() > 2) {
                        mustGetElevations = false;
                    }
                    if (mustGetElevations) {
                        const elevOptions = {
                            crs: ctl.map.crs,
                            features: [feature],
                            maxCoordQuantity: ctl.options.displayElevation && ctl.options.displayElevation.maxCoordQuantity,
                            resolution: options.elevation.resolution,
                            sampleNumber: 0 // No queremos determinar el número de muestras
                        };
                        ctl.elevation.setGeometry(elevOptions).then(
                            function (features) {
                                resolve(features[0]);
                            },
                            function (error) {
                                reject(error instanceof Error ? error : Error(error));
                            }
                        );
                    }
                    else {
                        resolve(feature);
                    }
                }
                else {
                    const coordsArray = feature.getCoordsArray();
                    const firstCoord = coordsArray[0];
                    if (firstCoord && firstCoord.length > 2) {
                        coordsArray.forEach(function (coord) {
                            coord.length = 2;
                        });
                        feature.setCoords(feature.geometry);
                    }
                    resolve(feature);
                }
            }
            else {
                resolve(null);
            }
        });
    };

    ctlProto.onShowShareDialog = function () {
        const self = this;
        const shareCtl = self._shareCtl;
        shareCtl.extraParams = null;
        prepareFeatureToShare(self).then(function (feature) {
            shareCtl.featureToShare = feature;
            const shareDiv = shareCtl.div;
            const link = shareCtl.generateLink();
            shareDiv.querySelector(".tc-url input[type=text]").value = link;
            shareDiv.querySelector(".tc-iframe input[type=text]").value = shareCtl.generateIframe(link);
        });
    };

    ctlProto.getFeatureTitle = function (feature) {
        const self = this;
        var result = "";
        if (feature) {
            result = feature.id;
        }
        return result;
    };

    ctlProto._getFeatureFilename = function (feature) {
        const self = this;
        const layerTitle = self.getFeatureTitle(feature).toString().replace(new RegExp(self.TITLE_SEPARATOR, 'g'), self.FILE_TITLE_SEPARATOR) || self.getLocaleString('feature');
        return layerTitle.toLowerCase().replace(/\s/gi, '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true);
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.layer) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (state.layer) {
            self.getHighlightLayer().then(function (layer) {
                layer.importState(state.layer);
            });
        }
    };
})();

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FileImport = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if (Array.isArray(self.options.formats)) {
        self.formats = self.options.formats;
    }
    else {
        self.formats = [
            TC.Consts.format.KML,
            TC.Consts.format.GML,
            TC.Consts.format.GML2,
            TC.Consts.format.GEOJSON,
            TC.Consts.format.WKT,
            TC.Consts.format.GPX
        ];
    }

    self.layers = [];

    self.apiAttribution = '';
    self.mainDataAttribution = '';
    self.dataAttributions = [];

    self.exportsState = true;
};

TC.inherit(TC.control.FileImport, TC.Control);

(function () {
    var ctlProto = TC.control.FileImport.prototype;

    ctlProto.CLASS = 'tc-ctl-file';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FileImport.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "openFile" }).w("</h2><div><p>").h("i18n", ctx, {}, { "$key": "fileImport.instructions" }).w("</p><div class=\"tc-ctl-file-open\"><label class=\"tc-button tc-ctl-file-open-label tc-icon-button\"><input type=\"file\" class=\"tc-ctl-file-open-ipt tc-button\" accept=\"").s(ctx.get(["formats"], false), ctx, { "block": body_1 }, {}).w("\" />").h("i18n", ctx, {}, { "$key": "openFile" }).w("</label></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(".").f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(","); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.Control.prototype.register.call(self, map);

        if (self.options.enableDragAndDrop) {
            map.wrap.enableDragAndDrop(self.options);
        }

        map
            .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                const fileName = e.fileName;
                const target = e.dropTarget;
                const features = e.features;
                // Ignoramos los GPX (se supone que los gestionará Geolocation)
                var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();
                if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length || target !== self.map.div && target !== self) {
                    return;
                }
                
                map.addLayer({
                    id: self.getUID(),
                    title: fileName,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layers.push(layer);
                    var geogCrs = 'EPSG:4326';
                    const flatten = function (prev, cur) {
                        return prev.concat(cur);
                    };
                    var projectGeom = function (feature) {
                        var geom = feature.geometry;
                        if (geom) {
                            var coordinates;
                            switch (true) {
                                case TC.feature.Point && feature instanceof TC.feature.Point:
                                    coordinates = [geom];
                                    break;
                                case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                                case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                    coordinates = geom;
                                    break;
                                case TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:
                                case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                    coordinates = geom.reduce(flatten);
                                    break;
                                case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                                    coordinates = geom.reduce(flatten).reduce(flatten);
                                    break;
                                default:
                                    break;
                            }
                            if (coordinates.every(function (coord) {
                                return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90; // Parecen geográficas
                            })) {
                                feature.setCoords(TC.Util.reproject(geom, geogCrs, self.map.crs));
                            }
                        }

                        return feature;
                    };

                    for (var i = 0, len = features.length; i < len; i++) {
                        var projectedFeature = projectGeom(features[i]);
                        layer.addFeature(projectedFeature);
                    }
                    setTimeout(function () {
                        map.zoomToFeatures(layer.features);
                    }, 100);
                });
            })
            .on(TC.Consts.event.FEATURESIMPORTERROR, function (e) {
                var dictKey;
                var fileName = e.file.name;
                if (fileName.toLowerCase().substr(fileName.length - 4) === '.kmz') {
                    dictKey = 'fileImport.error.reasonKmz';
                }
                else {
                    dictKey = 'fileImport.error.reasonUnknown';
                }

                TC.error(self.getLocaleString(dictKey, { fileName: fileName }), TC.Consts.msgErrorMode.TOAST);

                var reader = new FileReader();
                reader.onload = function (event) {
                    TC.error("Nombre del archivo: " + fileName + " \n Contenido del archivo: \n\n" + event.target.result, TC.Consts.msgErrorMode.EMAIL, "Error en la subida de un archivo");
                };
                reader.readAsText(e.file);
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                // Eliminamos la capa cuando ya no quedan features en ella
                const layer = e.layer;
                if (self.layers.indexOf(layer) >= 0) {
                    if (!layer.features.length) {
                        self.map.removeLayer(layer);
                    }
                }
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const idx = self.layers.indexOf(e.layer);
                if (idx >= 0) {
                    self.layers.splice(idx, 1);
                }
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ formats: self.formats }, function () {            
            const fileInput = self.div.querySelector('input[type=file]');
            // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
            fileInput.addEventListener(TC.Consts.event.CLICK, function (e) {
                const input = this;
                // Envolvemos el input en un form
                const form = document.createElement('form');
                const parent = input.parentElement;
                parent.insertBefore(form, input);
                form.appendChild(input);
                form.reset();
                // Desenvolvemos el input del form
                form.insertAdjacentElement('afterend', input);
                parent.removeChild(form);
            });
            fileInput.addEventListener('change', function (e) {
                if (self.map) {
                    console.log('salta el change');
                    self.map.wrap.loadFiles(e.target.files, { control: self });
                }
            });
        }));
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layers: self.layers.map(function (layer) {
                    return {
                        title: layer.title,
                        state: layer.exportState()
                    };
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            const layerPromises = [];
            state.layers.forEach(function (layerData) {
                layerPromises.push(self.map.addLayer({
                    id: self.getUID(),
                    title: layerData.title,
                    type: TC.Consts.layerType.VECTOR
                }));
            });

            Promise.all(layerPromises).then(function (layers) {
                for (var i = 0, len = layers.length; i < len; i++) {
                    const layer = layers[i];
                    layer.importState(state.layers[i].state);
                    self.layers.push(layer);
                }
            });
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FullScreen = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.FullScreen, TC.Control);

(function () {
    var ctlProto = TC.control.FullScreen.prototype;

    ctlProto.CLASS = 'tc-ctl-fscreen';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FullScreen.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-fscreen-btn\" title=\"").h("i18n", ctx, {}, { "$key": "fscreen.tip" }).w("\"></button>"); } body_0.__dustBody = !0; return body_0 };
    }

    const key = {
        fullscreenEnabled: 0,
        fullscreenElement: 1,
        requestFullscreen: 2,
        exitFullscreen: 3,
        fullscreenchange: 4,
        fullscreenerror: 5,
    };

    const webkit = [
        'webkitFullscreenEnabled',
        'webkitFullscreenElement',
        'webkitRequestFullscreen',
        'webkitExitFullscreen',
        'webkitfullscreenchange',
        'webkitfullscreenerror',
    ];

    const moz = [
        'mozFullScreenEnabled',
        'mozFullScreenElement',
        'mozRequestFullScreen',
        'mozCancelFullScreen',
        'mozfullscreenchange',
        'mozfullscreenerror',
    ];

    const ms = [
        'msFullscreenEnabled',
        'msFullscreenElement',
        'msRequestFullscreen',
        'msExitFullscreen',
        'MSFullscreenChange',
        'MSFullscreenError',
    ];

    const document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};

    const vendor = (
        ('fullscreenEnabled' in document && Object.keys(key)) ||
        (webkit[0] in document && webkit) ||
        (moz[0] in document && moz) ||
        (ms[0] in document && ms) ||
        []
    );

    ctlProto.fscreen = {
        inFullscreen: false,
        requestFullscreen: element => element[vendor[key.requestFullscreen]](),
        requestFullscreenFunction: element => element[vendor[key.requestFullscreen]],
        get exitFullscreen() { return document[vendor[key.exitFullscreen]].bind(document); },
        addEventListener: (type, handler, options) => document.addEventListener(vendor[key[type]], handler, options),
        removeEventListener: (type, handler, options) => document.removeEventListener(vendor[key[type]], handler, options),
        get fullscreenEnabled() { return Boolean(document[vendor[key.fullscreenEnabled]]); },
        set fullscreenEnabled(val) { },
        get fullscreenElement() { return document[vendor[key.fullscreenElement]]; },
        set fullscreenElement(val) { },
        get onfullscreenchange() { return document[("on" + vendor[key.fullscreenchange]).toLowerCase()]; },
        set onfullscreenchange(handler) { return document[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler; },
        get onfullscreenerror() { return document["on" + vendor[key.fullscreenerror].toLowerCase()]; },
        set onfullscreenerror(handler) { return document["on" + vendor[key.fullscreenerror].toLowerCase()] = handler; }
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        result.then(function () {
            const btn = self.div.querySelector('.' + self.CLASS + '-btn');
            
            if (self.fscreen.fullscreenEnabled) {                
                self.fscreen.addEventListener('fullscreenchange', function () {
                    self.fscreen.inFullscreen = self.fscreen.fullscreenElement !== null;
                    btn.classList.toggle(TC.Consts.classes.ACTIVE, self.fscreen.inFullscreen);
                    btn.setAttribute('title', self.fscreen.inFullscreen ? self.getLocaleString("fscreen.tip.return") : self.getLocaleString("fscreen.tip"));
                }, false);

                btn.addEventListener('click', function () {
                    if (!self.fscreen.inFullscreen) {
                        self.fscreen.requestFullscreen(self.map.div);
                    } else {
                        self.fscreen.exitFullscreen();
                    }
                }, false);

            } else {
                // GLS: 19/02/2019 en lugar de ocultar el botón, deshabilitamos el control para que no quede espacio de más entre los botones
                self.disable();
            }            
        });

        return result;
    };    

})();

(function () {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };
}());
(function () {
    var lastTime = 0,
        vendors = ['ms', 'moz', 'webkit', 'o'],
        // Feature check for performance (high-resolution timers)
        hasPerformance = !!(window.performance && window.performance.now);

    for (var x = 0, max = vendors.length; x < max && !window.requestAnimationFrame; x += 1) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }

    // Add new wrapper for browsers that don't have performance
    if (!hasPerformance) {
        // Store reference to existing rAF and initial startTime
        var rAF = window.requestAnimationFrame,
            startTime = +new Date;

        // Override window rAF to include wrapped callback
        window.requestAnimationFrame = function (callback, element) {
            // Wrap the given callback to pass in performance timestamp
            var wrapped = function (timestamp) {
                // Get performance-style timestamp
                var performanceTimestamp = (timestamp < 1e12) ? timestamp : timestamp - startTime;

                return callback(performanceTimestamp);
            };

            // Call original rAF with wrapped callback
            rAF(wrapped, element);
        }
    }
})();
(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Geolocation = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    self._layerPromises = {};

    self.Const = {
        Classes: {
            ACTIVE: 'tc-ctl-geolocation-active',
            CLOSED: 'closed',
            SELECTEDTRACK: 'selectedTrack',
            DRAWACTIVATED: 'draw-activated',
            SIMULATIONACTIVATED: 'simulation-activated'
        },
        Selector: {
            SIMULATE: '.tc-btn-simulate',
            DRAW: '.tc-draw',
            EDIT: '.tc-btn-edit',
            DELETE: '.tc-btn-delete',
            SAVE: '.tc-btn-save',
            CANCEL: '.tc-btn-cancel',
            EXPORT_GPX: '.tc-btn-export-gpx',
            EXPORT_KML: '.tc-btn-export-kml',
            STOP: '.tc-btn-stop',
            PAUSE: '.tc-btn-pause',
            BACKWARD: '.tc-btn-backward',
            FORWARD: '.tc-btn-forward',
            SPEED: '.tc-spn-speed'
        },
        LocalStorageKey: {
            TRACKING: 'trk',
            TRACKINGTEMP: 'trktemp',
            TRACKINGSHOWADVERTISEMENT: 'trkAdvertisement',
            GPSSHOWADVERTISEMENT: 'gpsAdvertisement',
            TEST: 'test'
        },
        Message: {
            VALIDATENAME: '',
        },
        Event: {
            POSITIONCHANGE: 'positionchange.tc.geolocation',
            GPSPOSITIONCHANGE: 'gpspositionchange.tc.geolocation',
            GPSPOSITIONERROR: 'positionerror.tc.geolocation',
            STATEUPDATED: 'stateupdated.tc.geolocation',
            GPSADD: 'gpsadd.tc.geolocation',
            TRACKSNAPPING: 'tracksnapping.tc.geolocation',
            DRAWTRACK: 'drawtrack.tc.geolocation',
            CLEARTRACK: 'cleartrack.tc.geolocation',
            IMPORTEDTRACK: 'importedtrack.tc.geolocation'
        },
        MimeMap: {
            KML: 'application/vnd.google-earth.kml+xml',
            GPX: 'application/gpx+xml'
        },
        SupportedFileExtensions: [
            '.kml',
            '.gpx'
        ],
        Tabs: {
            GPS: "gps"
        },
        Layers: {
            GPS: "gps",
            TRACK: "track",
            TRACKING: "tracking"
        }
    };

    TC.Control.apply(self, arguments);

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
    self.delta = 500;
    self.walkingSpeed = 5000;
    self.gapHill = self.options.gapHill || 20;

    self.snappingTolerance = self.options.snappingTolerance || 50;

    self.exportsState = true;

    self.storageCRS = 'EPSG:4326';
};

TC.inherit(TC.control.Geolocation, TC.Control);

(function () {
    var ctlProto = TC.control.Geolocation.prototype;

    ctlProto.CLASS = 'tc-ctl-geolocation';

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 300,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    ctlProto.featuresToShare = [];

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';
    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Geolocation.html";
        ctlProto.template[ctlProto.CLASS + '-track-node'] = TC.apiLocation + "TC/templates/GeolocationTrackNode.html";
        ctlProto.template[ctlProto.CLASS + '-track-snapping-node'] = TC.apiLocation + "TC/templates/GeolocationTrackSnappingNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/GeolocationDialog.html";
        ctlProto.template[ctlProto.CLASS + '-tracking-toast'] = TC.apiLocation + "TC/templates/GeolocationTrackingToast.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "geo" }).w("</h2><div class=\"tc-ctl-geolocation-content\"> <div class=\"tc-ctl-geolocation-track\"><div class=\"tc-ctl-geolocation-track-snap-info\"></div> <!-- img se insertan en el div del mapa--> <div id=\"tc-ctl-geolocation-track-elevation-marker\" class=\"tc-ctl-geolocation-trackMarker elevation\" style=\"display: none;\"></div> <div class=\"tc-ctl-geolocation-track-panel-block\" ><input id=\"tc-ctl-geolocation-track-panel-opened\" type=\"checkbox\" checked/><label for=\"tc-ctl-geolocation-track-panel-opened\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.1" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.2" }).w("</label><i class=\"tc-ctl-geolocation-track-panel-help icon-question-sign\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.3" }).w("\"></i></div><div class=\"tc-ctl-geolocation-track-mng\"><div class=\"tc-ctl-geolocation-select\"><form> <label class=\"tc-ctl-geolocation-btn-track\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.title" }).w("\"><input type=\"radio\" name=\"mode\" checked value=\"tracks\" /><span>").h("i18n", ctx, {}, { "$key": "geo.gps" }).w("</span></label><label class=\"tc-ctl-geolocation-btn-tracks\" title=\"").h("i18n", ctx, {}, { "$key": "geo.tracks.title" }).w("\"><input type=\"radio\" name=\"mode\" value=\"track-available\" /><span>").h("i18n", ctx, {}, { "$key": "geo.tracks" }).w("</span></label> </form></div> <div class=\"tc-ctl-geolocation-track-available tc-ctl-geolocation-track-cnt tc-ctl-geolocation-panel tc-hidden\"><i class=\"tc-ctl-geolocation-track-search-icon\"></i><input id=\"tc-ctl-geolocation-track-available-srch\" type=\"search\" list=\"tc-ctl-geolocation-track-available-lst\" class=\"tc-ctl-geolocation-track-available-srch tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.filter.plhr" }).w("\" maxlength=\"200\" /> <ol id=\"tc-ctl-geolocation-track-available-lst\" class=\"tc-ctl-geolocation-track-available-lst\"><li class=\"tc-ctl-geolocation-track-available-empty\"><span>").h("i18n", ctx, {}, { "$key": "geo.noTracks" }).w("</span></li><li class=\"tc-ctl-geolocation-track-not\" hidden><span>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</span></li></ol><div class=\"tc-ctl-geolocation-track-cnt\"><input name=\"uploaded-file\" id=\"uploaded-file\" type=\"file\" class=\"tc-ctl-geolocation-track-import tc-button\" accept=\".gpx,.kml\" disabled /><label class=\"tc-button tc-icon-button\" for=\"uploaded-file\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.import.upload" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.import.lbl" }).w("</label></div></div><div class=\"tc-ctl-geolocation-tracks tc-ctl-geolocation-panel\"> <div class=\"tc-alert alert-warning tc-hidden\" ><p id=\"panel-msg\">").h("i18n", ctx, {}, { "$key": "geo.trk.panel.1" }).w(" <ul><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.2" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.3" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.4" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.5" }).w("</li></ul></p></div> <div class=\"tc-ctl-geolocation-track-ui\"> <div class=\"tc-ctl-geolocation-track-render\"><input id=\"tc-ctl-geolocation-track-render\" type=\"checkbox\" hidden checked /><label for=\"tc-ctl-geolocation-track-render\" class=\"tc-ctl-geolocation-track-render\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.render" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.render" }).w("</label></div><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-ui-activate\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.activate.title" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.track.activate" }).w("</button><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-ui-deactivate tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.deactivate.title" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.track.deactivate" }).w("</button></div><div class=\"tc-ctl-geolocation-track-current tc-ctl-geolocation-track-cnt\"><input type=\"text\" class=\"tc-ctl-geolocation-track-title tc-textbox\" disabled placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.trk.name.plhr" }).w("\" maxlength=\"200\" /><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-save\" disabled title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.name.save" }).w("\"></button><input type=\"text\" class=\"tc-ctl-geolocation-track-waypoint tc-textbox\" disabled placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.trk.wyp.plhr" }).w("\" maxlength=\"200\" /><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-add-wpt\" disabled title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.wyp.save" }).w("\"></button></div></div></div></div></div><div class=\"tc-ctl-geolocation-track-center tc-hidden\"><button title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.center" }).w("\"></button></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-track-node'] = function () { dust.register(ctlProto.CLASS + '-track-node', body_0); function body_0(chk, ctx) { return chk.w("<li data-id=\"").f(ctx.get(["id"], false), ctx, "h").w("\" data-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><span class=\"tc-draw tc-selectable\" title=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</span><input class=\"tc-textbox tc-hidden\" type=\"text\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\" /> <button class=\"tc-btn-simulate\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.simulate" }).w("\"></button><button hidden class=\"tc-btn-stop\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.stop" }).w("\"></button><button class=\"tc-btn-edit\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.edit" }).w("\"></button><button hidden class=\"tc-btn-pause\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.pause" }).w("\"></button> <button hidden class=\"tc-btn-backward\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.backward" }).w("\"></button><label hidden class=\"tc-spn-speed\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.velocity" }).w("\"></label><button hidden class=\"tc-btn-forward\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.forward" }).w("\"></button> <button class=\"tc-btn-save tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "save" }).w("\"></button><button class=\"tc-btn-cancel tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.cancel" }).w("\"></button><button class=\"tc-btn-delete\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.delete" }).w("\"></button><button class=\"tc-btn-export-gpx\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.exportGPX" }).w("\"></button><button class=\"tc-btn-export-kml\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.exportKML" }).w("\"></button> </li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-track-snapping-node'] = function () { dust.register(ctlProto.CLASS + '-track-snapping-node', body_0); function body_0(chk, ctx) { return chk.w("<ul>").x(ctx.get(["n"], false), ctx, { "block": body_1 }, {}).w("<li> <span>").x(ctx.get(["isGeo"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(":</span> ").f(ctx.get(["x"], false), ctx, "h").w("</li><li> <span>").x(ctx.get(["isGeo"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(":</span> ").f(ctx.get(["y"], false), ctx, "h").w(" </li>").x(ctx.get(["z"], false), ctx, { "block": body_6 }, {}).x(ctx.get(["m"], false), ctx, { "block": body_8 }, {}).w("</ul>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li><span>").h("i18n", ctx, {}, { "$key": "geo.trk.snapping.name" }).w(":</span> ").f(ctx.get(["n"], false), ctx, "h").w("</li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("X"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lon" }); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("Y"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.h("ne", ctx, { "block": body_7 }, { "key": ctx.get(["z"], false), "value": 0 }); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w("<li> <span>Z:</span> ").f(ctx.get(["z"], false), ctx, "h").w(" </li>"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<li> ").f(ctx.get(["m"], false), ctx, "h").w(" </li>"); } body_8.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-geolocation-continue-track-dialog tc-modal\" ><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "geo.gps" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><button class=\"tc-button tc-ctl-geolocation-track-continue\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.cnt" }).w(" </button><button class=\"tc-button tc-ctl-geolocation-track-new\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.new" }).w(" </button> <button class=\"tc-button tc-modal-close\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.cancel" }).w(" </button></div></div></div><div class=\"tc-ctl-geolocation-track-advert-dialog tc-modal\" ><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "geo.track.activate.title" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p id=\"pageBlurMsg\">").h("i18n", ctx, {}, { "$key": "geo.trk.page.blur" }).w("</p><p class=\"tc-ctl-geolocation-track-advertisement p\"> <label> <input type=\"checkbox\" name=\"checkbox\" id=\"advertisement\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.advertisement" }).w(" </label> </p></div><div class=\"tc-modal-footer\"><button class=\"tc-button tc-ctl-geolocation-track-advert-ok\"> ").h("i18n", ctx, {}, { "$key": "ok" }).w(" </button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-tracking-toast'] = function () { dust.register(ctlProto.CLASS + '-tracking-toast', body_0); function body_0(chk, ctx) { return chk.w("<table class=\"tc-ctl-geolocation-info-tracking\"><tr><th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(":</th><td> ").f(ctx.get(["x"], false), ctx, "h").w(" </td>").x(ctx.get(["accuracy"], false), ctx, { "block": body_3 }, {}).w("</tr><tr><th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(":</th><td> ").f(ctx.get(["y"], false), ctx, "h").w(" </td>").x(ctx.get(["speed"], false), ctx, { "block": body_6 }, {}).w("</tr><tr>").x(ctx.get(["z"], false), ctx, { "block": body_7 }, {}).x(ctx.get(["mdt"], false), ctx, { "block": body_10 }, {}).w("</tr> </table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("X"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lon" }); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<th>").h("i18n", ctx, {}, { "$key": "geo.trk.accuracy" }).w(":</th><td> ").f(ctx.get(["accuracy"], false), ctx, "h").w(" m </td>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("Y"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<th>").h("i18n", ctx, {}, { "$key": "geo.trk.speed" }).w(":</th><td>").f(ctx.get(["speed"], false), ctx, "h").w(" km/h</td>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w("<th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_8, "block": body_9 }, {}).w(":</th><td> ").f(ctx.get(["z"], false), ctx, "h").w(" m </td>"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("Z"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.w("<th title=\"").h("i18n", ctx, {}, { "$key": " mdt.title" }).w("\">").h("i18n", ctx, {}, { "$key": "ele" }).w(" (").h("i18n", ctx, {}, { "$key": "mdt" }).w("):</th><td>").f(ctx.get(["mdt"], false), ctx, "h").w(" m </td>"); } body_10.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.wrap = new TC.wrap.control.Geolocation(self);
        self.wrap.register(map);

        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.GPS',
        }).then(function (layer) {
            self.layerGPS = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.Tracking',
            styles: {
                point: {
                    radius: 3,
                    fillColor: "#00ced1",
                    fillOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeColor: "#ffffff",
                    fontColor: "#00ced1",
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 1,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                },
                line: {
                    strokeOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeWidth: 2,
                    strokeColor: "#00ced1",
                    lineDash: [.1, 6]
                }
            }
        }).then(function (layer) {
            self.layerTracking = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.Track',
            styles: {
                line: {
                    strokeWidth: 2,
                    strokeColor: "#C52737"
                },
                point: {
                    radius: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            return 3;
                        } else {
                            return 6;
                        }

                        return 3;
                    },
                    fillColor: "#C52737",
                    strokeColor: "#ffffff",
                    fontColor: "#C52737",
                    fontSize: 10,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                }
            }
        }).then(function (layer) {
            self.layerTrack = layer;
        });

        map.on(TC.Consts.event.FEATURESIMPORT, function (e) {
            const self = this;
            const fileName = e.fileName;
            const target = e.dropTarget;
            var kmlPattern = '.' + TC.Consts.format.KML.toLowerCase();
            var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();

            // GLS: ¿es un GPX?
            if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length ||
                // GLS: ¿es un KML y viene desde el upload de Geolocation?
                (fileName.toLowerCase().indexOf(kmlPattern) === fileName.length - kmlPattern.length && target === self)) {

                self.clear(self.Const.Layers.TRACK);
                self.importTrack(e);

                if (/.kml$/g.test(fileName.toLowerCase()) && self.layerTrack) {
                    if (self.layerTrack.styles) {
                        self.layerTrack.features.forEach(function (feature) {
                            if (feature instanceof TC.feature.Point && self.layerTrack.styles.point) {
                                feature.setStyle(self.layerTrack.styles.point);
                            } else if (feature instanceof TC.feature.Polyline && self.layerTrack.styles.line) {
                                feature.setStyle(self.layerTrack.styles.line);
                            }
                        });
                    }
                }
            } else {
                //GLS: si es un KML pero viene desde el mapa o es otro tipo de archivo que no es ni GPX ni KML, lo ignoramos
                return;
            }
        }.bind(self));

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, callback);
        });
    };

    ctlProto.importTrack = function (options) {
        var self = this;

        if (!self.isDisabled) {
            if (options.fileName && options.features && options.features.length > 0) {

                var wait = self.getLoadingIndicator().addWait();
                self.importedFileName = options.fileName;
                const addPromises = [];
                for (var i = 0, len = options.features.length; i < len; i++) {
                    addPromises.push(self.layerTrack.addFeature(options.features[i]));
                }
                Promise.all(addPromises).then(function () {
                    self.wrap.processImportedFeatures({ wait: wait, notReproject: options.notReproject });

                    if (self.layerTrack) { // Si tenemos capa es que todo ha ido bien y gestionamos el despliegue del control
                        // Desplegamos el control "ubicar" al importar mediante drag&drop
                        if (self.map && self.map.layout && self.map.layout.accordion) {
                            if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                self.map.controls
                                    .filter(function (ctl) {
                                        // Todos los otros controles que no cuelgan de otro control
                                        return ctl !== self && !ctl.containerControl;
                                    })
                                    .forEach(function (ctl) {
                                        ctl.div.classList.add(TC.Consts.classes.COLLAPSED);
                                    });
                            }
                        }

                        self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                        self.div.querySelector('.' + self.CLASS + '-btn-tracks > span').click();

                        if (!options.isShared) {
                            // abrimos el panel de herramientas
                            self.map.trigger(TC.Consts.event.TOOLSOPEN);
                        }                        
                    }
                });
            }
        } else if (/.gpx$/g.test(options.fileName.toLowerCase())) {
            self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
        }
    };

    ctlProto.prepareFeaturesToShare = function (trackUid) {
        const self = this;

        return new Promise(function (resolve, reject) {
            if (trackUid) {

                var storageData = self.availableTracks.filter(function (saved) {
                    return saved.uid.toString() === trackUid.toString();
                })[0].data;

                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                var storageFeatures = new ol.format.GeoJSON().readFeatures(storageData);
                const promises = new Array(storageFeatures.length);
                storageFeatures.forEach(function (f, idx) {
                    promises[idx] = TC.wrap.Feature.createFeature(f);
                });

                Promise.all(promises).then(function (tcFeatures) {
                    self.featuresToShare = tcFeatures.map(function (f) {
                        const fObj = {};
                        var layerStyle;
                        switch (true) {
                            case TC.feature.Marker && f instanceof TC.feature.Marker:
                                fObj.type = TC.Consts.geom.MARKER;
                                break;
                            case TC.feature.Point && f instanceof TC.feature.Point:
                                fObj.type = TC.Consts.geom.POINT;
                                break;
                            case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                                fObj.type = TC.Consts.geom.POLYLINE;
                                break;
                            case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                                fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                                break;
                        }
                        fObj.id = f.id;
                        fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                        fObj.data = f.getData();

                        return fObj;
                    });

                    resolve();
                });
            } else {
                resolve();
            }
        });


    };

    var visibilityTrack = true;
    ctlProto.renderData = function (data, callback) {
        const self = this;

        var sel = self.Const.Selector;

        return TC.Control.prototype.renderData.call(self, data, function () {

            const options = self.div.querySelectorAll(self._classSelector + '-panel');
            self.div.querySelectorAll('.' + self.CLASS + '-select span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, function (e) {
                    var label = e.target;
                    while (label && label.tagName !== 'LABEL') {
                        label = label.parentElement;
                    }
                    const newFormat = label.querySelector('input[type=radio][name=mode]').value;

                    options.forEach(function (option) {
                        option.classList.toggle(TC.Consts.classes.HIDDEN, !option.matches('.' + self.CLASS + '-' + newFormat));
                    });
                });
            });

            self.track = {
                activateButton: self.div.querySelector(self._classSelector + '-track-ui-activate'),
                deactivateButton: self.div.querySelector(self._classSelector + '-track-ui-deactivate'),
                trackSearch: self.div.querySelector(self._classSelector + '-track-available-srch'),
                trackImportFile: self.div.querySelector(self._classSelector + '-track-import'),
                trackSave: self.div.querySelector(self._classSelector + '-track-save'),
                trackAdd: self.div.querySelector(self._classSelector + '-track-add-wpt'),
                trackContinue: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-continue'),
                trackRenew: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-new'),
                trackClose: self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog button.tc-modal-close'),
                //trackAddSegment: self.div.querySelector('#tc-ctl-geolocation-track-segment'),
                trackAdvertisementOK: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-ok')
            };

            self.track.trackList = self.div.querySelector(self._classSelector + '-track-available-lst');

            self.track.trackToolPanelOpened = self.div.querySelector('#tc-ctl-geolocation-track-panel-opened');

            self.div.querySelector('.' + ctlProto.CLASS + '-track-panel-help').addEventListener('click', function () {
                _showAlerMsg.call(self);
            });

            self.track.trackName = self.div.querySelector(self._classSelector + '-track-title');

            self.track.trackWPT = self.div.querySelector(self._classSelector + '-track-waypoint');

            if (TC.Util.detectMobile()) {
                if (matchMedia('screen and (max-height: 50em) and (max-width: 50em)').matches)
                    self.track.trackToolPanelOpened.checked = false;
            }

            if (window.File && window.FileReader && window.FileList && window.Blob) {
                self.track.trackImportFile.disabled = false;
                // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
                self.track.trackImportFile.addEventListener(TC.Consts.event.CLICK, function (e) {
                    // Envolvemos el input en un form
                    const input = this;
                    const form = document.createElement('form');
                    const parent = input.parentElement;
                    parent.insertBefore(form, input);
                    form.appendChild(input);
                    form.reset();
                    // Desenvolvemos el input del form
                    form.insertAdjacentElement('afterend', input);
                    parent.removeChild(form);
                });
                self.track.trackImportFile.addEventListener('change', function (e) {
                    if (!self._cleaning) { // Valido que el evento import no lo provoco yo al limpiar el fileinput (al limpiar se lanza el change)                        
                        self.clear(self.Const.Layers.TRACK);

                        if (self.map) {
                            self.map.on(TC.Consts.event.LAYERERROR, _layerError);
                            self.map.wrap.loadFiles(e.target.files, { control: self });
                        }
                    }
                });
            } else {
                console.log('no es posible la importación');
            }

            self.track.activateButton.addEventListener('click', function () {
                self.activateTracking();
                _activateTrackingBtns.call(self);

            });
            self.track.deactivateButton.addEventListener('click', function () {
                self.deactivateTracking();
                _deactivateTrackingBtns.call(self);
            });

            var _filter = function (searchTerm) {
                searchTerm = searchTerm.toLowerCase();
                //tc-ctl-geolocation-track-available-empty
                const lis = Array.from(self.track.trackList.querySelectorAll('li'));
                lis.forEach(function (li) {
                    li.style.display = 'none';
                });
                const trackLis = lis.filter(function (li) {
                    return li.matches('li:not([class]),li.' + self.Const.Classes.SELECTEDTRACK);
                });

                const searchIcon = self.div.querySelector(self._classSelector + '-track-search-icon');
                if (searchTerm.length === 0) {
                    trackLis.forEach(function (li) {
                        li.style.display = '';
                    });
                    searchIcon.style.visibility = 'visible';
                } else {
                    searchIcon.style.visibility = 'hidden';
                    var r = new RegExp(searchTerm, 'i');
                    trackLis.forEach(function (li) {
                        li.style.display = r.test(li.querySelector('span').textContent) ? '' : 'none';
                    });

                    if (!trackLis.some(function (li) {
                        return li.style.display === '';
                    })) {
                        lis.forEach(function (li) {
                            if (li.matches('[class^="tc-ctl-geolocation-track-not"]')) {
                                li.style.display = '';
                            }
                        });
                    }
                }
            };
            const trackSearchListener = function () {
                _filter(this.value.toLowerCase().trim());
            };
            self.track.trackSearch.addEventListener("keyup", trackSearchListener);
            self.track.trackSearch.addEventListener("search", trackSearchListener);

            // en el panel
            self.track.trackSave.addEventListener('click', self.saveTrack.bind(self));
            self.track.trackAdd.addEventListener('click', self.addWaypoint.bind(self));

            const list = self.div.querySelector(self._classSelector + '-track-available-lst');

            // en lista
            var _edit = function (edit, elm) {
                if (elm.tagName !== 'LI') {
                    elm = elm.parentElement;
                }

                const input = elm.querySelector('input');
                const span = elm.querySelector('span');

                if (edit) {

                    input.classList.remove(TC.Consts.classes.HIDDEN);
                    input.focus();
                    input.value = span.textContent;
                    span.classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_GPX).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_KML).classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.remove(TC.Consts.classes.HIDDEN);
                } else {

                    input.classList.add(TC.Consts.classes.HIDDEN);
                    span.classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_GPX).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_KML).classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.add(TC.Consts.classes.HIDDEN);
                }
            };

            self.uiSimulate = function (simulate, elm) {
                if (elm) {
                    var editControls = [
                        sel.SIMULATE,
                        sel.EDIT,
                        sel.DELETE,
                        sel.EXPORT_GPX,
                        sel.EXPORT_KML
                    ];
                    var simulateControls = [
                        sel.STOP,
                        sel.PAUSE,
                        sel.BACKWARD,
                        sel.FORWARD,
                        sel.SPEED
                    ];
                    var cnt = elm.tagName === 'LI' ? elm : elm.parentNode;

                    editControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = simulate;
                    });

                    simulateControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = !simulate;
                    });
                }
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.SIMULATE, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';

                _loadTrack(self, e.target).then(function () { //Para evitar el bloqueo de la interfaz en móviles
                    self.getLoadingIndicator().removeWait(wait)
                });
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.DRAW, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                _drawTrack(self, e.target).then(function () {
                    self.getLoadingIndicator().removeWait(wait);
                });
            }));

            self.on(self.Const.Event.IMPORTEDTRACK, function (e) {
                if (!self.isDisabled) {
                    const listElement = self.track.trackList.querySelector('li[data-id="' + e.index + '"]');
                    _drawTrack(self, listElement.querySelector(sel.DRAW));
                    setTimeout(function () {
                        self.track.trackList.scrollTop = e.index * listElement.offsetHeight;
                    }, 100);
                } else {
                    self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
                }
            });

            const _stopOtherTracks = function (self, trackLiId) {
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (listItem) {
                    if (listItem.dataset.id !== trackLiId) {
                        const btnSimulate = listItem.querySelector(sel.SIMULATE);
                        const btnPause = listItem.querySelector(sel.PAUSE);

                        btnSimulate.classList.remove(self.Const.Classes.SIMULATIONACTIVATED);
                        btnSimulate.setAttribute('title', self.getLocaleString("tr.lst.simulate"));
                        btnPause.classList.remove('play');
                        btnPause.setAttribute('title', self.getLocaleString("tr.lst.pause"));

                        self.uiSimulate(false, listItem);
                        _edit(false, listItem);
                    }
                });

                self.clear(self.Const.Layers.TRACK);
            };

            var _drawTrack = function (self, btnDraw) {
                return new Promise(function (resolve, reject) {

                    const trackLi = btnDraw.parentElement;

                    setTimeout(function () {
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.uiSimulate(false, btnDraw);

                            self.clear(self.Const.Layers.TRACK);

                            btnDraw.setAttribute('title', btnDraw.textContent);
                        }
                        else if (self.getSelectedTrack()) { // GLS: si hay elemento seleccionado actuamos
                            _stopOtherTracks(self, trackLi.dataset.id);
                            self.drawTrack(trackLi);
                        } else {
                            self.drawTrack(trackLi);
                        }

                        /* GLS: 15/02/2019 Preparamos la feature por si se comparte, necesito hacerlo aquí 
                           porque la gestión en asíncrona y todo el flujo de exportación es síncrono */
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.prepareFeaturesToShare(trackLi.dataset.uid).then(function () {
                                resolve();
                            });
                        } else {
                            resolve();
                        }
                    }, 0);
                });
            };

            var _loadTrack = function (self, btnSimulate) {
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        const trackLi = btnSimulate.parentElement;

                        _stopOtherTracks(self, trackLi.dataset.id);
                        self.uiSimulate(false, self.getSelectedTrack());
                        self.uiSimulate(true, btnSimulate);

                        self.simulate_paused = false;
                        self.simulateTrack(trackLi);

                        resolve();
                    }, 0);
                });
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EDIT, function (e) {
                _edit(true, e.target);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.DELETE, function (e) {
                self.removeTrack(e.target.parentElement);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.SAVE, function (e) {
                var newName = e.target.parentElement.querySelector('input').value;
                if (newName.trim().length === 0) {
                    TC.alert(self.getLocaleString('geo.trk.edit.alert'));
                }
                else {
                    self.editTrackName(e.target.parentElement.dataset.id, e.target.parentElement.querySelector('input').value);
                    _edit(false, e.target);
                }
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.CANCEL, function (e) {
                _edit(false, e.target);
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EXPORT_GPX + ',' + self._classSelector + ' ' + sel.EXPORT_KML, function (e) {
                const parent = e.target.parentElement;
                var prefix = 'tc-btn-export-';
                var className = Array.from(e.target.classList).filter(function (cls) {
                    return cls.indexOf(prefix) === 0;
                })[0];
                var mimeType = className.replace(prefix, '').toUpperCase();

                self.export(mimeType, parent).then(function (data) {
                    if (data) {
                        var filename = parent.querySelector('span').textContent;
                        var regex = new RegExp(self.Const.SupportedFileExtensions.join('|'), 'gi');
                        var cleanFilename = filename.replace(regex, '');
                        TC.Util.downloadFile(cleanFilename + '.' + mimeType.toLowerCase(), self.Const.MimeMap[mimeType], data);
                    } else {
                        TC.alert(self.getLocaleString('geo.error.export'));
                    }
                });
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.STOP, function (e) {
                self.uiSimulate(false, e.target);
                self.wrap.simulateTrackEnd();
                const btnPause = e.target.parentElement.querySelector(sel.PAUSE);
                btnPause.classList.remove('play');
                btnPause.setAttribute('title', self.getLocaleString('tr.lst.pause'));

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';
                self.simulate_speed = 1;
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.PAUSE, function (e) {
                self.simulate_paused = !e.target.classList.contains('play');
                if (self.simulate_paused)
                    self.simulate_pausedElapse = -1;

                e.target.setAttribute('title', self.getLocaleString(self.simulate_paused ? 'tr.lst.play' : 'tr.lst.pause'));
                e.target.classList.toggle('play', !!self.simulate_paused);
            }));

            var lapse = 0.5;
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.BACKWARD, function (e) {
                if (self.simulate_speed == 1)
                    self.simulate_speed = lapse;
                else self.simulate_speed = self.simulate_speed / 2;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.FORWARD).disabled = false;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                if (self.simulate_speed == 0.000244140625) {
                    e.target.disabled = true;
                }
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.FORWARD, function (e) {
                self.simulate_speed = self.simulate_speed / lapse;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.BACKWARD).disabled = false;

                if (self.simulate_speed == 4096) {
                    e.target.disabled = true;
                }
            }));


            // popup
            self.track.trackContinue.addEventListener('click', function () {
                // cerramos popup y continuamos con el track de session y almacenando en session
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackRenew.addEventListener('click', function () {
                // eliminamos el track actual de session - restablecemos el tracking
                delete self.sessionTracking;
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, undefined);
                localforage.removeItem(self.Const.LocalStorageKey.TRACKINGTEMP);
                // cerramos el popup
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackClose.addEventListener('click', function () {
                _deactivateTrackingBtns.call(self);
            });
            //self.track.trackAddSegment.addEventListener('click', function () {
            //    TC.alert('pendiente');
            //    // cerramos el popup
            //    TC.Util.closeModal();
            //});

            // popup advertencia
            self.track.trackAdvertisementOK.addEventListener('click', function () {

                const checkboxes = document.body.querySelectorAll('input[name*="Advertisement"]:checked');

                if (checkboxes.length > 0) {
                    const promise = new Promise(function (resolve, reject) {
                        if (window.localforage)
                            resolve();
                        else {
                            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                                resolve();
                            });
                        }
                    });

                    promise.then(function () {
                        localforage.setItem(checkboxes[0].getAttribute('name'), false);
                    });
                }

                TC.Util.closeModal();
            });

            self.track.renderTrack = document.querySelector('#tc-ctl-geolocation-track-render');
            self.track.renderTrack.addEventListener('change', function () {
                if (self.track.activateButton.classList.contains(TC.Consts.classes.HIDDEN)) {
                    self.layerTracking.setVisibility(this.checked);
                }

                visibilityTrack = this.checked;
            });

            if (window.localforage)
                self.bindTracks();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    self.bindTracks();
                });
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        var self = this;
        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Util.closeModal();
        self.clearSelection();
        self.deactivateTracking();
        //TC.Control.prototype.deactivate.call(self);
    };

    var _layerError = function () {
        var self = this;

        self.map.off(TC.Consts.event.LAYERERROR, _layerError);
        self.clearFileInput(self.track.trackImportFile);

        TC.alert(self.getLocaleString("geo.trk.upload.error3"));
    };
    var _activateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.add(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.remove(TC.Consts.classes.HIDDEN);
    };

    var _deactivateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
    };

    var _showAlerMsg = function () {
        var self = this;
        self.map.toast(self.div.querySelector(".alert-warning").innerHTML, {
            duration: 10000
        });
    };

    ctlProto.markerStyle = {
        radius: 7,
        fillColor: [255, 0, 0, 100],
        strokeColor: [255, 255, 255, 255],
        strokeWidth: 2
    };

    ctlProto.lineStyle = {
        strokeWidth: 2,
        strokeColor: [0, 206, 209, 255]
    };

    ctlProto.setFormatInfoNewPosition = function (newPosition) {
        var self = this;

        var data = {};
        var locale = TC.Util.getMapLocale(self.map);

        if (self.map.on3DView) {
            var geoCoords = self.map.crs !== self.map.view3D.crs ? TC.Util.reproject(newPosition.position, self.map.crs, self.map.view3D.crs) : newPosition.position;
            data.x = geoCoords[0].toLocaleString(locale);
            data.y = geoCoords[1].toLocaleString(locale);

            data.mdt = Math.round(self.map.view3D.getHeightFromMDT(geoCoords)).toLocaleString(locale);

            data.isGeo = true;

        } else {
            data.x = Math.round(newPosition.position[0]).toLocaleString(locale);
            data.y = Math.round(newPosition.position[1]).toLocaleString(locale);
        }

        data.z = (Math.round(newPosition.altitude).toLocaleString(locale));
        data.accuracy = (Math.round(newPosition.accuracy).toLocaleString(locale));
        data.speed = newPosition.speed.toLocaleString(locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 });

        return data;
    };

    ctlProto.renderInfoNewPosition = function (d) {
        var self = this;

        self.getRenderedHtml(self.CLASS + '-tracking-toast', self.setFormatInfoNewPosition(d.pd), function (html) {

            if (!self.track.infoPanel) {
                self.track.infoPanel = true;

                var resultsPanelOptions = {
                    content: "table",
                    titles: {
                        main: self.getLocaleString("geo.mylocation"),
                        max: self.getLocaleString("geo.mylocation.show")
                    },
                    classes: {
                        collapsed: "tracking"
                    }
                };

                var ctlPromise;
                const addResultsPanelInfo = function (controlContainer) {
                    resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                    ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                };

                if (self.options.displayOn) {
                    var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                    if (!controlContainer) {
                        self.map.addControl(self.options.displayOn).then(addResultsPanelInfo);
                    } else {
                        addResultsPanelInfo(controlContainer);
                    }
                } else {
                    resultsPanelOptions.div = document.createElement('div');
                    self.map.div.appendChild(resultsPanelOptions.div);
                    ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                }

                ctlPromise.then(function (resultsPanelInfo) {
                    resultsPanelInfo.caller = self;
                    self.map.getControlsByClass('TC.control.ResultsPanel').filter(function (panel) {
                        return panel.content === "table" && panel !== resultsPanelInfo;
                    }).forEach(function (panel) {
                        panel.close();
                    });

                    self.track.infoPanel = resultsPanelInfo;

                    resultsPanelInfo.renderPromise().then(function () {
                        resultsPanelInfo.open(html);
                    });
                });
            } else if (typeof (self.track.infoPanel) !== "boolean" && !self.track.infoPanel.isMinimized()) {
                self.track.infoPanel.renderPromise().then(function () {
                    self.track.infoPanel.getTableContainer().innerHTML = html;
                    if (!self.track.infoPanel.isVisible()) {
                        self.track.infoPanel.doVisible();
                    }
                });
            }
        });
    };


    var duringTrackingToolsPanel = function () {
        var self = this;

        if (!self.track.trackToolPanelOpened.checked) {
            self.map.trigger(TC.Consts.event.TOOLSCLOSE);
        }
    };

    var _tracking = function () {
        var self = this;

        self.activate();

        _activateTrackingBtns.call(self);
        duringTrackingToolsPanel.call(self);

        self.on(self.Const.Event.POSITIONCHANGE, function (d) {

            self.currentPoint = d.pd;
            self.renderInfoNewPosition(d);

            self.track.trackName.disabled = false;
            self.track.trackSave.disabled = false;

            self.track.trackWPT.disabled = false;
            self.track.trackAdd.disabled = false;

            // cada vez que se registra una nueva posición almacenamos en sessionStorage
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);
        });
        self.on(self.Const.Event.STATEUPDATED, function (data) {
            //self.track.htmlMarker.setAttribute('src', data.moving ? 'layout/idena/img/geo-marker-heading.png' : 'layout/idena/img/geo-marker.png');
        });

        self.clear(self.Const.Layers.TRACKING);

        advertisement.call(self, self.Const.LocalStorageKey.TRACKINGSHOWADVERTISEMENT);

        self.wrap.setTracking(true);
    };

    /* inicio gestión suspensión de la pantalla en móviles */
    var _onpauseVideo;
    var addVideoKeepScreenOn = function () {
        var self = this;

        if (!self.videoScreenOn) {
            var media = {
                WebM: "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=",
                MP4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=="
            };

            self.videoScreenOn = document.createElement('video');
            self.videoScreenOn.setAttribute("loop", "");
            self.videoScreenOn.setAttribute("muted", "");
            self.videoScreenOn.setAttribute("webkit-playsinline", "");
            self.videoScreenOn.setAttribute("playsinline", "");
            self.videoScreenOn.setAttribute("style", "transform: translateZ(0px);");

            var sourceWebM = document.createElement('source');
            sourceWebM.src = media.WebM;
            sourceWebM.type = "video/webm";
            self.videoScreenOn.appendChild(sourceWebM);

            var sourceMP4 = document.createElement('source');
            sourceMP4.src = media.MP4;
            sourceMP4.type = "video/mp4";
            self.videoScreenOn.appendChild(sourceMP4);
        }

        self.videoScreenOn.play();
    };
    var removeVideoKeepScreenOn = function () {
        var self = this;
        if (self.videoScreenOn) {
            self.videoScreenOn.pause();
        }
    };

    var _onWindowBlurred;
    var onWindowBlurred = function () {
        var self = this;

        fromSessionToStorage.apply(self);
    };

    var _onWindowFocused;
    var onWindowFocused = function () {
        var self = this;

        if (self.videoScreenOn.paused)
            self.videoScreenOn.play();

        fromStorageToSession.apply(self);
    };

    var getHiddenProperty = function () {
        var prefixes = ['webkit', 'moz', 'ms', 'o'];

        if ('hidden' in document) return 'hidden';

        for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document)
                return prefixes[i] + 'Hidden';
        }

        return null;
    };
    var _onWindowVisibility;
    var onWindowVisibility = function () {
        var self = this;

        var hidden = getHiddenProperty();

        if (!document[hidden])
            onWindowFocused.apply(self);

        console.log('video is: ' + self.videoScreenOn.paused);
    };
    var addWindowEvents = function () {
        var self = this;

        if (!_onWindowVisibility)
            _onWindowVisibility = onWindowVisibility.bind(self);

        if (!_onWindowBlurred)
            _onWindowBlurred = onWindowBlurred.bind(self);

        if (!_onWindowFocused)
            _onWindowFocused = onWindowFocused.bind(self);

        window.addEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && TC.browserFeatures.touch() && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.addEventListener('pagehide', _onWindowBlurred, false);
            window.addEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.addEventListener('blur', _onWindowBlurred, false);
            window.addEventListener('focus', _onWindowFocused, false);
        }
    }
    var removeWindowEvents = function () {

        window.removeEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && TC.browserFeatures.touch() && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.removeEventListener('pagehide', _onWindowBlurred, false);
            window.removeEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.removeEventListener('blur', _onWindowBlurred, false);
            window.removeEventListener('focus', _onWindowFocused, false);
        }
    };

    var fromSessionToStorage = function () {
        var self = this;

        var sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
        if (sessionTracking && sessionTracking.length > 0)
            localforage.setItem(self.Const.LocalStorageKey.TRACKINGTEMP, typeof (sessionTracking) === "string" ? sessionTracking : JSON.stringify(sessionTracking));
    };
    var fromStorageToSession = function () {
        var self = this;

        localforage.getItem(self.Const.LocalStorageKey.TRACKINGTEMP).then(function (storageData) {
            if (storageData !== null && storageData !== "null" && storageData.length > 0) {
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, storageData);
            }
        });
    };
    /* final gestión suspensión de la pantalla en móviles */

    var advertisement = function (showAdvertisement) {
        var self = this;

        var done = new Promise(function (resolve, reject) {
            if (window.localforage)
                resolve();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    resolve();
                });
            }
        });

        done.then(function () {
            localforage.getItem(showAdvertisement).then(function (registeredShowAdvertisement) {
                if (registeredShowAdvertisement == null) {
                    const dialog = self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog');
                    const checkbox = dialog.querySelector('input[type="checkbox"]');
                    checkbox.setAttribute('name', showAdvertisement);
                    checkbox.checked = false;

                    document.querySelector('#pageBlurMsg').textContent = TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur'): self.getLocaleString('geo.trk.page.blur.desktop');

                    dialog.querySelector('h3').textContent = showAdvertisement == self.Const.LocalStorageKey.GPSSHOWADVERTISEMENT ?
                        self.getLocaleString("geo.track.activate") + " " + self.getLocaleString("geo.gps") :
                        self.getLocaleString('geo.track.activate.title');

                    TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog'));
                }
            });
        });

        self.map.toast(!TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur.desktop') : self.getLocaleString('geo.trk.page.blur'), {
            type: TC.Consts.msgType.WARNING
        });
    };

    ctlProto._askTracking = function (callback) {
        var self = this;

        TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog'), {
            closeCallback: function () {

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            }
        });

        return true;
    };

    ctlProto.activateTracking = function () {
        var self = this;
        var trackingAvailable = true;

        if (!self.isActive) {
            self.activate();
        }

        self.clear(self.Const.Layers.TRACKING);

        try {
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TEST, self.Const.LocalStorageKey.TEST);
        } catch (error) {
            if (error.code === DOMException.QUOTA_EXCEEDED_ERR)
                TC.alert(self.getLocaleString("geo.error.trackinglocalstorage"));
            else TC.error(error);

            trackingAvailable = false;
        }

        if (trackingAvailable) {
            addVideoKeepScreenOn.apply(self);
            addWindowEvents.apply(self);

            self.sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
            if (self.sessionTracking) {
                var asked = self._askTracking(function () {
                    _deactivateTrackingBtns.call(self);
                });

                if (!asked) {
                    self.track.trackRenew.click();
                }
            } else _tracking.call(self);
        } else { _deactivateTrackingBtns.call(self); }
    };

    ctlProto.deactivateTracking = function () {
        var self = this;

        var _deactivateTracking = function () {

            self.track.infoPanel.close();

            fromSessionToStorage.apply(self);

            self.wrap.setTracking(false);


            delete self.geopositionTracking;

            if (!visibilityTrack) {
                self.div.querySelector(self._classSelector + '-track-render').querySelector('label').click();
            }

            removeVideoKeepScreenOn.apply(self);
            removeWindowEvents.apply(self);

            self.off(self.Const.Event.POSITIONCHANGE);
            self.off(self.Const.Event.STATEUPDATED);

            _deactivateTrackingBtns.call(self);

            self.track.trackName.value = '';
            self.track.trackName.disabled = true;
            self.track.trackSave.disabled = true;

            self.track.trackWPT.value = '';
            self.track.trackWPT.disabled = true;
            self.track.trackAdd.disabled = true;

            self.clear(self.Const.Layers.TRACKING);
            self.clear(self.Const.Layers.GPS);

            //TC.Control.prototype.deactivate.call(self);

            return true;
        };

        if (self.wrap.hasCoordinates()) {
            self.map.toast(self.getLocaleString("geo.trk.deactivate.alert"), {
                duration: 10000
            });
            //TC.alert(self.getLocaleString("geo.trk.deactivate.alert"));
            return _deactivateTracking();
        } else return _deactivateTracking();
    };

    /* Obtengo los tracks desde localForage */
    ctlProto.getStoredTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            var tracks = [];

            localforage.keys().then(function (keys) {
                keys = keys.filter(function (k) {
                    if (!(k.indexOf(self.Const.LocalStorageKey.TRACKINGTEMP) === 0) && k.indexOf(self.Const.LocalStorageKey.TRACKING) === 0) {
                        return /trk#\d/i.exec(k);
                    }
                    return false;
                });

                if (keys.length == 0) {
                    self.availableTracks = tracks;
                    resolve(tracks);
                }

                const promises = new Array(keys.length);
                keys.forEach(function (key, idx) {
                    promises[idx] = new Promise(function (res, rej) {
                        localforage.getItem(key, function (e, v) {
                            res(v);
                        });
                    });
                });

                Promise.all(promises).then(function (results) {
                    if (results && results.length) {
                        results.forEach(function (r) {
                            var r = JSON.parse(r);
                            if (r instanceof Array) {
                                tracks = tracks.concat(r);
                            } else {
                                tracks.push(r);
                            }
                        });

                        var tracksArray = tracks.length > 1 ? _orderTracks(tracks) : tracks;
                        self.availableTracks = tracksArray;
                        resolve(tracksArray);
                    }
                });
            });
        });
    };

    /**
     * Recibe una sucesión de tracks y la ordena por nombre.
     */
    var _orderTracks = function (tracks) {
        var tracksArray = [];

        for (var index in tracks) {
            if (tracks[index] && typeof (tracks[index]) === "object") {
                tracksArray.push(tracks[index]);
                tracksArray.sort(function (a, b) {
                    if (typeof (a.name) === "string") {
                        return TC.Util.isFunction(a.name.localeCompare) ? a.name.localeCompare(b.name) : 0;
                    } else { return 0; }
                });
            }
        }

        return tracksArray;
    };

    /* Almaceno los tracks mediante localForage, actualizo la vble availableTracks y actualizo la lista de tracks */
    ctlProto.setStoredTracks = function (tracks) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const promises = [];
            tracks.forEach(function (t) {
                promises.push(new Promise(function (res, rej) {
                    localforage.setItem(self.Const.LocalStorageKey.TRACKING + "#" + t.uid, JSON.stringify(t), function (e, v) {
                        res(v);
                    });
                }));
            });

            Promise.all(promises).then(function () {
                self.getStoredTracks().then(function () {
                    self.bindTracks();
                    resolve();
                });
            });
        });
    };

    /* Obtengo los tracks desde vble local */
    ctlProto.getAvailableTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (!self.availableTracks) {
                self.getStoredTracks().then(function (availableTracks) {
                    resolve(availableTracks);
                });
            }
            else {
                resolve(self.availableTracks);
            }
        });
    };

    ctlProto.bindTracks = function () {
        var self = this;

        const listItems = self.track.trackList.querySelectorAll('li');
        listItems.forEach(function (li) {
            li.style.display = 'none';
        });

        self.getAvailableTracks().then(function (tracks) {

            if (_isEmpty(tracks)) {
                self.track.trackList.querySelectorAll('li[class^="tc-ctl-geolocation-track-available-empty"]').forEach(function (li) {
                    li.style.display = '';
                });
                self.track.trackSearch.disabled = true;
            }
            else {
                const currentSelectedTrack = self.getSelectedTrack();
                var currentSelectedTrackId;
                if (currentSelectedTrack) {
                    currentSelectedTrackId = currentSelectedTrack.dataset.uid
                }
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (li) {
                    self.track.trackList.removeChild(li);
                });

                for (var i = 0; i < tracks.length; i++) {
                    var t = tracks[i];
                    if (typeof (t) === "object") {
                        self.getRenderedHtml(self.CLASS + '-track-node', {
                            id: i, uid: t.uid, name: t.name ? t.name.trim() : ''
                        }, function (html) {
                            const parser = new DOMParser();
                            const newLi = parser.parseFromString(html, 'text/html').body.firstChild;
                            self.track.trackList.appendChild(newLi);
                        });
                    }
                }

                if (currentSelectedTrackId) {
                    self.setSelectedTrack(self.track.trackList.querySelector('li[data-uid="' + currentSelectedTrackId + '"]'));
                }

                self.track.trackSearch.disabled = false;
            }
        });
    };

    ctlProto.chartProgressInit = function () {
        const self = this;

        if (!window.d3) {
            TC.syncLoadJS(TC.Consts.url.D3C3);
        }

        const dataDiv = d3.select(".c3-event-rects,.c3-event-rects-single").node().getBoundingClientRect();
        self.miDiv = document.createElement('div');
        self.miDiv.classList.add('miDiv');
        self.miDiv.style.width = dataDiv.width + 'px';
        self.miDiv.style.height = dataDiv.height + 'px';

        self.miProgressDiv = document.createElement('div');
        self.miProgressDiv.classList.add(
            'miProgressDiv',
            self.CLASS + '-track-elevation-chart-progress',
            TC.Consts.classes.HIDDEN);
        self.miProgressDiv.style.width = '0%';
        self.miProgressDiv.style.height = dataDiv.height + 'px';

        self.miProgressTextDiv = document.createElement('div');
        self.miProgressTextDiv.classList.add(
            'miProgressTextDiv',
            'tc-ctl-geolocation-track-elevation-chart-progress',
            'text');
        self.miProgressTextDiv.style.width = dataDiv.width + 'px';
        self.miProgressTextDiv.style.height = dataDiv.height + 'px';

        self.miDiv.style.top = dataDiv.top + 'px';
        self.miDiv.style.left = dataDiv.left + 'px';
        self.miDiv.style.bottom = dataDiv.bottom + 'px';
        self.miDiv.style.right = dataDiv.right + 'px';
        self.miDiv.style.position = 'absolute';
        self.miDiv.style.zIndex = 10008;
        self.miDiv.style.display = 'none';

        self.miProgressDiv.appendChild(self.miProgressTextDiv);
        self.miDiv.appendChild(self.miProgressDiv);
        document.body.appendChild(self.miDiv);

    };

    ctlProto.chartProgressClear = function () {
        const self = this;
        if (self.miDiv) {
            self.miDiv.parentElement.removeChild(self.miDiv);
            self.miDiv = null;
            self.miProgressDiv = null;
            self.miProgressTextDiv = null;
        }
    };

    ctlProto.chartSetProgress = function (previous, current, distance, doneTime) {
        var self = this;

        if (self.miDiv && self.miDiv.style.display === 'none') {
            self.miDiv.style.display = '';
        }

        self.miProgressDiv.classList.remove(TC.Consts.classes.HIDDEN);

        var done = previous.d;
        var progress = (done + Math.hypot(previous.p[0] - current[0], previous.p[1] - current[1])) / distance * 100;

        self.miProgressDiv.style.width = progress + '%';

        var locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
        var ele = parseInt(current[2].toFixed(0)).toLocaleString(locale);
        var dist;
        var measure;
        if ((done / 1000) < 1) {
            dist = Math.round((done / 1000) * 1000);
            measure = ' m';
        } else {
            dist = Math.round((done / 1000) * 100) / 100;
            measure = ' km';
        }

        dist = dist.toLocaleString(locale);

        self.miProgressTextDiv.innerHTML = '<div><span>' + ele + ' m' + '</span>' + '<br>' + '<span>' + dist + measure + '</span></div>' + (doneTime ? '<br><span>' + doneTime.toString + '</span>' : '');

    };

    ctlProto._getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.simulateTrack = function (li) {
        var self = this;

        self.simulate_speed = 1;

        self.drawTrack(li, false).then(function () {
            self.wrap.simulateTrack();
        });
    };

    ctlProto.drawTrack = function (li, activateSnapping) {
        var self = this;

        duringTrackingToolsPanel.call(self);
        return new Promise(function (resolve, reject) {
            self.setSelectedTrack(li);
            self.drawTrackingData(li).then(function () {
                self.elevationTrack(li);

                self.activate();
                resolve();
            });
        });
    };


    ctlProto.elevationTrack = function (li, resized) {
        var self = this;

        if (resized) {            

            self.wrap.simulateTrackEnd();
            self.uiSimulate(false, li);
            return;
        }

        if (!self.onResize) {
            self.onResize = self.elevationTrack.bind(self, li, true);
            window.addEventListener("resize", self.onResize, false);
        }

        self.chart = {
            coordinates: []
        };

        if (self.track.elevationChart)
            self.track.elevationChart = self.track.elevationChart.destroy();

        var getChartData = function (li) {
            return new Promise(function (resolve, reject) {
                TC.loadJS(
                    !TC.tool || !TC.tool.Elevation,
                    TC.apiLocation + 'TC/tool/Elevation',
                    function () {
                        self.getTrackingData(li).then(function (track) {
                            var geoJSON = track.data;
                            if (geoJSON) {
                                var x, ele; x = []; ele = [];
                                var empty = true;
                                var minEle, maxEle;
                                var elevationGain = {};
                                var time = {};
                                var km = 0;
                                var geom;

                                var f = (new ol.format.GeoJSON()).readFeatures(geoJSON);

                                var getDistance = function () {
                                    if (geom.getLayout() == ol.geom.GeometryLayout.XYZ ||
                                        geom.getLayout() == ol.geom.GeometryLayout.XYZM) {
                                        var distance = 0;
                                        if (self.map.crs !== self.map.options.utmCrs) {
                                            line = new ol.geom.LineString(TC.Util.reproject(geom.getCoordinates(), self.map.crs, self.map.options.utmCrs));
                                            distance = line.getLength();
                                        } else {
                                            distance = geom.getLength();
                                        }
                                        return parseFloat((distance / 1000).toFixed(2));
                                    }

                                    return null;
                                };
                                var getTime = function () {
                                    if (geom.getLayout() == ol.geom.GeometryLayout.XYZM ||
                                        geom.getLayout() == ol.geom.GeometryLayout.XYM) {
                                        var diff = geom.getLastCoordinate()[3] - geom.getFirstCoordinate()[3];
                                        return {
                                            s: Math.floor((diff / 1000) % 60),
                                            m: Math.floor(((diff / (1000 * 60)) % 60)),
                                            h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
                                        };
                                    }

                                    return null;
                                };

                                var addX = function (x) {
                                    if (self.chart.coordinates.length > 0) {
                                        var distance = 0;
                                        self.chart.coordinates
                                            .forEach(function (point, idx, arr) {
                                                var prev = idx === 0 ? point : arr[idx - 1];

                                                if (self.map.crs !== self.map.options.utmCrs) {
                                                    point = TC.Util.reproject(point, self.map.crs, self.map.options.utmCrs);
                                                    prev = TC.Util.reproject(prev, self.map.crs, self.map.options.utmCrs);
                                                }

                                                const dx = point[0] - prev[0];
                                                const dy = point[1] - prev[1];
                                                distance += Math.sqrt(dx * dx + dy * dy);

                                                x.push(parseFloat(distance.toFixed(2)));
                                            });
                                    }
                                };

                                var addElevation = function (ele) {
                                    var y = [];
                                    for (var i = 0; i < self.chart.coordinates.length; i++) {
                                        if (self.chart.coordinates[i].length > 2) {
                                            var v = (Math.round(self.chart.coordinates[i][2] * 10) / 10);
                                            if (empty && v > 0)
                                                empty = false;

                                            ele.push(v);

                                            if (i == 0)
                                                minEle = maxEle = v;

                                            minEle = Math.min(minEle, v);
                                            maxEle = Math.max(maxEle, v);

                                        }
                                        else {
                                            resolve(null);
                                            return;
                                        }
                                    }
                                };

                                f.filter(function (feature) {
                                    return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
                                }).forEach(function (feature) {
                                    geom = feature.getGeometry();

                                    switch (geom.getType().toLowerCase()) {
                                        case 'linestring':

                                            if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                track.layout === ol.geom.GeometryLayout.XYZ) {

                                                time = getTime(geom);
                                                km = getDistance(geom);
                                                elevationGain = TC.tool.Elevation.getElevationGain({ coords: geom.getCoordinates(), hillDeltaThreshold: self.gapHill });
                                                self.chart.coordinates = self.chart.coordinates.concat(geom.getCoordinates());

                                                addX(x);
                                                addElevation(ele);
                                            }
                                            break;
                                        case 'multilinestring':

                                            if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                track.layout === ol.geom.GeometryLayout.XYZ) {

                                                var _time;
                                                var ls = geom.getLineStrings();
                                                for (var i = 0; i < ls.length; i++) {
                                                    km = km + getDistance(ls[i]);

                                                    if (ls[i].getLayout() == ol.geom.GeometryLayout.XYZM)
                                                        _time = _time + (ls[i].getLastCoordinate()[3] - ls[i].getFirstCoordinate()[3]);

                                                    self.chart.coordinates = self.chart.coordinates.concat(ls[i].getCoordinates());

                                                    if (_time) { time = getTime(_time); }

                                                    addX(x);
                                                    addElevation(ele);
                                                }
                                            }

                                            break;
                                        default:
                                            return null;
                                            break;
                                    }
                                });

                                if (ele instanceof Array && ele.length == 0) {
                                    empty = true;
                                }

                                self.chartData = !empty ? TC.Util.extend({}, { time: time, ele: ele, x: x, miny: minEle, maxy: maxEle }, elevationGain) : null;

                                resolve(self.chartData);
                                return;
                            }

                            resolve(null);
                            return;
                        });
                    }
                );
            });
        };

        getChartData(li).then(function (data) {
            var locale = TC.Util.getMapLocale(self.map);
            if (data != null) {
                if (data.time) data.time = ("00000" + data.time.h).slice(-2) + ':' + ("00000" + data.time.m).slice(-2) + ':' + ("00000" + data.time.s).slice(-2);
                data.coords = self.chart.coordinates;
                self.hasElevation = true;
            }
            else {
                self.hasElevation = false;
                data = {
                    msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                };
            }

            data.minHeight = self.CHART_SIZE.MIN_HEIGHT;
            data.maxHeight = self.CHART_SIZE.MAX_HEIGHT;

            data.minWidth = self.CHART_SIZE.MIN_WIDTH;
            data.mediumWidth = self.CHART_SIZE.MEDIUM_WIDTH;
            data.maxWidth = self.CHART_SIZE.MAX_WIDTH;

            self.map.one(TC.Consts.event.DRAWCHART, function (e) {
                self.chartProgressInit();
            });

            if (!self.resultsPanelChart) {

                if (!window.c3) {
                    TC.syncLoadJS(TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js');
                }

                var resultsPanelOptions = {
                    content: "chart",
                    titles: {
                        main: self.getLocaleString("geo.trk.chart.chpe"),
                        max: self.getLocaleString("geo.trk.chart.chpe")
                    },
                    openOn: self.Const.Event.DRAWTRACK,
                    closeOn: self.Const.Event.CLEARTRACK,
                    chart: {
                        ctx: self,
                        onmouseout: ctlProto.removeElevationTooltip,
                        tooltip: ctlProto.getElevationTooltip
                    }
                };

                var ctlPromise;
                const addResultsPanelChart = function (controlContainer) {
                    resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                    ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                };

                if (self.options.displayOn) {
                    var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                    if (!controlContainer) {
                        self.map.addControl(self.options.displayOn).then(addResultsPanelChart);
                    } else {
                        addResultsPanelChart(controlContainer);
                    }
                } else {
                    resultsPanelOptions.div = document.createElement('div');
                    self.map.div.appendChild(resultsPanelOptions.div);
                    ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                }

                ctlPromise.then(function (resultsPanelChart) {
                    resultsPanelChart.caller = self;
                    self.resultsPanelChart = resultsPanelChart;
                    resultsPanelChart.renderPromise().then(function () {

                        resultsPanelChart.activateSnapping = function (e) {
                            if (self.layerTrack && (!self.layerTrack.getVisibility() && self.layerTrack.getOpacity() == 0))
                                self.wrap.deactivateSnapping.call(self.wrap);
                        };
                        resultsPanelChart.deactivateSnapping = function (e) {
                            if (self.layerTrack && self.layerTrack.getVisibility() && self.layerTrack.getOpacity() > 0)
                                self.wrap.activateSnapping.call(self.wrap);
                        };

                        resultsPanelChart.div.addEventListener('mouseover', resultsPanelChart.deactivateSnapping);
                        resultsPanelChart.div.addEventListener('mouseout', resultsPanelChart.activateSnapping);

                        self.map
                            .on(TC.Consts.event.RESULTSPANELMIN, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = 'none';
                                }
                            })
                            .on(TC.Consts.event.RESULTSPANELMAX, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = '';
                                }
                            })
                            .on(TC.Consts.event.RESULTSPANELCLOSE, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = 'none';
                                }
                            });

                        self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
                    });
                });
            } else {
                self.resultsPanelChart.open();
                self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
            }
        });
    };

    ctlProto.clear = function (layerType) {
        var self = this;

        if (self.onResize) {
            window.removeEventListener("resize", self.onResize, false);
            self.onResize = undefined;
        }

        if (layerType == self.Const.Layers.TRACK) {

            self.layerTrack.clearFeatures();

            // gráfico perfil de elevación
            if (self.resultsPanelChart)
                self.resultsPanelChart.close();
            delete self.chartData;

            // overlay de la simulación
            self.wrap.simulateTrackEnd();

            self.wrap.clear();

            // eliminamos la selección en la lista de tracks
            self.track.trackList.querySelectorAll('li').forEach(function (li) {
                li.classList.remove(self.Const.Classes.SELECTEDTRACK);
            });

            self.map.trigger(self.Const.Event.CLEARTRACK);

            self.featuresToShare = [];

            //TC.Control.prototype.deactivate.call(self);

        } else {
            self.layerTracking.clearFeatures();
            self.layerGPS.clearFeatures();
        }
    };

    ctlProto.saveTrack = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var message = options.message || self.getLocaleString("geo.trk.save.alert");

            var _save = function (layer) {
                var wait;
                wait = self.getLoadingIndicator().addWait();

                var trackName = options.importedFileName || self.track.trackName.value.trim();

                var tracks = self.availableTracks;
                if (!tracks) {
                    tracks = [];
                }

                var formatted = self.wrap.formattedToStorage(layer, true, options.notReproject);

                var clean = function (wait) {
                    self.track.trackName.value = '';
                    self.track.trackName.disabled = true;
                    self.track.trackSave.disabled = true;

                    self.track.trackWPT.value = '';
                    self.track.trackWPT.disabled = true;
                    self.track.trackAdd.disabled = true;

                    self.getLoadingIndicator().removeWait(wait);

                    duringTrackingToolsPanel.call(self);
                };

                var newTrack = {
                    name: trackName,
                    data: formatted.features,
                    layout: formatted.layout,
                    crs: self.storageCRS
                };

                TC.loadJS(
                    !window.hex_md5,
                    [TC.apiLocation + TC.Consts.url.HASH],
                    function () {
                        var hash = hex_md5(JSON.stringify(newTrack));

                        var sameTrackUID = tracks.map(function (savedTrack) {
                            var clonedTrack = JSON.parse(JSON.stringify(savedTrack));
                            delete clonedTrack.uid;
                            if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                return savedTrack.uid;
                            } else {
                                const jsonFormat = new ol.format.GeoJSON();
                                // validamos si se trata de un track exportado/importado ya que se compacta la geometría
                                var features = jsonFormat.readFeatures(clonedTrack.data);
                                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                                features.forEach(function (feature) {
                                    var geom = TC.Util.explodeGeometry(TC.Util.compactGeometry(feature.getGeometry().getCoordinates(), precision));
                                    feature.getGeometry().setCoordinates(geom);
                                });

                                clonedTrack.data = jsonFormat.writeFeatures(features);

                                if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                    return savedTrack.uid;
                                } else {
                                    return null;
                                }
                            }

                        }).filter(function (uid) {
                            return uid !== null
                        });

                        const getTrackIndex = function (uid) {
                            return self.getStoredTracks().then(function () {
                                self.bindTracks();

                                var index;
                                for (var i = 0; i < self.availableTracks.length; i++) {
                                    if (self.availableTracks[i].uid === uid) {
                                        index = i;
                                        break;
                                    }
                                }

                                return index;
                            });
                        };

                        if (sameTrackUID.length === 0) {

                            newTrack.uid = Date.now() + Math.random();
                            tracks.push(newTrack);
                            tracks = _orderTracks(tracks);

                            try {
                                self.setStoredTracks(tracks).then(function () {
                                    self.map.toast(message, { duration: 3000 });

                                    clean(wait);

                                    getTrackIndex(newTrack.uid).then(function (index) {
                                        resolve(index);
                                    });
                                });

                            } catch (error) {
                                TC.alert(self.getLocaleString("geo.error.savelocalstorage") + ': ' + error.message);
                                clean(wait);
                                reject();
                            }
                        } else {
                            console.log('Ya existe un track con ese mismo hash');

                            clean(wait);

                            getTrackIndex(sameTrackUID[0]).then(function (index) {
                                resolve(index);
                            });
                        }
                    });

            };

            const createTCFeatures = function (features) {
                return new Promise(function (resolve, reject) {
                    var featurePromises = features.filter(function (feature) {
                        return !feature._wrap;
                    }).forEach(function (elm) {
                        return TC.wrap.Feature.createFeature(elm);
                    });

                    Promise.all(featurePromises).then(function (tcFeatures) {
                        resolve();
                    });
                });
            };

            if (self.importedFileName)
                _save(self.layerTrack);
            else if (self.track.trackName.value.trim().length == 0) {
                self.track.trackName.value = new Date().toLocaleString();
                _save(self.layerTracking);
            }
            else {
                _save(self.layerTracking);
            }
        });
    };

    ctlProto.addWaypoint = function () {
        var self = this;

        var waypointName = self.track.trackWPT.value.trim();
        if (!waypointName) {
            waypointName = new Date().toLocaleString();
        }

        var wait = self.getLoadingIndicator().addWait();

        duringTrackingToolsPanel.call(self);

        self.wrap.addWaypoint(self.currentPoint.position, {
            name: waypointName,
            ele: self.currentPoint.heading,
            time: new Date().getTime() // GLS: lo quito ya que hemos actualizado la función que gestiona la fechas para la exportación a GPX - espera la fecha en segundos -> / 1000 // para la exportación a GPX - espera la fecha en segundos
        });

        self.track.trackWPT.value = '';
        self.track.trackWPT.disabled = true;
        self.track.trackAdd.disabled = true;

        // cada vez que se añade un waypoint almacenamos en sessionStorage
        TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);

        self.getLoadingIndicator().removeWait(wait);
    };

    ctlProto.editTrackName = function (trackId, newName) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                if (tracks[trackId]) {
                    tracks[trackId].name = newName;

                    self.setStoredTracks(tracks);
                }
            }
        });
    };

    ctlProto.removeTrack = function (li) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                var dataId = li.dataset.id;
                if (tracks[dataId]) {
                    var uid = tracks[dataId].uid;

                    TC.confirm(self.getLocaleString("geo.trk.delete.alert"), function () {

                        const selectedTrack = self.getSelectedTrack();
                        if (selectedTrack && selectedTrack.dataset.id === dataId) {
                            self.clear(self.Const.Layers.TRACK);
                        }

                        localforage.removeItem(self.Const.LocalStorageKey.TRACKING + '#' + uid).then(function () {
                            self.getStoredTracks().then(function () {
                                self.bindTracks();
                            });
                        }).catch(function (err) {
                            console.log(err);
                        });

                    }, function () { });
                }
            }
        });
    };

    ctlProto.setSelectedTrack = function (li) {
        var self = this;

        if (!self.isActive) {
            self.activate();
        }

        self.track.trackList.querySelectorAll('li[data-id] > span').forEach(function (span) {
            span.setAttribute('title', span.textContent);
        });
        self.track.trackList.querySelectorAll('li').forEach(function (li) {
            li.classList.remove(self.Const.Classes.SELECTEDTRACK);
        });

        li.classList.add(self.Const.Classes.SELECTEDTRACK);

        li.setAttribute('title', self.getLocaleString("tr.lst.clear") + " " + li.querySelector('span').textContent);
        li.querySelector(self.Const.Selector.DRAW).setAttribute('title', li.getAttribute('title'));
    };

    ctlProto.getSelectedTrack = function () {
        var self = this;

        return self.track.trackList.querySelector('li.' + self.Const.Classes.SELECTEDTRACK);
    };

    ctlProto.clearSelectedTrack = function () {
        const self = this;

        const selected = self.getSelectedTrack();
        if (selected) {

            if (self.onResize) {
                window.removeEventListener('resize', self.onResize, false);
                self.onResize = undefined;
            }

            selected.classList.remove(self.Const.Classes.SELECTEDTRACK);
            selected.setAttribute('title', selected.textContent);
            selected.querySelector(self.Const.Selector.DRAW).setAttribute('title', selected.getAttribute('title'));
        }
    };

    ctlProto.clearSelection = function () {
        var self = this;

        self.wrap.deactivateSnapping();
        var selected = self.getSelectedTrack();
        if (selected) {
            self.clearSelectedTrack();
        }
        if (self.resultsPanelChart) {

            self.resultsPanelChart.div.removeEventListener('mouseover', self.resultsPanelChart.deactivateSnapping);
            self.resultsPanelChart.div.removeEventListener('mouseout', self.resultsPanelChart.activateSnapping);

            self.resultsPanelChart.close();
        }

        self.clear(self.Const.Layers.TRACK);
    };

    ctlProto.drawTrackingData = function (li) {
        const self = this;

        return new Promise(function (resolve, reject) {
            self.wrap.clear();

            self.getTrackingData(li).then(function (track) {
                var data = track.data;
                if (track.data)
                    self.wrap.drawTrackingData(track).then(function () {
                        var showFeatures = self.layerTrack.features;
                        if (showFeatures && showFeatures.length > 0) {

                            var coordinates = showFeatures.filter(function (feature) {
                                feature.showsPopup = false;
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return true;
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return true;
                                }
                                return false;
                            }).map(function (feature) {
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return feature.geometry[0];
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return feature.geometry;
                                }
                            })[0];

                            if (coordinates) {
                                var first = coordinates[0];
                                var last = coordinates[coordinates.length - 1];

                                if (first && !(first === last)) {
                                    self.layerTrack.addMarker(first.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon-end', anchor: [0.5, 1], notExport: true
                                    });
                                }

                                if (last) {
                                    self.layerTrack.addMarker(last.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon', anchor: [0.5, 1], notExport: true
                                    });
                                }
                            }
                        }
                        self.layerTrack.setVisibility(true);
                        resolve();
                    });
            });
        });
    };

    ctlProto.getTrackingData = function (li) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.getAvailableTracks().then(function (tracks) {
                if (tracks) {
                    const dataId = li.dataset.id;
                    if (tracks[dataId]) {
                        var track = tracks[dataId].data;

                        // GLS: tengo que transformar de 4326 al crs del mapa en el momento de pintar, porque si lo hacemos al cargar la lista
                        // y después hay cambio de crs, en el momento de pintar no sé desde qué crs debo tranformar
                        track = self.wrap.formattedFromStorage(track);

                        resolve({ data: track, layout: tracks[dataId].layout });
                    }
                } else {
                    resolve();
                }
            });
        });
    };

    ctlProto.export = function (type, li) {
        var self = this;

        return self.wrap.export(type, li);
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.wrap.showElevationMarker(d);

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.wrap.hideElevationMarker();
    }

    ctlProto.clearFileInput = function (fileInput) {
        const form = document.createElement('form');
        const parent = fileInput.parentElement;
        parent.insertBefore(form, fileInput);
        form.appendChild(fileInput);
        form.reset();
        // Desenvolvemos el input del form
        form.insertAdjacentElement('afterend', fileInput);
        parent.removeChild(form);
    };

    ctlProto.getLoadingIndicator = function () {
        var self = this;

        if (!self.loading) {
            self.loading = self.map.getControlsByClass(TC.control.LoadingIndicator);
            if (self.loading && self.loading.length > 0)
                self.loading = self.loading[0];
        }

        return self.loading;
    };

    ctlProto.onGeolocateError = function (error) {
        var self = this;

        if (navigator.geolocation) {
            if (self.currentPosition)
                navigator.geolocation.clearWatch(self.currentPosition);
            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }
        }

        if (self.currentPositionWaiting)
            self.getLoadingIndicator().removeWait(self.currentPositionWaiting);

        var errorMsg;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMsg = self.getLocaleString("geo.error.permission_denied");
                break;
            case error.POSITION_UNAVAILABLE:
                errorMsg = self.getLocaleString("geo.error.position_unavailable");
                break;
            case error.TIMEOUT:
                errorMsg = self.getLocaleString("geo.error.timeout");
                break;
            default:
                errorMsg = self.getLocaleString("geo.error.default");
                break;
        }

        self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

        if (!self.geopositionTracking && self.track) {
            self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
            self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    var _isEmpty = function (obj) {
        return !obj || obj.length === 0;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.layerTrack) {
                var features = self.layerTrack.features;

                if (features.length > 0 && self.featuresToShare && self.featuresToShare.length > 0) {
                    state.features = self.featuresToShare;
                } else {
                    const layerState = self.layerTrack.exportState({
                        features: features
                    });

                    state.features = layerState.features;
                }

                state.id = self.id;
                const selectedTrack = self.getSelectedTrack();
                if (selectedTrack) {
                    state.trackName = selectedTrack.querySelector('span').innerHTML;
                }
                return state;
            }
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            if (state.features && state.features.length) {
                self.enable();

                if (state.features.length > 0) {
                    const promises = new Array(state.features.length);
                    state.features.forEach(function (f, idx) {
                        const featureOptions = { data: f.data, id: f.id, showsPopup: f.showsPopup };
                        var addFn;
                        var geom = TC.Util.explodeGeometry(f.geom);
                        switch (f.type) {
                            case TC.Consts.geom.POLYLINE:
                                promises[idx] = new TC.feature.Polyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MULTIPOLYLINE:
                                promises[idx] = new TC.feature.MultiPolyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MARKER:
                                promises[idx] = new TC.feature.Marker(geom, featureOptions);
                                break;
                            case TC.Consts.geom.POINT:
                                promises[idx] = new TC.feature.Point(geom, featureOptions);
                                break;
                        }
                    });

                    Promise.all(promises).then(function (tcFeatures) {
                        var options = { features: tcFeatures, fileName: state.trackName, notReproject: true, isShared: true };
                        if (!self.availableTracks) {
                            self.getStoredTracks().then(function () {
                                self.importTrack(options);
                            });
                        } else {
                            self.importTrack(options);
                        }
                    });
                }
            }
        }
    };
})();
TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

(function () {
    TC.control.GeometryFeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.GeometryFeatureInfo(self);
        self.lineColor = !self.options.lineColor ? "#cc0000" : self.options.lineColor;
        self._isDrawing = false;
        self._isSearching = false;
        self._drawToken = false;
    };

    TC.inherit(TC.control.GeometryFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.GeometryFeatureInfo.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        self.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
            self.wrap.cancelDraw();
        });

        return result;
    };

    ctlProto.callback = function (coords, xy) {
        var self = this;
        if (self._drawToken) {
            return;
        }
        self.closeResults();
        //self.filterLayer.clearFeatures();
        var visibleLayers = false;
        for (var i = 0; i < self.map.workLayers.length; i++) {
            var layer = self.map.workLayers[i];
            if (layer.type === TC.Consts.layerType.WMS) {
                if (layer.getVisibility() && layer.names.length > 0) {
                    visibleLayers = true;
                    break;
                }
            }
        }
        if (visibleLayers) {
            self.closeResults();
            self.wrap.beginDraw({
                geometryType: self.geometryType,
                xy: coords,
                layer: self.filterLayer,
                callback: function (feature) {
                    self.wrap.getFeaturesByGeometry(feature);
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        var self = this;

        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);

        if (self.filterFeature) {
            var services = options.services;

            // Eliminamos capas sin resultados a no ser que tenga un error
            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                if (service.hasLimits) {
                    delete service.layers;
                    service.hasLimits = service.hasLimits;
                }
                else {
                    for (var j = 0; j < service.layers.length; j++) {
                        if (!service.layers[j].features.length) {
                            service.layers.splice(j, 1);
                            j = j - 1;
                        }
                    }
                    if (!service.layers.length) {
                        services.splice(i, 1);
                        i = i - 1;
                    }
                }

            }
            self.renderData(options, function () {
                if (services.length) {
                    self.insertLinks();
                }
                self.displayResults();
            });
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

(function () {

    TC.control.LayerCatalog = function () {
        var self = this;

        self.layers = [];
        self.searchInit = false;

        TC.control.ProjectionSelector.apply(self, arguments);

        self._selectors = {
            LAYER_ROOT: 'div.' + self.CLASS + '-tree > ul.' + self.CLASS + '-branch > li.' + self.CLASS + '-node'
        };

        if (!TC.Consts.classes.SELECTABLE) {
            TC.Consts.classes.SELECTABLE = 'tc-selectable';
        }
        if (!TC.Consts.classes.INCOMPATIBLE) {
            TC.Consts.classes.INCOMPATIBLE = 'tc-incompatible';
        }
        if (!TC.Consts.classes.ACTIVE) {
            TC.Consts.classes.ACTIVE = 'tc-active';
        }
    };

    TC.inherit(TC.control.LayerCatalog, TC.control.ProjectionSelector);

    var ctlProto = TC.control.LayerCatalog.prototype;

    ctlProto.CLASS = 'tc-ctl-lcat';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/LayerCatalog.html";
        ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/LayerCatalogBranch.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LayerCatalogNode.html";
        ctlProto.template[ctlProto.CLASS + '-info'] = TC.apiLocation + "TC/templates/LayerCatalogInfo.html";
        ctlProto.template[ctlProto.CLASS + '-results'] = TC.apiLocation + "TC/templates/LayerCatalogResults.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/LayerCatalogDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "availableLayers" }).x(ctx.get(["enableSearch"], false), ctx, { "block": body_1 }, {}).w("</h2><div class=\"tc-ctl-lcat-search tc-hidden tc-collapsed\"><div class=\"tc-group\"><input type=\"search\" class=\"tc-ctl-lcat-input tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "textToSearchInLayers" }).w("\"></div><ul></ul></div><div class=\"tc-ctl-lcat-tree\">").x(ctx.get(["layerTrees"], false), ctx, { "else": body_4, "block": body_8 }, {}).w("</div><div class=\"tc-ctl-lcat-info tc-hidden\">").p("tc-ctl-lcat-info", ctx, ctx.rebase(ctx.getPath(true, [])), {}).w("</div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.x(ctx.get(["layerTrees"], false), ctx, { "block": body_2 }, {}).x(ctx.get(["layers"], false), ctx, { "block": body_3 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<button class=\"tc-ctl-lcat-btn-search\" title=\"").h("i18n", ctx, {}, { "$key": "searchLayersByText" }).w("\"></button>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<button class=\"tc-ctl-lcat-btn-search\" title=\"").h("i18n", ctx, {}, { "$key": "searchLayersByText" }).w("\"></button>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.x(ctx.get(["layers"], false), ctx, { "else": body_5, "block": body_6 }, {}); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<div class=\"tc-ctl tc-ctl-lcat-loading\"><span>").h("i18n", ctx, {}, { "$key": "loadingLayerTree" }).w("...</span></div>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<ul class=\"tc-ctl-lcat-branch\">").s(ctx.get(["layers"], false), ctx, { "block": body_7 }, {}).w("</ul>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w("<li data-layer-id=\"").f(ctx.get(["id"], false), ctx, "h").w("\" title=\"").h("i18n", ctx, {}, { "$key": "loadingLayers" }).w("\" class=\"tc-ctl-lcat-loading-node\"> ").f(ctx.get(["title"], false), ctx, "h").w("</li>"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<ul class=\"tc-ctl-lcat-branch\">").s(ctx.get(["layerTrees"], false), ctx, { "block": body_9 }, {}).w("</ul>"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.p("tc-ctl-lcat-branch", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_9.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-branch'] = function () { dust.register(ctlProto.CLASS + '-branch', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><button class=\"tc-ctl-lcat-collapse-btn\"></button><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-lcat-branch tc-collapsed\">").s(ctx.get(["children"], false), ctx, { "block": body_3 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-ctl-lcat-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-collapsed\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.p("tc-ctl-lcat-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["isVisible"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\">").x(ctx.get(["children"], false), ctx, { "block": body_4 }, {}).w("<span data-tooltip=\"").x(ctx.get(["name"], false), ctx, { "block": body_5 }, {}).w("\">").f(ctx.get(["title"], false), ctx, "h").w("</span>").x(ctx.get(["name"], false), ctx, { "block": body_6 }, {}).w("<ul class=\"tc-ctl-lcat-branch tc-collapsed\">").s(ctx.get(["children"], false), ctx, { "block": body_7 }, {}).w("</ul></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-ctl-lcat-leaf\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-collapsed\""); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<button class=\"tc-ctl-lcat-collapse-btn\"></button>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "clickToAddToMap" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<button title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\" class=\"tc-ctl-lcat-btn-info\"></button>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.p("tc-ctl-lcat-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_7.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-info'] = function () { dust.register(ctlProto.CLASS + '-info', body_0); function body_0(chk, ctx) { return chk.w("<a class=\"tc-ctl-lcat-info-close\"></a><h2>").h("i18n", ctx, {}, { "$key": "layerInfo" }).w("</h2><h3 class=\"tc-ctl-lcat-title\">").f(ctx.get(["title"], false), ctx, "h").w("</h3>").x(ctx.get(["abstract"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["metadata"], false), ctx, { "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-abstract\"><h4>").h("i18n", ctx, {}, { "$key": "abstract" }).w("</h4><div><pre>").f(ctx.get(["abstract"], false), ctx, "h", ["s"]).w("</pre></div></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-metadata\"><h4>").h("i18n", ctx, {}, { "$key": "metadata" }).w("</h4><ul>").s(ctx.get(["metadata"], false), ctx, { "block": body_3 }, {}).w("</ul></div>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<li><a href=\"").f(ctx.get(["url"], false), ctx, "h", ["s"]).w("\" type=\"").f(ctx.get(["format"], false), ctx, "h").w("\" title=\"").f(ctx.get(["formatDescription"], false), ctx, "h").w("\" target=\"_blank\">").f(ctx.get(["formatDescription"], false), ctx, "h", ["s"]).w("</a></li>"); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-results'] = function () { dust.register(ctlProto.CLASS + '-results', body_0); function body_0(chk, ctx) { return chk.s(ctx.get(["servicesFound"], false), ctx, { "else": body_1, "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li class=\"tc-ctl-lcat-no-results\"><h5>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</h5></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.h("gt", ctx, { "block": body_3 }, { "key": ctx.get(["servicesLooked"], false), "value": 1 }).s(ctx.get(["founds"], false), ctx, { "block": body_5 }, {}).h("gt", ctx, { "block": body_9 }, { "key": ctx.get(["servicesLooked"], false), "value": 1 }); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<li class=\"tc-ctl-lcat-search-group ").x(ctx.getPath(false, ["service", "isCollapsed"]), ctx, { "block": body_4 }, {}).w("\" data-service-index=\"").f(ctx.getPath(false, ["service", "index"]), ctx, "h").w("\"><h5>").f(ctx.getPath(false, ["service", "title"]), ctx, "h").w("</h5><ul>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("tc-collapsed"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<li data-layer-name=\"").f(ctx.get(["Name"], false), ctx, "h").w("\" ").x(ctx.get(["alreadyAdded"], false), ctx, { "block": body_6 }, {}).w("><h5 class=\"tc-selectable\"").x(ctx.get(["alreadyAdded"], false), ctx, { "else": body_7, "block": body_8 }, {}).w(">").f(ctx.get(["Title"], false), ctx, "h").w("</h5><button class=\"tc-ctl-lcat-search-btn-info\" title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\"></button></li>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w(" class=\"tc-checked\""); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(" data-tooltip=\"").h("i18n", ctx, {}, { "$key": "clickToAddToMap" }).w("\""); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w(" data-tooltip=\"").h("i18n", ctx, {}, { "$key": "layerAlreadyAdded" }).w("\""); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("</ul></li>"); } body_9.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-crs-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "wmsLayerNotCompatible.instructions|h" }).w("</p><ul class=\"tc-ctl-lcat-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const showProjectionChangeDialog = function (ctl, layer) {
        ctl.showProjectionChangeDialog({
            layer: layer,
            closeCallback: function () {
                ctl.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.LOADING);
                    node.querySelector('span').dataset.tooltip = ctl.getLocaleString('clickToAddToMap');
                });
            }
        });
    };

    var SEARCH_MIN_LENGTH = 3;

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        const load = function (resolve, reject) {
            if (Array.isArray(self.options.layers)) {
                for (var i = 0; i < self.options.layers.length; i++) {
                    var layer = self.options.layers[i];
                    if (!layer.type || layer.type === TC.Consts.layerType.WMS) {
                        if (!layer.id) {
                            layer.id = TC.getUID();
                        }                        
                        if (TC.Util.isPlainObject(layer)) {
                            layer = new TC.layer.Raster(layer);
                        }                        
                        self.layers.push(layer);
                    }
                }
                self.render(function () {
                    resolve();
                });
            }
            else {
                resolve();
            }
        };

        self._readyPromise = new Promise(function (resolve, reject) {
            const waitLoad = function (e) {
                if (e.layer === map.baseLayer) {
                    load(resolve, reject);
                    map.off(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            };

            map.loaded(function () {
                if (!map.baseLayer.state || map.baseLayer.state === TC.Layer.state.IDLE) {
                    load(resolve, reject);
                }
                else {
                    map.on(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            });
        });

        const findResultNodes = function (layer) {
            const result = [];
            if (!layer.isBase) {
                var url = layer.options.url;
                if (self.list) {
                    self.list.querySelectorAll('li').forEach(function (li) {
                        const lyr = self.getLayer(li.dataset.layerId);
                        if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                            for (var i = 0; i < layer.names.length; i++) {
                                if (li.dataset.layerName === layer.names[i]) {
                                    result.push(li);
                                    break;
                                }
                            }
                        }
                    });
                }
            }
            return result;
        };

        /**
         * Marca todas las capas del TOC como añadidas excepto la que se está borrando que se recibe como parámetro.
         */
        const _markWorkLayersAsAdded = function (layerRemoved) {
            var wlCtrl = self.map.getControlsByClass(TC.control.WorkLayerManager)[0];
            if (wlCtrl) {
                var layers = wlCtrl.layers;

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];

                    if (layer !== layerRemoved) {
                        self.getLayerNodes(layer).forEach(function (node) {
                            node.classList.add(TC.Consts.classes.CHECKED);
                            node.querySelector('span').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                        });
                    }
                }
            }
        };

        var clickToAddText = self.getLocaleString('clickToAddToMap');

        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' + TC.Consts.event.BEFOREUPDATEPARAMS, function (e) {
                self.getLayerNodes(e.layer).forEach(function (node) {
                    node.classList.add(TC.Consts.classes.LOADING);
                    delete node.querySelector('span').dataset.tooltip;
                });
            })
            .on(TC.Consts.event.LAYERADD + ' ' + TC.Consts.event.UPDATEPARAMS, function (e) {
                const layer = e.layer;
                if (!layer.isBase && layer.type === TC.Consts.layerType.WMS) {
                    self.loaded().then(function () { // Esperamos a que cargue primero las capas de la configuración

                        if (self.getLayerRootNode(layer)) {
                            updateControl.call(self, layer);
                        }
                        else {
                            // la capa no está renderizada, pero podría estar en proceso, comprobamos que no está en la lista de capas del control
                            var layerAlreadyAdded = false;
                            for (var i = 0, len = self.layers.length; i < len; i++) {
                                var lyr = self.layers[i];
                                if (lyr.type === layer.type && lyr.options.url === layer.options.url) {
                                    layerAlreadyAdded = true;
                                    break;
                                }
                            }

                            // 12/03/2019 GLS la capa forma parte de los servicios configurados pero el nodo aún no se ha cargado, la guardamos
                            if (layerAlreadyAdded) {
                                if (!self.layersToSetChecked) {
                                    self.layersToSetChecked = [];
                                }

                                self.layersToSetChecked.push(layer);
                            } else {
                                self.addLayer(new TC.layer.Raster({
                                    url: layer.options.url,
                                    type: layer.type,
                                    layerNames: [],
                                    title: layer.title || layer.wrap.getServiceTitle(),
                                    hideTitle: true,
                                    hideTree: false
                                })).then(function () {
                                    updateControl.call(self, layer);
                                });
                            }
                        }
                    });
                }
            })
            .on(TC.Consts.event.LAYERERROR, function (e) {
                const reason = e.reason;
                if (reason) {
                    TC.alert(self.getLocaleString(reason, { url: e.layer.url }));
                }
                self.getLayerNodes(e.layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.LOADING);
                });
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const layer = e.layer;
                self.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.querySelector('span').dataset.tooltip = clickToAddText;
                });
                findResultNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.querySelector('h5').dataset.tooltip = clickToAddText;
                });

                //Marcamos como añadidas aquellas capas que estén en el control de capas cargadas. Esto previene que si borramos una capa padre, todas
                //sus hijas aparezcan como no añadidas, a pesar que que alguna de ellas haya sido añadida previamente de manera individual
                _markWorkLayersAsAdded(layer);

                //refresh del searchList            
                _refreshResultList.call(self);
            })
            .on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
                if (e && e.layer) {
                    self.addLayer(e.layer);
                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                }
            })
            .on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                self.update();
            });

        return result;
    };

    const onCollapseButtonClick = function (e) {
        e.target.blur();
        e.stopPropagation();
        const li = e.target.parentElement;
        if (li.tagName === 'LI' && !li.classList.contains(self.CLASS + '-leaf')) {
            li.classList.toggle(TC.Consts.classes.COLLAPSED);
            const ul = li.querySelector('ul');
            ul.classList.toggle(TC.Consts.classes.COLLAPSED);
        }
    };

    const onSpanClick = function (e, ctl) {
        const li = e.target.parentNode;
        if (!li.classList.contains(TC.Consts.classes.LOADING) && !li.classList.contains(TC.Consts.classes.CHECKED)) {
            e.preventDefault;

            var layerName = li.dataset.layerName;
            layerName = (layerName !== undefined) ? layerName.toString() : '';
            var layer;
            for (var i = 0, len = ctl._roots.length; i < len; i++) {
                const root = ctl._roots[i];
                if (root.contains(li)) {
                    layer = ctl.getLayer(root.dataset.layerId);
                    break;
                }
            }
            if (!layer) {
                layer = ctl.getLayer(li.dataset.layerId);
            }
            if (layer && layerName) {
                var redrawTime = 1;

                if (/iPad/i.test(navigator.userAgent))
                    redrawTime = 10;
                else if (TC.Util.detectFirefox())
                    redrawTime = 250;

                if (!layer.title) {
                    layer.title = layer.getTree().title;
                }

                li.classList.add(TC.Consts.classes.LOADING);
                li.querySelector('span').dataset.tooltip = '';

                const reDraw = function (element) {
                    return new Promise(function (resolve, reject) {
                        setTimeout(function () {
                            element.offsetHeight = element.offsetHeight;
                            element.offsetWidth = element.offsetWidth;

                            resolve();
                        }, redrawTime);
                    });
                };

                reDraw(li).then(function () {
                    ctl.addLayerToMap(layer, layerName);
                });
                e.stopPropagation();
            }
        }
    };

    const createSearchAutocomplete = function () {
        const self = this;

        self.textInput = self.div.querySelector("." + self.CLASS + "-input");
        self.list = self.div.querySelector("." + self.CLASS + "-search ul");
        // Clear results list when x button is pressed in the search input
        self.textInput.addEventListener('mouseup', function (e) {
            var oldValue = self.textInput.value;

            if (oldValue === '') {
                return;
            }

            // When this event is fired after clicking on the clear button
            // the value is not cleared yet. We have to wait for it.
            setTimeout(function () {
                var newValue = self.textInput.value;

                if (newValue === '') {
                    self.list.innerHTML = '';
                }
            }, 1);
        });

        var layerCheckedList = [];
        //Definir el autocomplete del buscador de capas por texto
        TC._search = TC._search || {};
        TC._search.retryTimeout = null;

                    TC.loadJS(
                        !TC.UI || !TC.UI.autocomplete,
                        [TC.apiLocation + 'TC/ui/autocomplete.js'],
                        function () {
                            TC.UI.autocomplete.call(self.textInput, {
                                link: '#',
                                target: self.list,
                                minLength: 0,
                                source: function (text, callback) {
                                    //lista de capas marcadas
                                    layerCheckedList = [];
                                    self._roots.forEach(function (root) {
                                        root.querySelectorAll("li." + TC.Consts.classes.CHECKED).forEach(function (item) {
                                            layerCheckedList.push(item.dataset.layerName);
                                        });
                                    });

                        //con texto vacío, limpiar  y ocultar la lista de resultados
                        text = text.trim();
                        if (text.length < SEARCH_MIN_LENGTH) {
                            self.list.innerHTML = '';
                        }
                        else if (text.length >= SEARCH_MIN_LENGTH) {
                            if (TC._search.retryTimeout)
                                clearTimeout(TC._search.retryTimeout);
                            TC._search.retryTimeout = setTimeout(function () {
                                var results = [];
                                for (var index = 0; index < self.sourceLayers.length; index++) {
                                    var _founds = self.sourceLayers[index].searchSubLayers(text);
                                    if (_founds.length) {
                                        results.push({
                                            service: {
                                                index: index,
                                                title: self.sourceLayers[index].title || self.sourceLayers[index].id
                                            },
                                            founds: _founds
                                        });
                                    }
                                }
                                callback({ servicesFound: results, servicesLooked: self.sourceLayers.length });
                            }, TC._search.interval);
                        }
                    },
                    callback: function (e) {
                        self.textInput.value = e.target.text || e.target.innerText;
                        TC._search.lastPattern = self.textInput.value;
                        self.goToResult(unescape(e.target.hash).substring(1));
                        TC.UI.autocomplete.call(self.textInput, 'clear');
                    },
                    buildHTML: function (data) {
                        //si hay resultados, mostramos la lista
                        if (data.results && data.results.servicesFound.length > 0) {
                            var workLayers = self.map.getLayerTree().workLayers;
                            for (var k = 0; k < data.results.servicesFound.length; k++) {
                                var founds = data.results.servicesFound[k].founds;
                                for (var j = 0; j < founds.length; j++) {
                                    delete founds[j].alreadyAdded;
                                    for (var i = 0; i < workLayers.length; i++) {
                                        //if (workLayers[i].title == data.results[j].Title ) {
                                        if (layerCheckedList.indexOf(founds[j].Name) >= 0) {
                                            founds[j].alreadyAdded = true;
                                            break;
                                        }
                                    }
                                    //Si la capa no tiene Name, no se puede añadir al TOC
                                    if (!founds[j].Name) {
                                        founds.splice(j, 1);
                                        j--;
                                    }
                                }
                                if (!data.results.servicesFound[k].founds.length) {
                                    data.results.servicesFound.splice(k, 1);
                                    continue;
                                }
                                //si estaba collapsado mantenemos el estado
                                if (self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k]) {
                                    data.results.servicesFound[k].service.isCollapsed = self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k].classList.contains(TC.Consts.classes.COLLAPSED);
                                }
                            }
                        }
                        var ret = '';
                        dust.render(self.CLASS + '-results', data.results, function (err, out) {
                            ret = out;
                        });
                        return ret;
                    }
                });
            });


        if (!self.searchInit) {
            //botón de la lupa para alternar entre búsqueda y árbol
            self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2 button', function (e) {
                const wasCollapsed = self.div.classList.contains(TC.Consts.classes.COLLAPSED);
                self.div.classList.remove(TC.Consts.classes.COLLAPSED);

                const searchPane = self.div.querySelector('.' + self.CLASS + '-search');
                const treePane = self.div.querySelector('.' + self.CLASS + '-tree');
                const infoPane = self.div.querySelector('.' + self.CLASS + '-info');

                const searchPaneMustShow = !!(searchPane.classList.contains(TC.Consts.classes.HIDDEN) || wasCollapsed);
                searchPane.classList.toggle(TC.Consts.classes.HIDDEN, !searchPaneMustShow);
                treePane.classList.toggle(TC.Consts.classes.HIDDEN, searchPaneMustShow);
                e.target.classList.toggle(self.CLASS + '-btn-tree', searchPaneMustShow);
                e.target.classList.toggle(self.CLASS + '-btn-search', !searchPaneMustShow);
                if (searchPaneMustShow) {
                    self.textInput.focus();
                    e.target.setAttribute('title', self.getLocaleString('viewAvailableLayersTree'));

                    //Si no hay resultados resaltados en el buscador, ocultamos el panel de info
                    const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-search li button.tc-checked').length;
                    if (selectedCount === 0) {
                        infoPane.classList.add(TC.Consts.classes.HIDDEN);
                    }
                }
                else {
                    e.target.setAttribute('title', self.getLocaleString('searchLayersByText'));

                    //Si hay resaltados en el árbol, mostramos el panel de info
                    const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-tree li button.tc-checked').length;
                    if (selectedCount > 0) {
                        infoPane.classList.remove(TC.Consts.classes.HIDDEN);
                    }
                }
            }));


            //evento de expandir nodo de info
            //self._$div.off("click", ".tc-ctl-lcat-search button");                        
            self.div.addEventListener("click", TC.EventTarget.listenerBySelector("." + self.CLASS + "-search button." + self.CLASS + "-search-btn-info", function (evt) {
                evt.stopPropagation();
                const target = evt.target;
                if (!target.classList.contains(TC.Consts.classes.CHECKED)) {
                    const li = target.parentElement;
                    var parent = li;
                    do {
                        parent = parent.parentElement;
                    }
                    while (parent && parent.tagName !== 'LI');
                    self.showLayerInfo(self.layers.length > 1 ? self.layers[parent.dataset.serviceIndex] : self.layers[0], li.dataset.layerName);
                    target.classList.add(TC.Consts.classes.CHECKED);

                } else {
                    target.classList.remove(TC.Consts.classes.CHECKED);
                    self.hideLayerInfo();
                }
            }));

                        //click en un resultado - añadir capa
            const searchListElementSelector = '.' + self.CLASS + '-search li';
            self.div.addEventListener('click', TC.EventTarget.listenerBySelector(searchListElementSelector, function (evt) {
                evt.stopPropagation();
                var li = evt.target;
                while (li && !li.matches(searchListElementSelector)) {
                    li = li.parentElement;
                }
                if (li.classList.contains(self.CLASS + '-no-results')) {
                    return; //si clicko en el li de "no hay resultados" rompo el ciclo de ejecución
                }
                if (li.classList.contains(self.CLASS + '-search-group')) {
                    li.classList.toggle(TC.Consts.classes.COLLAPSED);
                    return;
                }
                var layerName = li.dataset.layerName;
                if (!layerName) {
                    return;
                }
                layerName = layerName.toString();

                if (layerName.trim().length === 0) {
                    return;
                }

                //si la capa ya ha sido anteriormente, no la añadimos y mostramos un mensaje
                if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                    return;
                } else {
                    var liParent = li;
                    do {
                        liParent = liParent.parentElement;
                    }
                    while (liParent && !liParent.matches('li.' + self.CLASS + '-search-group'));

                    const layerIdx = !liParent ? 0 : liParent.dataset.serviceIndex;
                    const url = self.layers[layerIdx].options.url;
                    const title = self.layers[layerIdx].title;

                    const layer = new TC.layer.Raster({
                        id: self.getUID(),
                        url: url,
                        title: title,
                        hideTitle: self.layers[layerIdx].hideTitle || self.layers[layerIdx].options.hideTitle,
                        hideTree: false,
                        layerNames: [layerName]
                    });
                    if (layer.isCompatible(self.map.crs)) {
                        self.map.addLayer(layer, function (layer) {
                            li.dataset.layerId = layer.id;
                            layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                                var layer = this.parent;
                                if (event.error.code === 401 || event.error.code === 403)
                                    layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                                layer.map.removeLayer(layer);
                            });
                        });
                        //marcamos el resultado como añadido
                        li.classList.add(TC.Consts.classes.CHECKED);
                        li.querySelector('h5').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                    }
                    else {
                        showProjectionChangeDialog(self, layer);
                    }
                }
            }));

            self.searchInit = true;
        }
    };

    const getLayerTree = function (layer) {
        var result = layer.getTree();
        var makeNodeVisible = function makeNodeVisible(node) {
            var result = false;
            var childrenVisible = false;
            for (var i = 0; i < node.children.length; i++) {
                if (makeNodeVisible(node.children[i])) {
                    childrenVisible = true;
                }
            }
            if (node.hasOwnProperty('isVisible')) {
                node.isVisible = (!layer.names || !layer.names.length) || childrenVisible || node.isVisible;
            }
            return node.isVisible;
        };
        makeNodeVisible(result);
        return result;
    };

    const _refreshResultList = function () {
        const self = this;

        if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("keyup", false, true);
            if (self.textInput) {
                self.textInput.dispatchEvent(evt);
            }
        }
        else {
            if (self.textInput) {
                self.textInput.fireEvent("keyup");
            }
        }
    };

    const updateControl = function (layer) {
        const self = this;

        self.getLayerNodes(layer).forEach(function (node) {
            node.classList.remove(TC.Consts.classes.LOADING);
            node.classList.add(TC.Consts.classes.CHECKED);
            node.querySelector('span').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
        });
        _refreshResultList.call(self);
    };

    const setCheckedLayersOnNode = function () {
        const self = this;

        if (self.layersToSetChecked && self.layersToSetChecked.length > 0) {
            self.layersToSetChecked.forEach(function (layer, index, array) {
                if (self.getLayerRootNode(layer)) {
                    updateControl.call(self, layer);

                    array.splice(index, 1);
                }
            });
        }
    };

    const addLogicToNode = function (node, layer) {
        const self = this;

        node.querySelectorAll('li > button.' + self.CLASS + '-collapse-btn').forEach(function (btn) {
            btn.addEventListener('click', onCollapseButtonClick);
        });

        node.querySelectorAll('span').forEach(function (span) {
            span.addEventListener('click', function (e) {
                onSpanClick(e, self);
            });
        });

        self._roots = self.div.querySelectorAll(self._selectors.LAYER_ROOT);                
        
        node.dataset.layerId = layer.id;

        var formatDescriptions = {};
        node.querySelectorAll('.' + self.CLASS + '-btn-info').forEach(function (a) {
            const span = a.parentElement.querySelector('span');
            const name = a.parentElement.dataset.layerName;
            if (name) {
                span.classList.add(TC.Consts.classes.SELECTABLE);
                var info = layer.wrap.getInfo(name);
                if (!info.hasOwnProperty('abstract') && !info.hasOwnProperty('legend') && !info.hasOwnProperty('metadata')) {
                    a.parentElement.removeChild(a);
                }
                else {                    
                    a.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.stopPropagation();
                        const elm = this;
                        if (elm.classList.toggle(TC.Consts.classes.CHECKED)) {
                            self.showLayerInfo(layer, name);
                        } else {
                            self.hideLayerInfo();
                        }
                    });
                }
                if (layer.compatibleLayers && layer.compatibleLayers.indexOf(name) < 0) {
                    span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                    span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                    //console.log("capa " + name + " incompatible");
                }
                if (self.map) {
                    for (var j = 0, len = self.map.workLayers.length; j < len; j++) {
                        var wl = self.map.workLayers[j];
                        if (wl.type === TC.Consts.layerType.WMS && wl.url === layer.url && wl.names.length === 1 && wl.names[0] === name) {
                            span.parentElement.classList.add(TC.Consts.classes.CHECKED);
                            span.dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                        }
                    }
                }
            }
            else {
                span.dataset.tooltip = '';
                a.parentElement.removeChild(a);
            }
        });        

        setCheckedLayersOnNode.call(self);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        });
    };

    ctlProto.renderBranch = function (layer, callback, promiseRenderResolve) {
        const self = this;

        layer.getCapabilitiesPromise()
            .then(function (result) {

                self.sourceLayers.push(layer);

                self.getRenderedHtml(self.CLASS + '-branch', getLayerTree(this), function (html) {
                    var template = document.createElement('template');
                    template.innerHTML = html;

                    var newChild = template.content ? template.content.firstChild : template.firstChild;
                    var oldChild = self.div.querySelector('.' + self.CLASS + '-branch').querySelector('li.' + self.CLASS + '-loading-node[data-layer-id="' + this.id + '"]');

                    if (oldChild) {
                        self.div.querySelector('.' + self.CLASS + '-branch').replaceChild(newChild, oldChild);
                    } else {
                        self.div.querySelector('.' + self.CLASS + '-branch').appendChild(newChild);
                    }

                    addLogicToNode.call(self, newChild, this);

                    if (self.div.querySelector('.' + self.CLASS + '-branch').childElementCount === 1) {
                        promiseRenderResolve();
                    }

                    if (TC.Util.isFunction(callback)) {
                        // pasamos el callback el item 
                        callback(self.sourceLayers[self.sourceLayers.map(function (l) { return l.id }).indexOf(this.id)]);
                    }

                }.bind(this));

            }.bind(layer))
            .catch(function (error) {
                var index = self.layers.map(function (l) { return l.id }).indexOf(this.id);
                self.layers.splice(index, 1);

                var errorMessage = self.getLocaleString("lyrCtlg.errorLoadingNode", { serviceName: this.title });
                var liError = self.div.querySelector('.' + self.CLASS + '-branch').querySelector('li.' + self.CLASS + '-loading-node[data-layer-id="' + this.id + '"]');
                liError.classList.add('error');
                liError.setAttribute('title', errorMessage);

                self.map.toast(errorMessage, { type: TC.Consts.msgType.ERROR });

            }.bind(layer));
    };

    ctlProto.render = function (callback) {
        const self = this;

        self.sourceLayers = [];

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            if (self.layers.length === 0) {
                self.renderData({ layerTrees: [], enableSearch: false }, function () {

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }

                    resolve();
                });
            } else {
                self.renderData({ layers: self.layers, enableSearch: true }, function () {

                    createSearchAutocomplete.call(self);

                    self.layers.forEach(function (layer) {
                        self.renderBranch(layer, callback, resolve);
                    });
                });
            }
        }));
    };

    ctlProto.getLayerRootNode = function (layer) {
        const self = this;
        var result = null;
        if (!layer.isBase) {
            var url = layer.options.url;
            if (self._roots) {
                self._roots.forEach(function (li) {
                    const lyr = self.getLayer(li.dataset.layerId);
                    if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                        result = li;
                    }
                });
            }
        }
        return result;
    };

    ctlProto.getLayerNodes = function (layer) {
        const self = this;
        const result = [];
        const rootNode = self.getLayerRootNode(layer);
        if (rootNode) {
            for (var i = 0; i < layer.names.length; i++) {
                const liLayer = rootNode.querySelector('li[data-layer-name="' + layer.names[i] + '"]');
                if (!liLayer) {
                    continue;
                }
                result[result.length] = liLayer;
                liLayer.querySelectorAll('li').forEach(function (li) {
                    result[result.length] = li;
                });
            }
        }
        return result;
    };

    ctlProto.showLayerInfo = function (layer, name) {
        const self = this;
        var result = null;

        var info = self.div.querySelector('.' + self.CLASS + '-info');

        const toggleInfo = function (layerName, infoObj) {
            var result = false;
            //if (lName !== undefined && lName.toString() === layerName) {
            //    info.dataset.layerName = '';
            //    $info.removeClass(TC.Consts.classes.HIDDEN);
            //}
            //else {
            if (infoObj) {
                result = true;
                info.dataset.layerName = layerName;
                info.classList.remove(TC.Consts.classes.HIDDEN);
                dust.render(self.CLASS + '-info', infoObj, function (err, out) {
                    info.innerHTML = out;
                    if (err) {
                        TC.error(err);
                    }
                    info.querySelector('.' + self.CLASS + '-info-close').addEventListener(TC.Consts.event.CLICK, function () {
                        self.hideLayerInfo();
                    });
                });
            }
            //}
            return result;
        };

        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });

        const formatDescriptions = {};
        for (var i = 0, ii = self._roots.length; i < ii; i++) {
            const root = self._roots[i];
            if (root.dataset.layerId === layer.id) {
                const as = root.querySelectorAll('.' + self.CLASS + '-btn-info');
                for (var j = 0, jj = as.length; j < jj; j++) {
                    const a = as[j];
                    var n = a.parentElement.dataset.layerName;
                    if (n === name) {
                        const info = layer.wrap.getInfo(name);
                        if (info.metadata) {
                            info.metadata.forEach(function (md) {
                                md.formatDescription = formatDescriptions[md.format] =
                                    formatDescriptions[md.format] ||
                                    self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) ||
                                    self.getLocaleString('viewMetadata');
                            });
                        }
                        const infoBtn = self.div.querySelector('li [data-layer-name="' + n + '"] > button.' + self.CLASS + '-btn-info');
                        infoBtn.classList.toggle(TC.Consts.classes.CHECKED, toggleInfo(n, info));
                        result = info;
                        break;
                    }
                }
                break;
            }
        }

        return result;
    };

    ctlProto.update = function () {
        const self = this;
        self.sourceLayers.forEach(function (layer) {
            layer.getCapabilitiesPromise().then(function () {
                layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);

                const rootNode = self.getLayerRootNode(layer);
                if (rootNode) {
                    rootNode
                        .querySelectorAll('li[data-layer-name]')
                        .forEach(function (li) {
                            const name = li.dataset.layerName;
                            const span = li.querySelector('span.' + TC.Consts.classes.SELECTABLE);
                            if (layer.compatibleLayers.indexOf(name) < 0) {
                                span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                                span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                            }
                            else {
                                span.classList.remove(TC.Consts.classes.INCOMPATIBLE)
                                span.removeAttribute('title');
                            }
                        });
                }
            });
        });
    };

    ctlProto.hideLayerInfo = function () {
        var self = this;
        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });
        self.div.querySelector('.' + self.CLASS + '-info').classList.add(TC.Consts.classes.HIDDEN);
    };

    ctlProto.addLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var fromLayerCatalog = [];

            if (self.options.layers && self.options.layers.length) {
                fromLayerCatalog = self.options.layers.filter(function (l) {
                    var getMap = TC.Util.reqGetMapOnCapabilities(l.url);
                    return getMap && getMap.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });
            }

            if (fromLayerCatalog.length == 0)
                fromLayerCatalog = self.layers.filter(function (l) {
                    return l.url.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });

            if (fromLayerCatalog.length == 0) {
                self.layers.push(layer);
                layer.getCapabilitiesPromise().then(function () {
                    layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);
                    layer.title = layer.title || layer.wrap.getServiceTitle();
                    self.renderBranch(layer, function () {
                        resolve(); //ver linea 55 y por ahí
                    });
                });
            } else { resolve(); }
        });
    };

    ctlProto.getLayer = function (id) {
        const self = this;
        for (var i = 0, len = self.layers.length; i < len; i++) {
            const layer = self.layers[i];
            if (layer.id === id) {
                // 10/04/2019 GLS: validamos si es una capa que viene de configuración o es un WMS externo o por estado 
                // para decidir si mostramos el título del servicio o no
                var configLayer = self.options.layers.filter(l => l.id === id);

                if (configLayer.length > 0) {
                    layer.hideTitle = layer.options.hideTitle = configLayer[0].hideTitle;
                } else {
                    layer.hideTitle = layer.options.hideTitle = false;
                }                
                
                return layer;
            }
        }
        return null;
    };

    ctlProto.addLayerToMap = function (layer, layerName) {
        const self = this;
        const layerOptions = TC.Util.extend({}, layer.options);
        layerOptions.id = self.getUID();
        layerOptions.layerNames = [layerName];
        layerOptions.title = layer.title;
        const newLayer = new TC.layer.Raster(layerOptions);
        if (newLayer.isCompatible(self.map.crs)) {
            self.map.addLayer(layerOptions).then(function (layer) {
                layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                    var layer = this.parent;
                    if (event.error.code === 401 || event.error.code === 403)
                        layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                    layer.map.removeLayer(layer);
                });
            });
        }
        else {
            showProjectionChangeDialog(self, newLayer);
        }
    };

    ctlProto.loaded = function () {
        return this._readyPromise;
    };

    ctlProto.getAvailableCRS = function (options) {
        const self = this;
        options = options || {};
        return self.map.getCompatibleCRS({
            layers: self.map.workLayers.concat(self.map.baseLayer, options.layer),
            includeFallbacks: true
        });
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options).then(function () {
                    if (self._layerToAdd) {
                        self.map.addLayer(self._layerToAdd);
                    }
                    TC.Util.closeModal();
                });
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        self._layerToAdd = options.layer;
        TC.control.ProjectionSelector.prototype.showProjectionChangeDialog.call(self, options);
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.Legend = function () {
    TC.control.MapContents.apply(this, arguments);
};

TC.inherit(TC.control.Legend, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.Legend.prototype;

    ctlProto.CLASS = 'tc-ctl-legend';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Legend.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LegendNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "legend" }).w("</h2><div class=\"tc-ctl-legend-tree\"><ul class=\"tc-ctl-legend-branch\">").s(ctx.get(["workLayers"], false), ctx, { "else": body_1, "block": body_2 }, {}).w("</ul></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li class=\"tc-ctl-legend-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.p("tc-ctl-legend-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_2.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["customLegend"], false), ctx, { "else": body_1, "block": body_11 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" data-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><div class=\"tc-ctl-legend-title\">").f(ctx.get(["title"], false), ctx, "h").w("</div>").x(ctx.get(["legend"], false), ctx, { "block": body_4 }, {}).w("<ul class=\"tc-ctl-legend-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_10 }, {}).w("</ul></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-legend-node tc-ctl-legend-leaf\" "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("class=\"tc-ctl-legend-node\" "); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<div class=\"tc-ctl-legend-watch\">").x(ctx.getPath(false, ["legend", "src"]), ctx, { "else": body_5, "block": body_8 }, {}).w("</div><div class=\"tc-ctl-legend-nvr\">").h("i18n", ctx, {}, { "$key": "notVisibleAtCurrentResolution" }).w("</div>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_6 }, {}); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<div class=\"tc-ctl-legend-img\" style=\"border:solid ").f(ctx.getPath(false, ["legend", "strokeWidth"]), ctx, "h").w("px ").f(ctx.getPath(false, ["legend", "strokeColor"]), ctx, "h").w(";background-color:").f(ctx.getPath(false, ["legend", "fillColor"]), ctx, "h").x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_7 }, {}).w("\"></div>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(";width:").f(ctx.getPath(false, ["legend", "width"]), ctx, "h").w("px;height:").f(ctx.getPath(false, ["legend", "height"]), ctx, "h").w("px;border-radius:50%"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<img src=\"\" data-img=\"").f(ctx.getPath(false, ["legend", "src"]), ctx, "h").w("\" ").x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_9 }, {}).w(" />"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("style=\"width:").f(ctx.getPath(false, ["legend", "width"]), ctx, "h").w("px;height:").f(ctx.getPath(false, ["legend", "height"]), ctx, "h").w("px;\" "); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.p("tc-ctl-legend-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.f(ctx.get(["customLegend"], false), ctx, "h", ["s"]); } body_11.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            const onLayerAdd = self.loadGraphics.bind(self);

            if (view === TC.Consts.view.THREED) {                
                map.on(TC.Consts.event.LAYERADD, onLayerAdd);
            } else if (view === TC.Consts.view.DEFAULT) {
                map.off(TC.Consts.event.LAYERADD, onLayerAdd);
            }
        });

        return TC.control.MapContents.prototype.register.call(self, map);
    };

    ctlProto.loadGraphics = function () {
        const self = this;
        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                li.querySelectorAll('li.' + self.CLASS + '-node-visible').forEach(function (l) {
                    const img = l.querySelector('img');
                    if (img && img.getAttribute('src') !== undefined && img.getAttribute('src').length === 0) {
                        self.styleLegendImage(img, layer);
                    }
                });
            }
        });
    };

    ctlProto.updateScale = function () {
        const self = this;
        const inScale = self.CLASS + '-node-inscale';
        const outOfScale = self.CLASS + '-node-outofscale';

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);

            if (layer) {
                var layersInScale = false;
                li.querySelectorAll('li').forEach(function (l) {
                    if (l.classList.contains(self.CLASS + '-node-visible')) {
                        const uid = l.dataset.layerUid;
                        if (layer.isVisibleByScale(uid)) {
                            layersInScale = true;
                            l.classList.remove(outOfScale);
                            l.classList.add(inScale);
                            const img = l.querySelector('img');
                            if (img) {
                                self.styleLegendImage(img, layer);
                            }
                        }
                        else {
                            l.classList.add(outOfScale);
                            l.classList.remove(inScale);
                        }
                    }
                });
                li.classList.toggle(inScale, layersInScale);
                li.classList.toggle(outOfScale, !layersInScale);
            }
        });
    };

    ctlProto.update = function () {
        const self = this;

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                layer.getTree();

                li.querySelectorAll('li').forEach(function (l) {
                    const uid = l.dataset.layerUid;
                    var visible = self.CLASS + '-node-visible';
                    var notVisible = self.CLASS + '-node-notvisible';
                    var hasVisible = self.CLASS + '-node-hasvisible';

                    switch (layer._cache.visibilityStates[uid]) {
                        case TC.Consts.visibility.NOT_VISIBLE:
                            l.classList.remove(visible, hasVisible);
                            l.classList.add(notVisible);                            
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            l.classList.remove(visible, notVisible);
                            l.classList.add(hasVisible);                            
                            break;
                        default:
                            // visible
                            l.classList.remove(notVisible, hasVisible);
                            l.classList.add(visible);                            
                            break;
                    }
                });

                self.updateLayerVisibility(layer);
            }
        });
        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;        

        if (!layer.isBase && !layer.options.stealth) {
            
            //// 09/04/2019 GLS: ignoramos el atributo que venga en la capa porque en la leyenda queremos que el árbol se muestre siempre y 
            //// nos ahorramos el tener que pasarlo en el estado del mapa
            if (layer.hideTree || layer.options.hideTree) {
                layer.tree = null;
                layer.hideTree = layer.options.hideTree = false;

                layer._cache.visibilityStates = {};
            }            

            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);            

            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(self.CLASS + '-node', self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        const uid = newLi.dataset.layerUid;
                        const ul = self.div.querySelector('ul.' + self.CLASS + '-branch');
                        const lis = ul.querySelectorAll('li[data-layer-uid="' + uid + '"]');
                        if (lis.length === 1) {
                            const li = lis[0];
                            li.innerHTML = newLi.innerHTML;
                            li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                        }
                        else {
                            newLi.dataset.layerId = layer.id;
                            ul.insertBefore(newLi, ul.firstChild);
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                li.classList.toggle(self.CLASS + '-node-notvisible', !layer.getVisibility());
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        return self.div.querySelector('ul.' + self.CLASS + '-branch').querySelectorAll('li.' + self.CLASS + '-node');
    };
})();

TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.LineFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYLINE;
    };

    TC.inherit(TC.control.LineFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.LineFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
TC.control = TC.control || {};

if (!TC.control.WorkLayerManager) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/WorkLayerManager');
}

TC.control.ListTOC = TC.control.WorkLayerManager;
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.LoadingIndicator = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self._waits = {};

    window.addEventListener('error', function () {
        self.reset();
        // Tell browser to run its own error handler as well
        return false;
    }, false);
};

TC.inherit(TC.control.LoadingIndicator, TC.Control);

(function () {
    var ctlProto = TC.control.LoadingIndicator.prototype;

    ctlProto.CLASS = 'tc-ctl-load';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/LoadingIndicator.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-load-bar\"><div class=\"tc-ctl-load-dots tc-ctl-load-dot1\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot2\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot3\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot4\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot5\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot6\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot7\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot8\"> </div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    //var ctlProto.waits = {};
    
    ctlProto.startWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        if (self._waits[layerId] === undefined) {
            self._waits[layerId] = 0;
        }
        self._waits[layerId] = self._waits[layerId] + 1;
        self.show();

        self.map.trigger(TC.Consts.event.STARTLOADING);
    };

    ctlProto.stopWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        var wait = self._waits[layerId];
        if (wait > 0) {
            wait = self._waits[layerId] = wait - 1;
        }
        if (!wait) {
            delete self._waits[layerId];
        }
        var count = 0;
        for (var key in self._waits) {
            count++;
        }
        if (!count) {
            self.hide();
            self.map.trigger(TC.Consts.event.STOPLOADING);
        }
    };

    ctlProto.endWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        var wait = self._waits[layerId];
        if (wait > 0) {
            delete self._waits[layerId];
        }
        var count = 0;
        for (var key in self._waits) {
            count++;
        }
        if (!count) {
            self.hide();
            self.map.trigger(TC.Consts.event.STOPLOADING);
        }
    };

    ctlProto.reset = function (e) {
        var self = this;
        self._waits = {};
        self.hide();
        self.map.trigger(TC.Consts.event.STOPLOADING);
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' +
                TC.Consts.event.BEFORELAYERUPDATE + ' ' +
                TC.Consts.event.BEFOREFEATURESADD, function (e) {
                    self.startWait(e);
                })
            .on(TC.Consts.event.LAYERADD + ' ' +
                TC.Consts.event.LAYERERROR + ' ' +
                TC.Consts.event.LAYERUPDATE + ' ' +
                TC.Consts.event.FEATURESADD, function (e) {
                    self.stopWait(e);
                })
            .on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                self.addWait(TC.Consts.event.FEATUREINFO);
            })
            .on(TC.Consts.event.FEATUREINFO + ' ' +
                TC.Consts.event.NOFEATUREINFO + ' ' +
                TC.Consts.event.FEATUREINFOERROR, function () {
                    self.removeWait(TC.Consts.event.FEATUREINFO);
                })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                self.endWait(e);
            });
        if (!TC.isDebug) {
            //Para evitar que se quede el indicador indefinidamente activo cuando hay un error en la página
            window.addEventListener('error', function (msg, url, line, col, error) {
                self.reset();
                return false;
            });

            //$(document).ajaxError(function (event, request, settings) {
            //    self.reset();
            //});
        }

        return result;
    };

    ctlProto.addWait = function (uid) {
        const self = this;
        const result = uid || TC.getUID();
        self.startWait({ layer: { id: result } });
        return result;
    };

    ctlProto.removeWait = function (uid) {
        this.stopWait({ layer: { id: uid } });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.BEFOREFEATUREMODIFY = "beforefeaturemodify.tc";
TC.Consts.event.FEATUREMODIFY = "featuremodify.tc";
TC.Consts.event.FEATURESSELECT = "featuresselect.tc";
TC.Consts.event.FEATURESUNSELECT = "featuresunselect.tc";
TC.Consts.event.CHANGE = 'change';

(function () {

    TC.control.Modify = function () {
        var self = this;

        TC.Control.apply(self, arguments);

        if (!TC.browserFeatures.inputTypeColor() && !window.CP) {
            TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
            TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
        }

        self.styles = TC.Util.extend(true, TC.Cfg.styles.selection, self.options.styles);
        self.styles.text = self.styles.text || {
            fontSize: self.styles.line.fontSize,
            fontColor: self.styles.line.fontColor,
            labelOutlineColor: self.styles.line.labelOutlineColor,
            labelOutlineWidth: self.styles.line.labelOutlineWidth
        };

        self._classSelector = '.' + self.CLASS;

        self.wrap = new TC.wrap.control.Modify(self);
    };

    TC.inherit(TC.control.Modify, TC.Control);

    var ctlProto = TC.control.Modify.prototype;

    ctlProto.CLASS = 'tc-ctl-mod';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Modify.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-btn tc-ctl-mod-btn-select\" disabled title=\"").h("i18n", ctx, {}, { "$key": "select" }).w("\">").h("i18n", ctx, {}, { "$key": "select" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-delete\" disabled title=\"").h("i18n", ctx, {}, { "$key": "deleteSelection" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteSelection" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-join\" disabled title=\"").h("i18n", ctx, {}, { "$key": "joinGeometries.tooltip" }).w("\">").h("i18n", ctx, {}, { "$key": "joinGeometries" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-split\" disabled title=\"").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("\">").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-text\" contenteditable=\"true\" disabled title=\"").h("i18n", ctx, {}, { "$key": "addText" }).w("\">").h("i18n", ctx, {}, { "$key": "addText" }).w("</button><div class=\"tc-ctl-mod-style tc-hidden\"><input type=\"text\" class=\"tc-ctl-mod-txt tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "writeTextForSketch" }).w("\" style=\"font-size:").f(ctx.get(["fontSize"], false), ctx, "h").w("pt;font-color:").f(ctx.get(["fontColor"], false), ctx, "h").w(";text-shadow: 0 0 ").f(ctx.get(["labelOutlineWidth"], false), ctx, "h").w("px ").f(ctx.get(["labelOutlineColor"], false), ctx, "h").w(";\" />").h("i18n", ctx, {}, { "$key": "textColor" }).w("<input type=\"color\" class=\"tc-ctl-mod-fnt-c\" value=\"").f(ctx.get(["fontColor"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "fontSize" }).w("<input type=\"number\" class=\"tc-ctl-mod-fnt-s tc-textbox\" value=\"").f(ctx.get(["fontSize"], false), ctx, "h").w("\" min=\"7\" max=\"20\" /></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const setFeatureSelectedState = function (ctl, features) {
        ctl._deleteBtn.disabled = features.length === 0;
        ctl._joinBtn.disabled = features.length < 2;
        ctl._splitBtn.disabled = features.filter(complexGeometryFilter).length === 0;
        ctl.displayLabelText();
    };

    const styleFunction = function (feature, mapStyles) {
        var result;
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                result = TC.Util.extend({}, mapStyles.polygon);
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
            case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                result = TC.Util.extend({}, mapStyles.point);
                break;
            default:
                result = TC.Util.extend({}, mapStyles.line);
                break;
        }
        const style = feature.getStyle();
        if (style.label) {
            result.label = style.label;
            result.fontSize = style.fontSize;
            result.fontColor = style.fontColor;
            result.labelOutlineColor = style.labelOutlineColor;
            result.labelOutlineWidth = style.labelOutlineWidth;
        }
        return result;
    };

    //const setFeatureSelectedStyle = function (ctl, features) {
    //    const mapStyles = ctl.map.options.styles.selection;
    //    features.forEach(function (feature) {
    //        feature._originalStyle = TC.Util.extend({}, feature.getStyle());
    //        feature.setStyle(ctl.styleFunction(feature));
    //    });
    //};

    //const setFeatureUnselectedStyle = function (ctl, features) {
    //    features.forEach(function (feature) {
    //        if (feature._originalStyle) {
    //            const style = feature.getStyle();
    //            if (style.label) {
    //                const originalStyle = feature._originalStyle;
    //                originalStyle.label = style.label;
    //                originalStyle.fontSize = style.fontSize;
    //                originalStyle.fontColor = style.fontColor;
    //                originalStyle.labelOutlineColor = style.labelOutlineColor;
    //                originalStyle.labelOutlineWidth = style.labelOutlineWidth;
    //            }
    //            feature.setStyle(feature._originalStyle);
    //            feature._originalStyle = undefined;
    //        }
    //    })
    //};

    const complexGeometryFilter = function (elm) {
        var result = false;
        if ((TC.feature.MultiPolygon && elm instanceof TC.feature.MultiPolygon) ||
            (TC.feature.MultiPolyline && elm instanceof TC.feature.MultiPolyline)) {
            if (elm.geometry.length > 1) {
                result = true;
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        if (self.options.layer) {

            self.setLayer(self.options.layer);

            map
                .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                    Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                        const layer = objects[0];
                        if (e.layer === layer) {
                            self._selectBtn.disabled = false;
                            self._textBtn.disabled = false;
                        }
                    });
                })
                .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                    const layer = e.layer;
                    const feature = e.feature;
                    Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                        if (layer === objects[0]) {
                            if (feature) {
                                self.unselectFeatures([feature]);
                            }
                            else {
                                self.unselectFeatures();
                            }
                            setFeatureSelectedState(self, self.getSelectedFeatures());
                            if (self.layer.features.length === 0) {
                                self._selectBtn.disabled = true;
                                self.setTextMode(false);
                                self._textBtn.disabled = true;
                            }
                        }
                    });
                });

            const featureSelectUpdater = function () {
                const selectedFeatures = self.getSelectedFeatures();
                setFeatureSelectedState(self, selectedFeatures);
                const unselectedFeatures = self.layer.features.filter(function (feature) {
                    return selectedFeatures.indexOf(feature) < 0;
                });
                unselectedFeatures.forEach(function (feature) {
                    feature.toggleSelectedStyle(false);
                });
                selectedFeatures.forEach(function (feature) {
                    feature.toggleSelectedStyle(true);
                });
            };
            self
                .on(TC.Consts.event.FEATURESSELECT, featureSelectUpdater)
                .on(TC.Consts.event.FEATURESUNSELECT, featureSelectUpdater);
        }

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        const renderCallback = function () {
            self._selectBtn = self.div.querySelector('.' + self.CLASS + '-btn-select');
            self._selectBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                if (!e.target.disabled) {
                    if (self.isActive) {
                        self.deactivate();
                    }
                    else {
                        self.activate();
                    }
                }
            });
            self._deleteBtn = self.div.querySelector('.' + self.CLASS + '-btn-delete');
            self._deleteBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.deleteSelectedFeatures();
            });
            self._textBtn = self.div.querySelector('.' + self.CLASS + '-btn-text');
            self._textBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.setTextMode(!self.textActive);
            });
            self._joinBtn = self.div.querySelector('.' + self.CLASS + '-btn-join');
            self._splitBtn = self.div.querySelector('.' + self.CLASS + '-btn-split');
            self._textInput = self.div.querySelector('input.' + self.CLASS + '-txt');
            self._textInput.addEventListener('input', function (e) {
                self.labelFeatures(e.target.value);
            });
            self._styleSection = self.div.querySelector('.' + self.CLASS + '-style');

            self._fontColorPicker = self.div.querySelector(self._classSelector + '-fnt-c');
            self._fontColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontColor(e.target.value);
            });

            self._fontSizeSelector = self.div.querySelector('.' + self.CLASS + '-fnt-s');
            self._fontSizeSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontSize(e.target.value);
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        };

        const renderObject = {
            fontSize: self.styles.text.fontSize,
            fontColor: self.styles.text.fontColor,
            labelOutlineColor: self.styles.text.labelOutlineColor,
            labelOutlineWidth: self.styles.text.labelOutlineWidth
        };

        var promise;
        if (TC.browserFeatures.inputTypeColor()) {
            promise = self._set1stRenderPromise(self.renderData(renderObject, renderCallback));
        }
        else {
            // El navegador no soporta input[type=color], usamos polyfill
            promise = self._set1stRenderPromise(self.renderData(renderObject, function () {
                const input = self.div.querySelector('input[type=color]');
                input.style.backgroundColor = input.value;
                input.style.color = 'transparent';
                const picker = new CP(input, 'click', document.body);

                input.onclick = function (e) {
                    e.preventDefault();
                };

                // Evitamos que salga el teclado virtual en iOS
                input.onfocus = function (e) {
                    this.blur();
                };

                input.onchange = function (e) {
                    this.style.backgroundColor = this.value;
                };
                self.map.loaded(function () {
                    picker.on("change", function (color) {
                        self.setFontColor('#' + color);
                    });
                });

                renderCallback();
            }));
        }
        return promise;
    };

    ctlProto.activate = function () {
        const self = this;
        self._selectBtn.classList.add(TC.Consts.classes.ACTIVE);
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
    };

    ctlProto.deactivate = function () {
        const self = this;
        TC.Control.prototype.deactivate.call(self);
        if (self._selectBtn) {
            setFeatureSelectedState(self, []);
        }
        if (self.wrap) {
            self.wrap.deactivate();
        }
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        if (self._selectBtn) {
            self._selectBtn.classList.remove(TC.Consts.classes.ACTIVE);
            self.layer.features.forEach(function (feature) {
                feature.toggleSelectedStyle(false);
            });
            //setFeatureUnselectedStyle(self, self.getSelectedFeatures());
        }
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            if (self.layer) {
                self.layer.map.putLayerOnTop(self.layer);
            }
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.getLayer = function () {
        var self = this;
        // Se ha instanciado un control sin capa asociada
        if (self.options && typeof self.options.layer === 'boolean' && !self.options.layer) {
            return Promise.resolve(null);
        }
        if (self.layer) {
            return Promise.resolve(self.layer);
        }
        return self._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        if (self.map) {
            self._layerPromise = new Promise(function (resolve, reject) {
                if (typeof (layer) === "string") {
                    self.map.loaded(function () {
                        self.layer = self.map.getLayer(layer);
                        resolve(self.layer);
                    });
                }
                else {
                    self.layer = layer;
                    resolve(self.layer);
                }
            });
        }
    };

    ctlProto.getSelectedFeatures = function () {
        return this.wrap.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        const self = this;
        const result = self.wrap.setSelectedFeatures(features);
        self.displayLabelText();
        return result;
    };

    ctlProto.getActiveFeatures = function () {
        const self = this;
        const result = self.getSelectedFeatures();
        if (!result.length && self.layer.features.length) {
            result.push(self.layer.features[self.layer.features.length - 1]);
        }
        return result;
    };

    ctlProto.unselectFeatures = function (features) {
        features = features || [];
        this.wrap.unselectFeatures(features.map(function (feat) {
            return feat.wrap.feature;
        }));
        return this;
    };

    ctlProto.deleteSelectedFeatures = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        self.wrap.unselectFeatures(features);
        features.forEach(function (feature) {
            self.layer.removeFeature(feature);
        });
        return self;
    };

    ctlProto.styleFunction = function (feature, resolution) {
        const self = this;
        var result;
        const mapStyles = self.map.options.styles.selection;
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                result = TC.Util.extend({}, mapStyles.polygon);
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
            case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                result = TC.Util.extend({}, mapStyles.point);
                break;
            default:
                result = TC.Util.extend({}, mapStyles.line);
                break;
        }
        const style = feature.getStyle();
        if (style.label) {
            result.label = style.label;
            result.fontSize = style.fontSize;
            result.fontColor = style.fontColor;
            result.labelOutlineColor = style.labelOutlineColor;
            result.labelOutlineWidth = style.labelOutlineWidth;
        }
        return result;
    };

    ctlProto.setTextMode = function (active) {
        const self = this;
        self.textActive = active;
        if (active) {
            self._textBtn.classList.add(TC.Consts.classes.ACTIVE, active);
            self._styleSection.classList.remove(TC.Consts.classes.HIDDEN);
        }
        else {
            self._textBtn.classList.remove(TC.Consts.classes.ACTIVE, active);
            self._styleSection.classList.add(TC.Consts.classes.HIDDEN);
        }
        self.displayLabelText();
        return self;
    };

    ctlProto.setFontColorWatch = function (color, outlineColor) {
        const self = this;
        if (color === undefined) {
            color = self.styles.text.fontColor;
        }
        color = TC.Util.colorArrayToString(color);
        outlineColor = outlineColor || self.getLabelOutlineColor(color);
        self.renderPromise().then(function () {
            self._fontColorPicker.value = color;
            self._textInput.style.color = color;
            self._textInput.style.textShadow = '0 0 ' + self.styles.text.labelOutlineWidth + 'px ' + outlineColor;
            if (!TC.browserFeatures.inputTypeColor()) {
                self._fontColorPicker.style.backgroundColor = color;
                self._fontColorPicker.blur();
            }
        });
        return self;
    };

    ctlProto.setFontColor = function (color) {
        const self = this;
        self.styles.text.fontColor = color;
        self.styles.text.labelOutlineColor = self.getLabelOutlineColor(color);
        self.setFontColorWatch(color, self.styles.text.labelOutlineColor);
        const features = self.getActiveFeatures();
        features.forEach(function (feature) {
            const style = feature.getStyle();
            style.fontColor = color;
            style.labelOutlineColor = self.styles.text.labelOutlineColor;
            feature.setStyle(style);
        });
        return self;
    };

    ctlProto.setFontSizeWatch = function (size) {
        const self = this;
        if (size === undefined) {
            size = self.styles.text.fontSize;
        }
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.renderPromise().then(function () {
                self._fontSizeSelector.value = sizeValue;
                self._textInput.style.fontSize = sizeValue + 'pt';
            });
        }
        return self;
    };

    ctlProto.setFontSize = function (size) {
        const self = this;
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.styles.text.fontSize = sizeValue;
            self.setFontSizeWatch(sizeValue);
            const features = self.getActiveFeatures();
            features.forEach(function (feature) {
                const style = feature.getStyle();
                style.fontSize = sizeValue;
                feature.setStyle(style);
            });
        }
        return self;
    };

    ctlProto.getLabelOutlineColor = function (fontColor) {
        if (fontColor) {
            fontColor = TC.Util.colorArrayToString(fontColor);
            const matchForShort = fontColor.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (matchForShort && matchForShort.length) {
                fontColor = '#' + matchForShort[1] + matchForShort[1] + matchForShort[2] + matchForShort[2] + matchForShort[3] + matchForShort[3];
            }
            const matchForLong = fontColor.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
            if (matchForLong && matchForLong.length) {
                const r = parseInt(matchForLong[1], 16);
                const g = parseInt(matchForLong[2], 16);
                const b = parseInt(matchForLong[3], 16);
                return (r + g + b) / 3 < 128 ? '#ffffff' : '#000000';
            }
        }
        return '#ffffff';
    };

    ctlProto.displayLabelText = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        var text;
        var size;
        var color;
        if (self.isActive && features.length) {
            const feature = features[features.length - 1];
            const style = feature.getStyle();
            text = style.label;
            color = style.fontColor;
            size = style.fontSize;
        }
        else {
            text = '';
            color = self.styles.text.fontColor;
            size = self.styles.text.fontSize;
        }
        self.renderPromise().then(function () {
            self
                .setFontSizeWatch(size)
                .setFontColorWatch(color)
                ._textInput.value = text || '';
        });
        return self;
    };

    ctlProto.labelFeatures = function (text) {
        const self = this;
        const features = self.getActiveFeatures();
        if (features.length) {
            const style = features[0].getStyle();
            features.forEach(function (feature) {
                const textStyle = TC.Util.extend({}, self.styles.text, style);
                style.label = text;
                style.labelOffset = textStyle.labelOffset;
                style.fontColor = textStyle.fontColor;
                style.fontSize = textStyle.fontSize;
                style.labelOutlineColor = textStyle.labelOutlineColor;
                style.labelOutlineWidth = textStyle.labelOutlineWidth;
                feature.setStyle(style);
            });
        }
        return self;
    };

})();
TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
(function () {
    TC.control.MultiFeatureInfo = function () {
        var self = this;
        self.lineColor = null;
        TC.Control.apply(self, arguments);
        self.modes = self.options.modes || {};
        if (typeof self.modes[TC.Consts.geom.POINT] === 'undefined') {
            self.modes[TC.Consts.geom.POINT] = true;
        }
        if (typeof self.modes[TC.Consts.geom.POLYGON] === 'undefined') {
            self.modes[TC.Consts.geom.POLYGON] = true;
        }
        self.fInfoCtrl = null;
        self.lineFInfoCtrl = null;
        self.polygonFInfoCtrl = null;
        self.lastCtrlActive = null;
        self.popup = null;
        self.exportsState = false; // Los controles que exportan estado son los hijos
    };

    TC.inherit(TC.control.MultiFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.MultiFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-m-finfo';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/MultiFeatureInfo.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS,body_0);function body_0(chk,ctx){return chk.w("<div class=\"tc-ctl-m-finfo-select\"><form><span>").h("i18n",ctx,{},{"$key":"selection"}).w("</span>").x(ctx.get(["pointSelectValue"], false),ctx,{"block":body_1},{}).x(ctx.get(["lineSelectValue"], false),ctx,{"block":body_2},{}).x(ctx.get(["polygonSelectValue"], false),ctx,{"block":body_3},{}).w("</form></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-point\" title=\"").h("i18n",ctx,{},{"$key":"selectionByPoint"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["pointSelectValue"], false),ctx,"h").w("\" checked /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byPoint"}).w("</span></label>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-line\" title=\"").h("i18n",ctx,{},{"$key":"selectionByLine"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["lineSelectValue"], false),ctx,"h").w("\" /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byLine"}).w("</span></label>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-polygon\" title=\"").h("i18n",ctx,{},{"$key":"selectionByPrecinct"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["polygonSelectValue"], false),ctx,"h").w("\" /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byPrecinct"}).w("</span></label>");}body_3.__dustBody=!0;return body_0};
    }

    const mergeOptions = function (opt1, opt2) {
        if (opt1 === true) {
            opt1 = {};
            return TC.Util.extend(opt1, opt2);
        }
        return opt1;
    };

    ctlProto.register = function (map) {
        const self = this;

        self.div.querySelectorAll('input[type=radio]').forEach(function (input) {
            input.checked = false;
        });


        return new Promise(function (resolve, reject) {
            const ctlPromises = [TC.Control.prototype.register.call(self, map)]
            if (self.modes[TC.Consts.geom.POINT]) {
                ctlPromises.push(map.addControl("featureInfo", mergeOptions(self.modes[TC.Consts.geom.POINT],
                    { displayMode: self.options.displayMode })).then(function (control) {
                        self.fInfoCtrl = control;
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYLINE]) {
                ctlPromises.push(map.addControl("lineFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYLINE],
                    { displayMode: self.options.displayMode, lineColor: self.lineColor })).then(function (control) {
                        self.lineFInfoCtrl = control;
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYGON]) {
                ctlPromises.push(map.addControl("polygonFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYGON],
                    { displayMode: self.options.displayMode, lineColor: self.lineColor })).then(function (control) {
                        self.polygonFInfoCtrl = control;
                        return control;
                    }));
            }

            map.on(`${TC.Consts.event.LAYERADD} ${TC.Consts.event.LAYERREMOVE} ${TC.Consts.event.LAYERVISIBILITY}`, function (e) {
                self.updateUI();
            });

            map.on(`${TC.Consts.event.CONTROLACTIVATE} ${TC.Consts.event.CONTROLDEACTIVATE}`, function (e) {
                if (e.control === self.fInfoCtrl || e.control === self.lineFInfoCtrl || e.control === self.polygonFInfoCtrl) {
                    self.updateUI();
                }
            });

            Promise.all(ctlPromises).then(function () {
                if (self.fInfoCtrl) {
                    self.fInfoCtrl.activate();
                    self.lastCtrlActive = self.fInfoCtrl;
                }
                self.updateUI();
                resolve(self);
            });
        });

    };

    ctlProto.render = function (callback) {
        const self = this;
        self.lineColor = !self.options.lineColor ? "#c00" : self.options.lineColor;
        var renderData = {};
        if (self.modes[TC.Consts.geom.POINT]) {
            renderData.pointSelectValue = TC.Consts.geom.POINT;
        }
        if (self.modes[TC.Consts.geom.POLYLINE]) {
            renderData.lineSelectValue = TC.Consts.geom.POLYLINE;
        }
        if (self.modes[TC.Consts.geom.POLYGON]) {
            renderData.polygonSelectValue = TC.Consts.geom.POLYGON;
        }
        return TC.Control.prototype.renderData.call(self, renderData,
            function () {
                var changeEvent = function () {
                    switch (this.value) {
                        case TC.Consts.geom.POLYLINE:
                            //modo línea
                            self.lineFInfoCtrl.activate();
                            self.lastCtrlActive = self.lineFInfoCtrl;
                            break;
                        case TC.Consts.geom.POLYGON:
                            //modo poligono
                            self.polygonFInfoCtrl.activate();
                            self.lastCtrlActive = self.polygonFInfoCtrl;
                            break;
                        default:
                            //modo point
                            self.fInfoCtrl.activate();
                            self.lastCtrlActive = self.fInfoCtrl;
                            break;
                    }
                };
                self.div.querySelectorAll('input[type=radio]').forEach(function (input) {
                    input.addEventListener('change', changeEvent);
                });

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            });
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.lastCtrlActive)
            self.lastCtrlActive.activate();
    };

    ctlProto.deactivate = function () {
        var self = this;
        self.lastCtrlActive.deactivate(false);
    };

    ctlProto.updateUI = function () {
        const self = this;
        if (self.map) {
            const enabled = self.map.workLayers.some(l => l.type === TC.Consts.layerType.WMS && l.getVisibility());
            self.div.querySelectorAll('input').forEach(function (input) {
                input.disabled = !enabled;
            });
            if (self.fInfoCtrl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POINT}]`);
                if (input) {
                    input.checked = self.fInfoCtrl.isActive;
                }
            }
            if (self.lineFInfoCtrl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POLYLINE}]`);
                if (input) {
                    input.checked = self.lineFInfoCtrl.isActive;
                }
            }
            if (self.polygonFInfoCtrl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POLYGON}]`);
                if (input) {
                    input.checked = self.polygonFInfoCtrl.isActive;
                }
            }
            // Hack para compensar bug de Edge: no se actualiza el estilo al cambiar el estado del radio.
            const displayValue = self.div.style.display;
            self.div.style.display = 'none';
            if (displayValue) {
                self.div.style.display = displayValue;
            }
            else {
                self.div.style.removeProperty('display');
            }
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBar, TC.Control);

(function () {
    var ctlProto = TC.control.NavBar.prototype;

    ctlProto.CLASS = 'tc-ctl-nav';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBar(self);
        }
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);

        if (self.options.home === undefined || self.options.home) {
            map.addControl('navBarHome');
        }        

        //esta chama es para que la primera vez se ajuste la barrita de escala (debido a otra chama con el maxResolution, que es culpa de OL)
        map.loaded(function () {
            self.wrap.refresh();
        });        

        return result;
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBarHome = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBarHome, TC.Control);

(function () {
    var ctlProto = TC.control.NavBarHome.prototype;

    ctlProto.CLASS = 'tc-ctl-nav-home';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBarHome(self);
        }
        return Promise.resolve();
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);        

        map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
            const crs = e.crs;
            var bottomLeft = TC.Util.reproject([map.options.initialExtent[0], map.options.initialExtent[1]], map.options.crs, crs);
            var topRight = TC.Util.reproject([map.options.initialExtent[2], map.options.initialExtent[3]], map.options.crs, crs);
            self.wrap.setInitialExtent([bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]);
        });

        return result;
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.OverviewMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.isLoaded = false;

    self.layer = null;
};

TC.inherit(TC.control.OverviewMap, TC.Control);

(function () {
    var ctlProto = TC.control.OverviewMap.prototype;

    ctlProto.CLASS = 'tc-ctl-ovmap';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/OverviewMap.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ovmap-load tc-hidden\"></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const instanceLayer = function (layer) {
            var lyr;

            var findLayerById = function (id, layers) {
                var result = null;
                for (var i = 0; i < layers.length; i++) {
                    var lyr = layers[i];
                    var l = lyr.id || lyr;
                    if (l === id) {
                        result = lyr;
                        break;
                    }
                }
                return result;
            };

            if (typeof layer === 'string') {
                var lyrObj = findLayerById(layer, map.options.availableBaseLayers);
                if (!TC.Util.isPlainObject(lyrObj)) {
                    lyrObj = findLayerById(layer, map.options.baseLayers);
                }
                if (TC.Util.isPlainObject(lyrObj)) {
                    lyr = new TC.layer.Raster(lyrObj);
                }
            }
            else {
                if (layer instanceof TC.Layer) {
                    lyr = layer;
                }
                else if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                    lyr = new TC.layer.Vector(layer);
                }
                else {
                    lyr = new TC.layer.Raster(layer);
                }
            }

            return lyr;
        };

        const registerLayer = function (layer) {
            var lyr;

            lyr = instanceLayer(layer);

            return lyr;
        };

        const resetOVMapProjection = function (e) {
            const resetOptions = {};
            self.layer.getCapabilitiesPromise().then(function () {
                if (!self.layer.isCompatible(map.crs) && self.layer.wrap.getCompatibleMatrixSets(map.crs).length === 0) {
                    resetOptions.layer = self.layer.getFallbackLayer();
                }
                self.wrap.reset(resetOptions);
            });
        };

        const changeBaseLayer = function (e) {
            const self = this;

            if (self.map.baseLayer.type === TC.Consts.layerType.WMS || self.map.baseLayer.type === TC.Consts.layerType.WMTS || self.options.layer) {
                var newLayer = self.map.baseLayer.overviewMapLayer || self.options.layer;
                if (self.layer.id !== newLayer) {
                    var overviewMapLayer = registerLayer(newLayer);
                    self.wrap.reset({
                        layer: overviewMapLayer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                } else if (TC.Consts.event.PROJECTIONCHANGE.indexOf(e.type) > -1) {
                    self.wrap.reset({
                        layer: self.layer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                }
            }
        };

        const result = new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map)
                .then(function (ctl) {
                    self.wrap = new TC.wrap.control.OverviewMap(self);
                    map.loaded(function () {
                        self.defaultLayer = registerLayer(self.options.layer);
                        self.layer = registerLayer(map.baseLayer.overviewMapLayer || self.options.layer || map.options.baseLayers[0] || map.options.availableBaseLayers[0]);

                        self.wrap.register(map);                        

                        resetOVMapProjection({ crs: map.crs });

                        map.on(TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.BASELAYERCHANGE, changeBaseLayer.bind(self));
                    });
                    resolve(ctl);
                })
                .catch(function (err) {
                    reject(err);
                });
        });

        return result;
    };

    ctlProto.loaded = function (callback) {
        var self = this;

        if (TC.Util.isFunction(callback)) {
            if (self.isLoaded && self.map && self.map.isLoaded) {
                callback();
            }
            else {
                self.on(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };

    ctlProto.activate = function () {
        this.enable();
    };

    ctlProto.deactivate = function () {
        this.disable();
    };

    ctlProto.enable = function () {
        var self = this;
        TC.Control.prototype.enable.call(self);
        self.wrap.enable();
    };

    ctlProto.disable = function () {
        var self = this;
        TC.Control.prototype.disable.call(self);
        self.wrap.disable();
    };

})();
TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.PolygonFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYGON;
    };

    TC.inherit(TC.control.PolygonFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.PolygonFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
TC.Consts.classes.DRAGGED = TC.Consts.classes.DRAGGED || 'tc-dragged';
TC.Consts.classes.DRAGGABLE = TC.Consts.classes.DRAGGABLE || 'tc-draggable';

TC.control.Popup = function () {
    var self = this;

    TC.Control.apply(self, arguments);
    self.currentFeature = null;
    //self.wrap = { popup: null };    
    self.wrap = new TC.wrap.control.Popup(self);
};

TC.inherit(TC.control.Popup, TC.Control);

(function () {
    var ctlProto = TC.control.Popup.prototype;

    ctlProto.CLASS = 'tc-ctl-popup';

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.map.wrap.addPopup(self)
                .then(function () {
                    self.trigger(TC.Consts.event.CONTROLRENDER);
                    resolve();
                },
                function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        return new Promise(function (resolve, reject) {
            Promise.all([result, self.renderPromise()]).then(function () {
                map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (map.view === TC.Consts.view.PRINTING) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer && !e.layer.getVisibility()) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERREMOVE, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.UPDATE, function () {
                    if (!self.currentFeature || self.currentFeature._visibilityState === TC.Consts.visibility.NOT_VISIBLE) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.FEATUREREMOVE, function (e) {
                    if (self.currentFeature === e.feature) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                /**
                    GLS: Controlamos el ancla del popup cuando hay zoom in/out de pantalla o navegador, debería hacerlo OL pero no lo gestiona.
                    No funciona, sólo salta la primera vez, paso a sobrescribir el método de OL
                 */
                //var config = { attributes: true, attributeFilter: ['style', 'class'], childList: false, subtree: false };
                //var observer = new MutationObserver(function (mutationsList, observer) {
                //    //var positionMutation = mutationsList.filter(function (mutation) {
                //    //    return mutation.type === "attributes"
                //    //}).filter(function (mutation) {
                //    //    return ['top', 'right', 'bottom', 'left', 'style'].indexOf(mutation.attributeName) > -1;
                //    //});

                //    if (mutationsList.length > 0) {
                //        // me desconecto para no entrar en un bucle infinito
                //        //observer.disconnect();

                //        var top = mutationsList[0].target[mutationsList[0].attributeName].top;
                //        var right = mutationsList[0].target[mutationsList[0].attributeName].right;
                //        var bottom = mutationsList[0].target[mutationsList[0].attributeName].bottom;
                //        var left = mutationsList[0].target[mutationsList[0].attributeName].left;

                //        [{ top: top }, { right: right }, { bottom: bottom }, { left: left }].forEach(function (elm) {
                //            var key = Object.keys(elm)[0];
                //            if (elm[key].length > 0) {
                //                document.querySelector('.ol-overlay-container').style[key] = parseFloat(elm[key].replace('px', '')) / window.devicePixelRatio + 'px';
                //            }
                //        });

                //        // volvemos a observar
                //        //observer.observe(document.querySelector('.ol-overlay-container'), config);
                //    }
                //});
                //observer.observe(document.querySelector('.ol-overlay-container'), config);

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        })
    };

    ctlProto.fitToView = function (delayed) {
        var self = this;
        if (delayed) {
            setTimeout(function () {
                self.wrap.fitToView();
            }, 1000);
        }
        else {
            self.wrap.fitToView();
        }
    };

    ctlProto.hide = function () {
        var self = this;
        if (self.map) {
            const data = {
                control: self,
                feature: self.currentFeature
            };
            self.map.wrap.hidePopup(self);
            self.setDragged(false);
            self.map.trigger(TC.Consts.event.POPUPHIDE, data);
        }
    };

    ctlProto.getContainerElement = function () {
        return this.contentDiv || null;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv || null;
    };

    ctlProto.setDragged = function (dragged) {
        const self = this;
        self.dragged = dragged;
        if (self.popupDiv) {
            self.popupDiv.classList.toggle(TC.Consts.classes.DRAGGED, !!dragged);
        }
        self.wrap.setDragged(dragged);
    };

    ctlProto.setDragging = function (dragging) {
        const self = this;
        if (dragging) {
            self.setDragged(true);
            self.popupDiv.classList.add(TC.Consts.classes.DRAG);
        }
        else {
            self.popupDiv.classList.remove(TC.Consts.classes.DRAG);
        }
    };

    ctlProto.isVisible = function () {
        const self = this;

        return self.popupDiv && self.popupDiv.classList.contains(TC.Consts.classes.VISIBLE);
    };

})();
TC.control = TC.control || {};

TC.Consts.classes.PRINTABLE = 'tc-printable';




TC.control.Print = function (options)
{
    var self = this;
    var opts = options || {};

    self.ready = false;

    self.title = opts.title || TC.Util.getLocaleString(TC.Cfg.locale, 'printPage');
    self.cssUrl = opts.cssUrl || TC.apiLocation + 'TC/css/print.css';

    if (opts.target)
    {
        const target = opts.target;

        if (!target.querySelector('.' + self.CLASS + '-btn')) {
            for (var key in self.template) {
                if (!dust.cache[key]) {
                    self.template[key]();
                }
            }
            
            target.classList.add(TC.Consts.classes.PRINTABLE);

            var renderPage = function (e) {
                var page = open(null, self.CLASS);
                var content = target.innerHTML;
                dust.render(self.CLASS + '-page', { title: self.title, content: content, cssUrl: self.cssUrl }, function (err, out) {
                    page.document.write(out);
                    page.document.close();
                    page.focus();
                    if (err) {
                        TC.error(err);
                    }
                });
            };
            dust.render(self.CLASS, null, function (err, out) {
                target.insertAdjacentHTML('afterbegin', out);
                target.querySelector('.' + self.CLASS + '-btn').addEventListener('click', renderPage);
            });
        }
    }
};

(function () {
    var ctlProto = TC.control.Print.prototype;

    ctlProto.CLASS = 'tc-ctl-print';

    ctlProto.template = {};

    //if (TC.isDebug) {
    //    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Print.html";
    //    ctlProto.template[ctlProto.CLASS + '-page'] = TC.apiLocation + "TC/templates/PrintPage.html";
    //}
    //else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<a class=\"tc-ctl-print-btn\" title=\"").h("i18n", ctx, {}, { "$key": "printThisWindow" }).w("\">").h("i18n", ctx, {}, { "$key": "print" }).w("</a>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-page'] = function () { dust.register(ctlProto.CLASS + '-page', body_0); function body_0(chk, ctx) { return chk.w("<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><title>").f(ctx.get(["title"], false), ctx, "h").w("</title><link rel=\"stylesheet\" href=\"").f(ctx.get(["cssUrl"], false), ctx, "h").w("\" /></head><body onload=\"print()\" class=\"tc-ctl-print-page\"><h1>").f(ctx.get(["title"], false), ctx, "h").w("</h1>").f(ctx.get(["content"], false), ctx, "h", ["s"]).w("</body></html>"); } body_0.__dustBody = !0; return body_0 };
    //}

})();
TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.PrintMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.PrintMap, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.PrintMap.prototype;

    ctlProto.CLASS = 'tc-ctl-printMap';

    var self = this;

    const ORIENTATION = {
        PORTRAIT: 'portrait',
        LANDSCAPE: 'landscape'
    };
    const PAGE_SIZE = {
        A4: 'A4',
        A3: 'A3'
    };

    /*
        GLS:
        La librería makePDF se basa en la librería PDFKit explicación sobre la unidad de medida que usa:
        PDF points (72 per inch)
        https://stackoverflow.com/questions/51540144/pdfkit-node-js-measurement-unit
        https://www.ninjaunits.com/converters/pixels/points-pixels/
        https://www.ninjaunits.com/converters/pixels/pixels-points/

        La clave es mantener las dimensiones del mapa en px enteros (canvas sólo admite px enteros), ajustando el layout que está en puntos y que sí admite decimales
    */

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a4 indicando el valor en px la sección del mapa   */
    var a4_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 595,
                height: 842
            },
            pageMargins: [29.5, 14, 29.5, 22.5],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a4 indicando el valor en px la sección del mapa   */
    var a4_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 842,
                height: 595
            },
            pageMargins: [30, 14, 30, 22],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a3 indicando el valor en px la sección del mapa   */
    var a3_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 841.89,
                height: 1190.55
            },
            pageMargins: [29.954, 14, 29.954, 21.55],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a3 indicando el valor en px la sección del mapa   */
    var a3_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 1190.55,
                height: 841.89
            },
            pageMargins: [28.775, 14, 28.775, 14.89],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    const getLayout = function (orientation, format) {
        switch (orientation) {
            case ORIENTATION.PORTRAIT: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_portrait;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_portrait;
                    }
                    default:
                }
                break;
            }
            case ORIENTATION.LANDSCAPE: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_landscape;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_landscape;
                    }
                    default:
                }
                break;
            }
            default:
                return a4_portrait;
        }
    };

    const getLogoColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[0];
    };
    const getTitleColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[1];
    };
    const getScaleBarColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[2];
    };
    const getMap = function (layout) {
        return layout.layoutPDF.content[1].table.body[0][0];
    };

    const options = {
        qrCode: {
            sideLength: 85
        }
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/PrintMap.html";
        ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/PrintMapView.html";
        ctlProto.template[ctlProto.CLASS + '-tools'] = TC.apiLocation + "TC/templates/PrintMapTools.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "print" }).w("</h2><div><div class=\"tc-ctl-printMap-div\"><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "title" }).w(":</label><input type=\"text\" class=\"tc-ctl-printMap-title tc-textbox\" maxlength=\"30\" placeholder=\"").h("i18n", ctx, {}, { "$key": "mapTitle" }).w("\" /></div><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "layout" }).w(":</label><select id=\"print-design\" class=\"tc-combo\"><option value=\"landscape\">").h("i18n", ctx, {}, { "$key": "landscape" }).w("</option><option value=\"portrait\">").h("i18n", ctx, {}, { "$key": "portrait" }).w("</option></select></div><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "size" }).w(":</label><select id=\"print-size\" class=\"tc-combo\"><option value=\"a4\">A4</option><option value=\"a3\">A3</option></select></div><div class=\"tc-group tc-ctl-printMap-cnt tc-ctl-printMap-cnt-btn\"><input id=\"tc-ctl-printMap-image-qr\" class=\"tc-hidden\" type=\"checkbox\" checked style=\"display:none;\" /><label for=\"tc-ctl-printMap-image-qr\" class=\"tc-ctl-printMap-image-qr-label\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCodeToImage" }).w("\">").h("i18n", ctx, {}, { "$key": "appendQRCode" }).w("</label><button class=\"tc-ctl-printMap-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "printMap" }).w("\">").h("i18n", ctx, {}, { "$key": "print" }).w("</button></div><div class=\"tc-group tc-ctl-printMap-cnt\"><div class=\"tc-ctl-printMap-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-view'] = function () { dust.register(ctlProto.CLASS + '-view', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-printMap-view\"> </div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-tools'] = function () { dust.register(ctlProto.CLASS + '-tools', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-printMap-tools\"><div class=\"tc-ctl-printMap-btn-pdf\" title=\"").h("i18n", ctx, {}, { "$key": "printpdf" }).w("\"></div><div class=\"tc-ctl-printMap-btn-close\" title=\"").h("i18n", ctx, {}, { "$key": "close" }).w("\"></div></div> "); } body_0.__dustBody = !0; return body_0 };
    }

    const hasLegend = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
        });
    };

    const hasLegendToPrint = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            if (layer.type === TC.Consts.layerType.WMS && layer.getVisibility()) {
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        return true;
                    }
                }

                return false;
            }

            return false;
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        const manageLegendOnZoom = function () {
            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            layout.reset();
        };

        const print = function () {

            self.map.setView(TC.Consts.view.PRINTING);

            var codeContainer = document.querySelector('.' + self.CLASS + '-qrcode');
            if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                if (!codeContainer) {
                    codeContainer = document.createElement('div');
                    codeContainer.classList.add(self.CLASS + '-qrcode');
                    self.map.div.appendChild(codeContainer);
                }

                codeContainer.innerHTML = '';
                self.makeQRCode(codeContainer, options.qrCode.sideLength, options.qrCode.sideLength);
            } else {
                if (codeContainer) {
                    codeContainer.innerHTML = '';
                }
            }

            const printBtnSelector = '.' + self.CLASS + '-btn';
            self.map.on(TC.Consts.event.STARTLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.add('disabled');
                printBtn.disabled = true;
            });

            self.map.on(TC.Consts.event.STOPLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.remove('disabled');
                printBtn.disabled = false;
            });

            if (hasLegend.call(self)) {
                // GLS: controlamos si una capa deja de verse por la escala para resetear la leyenda                
                self.map.on(TC.Consts.event.ZOOM, manageLegendOnZoom);
            }

            const updateCanvas = function (printFormat) {
                if (printFormat) {
                    self.map.div.classList.add(printFormat);
                    /**
                     * Validamos que el resultado en pixels sean valores enteros, si no lo son, redondeamos y establecemos evitando estiramiento del canvas /
                     */
                    var bounding = self.map.div.getBoundingClientRect();
                    if (!Number.isInteger(bounding.width)) {
                        self.map.div.style.width = Math.round(bounding.width) + 'px';
                    }
                    if (!Number.isInteger(bounding.height)) {
                        self.map.div.style.height = Math.round(bounding.height) + 'px';
                    }

                    self.map.toast(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'), { type: TC.Consts.msgType.INFO, duration: 7000 });
                }

                self.map.wrap.map.updateSize();
            };

            const resetPrinting = function () {

                var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
                layout.reset();

                if (hasLegend.call(self)) {
                    self.map.off(TC.Consts.event.ZOOM, manageLegendOnZoom);
                }

                self.map.toastHide(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'));

                self.map.div.classList.remove(self.currentFormat, self.CLASS + '-printing');

                self.map.div.style.removeProperty('width');
                self.map.div.style.removeProperty('height');

                updateCanvas();

                self.map.setView(TC.Consts.view.DEFAULT);

                self._viewDiv.classList.add(TC.Consts.classes.HIDDEN);
            };

            if (!self._viewDiv) {
                self._viewDiv = TC.Util.getDiv();
                document.body.appendChild(self._viewDiv);

                self.getRenderedHtml(self.CLASS + '-view', null, function (html) {
                    self._viewDiv.innerHTML = html;
                });

                self.getRenderedHtml(self.CLASS + '-tools', null, function (html) {
                    self.map.div.insertAdjacentHTML('beforeend', html);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-close').addEventListener('click', resetPrinting);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-pdf').addEventListener('click', self.createPdf.bind(self));
                });
            }

            self.orientation = self.div.querySelector("#print-design").value;
            self.format = self.div.querySelector("#print-size").value;

            self.currentFormat = self.CLASS + '-' + self.orientation + '-' + self.format;

            self._viewDiv.classList.remove(TC.Consts.classes.HIDDEN);

            self.map.div.classList.add(self.CLASS + "-printing");
            updateCanvas(self.currentFormat);
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn', print));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('#' + self.CLASS + '-image-qr', function (evt) {
            self.generateLink();
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.createPdf = function () {
        var self = this;

        var loadingCtrl = self.map.getControlsByClass(TC.control.LoadingIndicator)[0];
        var hasWait = loadingCtrl.addWait();

        TC.loadJS(!window.pdfMake, [TC.Consts.url.PDFMAKE], function () {
            const olViewport = self.map.div.querySelectorAll('.ol-viewport');
            for (var i = 0, len = olViewport.length; i < len; i++) {
                const elm = olViewport[i];
                if (!elm.parentElement.classList.contains('ol-overviewmap-map')) {
                    self.canvas = elm.querySelector('canvas');
                    break;
                }
            }

            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            var printLayout = layout.layoutPDF;

            const createPDF = function (printLayout) {
                var filename = window.location.host + '_';
                var title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();

                if (title) {
                    filename += title;
                } else {
                    var currentDate = TC.Util.getFormattedDate(new Date().toString(), true);
                    filename += currentDate;
                }

                try {
                    pdfMake.createPdf(printLayout).download(filename.replace(/[\\\/:*?"<>\|]/g, "") + '.pdf');
                } catch (error) {
                    self.map.toast(self.getLocaleString('print.error'), { type: TC.Consts.msgType.ERROR });
                    TC.error(error.message + '  ' + error.stack, TC.Consts.msgErrorMode.EMAIL);
                }

                loadingCtrl.removeWait(hasWait);
            };

            const imageErrorHandling = function (imageUrl) {
                TC.error(self.getLocaleString('print.error'));
                TC.error('No se ha podido generar el base64 correspondiente a la imagen: ' + imageUrl, TC.Consts.msgErrorMode.EMAIL, 'Error en la impresión'); //Correo de error
            };

            const getLogo = function () {

                const onLogoError = function () {
                    var logoColumn = getLogoColumn(layout);
                    delete logoColumn.image;
                    logoColumn.text = "";
                    return logoColumn;
                };

                if (self.options.logo) {
                    return TC.Util.imgToDataUrl(self.options.logo, 'image/png').then(function (result) {
                        const canvas = result.canvas;
                        const dataUrl = result.dataUrl;
                        var size = TC.Util.calculateAspectRatioFit(canvas.width, canvas.height, layout.logoWidth, layout.logoHeight);

                        var logoColumn = getLogoColumn(layout);
                        //URI: si no se define la anchura en el layout calcula la anchura en función de proporción entre ancho y alto de la imagen y el alto de su posición en el PDF
                        if (!logoColumn.width)
                            logoColumn.width = (canvas.width / canvas.height) * logoColumn.height;
                        logoColumn.image = dataUrl;
                        return logoColumn;

                    }, function () {
                        imageErrorHandling(self.options.logo);

                        return onLogoError();
                    });
                } else {
                    return onLogoError();
                }
            };
            const getScaleBar = function () {
                const onError = function () {
                    var scaleBarColumn = getScaleBarColumn(layout);
                    delete scaleBarColumn.image;
                    scaleBarColumn.text = "";
                    scaleBarColumn.width = "auto";
                    return scaleBarColumn;
                };

                var scaleCtrl = self.map.getControlsByClass(TC.control.ScaleBar)[0];
                if (scaleCtrl) {
                    var elem = document.getElementsByClassName("ol-scale-line-inner"); // no cogemos el DIV del control ya que contiene los bordes y suman al ancho total
                    var bounding = elem[0].getBoundingClientRect();
                    if (bounding) {
                        var styling = getComputedStyle(elem[0], null);
                        var leftBorder = parseInt(styling.getPropertyValue('border-left-width').replace('px', '')) || 0;
                        var rightBorder = parseInt(styling.getPropertyValue('border-right-width').replace('px', '')) || 0;

                        var scaleBarColumn = getScaleBarColumn(layout);

                        scaleBarColumn.table = {
                            widths: [((bounding.width > bounding.height ? bounding.width : bounding.height) - leftBorder - rightBorder) * 0.75], // lo pasamos a pt
                            body: [
                                [{ border: [true, false, true, true], text: scaleCtrl.getText(), fontSize: 10, alignment: 'center' }]
                            ]
                        };

                        scaleBarColumn.layout = {
                            paddingLeft: function (i, node) { return 0; },
                            paddingRight: function (i, node) { return 0; },
                            paddingTop: function (i, node) { return 0; },
                            paddingBottom: function (i, node) { return 0; }
                        };

                        return scaleBarColumn;
                    } else {
                        return onError();
                    }
                } else {
                    return onError();
                }
            };
            const getLegend = function () {
                var content = [];
                var layers = self.map.workLayers.filter(function (layer) {
                    return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
                });
                var legendByGroup = [];
                var indentationIncrement = 7;

                var _process = function (value, parentLayer, treeLevel) {
                    if (parentLayer.isVisibleByScale(value.name)) { //Si la capa es visible, la mostramos en la leyenda
                        var src,
                            srcBase64;

                        //Para las capas cargadas por POST (por ejemplo la búsquedas de Comercio Pamplona)
                        if (parentLayer.options && parentLayer.options.params && parentLayer.options.params.base64LegendSrc) {
                            srcBase64 = parentLayer.options.params.base64LegendSrc;
                        }
                        else if (value.legend) {
                            src = value.legend.src;
                        }

                        result.push({ src: src, title: value.title, level: treeLevel, srcBase64: srcBase64 });
                    }
                };
                var _traverse = function (o, func, parentLayer, treeLevel) {
                    if (Array.isArray(o)) {
                        for (var i = 0; i < o.length; i++) {
                            _traverse(o[i], func, parentLayer, treeLevel);
                        }
                    } else {
                        if (o && o.hasOwnProperty('children') && o.children.length > 0) {
                            if (o.title && o.name) {
                                result.push({ header: o.title, level: treeLevel });
                            }
                            _traverse(o.children, func, parentLayer, ++treeLevel);
                        }
                    }

                    if (o && o.hasOwnProperty('children') && o.children.length == 0) {
                        func.apply(this, [o, parentLayer, treeLevel]);
                        treeLevel--;
                    }
                };
                var _getLegendImages = function () {
                    var imagePromises = [];

                    for (var i = 0; i < legendByGroup.length; i++) {
                        var layers = legendByGroup[i].layers;

                        for (var j = 0; j < layers.length; j++) {
                            (function (k, l) {
                                var layer = legendByGroup[k].layers[l];
                                var src = layer.src || layer.srcBase64;

                                if (src) {

                                    if (!TC.tool || !TC.tool.Proxification) {
                                        TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
                                    }

                                    imagePromises.push(new Promise(function (resolve, reject) {
                                        var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: true });
                                        toolProxification.fetchImage(src, { exportable: true }).then(function (img) {
                                            if (img.complete) {
                                                var imageDetail = TC.Util.imgTagToDataUrl(img, 'image/png');
                                                layer.image = { base64: imageDetail.base64, canvas: imageDetail.canvas };
                                            } else {
                                                imageErrorHandling(src);
                                            }

                                            resolve();

                                        }, function (error) {
                                            imageErrorHandling(src);
                                            reject();
                                        });
                                    }));
                                }
                            })(i, j);
                        }
                    }

                    return imagePromises;
                };

                layers.forEach(function (layer) {
                    result = [];

                    var hideTree = layer.options.hideTree;

                    layer.tree = null;
                    layer.options.hideTree = true;

                    _traverse(layer.getTree(), _process, layer, 0);

                    layer.options.hideTree = hideTree;

                    if (result.length > 0) {
                        legendByGroup.push({ title: layer.title, layers: result });
                    }
                });

                return new Promise(function (resolve, reject) {
                    Promise.all(_getLegendImages()).then(function () {

                        const getGroupTable = function (group, index) {                            
                            var rows = [[{ text: group.title, colSpan: 2, alignment: 'left', fontSize: 11, margin: [0, index > 0 ? 10 : 0, 0, 5] }, {}]];
                            var indentation = 10;

                            rows = rows.concat(group.layers.filter(function (item) {
                                return item.hasOwnProperty('header') && item.header.trim().toLowerCase() !== group.title.trim().toLowerCase();
                            }).map(function (item) {
                                return [{ text: item.header.trim(), colSpan: 2, alignment: 'left', margin: [indentation * item.level, 0, 0, 3] }, {}];
                            }));

                            const headerRows = rows.length;
                            var headerItem = null;
                            var itemIndex = null;

                            const getLayerTable = function (item, index) {
                                if (item.header) {
                                    headerItem = item;

                                    if (itemIndex) {
                                        itemIndex = null;
                                    }
                                } else {
                                    if (!itemIndex) {
                                        itemIndex = 1;
                                    }

                                    var position;
                                    if (headerItem) {
                                        var headerIndex = rows.map(function (item) { return item[0].text }).indexOf(headerItem.header);
                                        position = headerIndex + itemIndex++;
                                    }

                                    if (item.image) {
                                        var imageWidth = item.image.canvas.width / 2;
                                        var imageHeight = (imageWidth * item.image.canvas.height / item.image.canvas.width);

                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            width: 'auto',
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {
                                            image: item.image.base64,
                                            width: imageWidth,
                                            height: imageHeight,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }

                                    } else {
                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            colSpan: 2,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {}];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }
                                    }
                                }
                            };

                            group.layers.forEach(getLayerTable);

                            content.push({
                                layout: 'noBorders',
                                table: {
                                    dontBreakRows: true,
                                    keepWithHeaderRows: 1,
                                    headerRows: headerRows,
                                    body: rows
                                }
                            });
                        };

                        legendByGroup.map(function (group, index) {
                            return {
                                groupIndex: index,
                                height: group.layers.filter(function (item) {
                                    return item.image && item.image.canvas;
                                }).reduce(function (prev, current, index, vector) {
                                    return prev + vector[index].image.canvas.height;
                                }, 0)
                            }
                        }).sort(function (a, b) {
                            if (a.height > b.height) {
                                return 1;
                            }
                            if (a.height < b.height) {
                                return -1;
                            }
                            return 0;
                        }).forEach(function (groupWithHeight, index) {
                            getGroupTable(legendByGroup[groupWithHeight.groupIndex], index)
                        });

                        resolve(content);

                    }, function () {
                        reject([]);
                    });
                });
            };
            const drawQR = function () {
                // GLS: añadimos el QR
                //QR
                if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                    const qrTarget = document.querySelector('.' + self.CLASS + '-qrcode');
                    qrTarget.innerHTML = '';
                    return self.makeQRCode(qrTarget, options.qrCode.sideLength, options.qrCode.sideLength).then(function (qrCodeBase64) {
                        if (qrCodeBase64) {
                            return TC.Util.addToCanvas(self.canvas, qrCodeBase64, { x: self.canvas.width - options.qrCode.sideLength, y: self.canvas.height - options.qrCode.sideLength }, {width: options.qrCode.sideLength, height: options.qrCode.sideLength }).then(function (mapCanvas) {
                                return mapCanvas;
                            });
                        } else {
                            TC.error(self.getLocaleString('print.qr.error'));
                            return self.canvas;
                        }
                    });
                } else {
                    return self.canvas;
                }
            };

            const basics = [getLogo, function () {
                var titleColumn = getTitleColumn(layout);
                titleColumn.text = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                return titleColumn;
            }, getScaleBar, drawQR];

            Promise.all(basics.map(function (fn) {
                return fn();
            })).then(function (basicsDone) {

                if (basicsDone[2].table) { // GLS: ajustamos el ancho del título para arrinconar la escala
                    layout.layoutPDF.content[0].columns[1].width = layout.layoutPDF.pageSize.width - (layout.layoutPDF.pageMargins[0] + layout.layoutPDF.pageMargins[2]) - layout.layoutPDF.content[0].columns[0].width - (layout.layoutPDF.content[0].columns[2].table.widths[0] + 2);
                }

                var mapPlace = getMap(layout);
                var canvas = basicsDone[3] || self.canvas;

                mapPlace.image = canvas.toDataURL();

                if (self.options.legend &&
                    self.options.legend.visible &&
                    hasLegendToPrint.call(self) && // GLS: validamos que haya capas visibles por escala 
                    printLayout.content.length == 2) { // GLS: es la primera descarga o hemos resetado la leyenda por algún zoom por lo que no tenemos la leyenda en el layout

                    const title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                    printLayout.content.push({
                        pageBreak: 'before',
                        pageOrientation: self.options.legend.orientation || 'portrait',
                        text: title.length > 0 ? title : '',
                        fontSize: 14,
                        margin: [0, 20, 0, 10]
                    });

                    getLegend().then(function (content) {
                        printLayout.content = printLayout.content.concat(content);
                        createPDF(printLayout);
                    });
                } else {
                    createPDF(printLayout);
                }
            });
        });
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const alertElm = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
            alertElm.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
        } else {
            alertElm.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.RESULTTOOLTIP = 'resulttooltip.tc';
TC.Consts.event.RESULTTOOLTIPEND = 'resulttooltipend.tc';
TC.Consts.event.DRAWCHART = 'drawchart.tc';
TC.Consts.event.DRAWTABLE = 'drawtable.tc';
TC.Consts.event.RESULTSPANELMIN = 'resultspanelmin.tc';
TC.Consts.event.RESULTSPANELMAX = 'resultspanelmax.tc';
TC.Consts.event.RESULTSPANELCLOSE = 'resultspanelclose.tc';

TC.control.ResultsPanel = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.wrap = new TC.wrap.control.ResultsPanel(self);

    self.data = {};
    self.classes = {
        FA: 'fa',
        SHOW_IN: 'showIn',
        SHOW_OUT: 'showOut'
    };

    self.contentType = {
        TABLE: {
            fnOpen: TC.control.ResultsPanel.prototype.openTable,
            collapsedClass: '.fa-list-alt'
        },
        CHART: {
            fnOpen: TC.control.ResultsPanel.prototype.openChart,
            collapsedClass: '.fa-area-chart'
        }
    };

    self.content = self.contentType.TABLE;

    if (TC.Util.isEmptyObject(self.options)) {
        self.options = { content: "table" };
    }

    if (self.options || { content: "table" }) {
        if (self.options.content)
            self.content = self.contentType[self.options.content.toUpperCase()];

        if (self.options.chart)
            self.chart = self.options.chart;

        if (self.options.table)
            self.table = self.options.table;

        if (self.options.save)
            self.save = self.options.save;
    }
};

TC.inherit(TC.control.ResultsPanel, TC.Control);

(function () {

    const ctlProto = TC.control.ResultsPanel.prototype;

    ctlProto.CLASS = 'tc-ctl-p-results';

    ctlProto.template = {};

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 215,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ResultsPanel.html";
        ctlProto.template[ctlProto.CLASS + '-table'] = TC.apiLocation + "TC/templates/ResultsPanelTable.html";
        ctlProto.template[ctlProto.CLASS + '-chart'] = TC.apiLocation + "TC/templates/ResultsPanelChart.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"prpanel-group prsidebar-body \" style=\"display: none\" data-no-cb><div class=\"prpanel prpanel-default\"><div class=\"prpanel-heading\"><h4 class=\"prpanel-title\"><span class=\"prpanel-title-text\"></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-close\" title=\"").h("i18n", ctx, {}, { "$key": "close" }).w("\"><i class=\"fa fa-times\"></i></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-min\" title=\"").h("i18n", ctx, {}, { "$key": "hide" }).w("\"><i class=\"fa fa-chevron-left\"></i></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-csv\" hidden title=\"").h("i18n", ctx, {}, { "$key": "export.excel" }).w("\"><i class=\"fa fa-file-excel-o\"></i></span></h4></div><div id=\"results\" class=\"prpanel-collapse collapse in\"><div class=\"tc-ctl-p-results-menu\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-info\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-table\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-chart\"></div></div></div></div><div class=\"prcollapsed prcollapsed-max prcollapsed-pull-left\" style=\"display: none;\" title=\"").h("i18n", ctx, {}, { "$key": "expand" }).w("\" data-no-cb><i class=\"fa-list-alt\" hidden></i><i class=\"fa-area-chart\" hidden></i></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-table'] = function () { dust.register(ctlProto.CLASS + '-table', body_0); function body_0(chk, ctx) { return chk.w("<table class=\"table\" style=\"display:none;\"><thead>").s(ctx.get(["columns"], false), ctx, { "block": body_1 }, {}).w("</thead><tbody>").s(ctx.get(["results"], false), ctx, { "block": body_2 }, {}).w("</tbody></table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<th>").f(ctx.getPath(true, []), ctx, "h").w("</th>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<tr>").h("iterate", ctx, { "block": body_3 }, { "on": ctx.getPath(true, []) }).w("</tr>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<td>").f(ctx.get(["value"], false), ctx, "h").w("</td>"); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-chart'] = function () { dust.register(ctlProto.CLASS + '-chart', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-track-chart\">").x(ctx.get(["msg"], false), ctx, { "else": body_1, "block": body_2 }, {}).w("</div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<span id=\"elevationGain\" >").h("i18n", ctx, {}, { "$key": "geo.trk.chart.elevationGain" }).w(": +").f(ctx.get(["upHill"], false), ctx, "h").w("m, -").f(ctx.get(["downHill"], false), ctx, "h").w("m</span><div class=\"tc-chart\"></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.f(ctx.get(["msg"], false), ctx, "h"); } body_2.__dustBody = !0; return body_0 };
    }

    const isElementVisible = function (elm) {
        const computedStyle = getComputedStyle(elm);
        return (elm && !elm.hidden && computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden');
    };

    ctlProto.isVisible = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(bodyElm) || isElementVisible(maximizeElm);
    };

    ctlProto.isMinimized = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(maximizeElm) && !isElementVisible(bodyElm);
    };

    const manageClassList = function (classElement, toAdd, toRemove) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.classList.add(toAdd);
            elm.classList.remove(toRemove);
        }
    };

    ctlProto.show = function (classElement) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm && elm.style.display === 'none') {
            elm.style.display = '';
        }

        manageClassList.call(self, classElement, self.classes.SHOW_IN, self.classes.SHOW_OUT);
    };

    ctlProto.hide = function (classElement) {
        const self = this;

        manageClassList.call(self, classElement, self.classes.SHOW_OUT, self.classes.SHOW_IN);

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.style.display = 'none';
        }
    };

    ctlProto.doVisible = function () {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);
        self.show('prsidebar-body');
    };

    ctlProto.render = function (callback) {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        return TC.Control.prototype.render.call(self, function () {

            self.mainTitleElm = self.div.querySelector('.prpanel-title-text');

            self.minimizeButton = self.div.querySelector('.prcollapsed-slide-submenu-min');
            self.minimizeButton.addEventListener('click', function () {
                self.minimize();
            });

            self.closeButton = self.div.querySelector('.prcollapsed-slide-submenu-close');
            self.closeButton.addEventListener('click', function () {
                self.close();
            });

            self.maximizeButton = self.div.querySelector('.prcollapsed-max');
            self.maximizeButton.addEventListener('click', function () {
                self.maximize();
            });

            if (self.save) {
                self.saveButton = self.div.querySelector('.prcollapsed-slide-submenu-csv');
                self.saveButton.addEventListener('click', function () {
                    self.exportToExcel();
                });
                self.saveButton.removeAttribute('hidden');
            }

            if (self.content) {
                self.content = self.content;

                if (self.options.titles) {

                    if (self.options.titles.main) {
                        self.mainTitleElm.setAttribute('title', self.options.titles.main);
                        self.mainTitleElm.innerHTML = self.options.titles.main;
                    }

                    if (self.options.titles.max) {
                        self.maximizeButton.setAttribute('title', self.options.titles.max);
                    }
                } else {
                    self.mainTitleElm.setAttribute('title', self.getLocaleString("rsp.title"));
                    self.mainTitleElm.innerHTML = self.getLocaleString("rsp.title");
                }
            }

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            //collapsedElm.hidden = false;
            collapsedElm.classList.add(self.classes.FA);

            self.infoDiv = self.div.querySelector('.' + self.CLASS + '-info');
            self.tableDiv = self.div.querySelector('.' + self.CLASS + '-table');
            //self.$divChart = self._$div.find('.' + self.CLASS + '-chart');
            self.menuDiv = self.div.querySelector('.' + self.CLASS + '-menu');

            if (TC.browserFeatures.touch()) {
                TC.Util.swipe(self.div, {
                    left: function () {
                        self.minimize();
                    }
                });
            }

            if (callback && typeof (callback) === "function")
                callback.call();
        });
    };

    ctlProto.minimize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (!isElementVisible(collapsedElm)) { // ya está minimizado
            collapsedElm.classList.add(self.classes.FA);
            collapsedElm.hidden = false;

            self.hide('prsidebar-body');
            self.show('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMIN, { control: self });
        }
    };

    ctlProto.maximize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) { // ya está maximizado
            collapsedElm.hidden = true;

            self.show('prsidebar-body');
            self.hide('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMAX, { control: self });
        }
    };

    ctlProto.close = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        if (self.chart && self.chart.chart) {
            self.chart.chart = self.chart.chart.destroy();
        }

        const body = self.div.querySelector('.prsidebar-body');
        if (body) {
            body.style.display = 'none';
            self.div.querySelector('.prcollapsed-max').style.display = 'none';

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            collapsedElm.hidden = true;
            collapsedElm.classList.remove(self.classes.FA);

            self.map.trigger(TC.Consts.event.RESULTSPANELCLOSE, { control: self });
        }
    };

    ctlProto.openChart = function (data) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        // Cerramos el resto de los perfiles
        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self;
            })
            .filter(function (ctl) {
                return ctl.options.content === 'chart';
            })
            .forEach(function (ctl) {
                ctl.close();
            });

        if (data) {

            if (data.msg) {
                self.map.toast(data.msg);
            }
            else {
                self.elevationProfileCoordinates = data.coords;
                self.renderElevationProfileChart({
                    data: data,
                    div: self.div.querySelector('.' + ctlProto.CLASS + '-chart')
                });
            }
        } else {
            self.map.toast(options.msg);
        }

        self.map.getLoadingIndicator().hide();
    };

    ctlProto.renderElevationProfileChart = function (options) {
        const self = this;
        options = options || {};
        TC.loadJS(!window.c3,
            TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js',
            function () {
                const data = options.data;
                data.ele = data.ele.map(val => val === null ? 0 : val);
                const div = options.div;
                var locale = TC.Util.getMapLocale(self.map);
                self.getRenderedHtml(ctlProto.CLASS + '-chart', {
                    upHill: data.upHill ? data.upHill.toLocaleString(locale) : '0',
                    downHill: data.downHill ? data.downHill.toLocaleString(locale) : '0'
                }, function (out) {

                    div.innerHTML = out;
                    div.style.display = '';

                    if (self.options.titles) {

                        if (self.options.titles.main) {
                            const titleElm = self.div.querySelector('.prpanel-title-text');
                            titleElm.setAttribute('title', self.options.titles.main);
                            titleElm.innerHTML = self.options.titles.main;
                        }

                        if (self.options.titles.max) {
                            self.div.querySelector('.prcollapsed-max').setAttribute('title', self.options.titles.max);
                        }
                    }
                    var chartOptions = TC.Util.extend({
                        bindto: div.querySelector('.tc-chart'),
                        padding: {
                            top: 0,
                            right: 15,
                            bottom: 0,
                            left: 45,
                        },
                        legend: {
                            show: false
                        }
                    }, self.createChartOptions(data));

                    if (self.chart.tooltip) {
                        chartOptions.tooltip = {
                            contents: function (d) {
                                var fn = self.chart.tooltip;
                                if (typeof (fn) !== "function")
                                    fn = TC.Util.getFNFromString(self.chart.tooltip);
                                return fn.call(eval(self.chart.ctx), d);
                            }
                        }
                    }

                    if (self.chart && self.chart.onmouseout) {
                        chartOptions.onmouseout = function () {
                            var fn = self.chart.onmouseout;
                            if (typeof (fn) !== "function")
                                fn = TC.Util.getFNFromString(self.chart.onmouseout);
                            fn.call(eval(self.chart.ctx));
                        };
                    }

                    chartOptions.onrendered = function () {                        
                        if (TC.Util.isFunction(chartOptions._onrendered)) {
                            chartOptions._onrendered.call(this);
                        }
                        self.map.trigger(TC.Consts.event.DRAWCHART, { control: self, svg: this.svg[0][0], chart: this });
                    };

                    if (window.c3) {

                        if (!c3._isOverriden) {
                            // GLS: Override de la función generateDrawLine y generateDrawArea para establecer otro tipo de interpolación en la línea
                            window.c3.chart.internal.fn.generateDrawLine = function (lineIndices, isSub) {
                                var $$ = this, config = $$.config,
                                    line = $$.d3.svg.line(),
                                    getPoints = $$.generateGetLinePoints(lineIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    yValue = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
                                if (!config.line_connectNull) { line = line.defined(function (d) { return d.value != null; }); }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x = isSub ? $$.x : $$.subX, y = yScaleGetter.call($$, d.id), x0 = 0, y0 = 0, path;
                                    if ($$.isLineType(d)) {
                                        if (config.data_regions[d.id]) {
                                            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                                        } else {
                                            if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                            path = line.interpolate('linear')(values);
                                        }
                                    } else {
                                        if (values[0]) {
                                            x0 = x(values[0].x);
                                            y0 = y(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            window.c3.chart.internal.fn.generateDrawArea = function (areaIndices, isSub) {
                                var $$ = this, config = $$.config, area = $$.d3.svg.area(),
                                    getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    value0 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(0);
                                    },
                                    value1 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(value0).y1(value1);
                                if (!config.line_connectNull) {
                                    area = area.defined(function (d) { return d.value !== null; });
                                }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x0 = 0, y0 = 0, path;
                                    if ($$.isAreaType(d)) {
                                        if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                        path = area.interpolate('linear')(values);
                                    } else {
                                        if (values[0]) {
                                            x0 = $$.x(values[0].x);
                                            y0 = $$.getYScale(d.id)(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            c3._isOverriden = true;
                        }

                        self.chart.chart = c3.generate(chartOptions);
                    }
                });
            }
        );
    };

    const closeOpenedTableResultsPanel = function () {
        const self = this;

        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self && ctl.isVisible();
            })
            .filter(function (ctl) {
                return ctl.options.content !== self.contentType.CHART;
            })
            .forEach(function (ctl) {
                ctl.close();
            });
    };

    ctlProto.openTable = function () {
        var self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        var data = arguments[0];
        if (data) {

            var css;
            if (data.css) {
                css = data.css;
            }
            var callback = data.callback;
            var columns = data.columns, data = data.data;

            if (data && data.length > 0) {
                //Si no recibe columnas, las extrae de las claves del primer objeto de la colección de datos
                if (!columns) {
                    columns = [];
                    for (var k in data[0]) {
                        columns.push(k);
                    }
                }

                //deleteColumns();

                self.tableData = {
                    columns: columns,
                    results: data,
                    css: css,
                    callback: callback
                }
                self.getRenderedHtml(self.CLASS + '-table', self.tableData).then(function (html) {
                    const table = self.div.querySelector('.' + self.CLASS + '-table');
                    const parent = table.parentElement;
                    parent.removeChild(table);
                    table.innerHTML = html;
                    parent.appendChild(table);
                    if (self.tableData.callback) {
                        self.tableData.callback(table);
                    }

                    closeOpenedTableResultsPanel.call(self);

                    self.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
                });

                self.div.querySelector('.' + self.CLASS + '-chart').style.display = 'none';
                self.div.querySelector('.' + self.CLASS + '-info').style.display = 'none';

                self.show('prsidebar-body');
            }
        }

        self.map.getLoadingIndicator().hide();

    };

    ctlProto.open = function (html, container) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        const toCheck = container || self.div.querySelector('.' + self.CLASS + '-table');
        var checkIsRendered = function () {
            var clientRect = toCheck.getBoundingClientRect();
            if (clientRect && clientRect.width > 100) {
                window.cancelAnimationFrame(this.requestIsRendered);

                //closeOpenedTableResultsPanel.call(self);
                this.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
            }
        };

        self.requestIsRendered = window.requestAnimationFrame(checkIsRendered.bind(self));

        const chartElm = self.div.querySelector('.' + self.CLASS + '-chart');
        chartElm.style.display = 'none';
        const tableElm = self.div.querySelector('.' + self.CLASS + '-table');
        tableElm.style.display = 'none';
        const infoElm = self.div.querySelector('.' + self.CLASS + '-info');
        infoElm.style.display = 'none';

        if (html) {
            if (container) {
                self.getTableContainer = function () {
                    return container;
                };
                container.innerHTML = html;
                container.style.display = '';
            } else {
                tableElm.innerHTML = html;
                tableElm.style.display = '';
            }
        }

        const maximizeElm = self.div.querySelector('.prcollapsed-max');

        if (self.options.titles) {

            if (self.options.titles.main) {
                const titleElm = self.div.querySelector('.prpanel-title-text');
                titleElm.setAttribute('title', self.options.titles.main);
                titleElm.innerHTML = self.options.titles.main;
            }

            if (self.options.titles.max) {
                maximizeElm.setAttribute('title', self.options.titles.max);
            }
        }

        if (self.options.classes) {
            if (self.options.classes.collapsed) {
                maximizeElm.querySelector('i.fa-list-alt').classList.add(self.options.classes.collapsed);
            }
        }

        // si está minimizado
        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) {
            self.maximize();
        }

        self.show('prsidebar-body');
        self.hide('prcollapsed-max');

        self.map.getLoadingIndicator().hide();
    };

    ctlProto.createChartOptions = function (options) {
        const self = this;
        var result = {};
        options = options || {};
        const locale = options.locale || TC.Util.getMapLocale(self.map);
        switch (options.chartType) {
            default:
                if (options.ele != null) {
                    const getChartSize = function () {
                        const docWidth = document.documentElement.clientWidth / 100 * 40; // css panel contendor
                        return {
                            height: docWidth > 445 ? options.maxHeight || self.CHART_SIZE.MAX_HEIGHT : options.minHeight || self.CHART_SIZE.MIN_HEIGHT,
                            width: docWidth > 445 ? options.maxWidth || self.CHART_SIZE.MAX_WIDTH : docWidth > 310 ? options.mediumWidth || self.CHART_SIZE.MEDIUM_WIDTH : options.minWidth || self.CHART_SIZE.MIN_WIDTH
                        };
                    };

                    var maxy = Number.NEGATIVE_INFINITY;
                    var miny = Number.POSITIVE_INFINITY;
                    options.ele.forEach(function (y) {
                        if (typeof y === 'number') {
                            maxy = Math.max(y, maxy);
                            miny = Math.min(y, miny);
                        }
                    });

                    const gradId = 'grad' + TC.getUID();

                    result = {
                        data: {
                            x: 'x',
                            columns: [['x'].concat(options.x), ['ele'].concat(options.ele)],
                            types: { 'ele': 'area-spline' }, colors: {
                                "ele": 'url(#' + gradId + ')'
                            }
                        },
                        size: getChartSize(),
                        point: {
                            show: false
                        },
                        axis: {
                            x: {
                                tick: {
                                    outer: false,
                                    count: 5, format: function (d) {
                                        d = d / 1000;
                                        var dist;
                                        var measure;
                                        if (d < 1) {
                                            dist = Math.round(d * 1000);
                                            measure = ' m';
                                        } else {
                                            dist = Math.round(d * 100) / 100;
                                            measure = ' km';
                                        }

                                        dist = dist.toLocaleString(locale);
                                        return dist + measure;
                                    }
                                }
                            },
                            y: {
                                padding: {
                                    top: 0, bottom: 0
                                },
                                max: maxy,
                                min: miny,
                                tick: {
                                    count: 2,
                                    format: function (d) {
                                        return (parseInt(d.toFixed(0)) || 0).toLocaleString(locale) + 'm';
                                    }
                                }
                            }
                        },
                        onresize: function () {
                            this.api.resize(getChartSize());                            
                        }
                    }

                    if (options.time) result.time = ("00000" + options.time.h).slice(-2) + ':' + ("00000" + options.time.m).slice(-2) + ':' + ("00000" + options.time.s).slice(-2);

                    result._onrendered = function () {
                        const svg = this.svg[0][0];
                        var svgDefsElement = svg.getElementsByTagName('defs')[0];
                        var xmlns = "http://www.w3.org/2000/svg";
                        var grad = document.createElementNS(xmlns, "linearGradient");
                        grad.setAttributeNS(null, "id", gradId);
                        grad.setAttributeNS(null, "x1", "0%");
                        grad.setAttributeNS(null, "x2", "0%");
                        grad.setAttributeNS(null, "y1", "0%");
                        grad.setAttributeNS(null, "y2", "100%");
                        grad.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");

                        const stop0 = document.createElementNS(xmlns, "stop");
                        stop0.setAttributeNS(null, "offset", "0%");
                        stop0.setAttributeNS(null, "stop-color", "red");
                        stop0.setAttributeNS(null, "stop-opacity", "0.7");
                        grad.appendChild(stop0);

                        const stop50 = document.createElementNS(xmlns, "stop");
                        stop50.setAttributeNS(null, "offset", "50%");
                        stop50.setAttributeNS(null, "stop-color", "orange");
                        stop50.setAttributeNS(null, "stop-opacity", "0.9");
                        grad.appendChild(stop50);

                        const stop100 = document.createElementNS(xmlns, "stop");
                        stop100.setAttributeNS(null, "offset", "100%");
                        stop100.setAttributeNS(null, "stop-color", "green");
                        stop100.setAttributeNS(null, "stop-opacity", "1");
                        grad.appendChild(stop100);

                        svgDefsElement.appendChild(grad);

                        const d3Node = d3.select(".c3-brush").node();
                        if (d3Node) {
                            d3Node.parentNode.removeChild(d3Node);
                        }

                        d3.select(".c3-event-rects,.c3-event-rects-single")
                            .selectAll("rect")
                            .style("cursor", "pointer")
                            .on("click", function (e) {
                                d3.event.stopPropagation();
                                const point = self.elevationProfileCoordinates[e.index].slice(0, 2);
                                if (point) {
                                    TC.loadJS(!TC.feature || (TC.feature && !TC.feature.Point),
                                        [TC.apiLocation + 'TC/feature/Point'],
                                        function () {
                                            self.map.zoomToFeatures([new TC.feature.Point(point)]);
                                        }
                                    );
                                }
                            });

                        var pattern = d3.select('.c3-axis.c3-axis-x').select('path').attr('d');
                        var match = /^M\d\,(\d)V\dH\d{3}V(\d)$/i.exec(pattern);
                        if (match) { // quitamos las barritas de los extremos del axis-x
                            pattern = pattern.replace(/(M\d\,)\d/i, "$10").replace(/(H\d{3}V)(\d)/i, "$10");
                            d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                        } else {
                            var match = /^M\s\d\s(\d)\sV\s\d\sH\s\d{3}\sV\s(\d)$/i.exec(pattern);
                            if (match) { // quitamos las barritas de los extremos del axis-x
                                pattern = pattern.replace(/(M\s\d\s)\d/i, "$10").replace(/(H\s\d{3}\sV\s)(\d)/i, "$10");
                                d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                            }
                        }

                        const svgRect = svg.getBoundingClientRect();
                        const chartSize = {
                            width: svgRect.width,
                            height: svgRect.height
                        };

                        // ¿es necesario pasar los labels a multiline?
                        var setMultilineLabels = function () {
                            var x = d3.scale.ordinal().rangeRoundBands([0, chartSize.width], .1, .3);
                            d3.select('.c3-axis-x').selectAll('text:not(.c3-axis-x-label)')
                                .call(function (textNode, width) {
                                    textNode.each(function () {
                                        textNode.each(function (d, i) {
                                            if (i == 0) return;

                                            d3text = d3.select(this);
                                            
                                            if (d3text.node().childNodes.length === 1) {                                                
                                                var clone = d3text.select('tspan').node().cloneNode();
                                                var words = d3text.text().split(' ');

                                                d3text.select('tspan').text(words[0]);
                                                clone.textContent = words[1];
                                                var dy = clone.getAttribute('dy');
                                                dy = dy ? parseFloat(clone.getAttribute('dy')) : .71;
                                                dy = dy + 0.18 + 'em';
                                                clone.setAttribute('dy', dy);
                                                d3text.node().appendChild(clone);
                                            }
                                        });
                                    });
                                }, x.rangeBand());
                        };
                        if (!d3.select('.c3-axis-x').node().getBoundingClientRect().width) {

                            if (self.elevationChartLabelsRAF) {
                                window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                self.elevationChartLabelsRAF = undefined;
                            }

                            function hasSize() {
                                if (d3.select('.c3-axis-x').length && !(d3.select('.c3-axis-x').node())) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                }
                                else if (d3.select('.c3-axis-x').length && d3.select('.c3-axis-x').node() &&
                                    !d3.select('.c3-axis-x').node().getBoundingClientRect().width) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                } else {
                                    window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                    self.elevationChartLabelsRAF = undefined;

                                    if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                                        (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                                        setMultilineLabels();
                                    }
                                }
                            }

                            self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                        }
                        else if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                            (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                            setMultilineLabels();
                        }

                        if (!self.isMinimized()) {
                            self.show('prsidebar-body');
                            self.hide('prcollapsed-max');
                        }


                        self.div.querySelector('.' + self.CLASS + '-table').style.display = '';
                        self.div.querySelector('.' + self.CLASS + '-info').style.display = '';
                    }
                }
                else {
                    result = {
                        msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                    };
                }
                break;
        }
        return result;
    };

    const getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.getElevationChartTooltip = function (data) {
        const self = this;
        const coords = self.elevationProfileCoordinates;
        var distance = data[0].x;
        distance = distance / 1000;

        const p = coords[data[0].index];
        var doneTime;
        if (coords[0].length == 4 && coords[0][3] > 0) {
            doneTime = getTime(coords[0][3], p[3]);
        }

        const locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
        const ele = parseInt(data[0].value.toFixed(0)).toLocaleString(locale);
        var dist;
        var measure;
        if (distance < 1) {
            dist = Math.round(distance * 1000);
            measure = ' m';
        } else {
            dist = Math.round(distance * 100) / 100;
            measure = ' km';
        }
        dist = dist.toLocaleString(locale);
        return '<div class="track-elevation-tooltip"><div><span>' + ele + ' m </span><br><span>' + dist + measure + ' </span></div>' + (doneTime ? '<span>' + doneTime.toString + '</span><div/>' : '');
    };

    ctlProto.getTableContainer = function () {
        return this.tableDiv;
    };

    ctlProto.getInfoContainer = function () {
        return this.infoDiv;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv;
    };

    ctlProto.getContainerElement = function () {
        return this.div || null;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.wrap.register(map);

        if (self.openOn) {
            self.map.one(self.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.closeOn) {
            self.map.one(self.closeOn, function (e, args) {
                self.close();
            });
        }

        if (self.options.openOn) {
            self.map.on(self.options.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.options.closeOn) {
            self.map.on(self.options.closeOn, function (e, args) {
                self.close();
            });
        }

        //map.on(TC.Consts.event.VIEWCHANGE, function () {

        //    map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctl) {
        //        return ctl.options.content !== "chart" && ($(ctl.div).find('.' + ctl.CLASS + '-info:visible').length === 1 || $(ctl.div).find('.' + ctl.CLASS + '-table:visible').length === 1);
        //    }).forEach(function (ctl) {
        //        ctl.close();
        //    });
        //});

        return result;
    };

    ctlProto.exportToExcel = function () {
        var _ctl = this;

        var rows = [_ctl.tableData.columns];

        _ctl.tableData.results.forEach(function (value) {
            var row = [];
            for (var k in value) {
                if (value.hasOwnProperty(k) && k !== "Id" && k !== "Geom") { //Las columnas ID y Geom no aparece en la exportaci\u00f3n
                    row.push(value[k]);
                }
            }
            rows.push(row);
        });
        var _fncSave = function (exporter) {
            var fileName = _ctl.save.fileName ? _ctl.save.fileName : 'resultados.xls';
            var title = (_ctl.options.titles && _ctl.options.titles.main ? _ctl.options.titles.main : null);
            exporter.Save(fileName, rows, title);
        }
        if (!TC.Util.ExcelExport) {
            TC.loadJS(true, TC.apiLocation + 'TC/Util.ExcelExport', function () {
                _fncSave(new TC.Util.ExcelExport());
            });
        }
        else {
            _fncSave(new TC.Util.ExcelExport());
        }
    };
})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ScaleBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.ScaleBar, TC.Control);

(function () {
    var ctlProto = TC.control.ScaleBar.prototype;

    ctlProto.CLASS = 'tc-ctl-sb';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.ScaleBar(self);
        }
        self.wrap.render();
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), map.wrap.getMap()]).then(function (objects) {
                objects[1].addControl(self.wrap.ctl);
                resolve(self);
            });
        });
    };

    ctlProto.getText = function () {
        var self = this;

        return self.wrap.getText();
    };

})();
TC.control = TC.control || {};

if (!TC.control.Scale) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Scale');
}

TC.control.ScaleSelector = function () {
    var self = this;

    TC.control.Scale.apply(self, arguments);

    self.scales = null;
};

TC.inherit(TC.control.ScaleSelector, TC.control.Scale);

(function () {
    var ctlProto = TC.control.ScaleSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-ss';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/ScaleSelector.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"ol-scale-line ol-unselectable\"><nobr><select>").s(ctx.get(["scales"], false), ctx, { "block": body_1 }, {}).w("</select> <input type=\"button\" value=\"").f(ctx.get(["screenSize"], false), ctx, "h").w("''\" title=\"").h("i18n", ctx, {}, { "$key": "estimatedMapSize" }).w("\" /></nobr></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<option value=\"").f(ctx.getPath(true, []), ctx, "h").w("\"").h("eq", ctx, { "block": body_2 }, { "key": body_3, "value": body_4 }).w(">1:").h("math", ctx, {}, { "key": body_5, "method": "round" }).w("</option>\n"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" selected=\"true\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.f(ctx.get(["scale"], false), ctx, "h"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h"); } body_5.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        var self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            if (self.map) {
                if (!self.scales && self.map.options.resolutions) {
                    self.scales = self.map.options.resolutions.map(self.getScale, self);
                }
                var render = function () {
                    self.scales = self.map.wrap.getResolutions().map(self.getScale, self);
                    self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize, scales: self.scales }, function () {

                        self.div.querySelectorAll('option').forEach(function (option) {
                            option.textContent = '1:' + self.format(option.textContent.substr(2));
                        });

                        self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

                        self.div.querySelector('select').addEventListener('change', function () {
                            self.setScale(this.value);
                        });
                        if (TC.Util.isFunction(callback)) {
                            callback();
                        }
                        resolve();
                    }).catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
                };
                if (self.scales) {
                    render();
                }
                else {
                    self.map.wrap.getMap().then(render);
                }
            }
            else {
                reject(Error('ScaleSelector no registrado'));
            }
        }));
    };

    /*
    *  setScale: Sets the resolution of the map from a scale denominator and estimated screen DPI
    *  Parameters: number, the scale denominator
    *  Returns: number, the resolution
    */
    ctlProto.setScale = function (scale) {
        var self = this;
        var result = scale * .0254 / self.getDpi(TC.Cfg.screenSize);
        if (window.devicePixelRatio) {
            result = result / window.devicePixelRatio;
        }
        if (self.metersPerDegree) {
            result = result / self.metersPerDegree;
        }
        self.map.wrap.setResolution(result);
        return result;
    };

})();
(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}


var SearchType = function (type, options, parent) {
    var self = this;

    self.parent = parent;

    self._featureTypes = [];

    TC.Util.extend(self, options);

    self.typeName = type;

    self._throwConfigError = function () {
        var self = this;

        throw new Error('Error en la configuración de la búsqueda: ' + self.typeName);
    };

    self.getFeatureTypes = function (toFilter) {
        var self = this;

        if (toFilter) {
            return self.featureType instanceof Array ? self.featureType : [self.featureType];
        }

        if (self._featureTypes.length === 0) {
            var type_featureType = self.featureType instanceof Array ? self.featureType : [self.featureType];
            var type_renderFeatureType = self.renderFeatureType ? self.renderFeatureType instanceof Array ? self.renderFeatureType : [self.renderFeatureType] : [];
            self._featureTypes = type_featureType.concat(type_renderFeatureType);
        }

        return self._featureTypes;
    };

    self.isFeatureOfThisType = function (id) {
        var self = this;

        return self.getFeatureTypes().indexOf(id) > -1;
    };

    self.getStyleByFeatureType = function (featureType) {
        var self = this;

        if (self.getFeatureTypes().indexOf(featureType) > -1) {
            return self.styles[self.getFeatureTypes().indexOf(featureType)];
        }

        return null;
    };

    var getColor = function (css, geomType, featureType) {
        var self = this;

        var getValue = function (style, geomType, css) {
            if (geomType) {
                if (style.hasOwnProperty(geomType) && style[geomType].hasOwnProperty(css)) {
                    return style[geomType][css];
                }
            } else {
                for (var geomType in style) {
                    if (style[geomType].hasOwnProperty(css)) {
                        return style[geomType][css];
                    }
                }
            }
        };

        if (featureType) {
            var style = self.getStyleByFeatureType(featureType);
            return getValue(style, geomType, css);
        } else {
            for (var i = 0; i < self.styles.length; i++) {
                var style = self.styles[i];
                var color = getValue(style, geomType, css);
                if (color) {
                    return color;
                }
            }
        }
    };

    self.getSuggestionListHead = function () {
        var self = this;

        var headerData, label, color;

        if (typeof self.suggestionListHead === "function") {
            headerData = self.suggestionListHead();
            label = headerData.label;
            color = [{
                color: headerData.color,
                title: headerData.label
            }];
        } else {
            headerData = self.suggestionListHead;
            label = self.parent.getLocaleString(headerData.label);

            // color es string que es el atributo CSS. El valor se obtiene de la 1º coincidencia encontrada en styles
            if (typeof headerData.color === "string") {
                color = [{
                    color: getColor.call(self, headerData.color),
                    title: label
                }];
            } else if (headerData.color instanceof Array) { // color es un array de objetos, con nombre de featureType como clave
                var featureTypes = self.getFeatureTypes();
                if (headerData.color.length === featureTypes.length) {
                    color = headerData.color.map(function (elm, i) {
                        return {
                            color: getColor.call(self, elm[featureTypes[i]].color.css, elm[featureTypes[i]].color.geomType, featureTypes[i]),
                            title: self.parent.getLocaleString(elm[featureTypes[i]].title) || label
                        }
                    });
                } else {
                    self._throwConfigError();
                }
            } else if (typeof headerData.color === "object") { // color es un objeto con atributo css y tipo de geometría
                color = [{
                    color: getColor.call(self, headerData.color.css, headerData.color.geomType),
                    title: label
                }];
            }
        }

        if (label && color) {
            var liHTML = '<li header><span class="header">' + label + '</span>';

            liHTML += color.map(function (elm) {
                if (elm.color) {
                    return '<span class="header-color" title="' + elm.title + '" style="color: ' + elm.color + ';"></span>';
                }
            }).join('') + '</li>';

            return liHTML;

        } else {
            self._throwConfigError();
        }
    };

    self.getSuggestionListElements = function (data) {
        var self = this;
        var results = [];

        var areSame = function (a, b) {
            switch (true) {
                case typeof (a) === "number":
                    if (a === b) {
                        return true;
                    }
                    break;
                case typeof (a) === "string":
                    if (!isNaN(a) || !isNaN(b)) {
                        if (a === b) {
                            return true;
                        }
                    } else {
                        if (a.trim() === b.trim()) {
                            return true;
                        }
                    }
                    break;
            }

            return false;
        };
        var getUnique = function (inputArray) {
            var outputArray = [];
            for (var i = 0; i < inputArray.length; i++) {
                if (outputArray.indexOf(inputArray[i]) === -1) {
                    outputArray.push(inputArray[i]);
                }
            }

            return outputArray;
        };
        var intoResults = function (compareData) {
            for (var r = 0; r < results.length; r++) {
                var length = 0;
                var isThere = [];
                for (var property in compareData) {
                    isThere.push(areSame(compareData[property], results[r].properties[property]));
                    length++;
                }
                if (isThere.filter(function (i) { return i; }).length === length) {
                    return true;
                }

            }

            return false;
        };

        var features = self.parseFeatures(data);

        features.forEach(function (feature) {
            var attributes = [], ids = [];
            var valueToAdd = '';

            var properties = self.outputProperties;
            var dataIdProperties = self.dataIdProperty;

            var strFormat = self.outputFormatLabel;
            var dataLayer = feature.id.split('.').slice(0, 1).shift();

            if (!(self.outputProperties instanceof Array)) {
                properties = self.outputProperties[dataLayer];
                dataIdProperties = self.dataIdProperty[dataLayer];
                strFormat = strFormat[dataLayer];
            }

            for (var j = 0; j < properties.length; j++) {
                attributes.push(feature.data[properties[j]]);
            }

            for (var j = 0; j < dataIdProperties.length; j++) {
                ids.push(feature.data[dataIdProperties[j]]);
            }

            var compareData = {};
            for (var p = 0; p < self.outputProperties.length; p++) {
                compareData[self.outputProperties[p]] = attributes[p];
            }

            if (attributes instanceof Array && strFormat && getUnique(attributes).length > 1) {
                valueToAdd = strFormat.tcFormat(attributes);
            }
            else if (attributes instanceof Array && getUnique(attributes).length == 1) {
                valueToAdd = attributes[0];
            }

            var text = valueToAdd.toCamelCase();

            if (!(intoResults(compareData))) {

                results.push({
                    text: text,
                    label: text,
                    id: ids.join('#'),
                    dataRole: self.typeName,
                    dataLayer: dataLayer,
                    properties: compareData
                });
            }
        });

        return results;
    };

    self.parseFeatures = function (data) {
        var parser;
        if (self.outputFormat === TC.Consts.format.JSON) {
            parser = new TC.wrap.parser.JSON();
        }
        else {
            parser = new TC.wrap.parser.WFS({
                featureNS: self.featurePrefix,
                featureType: self.featureType
            });
        }
        return parser.read(data);
    };

    self.getPattern = function () {
        var self = this;

        if (typeof self.pattern === "function") {
            return self.pattern();
        } else {
            return self.pattern;
        }
    };

    self.filter = (function (self) {

        const bindRootFilterNode = function (filtersArr, dataT) {
            var rootFilters = [];

            if (dataT != self.parent.rootCfg.active.root) {
                // GLS: Si llego aquí, significa que el usuario está indicando la población
                if (dataT.indexOf('#') === -1 && !self.parent.rootCfg.active.limit) { // si no está limitada la búsqueda, indico la población

                    var filterNode = self.parent.rootCfg.active.queryProperties.firstQueryWord.map(function (queryWord, index) {
                        return self.filter.getFilterNode(queryWord, self.parent._LIKE_PATTERN + dataT + self.parent._LIKE_PATTERN);
                    });

                    if (filterNode.length > 1) {
                        rootFilters.push('<ogc:And>');
                        rootFilters = rootFilters.concat(filterNode);
                        rootFilters.push('</ogc:And>');
                    } else {
                        rootFilters = rootFilters.concat(filterNode);
                    }

                } else { // por tanto no añado todas las raíces posibles, añado la población que ha indicado (validando antes contra rootLabel)                     
                    var item = dataT.split('#');

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }
            } else {
                for (var i = 0; i < self.parent.rootCfg.active.root.length; i++) {
                    var item = self.parent.rootCfg.active.root[i];

                    if (i == 0 && self.parent.rootCfg.active.root.length > 1) {
                        rootFilters.push('<ogc:Or>');
                    }

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }

                if (self.parent.rootCfg.active.root.length > 1) {
                    rootFilters.push('</ogc:Or>');
                }
            }

            return filtersArr.concat(rootFilters);
        };

        return {
            getPropertyValue: function (role, propertyName) {
                return self.getSearchTypeByRole(role)[propertyName];
            },
            getIsLikeNode: function (name, value) {
                var toEscape = /([\-\"\.\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1)
                    return '<Or><PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toLowerCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike>' +
                        '<PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toUpperCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike></Or>';
                else
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
            },
            getFunctionStrMatches: function (name, value) {
                var toEscape = /([\-\"\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1) {

                    var pattern = value;
                    pattern = pattern.replace(/a/gi, "[aáà]");
                    pattern = pattern.replace(/e/gi, "[eéè]");
                    pattern = pattern.replace(/i/gi, "[iíì]");
                    pattern = pattern.replace(/o/gi, "[oóò]");
                    pattern = pattern.replace(/u/gi, "[uúüù]");

                    return '<ogc:PropertyIsEqualTo> ' +
                        '<ogc:Function name="strMatches"> ' +
                        '<ogc:PropertyName>' + name + '</ogc:PropertyName> ' +
                        '<ogc:Literal>' + '(?i)' + pattern.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</ogc:Literal> ' +
                        '</ogc:Function> ' +
                        '<ogc:Literal>true</ogc:Literal> ' +
                        '</ogc:PropertyIsEqualTo>';
                }
                else {
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
                }
            },
            getFilterNode: function (propertyName, propertyValue) {
                var r;

                var fn = self.filter.getIsLikeNode;

                if (self.filterByMatch) {

                    fn = self.filter.getFunctionStrMatches;

                    var regex = new RegExp('\\' + self.parent._LIKE_PATTERN, 'gi');
                    propertyValue = propertyValue.replace(regex, self.parent._MATCH_PATTERN);
                }

                if (!(propertyName instanceof Array) && (typeof propertyName !== 'string')) {
                    var f = [];
                    for (var key in propertyName) {
                        if ((propertyName[key] instanceof Array) && propertyName[key].length > 1) {
                            r = '<Or>';
                            for (var i = 0; i < propertyName[key].length; i++) {
                                r += fn(propertyName[key][i].trim(), propertyValue);
                            }

                            r += '</Or>';
                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' + r + '</Filter>)');
                        } else {
                            var propName = propertyName[key];
                            if ((propertyName[key] instanceof Array) && propertyName[key].length == 1)
                                propName = propertyName[key][0];

                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' +
                                '<Or>' + fn(propName.trim(), propertyValue) + '</Or>' +
                                '</Filter>)');
                        }
                    }

                    return f.join('');

                } else if (propertyName instanceof Array && propertyName.length > 1) {
                    r = '<ogc:Or>';
                    for (var i = 0; i < propertyName.length; i++) {
                        r += fn(propertyName[i].trim(), propertyValue);
                    }

                    return r += '</ogc:Or>';
                } else
                    return fn((propertyName instanceof Array && propertyName.length === 1 ? propertyName[0].trim() : propertyName.trim()), propertyValue);
            },
            getFilter: function (data) {
                var r = {};
                r.multiL = false;
                r.f = '';

                var _f;

                switch (true) {
                    case self.typeName === TC.Consts.searchType.NUMBER:
                        _f = [];
                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)

                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        else {
                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            } else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }

                        _f.push(self.filter.getFilterNode(self.queryProperties.thirdQueryWord, data.p + self.parent._LIKE_PATTERN));

                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';

                        break;
                    case self.typeName === TC.Consts.searchType.STREET:
                        _f = [];

                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        } else {

                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            }
                            else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    case self.typeName === TC.Consts.searchType.LOCALITY:
                        r.f = self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN);
                        r.multiL = true;
                        break;                                            // GLS: consulta de 2 niveles (carretera con pk / topónimo con municipio)
                    case self.queryProperties.hasOwnProperty('secondQueryWord'):
                        var _f = [];
                        _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                        _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    default: // GLS: consulta de 1 único nivel (municipio, casco urbano, carretera)
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN) + '</ogc:Filter>';
                        break;
                }

                return r;
            },
            getParams: function (data) {
                var filters = self.filter.getFilter(data);

                var params = {
                    REQUEST: 'GetFeature',
                    SERVICE: 'WFS',
                    MAXFEATURES: 500,
                    VERSION: self.version,
                    OUTPUTFORMAT: self.outputFormat
                };

                var featureTypes = self.getFeatureTypes(true);
                if (!(featureTypes instanceof Array))
                    params.TYPENAME = self.featurePrefix ? self.featurePrefix + ':' + featureTypes.trim() : featureTypes.trim();
                else {
                    var ft = [];
                    for (var i = 0; i < featureTypes.length; i++) {
                        ft.push(self.featurePrefix ?
                            self.featurePrefix + ':' + featureTypes[i].trim() :
                            featureTypes[i].trim());
                    }

                    params.TYPENAME = ft.join(',');
                }

                var _getProperties = function (properties) {
                    if ((properties || '') !== '') {
                        if (!(properties instanceof Array)) {
                            var p = [];
                            if (properties instanceof Object) {
                                for (var key in properties) {
                                    var prop = properties[key][0];
                                    if (properties[key].length > 1)
                                        prop = properties[key].join(',');

                                    p.push(prop);
                                }
                            }
                            return p;
                        }
                        else
                            return properties.join(',');
                    }
                };
                var _properties = _getProperties(self.outputProperties);
                var _ids = _getProperties(self.dataIdProperty);

                if (_properties instanceof Array && _ids instanceof Array) {
                    params.PROPERTYNAME = '';
                    for (var i = 0; i < _properties.length; i++) {
                        params.PROPERTYNAME += '(' + _properties[i] + ',' + _ids[i] + ')';
                    }
                } else
                    params.PROPERTYNAME = _properties + ',' + _ids;

                params.FILTER = filters.f;

                return TC.Util.getParamString(params);
            },
            getGoToFilter: function (id) {
                var props = [];
                var _id = id.split('#');

                var source = self.dataIdProperty;
                var dataLayer = self.getFeatureTypes();

                if (source && dataLayer) {

                    if (id.indexOf('#') > -1 && dataLayer instanceof Array && dataLayer.length > 1) {
                        for (var i = 0; i < dataLayer.length; i++) {

                            for (var j = 0; j < source[dataLayer[i]].length; j++) {
                                props.push({ name: source[dataLayer[i]][j], value: _id[j] });
                            }
                        }
                    } else if (id.indexOf('#') == -1 && dataLayer instanceof Array) {
                        var src = source;

                        for (var i = 0; i < dataLayer.length; i++) {
                            if (!props.hasOwnProperty(dataLayer[i])) {

                                if (src instanceof Object && source.hasOwnProperty(dataLayer[i]))
                                    src = source[dataLayer[i]];

                                for (var j = 0; j < src.length; j++) {
                                    if (j < _id.length)
                                        props.push({ name: src[j], value: _id[j] });
                                }
                            }
                        }
                    }
                    else {
                        if (source instanceof Object && source.hasOwnProperty(dataLayer)) {
                            source = source[dataLayer];
                        }

                        for (var i = 0; i < source.length; i++) {
                            props.push({ name: source[i], value: _id[i] });
                        }
                    }
                }

                return self.filter.transformFilter(props);
            },
            transformFilter: function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }
        }
    })(self);
};

TC.control.Search = function () {
    var self = this;
    TC.Control.apply(self, arguments);

    self.exportsState = true;

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';

    self.url = '//idena.navarra.es/ogc/wfs';
    self.version = '1.1.0';
    self.featurePrefix = 'IDENA';

    if (self.options && self.options.url) {
        self.url = self.options.url;
    }

    self._LIKE_PATTERN = '*';
    self._MATCH_PATTERN = '.*';

    self.UTMX = 'X';
    self.UTMY = 'Y';
    self.LON = 'Lon';
    self.LAT = 'Lat';

    self.UTMX_LABEL = 'X: ';
    self.UTMY_LABEL = 'Y: ';
    self.LON_LABEL = 'Lon: ';
    self.LAT_LABEL = 'Lat: ';

    self.MUN = 'Mun';
    self.POL = 'Pol';
    self.PAR = 'Par';

    self.MUN_LABEL = 'Mun: ';
    self.POL_LABEL = 'Pol: ';
    self.PAR_LABEL = 'Par: ';

    self.availableSearchTypes = {};

    self.availableSearchTypes[TC.Consts.searchType.CADASTRAL] = {
        suggestionRoot: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        searchWeight: 3,
        featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
        municipality: {
            featureType: 'CATAST_Pol_Municipio',
            labelProperty: 'MUNICIPIO',
            idProperty: 'CMUNICIPIO'
        },
        queryProperties: {
            firstQueryWord: 'CMUNICIPIO',
            secondQueryWord: 'POLIGONO',
            thirdQueryWord: 'PARCELA'
        },
        suggestionListHead: {
            label: "search.list.cadastral",
            color: [
                {
                    CATAST_Pol_ParcelaUrba: {
                        title: "search.list.cadastral.urban",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaRusti: {
                        title: "search.list.cadastral.rustic",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaMixta: {
                        title: "search.list.cadastral.mixed",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                }
            ]
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#136278',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#0c8b3d',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#e5475f',
                    strokeWidth: 2,
                    strokeOpacity: 1
                },
            }
        ],
        parser: self.getCadastralRef,
        goTo: self.goToCadastralRef,
        goToIdFormat: self.MUN + '{0}' + self.POL + '{1}' + self.PAR + '{2}',
        idPropertiesIdentifier: '#'
    };

    self.availableSearchTypes[TC.Consts.searchType.COORDINATES] = {
        parser: self.getCoordinates,
        goTo: self.goToCoordinates,
        searchWeight: 4,
        label: null,
        suggestionListHead: function (text) {
            return {
                label: self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label || self.getLocaleString('search.list.coordinates')
            };
        }
    };

    self.queryProperties = {
        QUERYWORD: 'QueryWord',
        FIRST: 'first',
        SECOND: 'second',
        THIRD: 'third'
    };

    self.availableSearchTypes[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        url: '//idena.navarra.es/ogc/wfs',
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
        },
        suggestionListHead: {
            label: "search.list.municipality",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        searchWeight: 1,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fe06a5',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.MUNICIPALITY]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    //self.availableSearchTypes[TC.Consts.searchType.LOCALITY] = {
    //    root: null,
    //    limit: false,
    //    url: self.url || '//idena.navarra.es/ogc/wfs',
    //    version: self.version || '1.1.0',
    //    outputFormat: TC.Consts.format.JSON,
    //    featurePrefix: self.featurePrefix || 'IDENA',
    //    geometryName: 'the_geom',
    //    featureType: ['CATAST_Pol_Municipio', 'ESTADI_Pol_EntidadPob'],
    //    renderFeatureType: ['CATAST_Pol_Municipio'],
    //    dataIdProperty: {
    //        CATAST_Pol_Municipio: ['CMUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['CMUNICIPIO', 'CENTIDAD']
    //    },
    //    queryProperties: {
    //        firstQueryWord: {
    //            CATAST_Pol_Municipio: ['MUNINOAC', 'MUNICIPIO'],
    //            ESTADI_Pol_EntidadPob: ['ENTINOAC', 'ENTIDAD']
    //        }
    //    },
    //    suggestionListHead: {
    //        label: "search.list.locality",
    //        color: "strokeColor"
    //    },
    //    outputProperties: {
    //        CATAST_Pol_Municipio: ['MUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['MUNICIPIO', 'ENTIDAD']
    //    },
    //    outputFormatLabel: {
    //        CATAST_Pol_Municipio: '{0}',
    //        ESTADI_Pol_EntidadPob: '{1} ({0})'
    //    },
    //    searchWeight: 1,
    //    styles: [
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0,
    //                strokeColor: '#ffffff',
    //                strokeWidth: 5,
    //                strokeOpacity: 1
    //            }
    //        },
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0.1,
    //                strokeColor: '#feba1e',
    //                strokeWidth: 2,
    //                strokeOpacity: 1
    //            }
    //        }
    //    ],
    //    parser: self.getStringPattern.bind(this, [TC.Consts.searchType.LOCALITY]),
    //    goTo: self.goToStringPattern
    //};

    self.availableSearchTypes[TC.Consts.searchType.COUNCIL] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Concejo',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CCONCEJO'],
        queryProperties: {
            firstQueryWord: ['CONCEJO']
        },
        outputProperties: ['MUNICIPIO', 'CONCEJO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 4,
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.COUNCIL]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern,
        idPropertiesIdentifier: '#',
        suggestionListHead: {
            label: "search.list.council",
            color: "strokeColor"
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#49006a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.STREET] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        renderFeatureType: 'CATAST_Txt_Calle',
        featureType: 'CATAST_Lin_CalleEje',
        dataIdProperty: ['CVIA'],
        searchWeight: 5,
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
            secondQueryWord: ['VIA', 'VIANOAC']
        },
        suggestionListHead: {
            label: "search.list.street",
            color: "strokeColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1}, {0}',
        styles: [
            {
                line: {
                    strokeColor: "#CB0000",
                    strokeOpacity: 1,
                    strokeWidth: 2,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            },
            {
                point: {
                    label: "VIA",
                    angle: "CADANGLE",
                    fontColor: "#000000",
                    fontSize: 10,
                    fontWeight: "bold",
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.STREET]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.NUMBER] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Txt_Portal',
        renderFeatureType: '',
        searchWeight: 6,
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
        queryProperties: {
            firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
            secondQueryWord: ['VIA', 'VIANOAC'],
            thirdQueryWord: ['PORTAL']
        },
        suggestionListHead: {
            label: "search.list.number",
            color: "fontColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1} {2}, {0}',
        styles: [
            {
                point: {
                    radius: 0,
                    label: "PORTAL",
                    angle: "CADANGLE",
                    fontColor: "#CB0000",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.NUMBER]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.URBAN] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'ESTADI_Pol_EntidadPob',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDAD']
        },
        suggestionListHead: {
            label: "search.list.urban",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO', 'ENTIDAD'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 2,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#feba1e',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.URBAN]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAME] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 7,
        /*filterByMatch: true, // si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "CADTEXT",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAME]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAMEMUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['MUNICIPIO', 'MUNINOAC'],
            secondQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 8,
        /*filterByMatch: true, si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "CADTEXT",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAMEMUNICIPALITY]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.COMMONWEALTH] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['POLUCI_Pol_MancoRSUg'],
        renderFeatureType: '',
        dataIdProperty: ['CMANCOMUNI'],
        queryProperties: {
            firstQueryWord: ['MANCOMUNID']
        },
        outputProperties: ['MANCOMUNID'],
        outputFormatLabel: '{0}',
        searchWeight: 9,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fc4e2a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.ROAD] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Lin_CtraEje',
        dataIdProperty: ['DCARRETERA'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA']
        },
        suggestionListHead: {
            label: "search.list.road",
            color: "strokeColor"
        },
        outputProperties: ['DCARRETERA'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': ' + '{0}',
        searchWeight: 10,
        styles: [
            {
                polygon: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5
                },
                line: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            }
        ],
        parser: self.getRoad,
        goTo: self.goToRoad,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))$", "i")
        }
    };

    self.availableSearchTypes[TC.Consts.searchType.ROADPK] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Sym_CtraPK',
        dataIdProperty: ['DCARRETERA', 'CPK'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA'],
            secondQueryWord: ['PK']
        },
        suggestionListHead: {
            label: "search.list.pk.larger",
            color: "fontColor"
        },
        outputProperties: ['DCARRETERA', 'PK'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': {0} ' + self.getLocaleString('search.list.pk') + ': {1}',
        searchWeight: 11,
        styles: [
            {
                point: {
                    label: ["DCARRETERA", "PK"],
                    fontColor: "#00b2fc",
                    fontSize: 14,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2
                }
            }
        ],
        parser: self.getPK,
        goTo: self.goToPK,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))\\s*\\,*\\s*(?:(?:" + self.getLocaleString("search.list.pk") + "\\:?)|(?:P\\:?)|(?:K\\:?)|(?:KM\\:?)|(?:\\s+|\\,+))\\s*(\\d{1,4})$", "i")
        }
    };

    self.rootCfg = {};
    self.rootCfg[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNICIPIO']
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {

                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO'].concat(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].root.map(function (elem) {
                        return ['CMUNICIPIO'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.MUNICIPALITY].url + '?' + TC.Util.getParamString(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (response) {
                        const data = response.data;
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                }
            });
        }
    };
    self.rootCfg[TC.Consts.searchType.LOCALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['ESTADI_Pol_EntidadPob'],
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC'],
        queryProperties: {
            firstQueryWord: ['ENTINOAC']
        },
        outputProperties: ['ENTINOAC'],
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {
                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.LOCALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.LOCALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.LOCALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.LOCALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO', 'CENTIDAD'].concat(self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.LOCALITY].root.map(function (elem) {
                        return ['CMUNICIPIO', 'CENTIDAD'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.LOCALITY].url + '?' + TC.Util.getParamString(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (response) {
                        const data = response.data;
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO', 'CENTIDAD'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                }
            });
            return done;
        }
    };

    self.allowedSearchTypes = [];

    if (self.options.allowedSearchTypes) {
        for (var allowed in self.options.allowedSearchTypes) {

            if (self.availableSearchTypes[allowed] && !TC.Util.isEmptyObject(self.options.allowedSearchTypes[allowed])) {

                // GLS: gestionamos el override de featureType y renderFeatureType.
                // Si por defecto cuenta con renderFeatureType y sobrescribe featureType y no renderFeatureType, 
                // elimino la propiedad renderFeatureType y elimino el último estilo definido, que se corresponde con el de renderFeatureType.
                if (self.availableSearchTypes[allowed].renderFeatureType && self.availableSearchTypes[allowed].renderFeatureType.length > 0 &&
                    self.options.allowedSearchTypes[allowed].featureType && !self.options.allowedSearchTypes[allowed].renderFeatureType) {

                    delete self.availableSearchTypes[allowed].renderFeatureType;
                    self.availableSearchTypes[allowed].styles = self.availableSearchTypes[allowed].styles.slice(0, self.availableSearchTypes[allowed].styles.length - 1);
                }

                // GLS: override de la configuración por defecto con la del config.JSON
                TC.Util.extend(self.availableSearchTypes[allowed], self.options.allowedSearchTypes[allowed]);


                // GLS: Limitamos la búsqueda en portales y calles cuando así se establezca en la configuración de las búsquedas
                if (self.options.allowedSearchTypes[allowed].root &&
                    (allowed != TC.Consts.searchType.MUNICIPALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.MUNICIPALITY) ||
                    (allowed != TC.Consts.searchType.LOCALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.LOCALITY)) {

                    self.rootCfg.active = self.rootCfg[self.options.allowedSearchTypes[allowed].rootType];
                    self.rootCfg.active.root = self.options.allowedSearchTypes[allowed].root;
                    self.rootCfg.active.limit = self.options.allowedSearchTypes[allowed].limit;

                    self.availableSearchTypes[TC.Consts.searchType.STREET].queryProperties.firstQueryWord =
                        self.availableSearchTypes[TC.Consts.searchType.NUMBER].queryProperties.firstQueryWord =
                        self.rootCfg.active.dataIdProperty;
                }
            }

            // Si esta a false lo borramos de las disponibles
            if (!self.options.allowedSearchTypes[allowed]) {
                delete self.options.allowedSearchTypes[allowed];
            } else {
                self.addAllowedSearchType(allowed, self.availableSearchTypes[allowed] ? self.availableSearchTypes[allowed] : self.options.allowedSearchTypes[allowed], self);
            }
        }
    }

    if (self.rootCfg.active) {
        self.rootCfg.active.getRootLabel();
    }

    self.queryableFeatures = self.options.queryableFeatures || false;

    self.UTMX_LEN = 6;
    self.UTMY_LEN = 7;

    self.wrap = new TC.wrap.control.Search(self);

    self.interval = 500;

    self.NORMAL_PATTERNS = {
        ROMAN_NUMBER: /M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}){1,}?\S?\./i,
        ABSOLUTE_NOT_DOT: /[`~!@#$%^&*_|+\=?;:'"\{\}\[\]\\]/gi,
        ABSOLUTE: /[`~!@#$%^&*_|+\=?;:'.\{\}\[\]\\]/gi
    };
};

TC.inherit(TC.control.Search, TC.Control);

(function () {
    var ctlProto = TC.control.Search.prototype;

    ctlProto.CLASS = 'tc-ctl-search';

    TC.Consts.event.SEARCHQUERYEMPTY = TC.Consts.event.SEARCHQUERYEMPTY || 'searchqueryempty.tc';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Search.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "search.1" }).w("</h2><div class=\"tc-ctl-search-content\"><input type=\"search\" class=\"tc-ctl-search-txt\" placeholder=\"").h("i18n", ctx, {}, { "$key": "search.placeholder" }).w("\" title=\"").h("i18n", ctx, {}, { "$key": "search.instructions" }).w("\" /><button title=\"").h("i18n", ctx, {}, { "$key": "search.instructions" }).w("\" class=\"tc-ctl-btn tc-ctl-search-btn\">").h("i18n", ctx, {}, { "$key": "search.2" }).w("</button><ul class=\"tc-ctl-search-list tc-hidden\"></ul></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self._search = {
            data: []
        };

        self.layerStyleFN = (function () {
            function getFeatureType(idFeature) {
                return idFeature.indexOf('.') > -1 ? idFeature.split('.')[0] : idFeature;
            };
            function getStyle(property, geomType, id) {

                var type = self.getSearchTypeByFeature(id);
                if (type) {
                    var style = type.getStyleByFeatureType(getFeatureType(id));

                    if (style && style.hasOwnProperty(geomType)) {
                        return style[geomType][property];
                    }
                }

                return TC.Cfg.styles[geomType][property];
            };

            return function (geomType, property, extractValue, f) {
                var self = this;

                if (TC.Feature && !(f instanceof TC.Feature)) {
                    self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, geom: f.geom });
                }

                var prop = getStyle(property, geomType, getFeatureType(f.id));
                if (extractValue) {
                    if (prop instanceof Array) {
                        var values = prop.map(function (p) {
                            return f.getData().hasOwnProperty(p) ? f.getData()[p] : '';
                        });
                        var searchType = this.getSearchTypeByFeature(getFeatureType(f.id));
                        if (searchType) {
                            return searchType.outputFormatLabel.tcFormat(values);
                        } else {
                            return values.join(' ');
                        }
                    } else {
                        return f.getData().hasOwnProperty(prop) ? f.getData()[prop] : '';
                    }
                }
                else {
                    return prop;
                }
            };
        }());

        var styleFN = self.layerStyleFN;

        self.layerPromise = map.addLayer({
            id: self.getUID(),
            title: 'Búsquedas',
            stealth: true,
            declutter: true,
            type: TC.Consts.layerType.VECTOR,
            styles: {
                polygon: {
                    fillColor: styleFN.bind(self, 'polygon', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'polygon', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'polygon', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'polygon', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'polygon', 'strokeWidth', false)
                },
                line: {
                    strokeColor: styleFN.bind(self, 'line', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'line', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'line', 'strokeWidth', false)
                },
                marker: {
                    anchor: TC.Defaults.styles.marker.anchor,
                    height: TC.Defaults.styles.marker.height,
                    width: TC.Defaults.styles.marker.width
                },
                point: {
                    radius: styleFN.bind(self, 'point', 'radius', false),
                    height: styleFN.bind(self, 'point', 'height', false),
                    width: styleFN.bind(self, 'point', 'width', false),
                    fillColor: styleFN.bind(self, 'point', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'point', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'point', 'strokeColor', false),
                    strokeWidth: styleFN.bind(self, 'point', 'strokeWidth', false),
                    fontSize: styleFN.bind(self, 'point', 'fontSize', false),
                    fontColor: styleFN.bind(self, 'point', 'fontColor', false),
                    labelOutlineColor: styleFN.bind(self, 'point', 'labelOutlineColor', false),
                    labelOutlineWidth: styleFN.bind(self, 'point', 'labelOutlineWidth', false),
                    label: styleFN.bind(self, 'point', 'label', true),
                    angle: styleFN.bind(self, 'point', 'angle', true)
                }
            }
        })
            .then(function (layer) {
                self.layer = layer;
                return layer;
            });

        self.EMPTY_RESULTS_LABEL = self.getLocaleString('noResults');
        self.EMPTY_RESULTS_TITLE = self.getLocaleString('checkCriterion');
        self.OUTBBX_LABEL = self.getLocaleString('outsideOfLimits');

        self.WFS_TYPE_ATTRS = ["url", "version", "geometryName", "featurePrefix", "featureType", "properties", "outputFormat"];

        return result;
    };

    ctlProto.renderData = function (data, callback) {
        var self = this;

        self._search = self._search || {};

        var _search = function () {
            self.search(self.textInput.value, function (list) {
                if (list.length === 1) {
                    self.textInput.value = list[0].label;
                    self._goToResult(list[0].id, self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
                else if (list.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
            });
        };

        return TC.Control.prototype.renderData.call(self, data, function () {

            // desde keypress y desde la lupa
            var _research = function () {
                self.textInput.value = self.resultsList.label || self.resultsList.querySelector('li:not([header]) > a > span').textContent;
                self.lastPattern = self.textInput.value;
                self._goToResult(self.resultsList.id || unescape(self.resultsList.querySelector('li:not([header]) > a').getAttribute('href')).substring(1), self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            };

            self.textInput = self.div.querySelector('input.tc-ctl-search-txt');
            if (self.options && self.options.placeHolder) {
                self.textInput.setAttribute('placeHolder', self.options.placeHolder.trim());
            }

            self.resultsList = self.div.querySelector('.tc-ctl-search-list');
            self.button = self.div.querySelector('.tc-ctl-search-btn');
            self.button.addEventListener(TC.Consts.event.CLICK, function () {
                self.getLayer().then(function (l) {
                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length > 1) { }
                    else if (l.features.length > 0) {
                        l.map.zoomToFeatures(l.features);
                    }
                    else if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    }
                    else {
                        self.textInput.dispatchEvent(new Event("keyup"));
                    }
                });
            });
            if (self.options.instructions) {
                self.textInput.setAttribute('title', self.options.instructions.trim());
                self.button.setAttribute('title', self.options.instructions.trim());
            }

            // GLS: añadimos la funcionalidad al mensaje de "No hay resultados", al hacer click repliega el mensaje.
            self.resultsList.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('a.tc-ctl-search-li-empty', function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                self.textInput.focus();
            }));

            self.textInput.addEventListener('keypress', function (e) {
                if (e.which == 13) {
                    e.preventDefault();
                    e.stopPropagation();

                    self.lastPattern = "";

                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    } else {
                        _search();
                    }
                    return false;
                }
            });
            self.textInput.addEventListener("search", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("input", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("targetCleared.autocomplete", function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            })
            self.textInput.addEventListener("targetUpdated.autocomplete", function () {
                if (self.resultsList.querySelectorAll('li').length > 0) {
                    self.resultsList.classList.remove(TC.Consts.classes.HIDDEN);
                }
            });

            self.lastPattern = '';
            self.retryTimeout = null;
            TC.loadJS(
                !TC.UI || !TC.UI.autocomplete,
                [TC.apiLocation + 'TC/ui/autocomplete.js'],
                function () {
                    var searchDelay;

                    const source = function (text, callback) {
                        self.lastpress = performance.now();

                        if (!searchDelay) {
                            function step() {
                                var criteria = self.textInput.value.trim();

                                if (criteria.length > 0 &&
                                    (!self.lastPattern || criteria != self.lastPattern) &&
                                    performance.now() - self.lastpress > self.interval) {

                                    window.cancelAnimationFrame(searchDelay);
                                    searchDelay = undefined;

                                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);

                                    // Pendiente de afinar
                                    //if (self.lastPattern && criteria.substring(0, criteria.lastIndexOf(' ')) == self.lastPattern) {                                            

                                    //    // Si el patrón de búsqueda anterior y actual es el mismo más algo nuevo (típico en la búsqueda de un portal), lo nuevo lo separo por coma
                                    //    // self.lastPattern: "Calle Cataluña/Katalunia Kalea, Pamplona"
                                    //    // text: "Calle Cataluña/Katalunia Kalea, Pamplona 18"

                                    //    criteria = criteria.substring(0, criteria.lastIndexOf(' ')) + (self.lastPattern.trim().endsWith(',') ? "" : ",") + criteria.substring(criteria.lastIndexOf(' '));
                                    //}

                                    self.lastPattern = criteria;

                                    self.search(criteria, callback);
                                } else {
                                    searchDelay = requestAnimationFrame(step);
                                }
                            }

                            searchDelay = requestAnimationFrame(step);
                        }
                    };

                    var closest = function (el, selector) {
                        const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

                        while (el) {
                            if (matchesSelector.call(el, selector)) {
                                return el;
                            } else {
                                el = el.parentElement;
                            }
                        }
                        return null;
                    };

                    const callback = function (e) {
                        var _target = e.target;

                        if (e.target.tagName.toLowerCase() !== 'a') {
                            _target = closest(e.target, 'a');
                        }

                        if (_target.querySelector('span[hidden]')) {
                            self.textInput.value = _target.querySelector('span[hidden]').textContent;
                            self.lastPattern = self.textInput.value;
                            self._goToResult(unescape(_target.getAttribute('href')).substring(1), _target.parentNode.getAttribute('dataRole'));
                            TC.UI.autocomplete.call(self.textInput, 'clear');
                        }
                    };

                    const buildHTML = function (results) {

                        var html = [];
                        var dataRoles = [];

                        var reA = /[^a-zA-Z]/g;
                        var reN = /[^0-9]/g;
                        function sortAlphaNum(a, b) {
                            var AInt = parseInt(a, 10);
                            var BInt = parseInt(b, 10);

                            if (isNaN(AInt) && isNaN(BInt)) {
                                var aA = a.replace(reA, "");
                                var bA = b.replace(reA, "");
                                if (aA === bA) {
                                    var aN = parseInt(a.replace(reN, ""), 10);
                                    var bN = parseInt(b.replace(reN, ""), 10);
                                    return aN === bN ? 0 : aN > bN ? 1 : -1;
                                } else {
                                    return aA > bA ? 1 : -1;
                                }
                            } else if (isNaN(AInt)) {//A is not an Int
                                return 1;//to make alphanumeric sort first return -1 here
                            } else if (isNaN(BInt)) {//B is not an Int
                                return -1;//to make alphanumeric sort first return 1 here
                            } else {
                                return AInt > BInt ? 1 : -1;
                            }
                        };

                        // ordenamos por roles y alfabéticamente
                        var data = results.results.sort(function (a, b) {
                            if (this.ctx.getSearchTypeByRole(a.dataRole).searchWeight && this.ctx.getSearchTypeByRole(b.dataRole).searchWeight) {
                                if ((this.ctx.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (this.ctx.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                    return 1;
                                } else if ((this.ctx.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (this.ctx.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                    return -1;
                                }
                                else {
                                    return sortAlphaNum(a.label, b.label);
                                }
                            } else {
                                if (a.dataRole > b.dataRole) {
                                    return 1;
                                }
                                else if (a.dataRole < b.dataRole)
                                    return -1;
                                else {
                                    return sortAlphaNum(a.label, b.label);
                                }
                            }
                        }.bind(this));

                        if (self.rootCfg.active) {// si hay root, aplicamos el orden por entidades 
                            data = data.sort(function (a, b) {

                                const sort_ = function () {
                                    var first = this.rootCfg.active.root[0] instanceof Array ? this.rootCfg.active.root[0].join('-') : this.rootCfg.active.root[0];

                                    var aRoot, bRoot;
                                    if (a.properties && a.properties.length > 0 && b.properties && b.properties.length > 0) {
                                        aRoot = this.rootCfg.active.dataIdProperty.map(function (elem) { return a.properties[elem].toString(); }).join('-');
                                        bRoot = this.rootCfg.active.dataIdProperty.map(function (elem) { return b.properties[elem].toString(); }).join('-');
                                    } else {
                                        aRoot = a.id;
                                        bRoot = b.id;
                                    }

                                    if (aRoot !== first && bRoot === first) {
                                        return 1;
                                    } else if (aRoot === first && bRoot !== first) {
                                        return -1;
                                    } else {
                                        return sortAlphaNum(a.label, b.label);
                                    }
                                }.bind(this);

                                if (this.getSearchTypeByRole(a.dataRole).searchWeight && this.getSearchTypeByRole(b.dataRole).searchWeight) {
                                    if ((this.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (this.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                        return 1;
                                    } else if ((this.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (this.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                        return -1;
                                    }
                                    else {
                                        return sort_();
                                    }
                                }
                                else {
                                    return sort_();
                                }

                            }.bind(self));
                        }

                        for (var i = 0; i < data.length; i++) {
                            var elm = data[i];

                            if (dataRoles.indexOf(elm.dataRole) == -1) {

                                var type = this.ctx.getSearchTypeByRole(elm.dataRole);

                                html[html.length] = type.getSuggestionListHead();

                                dataRoles.push(elm.dataRole);
                            }

                            const highlighting = function () {
                                var highlighted = elm.label;
                                var strReg = [];

                                // eliminamos caracteres extraños del patrón ya analizado

                                if (this.ctx.lastPattern.trim().length === 0 && self.textInput.value.trim().length > 0) {
                                    this.ctx.lastPattern = self.textInput.value.trim();                                    
                                }

                                var normalizedLastPattern = this.ctx.lastPattern;
                                if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(normalizedLastPattern))
                                    normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
                                else
                                    normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');


                                var querys = [];
                                var separatorChar = ',';
                                if (normalizedLastPattern.indexOf(separatorChar) == -1) {
                                    separatorChar = ' ';
                                }

                                querys = normalizedLastPattern.trim().split(separatorChar);                                

                                // si estamos tratando con coordenadas el separador es el espacio, no la coma
                                if ((elm.label.indexOf(this.ctx.LAT_LABEL) > -1 && elm.label.indexOf(this.ctx.LON_LABEL) > -1) ||
                                    (elm.label.indexOf(this.ctx.UTMX_LABEL) > -1 && elm.label.indexOf(this.ctx.UTMY_LABEL) > -1)) {
                                    querys = this.ctx.lastPattern.split(' ');

                                    for (var t = 0; t < querys.length; t++) {
                                        if (querys[t].trim().slice(-1) == ',')
                                            querys[t] = querys[t].slice(0, -1);
                                    }
                                }

                                for (var q = 0; q < querys.length; q++) {
                                    if (querys[q].trim().length > 0) {
                                        strReg.push('(' + querys[q].trim().replace(/\(/gi, "").replace(/\)/gi, "") + ')');
                                        var match = /((\<)|(\>)|(\<\>))/gi.exec(querys[q].trim());
                                        if (match) {
                                            var _strReg = querys[q].trim().replace(/((\<)|(\>)|(\<\>))/gi, '').split(' ');
                                            for (var st = 0; st < _strReg.length; st++) {
                                                if (_strReg[st].trim().length > 0)
                                                    strReg.push('(' + _strReg[st].trim().replace(/\(/gi, "\\(").replace(/\)/gi, "\\)") + ')');
                                            }
                                        }
                                    }
                                }

                                if (elm.dataRole == TC.Consts.searchType.ROAD || elm.dataRole == TC.Consts.searchType.ROADPK) {
                                    var rPattern = self.getSearchTypeByRole(elm.dataRole).getPattern();
                                    var match = rPattern.exec(this.ctx.lastPattern);

                                    if (match) {
                                        strReg = [];

                                        if (match[2] && match[3] && match[4]) {
                                            strReg.push('(' + match[2] + "-" + match[3] + "-" + match[4] + ')');
                                        } else if (match[2] && match[3]) {
                                            strReg.push('(' + match[2] + "-" + match[3] + ')');
                                        } else if (match[3] && match[4]) {
                                            strReg.push('(' + match[3] + "-" + match[4] + ')');
                                        } else if (match[2] || match[3]) {
                                            strReg.push('(' + (match[2] || match[3]) + ')');
                                        }

                                        if (match[5]) {
                                            strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
                                        }
                                    } else if (match && match[5]) {
                                        strReg = [];

                                        strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
                                    }
                                }

                                var pattern = '(' + strReg.join('|') + ')';

                                pattern = pattern.replace(/á|à/gi, "a");
                                pattern = pattern.replace(/é|è/gi, "e");
                                pattern = pattern.replace(/í|ì/gi, "i");
                                pattern = pattern.replace(/ó|ò/gi, "o");
                                pattern = pattern.replace(/ú|ù/gi, "u");
                                pattern = pattern.replace(/ü/gi, "u");

                                pattern = pattern.replace(/a/gi, "[a|á|à]");
                                pattern = pattern.replace(/e/gi, "[e|é|è]");
                                pattern = pattern.replace(/i/gi, "[i|í|ì]");
                                pattern = pattern.replace(/o/gi, "[o|ó|ò]");
                                pattern = pattern.replace(/u/gi, "[u|ú|ü|ù]");
                                var rex = new RegExp(pattern, "gi");

                                var label = elm.label;

                                if (elm.dataRole !== TC.Consts.searchType.ROAD || elm.dataRole !== TC.Consts.searchType.ROADPK) {
                                    highlighted = label.replace(rex,
                                        function () {
                                            var params = Array.prototype.slice.call(arguments, 0);                                            

                                            if (params[params.length - 3]) {
                                                return params[0].replace(params[params.length - 3], "<b>" + params[params.length - 3] + "</b>");
                                            } else {
                                                return "<b>" + params[0] + "</b>";
                                            }
                                        });
                                } else {
                                    highlighted = label.replace(rex, "<b>$1</b>");
                                }

                                return highlighted;
                            }.bind(this);

                            html[html.length] = '<li dataRole="' + elm.dataRole + '"><a href="' + '#' + encodeURIComponent(elm.id) + '"><span hidden>' + elm.label + '</span>' + highlighting() + '</a></li>';
                        }



                        return html.join('');
                    };

                    TC.UI.autocomplete.call(self.textInput, {
                        link: '#',
                        target: self.resultsList,
                        minLength: 2,
                        ctx: self,
                        source: source,
                        callback: callback,
                        buildHTML: buildHTML
                    });                    

                    var getNextSibling = function (elem, selector) {

                        // Get the next sibling element
                        var sibling = elem.nextElementSibling;

                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;

                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.nextElementSibling
                        }

                    };

                    var getPreviousSibling = function (elem, selector) {

                        // Get the next sibling element
                        var sibling = elem.previousElementSibling;

                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;

                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.previousElementSibling;
                        }

                    };

                    // Detect up/down arrow
                    const onKeydown = function (e) {
                        if (!e.ctrlKey && !e.altKey && !e.shiftKey) {
                            if (e.keyCode === 40) { // down arrow
                                if (self.textInput == document.activeElement && self.resultsList.querySelector('li:not([header]) a')) {
                                    // Scenario 1: We're focused on the search input; move down to the first li
                                    self.resultsList.querySelector('li:not([header]) a').focus();
                                } else if (self.resultsList.querySelector('li:not([header]):last-child a') === document.activeElement) { //} else if (self.resultsList.querySelector('li:not([header]):last a').is(':focus')) {
                                    // Scenario 2: We're focused on the last li; move up to search input
                                    self.textInput.focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the last element, simply move down
                                    getNextSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();                                    
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            } else if (e.keyCode === 38) { // up arrow
                                if (self.textInput == document.activeElement) {
                                    // Scenario 1: We're focused on the search input; move down to the last li
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else if (document.activeElement == self.resultsList.querySelector('li:not([header]) a')) {
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the first element, simply move up
                                    getPreviousSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();                                    
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            }
                        }
                        e.stopPropagation();
                    };

                    self.textInput.addEventListener('keydown', onKeydown);
                    self.resultsList.addEventListener('keydown', onKeydown);
                }
            );

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.addAllowedSearchType = function (name, options) {
        var self = this;

        self.allowedSearchTypes.push(new SearchType(name, options, self));
    };

    ctlProto.getSearchTypeByRole = function (type) {
        var self = this;

        return self.allowedSearchTypes.filter(function (allowed) {
            return allowed.typeName == type;
        })[0];
    };

    ctlProto.getSearchTypeByFeature = function (id) {
        var self = this;

        var type = self.allowedSearchTypes.filter(function (allowed) {
            return allowed.isFeatureOfThisType(id);
        });

        if (type.length > 0) {
            return type[0];
        }

        return null;
    };

    ctlProto.getElementOnSuggestionList = function (id, dataRole) {
        const self = this;

        for (var i = 0; i < self._search.data.length; i++) {
            if (self._search.data[i].id == id && (!dataRole || (dataRole && self._search.data[i].dataRole === dataRole)))
                return self._search.data[i];
        }
    };

    ctlProto.getLayer = function () {
        const self = this;
        return self.layerPromise;
    };

    ctlProto.getFeatures = function () {
        const self = this;
        return self.layer.features;
    };

    ctlProto.cleanMap = function () {
        const self = this;

        if (self.layer) {
            const l = self.layer;
            var features = l.features.slice();
            l.clearFeatures();

            self.map.trigger(TC.Consts.event.FEATUREREMOVE, { layer: l, feature: features });

            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                if (l.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                    delete l[self.WFS_TYPE_ATTRS[i]];
            }
        }
    };

    ctlProto.getMunicipalities = function () {
        var self = this;

        TC.cache.search = TC.cache.search || {};
        self._municipalitiesPromise = new Promise(function (resolve, reject) {
            if (TC.cache.search.municipalities) {
                resolve(TC.cache.search.municipalities);
            }
            else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

                if (type.municipality && type.municipality.featureType && type.municipality.labelProperty && type.municipality.idProperty) {
                    var params = {
                        REQUEST: 'GetFeature',
                        SERVICE: 'WFS',
                        TYPENAME: type.municipality.featureType,
                        VERSION: type.version,
                        PROPERTYNAME: type.municipality.labelProperty + "," + type.municipality.idProperty,
                        OUTPUTFORMAT: type.outputFormat
                    };
                    if (type.featurePrefix) {
                        params.TYPENAME = type.featurePrefix + ':' + params.TYPENAME;
                    }
                    var url = type.url + '?' + TC.Util.getParamString(params);
                    TC.ajax({
                        url: url,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (response) {
                        const data = response.data;
                        var parser;
                        if (type.outputFormat === TC.Consts.format.JSON) {
                            parser = new TC.wrap.parser.JSON();
                        }
                        else {
                            parser = new TC.wrap.parser.WFS({
                                featureNS: type.municipality.featurePrefix,
                                featureType: type.municipality.featureType
                            });
                        }
                        var features = parser.read(data);
                        TC.cache.search.municipalities = [];
                        for (var i = 0; i < features.length; i++) {
                            var feature = features[i];
                            TC.cache.search.municipalities.push({ label: feature.data[type.municipality.labelProperty], id: feature.data[type.municipality.idProperty] });
                        }

                        TC.cache.search.municipalities.sort(function (a, b) {
                            var result;
                            if (a.label < b.label) {
                                result = -1;
                            }
                            else if (a.label > b.label) {
                                result = 1;
                            }
                            else {
                                result = 0;
                            }
                            return result;
                        });

                        resolve(TC.cache.search.municipalities);
                    }).catch(function () {
                        resolve();
                    });
                } else {
                    throw new Error("Error en la configuración de la búsqueda: " + type.typeName + ". Error en el objeto municipality");
                }
            }
        });
        return self._municipalitiesPromise;
    };

    ctlProto.getCoordinates = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp('^' + self.UTMX_LABEL.trim().toLowerCase() + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + self.UTMY_LABEL.trim().toLowerCase() + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[2];
            }

            match = pattern.match(new RegExp('^' + self.LAT_LABEL.trim().toLowerCase() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LON_LABEL.trim().toLowerCase() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[3];
            }

            if (/\d/.test(pattern) && (new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').test(pattern) || /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.test(pattern))) {
                match = /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.exec(pattern);
                if (match && (match[1].indexOf(',') > -1 || match[3].indexOf(',') > -1)) {
                    match[1] = match[1].replace(',', '.');
                    match[3] = match[3].replace(',', '.');

                    pattern = match[1] + ' ' + match[3];
                }

                if (!match || match && ((match[1].indexOf(',') > -1 ? match[1].replace(',', '.') : match[1]) <= 180) && ((match[3].indexOf(',') > -1 ? match[3].replace(',', '.') : match[3]) <= 90)) {

                    match = new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').exec(pattern);
                    if (match && (match[1].indexOf(',') > -1 || match[2].indexOf(',') > -1)) {
                        match[1] = match[1].replace(',', '.');
                        match[2] = match[2].replace(',', '.');

                        pattern = match[1] + ' ' + match[2];
                    }

                    // parse coordinates
                    pattern = pattern.replace(self.UTMX_LABEL, '').replace(self.UTMY_LABEL, '').replace(self.LON_LABEL, '').replace(self.LAT_LABEL, '');
                    var coords = TC.Util.parseCoords(pattern);
                    if (coords) {
                        var xValue = coords[0].value;
                        var yValue = coords[1].value;
                        var xLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                        var yLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                        var id = xLabel + xValue + yLabel + yValue;

                        var point = self.getPoint(id);
                        if (point && !self.insideLimit(point)) {
                            xValue = coords[1].value;
                            yValue = coords[0].value;
                            xLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                            yLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                            id = xLabel + xValue + yLabel + yValue;
                            point = self.getPoint(id);
                        }

                        if (point) {
                            self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.test(id) ? self.getLocaleString('search.list.coordinates.utm') + self.map.crs : self.getLocaleString('search.list.coordinates.geo');

                            //console.log('getCoordinates promise resuelta');
                            resolve([{
                                id: id, label: self.getLabel(id), dataRole: TC.Consts.searchType.COORDINATES
                            }]);
                        }
                        else {
                            //console.log('getCoordinates promise resuelta');
                            resolve([]);
                        }
                    } else {
                        //console.log('getCoordinates promise resuelta');
                        resolve([]);
                    }
                } else {
                    //console.log('getCoordinates promise resuelta');
                    resolve([]);
                }
            } else {
                //console.log('getCoordinates promise resuelta');
                resolve([]);
            }
        });
    };

    ctlProto.getCadastralRef = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp(self.MUN_LABEL.trim().toLowerCase() + '?\\s(.*)\\,\\s?' + self.POL_LABEL.trim().toLowerCase() + '?\\s(\\d{1,2})\\,\\s?' + self.PAR_LABEL.trim().toLowerCase() + '?\\s(\\d{1,4})'));
            if (match) {
                pattern = match[1] + ', ' + match[2] + ', ' + match[3];
            }

            var _pattern = pattern;
            if (!(/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(pattern)) && self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot)
                _pattern = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot + ', ' + pattern;

            if (/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(_pattern) && !(new RegExp('^([0-9]{' + self.UTMX_LEN + '})\\s*\\,\\s*([0-9]{' + self.UTMY_LEN + '})$').test(pattern))) {
                self.getMunicipalities().then(function (list) {
                    var match = /^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.exec(_pattern);
                    if (match) {
                        var matcher = new RegExp(match[1].trim().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
                        var results = [];

                        const getItem = function (mun, munLabel, pol, par) {
                            var properties = [];

                            properties.push[self.MUN] = mun;
                            properties.push[self.POL] = pol;
                            properties.push[self.PAR] = par;

                            return {
                                id: self.MUN + mun + self.POL + pol + self.PAR + par,
                                label: self.getLabel(self.MUN + munLabel + self.POL + pol + self.PAR + par),
                                dataRole: TC.Consts.searchType.CADASTRAL,
                                properties: properties
                            };
                        };

                        results = list.filter(function (value) {
                            value = value.label || value.id || value;
                            return matcher.test(value) || matcher.test(self.removePunctuation(value));
                        });

                        if (results.length > 0) {
                            for (var i = 0; i < results.length; i++) {
                                results[i] = getItem(results[i].id, results[i].label, match[2].trim(), match[3].trim());
                            }
                        }

                        if (/^[0-9]*$/g.test(match[1])) {

                            if (match[1].trim() === self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot) {

                                var suggestionRoot = list.filter(function (elm) {
                                    return parseInt(elm.id) === parseInt(self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot);
                                })[0];

                                if (suggestionRoot) {
                                    resolve([getItem(suggestionRoot.id, suggestionRoot.label, match[2].trim(), match[3].trim())]);
                                }
                            }

                            results.push(getItem(match[1].trim(), match[1].trim(), match[2].trim(), match[3].trim()));
                        }

                        //console.log('getCadastralRef promise resuelta');
                        resolve(results);
                    }
                });
            } else {
                //console.log('getCadastralRef promise resuelta - no es ref catastral');
                resolve([]);
            }
        });
    };

    ctlProto.stringPatternsValidators = {
        tsp: function (text, result, root, limit) {
            // town, street, portal - street, town, portal
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) {

                var getPortal = function () {
                    return formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[2].trim(), s: match[1].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[1].trim())) result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[1].trim(), t: match[2].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        spt: function (text, result, root, limit) {
            // street, portal, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);
            if (match && match[6] && match[1]) {

                var getPortal = function () {
                    return formatStreetNumber((match[2] || match[3] || match[4] || match[5]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[6].trim()) && /^([^0-9]+)$/i.test(match[1].trim())) {
                    result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[1].trim(), s: match[6].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[6].trim())) result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[6].trim(), t: match[1].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        tnsp: function (text, result, root, limit) {
            // town, numbers street, portal
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);

            if (match && match[1] && match[2]) {
                result.push({
                    t: match[2].trim(), s: match[1].trim(), p: formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim())
                });
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        ts: function (text, result, root, limit) {
            // town, street
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(text);

            // topónimo, municipio
            if (!match && /^[^0-9]*$/i.test(text.trim())) { // si no hay números reviso dándole la vuelta, si hay números que lo trate la función st
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match && match[1] && match[2]) {
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim()
                    });
                    result.push({
                        s: match[1].trim(), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit);
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles

                    var getStreet = function (s) {
                        var revS = s.split(' ').reverse();
                        // validamos si el criterio es compuesto 
                        var fs = [];
                        for (var si = 0; si < revS.length; si++) {
                            if (revS[si].length == 1) {
                                fs.push(revS[si]);
                                revS[si] = '';
                            }
                        }

                        return fs.length > 0 ? revS.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : revS.reverse().join(' ').trim();
                    };

                    if (/^([^0-9]+)$/i.test(match[1].trim()))
                        result.push({
                            t: match[1].trim(), s: getStreet(match[2].trim())
                        });
                    else result.push({
                        s: getStreet(match[1].trim()), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit, true);
                }

                return true;
            }

            return false;
        },
        st: function (text, result, root, limit) {
            // street, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);

            if (!match) {
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match) { // puede generar falsos positivos cuando el portal llega seguido de la calle -> calle mayor 14, pamplona
                var data = {
                };
                var criteria = text.split(',').reverse();
                for (var i = 0; i < criteria.length; i++) {
                    if (/^([^0-9\,]+)$/i.test(criteria[i].trim())) { // si no hay números se trata de municipio
                        data.t = criteria[i].trim();
                    }
                    else if (/(\s*\d+)/i.test(criteria[i].trim())) { // si contiene número, puede ser calle o calle + portal
                        if (criteria[i].trim().indexOf(' ') == -1) { // si no contiene espacios se trata de calle compuesta por números
                            data.s = criteria[i].trim();
                        } else { // si contiene espacio puede contener calle + portal
                            var _criteria = criteria[i].trim().split(' ').reverse();

                            var isPortal = function (c) {
                                var m = /^(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(c.trim());
                                if (m) {
                                    data.p = formatStreetNumber(c.trim());
                                    return true;
                                }
                                return false;
                            };

                            var x = 0;
                            var p = _criteria[x].trim();
                            while (x < _criteria.length && !isPortal(p)) {
                                x++;
                                if (x < _criteria.length)
                                    p = p + _criteria[x];

                            }

                            if (data.p) {
                                var _cr = _criteria;
                                for (var h = 0; h < _cr.length; h++) {
                                    // validamos que lo que hemos deducido como portal, está en portal para no añadirlo a calle
                                    var inPortal = false;
                                    for (var c = 0; c < _cr[h].split('').length; c++) {
                                        if (data.p.indexOf(_cr[h][c]) > -1)
                                            inPortal = true;
                                    }

                                    if (inPortal) {
                                        var _p = _cr[h];

                                        _cr[h] = '';
                                        if (data.p == formatStreetNumber(p))
                                            break;
                                    }
                                }

                                if (/^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+)$/i.test(_criteria.reverse().join(' ').trim())) {
                                    var fs = [];
                                    var criteriaRev = _criteria.reverse();
                                    for (var chs = 0; chs < criteriaRev.length; chs++) {
                                        if (criteriaRev[chs].trim().length == 1) {
                                            fs.push(criteriaRev[chs].trim());
                                            criteriaRev[chs] = '';
                                        }
                                    }

                                    data.s = fs.length > 0 ? criteriaRev.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : criteriaRev.reverse().join(' ').trim();
                                }


                                // nombre_de_calle = 137, 1, 20...
                                // duplico la búsqueda para el caso de [Calle nombre_de_calle], municipio
                                result.push({
                                    t: data.t,
                                    s: data.s + ' ' + data.p
                                });
                            } else {
                                data.s = criteria[i].trim();
                            }
                        }
                    }
                }

                result.push(data);
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        s_or_t: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9\<\>]+)$/i.exec(text);
            if (match && match[1]) {
                if (root) {
                    result.push({
                        t: match[1].trim()
                    });

                    result.push({
                        t: root,
                        s: match[1].trim()
                    });
                }
                else result.push({
                    t: match[1].trim()
                });
                return true;
            }

            return false;
        },
        sp: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/]+)\s*\,?\s*((\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) { // && text.indexOf(',') > -1 && text.split(',').length < 3) {
                if (root)
                    result.push({
                        t: root,
                        s: match[1].trim(),
                        p: formatStreetNumber(match[2].trim())
                    });
                else
                    result.push({
                        t: match[1].trim(),
                        s: match[2].trim()
                    });

                return true;
            }

            return false;
        },
        snp: function (text, result, root, limit) { // calle puede contener números con portal (cuando exista un municipio root establecido)
            var match = /^([^\,][0-9\s*\-\.\(\)\/]+)\s*\,?\s*(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(text);
            if (match && match[1] && match[2] && root) {
                result.push({
                    t: root,
                    s: match[1].trim(),
                    p: formatStreetNumber(match[2].trim())
                });
                return true;
            }

            return false;
        }
    };

    /* métodos auxiliares de getStringPattern */

    const normalizedCriteria = function (value) {
        const self = this;

        var _value = '';

        value = self.removePunctuation(value);

        // elimino los caracteres especiales
        if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(value))
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
        else
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');
        return value.toLowerCase();
    };

    const formatStreetNumber = function (value) {
        var result = value;

        var is_nc_c = function (value) {
            return /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.test(value);
        }
        var nc_c = function (value) {
            var f = [];
            var m = /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_cn = function (value) {
            return /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.test(value);
        };
        var cn = function (value) {
            var f = [];
            var m = /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_sn = function (value) {
            return /^(sn|S\/N|s\/n|s\-n)$/i.test(value);
        };
        var sn = function (value) {
            var m = /^(sn|S\/N|s\/n|s\-n)$/i.exec(value);
            if (m) {
                return 's*n';
            }
            return value;
        };


        var is_cmc = function (value) {
            return /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.test(value);
        };
        var cmc = function (value) {
            var m = /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(value);
            if (m) {
                return value;
            }
            return value;
        };

        var isCheck = [is_nc_c, is_cn, is_sn, is_cmc];
        var check = [nc_c, cn, sn, cmc];
        var ch = 0;
        while (ch < check.length && !isCheck[ch].call(self, value)) {
            ch++;
        }

        if (ch < check.length)
            return check[ch].call(self, value);
        else return value;
    };

    const bindRoot = function (result, root, limit, addRoot) {
        const self = this;

        if (root) {
            var i = result.length;
            while (i--) {
                if (!addRoot) {
                    if (result[i].t) {
                        var indicatedRoot = self.rootCfg.active.rootLabel.filter(function (elem) {
                            return elem.label.indexOf(self.removePunctuation(result[i].t).toLowerCase()) > -1;
                        }.bind(self));

                        if (indicatedRoot.length == 1) {
                            result[i].t = indicatedRoot[0].id;
                        } else if (indicatedRoot.length > 1) {

                            indicatedRoot.map(function (elem) {
                                var newResult = TC.Util.extend({
                                }, result[i]);
                                newResult.t = elem.id;

                                result.push(newResult);
                            });

                        } else if (indicatedRoot.length == 0 && limit) {
                            result.splice(i, 1);
                        }
                    }
                }
                else {
                    result.push(TC.Util.extend({}, result[i], { t: root }));
                };
            }
        }
    };

    const getObjectsFromStringToQuery = function (allowedRoles, text) {
        const self = this;
        const root = self.rootCfg.active && self.rootCfg.active.root || '';
        const limit = self.rootCfg.active && self.rootCfg.active.limit || false;

        var result = [];

        const test = function () {
            var tests = [function (text) {
                return text.length >= 3;
            },
            function (text) {
                return /^\d+$/.test(text) ? false : (/^\d+\,\s*\d+$/.test(text) ? false : true);
            }];

            for (var i = 0; i < tests.length; i++) {
                if (!tests[i].call(self, text))
                    return false;
            }

            return true;
        };

        // eliminamos espacios en blanco
        text = text.trim();

        // comprobamos si acaba con coma, si es así, la eliminamos
        if (text.charAt(text.length - 1) == ',') {
            text = text.substring(0, text.length - 1);
        }

        if (test(text)) {
            var check = [];

            check = allowedRoles.map(function (dataRole) {
                return self.getSearchTypeByRole(dataRole);
            }).filter(function (searchType) {
                return searchType.stringPatternToCheck;
            }).map(function (searchType) {
                return searchType.stringPatternToCheck;
            });

            if (check.length === 0) {
                check = [self.stringPatternsValidators.tsp, self.stringPatternsValidators.spt, self.stringPatternsValidators.tnsp, self.stringPatternsValidators.ts, self.stringPatternsValidators.st];
                if (root && text.split(',').length < 3) {
                    check = [self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t].concat(check);
                }
                else {
                    check = check.concat([self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t]);
                }
            }

            var ch = 0;
            try {
                while (ch < check.length && !check[ch].call(self, text, result, root, limit)) {
                    ch++;
                }
            }
            catch (ex) {
                TC.error("Error según el patrón: " + text, TC.Consts.msgErrorMode.EMAIL, "Error en la búsqueda del callejero");
            }

            return result;
        }

        return null;
    };

    const requestToWFS = function (type, doneCallback, data) {
        const self = this;

        self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
        self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
        return TC.ajax({
            url: type.url,
            method: 'POST',
            //contentType: "application/x-www-form-urlencoded;charset=UTF-8",
            responseType: 'text',
            data: type.filter.getParams(data)
        })
            .then(doneCallback)
            .catch(function (data) {
                if (data.statusText !== 'abort')
                    alert('error');

                //console.log('getStringPattern promise resuelta - data.statusText: ' + data.statusText);
            });
    };

    const getResultsFromWFS = function (allowedRoles, resolve, reject, objectsToQuery) {
        const self = this;

        if (objectsToQuery) {
            var results = [];

            self._search.data = results;

            if (!self.request) {
                self.request = [];
            }

            objectsToQuery.forEach(function (data, i) {

                allowedRoles.filter(function (elm) {
                    var type = self.getSearchTypeByRole(elm);
                    return Object.keys(type.queryProperties).length === Object.keys(data).length;
                }).map(function (dataRole) {
                    var type = self.getSearchTypeByRole(dataRole);
                    self.request.push(requestToWFS.call(self, type, function (response) {
                        results = results.concat(type.getSuggestionListElements(response.data));
                    }, data));
                });
            });

            Promise.all(self.request).then(function () {
                //self.request = [];
                //console.log('getStringPattern promise resuelta');
                resolve(results);
            });
        } else {
            //console.log('getStringPattern promise resuelta - no encaja en address');
            resolve([]);
        }
    };

    ctlProto.getStringPattern = function (allowedRoles, pattern) {
        const self = this;

        return new Promise(function (resolve, reject) {
            pattern = normalizedCriteria.call(self, pattern);

            /* gestionamos:
                Entidad de población: Irisarri Auzoa (Igantzi)
                Topónimo: Aldabeko Bidea (Arbizu)
            */
            var combinedCriteria = /(.*)\((.*)\)/.exec(pattern);
            if (combinedCriteria && combinedCriteria.length > 2) {

                // búsqueda de entidad de población
                var objectsToQuery = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1]);

                // búsqueda de topónimo
                var bothSearchObjects = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1] + ',' + combinedCriteria[2]);

                bothSearchObjects = (bothSearchObjects || []).concat(objectsToQuery || []);

                getResultsFromWFS.call(self, allowedRoles, resolve, reject, bothSearchObjects);
            } else {
                var objectsToQuery = getObjectsFromStringToQuery.call(self, allowedRoles, pattern);

                getResultsFromWFS.call(self, allowedRoles, resolve, reject, objectsToQuery);
            }
        });
    };

    ctlProto.getRoad = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 2) {
                resolve([]);
            } else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

                var roadPattern = type.getPattern();
                var match = roadPattern.exec(pattern);
                if (match && match[3]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    TC.ajax({
                        url: type.url + '?' + type.filter.getParams({ t: _pattern }),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (response) {
                        const data = response.data;
                        var result = [];                        

                        if (data.totalFeatures > 0) {
                            data.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.text == feature.properties[properties[0]]);
                                })) {
                                    var label = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));

                                    var text = type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }).join('-');

                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: label,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });

                            //console.log('getRoad promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoad promise resuelta');
                            resolve([]);
                        }
                    }).catch(function (data) {
                        //console.log('getRoad promise resuelta - xhr fail');
                        resolve([]);
                    });
                } else {
                    //console.log('getRoad promise resuelta - no encaja en road');
                    resolve([]);
                }
            }
        });
    };

    ctlProto.getPK = function (pattern) {
        var self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 3) {
                resolve([]);
            } else {

                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

                var roadPKPattern = type.getPattern();
                var match = roadPKPattern.exec(pattern);
                if (match && match[3] && match[5]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    TC.ajax({
                        url: type.url + '?' + type.filter.getParams({ t: _pattern, s: match[5].trim() }),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON                        
                    }).then(function (response) {
                        const data = response.data;
                        var result = [];
                        if (data.totalFeatures > 0) {
                            data.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.label == feature.properties[properties[0]]);
                                })) {
                                    var text = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));
                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: text,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });
                            //console.log('getRoadPK promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoadPK promise resuelta');
                            resolve([]);
                        }
                    }).catch(function (data) {
                        //console.log('getRoadPK promise resuelta - xhr fail');
                        resolve([]);
                    });
                } else {
                    //console.log('getRoadPK promise resuelta - no encaja en pk');
                    resolve([]);
                }
            }
        });
    };

    ctlProto.search = function (pattern, callback) {
        var self = this;
        var results = [];

        if (self.request) {

            for (var i = 0; i < self.request.length; i++) {
                console.log("new criteria: search promise/s aborted");
                //self.request[i].abort();
            }

            self.request = [];
        }

        pattern = pattern.trim();
        if (pattern.length > 0) {
            pattern = pattern.toLowerCase();

            var waiting = [];
            var addWaiting = function (fn) {
                waiting.push(new Promise(function (resolve, reject) {
                    fn.call(self, pattern).then(function (result) {
                        results = results.concat(result);
                        resolve(results);
                    });
                }));
            };

            self.allowedSearchTypes.forEach(function (allowed) {
                if (allowed.parser) {
                    addWaiting(allowed.parser);
                } else {
                    console.log('Falta implementación del método parser');
                }
            });

            Promise.all(waiting).then(function () {
                if (results)
                    self._search.data = results = results.sort(function (a, b) {
                        var pattern = /(\d+)/;
                        var _a, _b = '';
                        if (pattern.test(a.label) && pattern.test(b.label)) {
                            _a = a.label.match(pattern)[1];
                            _b = b.label.match(pattern)[1];
                        } else {
                            _a = a.label;
                            _b = b.label;
                        }

                        if (_a > _b)
                            return 1;
                        else
                            if (_a < _b)
                                return -1;
                            else
                                return 0;
                    }.bind(self));

                if (callback)
                    callback(results);

                if (results.length === 0) {
                    self.cleanMap();

                    if (!self.layer ||
                        (self.layer && self.layer.features.length === 0)) {
                        self.resultsList.innerHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';
                        self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    }
                }

                self.lastPattern = "";
            });
        }
        else self.cleanMap();
    };

    var setQueryableFeatures = function (features) {
        var self = this;

        if (features && features.length > 0) {
            for (var i = 0; i < features.length; i++) {
                if (features[i].showsPopup != self.queryableFeatures)
                    features[i].showsPopup = self.queryableFeatures;
            }
        }
    };
    ctlProto._goToResult = function (id, dataRole) {
        var self = this;
        var goTo = null;
        return new Promise(function (resolve, reject) {
            if (!self.loading)
                self.loading = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];

            var wait;
            wait = self.loading.addWait();

            // en pantallas pequeñas, colapsamos el panel de herramientas
            if (matchMedia('(max-width: 30em)').matches) {
                self.textInput.blur();
                self.map.trigger(TC.Consts.event.TOOLSCLOSE);
            }

            self.cleanMap();

            var customSearchType = false;
            var keepOnLooping = true;

            self.allowedSearchTypes.forEach(function (allowed) {
                if (keepOnLooping) {

                    if (!self.availableSearchTypes[allowed.typeName]) {

                        if (allowed.goTo) {
                            customSearchType = true;

                            goTo = allowed.goTo.call(self, id);
                            if (goTo !== null) {
                                keepOnLooping = false;
                            }
                        } else console.log('Falta implementación del método goTo');

                    } else {

                        var dr = dataRole || self.getElementOnSuggestionList.call(self, id).dataRole;
                        if (dr) {

                            var searchType = self.getSearchTypeByRole(dr);

                            if (self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else if (!self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                customSearchType = true;

                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else console.log('Falta implementación del método goTo');
                        }
                    }
                }
            });

            self.loading.removeWait(wait);

            if (goTo) {

                self.getLayer().then(function (layer) {
                    switch (true) {
                        case goTo.params.type == TC.Consts.layerType.VECTOR:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                if (layer.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                                    delete layer[self.WFS_TYPE_ATTRS[i]];
                            }
                            break;
                        case goTo.params.type == TC.Consts.layerType.WFS:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                layer[self.WFS_TYPE_ATTRS[i]] = goTo.params[self.WFS_TYPE_ATTRS[i]];
                            }

                            wait = self.loading.addWait();
                            break;
                        default:
                    }

                    layer.type = goTo.params.type;

                    self.map.on(TC.Consts.event.FEATURESADD, function (e) {
                        if (e.layer === self.layer) {
                            setQueryableFeatures.call(self, e.features);
                        }
                    });

                    layer.refresh().then(function () {
                        self.map.one(TC.Consts.event.LAYERUPDATE, function (e) {
                            if (e.layer == layer) {
                                // Salta cuando se pinta una feature que no es de tipo API porque la gestión de estilos salta antes (no es controlable)
                                self.map.one(TC.Consts.event.FEATURESADD, function (e) {
                                    if (e.layer == layer) {
                                        if (!e.layer.features || e.layer.features.length == 0 && e.layer.wrap.layer.getSource().getFeatures()) {
                                            self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                            var bounds = e.layer.wrap.layer.getSource().getExtent();
                                            var radius = e.layer.map.options.pointBoundsRadius;

                                            if (bounds[2] - bounds[0] === 0) {
                                                bounds[0] = bounds[0] - radius;
                                                bounds[2] = bounds[2] + radius;
                                            }
                                            if (bounds[3] - bounds[1] === 0) {
                                                bounds[1] = bounds[1] - radius;
                                                bounds[3] = bounds[3] + radius;
                                            }
                                            e.layer.map.setExtent(bounds);

                                            // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
                                            self.map.trigger(TC.Consts.event.ZOOMTO, {
                                                extent: bounds, layer: e.layer
                                            });
                                        }
                                        else if (e.layer.features && e.layer.features.length > 0) {
                                            self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                            self.layer.map.zoomToFeatures(e.layer.features);

                                            self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                        } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                            self.resultsList.inner = goTo.emptyResultHTML;
                                            self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                            self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                        }

                                        self.loading.removeWait(wait);
                                    }
                                });

                                if (e.layer.features && e.layer.features.length > 0) {
                                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                    self.layer.map.zoomToFeatures(self.layer.features);

                                    self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                    self.loading.removeWait(wait);
                                } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                    self.resultsList.innerHTML = goTo.emptyResultHTML;
                                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                    if (!(e.newData && e.newData.features && e.newData.features.length > 0)) {
                                        self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                    }

                                    self.loading.removeWait(wait);
                                }
                            }
                        });
                    });
                });

                resolve(goTo);
            } else {
                reject();
                if (!customSearchType) {
                    self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                }
            }
        });
    };

    ctlProto.goToResult = function (id, dataRole) {
        var self = this;
        // si está habilitada
        if (self.getSearchTypeByRole(dataRole)) {
            return self._goToResult(id, dataRole);
            // si no está habilitada pero está disponible
        } else if (self.availableSearchTypes[dataRole]) {
            self.addAllowedSearchType(dataRole, self.availableSearchTypes[dataRole], self);
            return self._goToResult(id, dataRole);
        } else {
            alert('No se reconoce el tipo de búsqueda: ' + dataRole);
        }
    };

    var drawPoint = function (id) {
        var self = this;

        wait = self.loading.addWait();

        var point = self.getPoint(id);
        var delta;
        var title;
        var promise;

        if (point) {
            title = self.getLabel(id);
            promise = self.layer.addMarker(point, TC.Util.extend({}, self.map.options.styles.point, { title: title, group: title }));
        } else {
            var match = /^Lat((?:[+-]?)\d+(?:\.\d+)?)Lon((?:[+-]?)\d+(?:\.\d+)?)$/.exec(id);
            id = self.LAT + match[2] + self.LON + match[1];
            point = self.getPoint(id);

            if (point) {
                title = self.getLabel(id);
                promise = self.layer.addMarker(point, TC.Util.extend({}, self.map.options.styles.point, { title: title, group: title }));

                self.textInput.value = title;
            }
        }

        promise.then(function (feat) {
            self.map.trigger(TC.Consts.event.FEATURESADD, {
                layer: self.layer, features: [feat]
            });

            self.map.zoomToFeatures([feat]);

            self.loading.removeWait(wait);
        });

    };
    ctlProto.goToCoordinates = function (id) {
        var self = this;
        var goTo = {};
        if (/^X(\d+(?:[\.\,]\d+)?)Y(\d+(?:[\.\,]\d+)?)$/.test(id) || /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.test(id)) {

            goTo.params = {
                type: TC.Consts.layerType.VECTOR,
                styles: {
                    marker: {
                        url: self.layerStyleFN.bind(self, 'marker', 'url', true)
                    }
                }
            };

            goTo.emptyResultHTML = '<li><a class="tc-ctl-search-li-empty">' + self.OUTBBX_LABEL + '</a></li>';

            drawPoint.call(self, id);

            return goTo;
        }

        return null;
    };

    ctlProto.goToCadastralRef = function (id) {
        var self = this;
        var goTo = {};

        var regex = new RegExp("^" + self.MUN + "(\\d+)" + self.POL + "(\\d{1,2})" + self.PAR + "{1}(\\d{1,4})");
        if (regex.test(id)) {
            var match = regex.exec(id);

            if (!TC.filter) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
            }

            var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

            goTo.params = {
                type: TC.Consts.layerType.WFS,
                url: type.url,
                version: type.version,
                geometryName: type.geometryName,
                featurePrefix: type.featurePrefix,
                featureType: type.featureType,
                properties: new TC.filter.and(
                    new TC.filter.equalTo(type.queryProperties.firstQueryWord, match[1].trim()),
                    new TC.filter.equalTo(type.queryProperties.secondQueryWord, match[2].trim()),
                    new TC.filter.equalTo(type.queryProperties.thirdQueryWord, match[3].trim())),
                outputFormat: type.outputFormat,
                styles: type.styles
            };

            goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

            return goTo;
        }

        return null;
    };

    ctlProto.goToRoad = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToPK = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToStringPattern = function (id, dataRole) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(dataRole);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        return goTo;
    };

    ctlProto.getPoint = function (pattern) {
        var self = this;
        var isMapGeo = self.map.wrap.isGeo();
        var point;
        var match = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.exec(pattern);
        if (match && match.length === 3) {
            point = [parseFloat(match[1]), parseFloat(match[2])];
            if (isMapGeo) {
                point = TC.Util.reproject(point, self.map.options.utmCrs, self.map.crs);
            }
        }
        else {
            match = /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }

            match = /^Lon((?:[+-]?)\d+(?:[.,]\d+)?)Lat((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }
        }

        return point;
    };

    ctlProto.insideLimit = function (point) {
        var self = this;
        var getIntersectsBounds = function (extent, point) {
            if (extent instanceof Array)
                return point[0] >= extent[0] && point[0] <= extent[2] && point[1] >= extent[1] && point[1] <= extent[3];
            else return true;
        };

        if (getIntersectsBounds(self.map.options.maxExtent, point)) {
            return true;
        }

        return false;
    };

    ctlProto.getPattern = function () {
        var self = this;
        return self.textInput.value;
    };

    ctlProto.getLabel = function (id) {
        var self = this;
        var result = id;
        var locale = TC.Util.getMapLocale(self.map);

        if (id.match(new RegExp('^(?:' + self.LAT + '[-\\d])|(?:' + self.UTMX + '[\\d])'))) {
            result = result.replace(self.LAT, self.LAT_LABEL).replace(self.LON, ' ' + self.LON_LABEL).replace(self.UTMX, self.UTMX_LABEL).replace(self.UTMY, ' ' + self.UTMY_LABEL);
            var match = result.match(new RegExp('^' + self.LAT_LABEL.trim() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LON_LABEL.trim() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

            var localeDecimalSeparator = 1.1.toLocaleString(locale).substring(1, 2);
            var match = result.match(new RegExp('^' + self.UTMX_LABEL.trim() + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + self.UTMY_LABEL.trim() + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                if (!Number.isInteger(parseFloat(match[1])))
                    result = result.replace(match[1], match[1].replace('.', localeDecimalSeparator));
                if (!Number.isInteger(parseFloat(match[2])))
                    result = result.replace(match[2], match[2].replace('.', localeDecimalSeparator));
            }

        } else if (id.match(new RegExp('^(?:' + self.LON + '[-\\d])'))) {
            result = result.replace(self.LON, self.LON_LABEL).replace(self.LAT, ' ' + self.LAT_LABEL);

            var match = result.match(new RegExp('^' + self.LON_LABEL.trim() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LAT_LABEL.trim() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

        } else if (id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'))) {
            var match = id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'));
            result = self.MUN_LABEL + match[2] + ', ' + self.POL_LABEL + match[4] + ', ' + self.PAR_LABEL + match[6];
        }
        return result;
    };

    ctlProto.removePunctuation = function (text) {
        text = text || '';
        var result = new Array(text.length);
        var map = {
            'á': 'a',
            'à': 'a',
            'Á': 'A',
            'À': 'A',
            'é': 'e',
            'è': 'e',
            'É': 'E',
            'È': 'E',
            'í': 'i',
            'ì': 'i',
            'Í': 'I',
            'Ì': 'I',
            'ó': 'o',
            'ò': 'o',
            'Ó': 'O',
            'Ò': 'O',
            'ú': 'u',
            'ù': 'u',
            'ü': 'u',
            'Ú': 'U',
            'Ù': 'U',
            'Ü': 'U'
        };
        for (var i = 0, len = text.length; i < len; i++) {
            result[i] = map[text.charAt(i)] || text.charAt(i);
        }
        return result.join('');
    };    

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                searchText: self.textInput.value,
                layer: self.layer.exportState({
                    exportStyles: false
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.textInput.value = state.searchText;
        self.layer.importState(state.layer).then(function () {
            self.layer.features.forEach(function (f) {
                f.setStyle(null); // Los estilos vienen dados exclusivamente por la capa, borramos estilos propios de la feature
            });
        });
    };

})();


if (!String.prototype.tcFormat) {
    String.prototype.tcFormat = function () {
        var args = (arguments || [""])[0];
        return this.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined' ?
                args[number]
                : match
                ;
        });
    };
}


if (!String.prototype.splitRemoveWhiteSpaces) {
    String.prototype.splitRemoveWhiteSpaces = function (separator) {
        var _arr = [];
        var arr = this.split(separator);
        for (var i = 0; i < arr.length; i++)
            if (arr[i].trim().length > 0)
                _arr.push(arr[i].trim());

        return _arr;
    };
}


if (!String.prototype.toCamelCase) {
    String.prototype.toCamelCase = function () {
        var _value = this.toLowerCase();
        var match = this.toLowerCase().match(/[^A-ZÁÉÍÓÚÜÀÈÌÒÙáéíóúüàèìòùa-z0-9_]+(.)/g);
        if (match) {
            for (var i = 0; i < match.length; i++) {
                if (/[-;:.<>\{\}\[\]\/\s()]/g.test(match[i]))
                    _value = _value.replace(match[i], match[i].toUpperCase());
            }
        }

        return _value.charAt(0).toUpperCase() + _value.substring(1);
    };
}


if (!Array.prototype.hasOwnProperty('findByProperty')) {
    Object.defineProperty(Array.prototype, "findByProperty", {
        enumerable: false,
        writable: true,
        value: function (propertyName, value) {
            for (var i = 0; i < this.length; i++) {
                if (this[i][propertyName] == value)
                    return this[i];
            }
        }
    });
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}

TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.SelectContainer = TC.control.TabContainer;
TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.Share = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self.exportsState = true;

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    self.render();
};

TC.inherit(TC.control.Share, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Share.prototype;

    ctlProto.CLASS = 'tc-ctl-share';
    ctlProto.MAILTO_MAX_LENGTH = 256;
    ctlProto.IFRAME_WIDTH = '600px';
    ctlProto.IFRAME_HEIGHT = '450px';
    ctlProto.FEATURE_PARAM = 'showfeature';

    ctlProto.MOBILEFAV = 'Siga las instrucciones del navegador del dispositivo móvil para añadir como favorito. Se guardará el estado actual del mapa.';
    ctlProto.NAVALERT = ' +D para guardar en marcadores.';


    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, function () {
                //Si el navegador no soporta copiar al portapapeles, ocultamos el botón de copiar
                if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
                    self.div.querySelectorAll('button').forEach(function (btn) {
                        btn.classList.remove('hide');
                    });
                    self.div.querySelectorAll('input[type=text]').forEach(function (input) {
                        delete input.dataset.dataOriginalTitle;
                    });
                }

                // Si el SO no es móvil, ocultamos el botón de compartir a WhatsApp
                if (!TC.Util.detectMobile()) {
                    self.div.querySelector(".share-whatsapp").classList.add(TC.Consts.classes.HIDDEN);
                }

                const options = self.div.querySelectorAll('.' + self.CLASS + '-url-box');
                self.div.querySelectorAll('span:not(.tc-beta)').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, function (e) {
                        var label = this;
                        while (label && label.tagName !== 'LABEL') {
                            label = label.parentElement;
                        }
                        const newFormat = label.querySelector('input[type=radio][name=format]').value;

                        options.forEach(function (option) {
                            option.classList.toggle(TC.Consts.classes.HIDDEN, !option.matches('.tc-' + newFormat));
                        });
                    });
                });
                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            });
        });
    };

    /**
     * Obtiene una URL "limpia" para compartir el mapa.
     */
    ctlProto.getLocation = function () {
        var result = window.location.href;
        if (window.location.hash) {
            result = result.substr(0, result.indexOf(window.location.hash));
        }
        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const browserAlert = self.div.querySelector('.' + self.CLASS + '-alert');
        //Si la URL sobrepasa el tamaño máximo avisamos que puede fallar en Edge
        browserAlert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.browser);

        const qrAlert = self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert');
        qrAlert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
    };

    ctlProto.generateIframe = function (url) {
        var self = this;
        var urlString = url || this.generateLink();
        if (urlString) {
            return '<iframe style="width:' + self.IFRAME_WIDTH + ';height:' + self.IFRAME_HEIGHT + ';" src="' + urlString + '"></iframe>';
        }
    }

    ctlProto.loadParamFeature = function () {
        const self = this;
        var result = null;
        var featureToShow = TC.Util.getParameterByName(self.FEATURE_PARAM);
        if (featureToShow) {
            var featureObj;
            try {
                featureObj = JSON.parse(decodeURIComponent(escape(window.atob(featureToShow))));
            }
            catch (error) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            if (featureObj && self.map) {
                if (featureObj.geom) {
                    self.map.addLayer({
                        id: self.getUID(),
                        type: TC.Consts.layerType.VECTOR,
                        title: self.getLocaleString('foi'),
                        stealth: true
                    }).then(function (layer) {
                        self.paramFeatureLayer = layer;
                        layer.importState({ features: [featureObj] }).then(function () {
                            self.map.zoomToFeatures(layer.features);
                        });
                    });
                }
                else {
                    result = featureObj;
                }
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapInfo.prototype.register.call(self, map);

        self.exportsState = true;

        self.MOBILEFAV = self.getLocaleString('mobileBookmarks.instructions');
        self.NAVALERT = self.getLocaleString('bookmarks.instructions');

        var selectInputField = function (elm) {
            const input = elm.parentElement.querySelector("input[type=text]");
            input.value = input.classList.contains('tc-url') ? self.generateLink() : self.generateIframe();
            input.select();
        };

        var unselectInputField = function () {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            const link = self.generateLink();
            self.registerListeners();
            self.div.querySelector('.tc-url input[type=text]').value = link;
            self.div.querySelector('.tc-iframe input[type=text]').value = self.generateIframe(link);
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.tc-ctl-share-url-box button', function (evt) {
            const copyBtn = evt.target;
            selectInputField(copyBtn);
            document.execCommand('copy');

            copyBtn.textContent = self.getLocaleString('copied');


            setTimeout(function () {
                copyBtn.textContent = self.getLocaleString('copy');
                unselectInputField();
            }, 1000);

        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('input[type=text]', function (evt) {
            selectInputField(evt.target);
        }));

        //Deshabilitar el click de ratón en los enlaces de compartir cuando están deshabilitados
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.ga-share-icon.disabled', function (evt) {
            evt.stopImmediatePropagation();
            evt.preventDefault();
            return false;
        }));

        //Enviar por e-mail
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('a.share-email', function (evt) {
            evt.preventDefault();
            var url = self.generateLink();

            if (url) {
                const body = encodeURIComponent(url + "\n");
                if (body.length > self.MAILTO_MAX_LENGTH) {
                    map.toast(self.getLocaleString('urlTooLongForMailto'), { type: TC.Consts.msgType.WARNING });
                }
                window.location.href = 'mailto:?body=' + body;
            }
        }));

        //Generar código QR        
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.qr-generator", function (evt) {
            evt.preventDefault();
            const qrContainer = self._dialogDiv.querySelector(".qrcode");
            qrContainer.innerHTML = '';

            if (self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert').classList.contains(TC.Consts.classes.HIDDEN)) {                
                self.makeQRCode(qrContainer, 256, 256).then(function (qrCodeBase64) {
                    if (qrCodeBase64) {
                        TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-qr-dialog'));
                    }
                });
            } else {
                TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-qr-dialog'));
            }
        }));

        
        const openSocialMedia = function (win, url, process) {
            if (url && url.trim().length > 0) {
                win.location.href = process(url);
            } else {
                TC.error(self.getLocaleString('urlTooLongForShortener'));
                win.close();
            }
        };

        //Compartir en Facebook
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-fb", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    return "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(url)
                });
            });

            return false;
        }));

        //Compartir en Twitter
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-twitter", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    var titulo = encodeURIComponent(window.document.title ? window.document.title : "Visor API SITNA");
                    return "https://twitter.com/intent/tweet?text=" + titulo + "&amp;url=" + encodeURIComponent(url);
                });
            });

            return false;
        }));

        //Compartir en Whatsapp
        if (TC.Util.detectMobile()) {
            self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-whatsapp", function (evt) {
                evt.preventDefault();

                self.shortenedLink().then(function (url) {
                    var waText = 'whatsapp://send?text=';
                    if (url !== undefined) {
                        location.href = waText + encodeURIComponent(url);
                    } else {
                        location.href = waText + encodeURIComponent(self.generateLink());
                    }
                });

                return false;
            }));
        }

        //Guardar en marcadores
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-star", function (evt) {
            evt.preventDefault();

            var bookmarkURL = self.generateLink();
            var bookmarkTitle = document.title;

            if (TC.Util.detectMobile()) {
                // Mobile browsers
                alert(ctlProto.MOBILEFAV);
            } else if (window.sidebar && window.sidebar.addPanel) {
                // Firefox version < 23
                window.sidebar.addPanel(bookmarkTitle, bookmarkURL, '');
            } else if ((window.sidebar && /Firefox/i.test(navigator.userAgent)) || (window.opera && window.print)) {
                // Firefox version >= 23 and Opera Hotlist                

                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);

            } else if (window.external && ('AddFavorite' in window.external)) {
                // IE Favorite
                window.external.AddFavorite(bookmarkURL, bookmarkTitle);
            } else {
                // Other browsers (mainly WebKit - Chrome/Safari)                
                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);
            }

            return false;
        }));

        //Cuando se añada o borre una capa, comprobamos de nuevo si la URL cumple los requisitos de longitud para habilitar el control
        //map.on(TC.Consts.event.MAPLOAD, function () {
        //    map.on(TC.Consts.event.LAYERREMOVE + ' ' + TC.Consts.event.LAYERADD, function (e) {
        //        self.generateLink();
        //    });
        //});        

        return result;
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Share.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/ShareDialog.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "share" }).w(" </h2><div><div class=\"ga-share-icons\"><a class=\"ga-share-icon share-email\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "sendMapByEmail" }).w("\"href=\"#\"><i class=\"icon-envelope-alt\"></i></a><a class=\"ga-share-icon qr-generator\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCode" }).w("\"href=\"#\"><i class=\"icon-qrcode\"></i></a><a class=\"ga-share-icon share-fb\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToFacebook" }).w("\"href=\"#\"><i class=\"icon-facebook\"></i></a><a class=\"ga-share-icon share-twitter\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToTwitter" }).w("\"href=\"#\"><i class=\"icon-twitter\"></i></a><a class=\"ga-share-icon share-whatsapp\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToWhatsapp" }).w("\"href=\"#\"><i class=\"icon-whatsapp\"></i></a><a class=\"ga-share-icon share-star\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "addToBookmarks" }).w("\"href=\"#\"><i class=\"icon-star\"></i></a></div><div class=\"tc-ctl-share-select\"><form><label class=\"tc-ctl-share-btn-url\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink" }).w("\"><input type=\"radio\" checked=\"checked\" name=\"format\" value=\"url\" /><span>").h("i18n", ctx, {}, { "$key": "shareLink" }).w("</span></label><label class=\"tc-ctl-share-btn-iframe\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap" }).w("\"><input type=\"radio\" name=\"format\" value=\"iframe\" /><span>").h("i18n", ctx, {}, { "$key": "embedMap" }).w("</span></label></form></div><div class=\"tc-ctl-share-url-box tc-group tc-url\"><input type=\"text\" class=\"tc-textbox tc-url\" readonly data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink.tip.1" }).w("\" /><button class=\"tc-button hide\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink.tip.2" }).w("\">").h("i18n", ctx, {}, { "$key": "copy" }).w("</button></div><div class=\"tc-ctl-share-url-box tc-group tc-iframe tc-hidden\"><input type=\"text\" class=\"tc-textbox tc-iframe\" readonly data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap.tip.1" }).w("\" /><button class=\"tc-button hide\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap.tip.2" }).w("\">").h("i18n", ctx, {}, { "$key": "copy" }).w("</button></div><div class=\"tc-ctl-share-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "tooManyLayersLoaded|s" }).w("</p></div> </div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-share-qr-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "qrCode" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><div class=\"qrcode\"></div> <div class=\"tc-ctl-share-qr-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }
})();
/// <reference path="../feature/Marker.js" />
/// <reference path="../feature/Point.js" />
/// <reference path="../ol/ol.js" />


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {
    TC.Consts.url.GOOGLEMAPS = '//maps.googleapis.com/maps/api/js?v=3';
    var gMapsUrl = TC.Consts.url.GOOGLEMAPS;
    TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];
    TC.Cfg.proxyExceptions.push(TC.Consts.url.GOOGLEMAPS);

    TC.control.StreetView = function () {
        var self = this;
        self._sv = null;
        self._mapActiveControl = null;

        TC.Control.apply(self, arguments);

        if (self.options.googleMapsKey) {
            gMapsUrl += '&key=' + self.options.googleMapsKey;
        }

        self.viewDiv = null;
        self._startLonLat = null;

        //self.render();
    };

    TC.inherit(TC.control.StreetView, TC.Control);

    var ctlProto = TC.control.StreetView.prototype;

    ctlProto.CLASS = 'tc-ctl-sv';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/StreetView.html";
        ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/StreetViewView.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-sv-btn\" title=\"").h("i18n", ctx, {}, { "$key": "sv.tip" }).w("\"><div class=\"tc-ctl-sv-drag\"></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-view'] = function () { dust.register(ctlProto.CLASS + '-view', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-sv-btn-close\" title=\"").h("i18n", ctx, {}, { "$key": "closeStreetView" }).w("\"></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const dispatchCanvasResize = function () {
        var event = document.createEvent('HTMLEvents');
        event.initEvent('resize', true, false);
        this.map.div.querySelector('canvas').dispatchEvent(event);
    };

    var preset = function (ctl) {
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.add(TC.Consts.classes.CHECKED);
        ctl.map.div.classList.add(ctl.CLASS + '-active');
    };

    var reset = function (ctl) {
        const view = ctl.viewDiv;
        const transitionEvents = ['webkitTransitionEnd', 'msTransitionEnd', 'oTransitionEnd', 'transitionend'];
        const onTransitionend = function () {
            if (!TC.Util.detectSafari()) {
                transitionEvents.forEach(function (eventName) {
                    view.removeEventListener(eventName, onTransitionend);
                });
            }

            dispatchCanvasResize.call(ctl);
        };

        // Safari no lanza transitionend
        if (TC.Util.detectSafari()) {
            setTimeout(function () {
                dispatchCanvasResize.call(ctl);
            }, 500);
        } else {
            transitionEvents.forEach(function (eventName) {
                view.addEventListener(eventName, onTransitionend);
            });
        }

        ctl.layer.clearFeatures();
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.remove(TC.Consts.classes.CHECKED);
        ctl.div.querySelector('.' + ctl.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
        ctl.map.div.classList.remove(ctl.CLASS + '-active');
        ctl._startLonLat = null;
    };

    var resolve = function (ctl) {
        var result = false;
        const btn = ctl.div.querySelector('.' + ctl.CLASS + '-btn');
        const drag = ctl.div.querySelector('.' + ctl.CLASS + '-drag');

        var btnRect = btn.getBoundingClientRect();
        var dragRect = drag.getBoundingClientRect();
        drag.classList.add(TC.Consts.classes.HIDDEN);
        if (dragRect.top < btnRect.top || dragRect.top > btnRect.bottom ||
            dragRect.left < btnRect.left || dragRect.left > btnRect.right) {
            // Hemos soltado fuera del botón: activar StreetView
            result = true;
            // Precarga de marcadores
            var extent = ctl.map.getExtent();
            var xy = [extent[2], extent[3]];
            var deferreds = new Array(16);
            for (var i = 0; i < 16; i++) {
                ctl.layer.addMarker(xy, {
                    cssClass: 'tc-marker-sv-' + i,
                    width: 48,
                    height: 48,
                    anchor: [0, 1]
                });
            }
            /////////////////////
            // Activamos StreetView
            var mapRect = ctl.map.div.getBoundingClientRect();
            var xpos = (((dragRect.left * window.devicePixelRatio) + (dragRect.right * window.devicePixelRatio)) / 2) - (mapRect.left * window.devicePixelRatio);
            var ypos = (dragRect.bottom * window.devicePixelRatio) - (mapRect.top * window.devicePixelRatio);
            var coords = ctl.map.wrap.getCoordinateFromPixel([xpos, ypos]);
            ctl.callback(coords);
        }
        else {
            reset(ctl);
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        if (!self.viewDiv) {
            self.viewDiv = TC.Util.getDiv(self.options.viewDiv);
            self.viewDiv.classList.add(self.CLASS + '-view', TC.Consts.classes.HIDDEN);
            if (!self.options.viewDiv) {
                map.div.insertAdjacentElement('beforebegin', self.viewDiv);
            }
        }

        const result = TC.Control.prototype.register.call(self, map);

        self.layer = null;
        var layerId = self.getUID();
        for (var i = 0; i < map.workLayers.length; i++) {
            var layer = map.workLayers[i];
            if (layer.type === TC.Consts.layerType.VECTOR && layer.id === layerId) {
                self.layer = layer;
                break;
            }
        }
        if (!self.layer) {
            map.loaded(function () {
                map.addLayer({
                    id: layerId,
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layer = layer;
                });
            });
        }

        self.renderPromise().then(function () {
            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    const drag = new Draggabilly(self.div.querySelector('.' + self.CLASS + '-drag'), {
                        containment: self.map.div
                    });
                    drag.on('dragStart', function (e) {
                        preset(self);
                    });
                    drag.on('dragEnd', function (e) {
                        resolve(self);
                        drag.setPosition(0, 0);
                    });
                }
            );

            const view = self.viewDiv;
            view.querySelector('.' + self.CLASS + '-btn-close').addEventListener(TC.Consts.event.CLICK, function (e) {
                const mapDiv = self.map.div;
                const endProcess = function () {
                    mapDiv.classList.remove(TC.Consts.classes.COLLAPSED);
                    const resizeEvent = document.createEvent('HTMLEvents');
                    resizeEvent.initEvent('resize', false, false);
                    mapDiv.dispatchEvent(resizeEvent); // Para evitar que salga borroso el mapa tras cerrar SV.
                };
                const transitionend = 'transitionend';
                const onTransitionend = function (e) {
                    if (e.propertyName === 'width' || e.propertyName === 'height') {
                        view.removeEventListener(transitionend, onTransitionend);
                        endProcess();
                    }
                };
                view.removeEventListener(transitionend, onTransitionend);
                view.addEventListener(transitionend, onTransitionend);
                setTimeout(endProcess, 1000); // backup por si falla la transición.

                view.classList.add(TC.Consts.classes.HIDDEN);
                view.classList.remove(TC.Consts.classes.VISIBLE);
                self.div.querySelector('.' + self.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
                self.layer.wrap.setDraggable(false);
                reset(self);
                self._sv.setVisible(false);
                e.stopPropagation();
                const header = document.body.querySelector('header');
                if (header) {
                    header.style.display = '';
                }

                if (self._previousActiveControl) {
                    self._previousActiveControl.activate();
                }
            });
        }
            , function (a, b, c) {
                TC.error("Error de renderizado StreetView");
            });

        return result;
    };



    ctlProto.render = function () {
        const self = this;

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.renderData(null, function () {
                if (dust.cache[self.CLASS + '-view']) {
                    dust.render(self.CLASS + '-view', null, function (err, out) {
                        //lo normal sería hacer el resolve después de volcar out en viewDiv
                        //pero a veces fallaba
                        //no se detonaba, sin dar error alguno
                        //así que lo arreglo como a mí me gusta:
                        setTimeout(function () {
                            self.viewDiv.innerHTML = out;
                            if (err) {
                                TC.error(err);
                            }
                            resolve(self);
                        }
                            , 300);


                        //console.log("Casi resuelto... " + out.length);
                        //self._$viewDiv.html(out);
                        //if (err)
                        //{
                        //    TC.error(err);
                        //}
                        //resolve(self);
                        //console.log("Resuelto!");

                    });
                }
                else {
                    TC.error("No hay dust.cache para StreetView");
                    resolve(self);
                }
            });
        }));
    };

    var waitId = 0;

    ctlProto.callback = function (coords) {
        var self = this;
        var geogCrs = 'EPSG:4326';

        var ondrop = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();                
                lonLat = TC.Util.reproject([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2], self.map.crs, geogCrs);                
                self._sv.setPosition({ lng: lonLat[0], lat: lonLat[1] });
            }
        }

        var ondrag = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();
                self._startLonLat = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2];
            }
        }

        var li = self.map.getLoadingIndicator();
        if (li) {
            waitId = li.addWait(waitId);
        }

        const mapDiv = self.map.div;

        var setMarker = function (sv, center) {
            self.layer.clearFeatures();

            var xy;
            var heading;
            if (sv) {
                var latLon = sv.getPosition();
                xy = TC.Util.reproject([latLon.lng(), latLon.lat()], geogCrs, self.map.crs);
                heading = sv.getPov().heading;
            }
            else {
                xy = coords;
                heading = 0;
            }
            self.map.addMarker(xy, {
                cssClass: 'tc-marker-sv-' + (Math.round(16.0 * heading / 360) + 16) % 16,
                width: 48,
                height: 48,
                anchor: [0.4791666666666667, 0.7083333333333333],
                layer: self.layer,
                showsPopup: false
            });
            Promise.all(self.map._markerPromises).then(function () {
                // Para poder arrastrar a pegman                
                self.layer.wrap.setDraggable(true, ondrop, ondrag);
            });

            if (center) {
                var setCenter = function () {
                    self.map.setCenter(xy);
                };
                // Esperamos a que el mapa esté colapsado para centrarnos: ahorramos ancho de banda
                if (mapDiv.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    setCenter();
                }
                else {
                    setTimeout(setCenter, 1200);
                }
            }
        };

        TC.loadJS(
            !window.google || !google.maps,
            gMapsUrl,
            function () {

                if (window.google) {

                    setMarker();

                    const view = self.viewDiv;
                    var lonLat = TC.Util.reproject(coords, self.map.crs, geogCrs);
                    var svDone = view.classList.contains(TC.Consts.classes.VISIBLE);

                    var svOptions = {
                        position: new google.maps.LatLng(lonLat[1], lonLat[0]),
                        pov: {
                            heading: 0,
                            pitch: 0
                        },
                        zoom: 1,
                        fullscreenControl: false,
                        zoomControlOptions: {
                            position: google.maps.ControlPosition.LEFT_TOP
                        },
                        panControlOptions: {
                            position: google.maps.ControlPosition.LEFT_TOP
                        }
                    };

                    if (!self._sv) {
                        self._sv = new google.maps.StreetViewPanorama(view, svOptions);
                        google.maps.event.addListener(self._sv, 'position_changed', function () {
                            setMarker(self._sv, view.classList.contains(TC.Consts.classes.VISIBLE));
                        });
                        google.maps.event.addListener(self._sv, 'pov_changed', function () {
                            if (self.layer.features && self.layer.features.length > 0) {
                                var pegmanMarker = self.layer.features[0];

                                delete pegmanMarker.options.url;
                                pegmanMarker.options.cssClass = 'tc-marker-sv-' + ((Math.round(16.0 * self._sv.getPov().heading / 360) + 16) % 16);
                                pegmanMarker.setStyle(pegmanMarker.options);

                                self.layer.refresh();
                            }
                        });
                        google.maps.event.addListener(self._sv, 'status_changed', function () {
                            var svStatus = self._sv.getStatus();
                            if (li) {
                                li.removeWait(waitId);
                            }
                            if (svStatus === google.maps.StreetViewStatus.OK) {

                                mapDiv.classList.add(TC.Consts.classes.COLLAPSED);
                                const resizeEvent = document.createEvent('HTMLEvents');
                                resizeEvent.initEvent('resize', false, false);
                                mapDiv.dispatchEvent(resizeEvent);

                                const endProcess = function () {
                                    google.maps.event.trigger(self._sv, 'resize');

                                    dispatchCanvasResize.call(self);
                                };
                                var transitionend = 'transitionend';
                                const onTransitionend = function (e) {
                                    if (e.propertyName === 'width' || e.propertyName === 'height') {
                                        if (!svDone) {
                                            svDone = true;
                                            view.removeEventListener(transitionend, onTransitionend);
                                            endProcess();
                                        }
                                    }
                                };
                                view.removeEventListener(transitionend, onTransitionend);
                                view.addEventListener(transitionend, onTransitionend);

                                setTimeout(endProcess, 1000); // Backup por si no salta el transitionend.

                                if (!view.classList.contains(TC.Consts.classes.VISIBLE)) {
                                    self._sv.setVisible(true);
                                    setMarker(self._sv, true);

                                    //apagar lo que sea que esté encendido (probablemente featInfo)
                                    //al cerrar con el aspa, volverá a detonarse StreetView.deactivate()
                                    //que, a su vez, restaurará el control anterior (FeatureInfo)
                                    if (self.map.activeControl) {
                                        self._previousActiveControl = self.map.activeControl;
                                        self.map.activeControl.deactivate(true);
                                    }

                                    setTimeout(function () {
                                        view.style.left = '';
                                        view.style.top = '';
                                        // triggers transitionend
                                        view.classList.remove(TC.Consts.classes.HIDDEN);
                                        view.classList.add(TC.Consts.classes.VISIBLE);
                                    }, 200);

                                    const header = document.body.querySelector('header');
                                    if (header) {
                                        header.style.display = 'none';
                                    }
                                }
                            }
                            else {
                                TC.alert(svStatus === google.maps.StreetViewStatus.ZERO_RESULTS ? self.getLocaleString('noStreetView') : self.getLocaleString('streetViewUnknownError'));
                                if (self._startLonLat) {
                                    self.callback(self._startLonLat);
                                }
                                else {
                                    self.layer.wrap.setDraggable(false);
                                    reset(self);
                                }
                            }
                        });
                    }
                    else {
                        self._sv.setOptions(svOptions);
                    }
                    setMarker(self._sv);
                }
                else {
                    reset(self);
                }
            }, false, true);
    };
})();
TC.control = TC.control || {};

(function () {

    TC.control.ThreeD = function () {
        var self = this;

        TC.Control.apply(self, arguments);
    };

    TC.inherit(TC.control.ThreeD, TC.Control);

    var ctlProto = TC.control.ThreeD.prototype;

    ctlProto.CLASS = 'tc-ctl-threed';
    ctlProto.classes = {
        BETA: 'tc-beta-button',
        BTNACTIVE: 'active'
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ThreeD.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-threed-btn tc-beta-button\" title=\"").h("i18n", ctx, {}, { "$key": "threed.tip" }).w("\"></button>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            if (e.view == TC.Consts.view.THREED) { // cargamos la vista 3D desde el estado actualizamos el estado del botón
                self.activate();
            }
        });

        return result;
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;

        return TC.Control.prototype.renderData.call(self, data, function () {
            self.button = self.div.querySelector('.' + self.CLASS + '-btn');

            self.button.addEventListener(TC.Consts.event.CLICK, function () {

                if (self.button.getAttribute("disabled") === "disabled") {
                    return;
                }

                if (!self.map.on3DView) {
                    self.activate();
                } else {
                    self.button.setAttribute("disabled", "disabled");

                    TC.view.ThreeD.unapply({
                        callback: function () {
                            self.button.setAttribute('title', self.getLocaleString("threed.tip"));

                            self.button.classList.remove(self.classes.BTNACTIVE);

                            self.button.removeAttribute("disabled");
                        }
                    });
                }
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        var self = this;

        self.button.setAttribute("disabled", "disabled");

        self.browserSupportWebGL.call(self);

        const manageButton = function () {
            self.button.setAttribute('title', self.getLocaleString('threed.two.tip'));
            self.button.classList.remove(self.classes.BETA);

            self.button.classList.add(self.classes.BTNACTIVE);
        };

        const removeDisabled = function () {
            self.button.removeAttribute("disabled");
        };

        if (!self.map.view3D) {
            TC.loadJS(
                !TC.view || !TC.view.ThreeD,
                TC.apiLocation + 'TC/view/ThreeD',
                function () {                                                           /* provisional */
                    TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
                });
        } else if (!self.map.on3DView) {                                               /* provisional */
            TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
        }

        manageButton();

        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.browserSupportWebGL = function () {
        var self = this;
        var result = false;

        //Check for webgl support and if not, then fall back to leaflet
        if (!window.WebGLRenderingContext) {
            // Browser has no idea what WebGL is. Suggest they
            // get a new browser by presenting the user with link to
            // http://get.webgl.org
            result = false;
        } else {
            var canvas = document.createElement('canvas');

            var webglOptions = {
                alpha: false,
                stencil: false,
                failIfMajorPerformanceCaveat: true
            };

            try {
                var gl = canvas.getContext("webgl", webglOptions) ||
                    canvas.getContext("experimental-webgl", webglOptions) ||
                    canvas.getContext("webkit-3d", webglOptions) ||
                    canvas.getContext("moz-webgl", webglOptions);
                if (!gl) {
                    // We couldn't get a WebGL context without a major performance caveat.  Let's see if we can get one at all.
                    webglOptions.failIfMajorPerformanceCaveat = false;
                    gl = canvas.getContext("webgl", webglOptions) ||
                        canvas.getContext("experimental-webgl", webglOptions) ||
                        canvas.getContext("webkit-3d", webglOptions) ||
                        canvas.getContext("moz-webgl", webglOptions);
                    if (!gl) {
                        // No WebGL at all.
                        result = false;
                    } else {
                        // We can do WebGL, but only with software rendering (or similar).
                        result = 'slow';
                        self.isSlower = true;
                    }
                } else {
                    // WebGL is good to go!
                    result = true;
                }
            } catch (e) {
                console.log(E);
            }

            if (result === "slow" || !result) {
                var warning = result === "slow" ? "threed.slowSupport.supported" : "threed.not.supported";
                self.map.toast(self.getLocaleString(warning), {
                    type: TC.Consts.msgType.WARNING,
                    duration: 10000
                });
            }

            return result;
        }
    };

})();
TC.control = TC.control || {};

/*pollyfill*/
if (!HTMLElement.prototype.appendHTML) {
    HTMLElement.prototype.appendHTML = function (html) {
        var d = document.createElement("div");
        d.innerHTML = html;
        if (d.childNodes.length > 1) {
            for (var i = 0; i < d.childNodes.length; i++) {
                this.appendChild(d.childNodes[i]);
            }
        }
        if (d.childNodes.length > 0)
            this.appendChild(d.firstChild);
        return null;
    };
};
if (!Document.prototype.createHTMLElement) {
    Document.prototype.createHTMLElement = function (html) {
        var d = document.createElement("div");
        d.innerHTML = html;
        if (d.childNodes.length > 0)
            return d.firstChild;
        return null;
    };
};
if (!HTMLElement.prototype.empty) {
    HTMLElement.prototype.empty = function () {
        while (this.children.length) {
            this.removeChild(this.children[0]);
        }
    };
};

if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/filter');
}

TC.control.WFSQuery = function (options) {
    var self = this;
    TC.Control.apply(this, arguments);
    self.styles = self.options.styles;
    self.highLightStyles = self.options.highLightStyles;
};

TC.inherit(TC.control.WFSQuery, TC.Control);

(function () {
    var ctlProto = TC.control.WFSQuery.prototype;

    var cssClassLoading = "tc-loading";
    var modalBody = null;
    var modalDialog = null;
    var ctlResultsPanel = null;
    var resultLayer = null;
    var logicalOperator = TC.Consts.logicalOperator.AND;
    var timer = null;
    var autoCompletePromise = null;
    var locale = null;

    var filterByOperation = {
        eq: TC.filter.equalTo,
        not: TC.filter.notEqualTo,
        gt: TC.filter.greaterThan,
        lt: TC.filter.lessThan,
        ge: TC.filter.greaterThanOrEqualTo,
        le: TC.filter.lessThanOrEqualTo,
        like: TC.filter.like,
        contains: TC.filter.like,
        start: TC.filter.like,
        end: TC.filter.like,
        bw: TC.filter.between
    }
    var map = null;
    var _currentLayer = null;
    var _currentLayerName = null;
    var _currentLayercapabilities = null;
    var _currentLayerTitle = null;
    var _currentLayerURL = null;
    var _maxRecordCount = null;
    var _getStyles = function () { return null };
    var _getHighLightStyles = function () { return null };
    var getLocaleString=null;
    ctlProto.CLASS = 'tc-ctl-wfsquery';
    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS + "-dialog"] = TC.apiLocation + "TC/templates/WFSQueryDialog.html";
        ctlProto.template[ctlProto.CLASS + "-form"] = TC.apiLocation + "TC/templates/WFSQueryForm.html";
        ctlProto.template[ctlProto.CLASS + "-filter"] = TC.apiLocation + "TC/templates/WFSQueryfilter.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () {
            dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window tc-ctl-wfsquery-modal-window\" ><div class=\"tc-modal-header\"><h3>").f(ctx.get(["layerName"], false), ctx, "h").w("</h3><div title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipCloseDialogBtn" }).w("\" class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").h("gt", ctx, { "block": body_1 }, { "key": ctx.getPath(false, ["layers", "length"]), "value": 1 }).w("<div class=\"tc-modal-form\"></div><div class=\"tc-ctl-wfsquery-message tc-hidden\"></div> </div><div class=\"tc-modal-footer\"><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipSendQueryBtn" }).w("\" class=\"tc-button tc-ctl-wlm-btn-launch\">").h("i18n", ctx, {}, { "$key": "query.sendQueryBtnText" }).w("</button><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.cancelQueryTooltip" }).w("\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "query.cancelQueryButton" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" <div><select class=\"tc-combo\" name=\"availableLayers\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "query.chooseALayerCombo" }).w("</option>").s(ctx.get(["layers"], false), ctx, { "block": body_2 }, {}).w("</select></div> "); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["title"], false), ctx, "h").w("</option>"); } body_2.__dustBody = !0; return body_0;
        };
        ctlProto.template[ctlProto.CLASS + '-form'] = function () {
            dust.register(ctlProto.CLASS + '-form', body_0); function body_0(chk, ctx) { return chk.w("<div>").h("countif", ctx, { "else": body_1, "block": body_2 }, { "key": ctx.get(["attributes"], false), "excludedKeys": "the_geom,FEATURE" }).w("</div><div class=\"tc-ctl-wfsquery-operacion tc-hidden\"><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-numeric tc-hidden\"><input type=\"radio\" id=\"cond_1\" name=\"codicion\" value=\"eq\" /><label for=\"cond_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_2\" name=\"codicion\" value=\"not\" /><label for=\"cond_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.notEqualToBtn" }).w("</label><input type=\"radio\" id=\"cond_3\" name=\"codicion\" value=\"gt\" /><label for=\"cond_3\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherThanBtn" }).w("</label><input type=\"radio\" id=\"cond_4\" name=\"codicion\" value=\"lt\" /><label for=\"cond_4\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerThanBtn" }).w("</label><input type=\"radio\" id=\"cond_5\" name=\"codicion\" value=\"ge\" /><label for=\"cond_5\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherOrEqualThanBtn" }).w("</label><input type=\"radio\" id=\"cond_6\" name=\"codicion\" value=\"le\" /><label for=\"cond_6\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerOrEqualThanBtn" }).w("</label><!--<input type=\"radio\" id=\"cond_7\" name=\"codicion\" value=\"like\" /><label for=\"cond_7\" class=\"tc-ctl-wfsquery-cond\">es como</label>--></div><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-text tc-hidden\"><input type=\"radio\" id=\"cond_8\" name=\"codicion\" value=\"eq\" /><label for=\"cond_8\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_9\" name=\"codicion\" value=\"contains\" /><label for=\"cond_9\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.containsBtn" }).w("</label><input type=\"radio\" id=\"cond_10\" name=\"codicion\" value=\"start\" /><label for=\"cond_10\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.startsByBtn" }).w("</label><input type=\"radio\" id=\"cond_11\" name=\"codicion\" value=\"end\" /><label for=\"cond_11\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.endsByBtn" }).w("</label></div><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-date tc-hidden\"><input type=\"radio\" id=\"cond_12\" name=\"codicion\" value=\"bw\" /><label for=\"cond_12\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_13\" name=\"codicion\" value=\"nbw\" /><label for=\"cond_13\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.notEqualToBtn" }).w("</label><input type=\"radio\" id=\"cond_14\" name=\"codicion\" value=\"gt\" /><label for=\"cond_14\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherThanBtn" }).w("</label><input type=\"radio\" id=\"cond_15\" name=\"codicion\" value=\"lt\" /><label for=\"cond_15\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerThanBtn" }).w("</label><input type=\"radio\" id=\"cond_16\" name=\"codicion\" value=\"ge\" /><label for=\"cond_16\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherOrEqualThanBtn" }).w("</label><input type=\"radio\" id=\"cond_17\" name=\"codicion\" value=\"le\" /><label for=\"cond_17\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerOrEqualThanBtn" }).w("</label><!--<input type=\"radio\" id=\"cond_7\" name=\"codicion\" value=\"like\" /><label for=\"cond_7\" class=\"tc-ctl-wfsquery-cond\">es como</label>--></div><div class=\"tc-ctl-wfsquery-where tc-hidden\"><input type=\"search\" placeholder=\"").h("i18n", ctx, {}, { "$key": "query.searchFieldPhd" }).w("\" class=\"tc-textbox\" /><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipAddCondBtn" }).w("\" class=\"tc-button\">").h("i18n", ctx, {}, { "$key": "query.textAddCondBtn" }).w("</button><ul class=\"tc-ctl-wfsquery-list tc-ctl-search-list tc-hidden\"></ul><div class=\"tc-ctl-wfsquery-key\"><label>").h("i18n", ctx, {}, { "$key": "query.logicalOpLbl" }).w("</label></div><div class=\"tc-ctl-wfsquery-value\"><input type=\"radio\" id=\"log_op_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOpRadio\" checked name=\"log_op\" value=\"AND\" /><label for=\"log_op_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOp\">").h("i18n", ctx, {}, { "$key": "query.logicalOpAndLbl" }).w("</label><input type=\"radio\" id=\"log_op_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOpRadio\" name=\"log_op\" value=\"OR\" /><label for=\"log_op_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOp\">").h("i18n", ctx, {}, { "$key": "query.logicalOpOrLbl" }).w("</label></div><div class=\"tc-ctl-wfsquery-whereList\"></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">").h("i18n", ctx, {}, { "$key": "query.noAttributes" }).w("</div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<select class=\"tc-combo\" id=\"attributes\" name=\"attributes\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "query.chooseAttrCombo" }).w("</option>").h("iterate", ctx, { "block": body_3 }, { "on": ctx.get(["attributes"], false), "excludedKeys": "the_geom,FEATURE" }).w("</select>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["key"], false), ctx, "h").w("\">").f(ctx.get(["key"], false), ctx, "h").w("</option>"); } body_3.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-filter'] = function () {
            dust.register(ctlProto.CLASS + '-filter', body_0); function body_0(chk, ctx) { return chk.s(ctx.get(["conditions"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-where-cond\">").f(ctx.get(["field"], false), ctx, "h").w("&nbsp;").f(ctx.get(["opText"], false), ctx, "h").w("&nbsp;").x(ctx.get(["isString"], false), ctx, { "block": body_2 }, {}).f(ctx.get(["valueToShow"], false), ctx, "h", ["numberSeparator"]).x(ctx.get(["isString"], false), ctx, { "block": body_3 }, {}).w("</div><div class=\"tc-ctl-wfsquery-del-cond\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipRemoveCond" }).w("\"></div>\t"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("&quot;"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("&quot;"); } body_3.__dustBody = !0; return body_0; 
        };        
    }

    var checkInput = function (type) {
        var input = document.createElement("input");
        input.setAttribute("type", type);
        return input.type == type;
    };

    var _loadDatePolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    };
    var _loadNumberPolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    }
    var _renderModalDialog = function (layer, layerName, capabilities, callback) {        
        var layers = [];
        layer.getDisgregatedLayerNames().forEach(function (value, index) {
            var path = layer.getPath(value);
            //quitamos aquellas que no estén disponibles en el WFS
            if (capabilities.FeatureTypes.hasOwnProperty(value.substring(value.indexOf(":") + 1)))
                layers.push({ name: value, title: path[path.length - 1] });
        });
        layers.sort(function (a, b) {
            if (a.title < b.title) return -1;
            if (a.title > b.title) return 1;
            return 0;
        });

        ctlProto.getRenderedHtml(ctlProto.CLASS + "-dialog",
            {
                layerName: getLocaleString("query.titleDialog", { "layerName": layerName }),
                layers: layers
            }, function (html) {
                var modal = document.createHTMLElement(html);
                document.body.appendChild(modal);
                modalBody = modal.getElementsByClassName("tc-modal-body")[0]
                modalBody.classList.add(cssClassLoading);

                TC.Util.showModal(modal, {
                    closeCallback: function () {
                        modal.parentElement.removeChild(modal);
                    }
                });
                //IE me hace la puñeta con los estilos, no me fuciona el calc el el max-height así que lo calculo cada vez que muestro el dialogo
                if (TC.Util.detectIE()) {
                    var coef = 1;
                    switch (true) {
                        case document.body.clientWidth > 768 && document.body.clientWidth < document.body.clientHeight:
                        case document.body.clientWidth > 1024:
                            coef = 0.8;
                        case document.body.clientWidth > 1140:
                            coef = 0.7;
                            break;
                    }
                    modalBody.style.maxHeight = (document.body.clientHeight * coef) - modalBody.nextElementSibling.clientHeight - modalBody.previousElementSibling.clientHeight;
                }
                modalDialog = modal;
                modal.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].addEventListener("click", function () {
                    _sendQuery();
                })
                if (callback) callback(modal);
            });
    }

    var _renderQueryForm = function (args) {
        var layer = args[0], dialog = args[1], capabilities = args[2];
        _currentLayer = layer;
        _currentLayercapabilities = capabilities;
        _currentLayerURL = capabilities.Operations.DescribeFeatureType.DCP.HTTP.Get["xlink:href"];
        if (capabilities.Operations.GetFeature.CountDefault)
            _maxRecordCount = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
        else
            _maxRecordCount = null;
        //analizamos si es una o varias capas, si es una agrupación la disgregamos 
        var layers = layer.getDisgregatedLayerNames();
        //quitamos aquellas que no estén disponibles en el WFS
        layers = layers.filter(function (l) {
            return capabilities.FeatureTypes.hasOwnProperty(l.substring(l.indexOf(":") + 1));
        });
        if (layers.length > 1) {
            modalBody.classList.remove(cssClassLoading);
            //bindeamos el onchange de combo
            dialog.getElementsByClassName("tc-combo")[0].addEventListener("change", function () {
                if (!this.value) {
                    var form = dialog.getElementsByClassName("tc-modal-form")[0];
                    form.empty();
                    for (var i = 0; i < form.children.length; i++) form.removeChild(form.children[i]);
                    _clear();
                    return;
                }
                dialog.querySelector(".tc-modal-body .tc-ctl-wfsquery-message", dialog).classList.add(TC.Consts.classes.HIDDEN);
                _currentLayerTitle = this.options[this.selectedIndex].text;
                modalBody.classList.add(cssClassLoading);
                _getDescribeFeature( this.value, capabilities).then(function (data) { _manageDescribeFeature(data, dialog); }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    tbody.empty();
                });
            });
        }
        else {
            //comprabamos que la capa existe en el capabilities
            var layerCapabilities = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)];
            if (layerCapabilities) {
                _currentLayerTitle = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)].Title;
                _getDescribeFeature( layers[0], capabilities).then(function (data) { _manageDescribeFeature(data, dialog); }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    tbody.empty();
                });
            }
            else {
                var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                tbody.classList.remove(cssClassLoading);
                tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                //TC.Util.closeModal();
                //layer.map.toast("Mal", { type: TC.Consts.msgType.WARNING });
            }

        }
    }

    var _getDescribeFeature = function ( layerName, capabilities) {
        _currentLayerName = layerName;
        return new Promise(function (resolve, reject) {
            if (!capabilities.Operations.DescribeFeatureType) {
                TC.error("No está habilitado DescribeFeatureType en este servicio", TC.Consts.msgErrorMode.TOAST);
                return;
            }
            var url = capabilities.Operations.DescribeFeatureType.DCP.HTTP.Get["xlink:href"] + "?REQUEST=DescribeFeatureType&TYPENAME=" + layerName + "&OUTPUTFORMAT=" + capabilities.Operations.DescribeFeatureType.outputFormat


            _currentLayer.toolProxification.fetchXML(url)
                .then(function (response) {
                    var obj = xml2json(response);
                    var objLayer = obj[layerName.substring(layerName.indexOf(":") + 1)];
                    if (objLayer) {
                        var type = objLayer.type
                        resolve(obj[type.substring(type.indexOf(":") + 1)].complexContent.extension.sequence);
                    }
                    else {
                        reject();
                    }
                }).catch(function (error) {
                    TC.error(error);
                });
        });
    }
    var _getValue = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.unmaskedValue;

        } else if (dateInputMask) {
            //si es texto con mascara de fecha convertierto la fecha de dd/mm/yyyy a yyyy-mm-dd
            return dateInputMask.unmaskedValue.substring(4) + "-" + dateInputMask.unmaskedValue.substring(2, 4) + "-" + dateInputMask.unmaskedValue.substring(0, 2)
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var _getValueToShow = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.value;
        }
        else if (dateInputMask) {
            //si es de tipo date devolvemos la fecha en formato dd/mm/yyyy
            return dateInputMask.value;
        }
        else if (input.type === "date") {
            return new Date(input.value).toLocaleDateString(locale)
        }
        else if (input.type === "number") {
            var dotOrComma = 1.1.toLocaleString(locale).substring(1, 2);
            return input.value.replace(".", dotOrComma);
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var dateInputMask = null;
    var inputMaskNumber = null;
    var _createDateMask = function (txtBox) {
        if (checkInput("date"))
            txtBox.type = "date";
        else {
            txtBox.type = "search";
            _loadDatePolyFill().then(function () {
                //construir el polyfill
                dateInputMask = new IMask(txtBox, {
                    mask: Date,
                    pattern: ((!locale || locale === "es-ES") ? 'd/`m/`Y' : (locale === "eu-ES" ? 'Y/`m/`d' : 'm/`d/`Y')),
                    lazy: false,
                    format: function (date) {
                        var day = date.getDate();
                        var month = date.getMonth() + 1;
                        var year = date.getFullYear();
                        if (day < 10) day = "0" + day;
                        if (month < 10) month = "0" + month;
                        switch (locale) {
                            case "eu-ES":
                                return [year, month, day].join('/');
                                break;
                            case "en-US":
                                return [month, day, year].join('/');
                                break;
                            case "es-ES":
                            default:
                                return [day, month, year].join('/');
                                break;
                        }

                    },
                    // define str -> date convertion
                    parse: function (str) {
                        switch (locale) {
                            case "eu-ES":
                                return new Date(str.split('/')[1] + "/" + str.split('/')[2] + "/" + str.split('/')[0])
                                break;
                            case "en-US":
                                return new Date(str)
                                break;
                            case "es-ES":
                            default:
                                return new Date(str.split('/')[1] + "/" + str.split('/')[0] + "/" + str.split('/')[2])
                                break;
                        }

                    },
                    blocks: {
                        d: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 31,
                            maxLength: 2,
                        },
                        m: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 12,
                            maxLength: 2,
                        },
                        Y: {
                            mask: IMask.MaskedRange,
                            from: 1900,
                            to: 9999,
                        }
                    }
                });
            });
        }
    };
    var _destroyDateMask = function () {
        if (dateInputMask) {
            var input = dateInputMask.el.input;
            dateInputMask.destroy();
            dateInputMask = null;
            input.value = "";
            input.type = "search";
        }
    };
    var destroyNumberMask = function () {
        if (inputMaskNumber) {
            var input = inputMaskNumber.el.input;
            inputMaskNumber.destroy();
            inputMaskNumber = null;
            input.value = "";
            input.type = "search";
        }
    };
    var _getDataTypes = function () {
        return _internalGetDataTypes();
    }
    var _manageDescribeFeature = function (data, dialog) {
        _clear();
        _internalGetDataTypes = function () {
            return data;
        };
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-form",
            {
                attributes: data
            }, function (html) {
                var form = dialog.getElementsByClassName("tc-modal-form")[0];
                form.empty();
                form.appendHTML(html);
                modalBody.classList.remove(cssClassLoading);
                TC.loadJS(
                    true,
                    [TC.apiLocation + 'TC/ui/autocomplete.js'],
                    function () {
                        console.log("autocomplete loaded");
                    });
                var type = null;
                var combo = form.getElementsByClassName("tc-combo");
                if (combo.length == 0)
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].setAttribute("disabled", "");
                else {
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].removeAttribute("disabled");
                    combo[0].addEventListener("change", function () {
                        var valueField = form.querySelector(".tc-ctl-wfsquery-where .tc-textbox");
                        if (valueField.dataset["autocomplete"])
                            TC.UI.autocomplete.call(valueField, "clear");
                        if (!data[this.value]) {
                            form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.add("tc-hidden");
                            return;
                        }
                        type = data[this.value].type;
                        form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.remove("tc-hidden");
                        TC.UI.autocomplete.call(valueField, "clear");
                        //$(valueField).unbind("keydown");
                        destroyNumberMask();
                        valueField.type = "search";
                        switch (true) {
                            case type.indexOf("int") >= 0:
                            case type.indexOf("float") >= 0:
                            case type.indexOf("double") >= 0:
                            case type.indexOf("long") >= 0:
                            case type.indexOf("decimal") >= 0:
                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-numeric input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-numeric :first-child").checked = true;                                
                                _destroyDateMask();
                                
                                if (checkInput("number")) {
                                    if (TC.Util.detectIE()) {
                                        valueField.type = "text";
                                        _loadNumberPolyFill().then(function () {
                                            inputMaskNumber = new IMask(valueField, {
                                                mask: Number,  // enable number mask
                                                scale: (type.indexOf("int") >= 0 || type.indexOf("long") >= 0) ? 0 : 2,  // digits after point, 0 for integers
                                                signed: false,  // disallow negative
                                                thousandsSeparator: (locale && locale === "en-US") ? ',' : '.',  // any single char
                                                padFractionalZeros: false,  // if true, then pads zeros at end to the length of scale
                                                normalizeZeros: true,  // appends or removes zeros at ends
                                                radix: (locale && locale === "en-US") ? '.' : ',',  // fractional delimiter
                                            })
                                        });
                                    }
                                    else {
                                        valueField.type = "number";
                                        if (type.indexOf("int") >= 0 || type.indexOf("long") >= 0)
                                            valueField.step = "1";
                                        else
                                            valueField.step = "0.0001";
                                    }                                        
                                }
                                break
                            case type.indexOf("dateTime") >= 0:

                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-date input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-date :first-child").checked = true;
                                _createDateMask(valueField);
                                break;
                            case type.indexOf("string") >= 0:
                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-text input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-text :first-child").checked = true;
                                _destroyDateMask();                                
                                _autocompleteConstructor(valueField, this.value, form.getElementsByClassName(ctlProto.CLASS + "-list tc-ctl-search-list")[0]);
                                break;
                        }
                    });
                    form.querySelector(".tc-ctl-wfsquery-where  input[type='radio']").addEventListener("change", function () {
                        logicalOperator = this.value === "OR" ? TC.Consts.logicalOperator.OR : TC.Consts.logicalOperator.AND
                        //reemplazar en la lista
                        form.getElementsByClassName("tc-ctl-wfsquery-whereList-op")[0].innerHTML = this.nextElementSibling.innerHTML;
                    });
                    
                    form.querySelector(".tc-button").addEventListener("click", function () {
                        var valueField = form.querySelector('input.tc-textbox');
                        TC.UI.autocomplete.call(valueField, "clear");
                        if (inputMaskNumber)
                            inputMaskNumber.masked.remove();
                        if (!_validate(form)) {
                            return;
                        }
                        var field = form.querySelector('.tc-combo').value;
                        var checkeOp = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');
                        var op = checkeOp.value;
                        var opText = checkeOp.nextElementSibling.innerText;

                        var value = _getValue(valueField);
                        var valueToShow = _getValueToShow(valueField);
                        var logOp = form.querySelector('.tc-ctl-wfsquery-where  input[type="radio"]:checked').nextElementSibling.innerText;
                                               
                        //reemplazo < y > por y &lt;&gt;
                        value = value.replace("<", "&lt;").replace(">", "&gt;");
                        //escapo los caracteres no alfamericos                    
                        //value = value.replace(/[^a-z\dáéíóúü]/gi, '!' + '$&');
                        //se añade asterisco al principio y/o final del valor para las busquedas: "empieza por", "termina en" o "contiene"
                        var f;
                        if (type.indexOf("dateTime") >= 0) {
                            if (op !== "nbw")
                                f = new filterByOperation[op](field, value + "T00:00:00Z", value + "T23:59:59Z");
                            else//el not bettween es un caso es especial por que concatena un filtro not y otro between
                            {
                                f = new TC.filter.not(TC.filter.between(field, value + "T00:00:00Z", value + "T23:59:59Z"));
                            }
                        }
                        else
                            f = new filterByOperation[op](
                                field,
                                (((op === "end" || op === "contains") ? '*' : '') + value + ((op === "start" || op === "contains") ? '*' : '')));
                        f.matchCase = false;
                        whereObjList.push(f);
                        switch (true) {
                            case type.indexOf("int") >= 0:
                                valueToShow = parseInt(value,10)
                                break;
                            case type.indexOf("float") >= 0:
                            case type.indexOf("double") >= 0:
                            case type.indexOf("long") >= 0:
                            case type.indexOf("decimal") >= 0:
                                valueToShow = parseFloat(value, 10)
                                break;
                        }
                        whereFilterList.push({
                            "field": field,
                            "opText": opText,
                            "isString": type.indexOf("string")>=0,
                            "valueToShow": valueToShow
                        });
                        
                        _renderFiltersConditions(form);
                        valueField.value = "";
                    });
                }
            });
    };
    var _renderFiltersConditions = function (form) {

        if (!dust.filters.numberSeparator)
            dust.filters.numberSeparator = function (value) {
                return value.toLocaleString(locale);
            };

        var whereDiv = form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0];
        whereDiv.empty();
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-filter", {
            conditions: whereFilterList
        }, function (html) {
            form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0].innerHTML = html;
            var delBtnCollection = form.getElementsByClassName("tc-ctl-wfsquery-del-cond");
            for (var i = 0; i < delBtnCollection.length; i++) {
                delBtnCollection[i].addEventListener("click", function () {
                    var index = Array.prototype.indexOf.call(delBtnCollection, this);
                    whereObjList.splice(index, 1);
                    whereFilterList.splice(index, 1);
                    _renderFiltersConditions(form);
                });
            }
        });
    }
    var _clear = function () {
        whereObjList = [];
        whereFilterList = [];
    };
    var _validate = function (form) {
        var opcion = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');

        if (dateInputMask && !dateInputMask.masked.isComplete) {
            if (/^(?=\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\x20|$))|(?:2[0-8]|1\d|0?[1-9]))([-.\/])(?:1[012]|0?[1-9])\1(?:1[6-9]|[2-9]\d)?\d\d(?:(?=\x20\d)\x20|$))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$/.test(str) === false)
                _showMessage("Fecha " + str + " inválida", TC.Consts.msgType.ERROR);
            return false;
        }
        if (opcion.length == 0) {
            _showMessage(getLocaleString("query.msgNoCondition"));
            return false;
        }
        if (form.querySelectorAll('input[type=\'date\']').length && !form.querySelector('input[type=\'date\']').checkValidity()) {
            _showMessage(getLocaleString("query.msgNoValidDate"));
            return false;
        }
        var number
        if (form.querySelectorAll('input[type=\'number\']').length && ((number = form.querySelector('input[type=\'number\']')) != null) && !number.checkValidity()) {
            if (number.step === "1")
                _showMessage(getLocaleString("query.msgNoValidNumberMustInt"));
            else
                _showMessage(getLocaleString("query.msgNoValidNumber"));
            return false;
        }
        if (form.querySelector('input.tc-textbox').value.trim() === "") {
            _showMessage(getLocaleString("query.msgNoValueCondition"));
            return false;
        }
        return true;
    };
    var _sendQuery = function () {

        if (!_validateQuery()) {
            _showMessage(getLocaleString("query.msgNoQueryFilter"));
            return;
        }
        modalDialog.getElementsByClassName("tc-modal-body")[0].classList.add(cssClassLoading);
        var _fncLoadVectorLayer = function () {
            var filtro = filterConstructor();

            _createResultPanel(_currentLayerTitle);

            _currentLayer.toolProxification.cacheHost.getAction(_currentLayerURL).then(function (cacheHost) {
                const url = cacheHost.action(_currentLayerURL);

                if (!resultLayer) {
                    _createVectorLayer({
                        id: "WFSQueryResults",
                        type: TC.Consts.layerType.WFS,
                        url: url,
                        version: "1.1.0",
                        stealth: true,
                        geometryName: "the_geom",
                        featurePrefix: _currentLayerName.substring(0, _currentLayerName.indexOf(":")),
                        featureType: _currentLayerName.substring(_currentLayerName.indexOf(":") + 1),
                        maxFeatures: _maxRecordCount,
                        properties: filtro,
                        outputFormat: TC.Consts.format.JSON,
                        styles: _getStyles()
                    });
                    map.on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                        if (e.control !== ctlResultsPanel)
                            return;
                        if (TC.browserFeatures.touch()) {
                            TC.Util.swipe(e.control.div, "enable");
                        }
                        resultLayer.clearFeatures();
                        resultLayer.setVisibility(false);
                        map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    });
                }
                else {
                    resultLayer.setVisibility(false);
                    resultLayer.clearFeatures();
                    //borro el evento featureUpdate por si hago una búsqueda sin cerra el panel previamente
                    map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    resultLayer.url = url;
                    resultLayer.featurePrefix = _currentLayerName.substring(0, _currentLayerName.indexOf(":"));
                    resultLayer.featureType = _currentLayerName.substring(_currentLayerName.indexOf(":") + 1);
                    resultLayer.maxFeatures = _maxRecordCount;
                    resultLayer.properties = filtro;
                    resultLayer.setVisibility(true);
                    resultLayer.refresh();
                }
            });
        }

        if (_maxRecordCount)
            _numHits(map).then(_fncLoadVectorLayer, function (error) {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading)
                if (error.err === "NumMaxFeatures") {
                    _showMessage(getLocaleString("query.msgTooManyResults", { limit: error.limit }), TC.Consts.msgType.WARNING)
                }
                else if (error.err === "Empty") {
                    _showMessage(getLocaleString("query.msgNoResults"), TC.Consts.msgType.INFO);
                }
                else {
                    console.error(error.errorThrown)
                    _showMessage(getLocaleString("query.errorUndefined"), TC.Consts.msgType.ERROR);
                }

            });
        else
            _fncLoadVectorLayer();
        //si está disponible el atributo CountDefault compruebo que no se sobrepasa la longitud

    }
    var _createVectorLayer = function (layerOptions) {
        map.addLayer(layerOptions).then(function (layer) {
            resultLayer = layer;
            layer.map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
        });
    };
    var filterConstructor = function () {
        if (whereObjList.length > 1) {
            var condicion = document.querySelector(".tc-ctl-wfsquery-logOpRadio:checked").value;
            return TC.filter[TC.Consts.logicalOperator[condicion]].apply(null, whereObjList);
        }
        else if (whereObjList.length === 0)
            return null
        else
            return whereObjList[0];
    }
    var _featuresUpdate = function (e) {
        if (e.layer == resultLayer) {
            var features = e.layer.features;
            if (features.length > 0) {
                map.zoomToFeatures(features);
                _showResultPanel(
                    (features.length > 1 ?
                        features.reduce(function (vi, va, index) {
                            return (vi instanceof Array ? vi : [vi.data]).concat([va.data])
                        })
                        :
                        [features[0].data])
                    , resultLayer, _currentLayerTitle);
            }
            else {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading);
                _showMessage("No hay resultados", TC.Consts.msgType.INFO);
            }
            e.layer.map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
        }
    };
    var _createResultPanel = function (layerName) {
        var _layerName = layerName;
        new Promise(function (resolve, reject) {
            if (!TC.control.ResultsPanel) {
                TC.loadJS(true, TC.apiLocation + 'TC/control/ResultsPanel', function () {
                    resolve(TC.control.ResultsPanel);
                });
            }
            else
                resolve(TC.control.ResultsPanel);
        }).then(function (ResultsPanel) {
            if (!ctlResultsPanel) {
                var fncResultPanelAdded = function (ctl) {
                    ctlResultsPanel = ctl;
                    delete dust.cache[ctlResultsPanel.CLASS + "-table"];
                    if (TC.isDebug) {
                        ctlResultsPanel.template[ctlResultsPanel.CLASS + "-table"] = TC.apiLocation + "TC/templates/WFSQueryResultsTable.html";
                    }
                    else {
                        ctlResultsPanel.template[ctlResultsPanel.CLASS + "-table"] = dust.register(ctlResultsPanel.CLASS + "-table", body_0); function body_0(chk, ctx) { return chk.w("<table class=\"table\"><thead>").s(ctx.get(["columns"], false), ctx, { "block": body_1 }, {}).w("</thead><tbody>").s(ctx.get(["results"], false), ctx, { "block": body_2 }, {}).w("</tbody></table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<th>").f(ctx.getPath(true, []), ctx, "h").w("</th>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<tr title=\"").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("\" data-id=\"").f(ctx.get(["Id"], false), ctx, "h").w("\" data-index=\"").f(ctx.get(["$idx"], false), ctx, "h").w("\" class=\"tc-selectable\">").h("iterate", ctx, { "block": body_3 }, { "on": ctx.getPath(true, []) }).w("</tr>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("select", ctx, { "block": body_4 }, { "key": ctx.get(["key"], false) }); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<td class=\"").f(ctx.get(["key"], false), ctx, "h", ["removeAccents", "downcase"]).w("\">").h("startsWith", ctx, { "else": body_5, "block": body_6 }, { "key": ctx.get(["value"], false), "value": "http" }).w("</td>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.get(["value"], false), ctx, "h", ["numberSeparator"]); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<a href=\"").f(ctx.get(["value"], false), ctx, "h").w("\" target=\"_blank\" title=\"").h("i18n", ctx, {}, { "$key": "query.linkOpenAtNewTab" }).w("\">").h("i18n", ctx, {}, { "$key": "query.linkText" }).w("</a>"); } body_6.__dustBody = !0; return body_0
                    }
                    ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');                    
                }
                var ccontainer = map.getControlsByClass(TC.control.ControlContainer);
                if (ccontainer.length == 0) {
                    map.addControl("ResultsPanel",
                        {
                            "content": "table",
                            "titles": {
                                "main": "",
                                "max": ""
                            },
                            "save": {
                                "fileName": _layerName + ".xls"
                            }
                        }).then(fncResultPanelAdded);
                }
                else {
                    ccontainer[0].addControl("ResultsPanel", {
                        "content": "table",
                        "titles": {
                            "main": "",
                            "max": ""
                        },
                        "save": {
                            "fileName": _layerName + ".xls"
                        }, "side": "right"
                    }).then(fncResultPanelAdded);
                }
            }
            else {
                ctlResultsPanel.options.save.fileName = _layerName + ".xls";
                ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');
            }
        });
    };
    var _showResultPanel = function (data, layer, layername) {

        //map.$events.trigger(TC.Consts.event.SEARCHDONE, { data: data } );

        var truthTest = function (name, test) {
            return function (chunk, context, bodies, params) {
                return filter(chunk, context, bodies, params, name, test);
            };
        }        
        
        //en funcion del número de elementos cargo un título en singular o plural

        ctlResultsPanel.div.querySelector(".prpanel-title-text").innerText = ctlResultsPanel.getLocaleString(data.length > 1 ? 'query.titleResultPaneMany' : 'query.titleResultPanelOne', { "numero": data.length, "layerName": layername });
                
        ctlResultsPanel.div.classList.add("tc-ctl-wfsquery-results");
        
        modalDialog.parentElement.removeChild(modalDialog);
        
        ctlResultsPanel.openTable({
            data: data,
            css: {
                trClass: "trClass",
                tdClass: "tdClass",
                thClass: "thClass",
            },
            callback: function (tabla) {
                
                ctlResultsPanel.maximize();
                console.log("render del panel de resultados");
                var col = tabla.getElementsByTagName("tr");
                var dataTypes = _getDataTypes();
                var j = 1;
                for (var i in data[0]) {
                    if (dataTypes.hasOwnProperty(i)) {
                        if (dataTypes[i].type.indexOf("int") >= 0 ||
                            dataTypes[i].type.indexOf("float") >= 0 ||
                            dataTypes[i].type.indexOf("double") >= 0 ||
                            dataTypes[i].type.indexOf("long") >= 0 ||
                            dataTypes[i].type.indexOf("decimal") >= 0) {
                            var tdNumeric = tabla.querySelectorAll("td:nth-child(" + j + ")");
                            for (var k = 0; k < tdNumeric.length; k++) {
                                tdNumeric[k].classList.add("tc-numeric");
                            }
                        }
                    }
                    j++;
                }

                
                for (var i = 0; i < col.length; i++) {
                    col[i].addEventListener("click", function (e) {
                        e.stopPropagation();
                        var index = this.dataset.index;
                        if (index != undefined)
                            layer.map.zoomToFeatures([layer.features[index]]);
                    });
                    col[i].addEventListener("mouseenter", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.select();
                            _select(feat);
                        }
                        for (var i = 0; i < this.children.length; i++) {
                            var td = this.children[i];
                            if (td.offsetWidth < td.scrollWidth)
                                td.title = td.innerText;
                        }

                    });
                    col[i].addEventListener("mouseleave", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.unselect();
                            _unselect(feat)
                            //esto es porque el unselect no devulve al estilo por defecto
                            //feat.setStyle(TC.Cfg.styles[feat.STYLETYPE]);
                        }
                    });
                }
                ////se deshabilita el swipe para que se pueda hacer scroll horizontal del panel de resultados
                if (TC.browserFeatures.touch()) {
                    TC.Util.swipe(ctlResultsPanel.div, 'disable');
                }
            }
        });

    }
    var _validateQuery = function () {
        return whereObjList.length > 0;
    };
    var _showMessage = function (Message, type) {
        var messageDiv = modalBody.getElementsByClassName("tc-ctl-wfsquery-message")[0];
        if (timer) {
            clearTimeout(timer);
        }
        else {
            messageDiv.innerHTML=Message;
            switch (type) {
                case TC.Consts.msgType.INFO:
                    messageDiv.classList.add("tc-msg-info")
                    break;
                case TC.Consts.msgType.WARNING:
                    messageDiv.classList.add("tc-msg-warning")
                    break;
                case TC.Consts.msgType.ERROR:
                default:
                    messageDiv.classList.add("tc-msg-error")
                    break;
            }
            messageDiv.classList.remove(TC.Consts.classes.HIDDEN);
        }
        timer = setTimeout(function () {
            timer = null;
            messageDiv.classList.add(TC.Consts.classes.HIDDEN);
        }, 3000)
    };
    var _getPossibleValues = function (field, value) {
        return new Promise(function (resolve, reject) {
            var _capabilities = Object.assign({}, _currentLayercapabilities);
            _capabilities.version = "1.1.0";
            switch (document.querySelector(".tc-ctl-wfsquery.tc-ctl-wfsquery-text input:checked").value) {
                case "start":
                    value = (value + "*");
                    break;
                case "contains":
                case "eq":
                    value = ("*" + value + "*");
                    break;
                case "end":
                    value = ("*" + value);
                    break;
            }
            if (autoCompletePromise) {
                autoCompletePromise = null;
            }
            //autoCompletePromise = TC.ajax({
            //    url: _currentLayerURL + '?' + Date.now(),
            //    data: TC.Util.WFSQueryBuilder([_currentLayer], TC.filter.like(field, value, undefined, undefined, undefined, false), _capabilities, "JSON", false),
            //    contentType: "application/xml",
            //    responseType: "application/json",
            //    method: "POST",
            //});
            autoCompletePromise = _currentLayer.toolProxification.fetchJSON(_currentLayerURL + '?' + Date.now().toString(),{                
                data: TC.Util.WFSQueryBuilder([_currentLayerName], TC.filter.like(field, value, undefined, undefined, undefined, false), _capabilities, "JSON", false),
                contentType: "application/xml",                
                method: "POST",
            });
            autoCompletePromise.then(function (data) {
                if (data.features && data.features.length > 0) {
                    var arr;
                    if (data.features.length === 1)
                        arr = [data.features[0].properties[field]];
                    if (data.features.length > 1)
                        arr = data.features.reduce(function (pv, cv) {
                            if (pv && pv instanceof Array) {
                                if (pv.indexOf(cv.properties[field]) < 0)
                                    return pv.concat(cv.properties[field]);
                                else
                                    return pv;
                            }
                            else {
                                if (pv.properties[field] === cv.properties[field])
                                    return [pv.properties[field]]
                                else
                                    return [pv.properties[field], cv.properties[field]]
                            }
                        });
                    //arr.sort();
                    resolve(arr);
                } else reject(null);
            });
        });
    };
    var _autocompleteConstructor = function (control, property, listCtrl) {

        TC.UI.autocomplete.call(control, {
            minLength: 3,
            target: listCtrl,
            source: function (text, callback) {
                var _self = this;
                _self.target.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + getLocaleString("searching") + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>'
                _self.target.classList.remove("tc-hidden");
                _getPossibleValues(property, text).then(callback).catch(function () {
                    _self.target.classList.add("tc-hidden");
                });
            },
            callback: function (e) {
                control.value = e.currentTarget.dataset["value"];
                this.target.classList.add("tc-hidden");
            },
            buildHTML: function (data) {
                var pattern = control.value;
                this.target.style.maxHeight = "";
                if (data.results.length > 1)
                    return data.results.reduce(function (pv, cp, i) {
                        return (i > 1 ? pv : _highlightText(pv, pattern)) + _highlightText(cp, pattern);
                    });
                else
                    return _highlightText(data.results[0], pattern);
            }
        });
        control.addEventListener("targetCleared.autocomplete", function () {
            listCtrl.classList.add("tc-hidden");
        });
        control.addEventListener('keypress', function (e) {
            if (e.which == 13) {
                TC.UI.autocomplete.call(control, "clear");
            }
        });
        control.addEventListener("search", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
        control.addEventListener("input", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
    };
    var _highlightText = function (text, pattern) {
        pattern = new RegExp(pattern, "gi");
        return "<li><a href=\"#\" data-value=\"" + text + "\">" + text.replace(pattern, '<b>$&</b>') + "</a></li>";
    };
    var _numHits = function (map) {
        return new Promise(function (resolve, reject) {
            var filtro = filterConstructor();
            var _capabilities = Object.assign({}, _currentLayercapabilities);
            _capabilities.version = "1.1.0";
            //TC.ajax({
            //    url: _currentLayerURL,
            //    data: TC.Util.WFSQueryBuilder([_currentLayerName], filtro, _capabilities, null, true),
            //    contentType: "application/xml",
            //    method: "POST"
            //})
            _currentLayer.toolProxification.fetchXML(_currentLayerURL,{
                data: TC.Util.WFSQueryBuilder([_currentLayerName], filtro, _capabilities, null, true, map.getCRS()),                
                method: "POST"
            }).then(function (response) {
                    var capabilitiesAsJSON = xml2json(response);
                if (capabilitiesAsJSON.Exception) {
                    reject({
                        err: capabilitiesAsJSON.Exception.exceptionCode, errorThrown: capabilitiesAsJSON.Exception.ExceptionText
                    });
                    return;
                }
                var featFounds = parseInt(capabilitiesAsJSON.numberMatched || capabilitiesAsJSON.numberOfFeatures, 10)
                if (isNaN(featFounds) || featFounds >= parseInt(_maxRecordCount, 10)) {
                    reject({
                        err: "NumMaxFeatures", limit: _maxRecordCount
                    });
                    return;
                }
                else if (!isNaN(featFounds) && featFounds === 0) {
                    reject({
                        err: "Empty"
                    });
                    return;
                }
                resolve();
            }).catch(function (xhr, state, message) {
                reject({
                    err: state, errorThrown: message
                });
            });
        });
    };
    var _select = function (feature) {
        var _addFeature = function (layer, feature) {
            var result
            if (feature instanceof TC.feature.Point) {
                result = layer.addPoint(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polyline) {
                result = layer.addPolyline(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polygon) {
                result = layer.addPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolygon) {
                result = layer.addMultiPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolyline) {
                result = layer.addMultiPolyline(feature.getCoords());
            }
            return result;
        };
        if (!feature.layer)
            return;
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (!layer) {
            feature.layer.map.addLayer({
                id: "WFSQueryResultsHighlight",
                type: TC.Consts.layerType.VECTOR,
                stealth: true,
                styles: _getHighLightStyles()
            }, function (layer) {
                _addFeature(layer, feature);
            });
        }
        else
            _addFeature(layer, feature);             
    };
    var _unselect = function (feature) {
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (layer) {
            layer.clearFeatures();
        }
    };
    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);
        return result;
    };

    ctlProto.register = function (_map) {
        const self = this;
        map = _map;
        return new Promise(function (resolve) {

            //condición IF si una coleccion de atributos tiene 1 o mas elementos. Tiene una lista negra llamada excludedKeys
            dust.helpers.countif = function (chunk, context, bodies, params) {
                params = params || {};
                var body = bodies.block, skip = bodies['else'], key = params["key"] || context.current();
                var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;
                var _count = 0
                for (var k in key) {
                    if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                        _count++;
                    }
                }
                if (_count > 0) {
                    chunk = chunk.render(body, context);
                }
                else if (skip) {
                    chunk = chunk.render(skip, context);
                }
                return chunk;
            }

            TC.Control.prototype.register.call(self, map).then(function () {                
                _getStyles = function () {
                    var _default = TC.Util.extend(true, {}, TC.Cfg.styles, {
                        "polygon": {
                            fillColor: "#ffffff",
                            fillOpacity: 0,
                            strokeColor: "#ff0000",
                            strokeWidth: 2
                        },
                        "polyline": {
                            strokeColor: "#ff0000",
                            strokeWidth: 2
                        },
                        "point": {
                            strokeColor: "#ff0000"
                        }
                    });
                    return self.styles ? Object.assign(_default, self.styles) : _default;
                };
                _getHighLightStyles = function () {
                    var _default = TC.Util.extend(true, {}, TC.Cfg.styles, {
                        "polygon": {
                            fillColor: "#0099FF",
                            fillOpacity: 0,
                            strokeColor: "#0099FF",
                            strokeWidth: 4
                        },
                        "polyline": {
                            strokeColor: "#0099FF",
                            strokeWidth: 4
                        },
                        "point": {
                            strokeColor: "#0099FF"
                        }
                    });
                    return self.highLightStyles ? Object.assign(_default, self.highLightStyles) : _default;
                };

                locale = map.options.locale;

                getLocaleString = function (key, texts) {
                    return TC.Util.getLocaleString(locale, key, texts);
                }
                resolve();
            });
        });
    };
    ctlProto.renderModalDialog = function (layer) {
        var path = layer.getPath();
        var renderDialogPromise = new Promise(function (resolve, reject) {
            layer.getWFSCapabilitiesPromise().then(function (capabilities) {
                _renderModalDialog(layer, path[path.length - 1], capabilities, function (modal) {
                    resolve(modal);
                });
            })
        });

        Promise.all([layer, renderDialogPromise, layer.getWFSCapabilitiesPromise()]).then(_renderQueryForm);
    };

})();

TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

TC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';

(function () {

    var capabilitiesPromises = {};

    const isWebWorkerEnabled = window.hasOwnProperty('Worker');
    const wwPromise = new Promise(function (resolve, reject) {
        if (isWebWorkerEnabled) {
            // Para evitar problemas con IE10 y Opera evitamos el uso de blobs cuando es evitable
            var wwLocation = TC.apiLocation + 'TC/workers/tc-caps-web-worker.js';
            if (TC.Util.isSameOrigin(TC.apiLocation)) {
                resolve(wwLocation);
            }
            else {
                TC.ajax({
                    url: wwLocation,
                    method: 'GET',
                    responseType: 'text'
                }).then(
                    function (response) {
                        const data = response.data;
                        var blob = new Blob([data], { type: "text/javascript" });
                        var url = window.URL.createObjectURL(blob);
                        resolve(url);
                    },
                    function (e) {
                        reject(Error(e));
                    }
                    );
            }
        }
    });

    const parseCapabilities = function (layer, data) {
        var capabilities;

        if (data.documentElement) {

            const serviceException = data.getElementsByTagName('ServiceException')[0];
            if (serviceException) {
                capabilities = { error: serviceException.textContent };
            }
            else {
                var format = (layer.type === TC.Consts.layerType.WMTS) ? new layer.wrap.WmtsParser() : new layer.wrap.WmsParser();
                capabilities = format.read(data);

                //parsear a manija los tileMatrixSetLimits, que openLayers no lo hace (de momento)
                if (layer.type === TC.Consts.layerType.WMTS) {
                    if (capabilities.Contents && capabilities.Contents.Layer) {
                        const layerCollection = data.getElementsByTagName('Layer');
                        for (var i = 0, len = layerCollection.length; i < len; i++) {
                            const curXmlLy = layerCollection[i];
                            var nd = TC.Util.getElementByNodeName(curXmlLy, "ows:Identifier")[0];
                            var id = nd.firstChild.data;

                            var capLy = capabilities.Contents.Layer.filter(function (ly) {
                                return ly.Identifier == id;
                            });

                            if (capLy.length) {
                                capLy = capLy[0];
                                for (var j = 0; j < capLy.TileMatrixSetLink.length; j++) {
                                    var capLink = capLy.TileMatrixSetLink[j];
                                    matrixId = capLink.TileMatrixSet;

                                    var xmlLink;
                                    const xmlLinks = curXmlLy.getElementsByTagName('TileMatrixSetLink');
                                    for (var k = 0, kk = xmlLinks.length; k < kk; k++) {
                                        const curLink = xmlLinks[k];
                                        if (curLink.querySelector("TileMatrixSet:first").textContent == matrixId) {
                                            xmlLink = curLink;
                                            break;
                                        }
                                    }

                                    if (xmlLink) {
                                        capLink.TileMatrixSetLimits = [];
                                        const tmlCollection = xmlLink.getElementsByTagName('TileMatrixLimits');
                                        for (var k = 0, kk = tmlCollection.length; k < kk; k++) {
                                            const lim = tmlCollection[k];
                                            capLink.TileMatrixSetLimits.push({
                                                TileMatrix: lim.getElementsByTagName('TileMatrix')[0].textContent,
                                                MinTileRow: parseInt(lim.getElementsByTagName('MinTileRow')[0].textContent),
                                                MinTileCol: parseInt(lim.getElementsByTagName('MinTileCol')[0].textContent),
                                                MaxTileRow: parseInt(lim.getElementsByTagName('MaxTileRow')[0].textContent),
                                                MaxTileCol: parseInt(lim.getElementsByTagName('MaxTileCol')[0].textContent)
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            storeCapabilities(layer, capabilities);
            return Promise.resolve(capabilities);
        }
        else {
            return new Promise(function (resolve, reject) {
                if (isWebWorkerEnabled && typeof data === 'string') {
                    wwPromise.then(function (wwUrl) {
                        var worker = new Worker(wwUrl);
                        worker.onmessage = function (e) {
                            if (e.data.state === 'success') {
                                capabilities = e.data.capabilities;

                                // GLS: Sólo almacenamos si el capabilities es correcto
                                storeCapabilities(layer, capabilities);
                            }
                            else {
                                capabilities = {
                                    error: 'Web worker error'
                                }
                                reject(capabilities.error);
                            }

                            resolve(capabilities);
                            worker.terminate();
                        };
                        worker.postMessage({
                            type: layer.type,
                            text: data
                        });
                    })
                }
                else {
                    capabilities = data;
                    resolve(capabilities);
                }
            });
        }
    };

    const capabilitiesError = function (layer, reason) {
        return 'No se pudo obtener el documento de capacidades del servicio ' + layer.url + ': [' + reason + ']';
    };

    const getCapabilitiesOnline = function (layer) {
        return new Promise(function (resolve, reject) {
            const url = layer.getGetCapabilitiesUrl();

            layer.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {
                parseCapabilities(layer, data.responseText)
                    .then(function (capabilities) {
                        if (capabilities.error) {
                            reject(Error(capabilitiesError(layer, capabilities.error)));
                            return;
                        }
                        resolve(capabilities);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            }).catch(function (dataError) {
                reject(Error(capabilitiesError(layer, dataError)));
            });

        });
    };

    const getCapabilitiesFromStorage = function (layer) {
        return new Promise(function (resolve, reject) {
            // Obtenemos el capabilities almacenado en caché
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(layer.CAPABILITIES_STORE_KEY_PREFIX + layer.url)
                    .then(function (value) {
                        if (value) {
                            resolve(value);
                        }
                        else {
                            reject(Error('Capabilities not in storage: ' + layer.url));
                        }
                    })
                    .catch(function () {
                        reject(Error('Undefined storage error'));
                    });
            });
        });
    };

    const storeCapabilities = function (layer, capabilities) {
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {

            // Esperamos a que el mapa se cargue y entonces guardamos el capabilities.
            // Así evitamos que la operación, que es bastante pesada, ocupe tiempo de carga 
            // (con el efecto secundario de que LoadingIndicator esté un tiempo largo apagado durante la carga)
            var capKey = layer.CAPABILITIES_STORE_KEY_PREFIX + layer.options.url;
            var setItem = function () {
                // GLS: antes de guardar, validamos que es un capabilities sin error
                if (capabilities.hasOwnProperty("error")) {
                    return;
                } else {

                    layer.getCapabilitiesPromise().then(function () {
                        localforage.setItem(capKey, capabilities).then(function () { }).catch(function (err) {
                            console.log(err);
                        });
                    });
                }
            };
            if (layer.map) {
                layer.map.loaded(setItem);
            }
            else {
                setItem();
            }
        });
    };

    const _createWMSLayer = function (layer) {

        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;
        var format = layer.options.format;
        var options = layer.options;

        var params = {
            LAYERS: layerNames,
            FORMAT: format,
            TRANSPARENT: layer.transparent,
            VERSION: layer.capabilities.version || '1.3.0'
        };

        if (layer.params) {
            TC.Util.extend(params, layer.params);
        }

        if (layer.queryParams) {
            TC.Util.extend(params, layer.queryParams);
        }

        var infoFormat = layer.getPreferredInfoFormat();
        if (infoFormat !== null) {
            params.INFO_FORMAT = infoFormat;
        }

        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);
    };

    const _createWMTSLayer = function (layer) {
        return layer.wrap.createWMTSLayer(layer.options);
    };

    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {

        var result = layer.availableNames.indexOf(treeNode.name);
        if (result === -1) {
            for (var i = 0, len = treeNode.children.length; i < len; i++) {
                result = _getLayerNodeIndex(layer, treeNode.children[i]);
                if (result !== -1) {
                    break;
                }
            }
        }
        return result;
    }

    const _sortTree = function _sortTree(layer, treeNode) {
        var _sortFunction = function (n1, n2) {
            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);
        }
        treeNode.children.sort(_sortFunction);
        for (var i = 0, len = treeNode.children.length; i < len; i++) {
            _sortTree(layer, treeNode.children[i]);
        }
    };

    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {
        var result = false;
        counter.count = counter.count + 1;
        if (treeNode.name === name) {
            result = true;
        }
        else {
            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés
            for (var i = treeNode.children.length - 1; i >= 0; i--) {
                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Opciones de nombre de capa.
     * Esta clase no tiene constructor.
     * @class TC.cfg.LayerNameOptions
     * @static
     */
    /**
     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.
     * @property aggregate
     * @type boolean
     * @default true
     */
    /**
     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} (valor <code>false</code>) 
     * o se espera a que la capa se actualice (valor <code>true</code>).
     * @property lazy
     * @type boolean
     * @default false
     */
    /**
     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/availableNames:property"}}{{/crossLink}} (valor <code>false</code>) se restablece 
     * al actualizar la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}}.
     * @property reset
     * @type boolean|undefined
     */

    /**
     * Opciones de capa raster.
     * Esta clase no tiene constructor.
     * @class TC.cfg.RasterOptions
     * @extend TC.cfg.LayerOptions
     * @static
     */
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     * @default TC.Consts.layerType.WMS
     */
    /**
     * URL del servicio OGC que define la capa.
     * @property url
     * @type string
     */
    /**
     * Indica si la capa tiene transparencia.
     * @property transparent
     * @type boolean|undefined
     */
    /**
     * Lista separada por comas de los nombres de capa del servicio OGC.
     * @property layerNames
     * @type string|undefined
     */
    /**
     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.
     * @property matrixSet
     * @type string|undefined
     */

    /**
     * Capa de tipo raster, como la de un WMS o un WMTS.
     * @class TC.layer.Raster
     * @extends TC.Layer
     * @constructor
     * @async
     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
     */
    TC.layer.Raster = function () {
        var self = this;

        if (!TC.tool || !TC.tool.Proxification) {
            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
        }

        this.toolProxification = new TC.tool.Proxification(TC.proxify);

        //esta promise se resolverá cuando el capabilities esté descargado y parseado
        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa
        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)
        this._capabilitiesPromise = null;

        TC.Layer.apply(self, arguments);

        self.wrap = new TC.wrap.layer.Raster(self);

        /**
         * Indica si la capa tiene transparencia.
         * @property transparent
         * @type boolean
         * @default true
         */
        self.transparent = (self.options.transparent === false) ? false : true;

        /**
         * URL del servicio al que pertenenece la capa.
         * @property url
         * @type string
         */
        self.url = self.options.url;
        self.capabilities = TC.capabilities[self.url];

        self.params = self.options.params;
        /**
         * Lista de nombres de capa.
         * @property names
         * @type array
         * @default []
         */
        /**
         * Lista de nombres de capa disponibles inicialmente.
         * @property availableNames
         * @type array
         * @default []
         */
        if (typeof self.options.layerNames === 'string') {
            self.names = self.availableNames = self.options.layerNames.split(',');
        }
        else {
            self.names = [];
            self.availableNames = [];
            if (Array.isArray(self.options.layerNames)) {
                for (var i = 0; i < self.options.layerNames.length; i++) {
                    var name = self.options.layerNames[i];
                    if (typeof name === 'string') {
                        self.names.push(name);
                        self.availableNames.push(name);

                    }
                    else if (name.hasOwnProperty('name')) {
                        self.availableNames.push(name.name);
                        if (name.isVisible === undefined || name.isVisible) {
                            self.names.push(name.name);
                        }
                    }
                }
            } else {
                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado
                // cuando queremos instanciar una capa pasándole un SLD en la petición
                var sldBody = self.options.params ? self.options.params.sld_body : null;

                if (sldBody) {
                    const parser = new DOMParser();
                    var sldBodyToXml;
                    try {
                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');
                    }
                    catch (e) {
                        TC.error(e.message);
                        sldBodyToXml = null;
                    }
                    if (sldBodyToXml) {
                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');
                        if (namedLayerElm && namedLayerElm.length > 0) {
                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');

                            if (names && names.length > 0) {
                                var name = names[0].textContent;
                                self.names.push(name);
                                self.availableNames.push(name);
                            }
                        }
                    }
                }
            }
        }

        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;

        self._capabilitiesNodes = {};

        /**
      * Árbol del documento de capabilities del servicio.
      * @property capabilities
      * @type object
      */
        self.wrap._promise = new Promise(function (resolve, reject) {
            /*
             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo
             */
            var _createOLLayer = function () {
                var ollyr;
                if (!self.wrap.layer) {
                    switch (self.type) {
                        case TC.Consts.layerType.GROUP:
                            break;
                        case TC.Consts.layerType.WMTS:
                            ollyr = _createWMTSLayer(self);
                            break;
                        default:
                            ollyr = _createWMSLayer(self);
                            break;
                    }
                    self.wrap.setLayer(ollyr);
                    if (ollyr) {
                        resolve(ollyr);
                    }
                    else {
                        reject(Error('Could not create native layer for "' + self.id + '"'));
                    }
                }
            };

            const processedCapabilities = function (capabilities) {
                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.
                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.
                self.capabilities = self.capabilities || capabilities;

                var actualUrl = self.getGetMapUrl();
                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;
                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;

                _createOLLayer();
            };

            if (self.capabilities) {
                processedCapabilities(self.capabilities);
                self._capabilitiesPromise = Promise.resolve(self.capabilities);
                return;
            }

            const cachePromise = capabilitiesPromises[self.url];
            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {
                const onlinePromise = getCapabilitiesOnline(self);
                const storagePromise = getCapabilitiesFromStorage(self);

                onlinePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function (error) {
                        storagePromise.catch(function () {
                            rej(error);
                        });
                    });
                storagePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function () {
                        onlinePromise.catch(function (error) {
                            rej(error);
                        });
                    });
            });

            self.getCapabilitiesPromise()
                .then(function (capabilities) {
                    processedCapabilities(capabilities);
                })
                .catch(function (error) {
                    if (self.map) {
                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });
                    }
                    reject(error);
                });
        });

        self._disgregatedLayerNames = null;

        if (TC.Consts.layerType.WMTS == self.type) {
            self.wrap.setWMTSUrl();
        }
    };

    TC.inherit(TC.layer.Raster, TC.Layer);

    var layerProto = TC.layer.Raster.prototype;

    layerProto.PROTOCOL_REGEX = /^(f|ht)tp?:\/\//i;
    layerProto.capabilitiesState_ = {
        PENDING: 0,
        DONE: 1
    };

    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';

    layerProto.getByProxy_ = function (url) {
        return TC.proxify(url);
    };

    layerProto.getBySSL_ = function (url) {
        var self = this;

        return url.replace(self.PROTOCOL_REGEX, "https://");
    };

    layerProto.getByUrl_ = function (url) {
        return url;
    };


    layerProto.setVisibility = function (visible) {
        var layer = this;
        layer.tree = null;
        layer._cache.visibilityStates = {
        };
        TC.Layer.prototype.setVisibility.call(layer, visible);
    };

    /*
     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)
     */
    var _getLimitedMatrixSet = function (layer) {
        var layerId = layer.layerNames;
        var matrixId = layer.matrixSet;
        var cap = layer.capabilities;

        var ret = [];

        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {
            return elto.Identifier == matrixId;
        });
        if (tset.length) {
            tset = tset[0];
            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];
            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {
                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;
                for (var i = 0; i < limits.length; i++) {
                    limit = limits[i];
                    var matrix = tset.TileMatrix.filter(function (elto) {
                        return elto.Identifier == limit.TileMatrix
                    });
                    if (matrix.length) {
                        var combi = TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);
                        ret.push(combi);
                    }
                }

                return ret;
            }
            else {
                return tset.TileMatrix;
            }
        }
        else
            return null;
    };


    /*
     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen
     */
    var _aggregateLayerNames = function (layer, layerNames) {
        if (layer.type !== TC.Consts.layerType.WMS) {
            return layerNames;
        }
        else {
            var ln = layerNames.slice();
            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());
            return ln;
        }
    };

    /*
     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.
     * Se parte de un nodo del árbol de capas del capabilities
     */
    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {
        var result = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        if (children.length) {
            for (var i = 0, len = children.length; i < len; i++) {
                if (_aggregateLayerNodeNames(layer, names, children[i])) {
                    result = true;
                }
            }

            var nodeNames = children.map(function (elm) {
                return layer.wrap.getName(elm);
            }).reverse();
            var idx, firstIdx;
            var fail = false;

            firstIdx = idx = names.indexOf(nodeNames[0]);
            if (idx < 0) {
                fail = true;
            }
            else {
                for (var i = 1, len = nodeNames.length; i < len; i++) {
                    if (nodeNames[i] != names[++idx]) {
                        fail = true;
                        break;
                    }
                }
            }
            if (!fail) {
                var nodeName = layer.wrap.getName(layerNode);
                if (nodeName && nodeNames.length > 1) {
                    names.splice(firstIdx, nodeNames.length, nodeName);
                    result = true;
                }
            }
        }
        return result;
    };

    /*
     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.
     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible
     */
    var _disgregateLayerNames = function (layer, layerNames) {
        var result = [];
        var ln = layerNames.slice();
        var rootNode = layer.wrap.getRootLayerNode();
        for (var i = 0, len = ln.length; i < len; i++) {
            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));
        }
        return result;
    };

    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {
        var result = [];
        var nodeName = layer.wrap.getName(layerNode);
        var nodeVisible = layer.compareNames(name, nodeName);
        var hasEmptyChildren = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        for (var i = 0; i < children.length; i++) {
            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);
            if (!names.length) {
                hasEmptyChildren = true;
            }
            else {
                result = result.concat(names);
            }
        }
        if (!children.length || hasEmptyChildren) {
            if (ancestorVisible || nodeVisible) {
                result = [nodeName];
            }
        }
        return result;
    };

    var _extendLayerNameOptions = function (options) {
        return TC.Util.extend({ aggregate: true, lazy: false }, options);
    };

    var _combineArray = function (source, add, rem) {
        var result = [];
        var s, a, r;
        s = source ? source : [];
        a = add ? add : [];
        r = rem ? rem : [];
        var sa = s.concat(a);
        for (var i = 0; i < sa.length; i++) {
            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {
                result[result.length] = sa[i];
            }
        }
        return result;
    };

    var _sortLayerNames = function (layer, layerNames) {
        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;
        if (layer.capabilities) {
            var tree = layer.getTree();
            ln.sort(function (a, b) {
                var idxa = {
                    count: 0
                };
                var idxb = {
                    count: 0
                };
                _getLayerNamePosition(tree, a, idxa);
                _getLayerNamePosition(tree, b, idxb);
                return idxa.count - idxb.count;
            });
        }
        return ln;
    };

    var _isNameInArray = function (layer, name, names, looseComparison) {
        return names.filter(function (elm) {
            return layer.compareNames(name, elm, looseComparison);
        }).length > 0;
    };


    layerProto.getLimitedMatrixSet = function () {
        return _getLimitedMatrixSet(this);
    };

    /**
     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.
     * @method setLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  setLayerNames: sets the visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.setLayerNames = function (layerNames, options) {
        var layer = this;
        return new Promise(function (resolve, reject) {
            layer.wrap.getLayer().then(function () {
                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                layer.names = ln;
                var opts = _extendLayerNameOptions(options);
                if (opts.aggregate) {
                    ln = _aggregateLayerNames(layer, ln);
                }
                layer._disgregatedLayerNames = null;
                var newParams = {
                    LAYERS: ln.join(','), TRANSPARENT: true
                };
                if (opts.lazy) {
                    var params = layer._newParams || layer.wrap.getParams();
                    layer._newParams = TC.Util.extend(params, newParams);
                }
                else {
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });
                    }
                    layer.tree = null;
                    layer._cache.visibilityStates = {
                    };
                    layer.wrap.setParams(newParams);
                    if (opts.reset || !layer.map) {
                        // layerNames se fija cuando se añade al mapa o cuando reset = true.
                        layer.availableNames = layer.names;
                    }
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });
                    }
                }
                resolve(layer.names);
            });
        });
    };

    /**
     * Añade capas por nombre a las que ya están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.addLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2a = _disgregateLayerNames(self, ln2a);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Elimina capas por nombre de las que están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.removeLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2r = _disgregateLayerNames(self, ln2r);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.
     * @method toggleLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.toggleLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var currentLayerNames = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2t = _disgregateLayerNames(self, ln2t);
                    currentLayerNames = self.getDisgregatedLayerNames();
                }
                var ln2a = [];
                var ln2r = [];
                for (var i = 0; i < ln2t.length; i++) {
                    var l = ln2t[i];
                    if (currentLayerNames.indexOf(l) < 0) {
                        ln2a[ln2a.length] = l;
                    }
                    else {
                        ln2r[ln2r.length] = l;
                    }
                }
                var promises = [];
                if (ln2a.length > 0) {
                    promises.push(self.addLayerNames(ln2a, opts));
                }
                if (ln2r.length > 0) {
                    promises.push(self.removeLayerNames(ln2r, opts));
                }
                Promise.all(promises).then(function (arrays) {
                    const a1 = arrays[0];
                    const a2 = arrays[1];
                    if (a1) {
                        if (a2) {
                            resolve(a1.concat(a2));
                        }
                        else {
                            resolve(a1);
                        }
                    }
                    else {
                        resolve([]);
                    }
                });
            });
        });
    };

    /**
     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
     * @method getDisgregatedLayerNames
     * @return {array}
     */
    /*
     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names
     */
    layerProto.getDisgregatedLayerNames = function () {
        ///<summary>
        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
        ///</summary>
        ///<returns type="array" elementType="string"></returns>
        var self = this;
        var olLayer = self.wrap.layer;
        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {
            if (!self._disgregatedLayerNames) {
                var layerNames = self.wrap.getParams().LAYERS;
                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);
            }
        }
        else {
            self._disgregatedLayerNames = self.names;
        }
        return self._disgregatedLayerNames.slice();
    };

    layerProto.isValidFromNames = function () {
        var self = this;
        var result = true;
        for (var i = 0, len = self.names.length; i < len; i++) {
            if (!self.getLayerNodeByName(self.names[i])) {
                result = false;
                break;
            }
        }
        return result;
    };

    layerProto.isCompatible = function (crs) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;
                break;
            case TC.Consts.layerType.WMS:
                result = self.wrap.isCompatible(crs);
                break;
            default:
                break;
        }
        return result;
    };

    layerProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        var result = self.wrap.getCompatibleCRS();
        if (options.includeFallback && self.fallbackLayer) {
            const fbLayer = self.getFallbackLayer();
            if (fbLayer instanceof TC.Layer) {
                result = result.concat(fbLayer.wrap.getCompatibleCRS());
            }
        }
        if (options.normalized) {
            result = result
                .map(function (crs) {
                    return TC.Util.getCRSCode(crs);
                }) // códigos numéricos
                .filter(function (code) {
                    return code !== null;
                })
                .reduce(function (prev, cur) {
                    if (prev.indexOf(cur) < 0) {
                        prev[prev.length] = cur;
                    }
                    return prev;
                }, []) // códigos numéricos sin duplicados
                .map(function (code) {
                    return 'EPSG:' + code;
                }); // códigos normalizados
        }
        return result;
    };

    layerProto.getProjection = function () {
        var self = this;

        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                return self.wrap.layer.getSource().getProjection().getCode();
            case TC.Consts.layerType.WMS:
                return self.map.crs;
        }
    };

    layerProto.setProjection = function (options) {
        var self = this;
        options = options || {};
        if (options.crs) {
            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];
                    if (matrixSet) {
                        self.matrixSet = matrixSet;
                        self.wrap.setMatrixSet(matrixSet);
                    }
                    else {
                        self.wrap.setProjection(options);
                    }
                    self.mustReproject = !matrixSet;
                    break;
                case TC.Consts.layerType.WMS:
                    self.wrap.setProjection(options);
                    self.mustReproject = !self.isCompatible(options.crs);
                    break;
                default:
                    break;
            }
        }
    };

    /*
     *  isVisibleByScale: return wether the WMS layer is visible at current scale
     *  Parameter: WMS layer name or UID
     */
    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {
        var self = this;
        var result;
        var _getOgcScale = function () {
            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel
        };
        var currentScale;
        var i;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = false;
                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);
                if (tileMatrix) {
                    currentScale = _getOgcScale();
                    for (i = 0; i < tileMatrix.length; i++) {
                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);
                        if (scaleDenominators[0] === currentScale) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMS:
                result = true;
                var layers = self.wrap.getAllLayerNodes();
                if (layers.length > 0) {
                    currentScale = _getOgcScale();
                    var node;
                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID
                        node = self._capabilitiesNodes[nameOrUid];
                    }
                    else {
                        for (i = 0; i < layers.length; i++) {
                            var layer = layers[i];
                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {
                                node = layer;
                                break;
                            }
                        }
                    }
                    if (node) {
                        var scaleDenominators = self.wrap.getScaleDenominators(node);
                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);

                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.
                        if (!result) {
                            if (node.Layer && node.Layer.length > 0) {
                                return node.Layer.some(function (nodeLayer) {
                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);
                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)
                                });
                            }
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    /*
     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names
     *  Parameter: WMS layer name
     */
    layerProto.isVisibleByName = function (name, looseComparison) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                if (self.wrap.getWMTSLayer()) {
                    result = true;
                    break;
                }
                break;
            case TC.Consts.layerType.WMS:
                var _getLayerPath = function _getLayerPath(name) {
                    return __getLayerPath(name, self.wrap.getRootLayerNode());
                };

                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {
                    var result = null;
                    var n = self.wrap.getName(capabilitiesNode);
                    if (self.compareNames(n, name, looseComparison)) {
                        result = [n];
                    }
                    else {
                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                        for (var i = 0; i < layerNodes.length; i++) {
                            var item = layerNodes[i];
                            var r = __getLayerPath(name, item);
                            if (r) {
                                TC.Util.fastUnshift(r, n);
                                result = r;
                                break;
                            }
                        }
                    }
                    return result;
                };

                var path = _getLayerPath(name);
                if (path) {
                    for (var i = 0; i < path.length; i++) {
                        if (_isNameInArray(self, path[i], self.names)) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    layerProto.getTree = function () {
        var self = this;
        
        var result = self.tree;

        var addChild = function (node, child) {
            if (self.options.inverseTree) {
                // Versión rápida de unshift
                TC.Util.fastUnshift(node.children, child);
            }
            else {
                node.children[node.children.length] = child;
            }
        }

        if (!result) {
            var rootNode;
            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {
                var uid;
                for (var key in self._capabilitiesNodes) {
                    if (self._capabilitiesNodes[key] === capabilitiesNode) {
                        uid = key;
                        break;
                    }
                }
                if (!uid) {
                    uid = TC.getUID();
                    self._capabilitiesNodes[uid] = capabilitiesNode;
                }
                var r = {
                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []
                };
                if (isRootNode) {
                    rootNode = r;
                }

                if (_isNameInArray(self, r.name, self.availableNames)) {
                    forceAddition = true;
                }

                if (!self.options.isBase) {
                    if (r === rootNode) {
                        r.isVisible = self.getVisibility();
                    }
                    else {
                        r.isVisible = self.isVisibleByName(r.name);
                    }
                    var i;
                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                    for (i = 0; i < layerNodes.length; i++) {
                        var treeNode = getTreeNode(layerNodes[i], forceAddition);
                        if (treeNode) {
                            addChild(r, treeNode);
                        }
                    }

                    r.legend = self.wrap.getLegend(capabilitiesNode);

                    // No muestra ramas irrelevantes si hideTree = true
                    if (!forceAddition && !isRootNode) {
                        // Eliminamos la rama hasta el nodo de interés
                        rootNode.children = rootNode.children.concat(r.children);
                        r = null;
                    }
                }
                else {
                    r.name = self.names.join(',');
                    r.title = self.title || r.title;
                    r.isBase = self.isDefault;
                    if (self.options.thumbnail) {
                        r.legend = {
                            src: self.options.thumbnail
                        };
                    }
                }
                return r;
            };

            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);
                    break;
                case TC.Consts.layerType.WMS:
                    if (self.capabilities) {
                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);

                        var cache = self._cache.visibilityStates;

                        var _setNodeState = function _setNodeState(node) {
                            var _result = TC.Consts.visibility.NOT_VISIBLE;
                            if (node) {
                                if (cache[node.uid] !== undefined) {
                                    _result = cache[node.uid];
                                }
                                else {
                                    if (node.children) {
                                        var hasVisible = false;
                                        var hasNotVisible = false;
                                        for (var i = 0, len = node.children.length; i < len; i++) {
                                            var r = _setNodeState(node.children[i]);
                                            switch (r) {
                                                case TC.Consts.visibility.VISIBLE:
                                                    hasVisible = true;
                                                    break;
                                                case TC.Consts.visibility.NOT_VISIBLE:
                                                    hasNotVisible = true;
                                                    break;
                                                case TC.Consts.visibility.HAS_VISIBLE:
                                                    hasVisible = true;
                                                    hasNotVisible = true;
                                                    break;
                                                default:
                                                    break;
                                            }
                                            if (hasVisible) {
                                                if (hasNotVisible) {
                                                    _result = TC.Consts.visibility.HAS_VISIBLE;
                                                }
                                                else {
                                                    _result = TC.Consts.visibility.VISIBLE;
                                                }
                                            }
                                        }
                                    }
                                    if (node.isVisible) {
                                        _result = TC.Consts.visibility.VISIBLE;
                                    }
                                    cache[node.uid] = _result;
                                }
                                node.visibilityState = _result;
                            }
                            return _result;
                        };
                        _setNodeState(result);

                        if (self.options.hideTree) {
                            _sortTree(self, result);
                        }
                    }
                    break;
                default:
                    break;
            }
            if (!result) {
                result = {
                    name: self.name, title: self.title
                };
            }
            result.title = self.title || result.title;
            result.customLegend = self.customLegend || result.customLegend;
            self.tree = result;
        }
        return result;
    };

    layerProto.setNodeVisibility = function (id, visible) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }

        var _getNames = function _getNames(node) {
            var result = [];
            if (node.name) {
                result[0] = node.name;
            }
            else {
                for (var i = 0; i < node.children.length; i++) {
                    result = result.concat(_getNames(node.children[i]));
                }
            }
            return result;
        };

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            if (visible && self.names.length === 0) {
                // Prevent pink error tile
                self.addLayerNames(self.availableNames).then(function () {
                    self.setVisibility(true);
                });
            }
            else {
                self.setVisibility(visible);
            }
        }
        else {
            var names = _getNames(node);
            if (visible) {
                self.addLayerNames(names);
            }
            else {
                self.removeLayerNames(names);
            }
        }
    };

    layerProto.getNodeVisibility = function (id) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }
        return self._cache.visibilityStates[id];
    };

    layerProto.getNodePath = function (layerName, ignorePrefix) {
        var self = this;
        var result = [];
        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {
            layerName = layerName || self.names[0];

            var _getPath = function _getPath(node) {
                var res = [];
                var nodeName = self.wrap.getName(node);
                if (self.compareNames(nodeName, layerName, ignorePrefix)) {
                    res.push(node);
                }
                else {
                    var children = self.wrap.getLayerNodes(node);
                    for (var i = 0; i < children.length; i++) {
                        var r = _getPath(children[i]);
                        if (r.length) {
                            res = r;
                            TC.Util.fastUnshift(res, node);
                            break;
                        }
                    }
                }
                return res;
            };
            result = _getPath(self.wrap.getRootLayerNode());
        }
        return result;
    };

    layerProto.getPath = function (layerName, ignorePrefix) {
        return this.getNodePath(layerName, ignorePrefix).map(function (node) {
            return node.title || node.Title;
        });
    };

    layerProto.getLayerNodeByName = function (name) {
        var result = null;
        var self = this;
        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName
        var nodes = self.wrap.getAllLayerNodes();
        for (var i = 0, len = nodes.length; i < len; i++) {
            if (self.compareNames(getName(nodes[i]), name)) {
                result = nodes[i];
                break;
            }
        }
        return result;
    };

    layerProto.getChildrenLayers = function (layer) {
        var self = this;
        var result = [];
        var _fnRecursiva = function (lyr, arr) {
            if (lyr && lyr.Layer && lyr.Layer.length) {
                for (var i = 0; i < lyr.Layer.length; i++) {
                    arr[arr.length] = lyr.Layer[i];
                    _fnRecursiva(lyr.Layer[i], arr)
                }
            }
        };
        _fnRecursiva(layer, result);
        return result;
    };

    layerProto.compareNames = function (n1, n2, looseComparison) {
        var result = n1 === n2;
        var self = this;
        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes
        if (!result && lc && n1 && n2) {
            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación
            var idx1 = n1.indexOf(':');
            var idx2 = n2.indexOf(':');
            if (idx1 >= 0 && idx2 < 0) {
                result = n1.substr(idx1 + 1) === n2;
            }
            else if (idx2 >= 0 && idx1 < 0) {
                result = n1 === n2.substr(idx2 + 1);
            }
        }
        return result;
    };

    layerProto.getCapabilitiesPromise = function () {
        return this._capabilitiesPromise;
    };

    layerProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    layerProto.setResolutions = function (resolutions) {
        this.wrap.setResolutions(resolutions);
    };

    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado
    //case insensitive
    layerProto.searchSubLayers = function (text) {
        if (!this.patternFn) {
            this.patternFn = function (t) {
                t = t.replace(/[^a-z\dáéíóúüñ]/gi, '\\' + '$&');
                t = t.replace(/(a|á)/gi, "(a|á)");
                t = t.replace(/(e|é)/gi, "(e|é)");
                t = t.replace(/(i|í)/gi, "(i|í)");
                t = t.replace(/(o|ó)/gi, "(o|ó)");
                t = t.replace(/(u|ú|ü)/gi, "(u|ú|ü)");
                t = t.replace(/n/gi, "(n|ñ)");
                return t;
            }
        }
        if (text && text.length && text.length >= 3) {
            var self = this;
            var layers = null;
            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado "cat" y ahora busco "cata" porque esto escribiendo "catastro" ...
            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */
            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {
                layers = this.lastMatches
            }
            else {
                /*si se ha definido el parametro layers de esta capa en configuraci\u00f3n filtro las capas del capability para que busque solo en las capas que est\u00e9n en 
                configuraci\u00f3n y sus hijas*/
                if (self.availableNames && self.availableNames.length > 0) {
                    layers = []
                    for (var i = 0; i < self.availableNames.length; i++) {
                        var layer = self.getLayerNodeByName(self.availableNames[i]);
                        if (layer) {
                            layers[layers.length] = layer;
                            layers = layers.concat(self.getChildrenLayers(layer));
                        }
                    }
                }
                else {
                    layers = self.wrap.getAllLayerNodes();
                }
            }

            var filter = this.patternFn(text);
            var re = new RegExp(filter, "i");

            var matches = layers.map(function (ly, ix) {
                delete ly.tcScore;

                ly.tcPosition = ix;

                self.wrap.normalizeLayerNode(ly);

                var title = ly.Title.trim();
                var res = re.exec(title);
                var titleIx = res ? res.index : -1;
                var abstractIx = -1;
                if (ly.Abstract) {
                    var abs = ly.Abstract.trim();
                    var res2 = re.exec(abs);
                    abstractIx = res2 ? res2.index : -1;
                }

                if (res && title == res[0])
                    ly.tcScore = 20;
                else if (titleIx == 0)
                    ly.tcScore = 15;
                else if (titleIx > -1)
                    ly.tcScore = 10;
                else if (abstractIx == 0)
                    ly.tcScore = 5;
                else if (abstractIx > -1)
                    ly.tcScore = 1;

                if (ly.tcScore)
                    return ly;
                else
                    return null;
            })
                .filter(function (elto) {
                    return elto != null;
                })
                .sort(function (a, b) {
                    if (b.tcScore === a.tcScore) {
                        //si la puntuación es la misma reordenamos por título
                        var titleA = TC.Util.replaceAccent(a.Title);
                        var titleB = TC.Util.replaceAccent(b.Title);
                        if (titleA < titleB) return -1;
                        if (titleA > titleB) return 1;
                        return 0;
                    }
                    else
                        return b.tcScore - a.tcScore;
                });

            this.lastPattern = text;
            this.lastMatches = matches;

            return matches;
        }
        else {
            return [];
        }

    };

    var cleanOgcUrl = function (url) {
        var result = url;
        if (url) {
            var match = url.match(/\??SERVICE=\w+&/i);
            if (match) {
                result = result.replace(match[0], '');
            }
        }
        return result;
    };

    layerProto.getGetCapabilitiesUrl = function () {
        const self = this;
        var url;
        const serviceUrl = self.url;
        const params = {};
        if (self.type === TC.Consts.layerType.WMTS) {
            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {
                var suffix = '/1.0.0/WMTSCapabilities.xml';
                const suffixIdx = serviceUrl.indexOf(suffix);
                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {
                    if (serviceUrl[serviceUrl.length - 1] === '/') {
                        suffix = suffix.substr(1);
                    }
                    url = serviceUrl + suffix;
                }
                else {
                    url = serviceUrl;
                }
            }
            else {
                url = serviceUrl;
                params.SERVICE = 'WMTS';
                params.VERSION = '1.0.0';
                params.REQUEST = 'GetCapabilities';
            }
        }
        else {
            url = serviceUrl;
            params.SERVICE = 'WMS';
            params.VERSION = '1.3.0';
            params.REQUEST = 'GetCapabilities';
        }
        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));
        return url;
    };



    layerProto.getGetMapUrl = function () {
        return cleanOgcUrl(this.wrap.getGetMapUrl());
    };

    layerProto.getPreferredInfoFormat = function () {
        const layer = this;
        var result = null;

        const infoFormats = layer.wrap.getInfoFormats();
        if (infoFormats) {
            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {
                var format = TC.wrap.layer.Raster.infoFormatPreference[i];
                if (infoFormats.indexOf(format) >= 0) {
                    result = format;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Carga la imagen de leyenda de una capa por POST.
     */
    layerProto.getLegendGraphicImage = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta
            if (self.options.params.base64LegendSrc) {
                return resolve(self.options.params.base64LegendSrc);
            }

            if (typeof window.btoa === 'function') {
                var name = self.names[0];
                var info = self.wrap.getInfo(name);
                var xhr = new XMLHttpRequest();
                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL
                var dataEntries = url[1].split("&"); // Separamos clave/valor de cada parámetro
                var params = self.options.params.sld_body ? "sld_body=" + self.options.params.sld_body : '';

                for (var i = 0; i < dataEntries.length; i++) {
                    var chunks = dataEntries[i].split('=');

                    if (chunks && chunks.length > 1 && chunks[1]) {
                        params += "&" + dataEntries[i];
                    }
                }
                if (self.options.params.env) {
                    params += "&" + self.options.params.env;
                }

                xhr.open('POST', url[0], true);
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                xhr.responseType = 'arraybuffer';
                xhr.onload = function (e) {
                    if (this.status === 200) {
                        var uInt8Array = new Uint8Array(this.response);
                        var i = uInt8Array.length;
                        var binaryString = new Array(i);
                        while (i--) {
                            binaryString[i] = String.fromCharCode(uInt8Array[i]);
                        }
                        var data = binaryString.join('');
                        var type = xhr.getResponseHeader('content-type');
                        if (type.indexOf('image') === 0) {
                            var imageSrc;
                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);
                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta
                            resolve(imageSrc);
                        }
                    }
                };
                xhr.send(params);
            } else {
                reject(Error("Función window.btoa no soportada por el navegador"));
            }
        });
    };

    layerProto.getUrl = function (src) {
        var self = this;

        return src;
    };

    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL
    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; 
    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.

    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.
    layerProto.getWebGLUrl = function (src, location) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;

            if (self.ignoreProxification) {
                resolve(_src);
            } else {
                const options = {
                    exportable: true,
                    ignoreProxification: self.ignoreProxification
                };

                self.toolProxification.fetchImage(_src, options).then(function () {
                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {
                        if (cache && cache.action) {
                            resolve(cache.action.call(self.toolProxification, _src));
                        }
                    });
                }).catch(function (e) {
                    reject(Error(e));
                });
            }

            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más
            //if (self.ignoreProxification) {
            //    setSRC({ src: TC.Consts.BLANK_IMAGE });
            //    return;
            //}

            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        
        });
    };

    layerProto.getFeatureUrl = function (url) {
        var self = this;

        return self.toolProxification.fetch(url).then(function () {
            return self.toolProxification.cacheHost.getAction(url)
                .then(function (cache) {
                    return cache.action.call(self.toolProxification, url);
                })
                .catch(function (error) {
                    return Promise.reject(error);
                })
        }).catch(function (error) {
            return Promise.reject(error);
        });
    };

    // GLS:
    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. 
    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.
    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {
        var self = this;

        if (!self.map) {
            return null;
        } else {
            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));

            const matchingLayer = layers.filter(function (elem) {
                return (elem.type === TC.Consts.layerType.WMS ||
                    elem.type === TC.Consts.layerType.WMTS) &&
                    (elem.capabilities === self.capabilities || elem.url === self.url) &&
                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);
            })[0];

            return matchingLayer || null;
        }
    };

    layerProto.getImageLoad = function (image, src, location) {
        const self = this;

        const setSRC = function (data) {
            var olImg = image.getImage();

            if (!TC.Util.isSameOrigin(data.src)) {
                if (!self.map || (self.map && self.map.mustBeExportable)) {
                    olImg.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : "anonymous";
                }
            }

            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.
            olImg.setAttribute("src", data.src);

            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
        };

        // Viene sin nombre desde el control TOC, si es así lo ignoramos.
        if (self.names && self.names.length > 0) {

            const error = function (error) {
                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                setSRC({ src: TC.Consts.BLANK_IMAGE });
            };

            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404
            if (self.type === TC.Consts.layerType.WMTS) {
                var z, x, y;
                if (self.encoding != "KVP") {
                    var _src = src.replace('.' + self.format.split('/')[1], '');
                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });
                    z = parts[0];
                    x = parts[1];
                    y = parts[2];
                } else {
                    var parts = /.*TileMatrix=(\d*)&TileCol=(\d*)&TileRow=(\d*)/i.exec(src);
                    if (parts && parts.length == 4) {
                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });
                        z = parts[0];
                        x = parts[2];
                        y = parts[1];
                    }
                }

                if (z && x && y) {
                    var wmtsOptions = self.wrap.getWMTSLayer();
                    if (wmtsOptions) {
                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });
                        if (matrixSet.length > 0) {

                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {
                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {
                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))
                                        return 1;
                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))
                                        return -1;
                                    else return 0;
                                });

                                var level = matrixSetLimits[z];
                                if (level && self.map && self.map.on3DView) {
                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {
                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');
                                        setSRC({ src: TC.Consts.BLANK_IMAGE });
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });

            var params = "";
            var isPOST = self.options.method === "POST";
            if (isPOST) {
                var url = src.split('?');
                params = url[1].split("&").filter(function (param) {
                    const values = param.split('=');
                    // eliminamos los valores en blanco y el parámetro layers
                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== "layers";
                }).join('&');

                self.toolProxification.fetchImageAsBlob(url[0], {
                    type: "POST",
                    data: params,
                    contentType: "application/x-www-form-urlencoded"
                }).then(function (blob) {
                    const imageUrl = URL.createObjectURL(blob);
                    const img = image.getImage();
                    img.onload = function (evt) {
                        URL.revokeObjectURL(imageUrl);
                    };
                    setSRC({ src: imageUrl });
                }).catch(error);

            } else {
                if (!self.ignoreProxification) {
                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {
                        setSRC(img);
                    }).catch(error);
                } else {
                    setSRC({ src: src });
                    var img = image.getImage();

                    if (!TC.Util.isSameOrigin(src)) {
                        if (!self.map || (self.map && self.map.mustBeExportable)) {
                            img.crossOrigin = "anonymous";
                        }
                    }

                    img.onload = function () {
                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
                    };
                    img.onerror = function (error) {
                        img.src = TC.Consts.BLANK_IMAGE;
                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                    };

                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;
                }
            }
        } else {
            setSRC({ src: TC.Consts.BLANK_IMAGE });
            // lanzamos el evento para gestionar el loading
            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
        }
    };

    var _get$events = function () {
        const self = this;
        if (self.wrap && self.wrap.$events) {
            return self.wrap.$events;
        }
        return null;
    };

    layerProto.getWFSCapabilitiesPromise = function () {
        const self = this;

        if (typeof (WFSCapabilities) === "undefined") {
            TC.syncLoadJS(TC.apiLocation + 'TC/layer/WFSCapabilitiesParser');
        }        
        const newUrl = this.options.url.replace(/wms/gi, "wfs");
        const _src = !TC.Util.isSecureURL(newUrl) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(newUrl)) ? self.getBySSL_(newUrl) : newUrl;
        const basicUrl = newUrl.substring(newUrl.indexOf("://") < 0 ? 0 : newUrl.indexOf("://") + 3);
        if (TC.WFScapabilities[basicUrl]) {
            if (TC.WFScapabilities[basicUrl] instanceof Promise)
                return TC.WFScapabilities[basicUrl];
            else
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        resolve(TC.WFScapabilities[basicUrl]);
                    }, 100);
                });
        }
        TC.WFScapabilities[basicUrl] = new Promise(function (resolve, reject) {            
            var params = {
            }
            params.SERVICE = 'WFS';
            params.VERSION = '2.0.0';
            params.REQUEST = 'GetCapabilities';

            var url = self.getUrl(_src + '?' + TC.Util.getParamString(params));

            self.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {

                var capabilities
                var xmlDoc;
                const documentElement = data.responseText && (data.responseText.ownerDocument || data.responseText).documentElement;
                const isXMLDoc = documentElement ? documentElement.nodeName !== 'HTML' : false;
                if (isXMLDoc) {
                    xmlDoc = data.responseText;
                }
                else {
                    xmlDoc = (new DOMParser()).parseFromString(data.responseText, 'text/xml');
                }
                //comprueba si el servidor ha devuelto una excepcion

                var errorNode = xmlDoc.getElementsByTagName('ServiceException')[0];
                if (!errorNode) {
                    errorNode = xmlDoc.getElementsByTagName('ExceptionText')[0];
                }
                if (errorNode) {
                    reject(Error(errorNode.innerHTML));
                    return;
                }
                try {
                    capabilities = WFSCapabilities.Parse(xmlDoc);
                }
                catch (err) {
                    reject(err instanceof Error ? err : Error(err));
                    return;
                }

                if (!capabilities.Operations) {
                    reject(null);
                    return;
                }
                var _url = (capabilities.Operations.GetCapabilities.DCP && capabilities.Operations.GetCapabilities.DCP.HTTP.Get["xlink:href"]) || capabilities.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource
                TC.WFScapabilities[_url] = capabilities;
                TC.WFScapabilities[basicUrl] = capabilities;
                resolve(capabilities);
            }).catch(function (error) {
                //reject(Error(capabilitiesError(layer, dataError)));
                reject(error instanceof Error ? error : Error(error));
            });
        });
        return TC.WFScapabilities[basicUrl];
    };

    layerProto.getFallbackLayer = function () {
        const self = this;
        if (self.fallbackLayer instanceof TC.Layer) {
            return self.fallbackLayer;
        }
        if (self.options.fallbackLayer) {
            var fbLayer = self.options.fallbackLayer;
            if (typeof fbLayer === 'string') {
                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
                ablCollection.forEach(function (baseLayer) {
                    if (self.options.fallbackLayer === baseLayer.id) {
                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));
                        self.fallbackLayer.firstOption = self;
                    }
                });
            }
            else if (fbLayer instanceof TC.Layer) {
                self.fallbackLayer = fbLayer;
                self.fallbackLayer.firstOption = self;
            }
            else {
                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {
                    id: TC.getUID(),
                    isBase: true,
                    stealth: true,
                    title: layer.title,
                    map: self.map
                }));
                self.fallbackLayer.firstOption = self;
            }
            return self.fallbackLayer;
        }
        return null;
    };
})();
var esriParser = {
    parse: function (text) {
        var result = [];
        var dom = (new DOMParser()).parseFromString(text, 'text/xml');
        if (dom.documentElement.tagName === 'FeatureInfoResponse') {
            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
            for (var i = 0, len = fiCollections.length; i < len; i++) {
                var fic = fiCollections[i];
                var layerName = fic.getAttribute('layername');
                var fInfos = fic.getElementsByTagName('FeatureInfo');
                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                    var fields = fInfos[j].getElementsByTagName('Field');
                    var attributes = {};
                    for (var k = 0, lenk = fields.length; k < lenk; k++) {
                        var field = fields[k];
                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                    }
                    var feature = new ol.Feature(attributes);
                    feature.setId(layerName + '.' + TC.getUID());
                    result[result.length] = feature;
                }
            }
        }
        return result;
    }
};
TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

/**
 * Opciones de capa vectorial.
 * Esta clase no tiene constructor.
 * @class TC.cfg.VectorOptions
 * @extend TC.cfg.LayerOptions
 * @static
 */
/**
 * Tipo de capa.
 * @property type
 * @type TC.consts.LayerType
 * @default TC.Consts.layerType.VECTOR
 */
/**
 * URL del servicio WFS o del documento que define la capa.
 * @property url
 * @type string|undefined
 */

/**
 * Capa de tipo vectorial, como la de un WFS o un KML.
 * @class TC.layer.Vector
 * @extends TC.Layer
 * @constructor
 * @async
 * @param {TC.Cfg.layer} [options] Objeto de opciones de configuración de la capa.
 */
TC.layer.Vector = function () {
    var self = this;
    TC.Layer.apply(self, arguments);

    self.type = self.options.type || TC.Consts.layerType.VECTOR;
    /**
     * Lista de entidades geográficas que hay en la capa.
     * @property features
     * @type array
     * @default []
     */
    self.features = [];
    /**
     * Lista de entidades geográficas seleccionadas en la capa.
     * @property selectedFeatures
     * @type array
     * @default []
     */
    self.selectedFeatures = [];

    const getFileExtension = function (url) {
        url = url || '';
        var idx = url.indexOf('?');
        if (idx >= 0) {
            url = url.substr(0, idx);
        }
        else {
            idx = url.indexOf('#');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
        }
        return url.substr(url.lastIndexOf('.')).toLowerCase();
    };

    const getFormatFromExtension = function (extension) {
        switch (extension) {
            case '.kml':
                return TC.Consts.format.KML;
            case '.gpx':
                return TC.Consts.format.GPX;
            case '.json':
            case '.geojson':
                return TC.Consts.format.GEOJSON;
            case '.gml':
                return TC.Consts.format.GML;
            case '.wkt':
                return TC.Consts.format.WKT;
            case '.topojson':
                return TC.Consts.format.TOPOJSON;
            default:
                return null;
        }
    };
    const getFormatFromMimeType = function (mimeType) {
        switch (mimeType) {
            case TC.Consts.mimeType.KML:
                return TC.Consts.format.KML;
            case TC.Consts.mimeType.GPX:
                return TC.Consts.format.GPX;
            case TC.Consts.mimeType.JSON:
            case TC.Consts.mimeType.GEOJSON:
                return TC.Consts.format.GEOJSON;
            case TC.Consts.mimeType.GML:
                return TC.Consts.format.GML;
            default:
                return null;
        }
    };
    /**
     * URL del servicio o documento al que pertenenece la capa.
     * @property url
     * @type string
     */
    const extension = getFileExtension(self.url);
    const format = getFormatFromMimeType(self.options.format) || getFormatFromExtension(extension);
    if (format || self.type === TC.Consts.layerType.KML) {
        if (format === TC.Consts.format.KML) {
            self.type = TC.Consts.layerType.KML;
        }

        var getFileName = function (url) {
            url = url || '';
            var result = url;
            var regexp = new RegExp('([^/]+' + extension + ')', 'i');
            for (var i = 0; i < 3; i++) {
                url = decodeURIComponent(url);
                var match = regexp.exec(url);
                if (match.length > 1) {
                    result = match[1];
                    break;
                }

            }
            return result;
        };
        self.title = self.options.title || getFileName(self.url);
    }

    self.wrap = new TC.wrap.layer.Vector(self);

    var ollyr = self.wrap.createVectorLayer();
    self.wrap.setLayer(ollyr);
    self.wrap._promise = Promise.resolve(ollyr);
};

TC.inherit(TC.layer.Vector, TC.Layer);

(function () {
    var layerProto = TC.layer.Vector.prototype;

    /*
     *  getTree: returns service layer tree { name, title, children }
     */
    layerProto.getTree = function () {
        var self = this;
        var result = null;
        if (!self.options.stealth) {
            result = {};
            result.children = [];
            for (var i = 0; i < self.features.length; i++) {
                var path = self.features[i].getPath();
                if (path.length) {
                    var node = TC.Util.addArrayToTree(path, result);
                    if (node) {
                        node.legend = self.features[i].getLegend();
                    }
                }
            }
            result.name = self.name || result.name;
            result.customLegend = self.options.customLegend; //Atributo para pasar una plantilla HTML diferente a la por defecto (LegendNode.html)
            result.title = self.title || result.title;
            result.uid = self.id;
        }
        return result;
    };

    var addFeatureInternal = function (layer, multipleFeatureFunction, coord, options) {
        return new Promise(function (resolve, reject) {
            multipleFeatureFunction.call(layer, [coord], options).then(function (features) {
                resolve(features[0]);
                if (layer.map) {
                    layer.map.trigger(TC.Consts.event.FEATUREADD, { layer: layer, feature: features[0] });
                }
            });
        });
    };

    var addFeaturesInternal = function (layer, coordsArray, constructorName, styleType, options) {
        var style = (layer.options.styles && layer.options.styles[styleType]) || TC.Cfg.styles[styleType];
        var opts = TC.Util.extend(true, {}, style, options);
        return new Promise(function (resolve, reject) {
            var FeatureConstructor;
            const endFn = function () {
                FeatureConstructor = FeatureConstructor || TC.feature[constructorName];
                var features = new Array(coordsArray.length);
                var nativeFeatures = [];
                for (var i = 0, len = coordsArray.length; i < len; i++) {
                    var coords = coordsArray[i];
                    var feature;
                    const isNative = TC.wrap.Feature.prototype.isNative(coords);
                    if (coords instanceof FeatureConstructor || "TC.feature." + constructorName === coords.CLASSNAME) {
                        feature = coords;
                    }
                    else {
                        opts.layer = layer;
                        if (isNative) {
                            feature = coords._wrap && coords._wrap.parent;
                        }
                        if (!feature) {
                            feature = new FeatureConstructor(coords, opts);
                        }
                    }
                    feature.layer = layer;
                    features[i] = feature;
                    layer.features[layer.features.length] = feature;
                    if (!isNative) {
                        nativeFeatures[nativeFeatures.length] = feature.wrap.feature;
                    }
                    if (feature.options.showPopup) {
                        feature.showPopup();
                    }
                    // Este evento mata el rendimiento
                    //self.map.trigger(TC.Consts.event.FEATUREADD, { layer: self, feature: marker });
                }
                if (nativeFeatures.length) {
                    layer.wrap.addFeatures(nativeFeatures);
                }
                resolve(features);
            };
            if (constructorName) {
                TC.loadJS(
                    !TC.feature || (TC.feature && !TC.feature[constructorName]),
                    [TC.apiLocation + 'TC/feature/' + constructorName],
                    endFn
                );
            }
            else {
                FeatureConstructor = TC.Feature;
                endFn();
            }
        });
    };

    /**
     * Añade un punto a la capa.
     * @method addPoint
     * @async
     * @param {array|TC.feature.Point|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
     * @param {TC.cfg.PointStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Point
     */
    layerProto.addPoint = function (coord, options) {
        return addFeatureInternal(this, this.addPoints, coord, options);
    };

    /**
     * Añade una lista de puntos a la capa.
     * @method addPoints
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPoint:method"}}{{/crossLink}}.
     * @param {TC.cfg.PointStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Point
     */
    layerProto.addPoints = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Point', TC.Consts.geom.POINT, options);
    };

    /**
     * Añade un marcador a la capa.
     * @method addMarker
     * @async
     * @param {array|TC.feature.Marker|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
     * @param {TC.cfg.MarkerStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Marker
     */
    layerProto.addMarker = function (coord, options) {
        return addFeatureInternal(this, this.addMarkers, coord, options);
    };

    /**
     * Añade una lista de marcadores a la capa.
     * @method addMarkers
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addMarker:method"}}{{/crossLink}}.
     * @param {TC.cfg.MarkerStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Marker
     */
    layerProto.addMarkers = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Marker', 'marker', options);
    };

    /**
     * Añade una polilínea a la capa.
     * @method addPolyline
     * @async
     * @param {array|TC.feature.Polyline|ol.geom.MultiLineString|OpenLayers.Geometry.LineString} coords Si es un array, contiene arrays de dos números (coordenadas de puntos).
     * @param {TC.cfg.PolylineOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polyline
     */
    layerProto.addPolyline = function (coords, options) {
        return addFeatureInternal(this, this.addPolylines, coords, options);
    };


    /**
     * Añade una lista de polilíneas a la capa.
     * @method addPolylines
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolyline:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolylineOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polyline
     */
    layerProto.addPolylines = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Polyline', TC.Consts.geom.POLYLINE, options);
    };

    layerProto.addMultiPolyline = function (coords, options) {
        return addFeatureInternal(this, this.addMultiPolylines, coords, options);
    };


    layerProto.addMultiPolylines = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'MultiPolyline', TC.Consts.geom.POLYLINE, options);
    };

    /**
     * Añade un polígono a la capa.
     * @method addPolygon
     * @async
     * @param {array|TC.feature.Polygon|ol.geom.Polygon|OpenLayers.Geometry.Polygon} coords Si es un array, contiene arrays de coordenadas, que son a su vez arrays de dos números. El primer
     * elemento de ese array es el anillo exterior, los siguientes son anillos interiores.
     * @param {TC.cfg.PolygonOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polygon
     */
    layerProto.addPolygon = function (coords, options) {
        return addFeatureInternal(this, this.addPolygons, coords, options);
    };

    /**
     * Añade una lista de polígonos a la capa.
     * @method addPolygons
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolygon:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolygonOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polygon
     */
    layerProto.addPolygons = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Polygon', TC.Consts.geom.POLYGON, options);
    };

    layerProto.addMultiPolygon = function (coords, options) {
        return addFeatureInternal(this, this.addMultiPolygons, coords, options);
    };


    layerProto.addMultiPolygons = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'MultiPolygon', TC.Consts.geom.POLYGON, options);
    };

    /**
     * Añade un círculo a la capa.
     * @method addCircle
     * @async
     * @param {array|TC.feature.Circle|ol.geom.Circle} coord Si es un array, contiene un array de dos números (la coordenada del centro) y un número (el radio).
     * @param {TC.cfg.PolygonStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Circle
     */
    layerProto.addCircle = function (coord, options) {
        return addFeatureInternal(this, this.addCircles, coord, options);
    };

    /**
     * Añade una lista de círculos a la capa.
     * @method addCircles
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addCircle:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolygonStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Circle
     */
    layerProto.addCircles = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Circle', TC.Consts.geom.POLYGON, options);
    };
    /**
     * Añade una entidad geográfica a la capa.
     * @method addFeature
     * @async
     * @param {TC.Feature} feature 
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.Feature
     */
    layerProto.addFeature = function (feature) {
        const self = this;
        var result;
        if (TC.feature) {
            if (TC.feature.Point && feature instanceof TC.feature.Point || feature.CLASSNAME === "TC.feature.Point") {
                result = self.addPoint(feature);
            }
            else if (TC.feature.Polyline && feature instanceof TC.feature.Polyline || feature.CLASSNAME === "TC.feature.Polyline") {
                result = self.addPolyline(feature);
            }
            else if (TC.feature.Polygon && feature instanceof TC.feature.Polygon || feature.CLASSNAME === "TC.feature.Polygon") {
                result = self.addPolygon(feature);
            }
            else if (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon || feature.CLASSNAME === "TC.feature.MultiPolygon") {
                result = self.addMultiPolygon(feature);
            }
            else if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline || feature.CLASSNAME === "TC.feature.MultiPolyline") {
                result = self.addMultiPolyline(feature);
            }
            else if (TC.feature.Circle && feature instanceof TC.feature.Circle || feature.CLASSNAME === "TC.feature.Circle") {
                result = self.addCircle(feature);
            }
            else {
                result = addFeaturesInternal(self, [feature])
            }
        }
        return result;
    };

    /**
     * Elimina una entidad geográfica de la capa.
     * @method removeFeature
     * @param {TC.Feature} feature 
     */
    layerProto.removeFeature = function (feature) {
        const self = this;
        if (feature.layer && self.features.indexOf(feature) >= 0) {
            if (self.map) {
                const popups = self.map.getControlsByClass('TC.control.Popup');
                popups.forEach(function (pu) {
                    if (pu.isVisible() && pu.currentFeature === feature) {
                        pu.hide();
                    }
                });

                const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                panels.forEach(function (p) {
                    if (p.isVisible() && p.currentFeature === feature) {
                        p.close();
                    }
                });
            }
            self.wrap.removeFeature(feature);
            feature.layer = null;
        }
    };

    layerProto.getFeatureById = function (id) {
        var result = null;
        var olFeat = this.wrap.getFeatureById(id);
        if (olFeat) {
            result = olFeat._wrap.parent;
        }
        return result;
    };

    /**
     * Borra todas las entidades geográficas de la capa.
     * @method clearFeatures
     */
    layerProto.clearFeatures = function () {
        var self = this;
        if (self.features && self.wrap) {
            if (self.map) {
                const popups = self.map.getControlsByClass('TC.control.Popup');
                popups.forEach(function (pu) {
                    if (pu.isVisible() && self.features.indexOf(pu.currentFeature) >= 0) {
                        pu.hide();
                    }
                });
            }
            self.features.length = 0;
            self.wrap.clearFeatures();
        }
    };

    layerProto.describeFeatureType = function (callback, error) {
        const self = this;
        const promise = new Promise(function (resolve, reject) {
            TC.ajax({
                url: self.wrap.getDescribeFeatureTypeUrl(),
                method: 'GET',
                responseType: TC.Consts.mimeType.XML
            })
                .then(function (response) {
                    const data = response.data;
                    var ns = 'http://www.w3.org/2001/XMLSchema';
                    var complexType = data.getElementsByTagNameNS(ns, 'complexType')[0];
                    if (complexType) {
                        var elements = complexType.getElementsByTagNameNS(ns, 'element');
                        var result = new Array(elements.length);
                        for (var i = 0, len = elements.length; i < len; i++) {
                            var element = elements[i];
                            result[i] = {
                                name: element.getAttribute('name'),
                                type: element.getAttribute('type'),
                                nillable: element.getAttribute('nillable') === 'true' ? true : false,
                                minOccurs: parseInt(element.getAttribute('minOccurs')),
                                maxOccurs: parseInt(element.getAttribute('maxOccurs'))
                            }
                        }
                        resolve(result);
                    }
                    else {
                        var exception = data.getElementsByTagName('Exception')[0];
                        if (exception) {
                            reject(exception.getElementsByTagName('ExceptionText')[0].innerHTML);
                        }
                    }
                })
                .catch(function (jqXHR, textStatus, errorThrown) {
                    reject(Error(errorThrown));
                });
        });
        promise.then(
            function (data) {
                if (TC.Util.isFunction(callback)) {
                    callback(data);
                }
            },
            function (errorText) {
                if (TC.Util.isFunction(error)) {
                    error(errorText);
                }
            }
        );
    };

    layerProto.import = function (options) {
        this.wrap.import(options);
    };

    layerProto.setNodeVisibility = function (id, visible) {
        var self = this;

        self.state = TC.Layer.state.LOADING;
        self.map.trigger(TC.Consts.event.BEFOREUPDATE);
        self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });

        if (!self.tree) {
            self.tree = self.getTree();
        }

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            self.setVisibility(visible);
        }
        else {
            var cache = self._cache.visibilityStates;
            cache[id] = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;

            var found = false;
            var i;
            var f;
            for (i = 0; i < self.features.length; i++) {
                f = self.features[i];
                if (f.id == id) {
                    found = true;
                    f.setVisibility(visible);
                    break;
                }
            }
            if (!found) {
                for (i = 0; i < self.features.length; i++) {
                    f = self.features[i];
                    if (f._path === undefined) {
                        f._path = '/' + f.getPath().join('/');
                    }
                    if (f._path === id) {
                        f.setVisibility(visible);
                    }
                }
            }
        }
        self.state = TC.Layer.state.IDLE;
        self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
        self.map.trigger(TC.Consts.event.UPDATE);
    };

    layerProto.getNodeVisibility = function (id) {
        var self = this;
        var result = TC.Layer.prototype.getNodeVisibility.call(self, id);
        if (!self.tree) {
            self.tree = self.getTree();
        }

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            result = self.getVisibility() ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
        }
        else {
            var cache = self._cache.visibilityStates;
            var r = cache[id];
            if (r !== undefined) {
                result = r;
            }
        }
        return result;
    };

    layerProto.setModifiable = function (modifiable) {
        this.wrap.setModifiable(modifiable);
    };

    layerProto.applyEdits = function (inserts, updates, deletes) {
        return this.wrap.sendTransaction(inserts, updates, deletes);
    };

    layerProto.refresh = function () {
        var self = this;
        return this.wrap.reloadSource();
    };

    layerProto.getFeaturesInCurrentExtent = function (tolerance) {
        var self = this;

        var extent = self.map.getExtent();
        return this.getFeaturesInExtent(extent, tolerance);
    };

    layerProto.getFeaturesInExtent = function (extent, tolerance) {
        return this.wrap.getFeaturesInExtent(extent, tolerance);
    };

    layerProto.setProjection = function (options) {
        const self = this;
        self.wrap.setProjection(options);
        if (options.crs && options.oldCrs) {
            self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });
            self.features.forEach(function (feat) {
                feat.wrap.setGeometry(TC.Util.reproject(feat.geometry, options.oldCrs, options.crs));
                feat.geometry = feat.wrap.getGeometry();
            });
            self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
        }
    };
   

    

    layerProto.exportState = function (options) {
        const self = this;
        options = options || {};
        const lObj = {
            id: self.id
        };
        if (self.map && self.map.crs !== self.map.options.crs) {
            lObj.crs = self.map.crs;
        }

        // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
        var precision = Math.pow(10, (self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) + 1);

        const features = options.features || self.features;
        lObj.features = features
            .map(function (f) {
                const fObj = {};
                var layerStyle;
                switch (true) {
                    case TC.feature.Marker && f instanceof TC.feature.Marker:
                        fObj.type = TC.Consts.geom.POINT;
                        layerStyle = self.options.styles && self.options.styles.marker;
                        break;
                    case TC.feature.Point && f instanceof TC.feature.Point:
                        fObj.type = TC.Consts.geom.POINT;
                        layerStyle = self.options.styles && self.options.styles.point;
                        break;
                    //case TC.feature.MultiPoint && f instanceof TC.feature.MultiPoint:
                    //    fObj.type = TC.Consts.geom.MULTIPOINT;
                    //    break;
                    case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                        fObj.type = TC.Consts.geom.POLYLINE;
                        layerStyle = self.options.styles && self.options.styles.line;
                        break;
                    case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                        fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                        layerStyle = self.options.styles && self.options.styles.line;
                        break;
                    case TC.feature.Polygon && f instanceof TC.feature.Polygon:
                        fObj.type = TC.Consts.geom.POLYGON;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    case TC.feature.MultiPolygon && f instanceof TC.feature.MultiPolygon:
                        fObj.type = TC.Consts.geom.MULTIPOLYGON;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    case TC.feature.Circle && f instanceof TC.feature.Circle:
                        fObj.type = TC.Consts.geom.CIRCLE;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    default:
                        break;
                }
                fObj.id = f.id;
                fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                fObj.data = f.getData();
                fObj.showsPopup = f.showsPopup;
                if (options.exportStyles === undefined || options.exportStyles) {
                    layerStyle = TC.Util.extend({}, layerStyle);
                    for (var key in layerStyle) {
                        var val = layerStyle[key];
                        if (TC.Util.isFunction(val)) {
                            layerStyle[key] = val(f);
                        }
                    }
                    fObj.style = TC.Util.extend(layerStyle, f.getStyle());
                }
                return fObj;
            });
        return lObj;
    };
    

    layerProto.importState = function (obj) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const promises = new Array(obj.features.length);
            obj.features.forEach(function (f, idx) {
                const featureOptions = TC.Util.extend(f.style, { data: f.data, id: f.id, showsPopup: f.showsPopup });
                var addFn;
                switch (f.type) {
                    case TC.Consts.geom.POLYGON:
                        addFn = self.addPolygon;
                        break;
                    case TC.Consts.geom.MULTIPOLYGON:
                        addFn = self.addMultiPolygon;
                        break;
                    case TC.Consts.geom.POLYLINE:
                        addFn = self.addPolyline;
                        break;
                    case TC.Consts.geom.MULTIPOLYLINE:
                        addFn = self.addMultiPolyline;
                        break;
                    case TC.Consts.geom.CIRCLE:
                        addFn = self.addCircle;
                        break;
                    case TC.Consts.geom.POINT:
                        if (f.style && (f.style.url || f.style.className)) {
                            addFn = self.addMarker;
                        }
                        else {
                            addFn = self.addPoint;
                        }
                        break;
                    default:
                        break;
                }
                if (addFn) {
                    var geom = TC.Util.explodeGeometry(f.geom);
                    if (obj.crs && self.map.crs !== obj.crs) {
                        promises[idx] = new Promise(function (res, rej) {
                            self.map.one(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                                addFn.call(self, geom, featureOptions).then(
                                    function () {
                                        res();
                                    },
                                    function () {
                                        rej();
                                    }
                                );
                            });
                        });
                    }
                    else {
                        promises[idx] = addFn.call(self, geom, featureOptions);
                    }
                }
            });
            Promise.all(promises).then(
                function () {
                    resolve();
                },
                function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
        });
    };
})();
/*	This work is licensed under Creative Commons GNU LGPL License.

	License: http://creativecommons.org/licenses/LGPL/2.1/
   Version: 0.9
	Author:  Stefan Goessner/2006
	Web:     http://goessner.net/ 
*/
function xml2json(e) { var n = { toObj: function (e) { var t = {}; if (1 == e.nodeType) { if (e.attributes.length) for (var i = 0; i < e.attributes.length; i++) "name" !== e.attributes[i].nodeName && (t[e.attributes[i].nodeName] = (e.attributes[i].nodeValue || "").toString()); if (e.firstChild) { for (var r = 0, o = 0, l = !1, a = e.firstChild; a; a = a.nextSibling) 1 == a.nodeType ? l = !0 : 3 == a.nodeType && a.nodeValue.match(/[^ \f\n\r\t\v]/) ? r++ : 4 == a.nodeType && o++; if (l) if (2 > r && 2 > o) { n.removeWhite(e); for (var a = e.firstChild; a; a = a.nextSibling) { var s = n.removePrefix(a.nodeName); if (3 == a.nodeType) t["#text"] = n.escape(a.nodeValue); else if (4 == a.nodeType) t["#cdata"] = n.escape(a.nodeValue); else if (t[s]) t[s] instanceof Array ? t[s][t[s].length] = n.toObj(a) : t[s] = [t[s], n.toObj(a)]; else { var f = null; a.attributes.getNamedItem("name") && (f = a.attributes.getNamedItem("name").nodeValue), t[f ? f : s] = n.toObj(a) } } } else e.attributes.length ? t["#text"] = n.escape(n.innerXml(e)) : t = n.escape(n.innerXml(e)); else if (r) e.attributes.length ? t["#text"] = n.escape(n.innerXml(e)) : t = n.escape(n.innerXml(e)); else if (o) if (o > 1) t = n.escape(n.innerXml(e)); else for (var a = e.firstChild; a; a = a.nextSibling) t["#cdata"] = n.escape(a.nodeValue) } e.attributes.length || e.firstChild || (t = null) } else 9 == e.nodeType ? t = n.toObj(e.documentElement) : 8 == e.nodeType ? console.log(e.textContent) : alert("unhandled node type: " + e.nodeType); return t }, toJson: function (e, t, i) { var r = t ? '"' + t + '"' : ""; if (e instanceof Array) { for (var o = 0, l = e.length; l > o; o++) e[o] = n.toJson(e[o], "", i + "	"); r += (t ? ":[" : "[") + (e.length > 1 ? "\n" + i + "	" + e.join(",\n" + i + "	") + "\n" + i : e.join("")) + "]" } else if (null == e) r += (t && ":") + "null"; else if ("object" == typeof e) { var a = []; for (var s in e) a[a.length] = n.toJson(e[s], s, i + "	"); r += (t ? ":{" : "{") + (a.length > 1 ? "\n" + i + "	" + a.join(",\n" + i + "	") + "\n" + i : a.join("")) + "}" } else r += "string" == typeof e ? (t && ":") + '"' + e.toString() + '"' : (t && ":") + e.toString(); return r }, innerXml: function (e) { var n = ""; if ("innerHTML" in e) n = e.innerHTML; else for (var t = function (e) { var n = ""; if (1 == e.nodeType) { n += "<" + e.nodeName; for (var i = 0; i < e.attributes.length; i++) n += " " + e.attributes[i].nodeName + '="' + (e.attributes[i].nodeValue || "").toString() + '"'; if (e.firstChild) { n += ">"; for (var r = e.firstChild; r; r = r.nextSibling) n += t(r); n += "</" + e.nodeName + ">" } else n += "/>" } else 3 == e.nodeType ? n += e.nodeValue : 4 == e.nodeType && (n += "<![CDATA[" + e.nodeValue + "]]>"); return n }, i = e.firstChild; i; i = i.nextSibling) n += t(i); return n }, escape: function (e) { return e.replace(/[\\]/g, "\\\\").replace(/[\"]/g, '\\"').replace(/[\n]/g, "\\n").replace(/[\r]/g, "\\r") }, removeWhite: function (e) { e.normalize(); for (var t = e.firstChild; t;) if (3 == t.nodeType) if (t.nodeValue.match(/[^ \f\n\r\t\v]/)) t = t.nextSibling; else { var i = t.nextSibling; e.removeChild(t), t = i } else 1 == t.nodeType ? (n.removeWhite(t), t = t.nextSibling) : t = t.nextSibling; return e }, removePrefix: function (e) { return e.substring(e.indexOf(":") + 1) } }; return 9 == e.nodeType && (e = e.documentElement), n.toObj(n.removeWhite(e)) }

var WFSCapabilities = function () { var e = { V1_0_0: "1.0.0", V1_1_0: "1.1.0", V2_0_0: "2.0.0" }, r = function () { var r, n = [], u = [], p = [], _ = xml2json(arguments[0]); switch (_.version) { case e.V1_0_0: r = e.V1_0_0; break; case e.V1_1_0: r = e.V1_1_0; break; case e.V2_0_0: r = e.V2_0_0 } n = t(_, r), u = a(_, r), p = i(_, r); var o = s(_, r), l = { Operations: n, FeatureTypes: u, Filters: p }; return TC.Util.extend(l, o), l }, t = function (r, t) { switch (t) { case e.V1_0_0: var a = r.Capability.Request; if (a.GetFeature) { var i = []; for (var s in a.GetFeature.ResultFormat) i.push(s.toLowerCase()); a.GetFeature.outputFormat = i, delete a.GetFeature.ResultFormat, a.GetFeature.Operations = r.FeatureTypeList.Operations } return a; case e.V1_1_0: return {}; case e.V2_0_0: var n = {}; for (var s in r.OperationsMetadata) { var u = {}; u[s] = r.OperationsMetadata[s]; for (var p in u[s]) u[s][p] && u[s][p].hasOwnProperty("AllowedValues") && (u[s][p] = u[s][p].AllowedValues.Value); TC.Util.extend(n, u) } return n } return null }, a = function (r, t) { switch (t) { case e.V1_0_0: for (var a = {}, i = 0; i < r.FeatureTypeList.FeatureType.length; i++) { var s = r.FeatureTypeList.FeatureType[i].Name; a[s.substring(s.indexOf(":") + 1)] = r.FeatureTypeList.FeatureType[i] } return a; case e.V1_1_0: return {}; case e.V2_0_0: for (var a = {}, i = 0; i < r.FeatureTypeList.FeatureType.length; i++) { var s = r.FeatureTypeList.FeatureType[i].Name; a[s.substring(s.indexOf(":") + 1)] = r.FeatureTypeList.FeatureType[i] } return a } return null }, i = function (r, t) { switch (t) { case e.V1_0_0: return r.Filter_Capabilities; case e.V1_1_0: return {}; case e.V2_0_0: var a = r.Filter_Capabilities; return a } return null }, s = function (r, t) { switch (t) { case e.V1_0_0: var a = {}; for (var i in r) "string" == typeof r[i] && (a[i] = r[i]); return a; case e.V1_1_0: return {}; case e.V2_0_0: var a = {}; for (var i in r) "string" == typeof r[i] && (a[i] = r[i]); return a } return {} }, n = function (e) { var e = e, t = e.substring(e.indexOf("://") < 0 ? 0 : e.indexOf("://") + 3); if (TC.capabilities[t]) return Promise.resolve(TC.capabilities[t]); var a = {}; return a.SERVICE = "WFS", a.VERSION = "2.0.0", a.REQUEST = "GetCapabilities", new Promise(function (x, y) { TC.ajax({ url: TC.proxify(e) + "?" + TC.Util.getParamString(a), method: "GET" }).then(function (response) { var e = WFSCapabilities.Parse(response.data), a = e.Operations.GetCapabilities.DCP && e.Operations.GetCapabilities.DCP.HTTP.Get["xlink:href"] || e.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource; TC.capabilities[a] = e, TC.capabilities[t] = e, x(WFSCapabilities.Parse(response.data)) }) }) }; return { Promises: n, Parse: r } }();
; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Geometry = factory();
    }
})(TC, function () {
        const Geometry = {
            isPoint: function (geometry) {
                return Array.isArray(geometry) && geometry.length >= 2 && typeof geometry[0] === 'number' && typeof geometry[1] === 'number';
            },
            isRing: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isPoint(geometry[0]));
            },
            isRingCollection: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRing(geometry[0]));
            },
            isMultiRingCollection: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRingCollection(geometry[0]));
            },
            getNearest: function getNearest(point, candidates) {
                return TC.wrap.Geometry.getNearest(point, candidates);
            },
            isInside: function isInside(point, ring) {
                var result = false;
                if (Geometry.isPoint(point)) {
                    if (Geometry.isPoint(ring)) {
                        result = point[0] === ring[0] && point[1] === ring[1];
                    }
                    else if (Geometry.isRing(ring)) {
                        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                            var xi = ring[i][0], yi = ring[i][1];
                            var xj = ring[j][0], yj = ring[j][1];

                            var intersect = ((yi > point[1]) != (yj > point[1]))
                                && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                            if (intersect) result = !result;
                        }
                    }
                    else if (Geometry.isRingCollection(ring) && ring.length > 0) {
                        // polígono con agujeros
                        // miramos si está en el polígono exterior
                        if (isInside(point, ring[0])) {
                            var insideHole = false;
                            // miramos si está en un agujero
                            for (var i = 1; i < ring.length; i++) {
                                if (isInside(point, ring[i])) {
                                    insideHole = true;
                                    break;
                                }
                            }
                            if (!insideHole) {
                                result = true;
                            }
                        }
                    }
                    else if (Geometry.isMultiRingCollection(ring) && ring.length > 0) {
                        // multipolígono
                        // miramos si está en alguno de los polígonos
                        for (var i = 0, len = ring.length; i < len; i++) {
                            if (isInside(point, ring[i])) {
                                result = true;
                                break;
                            }
                        }
                    }
                }
                return result;
            }
        };
        return Geometry;
    });


/**
Para crear la interfaz de usuario, la API SITNA dibuja en la página una gran cantidad de elementos HTML. Para marcarlos como elementos de la
interfaz de usuario de los objetos de la API SITNA, se les añade una serie de clases CSS con un nombre convenido, de forma que es fácil modificar
el aspecto de los controles de la API mediante reglas CSS, e identificar elementos de interfaz mediante selectores CSS.

El nombre de las clases CSS usadas en la API SITNA es sistemático: todas empiezan con el prefijo `tc-`, y si un elemento está anidado dentro de otro,
generalmente su nombre empieza con el nombre del elemento padre (p.e. el elemento con la clase `tc-ctl-lcat-search` está dentro del elemento
con la clase `tc-ctl-lcat`). Esta no es una regla estricta, porque ciertos elementos son muy genéricos y tienen un nombre más sencillo
(p. e., dentro de un elemento con clase `tc-ctl-lcat` existe un elemento con clase `tc-textbox`, que se utiliza para dar estilo a todas las cajas
de texto de la API SITNA).

Aparte de las clases CSS que definen elementos de la interfaz de usuario, hay otras clases CSS que definen estados de elementos que son relevantes
desde el punto de vista de esa interfaz (p. e., el elemento está oculto, o es un nodo de un árbol que está replegado, o es una herramienta que está
activa).

En general, cualquier cambio de estado en la interfaz de usuario se define añadiendo o quitando clases de este tipo a elementos HTML de la aplicación
(p. e., si un elemento debe ocultarse de la interfaz, en vez de ponerle una regla de estilo `display:none` la API le añade la clase `tc-hidden`).

Para comprobar la estructura de elementos HTML y clases CSS de los controles de la API SITNA puede consultar el siguiente
[ejemplo](../../examples/CSS.html).

@module 3. Clases CSS
 */
/**
A continuación se describen todas las clases CSS que definen la estructura y/o afectan el comportamiento y aspecto del control
{{#crossLink "SITNA.cfg.MapControlOptions/layerCatalog:property"}}{{/crossLink}}.

## Clases que definen elementos de interfaz

| Clase CSS | Función que desempeña el elemento que tiene la clase |
|-----------|------------------------------------------------------|
| `tc-map` | Interfaz de una instancia de la clase SITNA.Map. Generalmente un `<div>`, es el elemento cuyo id se pasa como parámetro al constructor de la clase SITNA.Map. En él se dibuja el viewport del mapa y todos los elementos del layout. |
| `tc-ctl` | Interfaz de un control. Los controles se renderizan en un elemento definido por la opción div de la configuración propia del control. |
| `tc-ctl-lcat` | Interfaz del control layerCatalog. |
| `tc-ctl-lcat-search` | Parte de la interfaz que contiene el buscador de capas disponibles, con su cuadro de texto y su lista de resultados. |
| `tc-group` | Un elemento de interfaz que contiene un grupo de subelementos. |
| `tc-ctl-lcat-input` | Un elemento de introducción de texto en el control layerCatalog. |
| `tc-textbox` | Un elemento de introducción de texto de un control. |
| `tc-ctl-lcat-search-group` | En los resultados de búsqueda de capas, el conjunto de resultados que se corresponden con uno de los nodos raíz del árbol de capas disponibles. En la práctica, suele ser el conjunto de resultados de búsqueda de uno de los servicios WMS que tenemos añadidos al catálogo. |
| `tc-ctl-lcat-search-btn-info` | Botón junto al nombre de la capa que nos abre el panel de información adicional de la capa. |
| `tc-ctl-lcat-tree` | Elemento donde se muestra el árbol de capas disponibles. |
| `tc-ctl-lcat-branch` | Lista de nodos del árbol de capas disponibles. |
| `tc-ctl-lcat-node` | Nodo del árbol de capas disponibles. |
| `tc-ctl-lcat-info` | Panel que muestra información adicional de la capa (descripción, enlaces a metadatos) |
| `tc-ctl-lcat-info-close` | Botón para cerrar el panel de información adicional de la capa |
| `tc-ctl-lcat-title` | En el panel de información adicional de la capa, título de la capa |
| `tc-ctl-lcat-abstract` | Texto descriptivo de la capa. |
| `tc-ctl-lcat-metadata` | Sección con los enlaces a los metadatos de la capa. |

## Clases que definen estados

| Clase CSS | Función que desempeña el elemento que tiene la clase |
|-----------|------------------------------------------------------|
| `tc-collapsed` | Un elemento desplegable de la interfaz (por ejemplo, una rama del árbol de capas disponibles) está replegado. |
| `tc-checked` | En un nodo de capas disponibles, indica que la capa ya está añadida. |
| `tc-hidden` | El elemento está oculto a la vista del usuario. |
| `tc-selectable` | El elemento corresponde a una capa que es elegible para ser añadida al mapa. |
| `tc-loading` | El elemento es un nodo del árbol o de los resultados de búsqueda que ha sido seleccionado por el usuario para añadirse al mapa, pero la carga de la capa en el mapa no ha terminado todavía. |
| `tc-active` | Elemento biestado que está activo. Por ejemplo, el botón del idioma en el que está el visor actualmente. |
  
#### Ejemplo:

```javascript
   <div id="catalog" class="tc-ctl tc-ctl-lcat">
     <h2>Capas disponibles<button class="tc-ctl-lcat-btn-search" title="Buscar capas por texto"></button></h2>
     <div class="tc-ctl-lcat-search tc-hidden tc-collapsed">
       <div class="tc-group"><input type="search" class="tc-ctl-lcat-input tc-textbox" placeholder="Texto para buscar en las capas"></div>
       <ul></ul>
     </div>
     <div class="tc-ctl-lcat-tree">
       <ul class="tc-ctl-lcat-branch">
         <li class="tc-ctl-lcat-node" data-layer-name="" data-layer-uid="10"><span>IDENA</span>
           <ul class="tc-ctl-lcat-branch">
             <li class="tc-ctl-lcat-node tc-collapsed" data-layer-name="nombresGeograficos" data-layer-uid="656"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Nombres geográficos</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed">
                 <li class="tc-ctl-lcat-node tc-collapsed" data-layer-name="IDENA:toponimia" data-layer-uid="657"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Toponimia</span><button class="tc-ctl-lcat-btn-info"></button>
                   <ul class="tc-ctl-lcat-branch tc-collapsed">
                     <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-layer-name="IDENA:TOPONI_Txt_Toponimos" data-layer-uid="658"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Nombres de lugar (topónimos)</span><button class="tc-ctl-lcat-btn-info"></button>
                       <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
                     </li>
                   </ul>
                 </li>
               </ul>
             </li>
           </ul>
         </li>
         <li class="tc-ctl-lcat-node tc-collapsed" data-layer-name="" data-layer-uid="962"><span>IGN - Unidades administrativas</span>
           <ul class="tc-ctl-lcat-branch tc-collapsed">
             <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-layer-name="AU.AdministrativeBoundary" data-layer-uid="963"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Límite administrativo</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
             </li>
             <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-layer-name="AU.AdministrativeUnit" data-layer-uid="964"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Unidad administrativa</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
             </li>
           </ul>
         </li>
       </ul>
     </div>
     <div class="tc-ctl-lcat-info tc-hidden"><a class="tc-ctl-lcat-info-close"></a>
       <h2>Información de capa</h2>
       <h3 class="tc-ctl-lcat-title"></h3>
     </div>
   </div>
    ```


@module 3. Clases CSS
@submodule 3.1. layerCatalog
 */

/**
### 2.0.0

- Eliminadas todas las referencias a OpenLayers 2.
- Eliminada la dependencia de jQuery.
- Eliminada la dependencia de Modernizr.
- Se retira el soporte a Internet Explorer.
- Actualización a OpenLayers 5.
- Corrección de errores.

### 1.6.0

- Añadida capacidad de compartir entidades vectoriales.
- Cambiada interfaz de usuario del control de información del mapa.
- Añadido control de dibujo y medida.
- Añadido control con herramientas para aplicar a una entidad geográfica: zoom, compartir, descargar, borrar.
- Corrección de errores.

### 1.5.1

- Cambiada la interfaz de usuario del control de mapas de fondo para mostrar una preselección de mapas.
- Corrección de errores.

### 1.5.0

- Añadido el control de catálogo de capas.
- Añadido el control de administración de capas de trabajo.
- Añadido el control para añadir datos geográficos externos.
- Añadido el control de impresión de mapas en PDF.
- Las capas de tipo VECTOR soportan más formatos de archivos geográficos.
- Se ha eliminado la limitación de extensión máxima por defecto del mapa.
- Corrección de errores.

### 1.4.0

- Añadida la capacidad de cambiar la proyección del mapa.
- Añadidos mapas de fondo de OpenStreetMap, Carto y Mapbox.
- Mejora de soporte a peticiones CORS.
- Corrección de errores.

### 1.3.0

- Añadida opción de clustering para capas de puntos.
- Añadido soporte multiidioma.
- El control de búsqueda soporta nuevos tipos de búsqueda: vías, direcciones postales y parcelas catastrales.
- Mejora de soporte a peticiones CORS.
- Corrección de errores.

### 1.2.2

- Actualización a OpenLayers 4.
- Corrección de errores.

### 1.2.1

- Corrección de errores.

### 1.2.0

- Añadida la capacidad de exportar el mapa a una imagen.
- Añadido a la documentación ejemplo de exportación de imagen.
- El control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}} permite compartir entidades geográficas o descargarlas en distintos formatos.
- Corrección de errores.

### 1.1.3

- Añadidos a la clase {{#crossLink "SITNA.Map"}}{{/crossLink}} métodos de consulta y visualización de entidades geográficas.
- Añadidos ejemplos a la documentación para los métodos anteriores.
- Mejorada la interfaz del control de búsquedas añadiendo a los resultados distinción por tipo.
- Añadido registro centralizado de errores JavaScript.
- Corrección de errores.

### 1.1.2

- El control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}} pasa a estar incluido por defecto en el mapa.
- La [página de incrustación de visores con KML](//sitna.tracasa.es/kml/) pasa a usar OpenLayers 3.
- Correción de errores de la [página de incrustación de visores con KML](//sitna.tracasa.es/kml/).
- Añadido ejemplo a la documentación de {{#crossLink "SITNA.cfg.ClickOptions"}}{{/crossLink}}.
- Añadido ejemplo a la documentación de {{#crossLink "SITNA.cfg.CoordinatesOptions"}}{{/crossLink}}.
- Mejorada con botones triestado la usabilidad del control de medición.
- Añadido indicador de carga de los elementos del visor.
- Añadido registro centralizado de errores JavaScript.
- Corrección de errores.

### 1.1.1

- Añadido el control de Google StreetView ({{#crossLink "SITNA.cfg.MapControlOptions/streetView:property"}}{{/crossLink}}).
- Añadido el control de gestión de clics en el mapa ({{#crossLink "SITNA.cfg.MapControlOptions/click:property"}}{{/crossLink}}).
- Añadidas [opciones](./classes/SITNA.cfg.CoordinatesOptions.html) de representación de coordenadas en el control {{#crossLink "SITNA.cfg.MapControlOptions/coordinates:property"}}{{/crossLink}}.
- Compatibilidad mejorada con dispositivos móviles.
- Mejoras de rendimiento en el layout por defecto.
- Mejoras en la documentación.
- Corrección de errores.

### 1.1.0

- Mejoras en el control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}}: visualización de geometrías
 de las entidades geográficas, bocadillo arrastrable.
- Se retira el soporte a OpenLayers 2.
- Corrección de errores.

### 1.0.6

- Añadido el control de información de entidades basado en la petición `getFeatureInfo` de WMS, activable con la opción
 SITNA.cfg.MapControlOptions.{{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}}.
- Añadidas las opciones de zoom al método SITNA.Map.{{#crossLink "SITNA.Map/zoomToMarkers:method"}}{{/crossLink}}: radio del
 área alrededor del marcador a mostrar y margen a dejar en los bordes.
- Corregido error en el layout por defecto que impedía la funcionalidad de deslizar dedo para colapsar paneles.

### 1.0.5

- Corregido error que impedía en ver en la tabla de contenidos si una capa cargada es visible a la escala actual.
- Corregido error que impedía que se pudieran ocultar desde la tabla de contenidos todas las entidades de una capa KML.
- Correcciones de estilo en Internet Explorer.
- Eliminada la necesidad de que el mapa de situación tenga un mapa de fondo de los disponibles en el mapa principal.
- Cambios menores del estilo por defecto.

### 1.0.4

- Añadidas etiquetas `form` en el HTML de la tabla de contenidos.
- Añadida compatibilidad con OpenLayers 3.
- Actualizada para la maquetación por defecto la fuente [FontAwesome](http://fortawesome.github.io/Font-Awesome/) a la versión 4.3.0.
- La leyenda ahora oculta los servicios que no tienen capas visibles.
- Cambios en el estilo por defecto.
- Corrección de errores.

### 1.0.3

- Añadida la opción de deshabilitar el zoom en el mapa con la rueda de ratón mediante la propiedad SITNA.Cfg.{{#crossLink "SITNA.Cfg/mousewWheelZoom:property"}}{{/crossLink}}.
- Añadida la posibilidad de mostrar un marcador con su bocadillo de información asociada visible por defecto, mediante la propiedad SITNA.cfg.MarkerOptions.{{#crossLink "SITNA.cfg.MarkerOptions/showPopup:property"}}{{/crossLink}}.
- Corrección de errores.

### 1.0

- Despliegue inicial.

@module 4. Historial de cambios
 */

var SITNA = window.SITNA || {};
var TC = window.TC || {};
TC.isDebug = true;

(function () {
    if (!window.TC || !window.TC.Cfg) {
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
        var url = TC.apiLocation + (TC.isDebug ? 'tcmap.js' : 'tcmap.min.js');
        var req = new XMLHttpRequest();
        req.open("GET", url, false); // 'false': synchronous.
        req.send(null);

        var head = document.getElementsByTagName("head")[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.text = req.responseText;
        head.appendChild(script);
    }
})();

/**
La dirección principal de acceso a la API es **[//sitna.tracasa.es/api/](//sitna.tracasa.es/api/)**. No obstante, hay otras direcciones disponibles para
otras necesidades concretas:

- Lógica de la API compilada en un solo archivo:
  + Minimizada: [//sitna.tracasa.es/api/sitna.ol.min.js](//sitna.tracasa.es/api/sitna.ol.min.js).
  + Sin minimizar: [//sitna.tracasa.es/api/sitna.ol.debug.js](//sitna.tracasa.es/api/sitna.ol.debug.js).

- Lógica de la API repartida en varios archivos que se solicitan bajo demanda:
  + Minimizada: [//sitna.tracasa.es/api/sitna.min.js](//sitna.tracasa.es/api/sitna.min.js).
  + Sin minimizar: [//sitna.tracasa.es/api/sitna.js](//sitna.tracasa.es/api/sitna.js).

@module 1. Direcciones de la API
 */


/**
La configuración por defecto de {{#crossLink "SITNA.cfg.SearchOptions"}}{{/crossLink}} tiene como origen de datos el WFS de IDENA. Es posible establecer un origen de datos distinto en el que consultar, para ello en lugar de indicar un booleano, que activa o desactiva la búsqueda, se indicará un objeto con las propiedades a sobrescribir. Las propiedades a sobrescribir no siempre serán las mismas, variarán en función de la configuración que tenga la búsqueda que se quiera modificar.


@module 2.3. Objeto de configuración global
@submodule 2.3.1. Objeto de configuración de opciones del buscador
 */

/**
  Opciones de configuración del origen de datos de la búsqueda de direcciones postales.

  Esta clase no tiene constructor.
  
  Puede consultar el ejemplo [online](../../examples/Cfg.SearchPostalAddressSource.html). 
  #### Ejemplo:

  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Txt_Portal',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
        queryProperties: {
            firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
            secondQueryWord: ['VIA', 'VIANOAC'],
            thirdQueryWord: ['PORTAL']
        },
        suggestionListHead: {
            label: "search.list.number",
            color: "fontColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1} {2}, {0}',
        styles: [
            {
                point: {
                    radius: 0,
                    label: "PORTAL",
                    angle: "CADANGLE",
                    fontColor: "#CB0000",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchPostalAddressSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).  
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de direcciones postales. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la entidad de población.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la vía.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/thirdQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el número de portal.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la dirección postal.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a la dirección postal. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputProperties:property"}}{{/crossLink}} como `[EntidadPoblacion, Via, Numero]` y {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1} {2}, {0}”` mostrará en la lista resultados del tipo: <em>Calle Estafeta 13, Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de parcelas catastrales.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchCadastralSource.html). 
  #### Ejemplo:

  ```javascript
  {   
    url:'//idena.navarra.es/ogc/wfs',                
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',        
        featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
        municipality: {
            featureType: 'CATAST_Pol_Municipio',
            labelProperty: 'MUNICIPIO',
            idProperty: 'CMUNICIPIO'
        },
        queryProperties: {
            firstQueryWord: 'CMUNICIPIO',
            secondQueryWord: 'POLIGONO',
            thirdQueryWord: 'PARCELA'
        },
        suggestionListHead: {
            label: "search.list.cadastral",
            color: [
                {
                    CATAST_Pol_ParcelaUrba: {
                        title: "search.list.cadastral.urban",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaRusti: {
                        title: "search.list.cadastral.rustic",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaMixta: {
                        title: "search.list.cadastral.mixed",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                }
            ]
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#136278',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#0c8b3d',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#e5475f',
                    strokeWidth: 2,
                    strokeOpacity: 1
                },
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchCadastralSource
  @static
 */

/**
  Definición de la fuente de datos para la búsqueda de parcela por nombre de municipio en lugar de por código del mismo.
  @property municipality
  @type SITNA.cfg.SearchCadastralSourceExt
  @required
*/

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs").
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchCadastralSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de parcelas. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el código de municipio.</pre>
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el polígono.</pre>
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/thirdQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar la parcela. </pre>
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la parcela catastral.
  @property geometryName
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}.
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchCadastralSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de municipios.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchMunicipalitySource.html). 
  #### Ejemplo:

  ```javascript
  {
    url:'//idena.navarra.es/ogc/wfs',        
        url: '//idena.navarra.es/ogc/wfs',
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
        },
        suggestionListHead: {
            label: "search.list.municipality",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',        
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fe06a5',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchMunicipalitySource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace). 
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de municipios. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre del municipio.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría del municipio.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un municipio. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputProperties:property"}}{{/crossLink}} como `[NombreMunicipio]` y {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputFormatLabel:property"}}{{/crossLink}} como `“{0}”` mostrará en la lista resultados del tipo: <em>Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
  
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.  
  
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}. 
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de cascos urbanos.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchTownSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'ESTADI_Pol_EntidadPob',        
        dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],        
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDAD']
        },
        suggestionListHead: {
            label: "search.list.urban",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO', 'ENTIDAD'],
        outputFormatLabel: '{1} ({0})',        
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#feba1e',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchTownSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace). 
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchTownSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de cascos urbanos. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre del casco urbano.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría del casco urbano.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un casco urbano. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchTownSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchTownSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchTownSource/outputProperties:property"}}{{/crossLink}} como `[NombreMunicipio, NombreCascoUrbano]` y {{#crossLink "SITNA.cfg.SearchTownSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1} ({0})”` mostrará en la lista resultados del tipo: <em>Salinas de Pamplona (Galar)</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchTownSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de vías.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchStreetSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        renderFeatureType: 'CATAST_Txt_Calle',
        featureType: 'CATAST_Lin_CalleEje',
        dataIdProperty: ['CVIA'],        
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
            secondQueryWord: ['VIA', 'VIANOAC']
        },
        suggestionListHead: {
            label: "search.list.street",
            color: "strokeColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1}, {0}',
        styles: [
            {
                line: {
                    strokeColor: "#CB0000",
                    strokeOpacity: 1,
                    strokeWidth: 2,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            },
            {
                point: {
                    label: "VIA",
                    angle: "CADANGLE",
                    fontColor: "#000000",
                    fontSize: 7,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchStreetSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).  
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Colección con los nombres de las capas auxiliares a añadir al resultado de la búsqueda en el mapa. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/dataIdProperty:property"}}{{/crossLink}}.
   
No se muestran sugerencias en base a las capas auxiliares, únicamente se añade información en el momento de pintar en el mapa, es por ello que debe existir relación en los datos entre las capas definidas en {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}} y que ambas cuenten con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/dataIdProperty:property"}}{{/crossLink}}. 
  @property renderFeatureType
  @type Array
  @optional
*/

/**
  Definición de los campos por los que filtrar la búsqueda de vías. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la entidad de población.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la vía.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la vía.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a una vía. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchStreetSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchStreetSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchStreetSource/outputProperties:property"}}{{/crossLink}} como `[EntidadPoblacion, Via]` y {{#crossLink "SITNA.cfg.SearchStreetSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1}, {0}”` mostrará en la lista resultados del tipo: <em>Calle Estafeta, Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en las colecciones 1 y 2 siendo 1 la concatenación de {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}} y 2 {{#crossLink "SITNA.cfg.SearchStreetSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como la suma de las capas definidas en {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}}  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Definición del color en la cabecera de la lista de sugerencias (para una capa concreta) de una búsqueda con resultados posibles de varias capas. Se establece como clave el nombre de la capa a la cual afecta ésta configuración.
  
Esta clase no tiene constructor.
  #### Ejemplo:

  ```javascript
    CATAST_Pol_ParcelaUrba: {
      title: "search.list.cadastral.urban",
      color: {
        geomType: "polygon",
        css: "strokeColor"
      }
    }
  ```
  @class SITNA.cfg.SearchSuggestionListColorByFeatureType
  @static
 */

/**
  Title para identificar al color. Se define con la clave del diccionario de traducciones. Revisar la sección "Soporte multiidioma" en {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}. 
  @property title
  @type String
  @required
 */

/**
  Configuración para obtener el color. 
  @property color
  @type SITNA.cfg.SearchSuggestionListColor
  @required
 */

/**
  Definición del color en la cabecera de la lista de sugerencias de una búsqueda con resultados posibles de una sola capa.
  
Esta clase no tiene constructor.
  #### Ejemplo:

  ```javascript
     {
        geomType: "point",
        css: "fontColor"
     }
  ```
  @class SITNA.cfg.SearchSuggestionListColor
  @static
 */

/**
  Nombre del tipo de geometría.
  @property geomType
  @type SITNA.consts.Geom
  @required
 */

/**
  Nombre de la propiedad de las sugerencias de la cual extraer el color. Ha de ser alguna de las distintas propiedades de colores presentes en {{#crossLink "SITNA.cfg.PointStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.LineStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.PolygonStyleOptions"}}{{/crossLink}}.
  @property css
  @type String
  @required
 */


/**
  Opciones de configuración del origen de datos de una búsqueda.
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.SearchQueryProperties
  @static
 */

/**
  Colección de nombre de campo o campos a consultar para el 1º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property firstQueryWord
  @type Array
  @required
 */

/**
  Colección de nombre de campo o campos a consultar para el 2º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property secondQueryWord
  @type Array
  @optional
*/

/**
  Colección de nombre de campo o campos a consultar para el 3º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property thirdQueryWord
  @type Array
  @optional
*/

/**
  Opciones de configuración para la composición de la cabecera de una lista de sugerencias de búsqueda.
  
Esta clase no tiene constructor.
  #### Ejemplo:
  ```javascript
  {
    label: "search.list.town",
    color: "strokeColor"
  }
  @class SITNA.cfg.SearchSuggestionListProperties
  @static
 */

/**
  Clave del diccionario de traducciones que indica qué tipo de búsqueda es: Parcela Catastral, Municipio, Calle… Revisar la sección "Soporte multiidioma" en {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}. 
  @property label
  @type String
  @required
 */

/**
  Configuración para obtener el color que representa al tipo de búsqueda. Se establece como color la primera coincidencia en {{#crossLink "SITNA.cfg.SearchCadastralSource/styles:property"}}{{/crossLink}} que cumpla con la configuración. 
  
La definición como String String ha de ser para indicar el nombre de una propiedad presente en {{#crossLink "SITNA.cfg.PointStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.LineStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.PolygonStyleOptions"}}{{/crossLink}}.
  @property color
  @type SITNA.cfg.SearchSuggestionListColorByFeatureType|SITNA.cfg.SearchSuggestionListColor|String
  @required
 */

/**
  Configuración del origen de datos auxiliar a la búsqueda de parcelas catastrales para la codificación de los nombres de municipio.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchCadastralSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//miServicioWFS/ogc/wfs',
    featurePrefix: 'IDENA',    
    featureType: ['Pol_ParcelaUrbana', 'Pol_ParcelaRustica', 'Pol_ParcelaMixta'],
    municipality: {
      featureType: 'Pol_Municipio',
      labelProperty: 'MUNICIPIO',
      idProperty: 'COD_MUNICIPIO'      
    },
    queryProperties: {
      firstQueryWord: 'COD_MUNICIPIO',
      secondQueryWord: 'POLIGONO',
      thirdQueryWord: 'PARCELA'
    }
  }
  @class SITNA.cfg.SearchCadastralSourceExt
  @static
 */

/**
  Colección de nombre de capa o capas a consultar.
  @property featureType
  @type Array
  @required
 */

/**
  Nombre de campo que identifica unívocamente el municipio cuyos valores deben coincidir con los posibles valores del campo indicado en {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}.
  @property idProperty
  @type String
  @required
*/

/**
  Nombre de campo en el que buscar el texto indicado.
  @property labelProperty
  @type String
  @required
*/


/**
  Colección de identificadores de tipo de geometría.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.Geom
  @static
 */

/**
  Identificador de geometría de tipo polígono.
  @property polygon
  @type string
  @final
 */

/**
  Identificador de geometría de tipo línea.
  @property line
  @type string
  @final
 */

/**
  Identificador de geometría de tipo punto.
  @property point
  @type string
  @final
 */



/**
Para modificar el aspecto y los datos del mapa existen varias opciones de configuración. Estas opciones se le pueden pasar por tres medios
no excluyentes. Son los siguientes:

1. Parámetros del constructor de [SITNA.Map](../classes/SITNA.Map.html).
2. Maquetación del visor (ver [SITNA.Cfg.layout](../classes/SITNA.Cfg.html#property_layout)).
3. Objeto de configuración global (ver [SITNA.Cfg](../classes/SITNA.Cfg.html)).

Esta lista está ordenada por orden de mayor a menor prevalencia, de manera que si una configuración por un medio entra en conflicto por otra los
conflictos se resuelven en ese orden.

@module 2. Configuración
 */

/**
  Colección de constantes utilizadas por la API. Se recomienda utilizar las propiedades de esta clase estática para referirse a valores conocidos.
  
No deberían modificarse las propiedades de esta clase.
  @class SITNA.Consts
  @static
 */
SITNA.Consts = TC.Consts;
/**
  Identificadores de capas útiles de IDENA y otros servicios de terceros.
  @property layer
  @type SITNA.consts.Layer
  @final
 */
/**
  Identificadores de tipo de capa.
  @property layerType
  @type SITNA.consts.LayerType
  @final
 */
/*
  Identificadores de tipo de consulta al mapa.
  property mapSearchType
  type SITNA.consts.MapSearchType
  final
 */
/**
  Tipos MIME de utilidad.
  @property mimeType
  @type SITNA.consts.MimeType
  @final
 */

/**
  Colección de identificadores de tipo de capa.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.LayerType
  @static
 */
/**
  Identificador de capa de tipo WMS.
  @property WMS
  @type string
  @final
 */
/**
  Identificador de capa de tipo WMTS.
  @property WMTS
  @type string
  @final
 */
/**
  Identificador de capa de tipo WFS.
  @property WFS
  @type string
  @final
 */
/**
  Identificador de capa de tipo KML.
  @property KML
  @type string
  @final
  @deprecated En lugar de esta propiedad es recomendable usar VECTOR para cargar archivos KML.
 */
/**
  Identificador de capa de tipo vectorial. Este tipo de capa es la que se utiliza para dibujar marcadores o para cargar
  archivos de datos geográficos vectoriales de los siguientes tipos: KML, GeoJSON, GPX, GML, WKT y TopoJSON.
  @property VECTOR
  @type string
  @final
 */

/**
  Colección de identificadores de capas útiles de IDENA y otros servicios de terceros.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.Layer
  @static
 */
/**
  Identificador de la capa de ortofoto de máxima actualidad del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de mapa base del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_BASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa de catastro del WMS de IDENA.
  @property IDENA_CADASTER
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía topográfica 2017 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_CARTO
  @type string
  @final
 */
/**
  Identificador de la capa de la combinación de ortofoto de máxima actualidad y mapa base del WMS de IDENA.
  @property IDENA_BASEMAP_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de relieve en blanco y negro del WMS de IDENA.
  @property IDENA_BW_RELIEF
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2018 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2018
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2017 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2017
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2014 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2014
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2012 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2012
  @type string
  @final
 */
/**
  Identificador de la capa de mapa base del WMS de IDENA.
  @property IDENA_DYNBASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía topográfica 2017 del WMS de IDENA.
  @property IDENA_DYNCARTO
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto de máxima actualidad del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2018 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2018
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2017 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2017
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2014 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2014
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2012 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2012
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía raster del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_CARTO
  @type string
  @final
 */
/**
  Identificador de la capa del callejero del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_BASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa del callejero en gris del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_BASEMAP_GREY
  @type string
  @final
 */
/**
  Identificador de la capa de relieve del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_RELIEF
  @type string
  @final
 */
/**
  Identificador de la capa del PNOA del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa del modelo digital de superficies LIDAR del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_LIDAR
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía raster del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNCARTO
  @type string
  @final
 */
/**
  Identificador de la capa del callejero del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNBASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa del callejero en gris del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNBASEMAP_GREY
  @type string
  @final
 */
/**
  Identificador de la capa de relieve del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNRELIEF
  @type string
  @final
 */
/**
  Identificador de la capa del PNOA del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa del modelo digital de superficies LIDAR del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNLIDAR
  @type string
  @final
 */
/**
  Identificador de la capa de OpenStreetMap a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property OSM
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Voyager a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_VOYAGER
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Light a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_LIGHT
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Dark a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_DARK
  @type string
  @final
 */
/**
  Identificador de la capa de Mapbox Streets a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property MAPBOX_STREETS
  @type string
  @final
 */
/**
  Identificador de la capa de Mapbox Satellite a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property MAPBOX_SATELLITE
  @type string
  @final
 */
/**
  Identificador de una capa en blanco.
  @property BLANK
  @type string
  @final
 */

/**
  Colección de tipos MIME de utilidad.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.MimeType
  @static
 */
/**
  Tipo MIME de imagen PNG (`image/png`).
  @property PNG
  @type string
  @final
 */
/**
  Tipo MIME de imagen JPEG (`image/jpeg`).
  @property JPEG
  @type string
  @final
 */
/**
  Tipo MIME de documento GeoJSON (`application/vnd.geo+json`).
  @property GEOJSON
  @type string
  @final
 */
/**
  Tipo MIME de documento KML (`application/vnd.google-earth.kml+xml`).
  @property KML
  @type string
  @final
 */
/**
  Tipo MIME de documento GML (`application/gml+xml`).
  @property GML
  @type string
  @final
 */
/**
  Tipo MIME de documento GPX (`application/gpx+xml`).
  @property GPX
  @type string
  @final
 */

/*
  Colección de tipos de filtros.
  
No se deberían modificar las propiedades de este objeto.
  @class SITNA.consts.MapSearchType
  @static
 */
/*
  Identificador de filtro de consulta de tipo municipio.
  @property MUNICIPALITY
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo concejo.
  @property COUNCIL
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo casco urbano.
  @property URBAN
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo mancomunidad.
  @property COMMONWEALTH
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo genérico.
  @property GENERIC
  @type string
  @final
 */

/**
Un objeto {{#crossLink "SITNA.Cfg"}}{{/crossLink}} está accesible para todas las instancias del la clase {{#crossLink "SITNA.Map"}}{{/crossLink}}.

Por tanto, se puede configurar un mapa asignando valores a las propiedades de ese objeto:
  #### Ejemplo:

```javascript
SITNA.Cfg.crs = "EPSG:4326";
SITNA.Cfg.initialExtent = [
  -2.84820556640625,
  41.78912492257675,
  -0.32135009765625,
  43.55789822064767
];
var map = new SITNA.Map("mapa");
```
@module 2. Configuración
@submodule 2.3. Objeto de configuración global
 */


/**
  Configuración general de la API. Cualquier llamada a un método o un constructor de la API sin parámetro de opciones toma las opciones de esta clase. 
  Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

La clase es estática. 
  @class SITNA.Cfg
  @static
 */
SITNA.Cfg = TC.Cfg;
/**
  URL del proxy utilizado para peticiones a dominios remotos. 
  
Debido a restricciones de seguridad implementadas en Javascript, a través de `XMLHttpRequest` no es posible obtener información de dominios distintos al de la página web. 

  Hay dos maneras de solventar esta restricción. La primera es que el servidor remoto permita el acceso entre dominios estableciendo la cabecera `Access-Control-Allow-Origin` a 
  la respuesta HTTP. Dado que esta solución la implementan terceras personas (los administradores del dominio remoto), no siempre es aplicable. 

  La segunda solución es desplegar en el dominio propio un proxy. Un proxy es un servicio que recibe peticiones HTTP y las redirige a otra URL. 

  Si la propiedad `proxy` está establecida, todas las peticiones a dominios remotos las mandará al proxy para que este las redirija. De esta manera no infringimos las reglas de
  seguridad de Javascript, dado que el proxy está alojado en el dominio propio. 
 #### Ejemplo:

  ```javascript
    SITNA.Cfg.proxy = ""; // Las peticiones a http://www.otrodominio.com se hacen directamente
 
    SITNA.Cfg.proxy = "/cgi-bin/proxy.cgi?url="; // Las peticiones a http://www.otrodominio.com se convierten en peticiones a /cgi-bin/proxy.cgi?url=http://www.otrodominio.com
  ```
  @property proxy
  @type string
  @default ""  
 */
/**
  Código EPSG del sistema de referencia espacial del mapa. 

  Puede consultar el ejemplo [online](../../examples/Cfg.crs.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, lo cambiamos por SITNA.Consts.layer.IDENA_DYNBASEMAP.
      SITNA.Cfg.baseLayers[0] = SITNA.Consts.layer.IDENA_DYNBASEMAP;
      SITNA.Cfg.defaultBaseLayer = SITNA.Consts.layer.IDENA_DYNBASEMAP;
  
      // WGS 84
      SITNA.Cfg.crs = "EPSG:4326";
      // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
      SITNA.Cfg.initialExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
      SITNA.Cfg.maxExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
  
      var map = new SITNA.Map("mapa", {
        // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, establecer la capa SITNA.Consts.layer.IDENA_DYNBASEMAP en el control de mapa de situación.
        controls: {
          overviewMap: {
            layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
          }
        }
      });
    </script>
 ```
  @property crs
  @type string
  @default "EPSG:25830"  
 */
/**
  Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. Estos valores deben estar en las unidades definidas por 
  el sistema de referencia espacial del mapa. Por defecto la extensión es la de Navarra.
  @property initialExtent
  @type array
  @default [541084.221, 4640788.225, 685574.4632, 4796618.764]
 */
/**
  Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima, de forma que el centro del mapa nunca saldrá fuera de estos límites.
  Estos valores deben estar en las unidades definidas por el sistema de referencia espacial del mapa.

  Si en vez de un array el valor es `false`, el mapa no tiene limitada la extensión máxima.
  @property maxExtent
  @type array|boolean
  @default false
 */
/**
  Si se establece a `true`, la rueda de scroll del ratón se puede utilizar para hacer zoom en el mapa. 
  @property mouseWheelZoom
  @type boolean
  @default true
 */
/**
  Tolerancia en pixels a las consultas de información de capa. 
  
En ciertas capas, por ejemplo las que representan geometrías de puntos, puede ser difícil pulsar precisamente en el punto donde está la entidad geográfica que interesa.

  La propiedad `pixelTolerance` define un área de un número de pixels hacia cada lado del punto de pulsación, de forma que toda entidad geográfica que se interseque con ese área se incluye en el resultado de la consulta. 

  Por ejemplo, si el valor establecido es 10, toda entidad geográfica que esté dentro de un cuadrado de 21 pixels de lado (10 pixels por cuadrante más el pixel central) centrado en el punto de pulsación 
  se mostrará en el resultado. 
  <em>A tener en cuenta:</em> Esta propiedad establece el valor de los llamados "parámetros de vendedor" que los servidores de mapas admiten para modificar el comportamiento de las peticiones
  `getFeatureInfo` del standard WMS. Pero este comportamiento puede ser modificado también por otras circunstancias, como los estilos aplicados a las capas en el servidor. 
  
Como estas circunstancias están fuera del ámbito de alcance de esta API, es posible que los resultados obtenidos desde algún servicio WMS sean inesperados en lo referente a `pixelTolerance`. 
  @property pixelTolerance
  @type number
  @default 10
 */
/**
  Lista de objetos de definición de capa (instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}}) para incluir dichas capas como mapas de fondo. 

  Puede consultar el ejemplo [online](../../examples/Cfg.baseLayers.html). 
  #### Ejemplo:
    ```javascript
        <div id="mapa"></div>
        <script>
          // Establecer un proxy porque se hacen peticiones a otro dominio.
          SITNA.Cfg.proxy = "proxy.ashx?";
  
          // Añadir PNOA y establecerla como mapa de fondo por defecto.
          SITNA.Cfg.baseLayers.push({
            id: "PNOA",
            url: "http://www.ign.es/wms-inspire/pnoa-ma",
            layerNames: "OI.OrthoimageCoverage",
            isBase: true
          });
          SITNA.Cfg.defaultBaseLayer = "PNOA";
  
          var map = new SITNA.Map("mapa");
        </script>
  ```
  @property baseLayers
  @type array
  @default La lista incluye las siguientes capas de IDENA: Ortofoto 2014 (capa por defecto), Mapa base, Catastro, Cartografía topográfica.
  
 */
/**
  Identificador de la capa base por defecto o índice de la capa base por defecto en la lista de capas base del mapa (Consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/baseLayers:property"}}{{/crossLink}}).
  @property defaultBaseLayer
  @type string|number
  @default SITNA.consts.Layer.IDENA_ORTHOPHOTO
 */
/**
  Lista de objetos de definición de capa (instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}}) para incluir dichas capas como contenido del mapa. 

  Puede consultar el ejemplo [online](../../examples/Cfg.workLayers.html). 
    #### Ejemplo:
  ```javascript
    <div id="mapa"></div>
    <script>
      // Establecer un proxy porque se hacen peticiones a otro dominio.
      SITNA.Cfg.proxy = "proxy.ashx?";

      SITNA.Cfg.workLayers = [{
        id: "csantiago",
        title: "Camino de Santiago",
        url: "http://www.ign.es/wms-inspire/camino-santiago",
        layerNames: "PS.ProtectedSite,GN.GeographicalNames,AU.AdministrativeUnit"
      }];
      var map = new SITNA.Map("mapa");
    </script>
  ```
  @property workLayers
  @type array
  @default []  
 */
/**
  Opciones de controles de mapa.
  @property controls
  @type SITNA.cfg.MapControlOptions
  @default Se incluyen controles de indicador de espera de carga, atribución, indicador de coordenadas.
 */
/**
URL de la carpeta de maquetación. Para prescindir de maquetación, establecer esta propiedad a `null`.

Puede consultar el ejemplo [online](../../examples/Cfg.layout.html). 

Sus archivos de maquetación son
[markup.html](../../examples/layout/example/markup.html), [config.json](../../examples/layout/example/config.json),
[style.css](../../examples/layout/example/style.css), [resources/es-ES.json](../../examples/layout/example/resources/es-ES.json),
[resources/eu-ES.json](../../examples/layout/example/resources/eu-ES.json) y [resources/en-US.json](../../examples/layout/example/resources/en-US.json).

Para saber cómo utilizar maquetaciones, consulte la sección {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}.

#### Ejemplo:
```javascript
  <!-- layout/example/markup.html -->
   <div id="controls">
     <h1>{{stJamesWayInNavarre}}</h1>
     <div id="toc" />
     <div id="legend" />
   </div>
  <div id="languages">
    <a class="lang" href="?lang=es-ES" title="{{spanish}}">ES</a>
    <a class="lang" href="?lang=eu-ES" title="{{basque}}">EU</a>
    <a class="lang" href="?lang=en-US" title="{{english}}">EN</a>
  </div>
```
```javascript
  resources/es-ES.json
  {
    "stJamesWayInNavarre": "Camino de Santiago en Navarra",
    "spanish": "castellano",
    "basque": "euskera",
    "english": "inglés"
  }
```
```javascript
  resources/eu-ES.json
  {
    "stJamesWayInNavarre": "Nafarroan Donejakue bidea",
    "spanish": "gaztelania",
    "basque": "euskara",
    "english": "ingelesa"
  }
```
```javascript
  resources/en-US.json
  {
    "stJamesWayInNavarre": "St. James' Way in Navarre",
    "spanish": "spanish",
    "basque": "basque",
    "english": "english"
  }
```
```javascript
  <div id="mapa"></div>
  <script>
    // Obtener el idioma de interfaz de usuario
    var selectedLocale = location.search.substr(location.search.indexOf("?lang=") + 6) || "es-ES";
    // Establecer un proxy porque se hacen peticiones a otro dominio.
    SITNA.Cfg.proxy = "proxy.ashx?";

    SITNA.Cfg.layout = "layout/example";
    var map = new SITNA.Map("mapa", {
      locale: selectedLocale
    });
  </script>
```


@property layout
@type string
@default "//sitna.tracasa.es/api/tc/layout/responsive"
 */
SITNA.Cfg.layout = TC.apiLocation + 'TC/layout/responsive';
/**
  Opciones de estilo de entidades geográficas.
  @property styles
  @type SITNA.cfg.StyleOptions
 */

/**
  Opciones de capa.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.LayerOptions
  @static
 */
/**
  Identificador único de capa.
  @property id
  @type string
 */
/**
  Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
  @property title
  @type string|undefined
 */
/**
  Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {{#crossLink "SITNA.consts.LayerType"}}{{/crossLink}}.
  @property type
  @type string|undefined
 */
/**
  URL del servicio OGC o del archivo de datos geográficos que define la capa. Propiedad obligatoria en capas de tipo
  {{#crossLink "SITNA.consts.LayerType/WMS:property"}}{{/crossLink}}, {{#crossLink "SITNA.consts.LayerType/WMTS:property"}}{{/crossLink}},
  {{#crossLink "SITNA.consts.LayerType/WFS:property"}}{{/crossLink}} y {{#crossLink "SITNA.consts.LayerType/KML:property"}}{{/crossLink}}. 
  
En las capas de tipo VECTOR los archivos de datos geográficos soportados son KML, GeoJSON, GPX, GML, WKT y TopoJSON.

  El formato se deduce de la extensión del nombre de archivo, pero también se puede especificar utilizando la propiedad {{#crossLink "SITNA.cfg.LayerOptions/format:property"}}{{/crossLink}}. 
  
  Puede consultar el ejemplo [online](../../examples/cfg.LayerOptions.url.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de tabla de contenidos en la primera posición.
      SITNA.Cfg.controls.TOC = {
        div: "slot1"
      };
      // Añadimos una capa raster desde un servicio WMS y cuatro capas vectoriales
      // a partir de archivos geográficos: GeoJSON, GPX, KML y GML.
      SITNA.Cfg.workLayers = [
        {
          id: "wms",
          title: "Camino de Santiago",
          type: SITNA.Consts.layerType.WMS,
          url: "//idena.navarra.es/ogc/wms",
          layerNames: "IDENA:PATRIM_Lin_CaminoSantR",
          format: SITNA.Consts.mimeType.PNG
        },
        {
          id: "geojson",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/PARQUESNATURALES.json",
          format: SITNA.Consts.mimeType.GEOJSON
        },
        {
          id: "gpx",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/CAMINOFRANCES.gpx"
        },
        {
          id: "kml",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/MUSEOSNAVARRA.kml"
        },
        {
          id: "gml",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/ESTACIONESTREN.gml"
        },
      ];
      var map = new SITNA.Map("mapa");
    </script>
```
  @property url
  @type string|undefined  
 */
/**
  Lista separada por comas de los nombres de capa del servicio OGC.
  @property layerNames
  @type string|undefined
 */
/**
  Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.
  @property matrixSet
  @type string|undefined
 */
/**
  En las capas de tipo {{#crossLink "SITNA.consts.LayerType/WMS:property"}}{{/crossLink}} y {{#crossLink "SITNA.consts.LayerType/WMTS:property"}}{{/crossLink}},
  es el tipo MIME del formato de archivo de imagen a obtener del servicio. En las capas de tipo {{#crossLink "SITNA.consts.LayerType/VECTOR:property"}}{{/crossLink}},
  es el tipo MIME del formato de archivo de datos geográficos que queremos cargar (GeoJSON, KML, etc.). 
  
Si esta propiedad no está definida, si la capa es un mapa de fondo (consultar propiedad {{#crossLink "SITNA.cfg.LayerOptions/isBase:property"}}{{/crossLink}}),
  se asume que el formato es `"image/jpeg"`, en caso contrario se asume que el formato es `"image/png"`. 
  @property format
  @type SITNA.consts.MimeType|undefined
 */
/**
  Si se establece a `true`, la capa se muestra por defecto si forma parte de los mapas de fondo.
  @property isDefault
  @type boolean|undefined
  @deprecated En lugar de esta propiedad es recomendable usar SITNA.Cfg.defaultBaseLayer.
 */
/**
  Si se establece a `true`, la capa es un mapa de fondo.
  @property isBase
  @type boolean|undefined
 */
/**
  Aplicable a capas de tipo WMS y KML. Si se establece a `true`, la capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
  @property hideTree
  @type boolean|undefined
 */
/**
  Si se establece a `true`, la capa no aparece en la tabla de contenidos ni en la leyenda. De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
  @property stealth
  @type boolean|undefined
 */
/**
  URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
  @property thumbnail
  @type string|undefined
 */
/**
  La capa agrupa sus entidades puntuales cercanas entre sí en grupos (clusters). Aplicable a capas de tipo VECTOR, WFS y KML. 

  Puede consultar el ejemplo [online](../../examples/cfg.LayerOptions.cluster.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Creamos un mapa con una capa de puntos de un KML,
      // clustering activado a 50 pixels y transiciones animadas.
      var map = new SITNA.Map("mapa", {
        workLayers: [
         {
           id: "cluster",
           type: SITNA.Consts.layerType.KML,
           url: "data/PromocionesViviendas.kml",
           title: 'Clusters',
           cluster: {
             distance: 50,
             animate: true
           }
         }
       ]
      });
    </script>
```
  @property cluster
  @type SITNA.cfg.ClusterOptions|undefined  
 */
///**
//  Propiedad que establece si deseamos que el título de la capa se oculte cuando esté cargada como capa de trabajo. La utilizan controles como
//  {{#crossLink "SITNA.cfg.MapControlOptions/layerCatalog:property"}}{{/crossLink}} para componer los elementos que la representan.
//  @property hideTitle
//  @type boolean|undefined
// */

/**
  Opciones de clustering de puntos de una capa, define si los puntos se tienen que agrupar cuando están más cerca entre sí que un valor umbral.
  
Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.ClusterOptions
  @static
 */
/**
  Distancia en píxels que tienen que tener como máximo los puntos entre sí para que se agrupen en un cluster.
  @property distance
  @type number
 */
/**
  Si se establece a `true`, los puntos se agrupan y desagrupan con una transición animada.
  @property animate
  @type boolean|undefined
 */
/**
  Opciones de estilo de los clusters.
  @property styles
  @type SITNA.cfg.ClusterStyleOptions|undefined
 */

/**
  Opciones de controles de mapa, define qué controles se incluyen en un mapa y qué opciones se pasan a cada control.
  
Las propiedades de esta clase son de tipo boolean, en cuyo caso define la existencia o no del control asociado, o una instancia de la clase {{#crossLink "SITNA.cfg.ControlOptions"}}{{/crossLink}}.

  Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.MapControlOptions
  @static
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador de espera de carga.
  @property loadingIndicator
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una barra de navegación con control de zoom.
  @property navBar
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una barra de escala.
  @property scaleBar
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador numérico de escala.
  @property scale
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un selector numérico de escala.
  @property scaleSelector
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un mapa de situación.
  @property overviewMap
  @type boolean|SITNA.cfg.OverviewMapOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un selector de mapas de fondo.
  @property basemapSelector
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene atribución. La atribución es un texto superpuesto al mapa que actúa como reconocimiento de la procedencia de los datos que se muestran.
  @property attribution
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una tabla de contenidos mostrando las capas de trabajo y los grupos de marcadores.
.* Los controles TOC y {{#crossLink "SITNA.cfg.MapControlOptions/workLayerManager:property"}}{{/crossLink}} realizan varias funciones comunes, así
  rara vez será necesario tener los dos a la vez en un visor. 
  @property TOC
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador de coordenadas y de sistema de referencia espacial.
  @property coordinates
  @type boolean|SITNA.cfg.CoordinatesOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene leyenda.
  @property legend
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa muestra los datos asociados a los marcadores cuando se pulsa sobre ellos.
  @property popup
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un buscador. El buscador localiza coordenadas y busca entidades geográficas tales como: municipios, cascos urbanos, vías, portales y parcelas catastrales de IDENA. Es posible establecer un origen de datos distinto a IDENA en el que buscar, consultar la sección: {{#crossLinkModule "2.3.1. Objeto de configuración de opciones del buscador"}}{{/crossLinkModule}} 
  @property search
  @type boolean|SITNA.cfg.SearchOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un medidor de longitudes, áreas y perímetros.
  @property measure
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un control que gestiona los clics del usuario en ellos. 
  @property click
  @type boolean|SITNA.cfg.ClickOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa puede abrir una ventana de Google StreetView. 
  @property streetView
  @type boolean|SITNA.cfg.StreetViewOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa responde a los clics con un información de las capas cargadas de tipo WMS. Se usa para ello la petición `getFeatureInfo` del standard WMS.

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.featureInfo.html).
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Añadimos el control featureInfo.
      SITNA.Cfg.controls.featureInfo = true;
      // Añadimos una capa WMS sobre la que hacer las consultas.
      SITNA.Cfg.workLayers = [
        {
          id: "terremotos",
          title: "Terremotos últimos 365 días",
          type: SITNA.Consts.layerType.WMS,
          url: "https://www.ign.es/wms-inspire/geofisica",
          layerNames: ["Ultimos365dias"]
        }
      ];
      var map = new SITNA.Map("mapa");
    </script>
```
  @property featureInfo
  @type boolean|SITNA.cfg.ClickOptions|undefined
  @default true  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra una herramienta para imprimir el mapa en PDF. 
  
El control permite al usuario elegir entre varios tamaños de hoja y orientación horizontal o vertical, además se le puede poner un título al documento de impresión. 

  Al pulsar el botón de imprimir se abre una previsualización como paso previo a la impresión. Ahí el usuario puede realizar unos últimos ajustes a la extensión del mapa.

  El PDF se generará al pulsar en el botón dentro de la previsualización. 

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.printMap.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de impresión en el primer contenedor.
      SITNA.Cfg.controls.printMap = {
        div: "slot1"
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property printMap
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para consultar y gestionar las capas de trabajo que están cargadas en el mapa. Con este control
  se dispone de las siguientes funcionalidades: 
  <ul>
    <li>Consultar qué capas están cargadas en el mapa</li>
    <li>Ver en qué orden están superpuestas y modificar ese orden</li>
    <li>Comprobar si una capa es visible al nivel de zoom actual</li>
    <li>Activar y desactivar la visibilidad de las capas</li>
    <li>Establecer el grado de transparencia de cada capa</li>
    <li>Borrar capas cargadas</li>
    <li>Consultar metadatos asociados a la capa</li>
  </ul>
  
Los controles workLayerManager y {{#crossLink "SITNA.cfg.MapControlOptions/TOC:property"}}{{/crossLink}} realizan varias funciones comunes, así
  rara vez será necesario tener los dos a la vez en un visor. 

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
#### Ejemplo:
````javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property workLayerManager
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para añadir datos externos, en concreto servicios WMS y archivos locales de datos geográficos. 

  Se pueden añadir WMS escribiendo la dirección del servicio o eligiendo un servicio de la lista de sugerencias de servicios de interés. 

  Se pueden añadir datos de archivos buscándolos en el cuadro de diálogo que se abre tras pulsar “Abrir archivo” o arrastrándolos y soltándolos dentro del área del mapa. 

  Puede consultar el ejemplo [online](../../examples/cfg.DataLoaderOptions.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Activamos el proxy para poder acceder a servicios de otro dominio.
      SITNA.Cfg.proxy = "proxy.ashx?";
      // Añadimos el control de tabla de contenidos en el primer contenedor.
      SITNA.Cfg.controls.TOC = {
        div: "slot1"
      };
      // Añadimos el control de datos externos en el segundo contenedor.
      SITNA.Cfg.controls.dataLoader = {
        div: "slot2",
        enableDragAndDrop: true,
        wmsSuggestions: [
          {
            group: "Estatales",
            items: [
              {
                name: "Mapa Base (IGN)",
                url: "https://www.ign.es/wms-inspire/ign-base"
              },
              {
                name: "Unidades Administrativas (IGN)",
                url: "https://www.ign.es/wms-inspire/unidades-administrativas"
              },
              {
                name: "Cartografía Topográfica (IGN)",
                url: "https://www.ign.es/wms-inspire/mapa-raster"
              },
              {
                name: "Ortofotos PNOA Máxima Actualidad (IGN)",
                url: "https://www.ign.es/wms-inspire/pnoa-ma"
              }
            ]
          },
          {
            group: "Comunidades limítrofes",
            items: [
              {
                name: "Aragón",
                url: "http://idearagon.aragon.es/Visor2D"
              },
              {
                name: "La Rioja",
                url: "https://ogc.larioja.org/wms/request.php"
              },
              {
                name: "País Vasco",
                url: "http://www.geo.euskadi.eus/WMS_KARTOGRAFIA"
              }
            ]
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property dataLoader
  @type boolean|SITNA.cfg.DataLoaderOptions|undefined
  @default false
  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para añadir capas de trabajo desde uno o varios servicios WMS. Con este control
  se dispone de las siguientes funcionalidades: 
  <ul>
    <li>Consultar las capas disponibles en uno o varios WMS.</li>
    <li>Buscar capas mediante texto libre. Se busca el texto en los títulos y los resúmenes descriptivos de cada capa, que se publican en el
    [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities") del servicio.</li>
    <li>Añadir capas al mapa como capas de trabajo.</li>
  </ul>

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property layerCatalog
  @type boolean|SITNA.cfg.LayerCatalogOptions|undefined
  @default false  
 */

/**
  Opciones de control.
  Esta clase no tiene constructor.
  @class SITNA.cfg.ControlOptions
  @static
 */
/**
  Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
  @property div
  @type HTMLElement|string|undefined
 */

/**
  Opciones de control de mapa de situación.
  Esta clase no tiene constructor.
  @class SITNA.cfg.OverviewMapOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Identificador de capa para usar como mapa de fondo u objeto de opciones de capa. 
  @property layer
  @type string|SITNA.cfg.LayerOptions
 */

/**
  Opciones de control de coordenadas.
  Esta clase no tiene constructor. 

  Puede consultar el ejemplo [online](../../examples/cfg.CoordinatesOptions.html). 
  @class SITNA.cfg.CoordinatesOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Determina si se muestran coordenadas geográficas (en EPSG:4326) además de las del mapa, que por defecto son UTM (EPSG:25830). 
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <script>
     // Hacemos que el control que muestra las coordenadas en pantalla
     // muestre también las coordenadas geográficas
     SITNA.Cfg.controls.coordinates = {
       showGeo: true
     };
     var map = new SITNA.Map('map');
    </script>
```
  @property showGeo
  @type boolean|undefined  
 */

/**
  Opciones de control de clic.
  
Esta clase no tiene constructor.

  Estas opciones se utilizan si se desea tener un control en el mapa que reaccione a los clic del ratón o los toques en el mapa. 

  Puede consultar el ejemplo [online](../../examples/cfg.ClickOptions.html). 
  @class SITNA.cfg.ClickOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Si se establece a `true`, el control asociado está activo, es decir, responde a los clics hechos en el mapa desde que se carga.
  @property active
  @type boolean|undefined
 */
/**
  Función de callback que gestiona la respuesta al clic. Es válida cualquier función que acepta un parámetro de coordenada, que es un array de dos números.
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <script>
     // Creamos un mapa con el control de gestión de clics, con una función de callback personalizada
     var map = new SITNA.Map("mapa", {
       controls: {
         click: {
           active: true,
           callback: function (coord) {
             alert("Has pulsado en la posición " + coord[0] + ", " + coord[1]);
           }
         }
       }
     });
    </script>
```  
@property callback
  @type function|undefined
  @default Una función que escribe en consola las coordenadas pulsadas  
 */

/**
  Opciones de control de Google StreetView.
  
Esta clase no tiene constructor.

  Para incrustar StreetView en el visor se utiliza la versión 3 de la API de Google Maps. Esta se carga automáticamente al instanciar el control. 

  Puede consultar el ejemplo [online](../../examples/cfg.StreetViewOptions.html). 
  @class SITNA.cfg.StreetViewOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Elemento del DOM en el que mostrar la vista de StreetView o valor de atributo id de dicho elemento.
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <div id="sv"/>
    <script>
      // Creamos un mapa con el control de StreetView.
      // La vista de StreetView se debe dibujar en el elemento con identificador "sv".
      // Se utilizará la clave de Google Maps para el SITNA.
      var map = new SITNA.Map("mapa", {
        controls: {
          streetView: {
            viewDiv: "sv",
            googleMapsKey: "AIzaSyDyXgqllcajbMjx8yQxEX28VgA9nQOhtCM"
          }
        }
      });
    </script>
```
  @property viewDiv
  @type HTMLElement|string|undefined
  
 */
/**
  El control de StreetView hace uso de la API de Google Maps para funcionar. Esta propiedad establece la clave de uso asociada al sitio
  donde está alojada la aplicación que usa la API SITNA. No es necesaria para hacer funcionar el control pero es recomendable obtener una para garantizar el servicio por parte de Google. 
  
Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key">).
  @property googleMapsKey
  @type string|undefined
 */

/**
  Opciones de control de búsquedas.
  Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.SearchOptions.html). 
#### Ejemplo:
  ```javascript      
        <script>
          // Creamos un mapa con el control de búsquedas. 
          // Configuramos el buscador desactivando la búsqueda de parcelas y la localización de coordenadas.
          // Indicamos un placeHolder y tooltip (propiedad "instructions") acorde con las búsquedas configuradas.
          var map = new SITNA.Map("mapa", {
            controls: {
              search: { 
                coordinates: false,
                cadastralParcel: false,
                municipality: true,
                town: true,
                street: true,
                postalAddress: true,
                placeHolder: "Municipio, casco urbano, calle o portal",
                instructions: "Buscar municipio, casco urbano, calle o portal"
              }
            }
          });
        </script> 
  ```
  @class SITNA.cfg.SearchOptions
  @extends SITNA.cfg.ControlOptions
  @static 
 */
/**
  Esta propiedad establece el atributo "placeHolder" del cajetín del buscador del mapa. 
  @property placeHolder
  @type string
  @default Municipio, casco urbano, calle, dirección… 
 */
/**
  Esta propiedad establece el atributo "title" del cajetín y del botón del buscador del mapa. 
  @property instructions
  @type string
  @default Buscar municipio, casco urbano, calle, dirección, referencia catastral, coordenadas UTM o latitud-longitud
 */
/**
  Esta propiedad activa/desactiva la localización de coordenadas en Sistema de Referencia ETRS89, bien UTM Huso 30 Norte (EPSG:25830) o latitud-longitud (EPSG:4258, EPSG:4326 o CRS:84) en el buscador del mapa. 
  @property coordinates
  @type boolean
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de municipios en el buscador del mapa. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchMunicipalitySource"}}{{/crossLink}}. 
  @property municipality
  @type boolean|SITNA.cfg.SearchMunicipalitySource
  @default true
 */

/**
  Esta propiedad activa/desactiva la búsqueda de cascos urbanos en el buscador del mapa. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchTownSource"}}{{/crossLink}}. 
  @property town
  @type boolean|SITNA.cfg.SearchTownSource
  @default true 
    
 */

/**
  Esta propiedad activa/desactiva la búsqueda de vías en el buscador del mapa. Formato: entidad de población, vía 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchStreetSource"}}{{/crossLink}}. 
  @property street
  @type boolean|SITNA.cfg.SearchStreetSource
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de direcciones postales en el buscador del mapa. Formato: entidad de población, vía, portal. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchPostalAddressSource"}}{{/crossLink}}. 
  @property postalAddress
  @type boolean|SITNA.cfg.SearchPostalAddressSource
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de parcelas catastrales en el buscador del mapa. Formato: municipio, polígono, parcela. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchCadastralSource"}}{{/crossLink}}. 
  @property cadastralParcel
  @type boolean|SITNA.cfg.SearchCadastralSource
  @default true 
 */

/**
  Opciones de control de catálogo de capas.

  Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
  @class SITNA.cfg.LayerCatalogOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Propiedad que establece si se puede buscar capas por texto. La búsqueda del texto se realiza en los títulos y los resúmenes descriptivos de cada capa, que se publican en el
  [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities") del servicio.
  @property enableSearch
  @type boolean|undefined
 */

/**
  Lista de objetos {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} que se corresponden con capas de servicios WMS que queremos añadir al catálogo.
  
En estos objetos, si se asigna un valor a la propiedad {{#crossLink "SITNA.cfg.LayerOptions/layerNames:property"}}{{/crossLink}}, solo las capas
  especificadas y sus hijas estarán disponibles para ser añadidas al mapa. Sin embargo, si esta propiedad se deja sin asignar, todas las capas publicadas
  en el servicio WMS estarán disponibles para ser añadidas. 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property layers
  @type Array
  @default []
  
 */

/**
  Opciones de control para añadir datos geográficos.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.DataLoaderOptions.html). 
  @class SITNA.cfg.DataLoaderOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Lista de grupos de sugerencias de servicios WMS ofrecidos por el control. Es un array de instancias de la clase {{#crossLink "SITNA.cfg.WMSGroupOptions"}}{{/crossLink}},
  que establece grupos de servicios WMS sugeridos. Por ejemplo se puede establecer un grupo de servicios WMS estatales y otro de servicios WMS mundiales.
  @property wmsSuggestions
  @type Array|undefined
 */
/**
  Propiedad que establece si está permitido arrastrar y soltar archivos al área del mapa, además de abrirlos de la manera convencional abriendo el cuadro de diálogo de búsqueda de archivos.
  @property enableDragAndDrop
  @type boolean|undefined
 */

/**
  Opciones de grupo de sugerencias de servicios externos WMS.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.WMSGroupOptions
  @static
 */
/**
  Nombre del grupo de sugerencias. Se mostrará como una sección en la lista de opciones del control.
  @property group
  @type String
 */
/**
  Lista de sugerencias de servicios externos WMS. Es un array de instancias de la clase {{#crossLink "SITNA.cfg.WMSOptions"}}{{/crossLink}}.
  @property items
  @type String
 */

/**
  Opciones de sugerencia de servicio externo WMS.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.WMSOptions
  @static
 */
/**
  Nombre del servicio WMS. Se mostrará como un elemento en la lista de opciones del control.
  @property name
  @type String
 */
/**
  URL de acceso al servicio WMS.
  @property url
  @type String
 */

/**
  Opciones de estilo de entidades geográficas.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.StyleOptions
  @static
 */
/**
  Opciones de estilo de marcador (punto de mapa con icono).
  @property marker
  @type SITNA.cfg.MarkerStyleOptions|undefined
 */
/**
  Opciones de estilo de punto.
  @property marker
  @type SITNA.cfg.PointStyleOptions|undefined
 */
/**
  Opciones de estilo de línea.
  @property line
  @type SITNA.cfg.LineStyleOptions|undefined
 */
/**
  Opciones de estilo de polígono.
  @property polygon
  @type SITNA.cfg.PolygonStyleOptions|undefined
 */
/**
  Opciones de estilo de cluster de puntos. Consultar SITNA.cfg.LayerOptions.{{#crossLink "SITNA.cfg.LayerOptions/cluster:property"}}{{/crossLink}}
  para saber cómo mostrar clusters.
  @property cluster
  @type SITNA.cfg.ClusterStyleOptions|undefined
 */

/**
  Opciones de estilo de marcador (punto de mapa con icono).
  
Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.MarkerStyleOptions
  @static
 */
/**
  Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo `background-image` asociado a la clase.
  @property classes
  @type Array
  @default ["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]
 */
/**
  Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono.
  @property anchor
  @type Array
  @default [.5, 1]
 */
/**
  Anchura en píxeles del icono.
  @property width
  @type number
  @default 32
 */
/**
  Altura en píxeles del icono.
  @property height
  @type number
  @default 32
 */

/**
  Opciones de estilo de línea. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.LineStyleOptions
  @static
 */
/**
  Color de trazo de la línea, representado en formato hex triplet (`"#RRGGBB"`).
  @property strokeColor
  @type string
  @default "#f00" en polígonos y líneas
 */
/**
  Anchura de trazo en píxeles de la línea.
  @property strokeWidth
  @type number
  @default 2 en polígonos y líneas
 */
/**
  Opacidad de trazo, valor de 0 a 1.
  @property strokeOpacity
  @type number
  @default 1 en polígonos y líneas
 */

/**
  Opciones de estilo de polígono. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.PolygonStyleOptions
  @extends SITNA.cfg.LineStyleOptions
  @static
 */
/**
  Color de relleno, representado en formato hex triplet (`"#RRGGBB"`).
  @property fillColor
  @type string
  @default "#000" en polígonos, "#336" en clusters
 */
/**
  Opacidad de relleno, valor de 0 a 1.
  @property fillOpacity
  @type number
  @default 0.3 en polígonos, 0.6 en clusters
 */

/**
  Opciones de estilo de punto. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.PointStyleOptions
  @extends SITNA.cfg.PolygonStyleOptions
  @static
 */
/**
  Colección de nombre de campo o campos de los cuales extraer el valor de la etiqueta.
  @property label
  @type string|undefined
  @default null
 */
/**
  Nombre del campo del cual extraer la rotación a aplicar a la etiqueta.
  @property angle
  @type string|undefined
  @default null
 */
/**
  Radio en pixels del símbolo que representa el punto.
  @property radius
  @type number|undefined
  @default 6 en puntos
 */
/**
  Color del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`"#RRGGBB"`).
  @property fontColor
  @type string|undefined
  @default "#fff" en clusters
 */
/**
  Color del contorno del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`"#RRGGBB"`).
  @property labelOutlineColor
  @type string|undefined
  @default null
 */
/**
  Anchura de trazo del contorno del texto de la etiqueta en píxeles.
  @property labelOutlineWidth
  @type number|undefined
  @default null
 */
/**
  Tamaño de fuente del texto de la etiqueta descriptiva del punto.
  @property fontSize
  @type number|undefined
  @default 9 en clusters
 */

/**
  Opciones de estilo de cluster de puntos. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.ClusterStyleOptions
  @static
 */
/**
  Opciones de estilo del punto que representa el cluster. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  
Puede consultar también el ejemplo [online](../../examples/cfg.ClusterStyleOptions.point.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Creamos un mapa con una capa vectorial,
      // clustering activado a 50 pixels y estilos personalizados.
      var map = new SITNA.Map("mapa", {
        workLayers: [
         {
           id: "cluster",
           type: SITNA.Consts.layerType.VECTOR,
           title: "Clusters",
           cluster: {
             distance: 50,
             styles: {
               point: {
                 fillColor: "#f90",
                 fillOpacity: 1,
                 strokeColor: "#c60",
                 strokeWidth: 2,
                 fontColor: "#f90"
               }
             }
           }
         }
       ]
      });

     map.loaded(function () {
       // Añadimos puntos aleatorios
       var extent = TC.Cfg.initialExtent;
       var dx = extent[2] - extent[0];
       var dy = extent[3] - extent[1];

       var randomPoint = function () {
         var x = extent[0] + Math.random()  dx;
         var y = extent[1] + Math.random()  dy;
         return [x, y];
       }

       for (var i = 0; i < 200; i++) {
         var point = randomPoint();
         map.addMarker(point, {
           layer: "cluster",
           data: {
             x: point[0],
             y: point[1]
           }
         });
       }
     });
    </script>
```
  @property point
  @type SITNA.cfg.PointStyleOptions|undefined  
 */

/**
  Opciones de marcador. El icono se obtiene de las propiedades {{#crossLink "SITNA.cfg.MarkerOptions/url:property"}}{{/crossLink}}, 
  {{#crossLink "SITNA.cfg.MarkerOptions/cssClass:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.MarkerOptions/group:property"}}{{/crossLink}}, por ese orden de preferencia. 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.MarkerOptions
  @extends SITNA.cfg.MarkerStyleOptions
  @static
 */
/**
  Nombre de grupo en el que incluir el marcador. Estos grupos se muestran en la tabla de contenidos y en la leyenda.

  Todos los marcadores pertenecientes al mismo grupo tienen el mismo icono. Los iconos se asignan automáticamente, rotando por la lista disponible en
  SITNA.cfg.MarkerStyleOptions.{{#crossLink "SITNA.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
  @property group
  @type string|undefined
 */
/**
  Nombre de clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
  @property cssClass
  @type string|undefined
 */
/**
  URL de archivo de imagen que se utilizará para el icono.
  @property url
  @type string|undefined
 */
/**
  Identificador de la capa vectorial a la que añadir el marcador.
  @property layer
  @type string|undefined
 */
/**
  Objeto de datos en pares clave/valor para mostrar cuando se pulsa sobre el marcador.
  @property data
  @type object|undefined
 */
/**
  Si se establece a `true`, al añadirse el marcador al mapa se muestra con el bocadillo de información asociada visible por defecto.
  @property showPopup
  @type boolean|undefined
 */

/*
  Búsqueda realizada de entidades geográficas en el mapa. Define el tipo de consulta y a qué capa afecta. 
  Esta clase no tiene constructor. 
  class SITNA.Search
  static
/*
  Tipo de consulta que se está realizando al mapa.
  property type
  type SITNA.consts.MapSearchType
 */
/*
  Capa del mapa sobre la que se hace la consulta.
  property layer
  type SITNA.consts.Layer
 */

/**
Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que el constructor es asíncrono, por tanto cualquier código
que haga uso de este objeto debería estar dentro de una función de callback pasada como parámetro al método {{#crossLink "SITNA.Map/loaded:method"}}{{/crossLink}}.

Las opciones de configuración del mapa son una combinación de las opciones de configuración global (definidas en {{#crossLink "SITNA.Cfg"}}{{/crossLink}}),
las opciones definidas por el {{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} que utilicemos, y las opciones pasadas como parámetro al
constructor. Estas opciones están ordenadas de menor a mayor prevalencia, de modo que por ejemplo una opción pasada como parámetro del constructor
siempre sobreescribirá una opción de la configuración global.

Puede consultar también online el [ejemplo 1](../../examples/Map.1.html), el [ejemplo 2](../../examples/Map.2.html) y el [ejemplo 3](../../examples/Map.3.html).
  #### Ejemplo 1:
```javascript
  <div id="mapa"/>
  <script>
    // Crear un mapa con las opciones por defecto.
    var map = new SITNA.Map("mapa");
  </script>
```
  #### Ejemplo 2:
```javascript
  <div id="mapa"/>
  <script>
    // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
    var map = new SITNA.Map("mapa", {
      crs: "EPSG:4326",
      initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      maxExtent: [
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      baselayerExtent: [
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      baseLayers: [
        SITNA.Consts.layer.IDENA_DYNBASEMAP
      ],
      defaultBaseLayer: SITNA.Consts.layer.IDENA_DYNBASEMAP,
      // Establecemos el mapa de situación con una capa compatible con WGS 84
      controls: {
        overviewMap: {
          layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
        }
      }
    });
  </script>
```
  #### Ejemplo 3:
```javascript
  <div id="mapa"></div>
  <script>
    // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
    var map = new SITNA.Map("mapa", {
      workLayers: [
        {
          id: "topo_mallas",
          title: "Toponimia y mallas cartográficas",
          type: SITNA.Consts.layerType.WMS,
          url: "//idena.navarra.es/ogc/wms",
          layerNames: "IDENA:TOPONI_Txt_Toponimos,IDENA:mallas"
        }
      ]
    });
  </script>
```

@class SITNA.Map
@constructor
@async
@param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
@param {object} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global {{#crossLink "SITNA.Cfg"}}{{/crossLink}}.
@param {string} [options.crs="EPSG:25830"] Código EPSG del sistema de referencia espacial del mapa. Por defecto es `"EPSG:25830"`.
@param {array} [options.initialExtent] Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. 
Esta opción es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver SITNA.Cfg.{{#crossLink "SITNA.Cfg/crs:property"}}{{/crossLink}}).

Para más información consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/initialExtent:property"}}{{/crossLink}}.
@param {array} [options.maxExtent] Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima. Para más información consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/maxExtent:property"}}{{/crossLink}}.
@param {string} [options.layout] URL de una carpeta de maquetación. Consultar la sección {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}} para ver instrucciones de uso de maquetaciones.
@param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. 
@param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. 
@param {string|number} [options.defaultBaseLayer] Identificador o índice en `baseLayers` de la capa base por defecto. 
@param {SITNA.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.
@param {SITNA.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geográficas.
@param {string} [options.locale="es-ES"] Código de idioma de la interfaz de usuario. Este código debe obedecer la sintaxis definida por la <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF</a>.
Los valores posibles son `"es-ES"`, `"eu-ES"` y `"en-US"`. Por defecto es `"es-ES"`.
@param {string} [options.crossOrigin] Valor del atributo `crossorigin` de las imágenes del mapa para  <a href="https://developer.mozilla.org/es/docs/Web/HTML/Imagen_con_CORS_habilitado">habilitar CORS</a>
Es necesario establecer esta opción para poder utilizar el método SITNA.Map.{{#crossLink "SITNA.Map/exportImage:method"}}{{/crossLink}}. 

Los valores soportados son `"anonymous"` y `"use-credentials"`.
@param {boolean} [options.mouseWheelZoom] Si se establece a `true`, la rueda del ratón se puede utilizar para hacer zoom en el mapa.
@param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver SITNA.Cfg.{{#crossLink "SITNA.Cfg/proxy:property"}}{{/crossLink}}).
 */

/*
  Búsqueda actual de consulta de entidad geográfica aplicado al mapa.
  property search
  type SITNA.Search|null
 */

SITNA.Map = function (div, options) {
    var map = this;

    // Por defecto en SITNA todas las búsquedas están habilitadas
    TC.Cfg.controls.search.allowedSearchTypes = TC.Util.extend(TC.Cfg.controls.search.allowedSearchTypes, {
        urban: {},
        street: {},
        number: {},
        cadastral: {}
    });

    if (options && options.controls && options.controls.search) {
        var keys = Object.keys(options.controls.search);

        var searchCfg = TC.Util.extend(options.controls.search, { allowedSearchTypes: {} });

        keys.forEach(function (key) {
            if (typeof (options.controls.search[key]) === "boolean" || TC.Util.isPlainObject(options.controls.search[key])) {
                if (options.controls.search[key]) {

                    switch (true) {
                        case (key === "postalAddress"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.NUMBER] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "cadastralParcel"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.CADASTRAL] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "town"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.URBAN] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        default:
                            searchCfg.allowedSearchTypes[key] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                    }
                }

                delete searchCfg[key];
            }
        });

        options.controls.search = searchCfg;
    }

    var tcMap = new TC.Map(div, options);
    var tcSearch;
    var tcSearchLayer;

    /**
    Añade una capa al mapa. Si se le pasa una instancia de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} como parámetro `layer`
    y tiene definida la propiedad SITNA.cfg.LayerOptions.{{#crossLink "SITNA.cfg.LayerOptions/url:property"}}{{/crossLink}}, establece por defecto
    el tipo de capa a {{#crossLink "SITNA.consts.LayerType/KML:property"}}{{/crossLink}} si la URL acaba en ".kml".
    
El tipo de la capa no puede ser {{#crossLink "SITNA.consts.LayerType/WFS:property"}}{{/crossLink}}.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.addLayer.1.html) y el [ejemplo 2](../../examples/Map.addLayer.2.html). 
  #### Ejemplo 1:
```javascript
      <div id="mapa"></div>
      <script>
        // Crear un mapa con las opciones por defecto.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
          // Añadir al mapa la capa de cartografía topográfica de IDENA
          map.addLayer(SITNA.Consts.layer.IDENA_CARTO);
        });
      </script>
```
  #### Ejemplo 2:
    ```javascript
      <div id="mapa"></div>
      <script>
        // Crear un mapa con las opciones por defecto.
        var map = new SITNA.Map("mapa");
  
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
          // Añadir al mapa un documento KML
          map.addLayer({
            id: "capa_kml",
            title: "Museos en Navarra",
            type: SITNA.Consts.layerType.KML,
            url: "data/MUSEOSNAVARRA.kml"
          });
        });
      </script>
```

    @method addLayer
    @async
    @param {string|SITNA.cfg.LayerOptions} layer Identificador de capa u objeto de opciones de capa.
    @param {function} [callback] Función a la que se llama tras ser añadida la capa.     
     */
    map.addLayer = function (layer, callback) {
        tcMap.addLayer(layer, callback);
    };

    /**
    Hace visible una capa como mapa de fondo. Esta capa debe existir previamente en la lista de mapas de fondo del mapa.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.setBaseLayer.1.html) y el [ejemplo 2](../../examples/Map.setBaseLayer.2.html).
#### Ejemplo 1:

```javascript
      <div id="mapa"></div>
      <script>
        // Crear mapa con opciones por defecto. Esto incluye la capa del catastro de Navarra entre los mapas de fondo.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado establecer como mapa de fondo visible el catastro de Navarra.
        map.loaded(function () {
          map.setBaseLayer(SITNA.Consts.layer.IDENA_CADASTER);
        });
      </script>
```
#### Ejemplo 2:
    ```javascript
      <div id="mapa"></div>
      <script>
        // Crear mapa con opciones por defecto.
        var map = new SITNA.Map("mapa");
        // Cuando el mapa esté cargado, añadir la ortofoto de 1956/1957 como mapa de fondo y establecerla como mapa de fondo visible.
        map.loaded(function () {
          map.addLayer({
            id: "orto_56_57",
            title: "Ortofoto de 1956/1957",
            url: "http://idena.navarra.es/ogc/wms",
            layerNames: "ortofoto_10000_1957",
            isBase: true
          }, function () {
            map.setBaseLayer("orto_56_57");
          });
        });
      </script>
```

    @method setBaseLayer
    @async
    @param {string|SITNA.cfg.LayerOptions} layer Identificador de capa u objeto de opciones de capa. 
    @param {function} [callback] Función al que se llama tras ser establecida la capa como mapa de fondo.    
     */
    map.setBaseLayer = function (layer, callback) {
        tcMap.setBaseLayer(layer, callback);
    };

    /**
    Añade un marcador (un punto asociado a un icono) al mapa.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.addMarker.1.html), el [ejemplo 2](../../examples/Map.addMarker.2.html),
    el [ejemplo 3](../../examples/Map.addMarker.3.html) y el [ejemplo 4](../../examples/Map.addMarker.4.html).

    #### Ejemplo 1:
    ```
    <div id="mapa"></div>
    <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador.
            map.addMarker([610749, 4741648]);
            // Centrar el mapa en el marcador.
            map.zoomToMarkers();
        });
    </script>
    ```
    #### Ejemplo 2:
    ```
    <div id="mapa"></div>
    <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir marcadores al grupo "Marcadores colgantes"
            // cuyo icono se ancle al punto en el centro hacia abajo.
            // Establecer un icono adecuado.
            var markerOptions = {
                group: "Marcadores colgantes",
                url: "data/colgante.png",
                anchor: [0.5, 0]
            };
            map.addMarker([610887, 4741244], markerOptions);
            map.addMarker([615364, 4657556], markerOptions);
            // Centrar el mapa en los marcadores.
            map.zoomToMarkers();
        });
    </script>
    ```
    #### Ejemplo 3:
    ```
    <div id="mapa"></div>
    <script>
        // Crear un mapa con una capa vectorial, centrado en la Ciudadela de Pamplona.
        var map = new SITNA.Map("mapa", {
            initialExtent: [
                609627,
                4740225,
                611191,
                4741395
            ],
            workLayers: [{
                id: "markers",
                title: "Marcadores geográficos",
                type: SITNA.Consts.layerType.VECTOR
            }]
        });
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador en la capa "markers",
            // asignarle un grupo para que salga en tabla de contenidos y leyenda.
            map.addMarker([610431, 4740837], {
                layer: "markers",
                group: "Ciudadela"
            });
        });
    </script>
    ```
    #### Ejemplo 4:
    ```
    <div id="mapa"></div>
    <script>
        // Añadir información emergente al mapa.
        SITNA.Cfg.controls.popup = true;

        // Crear un mapa.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador con un icono de 40x40 píxeles definido por la clase CSS kiosko.
            // Asignarle unos datos asociados que se muestren por defecto.
            map.addMarker([615366, 4657426], {
                cssClass: "kiosko",
                width: 40,
                height: 40,
                data: {
                    "Nombre": "Plaza de la Constitución, Tudela",
                    "Sitio web": "http://www.tudela.es/"
                },
                showPopup: true
            });
            // Centrar el mapa en el marcador.
            map.zoomToMarkers();
        });
    </script>
    ```
    @method addMarker
    @async
    @param {array} coords Coordenadas x e y del punto en las unidades del sistema de referencia del mapa.
    @param {object} [options] Objeto de opciones de marcador.
    @param {string} [options.group] Nombre de grupo en el que incluir el marcador. Estos grupos se muestran en la tabla de contenidos y en la leyenda.
  
    Todos los marcadores pertenecientes al mismo grupo tienen el mismo icono. Los iconos se asignan automáticamente, rotando por la lista disponible en
    SITNA.cfg.MarkerStyleOptions.{{#crossLink "SITNA.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
    @param {string} [options.cssClass] Nombre de clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
    @param {string} [options.url] URL de archivo de imagen que será el icono del marcador.
    @param {number} [options.width] Anchura en píxeles del icono del marcador.
    @param {number} [options.height] Altura en píxeles del icono del marcador.
    @param {array} [options.anchor] Coordenadas proporcionales (entre 0 y 1) del punto de anclaje del icono al punto del mapa. La coordenada (0, 0) es la esquina superior izquierda del icono.
    @param {object} [options.data] Objeto de datos en pares clave/valor para mostrar cuando se pulsa sobre el marcador. Si un valor es una URL, se mostrará como un enlace.
    @param {boolean} [options.showPopup] Si se establece a `true`, al añadirse el marcador al mapa se muestra con el bocadillo de información asociada visible por defecto.
    @param {string} [options.layer] Identificador de capa de tipo SITNA.consts.LayerType.{{#crossLink "SITNA.consts.LayerType/VECTOR:property"}}{{/crossLink}} en la que se añadirá el marcador. Si no se especifica se creará una capa específica para marcadores.
    
     */
    map.addMarker = function (coords, options) {
        tcMap.addMarker(coords, options);
    };

    /**
     Centra y escala el mapa a la extensión que ocupan todos sus marcadores.
  
     Puede consultar también el ejemplo [online](../../examples/Map.zoomToMarkers.html).
#### Ejemplo:
```javascript
       <div class="controls">
         <div><button id="addMarkerBtn">Añadir marcador aleatorio</button></div>
         <div><input type="number" step="1" id="pbrVal" value="30" /> <label for="pbrVal">pointBoundsRadius</label></div>
         <div><input type="number" step="0.1" id="emVal" value="0.2" /> <label for="emVal">extentMargin</label></div>
         <div><button id="zoomBtn">Hacer zoom a los marcadores</button></div>
       </div>
       <div id="mapa"></div>
       <script>
         // Crear mapa.
         var map = new SITNA.Map("mapa");
  
         // Añadir un marcador en un punto aleatorio
         var addRandomMarker = function () {
           var xmin = SITNA.Cfg.initialExtent[0];
           var ymin = SITNA.Cfg.initialExtent[1];
           var width = SITNA.Cfg.initialExtent[2] - SITNA.Cfg.initialExtent[0];
           var height = SITNA.Cfg.initialExtent[3] - SITNA.Cfg.initialExtent[1];
           map.addMarker([xmin + Math.random() width, ymin + Math.random() height]);
         };
  
         // Hacer zoom a los marcadores con las opciones elegidas
         var zoomToMarkers = function () {
           map.zoomToMarkers({
             pointBoundsRadius: parseInt(document.getElementById("pbrVal").value),
             extentMargin: parseFloat(document.getElementById("emVal").value)
           });
         };
  
         document.getElementById("addMarkerBtn").addEventListener("click", addRandomMarker);
         document.getElementById("zoomBtn").addEventListener("click", zoomToMarkers);
       </script>
```

     @method zoomToMarkers
     @param {object} [options] Objeto de opciones de zoom.
     @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del marcador que se respetará al hacer zoom. Por defecto es 30.
     @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas los marcadores.
     El valor es la relación de crecimiento en ancho y alto entre la extensión resultante y la original. Por ejemplo, el valor por defecto 0,2 indica un crecimiento del 20% de la extensión, 10% por cada lado.
     @async
     
     */
    map.zoomToMarkers = function (options) {
        tcMap.zoomToMarkers(options);
    };

    /**
    Añade una función de callback que se ejecutará cuando el mapa, sus controles y todas sus capas se hayan cargado.
#### Ejemplo:
```javascript
       // Notificar cuando se haya cargado el mapa.
       map.loaded(function () { 
         console.log("Código del mapa y de sus controles cargado, cargando datos...");
       });
```
    @method loaded
    @async
    @param {function} callback Función a la que se llama tras la carga del mapa.
    
    */
    map.loaded = function (callback) {
        tcMap.loaded(callback);
    };

    // Si existe el control featureInfo lo activamos.
    tcMap.loaded(function () {

        TC.loadJS(
          !TC.control.Search,
          TC.apiLocation + 'TC/control/Search',
          function () {
              tcSearch = new TC.control.Search();
              tcSearch.register(tcMap);

              tcSearch.getLayer().then(function (layer) {
                  tcSearchLayer = layer;
              });
          }
        );

        if (!tcMap.activeControl) {
            var fi = tcMap.getControlsByClass('TC.control.FeatureInfo')[0];
            if (fi) {
                fi.activate();
            }
        }
    });

    /*
      Obtiene los valores (id y label) de las entidades geográficas disponibles en la capa de IDENA que corresponda según el parámetro searchType. 
      Puede consultar también online el [ejemplo 1](../../examples/Map.getQueryableData.html). 
    
     method getQueryableData
     async
     param {string|SITNA.consts.MapSearchType} searchType Fuente de datos del cual obtendremos los valores disponibles para buscar posteriormente.
     param {function} [callback] Función a la que se llama tras obtener los datos.  
     example
        <div class="instructions divSelect">
            <div>
                Municipios
                <select id="municipality" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Concejos
                <select id="council" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Casco Urbano
                <select id="urban" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Manconmunidad
                <select id="commonwealth" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
            </div>
        </div>
        <div id="mapa"></div>
        <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        map.loaded(function () {
            // completamos el desplegable de municipios
            map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#municipality").appendChild(fragment);
            });

            // completamos el desplegable de concejos
            map.getQueryableData(SITNA.Consts.mapSearchType.COUNCIL, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#council").appendChild(fragment);
            });

            // completamos el desplegable de cascos urbanos
            map.getQueryableData(SITNA.Consts.mapSearchType.URBAN, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#urban").appendChild(fragment);
            });

            // completamos el desplegable de mancomunidades de residuos
            map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#commonwealth").appendChild(fragment);
            });
        });

        // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
        function applyFilter(target) {
            if (target) {
                var municipalitySelect = document.querySelector("#municipality");
                var councilSelect = document.querySelector("#council");
                var urbanSelect = document.querySelector("#urban");
                var commonwealthSelect = document.querySelector("#commonwealth");
                var id = target.querySelector('option:checked').value;
                var searchType;
                switch (true) {
                    case target.id == SITNA.Consts.mapSearchType.MUNICIPALITY:
                        searchType = SITNA.Consts.mapSearchType.MUNICIPALITY;

                        councilSelect.value = -1;
                        urbanSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.COUNCIL:
                        searchType = SITNA.Consts.mapSearchType.COUNCIL;

                        municipalitySelect.value = -1;
                        urbanSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.URBAN:
                        searchType = SITNA.Consts.mapSearchType.URBAN;

                        municipalitySelect.value = -1;
                        councilSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.COMMONWEALTH:
                        searchType = SITNA.Consts.mapSearchType.COMMONWEALTH;

                        municipalitySelect.value = -1;
                        councilSelect.value = -1;
                        urbanSelect.value = -1;
                        break;
                }

                if (id == -1)
                    map.removeSearch();
                else {
                    map.searchTyped(searchType, id, function (idQuery) {
                        if (idQuery == null) {
                            alert('No se han encontrado resultados');
                        }
                    });
                }
            }
        };
        </script>
    */
    map.getQueryableData = function (searchType, callback) {
        var queryable = tcSearch.availableSearchTypes[searchType];

        if (queryable.queryableData) {
            if (callback)
                callback(queryable.queryableData);
        } else {
            var params = {
                request: 'GetFeature',
                service: 'WFS',
                typename: queryable.featurePrefix + ':' + queryable.featureType,
                version: queryable.version,
                propertyname: (!(queryable.dataIdProperty instanceof Array) ? [queryable.dataIdProperty] : queryable.dataIdProperty)
                        .concat((!(queryable.outputProperties instanceof Array) ? [queryable.outputProperties] : queryable.outputProperties)).join(','),
                outputformat: TC.Consts.format.JSON
            };

            var url = queryable.url + '?' + TC.Util.getParamString(params);
            TC.ajax({
                url: url,
                responseType: TC.Consts.mimeType.JSON
            }).then(function (response) {
                const responseData = response.data;
                queryable.queryableData = [];

                if (responseData.features) {
                    var features = responseData.features;

                    for (var i = 0; i < features.length; i++) {
                        var f = features[i];
                        var data = {};

                        data.id = [];
                        if (!(queryable.dataIdProperty instanceof Array))
                            queryable.dataIdProperty = [queryable.dataIdProperty];

                        for (var ip = 0; ip < queryable.dataIdProperty.length; ip++) {
                            if (f.properties.hasOwnProperty(queryable.dataIdProperty[ip])) {
                                data.id.push(f.properties[queryable.dataIdProperty[ip]]);
                            }
                        }

                        data.id = queryable.idPropertiesIdentifier ? data.id.join(queryable.idPropertiesIdentifier) : data.id.join('');

                        data.label = [];
                        if (!(queryable.outputProperties instanceof Array))
                            queryable.outputProperties = [queryable.outputProperties];

                        for (var lbl = 0; lbl < queryable.outputProperties.length; lbl++) {
                            if (f.properties.hasOwnProperty(queryable.outputProperties[lbl])) {
                                data.label.push(f.properties[queryable.outputProperties[lbl]]);
                            }
                        }

                        var add = (data.label instanceof Array && data.label.join('').trim().length > 0) || (!(data.label instanceof Array) && data.label.trim().length > 0);
                        data.label = queryable.outputFormatLabel ? queryable.outputFormatLabel.tcFormat(data.label) : data.label.join('-');

                        if (add)
                            queryable.queryableData.push(data);
                    }
                }

                queryable.queryableData = queryable.queryableData.sort(function (a, b) {
                    if (queryable.idPropertiesIdentifier ? a.id.indexOf(queryable.idPropertiesIdentifier) == -1 : false) {
                        if (tcSearch.removePunctuation(a.label) < tcSearch.removePunctuation(b.label))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label) > tcSearch.removePunctuation(b.label))
                            return 1;
                        else
                            return 0;
                    } else {
                        if (tcSearch.removePunctuation(a.label.split(' ')[0]) < tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label.split(' ')[0]) > tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return 1;
                        else
                            return 0;
                    }
                });
                queryable.queryableData = queryable.queryableData.filter(function (value, index, arr) {
                    if (index < 1)
                        return true;
                    else
                        return value.id !== arr[index - 1].id && value.label !== arr[index - 1].label;
                });

                if (callback)
                    callback(queryable.queryableData);
            });
        }
    };
    /**
    Obtiene los valores (id y label) de los municipios disponibles en la capa de IDENA.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.getMunicipalities.html).
#### Ejemplo:  
```javascript
    <div class="instructions divSelect">
        <div>
            Municipios
            <select id="municipality" onchange="applyFilter()">
                <option value="-1">Seleccione...</option>
            </select>

        </div>
    </div>
    <div id="mapa"></div>
    <script>
    // Crear mapa.
    var map = new SITNA.Map("mapa");

    map.loaded(function () {
        // completamos el desplegable
        map.getMunicipalities(function (data) {
            var fragment = document.createDocumentFragment();
            data.forEach(function (value) {
                var option = document.createElement("option");
                option.setAttribute("value", value.id);
                option.textContent = value.label;
                fragment.appendChild(option);
            });
            document.querySelector("#municipality").appendChild(fragment);
        });
    });

    // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
    function applyFilter() {
        var id = document.querySelector("#council").querySelector("option:checked").value;
        if (id == -1)
            map.removeSearch();
        else {
            map.searchMunicipality(id, function (idQuery) {
                if (idQuery == null) {
                    alert("No se han encontrado resultados");
                }
            });
        }
    };
    </script>
```

    @method getMunicipalities
    @async  
    @param {function} [callback] Función a la que se llama tras obtener los datos.
    
    */
    map.getMunicipalities = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, callback);
    };
    /**
    Obtiene los valores (id y label) de los cascos urbanos disponibles en la capa de IDENA.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.getUrbanAreas.html).
#### Ejemplo:
```javascript
    <div class="instructions divSelect">
        <div>
            Cascos urbanos
            <select id="urban" onchange="applyFilter()">
                <option value="-1">Seleccione...</option>
            </select>

        </div>
    </div>
    <div id="mapa"></div>
    <script>
    // Crear mapa.
    var map = new SITNA.Map("mapa");

    map.loaded(function () {
        // completamos el desplegable
        map.getUrbanAreas(function (data) {
            var fragment = document.createDocumentFragment();
            data.forEach(function (value) {
                var option = document.createElement("option");
                option.setAttribute("value", value.id);
                option.textContent = value.label;
                fragment.appendChild(option);
            });
            document.querySelector("#urban").appendChild(fragment);
        });
    });

    // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
    function applyFilter() {
        var id = document.querySelector("#urban").querySelector("option:checked").value;
        if (id == -1)
            map.removeSearch();
        else {
            map.searchUrbanArea(id, function (idQuery) {
                if (idQuery == null) {
                    alert('No se han encontrado resultados');
                }
            });
        }
    };
    </script>
```

    @method getUrbanAreas
    @async  
    @param {function} [callback] Función a la que se llama tras obtener los datos.  
    
    */
    map.getUrbanAreas = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.URBAN, callback);
    };
    /**
    Obtiene los valores (id y label) de las mancomunidades de residuos disponibles en la capa de IDENA. 
      
    Puede consultar también online el [ejemplo 1](../../examples/Map.getCommonwealths.html). 
#### Ejemplo:
```javascript
    <div class="instructions divSelect">
        <div>
            Mancomunidades de residuos
            <select id="commonwealths" onchange="applyFilter()">
                <option value="-1">Seleccione...</option>
            </select>
        </div>
    </div>
    <div id="mapa"></div>
    <script>
    // Crear mapa.
    var map = new SITNA.Map("mapa");

    map.loaded(function () {
        // completamos el desplegable
        map.getCommonwealths(function (data) {
            var fragment = document.createDocumentFragment();
            data.forEach(function (value) {
                var option = document.createElement("option");
                option.setAttribute("value", value.id);
                option.textContent = value.label;
                fragment.appendChild(option);
            });
            document.querySelector("#commonwealths").appendChild(fragment);
        });
    });

    // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
    function applyFilter() {
        var id = document.querySelector("#commonwealths").querySelector("option:checked").value;
        if (id == -1)
            map.removeSearch();
        else {
            map.searchCommonwealth(id, function (idQuery) {
                if (idQuery == null) {
                    alert("No se han encontrado resultados");
                }
            });
        }
    };
    </script>
```    

     @method getCommonwealths
     @async  
     @param {function} [callback] Función a la que se llama tras obtener los datos.  
     
    */
    map.getCommonwealths = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, callback);
    };
    /**
    Obtiene los valores (id y label) de los concejos disponibles en la capa de IDENA. 
       
    Puede consultar también online el [ejemplo 1](../../examples/Map.getCouncils.html). 
#### Ejemplo:    
```javascript
    <div class="instructions divSelect">
        <div>
            Concejos
            <select id="council" onchange="applyFilter()">
                <option value="-1">Seleccione...</option>
            </select>
        </div>
    </div>
    <div id="mapa"></div>
    <script>
    // Crear mapa.
    var map = new SITNA.Map("mapa");

    map.loaded(function () {
        // completamos el desplegable
        map.getCouncils(function (data) {
            var fragment = document.createDocumentFragment();
            data.forEach(function (value) {
                var option = document.createElement("option");
                option.setAttribute("value", value.id);
                option.textContent = value.label;
                fragment.appendChild(option);
            });
            document.querySelector("#council").appendChild(fragment);
        });
    });

    // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
    function applyFilter() {
        var id = document.querySelector("#council").querySelector("option:checked").value;
        if (id == -1)
            map.removeSearch();
        else {
            map.searchCouncil(id, function (idQuery) {
                if (idQuery == null) {
                    alert("No se han encontrado resultados");
                }
            });
        }
    };
    </script>
```

      @method getCouncils
      @async  
      @param {function} [callback] Función a la que se llama tras obtener los datos.  
     
     */
    map.getCouncils = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COUNCIL, callback);
    };
    /**
        Busca la mancomunidad de residuos y pinta en el mapa la entidad geográfica encontrada que corresponda al identificador indicado.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchCommonwealth.html). 
#### Ejemplo:
```javascript
            <div class="instructions searchCommonwealth">    
              <div><button id="searchPamplonaBtn">Buscar Mancomunidad de la Comarca de Pamplona</button></div>    
            </div>
            <div id="mapa"></div>
            <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchPamplonaBtn").addEventListener("click", search);
              });
      
              var search = function () {
                map.removeSearch();
                map.searchCommonwealth("8", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado la mancomunidad con código 8.");
                  }
                });
              };
            </script>
```      

       @method searchCommonwealth
       @async
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      */

    map.searchCommonwealth = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COMMONWEALTH, id, callback);
    };
    /**
        Busca el concejo que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchCouncil.html). 
#### Ejemplo:     
```javascript
             <div class="instructions search">    
              <div><button id="searchBtn">Buscar concejo Esquíroz (Galar)</button></div>    
             </div>
             <div id="mapa"></div>
             <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
     
              var search = function () {
                map.removeSearch();
                map.searchCouncil("109#5", function (idQuery) {
                  if (idQuery == null) {
                      alert("No se ha encontrado el concejo con código 109#5.");
                  }
                });
              };    
             </script>    
```

       @method searchCouncil
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchCouncil = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COUNCIL, id, callback);
    };
    /**
        Busca el casco urbano que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchUrbanArea.html). 
#### Ejemplo:
```javascript
            <div class="instructions search">
            <div><button id="searchBtn">Buscar casco urbano de Arbizu</button></div>
            </div>
            <div id="mapa"></div>
            <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
              var search = function () {
                map.removeSearch();
                map.searchUrbanArea("27", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado el casco urbano con código 27.");
                  }
                });
              };
            </script>
```     

       @method searchUrbanArea
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchUrbanArea = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.URBAN, id, callback);
    };
    /**
        Busca el municipio que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchMunicipality.html). 
#### Ejemplo:     
```javascript
             <div class="instructions search">
              <div><button id="searchBtn">Buscar Arbizu</button></div>
             </div>
             <div id="mapa"></div>
             <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
     
              var search = function () {
                 map.removeSearch();
                 map.searchMunicipality("27", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado el municipio con código 27.");
                  }
                 });
              };
             </script>
```

       @method searchMunicipality
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchMunicipality = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.MUNICIPALITY, id, callback);
    };
    // Busca en la configuración que corresponda según el parámetro searchType el identificador pasado como parámetro
    map.searchTyped = function (searchType, id, callback) {
        var idQuery = TC.getUID();
        var query = tcSearch.availableSearchTypes[searchType];

        if (id instanceof Array && query.goToIdFormat)
            id = query.goToIdFormat.tcFormat(id);

        tcSearch._search.data = tcSearch._search.data || [];
        tcSearch._search.data.push({
            dataLayer: query.featureType,
            dataRole: searchType,
            id: id,
            label: "",
            text: ""
        });

        map.removeSearch();

        if (tcSearch.availableSearchTypes[searchType] && !tcSearch.getSearchTypeByRole(searchType)) {

            if (!tcSearch.availableSearchTypes[searchType].goTo) {
                tcSearch.availableSearchTypes[searchType].goTo = function (id) {
                    var getProperties = function (id) {

                        if (!TC.filter) {
                            TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                        }

                        var filter = [];
                        if (query.idPropertiesIdentifier) id = id.split(query.idPropertiesIdentifier);
                        if (!(id instanceof Array)) id = [id];
                        for (var i = 0; i < query.dataIdProperty.length; i++) {
                            filter.push(
                              new TC.filter.equalTo(query.dataIdProperty[i], id[i].trim())
                            );
                        }

                        if (filter.length > 1) {
                            filter = new TC.filter.and(filter);
                        } else {
                            filter = filter[0];
                        }

                        return filter;
                    };
                    var properties = getProperties(id);

                    return {
                        params: {
                            type: TC.Consts.layerType.WFS,
                            url: this.url,
                            version: this.version,
                            geometryName: this.geometryName,
                            featurePrefix: this.featurePrefix,
                            featureType: this.featureType,
                            properties: properties,
                            outputFormat: this.outputFormat,
                            styles: this.styles
                        }
                    };
                }.bind(query);
            }

            tcSearch.addAllowedSearchType(searchType, tcSearch.availableSearchTypes[searchType], tcSearch);
        }

        tcMap.one(TC.Consts.event.SEARCHQUERYEMPTY, function (e) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        });

        tcMap.one(TC.Consts.event.FEATURESADD, function (e) {
            if (e.layer == tcSearchLayer && e.layer.features && e.layer.features.length > 0)
                tcMap.zoomToFeatures(e.layer.features);

            map.search = {
                layer: e.layer, type: searchType
            };

            if (callback)
                callback(e.layer.id !== idQuery ? e.layer.id : idQuery);
        });

        tcSearch.goToResult(id, searchType);
    };
    /**
          Busca y pinta en el mapa la entidad geográfica encontrada correspondiente al identificador establecido.
          
Puede consultar también online el [ejemplo 1](../../examples/Map.searchFeature.html). 
#### Ejemplo:       
```javascript
              <div class="instructions query">
                 <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
                 <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
                 <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
                 <div><button id="searchBtn">Buscar</button></div>
                 <div><button id="removeBtn">Eliminar filtro</button></div>
               </div>
               <div id="mapa"></div>
               <script>
                 // Crear mapa.
                  var map = new SITNA.Map("mapa");
                 
                  map.loaded(function () {
                    document.getElementById("searchBtn").addEventListener("click", search);
                    document.getElementById("removeBtn").addEventListener("click", remove);
                  });
                  
                  var search = function () {
                    var capa = document.getElementById("capa").value;
                    capa = capa.trim();
                 
                    var campo = document.getElementById("campo").value;
                    campo = campo.trim();
                 
                    var valor = document.getElementById("valor").value;
                    valor = valor.trim();
                 
                    map.searchFeature(capa, campo, valor, function (idQuery) {
                      if (idQuery == null) {
                        alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
                      }
                    });
                  };
                 
                  // Limpiar el mapa 
                  var remove = function () {
                    map.removeSearch();
                  };
               </script>
```

         @method searchFeature
         @async
         @param {string} layer Capa de IDENA en la cual buscar.
         @param {string} field Campo de la capa de IDENA en el cual buscar.
         @param {string} id Identificador de la entidad geográfica por el cual filtrar.
         @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
         
     */
    map.searchFeature = function (layer, field, id, callback) {
        var idQuery = TC.getUID();
        var prefix = tcSearch.featurePrefix;

        map.removeSearch();

        layer = (layer || '').trim(); field = (field || '').trim(); id = (id || '').trim();
        if (layer.length == 0 || field.length == 0 || id.length == 0) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        } else {

            if (layer.indexOf(':') > -1) {
                prefix = layer.split(':')[0];
                layer = layer.split(':')[1];
            }

            var transformFilter = function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }

            var layerOptions = {
                id: idQuery,
                type: SITNA.Consts.layerType.WFS,
                url: tcSearch.url,
                version: tcSearch.version,
                stealth: true,
                geometryName: 'the_geom',
                featurePrefix: prefix,
                featureType: layer,
                maxFeatures: 1,
                properties: transformFilter([{
                    name: field, value: id, type: TC.Consts.comparison.EQUAL_TO
                }]),
                outputFormat: TC.Consts.format.JSON
            };

            var tcSrchGenericLayer;
            tcMap.addLayer(layerOptions).then(function (layer) {
                tcSrchGenericLayer = layer;

                map.search = {
                    layer: layer, type: SITNA.Consts.mapSearchType.GENERIC
                };
            });

            tcMap.on(TC.Consts.event.FEATURESADD, function (e) {
                const layer = e.layer;
                if (layer == tcSrchGenericLayer && layer.features && layer.features.length > 0) {

                    for (var i = 0; i < layer.features.length; i++) {
                        if (layer.features[i].showsPopup != tcSearch.queryableFeatures)
                            layer.features[i].showsPopup = tcSearch.queryableFeatures;
                    }

                    tcMap.zoomToFeatures(layer.features);
                }
            });

            tcMap.on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                const newData = e.newData;
                if (layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0)
                    tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                        type: TC.Consts.msgType.INFO, duration: 5000
                    });

                if (callback)
                    callback(layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0 ? null : idQuery);
            });
        }
    };
    /**
       Elimina del mapa la entidad geográfica encontrada. 
       
Puede consultar también online el [ejemplo 1](../../examples/Map.removeSearch.html). 
#### Ejemplo:    
```javascript
        <div class="instructions query">
           <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
           <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
           <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
           <div><button id="searchBtn">Buscar</button></div>
           <div><button id="removeBtn">Eliminar filtro</button></div>
         </div>
         <div id="mapa"></div>
         <script>
           // Crear mapa.
           var map = new SITNA.Map("mapa");
    
           map.loaded(function () {
             document.getElementById("addFilterBtn").addEventListener("click", addFilter);
             document.getElementById("removeFilterBtn").addEventListener("click", removeFilter);
           });
    
           // Establecer como filtro del mapa el municipio Valle de Egüés
           var addFilter = function () {
             var capa = document.getElementById("capa").value;
             capa = capa.trim();
    
            var campo = document.getElementById("campo").value;
             campo = campo.trim();
    
             var valor = document.getElementById("valor").value;
             valor = valor.trim();
        
             map.searchFeature(capa, campo, valor, function (idQuery) {
               if (idQuery == null) {
                 alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
               }
             });
           };
          
           // Limpiar el mapa del filtro
           var remove = function () {
             map.removeSearch();
           };
         </script>
```

      @method removeSearch
      @async   
      @param {function} [callback] Función a la que se llama tras eliminar la entidad geográfica.  
      
     */
    map.removeSearch = function (callback) {
        if (map.search) {
            if (!tcSearch.availableSearchTypes[map.search.type] || !tcSearch.availableSearchTypes[map.search.type].hasOwnProperty('goTo')) {
                tcMap.removeLayer(map.search.layer).then(function () {
                    map.search = null;
                });
            } else {
                for (var i = 0; i < map.search.layer.features.length; i++) {
                    map.search.layer.removeFeature(map.search.layer.features[i]);
                }
                map.search = null;
            }
        }

        if (callback)
            callback();
    };

    /**
      Exporta el mapa a una imagen PNG. Para poder utilizar este método hay que establecer la opción `crossOrigin` al instanciar {{#crossLink "SITNA.Map"}}{{/crossLink}}. 
      
Puede consultar también el ejemplo [online](../../examples/Map.exportImage.html).
#### Ejemplo:    
```javascript
                <div id="controls" class="controls">
                   <button id="imageBtn">Exportar imagen</button>
                </div>
                 <div id="mapa"></div>
                 <script>
                   // Crear un mapa con la opción de imágenes CORS habilitada.
                   var map = new SITNA.Map("mapa", { crossOrigin: "anonymous" });
    
                   var exportImage = function () {
                     var dataUrl = map.exportImage();
                     var image = document.createElement("img");
                     image.setAttribute("src", dataUrl);
                     image.style.width = '25vw';
                     var div = document.createElement("div");
                     div.appendChild(image);
                     document.getElementById("controls").appendChild(div);
                   };
          
                   document.getElementById("imageBtn").addEventListener("click", exportImage);
                 </script>
```
      @method exportImage
      @return {String} Imagen en un [data URI](https://developer.mozilla.org/es/docs/Web/HTTP/Basics_of_HTTP/Datos_URIs).
     */
    map.exportImage = function () {
        return tcMap.exportImage();
    };

    map.search = null;
};

/**
Cuando se instancia un mapa, se carga una maquetación que establece qué datos se cargan, qué controles y en que distribución se muestran, y qué estilo
va a tener el visor. La API SITNA tiene una maquetación definida por defecto, pero esto se puede cambiar utilizando la opción
{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}}:
#### Ejemplo:
```javascript
var map = new SITNA.Map("mapa", {
  layout: "layouts/mylayout"
});
```

El valor de esa opción es una ruta a una carpeta, donde se encontrarán todos o alguno de los siguientes archivos:

- `markup.html`, con la plantilla HTML que se inyectará en el elemento del DOM del mapa.
- `config.json`, con un objeto JSON que sobreescribirá propiedades de {{#crossLink "SITNA.Cfg"}}{{/crossLink}}.
- `style.css`, para personalizar el estilo del visor y sus controles.
- `script.js`, para añadir lógica nueva. Este es el lugar idóneo para la lógica de la nueva interfaz definida por el marcado inyectado con `markup.html`.
- `resources/*.json`, donde `*` es el código IETF del idioma que tendrá la interfaz de usuario, por ejemplo `resources/es-ES.json`.
 Si se van a soportar varios idiomas hay que preparar un archivo por idioma. Para saber cómo establecer un idioma de interfaz de usuario, consultar
 la opción `locale` del constructor de {{#crossLink "SITNA.Map"}}{{/crossLink}}.

La maquetación por defecto añade los siguientes controles al conjunto por defecto: {{#crossLink "SITNA.cfg.MapControlOptions/navBar:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/basemapSelector:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/TOC:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/legend:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/scaleBar:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/search:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/streetView:property"}}{{/crossLink}}
, {{#crossLink "SITNA.cfg.MapControlOptions/measure:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/overviewMap:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.MapControlOptions/popup:property"}}{{/crossLink}}.
Puede [descargar la maquetación por defecto](../../tc/layout/responsive/responsive.zip).

### Soporte multiidioma

La API soporta actualmente tres idiomas: castellano, euskera e inglés. Para saber cómo establecer un idioma de interfaz de usuario, consultar la opción
`locale` del constructor de {{#crossLink "SITNA.Map"}}{{/crossLink}}. Los textos específicos para cada idioma se guardan en archivos `*.json`,
donde `*` es el código IETF del idioma de la interfaz de usuario, dentro de la subcarpeta resources en la dirección donde se aloja la API SITNA.
Por ejemplo, los textos en castellano se guardan en `resources/es-ES.json`. Estos archivos contienen un diccionario en formato JSON de pares clave/valor,
siendo la clave un identificador único de cadena y el valor el texto en el idioma elegido.

Para añadir soporte multiidioma a la maquetación, hay que crear un archivo de recursos de texto para cada idioma soportado y colocarlo en la subcarpeta
`resources` dentro de la carpeta de maquetación. Este diccionario se combinará con el diccionario de textos propio de la API.

Por otro lado, la plantilla contenida en `markup.html` puede tener identificadores de cadena de texto entre dobles llaves. La API
sustituirá estos textos por los valores del diccionario correspondiente al idioma de la interfaz de usuario.

Finalmente, hay que activar el soporte multiidioma añadiendo a config.json una clave `"i18n": true`.

@module 2. Configuración
@submodule 2.2. Maquetación
 */

/**
Al instanciar {{#crossLink "SITNA.Map"}}{{/crossLink}} se le puede pasar como parámetro un objeto de opciones con la estructura de la clase [SITNA.Cfg](../classes/SITNA.Cfg.html):
#### Ejemplo:
```javascript
var map = new SITNA.Map("mapa", {
  crs: "EPSG:4326",
  initialExtent: [
    -2.84820556640625,
    41.78912492257675,
    -0.32135009765625,
    43.55789822064767
  ]
});
```
@module 2. Configuración
@submodule 2.1. Parámetros del constructor
 */

