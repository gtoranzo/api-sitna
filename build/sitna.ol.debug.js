/*! dustjs-linkedin - v2.7.1
* http://dustjs.com/
* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */
(function (root, factory) {
  /*global define*/
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define('dust.core', [], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.dust = factory();
  }
}(this, function() {
  var dust = {
        "version": "2.7.1"
      },
      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',
      EMPTY_FUNC = function() {};

  dust.config = {
    whitespace: false,
    amd: false,
    cjs: false,
    cache: true
  };

  // Directive aliases to minify code
  dust._aliases = {
    "write": "w",
    "end": "e",
    "map": "m",
    "render": "r",
    "reference": "f",
    "section": "s",
    "exists": "x",
    "notexists": "nx",
    "block": "b",
    "partial": "p",
    "helper": "h"
  };

  (function initLogging() {
    /*global process, console*/
    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },
        consoleLog,
        log;

    if (typeof console !== 'undefined' && console.log) {
      consoleLog = console.log;
      if(typeof consoleLog === 'function') {
        log = function() {
          consoleLog.apply(console, arguments);
        };
      } else {
        log = function() {
          consoleLog(Array.prototype.slice.apply(arguments).join(' '));
        };
      }
    } else {
      log = EMPTY_FUNC;
    }

    /**
     * Filters messages based on `dust.debugLevel`.
     * This default implementation will print to the console if it exists.
     * @param {String|Error} message the message to print/throw
     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
     * @public
     */
    dust.log = function(message, type) {
      type = type || INFO;
      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
        log('[DUST:' + type + ']', message);
      }
    };

    dust.debugLevel = NONE;
    if(typeof process !== 'undefined' && process.env && /\bdust\b/.test(process.env.DEBUG)) {
      dust.debugLevel = DEBUG;
    }

  }());

  dust.helpers = {};

  dust.cache = {};

  dust.register = function(name, tmpl) {
    if (!name) {
      return;
    }
    tmpl.templateName = name;
    if (dust.config.cache !== false) {
      dust.cache[name] = tmpl;
    }
  };

  dust.render = function(nameOrTemplate, context, callback) {
    var chunk = new Stub(callback).head;
    try {
      load(nameOrTemplate, chunk, context).end();
    } catch (err) {
      chunk.setError(err);
    }
  };

  dust.stream = function(nameOrTemplate, context) {
    var stream = new Stream(),
        chunk = stream.head;
    dust.nextTick(function() {
      try {
        load(nameOrTemplate, chunk, context).end();
      } catch (err) {
        chunk.setError(err);
      }
    });
    return stream;
  };

  /**
   * Extracts a template function (body_0) from whatever is passed.
   * @param nameOrTemplate {*} Could be:
   *   - the name of a template to load from cache
   *   - a CommonJS-compiled template (a function with a `template` property)
   *   - a template function
   * @param loadFromCache {Boolean} if false, don't look in the cache
   * @return {Function} a template function, if found
   */
  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {
    if(!nameOrTemplate) {
      return;
    }
    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {
      // Sugar away CommonJS module templates
      return nameOrTemplate.template;
    }
    if(dust.isTemplateFn(nameOrTemplate)) {
      // Template functions passed directly
      return nameOrTemplate;
    }
    if(loadFromCache !== false) {
      // Try loading a template with this name from cache
      return dust.cache[nameOrTemplate];
    }
  }

  function load(nameOrTemplate, chunk, context) {
    if(!nameOrTemplate) {
      return chunk.setError(new Error('No template or template name provided to render'));
    }

    var template = getTemplate(nameOrTemplate, dust.config.cache);

    if (template) {
      return template(chunk, Context.wrap(context, template.templateName));
    } else {
      if (dust.onLoad) {
        return chunk.map(function(chunk) {
          // Alias just so it's easier to read that this would always be a name
          var name = nameOrTemplate;
          // Three possible scenarios for a successful callback:
          //   - `require(nameOrTemplate)(dust); cb()`
          //   - `src = readFile('src.dust'); cb(null, src)`
          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`
          function done(err, srcOrTemplate) {
            var template;
            if (err) {
              return chunk.setError(err);
            }
            // Prefer a template that is passed via callback over the cached version.
            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
            if (!template) {
              // It's a template string, compile it and register under `name`
              if(dust.compile) {
                template = dust.loadSource(dust.compile(srcOrTemplate, name));
              } else {
                return chunk.setError(new Error('Dust compiler not available'));
              }
            }
            template(chunk, Context.wrap(context, template.templateName)).end();
          }

          if(dust.onLoad.length === 3) {
            dust.onLoad(name, context.options, done);
          } else {
            dust.onLoad(name, done);
          }
        });
      }
      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));
    }
  }

  dust.loadSource = function(source) {
    /*jshint evil:true*/
    return eval(source);
  };

  if (Array.isArray) {
    dust.isArray = Array.isArray;
  } else {
    dust.isArray = function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
  }

  dust.nextTick = (function() {
    return function(callback) {
      setTimeout(callback, 0);
    };
  })();

  /**
   * Dust has its own rules for what is "empty"-- which is not the same as falsy.
   * Empty arrays, null, and undefined are empty
   */
  dust.isEmpty = function(value) {
    if (value === 0) {
      return false;
    }
    if (dust.isArray(value) && !value.length) {
      return true;
    }
    return !value;
  };

  dust.isEmptyObject = function(obj) {
    var key;
    if (obj === null) {
      return false;
    }
    if (obj === undefined) {
      return false;
    }
    if (obj.length > 0) {
      return false;
    }
    for (key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  dust.isTemplateFn = function(elem) {
    return typeof elem === 'function' &&
           elem.__dustBody;
  };

  /**
   * Decide somewhat-naively if something is a Thenable.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Thenable?
   */
  dust.isThenable = function(elem) {
    return elem &&
           typeof elem === 'object' &&
           typeof elem.then === 'function';
  };

  /**
   * Decide very naively if something is a Stream.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Stream?
   */
  dust.isStreamable = function(elem) {
    return elem &&
           typeof elem.on === 'function';
  };

  // apply the filter chain and return the output string
  dust.filter = function(string, auto, filters) {
    var i, len, name;
    if (filters) {
      for (i = 0, len = filters.length; i < len; i++) {
        name = filters[i];
        if (name === 's') {
          auto = null;
        }
        else if (typeof dust.filters[name] === 'function') {
          string = dust.filters[name](string);
        }
        else {
          dust.log('Invalid filter `' + name + '`', WARN);
        }
      }
    }
    // by default always apply the h filter, unless asked to unescape with |s
    if (auto) {
      string = dust.filters[auto](string);
    }
    return string;
  };

  dust.filters = {
    h: function(value) { return dust.escapeHtml(value); },
    j: function(value) { return dust.escapeJs(value); },
    u: encodeURI,
    uc: encodeURIComponent,
    js: function(value) { return dust.escapeJSON(value); },
    jp: function(value) {
      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);
        return value;
      } else {
        return JSON.parse(value);
      }
    }
  };

  function Context(stack, global, options, blocks, templateName) {
    if(stack !== undefined && !(stack instanceof Stack)) {
      stack = new Stack(stack);
    }
    this.stack = stack;
    this.global = global;
    this.options = options;
    this.blocks = blocks;
    this.templateName = templateName;
  }

  dust.makeBase = dust.context = function(global, options) {
    return new Context(undefined, global, options);
  };

  /**
   * Factory function that creates a closure scope around a Thenable-callback.
   * Returns a function that can be passed to a Thenable that will resume a
   * Context lookup once the Thenable resolves with new data, adding that new
   * data to the lookup stack.
   */
  function getWithResolvedData(ctx, cur, down) {
    return function(data) {
      return ctx.push(data)._get(cur, down);
    };
  }

  Context.wrap = function(context, name) {
    if (context instanceof Context) {
      return context;
    }
    return new Context(context, {}, {}, null, name);
  };

  /**
   * Public API for getting a value from the context.
   * @method get
   * @param {string|array} path The path to the value. Supported formats are:
   * 'key'
   * 'path.to.key'
   * '.path.to.key'
   * ['path', 'to', 'key']
   * ['key']
   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
   * current context (true), or if get should search in parent contexts as well (false).
   * @public
   * @returns {string|object}
   */
  Context.prototype.get = function(path, cur) {
    if (typeof path === 'string') {
      if (path[0] === '.') {
        cur = true;
        path = path.substr(1);
      }
      path = path.split('.');
    }
    return this._get(cur, path);
  };

  /**
   * Get a value from the context
   * @method _get
   * @param {boolean} cur Get only from the current context
   * @param {array} down An array of each step in the path
   * @private
   * @return {string | object}
   */
  Context.prototype._get = function(cur, down) {
    var ctx = this.stack || {},
        i = 1,
        value, first, len, ctxThis, fn;

    first = down[0];
    len = down.length;

    if (cur && len === 0) {
      ctxThis = ctx;
      ctx = ctx.head;
    } else {
      if (!cur) {
        // Search up the stack for the first value
        while (ctx) {
          if (ctx.isObject) {
            ctxThis = ctx.head;
            value = ctx.head[first];
            if (value !== undefined) {
              break;
            }
          }
          ctx = ctx.tail;
        }

        // Try looking in the global context if we haven't found anything yet
        if (value !== undefined) {
          ctx = value;
        } else {
          ctx = this.global && this.global[first];
        }
      } else if (ctx) {
        // if scope is limited by a leading dot, don't search up the tree
        if(ctx.head) {
          ctx = ctx.head[first];
        } else {
          // context's head is empty, value we are searching for is not defined
          ctx = undefined;
        }
      }

      while (ctx && i < len) {
        if (dust.isThenable(ctx)) {
          // Bail early by returning a Thenable for the remainder of the search tree
          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
        }
        ctxThis = ctx;
        ctx = ctx[down[i]];
        i++;
      }
    }

    if (typeof ctx === 'function') {
      fn = function() {
        try {
          return ctx.apply(ctxThis, arguments);
        } catch (err) {
          dust.log(err, ERROR);
          throw err;
        }
      };
      fn.__dustBody = !!ctx.__dustBody;
      return fn;
    } else {
      if (ctx === undefined) {
        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);
      }
      return ctx;
    }
  };

  Context.prototype.getPath = function(cur, down) {
    return this._get(cur, down);
  };

  Context.prototype.push = function(head, idx, len) {
    if(head === undefined) {
      dust.log("Not pushing an undefined variable onto the context", INFO);
      return this;
    }
    return this.rebase(new Stack(head, this.stack, idx, len));
  };

  Context.prototype.pop = function() {
    var head = this.current();
    this.stack = this.stack && this.stack.tail;
    return head;
  };

  Context.prototype.rebase = function(head) {
    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
  };

  Context.prototype.clone = function() {
    var context = this.rebase();
    context.stack = this.stack;
    return context;
  };

  Context.prototype.current = function() {
    return this.stack && this.stack.head;
  };

  Context.prototype.getBlock = function(key) {
    var blocks, len, fn;

    if (typeof key === 'function') {
      key = key(new Chunk(), this).data.join('');
    }

    blocks = this.blocks;

    if (!blocks) {
      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);
      return false;
    }

    len = blocks.length;
    while (len--) {
      fn = blocks[len][key];
      if (fn) {
        return fn;
      }
    }

    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');
    return false;
  };

  Context.prototype.shiftBlocks = function(locals) {
    var blocks = this.blocks,
        newBlocks;

    if (locals) {
      if (!blocks) {
        newBlocks = [locals];
      } else {
        newBlocks = blocks.concat([locals]);
      }
      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
    }
    return this;
  };

  Context.prototype.resolve = function(body) {
    var chunk;

    if(typeof body !== 'function') {
      return body;
    }
    chunk = new Chunk().render(body, this);
    if(chunk instanceof Chunk) {
      return chunk.data.join(''); // ie7 perf
    }
    return chunk;
  };

  Context.prototype.getTemplateName = function() {
    return this.templateName;
  };

  function Stack(head, tail, idx, len) {
    this.tail = tail;
    this.isObject = head && typeof head === 'object';
    this.head = head;
    this.index = idx;
    this.of = len;
  }

  function Stub(callback) {
    this.head = new Chunk(this);
    this.callback = callback;
    this.out = '';
  }

  Stub.prototype.flush = function() {
    var chunk = this.head;

    while (chunk) {
      if (chunk.flushable) {
        this.out += chunk.data.join(''); //ie7 perf
      } else if (chunk.error) {
        this.callback(chunk.error);
        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.callback(null, this.out);
  };

  /**
   * Creates an interface sort of like a Streams2 ReadableStream.
   */
  function Stream() {
    this.head = new Chunk(this);
  }

  Stream.prototype.flush = function() {
    var chunk = this.head;

    while(chunk) {
      if (chunk.flushable) {
        this.emit('data', chunk.data.join('')); //ie7 perf
      } else if (chunk.error) {
        this.emit('error', chunk.error);
        this.emit('end');
        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.emit('end');
  };

  /**
   * Executes listeners for `type` by passing data. Note that this is different from a
   * Node stream, which can pass an arbitrary number of arguments
   * @return `true` if event had listeners, `false` otherwise
   */
  Stream.prototype.emit = function(type, data) {
    var events = this.events || {},
        handlers = events[type] || [],
        i, l;

    if (!handlers.length) {
      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);
      return false;
    }

    handlers = handlers.slice(0);
    for (i = 0, l = handlers.length; i < l; i++) {
      handlers[i](data);
    }
    return true;
  };

  Stream.prototype.on = function(type, callback) {
    var events = this.events = this.events || {},
        handlers = events[type] = events[type] || [];

    if(typeof callback !== 'function') {
      dust.log('No callback function provided for `' + type + '` event listener', WARN);
    } else {
      handlers.push(callback);
    }
    return this;
  };

  /**
   * Pipes to a WritableStream. Note that backpressure isn't implemented,
   * so we just write as fast as we can.
   * @param stream {WritableStream}
   * @return self
   */
  Stream.prototype.pipe = function(stream) {
    if(typeof stream.write !== 'function' ||
       typeof stream.end !== 'function') {
      dust.log('Incompatible stream passed to `pipe`', WARN);
      return this;
    }

    var destEnded = false;

    if(typeof stream.emit === 'function') {
      stream.emit('pipe', this);
    }

    if(typeof stream.on === 'function') {
      stream.on('error', function() {
        destEnded = true;
      });
    }

    return this
    .on('data', function(data) {
      if(destEnded) {
        return;
      }
      try {
        stream.write(data, 'utf8');
      } catch (err) {
        dust.log(err, ERROR);
      }
    })
    .on('end', function() {
      if(destEnded) {
        return;
      }
      try {
        stream.end();
        destEnded = true;
      } catch (err) {
        dust.log(err, ERROR);
      }
    });
  };

  function Chunk(root, next, taps) {
    this.root = root;
    this.next = next;
    this.data = []; //ie7 perf
    this.flushable = false;
    this.taps = taps;
  }

  Chunk.prototype.write = function(data) {
    var taps = this.taps;

    if (taps) {
      data = taps.go(data);
    }
    this.data.push(data);
    return this;
  };

  Chunk.prototype.end = function(data) {
    if (data) {
      this.write(data);
    }
    this.flushable = true;
    this.root.flush();
    return this;
  };

  Chunk.prototype.map = function(callback) {
    var cursor = new Chunk(this.root, this.next, this.taps),
        branch = new Chunk(this.root, cursor, this.taps);

    this.next = branch;
    this.flushable = true;
    try {
      callback(branch);
    } catch(err) {
      dust.log(err, ERROR);
      branch.setError(err);
    }
    return cursor;
  };

  Chunk.prototype.tap = function(tap) {
    var taps = this.taps;

    if (taps) {
      this.taps = taps.push(tap);
    } else {
      this.taps = new Tap(tap);
    }
    return this;
  };

  Chunk.prototype.untap = function() {
    this.taps = this.taps.tail;
    return this;
  };

  Chunk.prototype.render = function(body, context) {
    return body(this, context);
  };

  Chunk.prototype.reference = function(elem, context, auto, filters) {
    if (typeof elem === 'function') {
      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
      if (elem instanceof Chunk) {
        return elem;
      } else {
        return this.reference(elem, context, auto, filters);
      }
    }
    if (dust.isThenable(elem)) {
      return this.await(elem, context, null, auto, filters);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, null, auto, filters);
    } else if (!dust.isEmpty(elem)) {
      return this.write(dust.filter(elem, auto, filters));
    } else {
      return this;
    }
  };

  Chunk.prototype.section = function(elem, context, bodies, params) {
    var body = bodies.block,
        skip = bodies['else'],
        chunk = this,
        i, len, head;

    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {
      try {
        elem = elem.apply(context.current(), [this, context, bodies, params]);
      } catch(err) {
        dust.log(err, ERROR);
        return this.setError(err);
      }
      // Functions that return chunks are assumed to have handled the chunk manually.
      // Make that chunk the current one and go to the next method in the chain.
      if (elem instanceof Chunk) {
        return elem;
      }
    }

    if (!dust.isEmptyObject(params)) {
      context = context.push(params);
    }

    /*
    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
    When elem resolves to a value or object instead of an array, Dust sets the current context to the value
    and renders the block one time.
    */
    if (dust.isArray(elem)) {
      if (body) {
        len = elem.length;
        if (len > 0) {
          head = context.stack && context.stack.head || {};
          head.$len = len;
          for (i = 0; i < len; i++) {
            head.$idx = i;
            chunk = body(chunk, context.push(elem[i], i, len));
          }
          head.$idx = undefined;
          head.$len = undefined;
          return chunk;
        } else if (skip) {
          return skip(this, context);
        }
      }
    } else if (dust.isThenable(elem)) {
      return this.await(elem, context, bodies);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, bodies);
    } else if (elem === true) {
     // true is truthy but does not change context
      if (body) {
        return body(this, context);
      }
    } else if (elem || elem === 0) {
       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
       // zero is truthy
       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
      if (body) {
        return body(this, context.push(elem));
      }
     // nonexistent, scalar false value, scalar empty string, null,
     // undefined are all falsy
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);
    return this;
  };

  Chunk.prototype.exists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (!dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.notexists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.block = function(elem, context, bodies) {
    var body = elem || bodies.block;

    if (body) {
      return body(this, context);
    }
    return this;
  };

  Chunk.prototype.partial = function(elem, context, partialContext, params) {
    var head;

    if(params === undefined) {
      // Compatibility for < 2.7.0 where `partialContext` did not exist
      params = partialContext;
      partialContext = context;
    }

    if (!dust.isEmptyObject(params)) {
      partialContext = partialContext.clone();
      head = partialContext.pop();
      partialContext = partialContext.push(params)
                                     .push(head);
    }

    if (dust.isTemplateFn(elem)) {
      // The eventual result of evaluating `elem` is a partial name
      // Load the partial after getting its name and end the async chunk
      return this.capture(elem, context, function(name, chunk) {
        partialContext.templateName = name;
        load(name, chunk, partialContext).end();
      });
    } else {
      partialContext.templateName = elem;
      return load(elem, this, partialContext);
    }
  };

  Chunk.prototype.helper = function(name, context, bodies, params) {
    var chunk = this,
        ret;
    // handle invalid helpers, similar to invalid filters
    if(dust.helpers[name]) {
      try {
        ret = dust.helpers[name](chunk, context, bodies, params);
        if (dust.isThenable(ret)) {
          return this.await(ret, context, bodies);
        }
        return ret;
      } catch(err) {
        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);
        return chunk.setError(err);
      }
    } else {
      dust.log('Helper `' + name + '` does not exist', WARN);
      return chunk;
    }
  };

  /**
   * Reserve a chunk to be evaluated once a thenable is resolved or rejected
   * @param thenable {Thenable} the target thenable to await
   * @param context {Context} context to use to render the deferred chunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      thenable.then(function(data) {
        if(body) {
          chunk.render(body, context.push(data)).end();
        } else {
          chunk.reference(data, context, auto, filters).end();
        }
      }, function(err) {
        if(errorBody) {
          chunk.render(errorBody, context.push(err)).end();
        } else {
          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`');
          chunk.end();
        }
      });
    });
  };

  /**
   * Reserve a chunk to be evaluated with the contents of a streamable.
   * Currently an error event will bomb out the stream. Once an error
   * is received, we push it to an {:error} block if one exists, and log otherwise,
   * then stop listening to the stream.
   * @param streamable {Streamable} the target streamable that will emit events
   * @param context {Context} context to use to render each thunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      var ended = false;
      stream
        .on('data', function data(thunk) {
          if(ended) {
            return;
          }
          if(body) {
            // Fork a new chunk out of the blockstream so that we can flush it independently
            chunk = chunk.map(function(chunk) {
              chunk.render(body, context.push(thunk)).end();
            });
          } else {
            // Don't fork, just write into the master async chunk
            chunk = chunk.reference(thunk, context, auto, filters);
          }
        })
        .on('error', function error(err) {
          if(ended) {
            return;
          }
          if(errorBody) {
            chunk.render(errorBody, context.push(err));
          } else {
            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`');
          }
          if(!ended) {
            ended = true;
            chunk.end();
          }
        })
        .on('end', function end() {
          if(!ended) {
            ended = true;
            chunk.end();
          }
        });
    });
  };

  Chunk.prototype.capture = function(body, context, callback) {
    return this.map(function(chunk) {
      var stub = new Stub(function(err, out) {
        if (err) {
          chunk.setError(err);
        } else {
          callback(out, chunk);
        }
      });
      body(stub.head, context).end();
    });
  };

  Chunk.prototype.setError = function(err) {
    this.error = err;
    this.root.flush();
    return this;
  };

  // Chunk aliases
  for(var f in Chunk.prototype) {
    if(dust._aliases[f]) {
      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
    }
  }

  function Tap(head, tail) {
    this.head = head;
    this.tail = tail;
  }

  Tap.prototype.push = function(tap) {
    return new Tap(tap, this);
  };

  Tap.prototype.go = function(value) {
    var tap = this;

    while(tap) {
      value = tap.head(value);
      tap = tap.tail;
    }
    return value;
  };

  var HCHARS = /[&<>"']/,
      AMP    = /&/g,
      LT     = /</g,
      GT     = />/g,
      QUOT   = /\"/g,
      SQUOT  = /\'/g;

  dust.escapeHtml = function(s) {
    if (typeof s === "string" || (s && typeof s.toString === "function")) {
      if (typeof s !== "string") {
        s = s.toString();
      }
      if (!HCHARS.test(s)) {
        return s;
      }
      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
    }
    return s;
  };

  var BS = /\\/g,
      FS = /\//g,
      CR = /\r/g,
      LS = /\u2028/g,
      PS = /\u2029/g,
      NL = /\n/g,
      LF = /\f/g,
      SQ = /'/g,
      DQ = /"/g,
      TB = /\t/g;

  dust.escapeJs = function(s) {
    if (typeof s === 'string') {
      return s
        .replace(BS, '\\\\')
        .replace(FS, '\\/')
        .replace(DQ, '\\"')
        .replace(SQ, '\\\'')
        .replace(CR, '\\r')
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(NL, '\\n')
        .replace(LF, '\\f')
        .replace(TB, '\\t');
    }
    return s;
  };

  dust.escapeJSON = function(o) {
    if (!JSON) {
      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);
      return o;
    } else {
      return JSON.stringify(o)
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(LT, '\\u003c');
    }
  };

  return dust;

}));

(function(root, factory) {
  if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define("dust.parse", ["dust.core"], function(dust) {
      return factory(dust).parse;
    });
  } else if (typeof exports === 'object') {
    // in Node, require this file if we want to use the parser as a standalone module
    module.exports = factory(require('./dust'));
    // @see server file for parser methods exposed in node
  } else {
    // in the browser, store the factory output if we want to use the parser directly
    factory(root.dust);
  }
}(this, function(dust) {
  var parser = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(p) {
            var body = ["body"].concat(p);
            return withPosition(body);
          },
        peg$c2 = { type: "other", description: "section" },
        peg$c3 = peg$FAILED,
        peg$c4 = null,
        peg$c5 = function(t, b, e, n) {
            if( (!n) || (t[1].text !== n.text) ) {
              error("Expected end tag for "+t[1].text+" but it was not found.");
            }
            return true;
          },
        peg$c6 = void 0,
        peg$c7 = function(t, b, e, n) {
            e.push(["param", ["literal", "block"], b]);
            t.push(e);
            return withPosition(t)
          },
        peg$c8 = "/",
        peg$c9 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c10 = function(t) {
            t.push(["bodies"]);
            return withPosition(t)
          },
        peg$c11 = /^[#?\^<+@%]/,
        peg$c12 = { type: "class", value: "[#?\\^<+@%]", description: "[#?\\^<+@%]" },
        peg$c13 = function(t, n, c, p) { return [t, n, c, p] },
        peg$c14 = { type: "other", description: "end tag" },
        peg$c15 = function(n) { return n },
        peg$c16 = ":",
        peg$c17 = { type: "literal", value: ":", description: "\":\"" },
        peg$c18 = function(n) {return n},
        peg$c19 = function(n) { return n ? ["context", n] : ["context"] },
        peg$c20 = { type: "other", description: "params" },
        peg$c21 = "=",
        peg$c22 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c23 = function(k, v) {return ["param", ["literal", k], v]},
        peg$c24 = function(p) { return ["params"].concat(p) },
        peg$c25 = { type: "other", description: "bodies" },
        peg$c26 = function(p) { return ["bodies"].concat(p) },
        peg$c27 = { type: "other", description: "reference" },
        peg$c28 = function(n, f) { return withPosition(["reference", n, f]) },
        peg$c29 = { type: "other", description: "partial" },
        peg$c30 = ">",
        peg$c31 = { type: "literal", value: ">", description: "\">\"" },
        peg$c32 = "+",
        peg$c33 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c34 = function(k) {return ["literal", k]},
        peg$c35 = function(s, n, c, p) {
            var key = (s === ">") ? "partial" : s;
            return withPosition([key, n, c, p])
          },
        peg$c36 = { type: "other", description: "filters" },
        peg$c37 = "|",
        peg$c38 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c39 = function(f) { return ["filters"].concat(f) },
        peg$c40 = { type: "other", description: "special" },
        peg$c41 = "~",
        peg$c42 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c43 = function(k) { return withPosition(["special", k]) },
        peg$c44 = { type: "other", description: "identifier" },
        peg$c45 = function(p) {
            var arr = ["path"].concat(p);
            arr.text = p[1].join('.').replace(/,line,\d+,col,\d+/g,'');
            return arr;
          },
        peg$c46 = function(k) {
            var arr = ["key", k];
            arr.text = k;
            return arr;
          },
        peg$c47 = { type: "other", description: "number" },
        peg$c48 = function(n) { return ['literal', n]; },
        peg$c49 = { type: "other", description: "float" },
        peg$c50 = ".",
        peg$c51 = { type: "literal", value: ".", description: "\".\"" },
        peg$c52 = function(l, r) { return parseFloat(l + "." + r); },
        peg$c53 = { type: "other", description: "unsigned_integer" },
        peg$c54 = /^[0-9]/,
        peg$c55 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c56 = function(digits) { return makeInteger(digits); },
        peg$c57 = { type: "other", description: "signed_integer" },
        peg$c58 = "-",
        peg$c59 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c60 = function(sign, n) { return n * -1; },
        peg$c61 = { type: "other", description: "integer" },
        peg$c62 = { type: "other", description: "path" },
        peg$c63 = function(k, d) {
            d = d[0];
            if (k && d) {
              d.unshift(k);
              return withPosition([false, d])
            }
            return withPosition([true, d])
          },
        peg$c64 = function(d) {
            if (d.length > 0) {
              return withPosition([true, d[0]])
            }
            return withPosition([true, []])
          },
        peg$c65 = { type: "other", description: "key" },
        peg$c66 = /^[a-zA-Z_$]/,
        peg$c67 = { type: "class", value: "[a-zA-Z_$]", description: "[a-zA-Z_$]" },
        peg$c68 = /^[0-9a-zA-Z_$\-]/,
        peg$c69 = { type: "class", value: "[0-9a-zA-Z_$\\-]", description: "[0-9a-zA-Z_$\\-]" },
        peg$c70 = function(h, t) { return h + t.join('') },
        peg$c71 = { type: "other", description: "array" },
        peg$c72 = function(n) {return n.join('')},
        peg$c73 = function(a) {return a; },
        peg$c74 = function(i, nk) { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; },
        peg$c75 = { type: "other", description: "array_part" },
        peg$c76 = function(k) {return k},
        peg$c77 = function(d, a) { if (a) { return d.concat(a); } else { return d; } },
        peg$c78 = { type: "other", description: "inline" },
        peg$c79 = "\"",
        peg$c80 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c81 = function() { return withPosition(["literal", ""]) },
        peg$c82 = function(l) { return withPosition(["literal", l]) },
        peg$c83 = function(p) { return withPosition(["body"].concat(p)) },
        peg$c84 = function(l) { return ["buffer", l] },
        peg$c85 = { type: "other", description: "buffer" },
        peg$c86 = function(e, w) { return withPosition(["format", e, w.join('')]) },
        peg$c87 = { type: "any", description: "any character" },
        peg$c88 = function(c) {return c},
        peg$c89 = function(b) { return withPosition(["buffer", b.join('')]) },
        peg$c90 = { type: "other", description: "literal" },
        peg$c91 = /^[^"]/,
        peg$c92 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c93 = function(b) { return b.join('') },
        peg$c94 = "\\\"",
        peg$c95 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c96 = function() { return '"' },
        peg$c97 = { type: "other", description: "raw" },
        peg$c98 = "{`",
        peg$c99 = { type: "literal", value: "{`", description: "\"{`\"" },
        peg$c100 = "`}",
        peg$c101 = { type: "literal", value: "`}", description: "\"`}\"" },
        peg$c102 = function(char) {return char},
        peg$c103 = function(rawText) { return withPosition(["raw", rawText.join('')]) },
        peg$c104 = { type: "other", description: "comment" },
        peg$c105 = "{!",
        peg$c106 = { type: "literal", value: "{!", description: "\"{!\"" },
        peg$c107 = "!}",
        peg$c108 = { type: "literal", value: "!}", description: "\"!}\"" },
        peg$c109 = function(c) { return withPosition(["comment", c.join('')]) },
        peg$c110 = /^[#?\^><+%:@\/~%]/,
        peg$c111 = { type: "class", value: "[#?\\^><+%:@\\/~%]", description: "[#?\\^><+%:@\\/~%]" },
        peg$c112 = "{",
        peg$c113 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c114 = "}",
        peg$c115 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c116 = "[",
        peg$c117 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c118 = "]",
        peg$c119 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c120 = "\n",
        peg$c121 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c122 = "\r\n",
        peg$c123 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c124 = "\r",
        peg$c125 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c126 = "\u2028",
        peg$c127 = { type: "literal", value: "\u2028", description: "\"\\u2028\"" },
        peg$c128 = "\u2029",
        peg$c129 = { type: "literal", value: "\u2029", description: "\"\\u2029\"" },
        peg$c130 = /^[\t\x0B\f \xA0\uFEFF]/,
        peg$c131 = { type: "class", value: "[\\t\\x0B\\f \\xA0\\uFEFF]", description: "[\\t\\x0B\\f \\xA0\\uFEFF]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsebody();

      return s0;
    }

    function peg$parsebody() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsepart();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsepart();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsepart() {
      var s0;

      s0 = peg$parseraw();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesection();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepartial();
            if (s0 === peg$FAILED) {
              s0 = peg$parsespecial();
              if (s0 === peg$FAILED) {
                s0 = peg$parsereference();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsebuffer();
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesection() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsesec_tag_start();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parserd();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsebody();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsebodies();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseend_tag();
                if (s6 === peg$FAILED) {
                  s6 = peg$c4;
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = peg$currPos;
                  s7 = peg$c5(s1, s4, s5, s6);
                  if (s7) {
                    s7 = peg$c6;
                  } else {
                    s7 = peg$c3;
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c7(s1, s4, s5, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsesec_tag_start();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsews();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsews();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c8;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c9); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parserd();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c10(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }

      return s0;
    }

    function peg$parsesec_tag_start() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecontext();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparams();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c13(s2, s4, s5, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }

      return s0;
    }

    function peg$parseend_tag() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c8;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c9); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsews();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsews();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parserd();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }

      return s0;
    }

    function peg$parsecontext() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c16;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseidentifier();
        if (s3 !== peg$FAILED) {
          peg$reportedPos = s1;
          s2 = peg$c18(s3);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c3;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c3;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c19(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseparams() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$parsews();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsews();
        }
      } else {
        s3 = peg$c3;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s5 = peg$c21;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parsenumber();
            if (s6 === peg$FAILED) {
              s6 = peg$parseidentifier();
              if (s6 === peg$FAILED) {
                s6 = peg$parseinline();
              }
            }
            if (s6 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c23(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsews();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
        } else {
          s3 = peg$c3;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsekey();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c21;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c22); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsenumber();
              if (s6 === peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 === peg$FAILED) {
                  s6 = peg$parseinline();
                }
              }
              if (s6 !== peg$FAILED) {
                peg$reportedPos = s2;
                s3 = peg$c23(s4, s6);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c24(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }

      return s0;
    }

    function peg$parsebodies() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parseld();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s4 = peg$c16;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c17); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsekey();
          if (s5 !== peg$FAILED) {
            s6 = peg$parserd();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsebody();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s2;
                s3 = peg$c23(s5, s7);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parseld();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c16;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsekey();
            if (s5 !== peg$FAILED) {
              s6 = peg$parserd();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebody();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c23(s5, s7);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }

      return s0;
    }

    function peg$parsereference() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefilters();
          if (s3 !== peg$FAILED) {
            s4 = peg$parserd();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c28(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }

      return s0;
    }

    function peg$parsepartial() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s2 = peg$c30;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s2 = peg$c32;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c33); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsews();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parsekey();
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s4;
              s5 = peg$c34(s5);
            }
            s4 = s5;
            if (s4 === peg$FAILED) {
              s4 = peg$parseinline();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecontext();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparams();
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsews();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsews();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parserd();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c35(s2, s4, s5, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c3;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c3;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }

      return s0;
    }

    function peg$parsefilters() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s3 = peg$c37;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c18(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 124) {
          s3 = peg$c37;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsekey();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s2;
            s3 = peg$c18(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }

      return s0;
    }

    function peg$parsespecial() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 126) {
          s2 = peg$c41;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsekey();
          if (s3 !== peg$FAILED) {
            s4 = peg$parserd();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsepath();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c45(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c46(s1);
        }
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsefloat();
      if (s1 === peg$FAILED) {
        s1 = peg$parseinteger();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c48(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }

      return s0;
    }

    function peg$parsefloat() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseinteger();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c50;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseunsigned_integer();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c52(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }

      return s0;
    }

    function peg$parseunsigned_integer() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c56(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }

      return s0;
    }

    function peg$parsesigned_integer() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c58;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseunsigned_integer();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c60(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$parsesigned_integer();
      if (s0 === peg$FAILED) {
        s0 = peg$parseunsigned_integer();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }

      return s0;
    }

    function peg$parsepath() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsekey();
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsearray_part();
        if (s3 === peg$FAILED) {
          s3 = peg$parsearray();
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_part();
            if (s3 === peg$FAILED) {
              s3 = peg$parsearray();
            }
          }
        } else {
          s2 = peg$c3;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c63(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c50;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_part();
          if (s3 === peg$FAILED) {
            s3 = peg$parsearray();
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_part();
            if (s3 === peg$FAILED) {
              s3 = peg$parsearray();
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }

      return s0;
    }

    function peg$parsekey() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$c66.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c68.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c69); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c70(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsearray() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parselb();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        if (peg$c54.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c54.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c55); }
            }
          }
        } else {
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s3;
          s4 = peg$c72(s4);
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          s3 = peg$parseidentifier();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parserb();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s1;
            s2 = peg$c73(s3);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c3;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c3;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearray_part();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }

      return s0;
    }

    function peg$parsearray_part() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c50;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekey();
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c76(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c50;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekey();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c76(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearray();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c77(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }

      return s0;
    }

    function peg$parseinline() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c79;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c79;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c80); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c79;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c80); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseliteral();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c79;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c80); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c82(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c79;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseinline_part();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseinline_part();
              }
            } else {
              s2 = peg$c3;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c79;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c80); }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c83(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }

      return s0;
    }

    function peg$parseinline_part() {
      var s0, s1;

      s0 = peg$parsespecial();
      if (s0 === peg$FAILED) {
        s0 = peg$parsereference();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseliteral();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c84(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsebuffer() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseeol();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c86(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsetag();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseraw();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parsecomment();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = peg$c6;
            } else {
              peg$currPos = s5;
              s5 = peg$c3;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseeol();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = peg$c6;
              } else {
                peg$currPos = s6;
                s6 = peg$c3;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c87); }
                }
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c88(s7);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parsetag();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c6;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseraw();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c6;
              } else {
                peg$currPos = s4;
                s4 = peg$c3;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$currPos;
                peg$silentFails++;
                s6 = peg$parsecomment();
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = peg$c6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c3;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parseeol();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = peg$c6;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c87); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s2;
                      s3 = peg$c88(s7);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c3;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c3;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c3;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c3;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          }
        } else {
          s1 = peg$c3;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c89(s1);
        }
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }

      return s0;
    }

    function peg$parseliteral() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parsetag();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = peg$c6;
      } else {
        peg$currPos = s3;
        s3 = peg$c3;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseesc();
        if (s4 === peg$FAILED) {
          if (peg$c91.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c92); }
          }
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s2;
          s3 = peg$c88(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c3;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c3;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parsetag();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = peg$c6;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseesc();
            if (s4 === peg$FAILED) {
              if (peg$c91.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c92); }
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c88(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c3;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c3;
          }
        }
      } else {
        s1 = peg$c3;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c93(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }

      return s0;
    }

    function peg$parseesc() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c94) {
        s1 = peg$c94;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c96();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseraw() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c98) {
        s1 = peg$c98;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c99); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c100) {
          s5 = peg$c100;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c6;
        } else {
          peg$currPos = s4;
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c102(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s5 = peg$c100;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c102(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s3 = peg$c100;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c103(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c105) {
        s1 = peg$c105;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c107) {
          s5 = peg$c107;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c108); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c6;
        } else {
          peg$currPos = s4;
          s4 = peg$c3;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c88(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c3;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c107) {
            s5 = peg$c107;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c108); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c6;
          } else {
            peg$currPos = s4;
            s4 = peg$c3;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c88(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c3;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c3;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c107) {
            s3 = peg$c107;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c108); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c109(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }

      return s0;
    }

    function peg$parsetag() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseld();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsews();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsews();
        }
        if (s2 !== peg$FAILED) {
          if (peg$c110.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c111); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsews();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsews();
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parserd();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = peg$c6;
              } else {
                peg$currPos = s7;
                s7 = peg$c3;
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$parseeol();
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = peg$c6;
                } else {
                  peg$currPos = s8;
                  s8 = peg$c3;
                }
                if (s8 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c87); }
                  }
                  if (s9 !== peg$FAILED) {
                    s7 = [s7, s8, s9];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c3;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c3;
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$parserd();
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = peg$c6;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$c3;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$parseeol();
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = peg$c6;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$c3;
                    }
                    if (s8 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s9 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c87); }
                      }
                      if (s9 !== peg$FAILED) {
                        s7 = [s7, s8, s9];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c3;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c3;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c3;
                  }
                }
              } else {
                s5 = peg$c3;
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsews();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsews();
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parserd();
                  if (s7 !== peg$FAILED) {
                    s1 = [s1, s2, s3, s4, s5, s6, s7];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c3;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c3;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c3;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c3;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c3;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c3;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c3;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsereference();
      }

      return s0;
    }

    function peg$parseld() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 123) {
        s0 = peg$c112;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }

      return s0;
    }

    function peg$parserd() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 125) {
        s0 = peg$c114;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c115); }
      }

      return s0;
    }

    function peg$parselb() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 91) {
        s0 = peg$c116;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c117); }
      }

      return s0;
    }

    function peg$parserb() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 93) {
        s0 = peg$c118;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c119); }
      }

      return s0;
    }

    function peg$parseeol() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c120;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c122) {
          s0 = peg$c122;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c123); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c124;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c125); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c126;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c127); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c128;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c129); }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsews() {
      var s0;

      if (peg$c130.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c131); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseeol();
      }

      return s0;
    }


      function makeInteger(arr) {
        return parseInt(arr.join(''), 10);
      }
      function withPosition(arr) {
        return arr.concat([['line', line()], ['col', column()]]);
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

  // expose parser methods
  dust.parse = parser.parse;

  return parser;
}));

(function(root, factory) {
  if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define("dust.compile", ["dust.core", "dust.parse"], function(dust, parse) {
      return factory(parse, dust).compile;
    });
  } else if (typeof exports === 'object') {
    // in Node, require this file if we want to use the compiler as a standalone module
    module.exports = factory(require('./parser').parse, require('./dust'));
  } else {
    // in the browser, store the factory output if we want to use the compiler directly
    factory(root.dust.parse, root.dust);
  }
}(this, function(parse, dust) {
  var compiler = {},
      isArray = dust.isArray;


  compiler.compile = function(source, name) {
    // the name parameter is optional.
    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or
    // for templates that are compiled as a callable (compileFn)
    //
    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.

    try {
      var ast = filterAST(parse(source));
      return compile(ast, name);
    }
    catch (err)
    {
      if (!err.line || !err.column) {
        throw err;
      }
      throw new SyntaxError(err.message + ' At line : ' + err.line + ', column : ' + err.column);
    }
  };

  function filterAST(ast) {
    var context = {};
    return compiler.filterNode(context, ast);
  }

  compiler.filterNode = function(context, node) {
    return compiler.optimizers[node[0]](context, node);
  };

  compiler.optimizers = {
    body:      compactBuffers,
    buffer:    noop,
    special:   convertSpecial,
    format:    format,
    reference: visit,
    '#':       visit,
    '?':       visit,
    '^':       visit,
    '<':       visit,
    '+':       visit,
    '@':       visit,
    '%':       visit,
    partial:   visit,
    context:   visit,
    params:    visit,
    bodies:    visit,
    param:     visit,
    filters:   noop,
    key:       noop,
    path:      noop,
    literal:   noop,
    raw:       noop,
    comment:   nullify,
    line:      nullify,
    col:       nullify
  };

  compiler.pragmas = {
    esc: function(compiler, context, bodies) {
      var old = compiler.auto,
          out;
      if (!context) {
        context = 'h';
      }
      compiler.auto = (context === 's') ? '' : context;
      out = compileParts(compiler, bodies.block);
      compiler.auto = old;
      return out;
    }
  };

  function visit(context, node) {
    var out = [node[0]],
        i, len, res;
    for (i=1, len=node.length; i<len; i++) {
      res = compiler.filterNode(context, node[i]);
      if (res) {
        out.push(res);
      }
    }
    return out;
  }

  // Compacts consecutive buffer nodes into a single node
  function compactBuffers(context, node) {
    var out = [node[0]],
        memo, i, len, res;
    for (i=1, len=node.length; i<len; i++) {
      res = compiler.filterNode(context, node[i]);
      if (res) {
        if (res[0] === 'buffer' || res[0] === 'format') {
          if (memo) {
            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];
            memo[1] += res.slice(1, -2).join('');
          } else {
            memo = res;
            out.push(res);
          }
        } else {
          memo = null;
          out.push(res);
        }
      }
    }
    return out;
  }

  var specialChars = {
    's': ' ',
    'n': '\n',
    'r': '\r',
    'lb': '{',
    'rb': '}'
  };

  function convertSpecial(context, node) {
    return ['buffer', specialChars[node[1]], node[2], node[3]];
  }

  function noop(context, node) {
    return node;
  }

  function nullify(){}

  function format(context, node) {
    if(dust.config.whitespace) {
      // Format nodes are in the form ['format', eol, whitespace, line, col],
      // which is unlike other nodes in that there are two pieces of content
      // Join eol and whitespace together to normalize the node format
      node.splice(1, 2, node.slice(1, -2).join(''));
      return node;
    }
    return null;
  }

  function compile(ast, name) {
    var context = {
      name: name,
      bodies: [],
      blocks: {},
      index: 0,
      auto: 'h'
    },
    escapedName = dust.escapeJs(name),
    AMDName = name? '"' + escapedName + '",' : '',
    compiled = 'function(dust){',
    entry = compiler.compileNode(context, ast),
    iife;

    if(name) {
      compiled += 'dust.register("' + escapedName + '",' + entry + ');';
    }

    compiled += compileBlocks(context) +
                compileBodies(context) +
                'return ' + entry + '}';

    iife = '(' + compiled + '(dust));';

    if(dust.config.amd) {
      return 'define(' + AMDName + '["dust.core"],' + compiled + ');';
    } else if(dust.config.cjs) {
      return 'module.exports=function(dust){' +
             'var tmpl=' + iife +
             'var f=' + loaderFor().toString() + ';' +
             'f.template=tmpl;return f}';
    } else {
      return iife;
    }
  }

  function compileBlocks(context) {
    var out = [],
        blocks = context.blocks,
        name;

    for (name in blocks) {
      out.push('"' + name + '":' + blocks[name]);
    }
    if (out.length) {
      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';
      return 'var blocks={' + out.join(',') + '};';
    } else {
      context.blocks = '';
    }
    return context.blocks;
  }

  function compileBodies(context) {
    var out = [],
        bodies = context.bodies,
        blx = context.blocks,
        i, len;

    for (i=0, len=bodies.length; i<len; i++) {
      out[i] = 'function body_' + i + '(chk,ctx){' +
          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';
    }
    return out.join('');
  }

  function compileParts(context, body) {
    var parts = '',
        i, len;
    for (i=1, len=body.length; i<len; i++) {
      parts += compiler.compileNode(context, body[i]);
    }
    return parts;
  }

  compiler.compileNode = function(context, node) {
    return compiler.nodes[node[0]](context, node);
  };

  compiler.nodes = {
    body: function(context, node) {
      var id = context.index++,
          name = 'body_' + id;
      context.bodies[id] = compileParts(context, node);
      return name;
    },

    buffer: function(context, node) {
      return '.w(' + escape(node[1]) + ')';
    },

    format: function(context, node) {
      return '.w(' + escape(node[1]) + ')';
    },

    reference: function(context, node) {
      return '.f(' + compiler.compileNode(context, node[1]) +
        ',ctx,' + compiler.compileNode(context, node[2]) + ')';
    },

    '#': function(context, node) {
      return compileSection(context, node, 'section');
    },

    '?': function(context, node) {
      return compileSection(context, node, 'exists');
    },

    '^': function(context, node) {
      return compileSection(context, node, 'notexists');
    },

    '<': function(context, node) {
      var bodies = node[4];
      for (var i=1, len=bodies.length; i<len; i++) {
        var param = bodies[i],
            type = param[1][1];
        if (type === 'block') {
          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);
          return '';
        }
      }
      return '';
    },

    '+': function(context, node) {
      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){
        return '.b(ctx.getBlock(' +
              compiler.compileNode(context, node[1]) +
              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +
              compiler.compileNode(context, node[3]) +
              ')';
      } else {
        return '.b(ctx.getBlock(' +
            escape(node[1].text) +
            '),' + compiler.compileNode(context, node[2]) + ',' +
            compiler.compileNode(context, node[4]) + ',' +
            compiler.compileNode(context, node[3]) +
            ')';
      }
    },

    '@': function(context, node) {
      return '.h(' +
        escape(node[1].text) +
        ',' + compiler.compileNode(context, node[2]) + ',' +
        compiler.compileNode(context, node[4]) + ',' +
        compiler.compileNode(context, node[3]) +
        ')';
    },

    '%': function(context, node) {
      // TODO: Move these hacks into pragma precompiler
      var name = node[1][1],
          rawBodies,
          bodies,
          rawParams,
          params,
          ctx, b, p, i, len;
      if (!compiler.pragmas[name]) {
        return '';
      }

      rawBodies = node[4];
      bodies = {};
      for (i=1, len=rawBodies.length; i<len; i++) {
        b = rawBodies[i];
        bodies[b[1][1]] = b[2];
      }

      rawParams = node[3];
      params = {};
      for (i=1, len=rawParams.length; i<len; i++) {
        p = rawParams[i];
        params[p[1][1]] = p[2][1];
      }

      ctx = node[2][1] ? node[2][1].text : null;

      return compiler.pragmas[name](context, ctx, bodies, params);
    },

    partial: function(context, node) {
      return '.p(' +
          compiler.compileNode(context, node[1]) +
          ',ctx,' + compiler.compileNode(context, node[2]) +
          ',' + compiler.compileNode(context, node[3]) + ')';
    },

    context: function(context, node) {
      if (node[1]) {
        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';
      }
      return 'ctx';
    },

    params: function(context, node) {
      var out = [];
      for (var i=1, len=node.length; i<len; i++) {
        out.push(compiler.compileNode(context, node[i]));
      }
      if (out.length) {
        return '{' + out.join(',') + '}';
      }
      return '{}';
    },

    bodies: function(context, node) {
      var out = [];
      for (var i=1, len=node.length; i<len; i++) {
        out.push(compiler.compileNode(context, node[i]));
      }
      return '{' + out.join(',') + '}';
    },

    param: function(context, node) {
      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);
    },

    filters: function(context, node) {
      var list = [];
      for (var i=1, len=node.length; i<len; i++) {
        var filter = node[i];
        list.push('"' + filter + '"');
      }
      return '"' + context.auto + '"' +
        (list.length ? ',[' + list.join(',') + ']' : '');
    },

    key: function(context, node) {
      return 'ctx.get(["' + node[1] + '"], false)';
    },

    path: function(context, node) {
      var current = node[1],
          keys = node[2],
          list = [];

      for (var i=0,len=keys.length; i<len; i++) {
        if (isArray(keys[i])) {
          list.push(compiler.compileNode(context, keys[i]));
        } else {
          list.push('"' + keys[i] + '"');
        }
      }
      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';
    },

    literal: function(context, node) {
      return escape(node[1]);
    },
    raw: function(context, node) {
      return ".w(" + escape(node[1]) + ")";
    }
  };

  function compileSection(context, node, cmd) {
    return '.' + (dust._aliases[cmd] || cmd) + '(' +
      compiler.compileNode(context, node[1]) +
      ',' + compiler.compileNode(context, node[2]) + ',' +
      compiler.compileNode(context, node[4]) + ',' +
      compiler.compileNode(context, node[3]) +
      ')';
  }

  var BS = /\\/g,
      DQ = /"/g,
      LF = /\f/g,
      NL = /\n/g,
      CR = /\r/g,
      TB = /\t/g;
  function escapeToJsSafeString(str) {
    return str.replace(BS, '\\\\')
              .replace(DQ, '\\"')
              .replace(LF, '\\f')
              .replace(NL, '\\n')
              .replace(CR, '\\r')
              .replace(TB, '\\t');
  }

  var escape = (typeof JSON === 'undefined') ?
                  function(str) { return '"' + escapeToJsSafeString(str) + '"';} :
                  JSON.stringify;

  function renderSource(source, context, callback) {
    var tmpl = dust.loadSource(dust.compile(source));
    return loaderFor(tmpl)(context, callback);
  }

  function compileFn(source, name) {
    var tmpl = dust.loadSource(dust.compile(source, name));
    return loaderFor(tmpl);
  }

  function loaderFor(tmpl) {
    return function load(ctx, cb) {
      var fn = cb ? 'render' : 'stream';
      return dust[fn](tmpl, ctx, cb);
    };
  }

  // expose compiler methods
  dust.compiler = compiler;
  dust.compile = dust.compiler.compile;
  dust.renderSource = renderSource;
  dust.compileFn = compileFn;

  // DEPRECATED legacy names. Removed in 2.8.0
  dust.filterNode = compiler.filterNode;
  dust.optimizers = compiler.optimizers;
  dust.pragmas = compiler.pragmas;
  dust.compileNode = compiler.compileNode;
  dust.nodes = compiler.nodes;

  return compiler;

}));

if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define(["require", "dust.core", "dust.compile"], function(require, dust) {
        dust.onLoad = function(name, cb) {
            require([name], function() {
                cb();
            });
        };
        return dust;
    });
}

/*! dustjs-helpers - v1.7.4
* http://dustjs.com/
* Copyright (c) 2017 Aleksander Williams; Released under the MIT License */
(function(root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define(['dust.core'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('dustjs-linkedin'));
    module.exports.registerWith = factory;
  } else {
    factory(root.dust);
  }
}(this, function(dust) {

function log(helper, msg, level) {
  level = level || "INFO";
  helper = helper ? '{@' + helper + '}: ' : '';
  dust.log(helper + msg, level);
}

var _deprecatedCache = {};
function _deprecated(target) {
  if(_deprecatedCache[target]) { return; }
  log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
  log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
  _deprecatedCache[target] = true;
}

function isSelect(context) {
  return context.stack.tail &&
         context.stack.tail.head &&
         typeof context.stack.tail.head.__select__ !== "undefined";
}

function getSelectState(context) {
  return isSelect(context) && context.get('__select__');
}

/**
 * Adds a special __select__ key behind the head of the context stack. Used to maintain the state
 * of {@select} blocks
 * @param context {Context} add state to this Context
 * @param opts {Object} add these properties to the state (`key` and `type`)
 */
function addSelectState(context, opts) {
  var head = context.stack.head,
      newContext = context.rebase(),
      key;

  if(context.stack && context.stack.tail) {
    newContext.stack = context.stack.tail;
  }

  var state = {
    isPending: false,
    isResolved: false,
    isDeferredComplete: false,
    deferreds: []
  };

  for(key in opts) {
    state[key] = opts[key];
  }

  return newContext
  .push({ "__select__": state })
  .push(head, context.stack.index, context.stack.of);
}

/**
 * After a {@select} or {@math} block is complete, they invoke this function
 */
function resolveSelectDeferreds(state) {
  var x, len;
  state.isDeferredPending = true;
  if(state.deferreds.length) {
    state.isDeferredComplete = true;
    for(x=0, len=state.deferreds.length; x<len; x++) {
      state.deferreds[x]();
    }
  }
  state.isDeferredPending = false;
}

/**
 * Used by {@contextDump}
 */
function jsonFilter(key, value) {
  if (typeof value === "function") {
    return value.toString()
      .replace(/(^\s+|\s+$)/mg, '')
      .replace(/\n/mg, '')
      .replace(/,\s*/mg, ', ')
      .replace(/\)\{/mg, ') {');
  }
  return value;
}

/**
 * Generate a truth test helper
 */
function truthTest(name, test) {
  return function(chunk, context, bodies, params) {
    return filter(chunk, context, bodies, params, name, test);
  };
}

/**
 * This function is invoked by truth test helpers
 */
function filter(chunk, context, bodies, params, helperName, test) {
  var body = bodies.block,
      skip = bodies['else'],
      selectState = getSelectState(context) || {},
      willResolve, key, value, type;

  // Once one truth test in a select passes, short-circuit the rest of the tests
  if (selectState.isResolved && !selectState.isDeferredPending) {
    return chunk;
  }

  // First check for a key on the helper itself, then look for a key on the {@select}
  if (params.hasOwnProperty('key')) {
    key = params.key;
  } else if (selectState.hasOwnProperty('key')) {
    key = selectState.key;
  } else {
    log(helperName, "No key specified", "WARN");
    return chunk;
  }

  type = params.type || selectState.type;

  key = coerce(context.resolve(key), type);
  value = coerce(context.resolve(params.value), type);

  if (test(key, value)) {
    // Once a truth test passes, put the select into "pending" state. Now we can render the body of
    // the truth test (which may contain truth tests) without altering the state of the select.
    if (!selectState.isPending) {
      willResolve = true;
      selectState.isPending = true;
    }
    if (body) {
      chunk = chunk.render(body, context);
    }
    if (willResolve) {
      selectState.isResolved = true;
    }
  } else if (skip) {
    chunk = chunk.render(skip, context);
  }
  return chunk;
}

function coerce(value, type) {
  if (type) {
    type = type.toLowerCase();
  }
  switch (type) {
    case 'number': return +value;
    case 'string': return String(value);
    case 'boolean':
      value = (value === 'false' ? false : value);
      return Boolean(value);
    case 'date': return new Date(value);
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses native Dust Context#resolve (available since Dust 2.6.2)
  "tap": function(input, chunk, context) {
    // deprecated for removal in 1.8
    _deprecated("tap");
    return context.resolve(input);
  },

  "sep": function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if (body) {
      return body(chunk, context);
    } else {
      return chunk;
    }
  },

  "first": function(chunk, context, bodies) {
    if (context.stack.index === 0) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  "last": function(chunk, context, bodies) {
    if (context.stack.index === context.stack.of - 1) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  /**
   * {@contextDump}
   * @param key {String} set to "full" to the full context stack, otherwise the current context is dumped
   * @param to {String} set to "console" to log to console, otherwise outputs to the chunk
   */
  "contextDump": function(chunk, context, bodies, params) {
    var to = context.resolve(params.to),
        key = context.resolve(params.key),
        target, output;
    switch(key) {
      case 'full':
        target = context.stack;
        break;
      default:
        target = context.stack.head;
    }
    output = JSON.stringify(target, jsonFilter, 2);
    switch(to) {
      case 'console':
        log('contextDump', output);
        break;
      default:
        output = output.replace(/</g, '\\u003c');
        chunk = chunk.write(output);
    }
    return chunk;
  },

  /**
   * {@math}
   * @param key first value
   * @param method {String} operation to perform
   * @param operand second value (not required for operations like `abs`)
   * @param round if truthy, round() the result
   */
  "math": function (chunk, context, bodies, params) {
    var key = params.key,
        method = params.method,
        operand = params.operand,
        round = params.round,
        output, state, x, len;

    if(!params.hasOwnProperty('key') || !params.method) {
      log("math", "`key` or `method` was not provided", "ERROR");
      return chunk;
    }

    key = parseFloat(context.resolve(key));
    operand = parseFloat(context.resolve(operand));

    switch(method) {
      case "mod":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key % operand;
        break;
      case "add":
        output = key + operand;
        break;
      case "subtract":
        output = key - operand;
        break;
      case "multiply":
        output = key * operand;
        break;
      case "divide":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key / operand;
        break;
      case "ceil":
      case "floor":
      case "round":
      case "abs":
        output = Math[method](key);
        break;
      case "toint":
        output = parseInt(key, 10);
        break;
      default:
        log("math", "Method `" + method + "` is not supported", "ERROR");
    }

    if (typeof output !== 'undefined') {
      if (round) {
        output = Math.round(output);
      }
      if (bodies && bodies.block) {
        context = addSelectState(context, { key: output });
        chunk = chunk.render(bodies.block, context);
        resolveSelectDeferreds(getSelectState(context));
      } else {
        chunk = chunk.write(output);
      }
    }

    return chunk;
  },

  /**
   * {@select}
   * Groups a set of truth tests and outputs the first one that passes.
   * Also contains {@any} and {@none} blocks.
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param type coerce all truth test keys without an explicit type to this type
   */
  "select": function(chunk, context, bodies, params) {
    var body = bodies.block,
        state = {};

    if (params.hasOwnProperty('key')) {
      state.key = context.resolve(params.key);
    }
    if (params.hasOwnProperty('type')) {
      state.type = params.type;
    }

    if (body) {
      context = addSelectState(context, state);
      chunk = chunk.render(body, context);
      resolveSelectDeferreds(getSelectState(context));
    } else {
      log("select", "Missing body block", "WARN");
    }
    return chunk;
  },

  /**
   * Truth test helpers
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param value a value or reference to use as the right-hand side of comparisons
   * @param type if specified, `key` and `value` will be forcibly cast to this type
   */
  "eq": truthTest('eq', function(left, right) {
    return left === right;
  }),
  "ne": truthTest('ne', function(left, right) {
    return left !== right;
  }),
  "lt": truthTest('lt', function(left, right) {
    return left < right;
  }),
  "lte": truthTest('lte', function(left, right) {
    return left <= right;
  }),
  "gt": truthTest('gt', function(left, right) {
    return left > right;
  }),
  "gte": truthTest('gte', function(left, right) {
    return left >= right;
  }),

  /**
   * {@any}
   * Outputs as long as at least one truth test inside a {@select} has passed.
   * Must be contained inside a {@select} block.
   * The passing truth test can be before or after the {@any} block.
   */
  "any": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("any", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
   * {@none}
   * Outputs if no truth tests inside a {@select} pass.
   * Must be contained inside a {@select} block.
   * The position of the helper does not matter.
   */
  "none": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("none", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(!selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
  * {@size}
  * Write the size of the target to the chunk
  * Falsy values and true have size 0
  * Numbers are returned as-is
  * Arrays and Strings have size equal to their length
  * Objects have size equal to the number of keys they contain
  * Dust bodies are evaluated and the length of the string is returned
  * Functions are evaluated and the length of their return value is evaluated
  * @param key find the size of this value or reference
  */
  "size": function(chunk, context, bodies, params) {
    var key = params.key,
        value, k;

    key = context.resolve(params.key);
    if (!key || key === true) {
      value = 0;
    } else if(dust.isArray(key)) {
      value = key.length;
    } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
      value = key;
    } else if (typeof key === "object") {
      value = 0;
      for(k in key){
        if(key.hasOwnProperty(k)){
          value++;
        }
      }
    } else {
      value = (key + '').length;
    }
    return chunk.write(value);
  }

};

for(var key in helpers) {
  dust.helpers[key] = helpers[key];
}

return dust;

}));

/*! dustjs-i18n - v0.0.2 - 2015-03-31
* https://bitbucket.org/manolakis/dustjs-i18n
* Copyright (c) 2015 Manuel Martin; Licensed MIT */
(function (root, factory) { /* istanbul ignore if  */
	if (typeof define === "function" && define.amd) {
		// AMD. Register as an anonymous module.
		define(["dustjs-linkedin"], function (dust) {
			return factory(dust, root);
		}); /* istanbul ignore else */
	} else if (typeof module === "object" && module.exports) {
		// Node, or CommonJS-Like environments
		module.exports = factory(require("dustjs-linkedin"), this);
	} else {
		// Browser globals
		root.dust = factory(root.dust, root);
	}
}(this, function (dust, global, undefined) {
	'use strict';

		/* Utility functions */
	var toString = Object.prototype.toString,
		_console = (typeof console !== undefined) ? console : {
			log: function(){ /* a noop */}
		},
		_ = {
			isArray : Array.isArray || function(obj) {
				return toString.call(obj) === '[object Array]';
			},
			isAvailable : function(language) {
				return i18nLanguages[language] !== undefined;
			},
			log: _console.log
		},
		i18nContext = {
			selected: undefined,
			languages: {},
			filters: {}
		},
		i18nLanguages = i18nContext.languages;

	// set String trim if undefined
	if (typeof String.prototype.trim === undefined) {
		String.prototype.trim = function(){
			return this.replace(/^\s+|\s+$/g, '');
		};	
	}

	dust.i18n = {
		/* Clears all config and loaded keys */
		resetContext: function() {
			i18nContext.selected = undefined;
			Object.keys(i18nLanguages).forEach(function(language){
				delete i18nLanguages[language];
			});
		},

		/* Set the current language. Selected language must be setted previously with setLanguages  */
		setLanguage: function(language) {
			if (_.isAvailable(language)) {
				i18nContext.selected = language;
			} else {
				throw new Error("language '" + language + "' not available!");
			}
		},

		/* Set the available languages */
		setLanguages: function(languages) {
			if (_.isArray(languages)) {
				languages.forEach(function(language){
					if (!_.isAvailable(language)) {
						i18nLanguages[language] = {};
					}
					if (i18nContext.selected === undefined) {
						i18nContext.selected = language;
					}
				});
			}
		},

		/* Be careful. If language is not setted as available then it fails silently */
		add: function(language, context) {
			if (_.isAvailable(language)){
				var languageItems = i18nLanguages[language];
				Object.keys(context).forEach(function(key){
					languageItems[key] = context[key];
				});
			}
		},

		/* Add a new filter. If name exists it won't override it */
		addFilter: function(name, filter) {
			if (!(name in i18nContext.filters)) {
				i18nContext.filters[name] = filter;
			}
		}
	};

	dust.helpers.i18n = function(chunk, context, bodies, params){
		if (params && params.$key !== undefined) {
			var selected = i18nContext.selected,
				languageItems = i18nLanguages[selected],
				pattern = /\{(\s*[\w]+\s*)\}/g,
				paramsArray, param, paramName,
				$key, $data;

			
			$key = dust.helpers.tap(params.$key, chunk, context).split('|');
            var keyName = dust.helpers.tap($key.shift(), chunk, context);
            if (languageItems !== undefined &&  languageItems[keyName] !== undefined) {
                $data = languageItems[keyName];
            }
            else {
                $data = null;
            }

			while ((paramsArray = pattern.exec($data)) !== null) {
				paramName = paramsArray[1].trim();

				if (paramName === '$key') {
					param = '';
					_.log( "$key can't be used as a parameter" );
				} else {
					param = dust.helpers.tap(params[paramsArray[1].trim()], chunk, context);	
				}
				
				$data = $data.replace(paramsArray[0], param);
			}

			$key.forEach(function(filterName){
				if (filterName in i18nContext.filters) {
					$data = i18nContext.filters[filterName]($data);
				}
			});

			chunk.write($data);
		} else {
			_.log( "No key given in the i18n helper" );
		}

		return chunk;
	};

	return dust;
}));

(function () {

    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (stringBuscada, posicion) {
            posicion = posicion || 0;
            return this.indexOf(stringBuscada, posicion) === posicion;
        };
    }

    dust.helpers.iterate = function (chunk, context, bodies, params) {
        params = params || {};
        var obj = params['on'] || context.current();
        var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;

        for (var k in obj) {
            if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                chunk = chunk.render(bodies.block, context.push({ key: k, value: obj[k] }));
            }
        }
        return chunk;
    }
    dust.helpers.startsWith = function (chunk, context, bodies, params) {
        var body = bodies.block, skip = bodies['else'], key = params["key"], value = params["value"];
        if (typeof (key) === "string" && key.toLowerCase().indexOf(value.toLowerCase()) === 0) {
            chunk = chunk.render(body, context);
        }
        else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    };
    dust.helpers.isObject = function (chunk, context, bodies, params) {
        params = params || {};
        var body = bodies.block, skip = bodies['else'], obj = params["object"] || context.current();
        if (obj instanceof Array && bodies['array']) {
            chunk = chunk.render(bodies['array'], context);
        }
        else if (obj instanceof Object) {
            chunk = chunk.render(body, context);
        }
        else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    }
    dust.helpers.isKeyKalue = function (chunk, context, bodies, params) {
        params = params || {};
        var body = bodies.block, skip = bodies['else'], obj = params["object"] || context.current();
        if (obj.hasOwnProperty("value") && !(obj["value"] instanceof Object))
            chunk.render(body, context);
        else if (skip)
            chunk.render(skip, context);
        return chunk;
    }
    var ids = [];
    dust.filters.objectId = function (value) {
        let found = ids.find((item) => { return item.obj === value });
        if (!found)
            ids.push(found = { "obj": value, id: TC.getUID() })
        return found.id;
    }	    
})();

var __extends=this.__extends||function(b,d){function n(){this.constructor=b}for(var f in d)d.hasOwnProperty(f)&&(b[f]=d[f]);n.prototype=d.prototype;b.prototype=new n};
function JL(b){if(!b)return JL.__;Array.prototype.reduce||(Array.prototype.reduce=function(b,d){for(var l=d,g=0;g<this.length;g++)l=b(l,this[g],g,this);return l});var d="";return("."+b).split(".").reduce(function(b,f,l,g){d=d?d+("."+f):f;f=b["__"+d];void 0===f&&(JL.Logger.prototype=b,f=new JL.Logger(d),b["__"+d]=f);return f},JL.__)}
(function(b){function d(a,c,h){void 0!==c[a]&&(null===c[a]?delete h[a]:h[a]=c[a])}function n(a){if(null!=b.enabled&&!b.enabled||null!=b.maxMessages&&1>b.maxMessages)return!1;try{if(a.userAgentRegex&&!RegExp(a.userAgentRegex).test(navigator.userAgent))return!1}catch(c){}try{if(a.ipRegex&&b.clientIP&&!RegExp(a.ipRegex).test(b.clientIP))return!1}catch(h){}return!0}function f(a,c){try{if(a.disallow&&RegExp(a.disallow).test(c))return!1}catch(h){}return!0}function l(a){return"function"==typeof a?a instanceof
RegExp?a.toString():a():a}function g(a){a=l(a);switch(typeof a){case "string":return new m(a,null,a);case "number":return a=a.toString(),new m(a,null,a);case "boolean":return a=a.toString(),new m(a,null,a);case "undefined":return new m("undefined",null,"undefined");case "object":return a instanceof RegExp||a instanceof String||a instanceof Number||a instanceof Boolean?(a=a.toString(),new m(a,null,a)):new m(null,a,JSON.stringify(a));default:return new m("unknown",null,"unknown")}}b.enabled;b.maxMessages;
b.defaultAjaxUrl;b.clientIP;b.defaultBeforeSend;b.requestId="";var m=function(){return function(a,c,h){this.msg=a;this.meta=c;this.finalString=h}}();b.setOptions=function(a){d("enabled",a,this);d("maxMessages",a,this);d("defaultAjaxUrl",a,this);d("clientIP",a,this);d("requestId",a,this);d("defaultBeforeSend",a,this);return this};b.getAllLevel=function(){return-2147483648};b.getTraceLevel=function(){return 1E3};b.getDebugLevel=function(){return 2E3};b.getInfoLevel=function(){return 3E3};b.getWarnLevel=
function(){return 4E3};b.getErrorLevel=function(){return 5E3};b.getFatalLevel=function(){return 6E3};b.getOffLevel=function(){return 2147483647};var e=function(){return function(a,c){this.inner=c;this.name="JL.Exception";this.message=g(a).finalString}}();b.Exception=e;e.prototype=Error();var r=function(){return function(a,c,h,b){this.l=a;this.m=c;this.n=h;this.t=b}}();b.LogItem=r;e=function(){function a(c,a){this.appenderName=c;this.sendLogItems=a;this.level=b.getTraceLevel();this.sendWithBufferLevel=
2147483647;this.storeInBufferLevel=-2147483648;this.bufferSize=0;this.batchSize=1;this.buffer=[];this.batchBuffer=[]}a.prototype.setOptions=function(c){d("level",c,this);d("ipRegex",c,this);d("userAgentRegex",c,this);d("disallow",c,this);d("sendWithBufferLevel",c,this);d("storeInBufferLevel",c,this);d("bufferSize",c,this);d("batchSize",c,this);this.bufferSize<this.buffer.length&&(this.buffer.length=this.bufferSize);return this};a.prototype.log=function(c,a,b,d,k,e,g){!n(this)||!f(this,e)||k<this.storeInBufferLevel||
(c=new r(k,e,g,(new Date).getTime()),k<this.level?0<this.bufferSize&&(this.buffer.push(c),this.buffer.length>this.bufferSize&&this.buffer.shift()):(k<this.sendWithBufferLevel||!this.buffer.length||(this.batchBuffer=this.batchBuffer.concat(this.buffer),this.buffer.length=0),this.batchBuffer.push(c),this.batchBuffer.length>=this.batchSize&&this.sendBatch()))};a.prototype.sendBatch=function(){0==this.batchBuffer.length||null!=b.maxMessages&&1>b.maxMessages||(null!=b.maxMessages&&(b.maxMessages-=this.batchBuffer.length),
this.sendLogItems(this.batchBuffer),this.batchBuffer.length=0)};return a}();b.Appender=e;var p=function(a){function c(b){a.call(this,b,c.prototype.sendLogItemsAjax)}__extends(c,a);c.prototype.setOptions=function(c){d("url",c,this);d("beforeSend",c,this);a.prototype.setOptions.call(this,c);return this};c.prototype.sendLogItemsAjax=function(c){try{var a="/jsnlog.logger";null!=b.defaultAjaxUrl&&(a=b.defaultAjaxUrl);this.url&&(a=this.url);var d=JSON.stringify({r:b.requestId,lg:c}),k=this.getXhr(a);"function"===
typeof this.beforeSend?this.beforeSend.call(this,k):"function"===typeof b.defaultBeforeSend&&b.defaultBeforeSend.call(this,k);k.send(d)}catch(f){}};c.prototype.getXhr=function(c){var a=new XMLHttpRequest;if(!("withCredentials"in a)&&"undefined"!=typeof XDomainRequest)return a=new XDomainRequest,a.open("POST",c),a;a.open("POST",c);a.setRequestHeader("Content-Type","application/json");a.setRequestHeader("JSNLog-RequestId",b.requestId);return a};return c}(e);b.AjaxAppender=p;var q=function(a){function c(b){a.call(this,
b,c.prototype.sendLogItemsConsole)}__extends(c,a);c.prototype.clog=function(a){console.log(a)};c.prototype.cerror=function(a){console.error?console.error(a):this.clog(a)};c.prototype.cwarn=function(a){console.warn?console.warn(a):this.clog(a)};c.prototype.cinfo=function(a){console.info?console.info(a):this.clog(a)};c.prototype.cdebug=function(a){console.debug?console.debug(a):this.cinfo(a)};c.prototype.sendLogItemsConsole=function(a){try{if(console){var c;for(c=0;c<a.length;++c){var d=a[c],f=d.n+
": "+d.m;"undefined"===typeof window&&(f=new Date(d.t)+" | "+f);d.l<=b.getDebugLevel()?this.cdebug(f):d.l<=b.getInfoLevel()?this.cinfo(f):d.l<=b.getWarnLevel()?this.cwarn(f):this.cerror(f)}}}catch(e){}};return c}(e);b.ConsoleAppender=q;e=function(){function a(a){this.loggerName=a;this.seenRegexes=[]}a.prototype.setOptions=function(a){d("level",a,this);d("userAgentRegex",a,this);d("disallow",a,this);d("ipRegex",a,this);d("appenders",a,this);d("onceOnly",a,this);this.seenRegexes=[];return this};a.prototype.buildExceptionObject=
function(a){var b={};a.stack?b.stack=a.stack:b.e=a;a.message&&(b.message=a.message);a.name&&(b.name=a.name);a.data&&(b.data=a.data);a.inner&&(b.inner=this.buildExceptionObject(a.inner));return b};a.prototype.log=function(a,b,d){var e=0;if(!this.appenders)return this;if(a>=this.level&&n(this)&&(d?(e=this.buildExceptionObject(d),e.logData=l(b)):e=b,b=g(e),f(this,b.finalString))){if(this.onceOnly)for(e=this.onceOnly.length-1;0<=e;){if(RegExp(this.onceOnly[e]).test(b.finalString)){if(this.seenRegexes[e])return this;
this.seenRegexes[e]=!0}e--}b.meta=b.meta||{};b.meta.loggerName=this.loggerName;for(e=this.appenders.length-1;0<=e;)this.appenders[e].log(1E3>=a?"trace":2E3>=a?"debug":3E3>=a?"info":4E3>=a?"warn":5E3>=a?"error":"fatal",b.msg,b.meta,function(){},a,b.finalString,this.loggerName),e--}return this};a.prototype.trace=function(a){return this.log(1E3,a)};a.prototype.debug=function(a){return this.log(2E3,a)};a.prototype.info=function(a){return this.log(3E3,a)};a.prototype.warn=function(a){return this.log(4E3,
a)};a.prototype.error=function(a){return this.log(5E3,a)};a.prototype.fatal=function(a){return this.log(6E3,a)};a.prototype.fatalException=function(a,b){return this.log(6E3,a,b)};return a}();b.Logger=e;b.createAjaxAppender=function(a){return new p(a)};b.createConsoleAppender=function(a){return new q(a)};e=new p("");"undefined"===typeof window&&(e=new q(""));b.__=new b.Logger("");b.__.setOptions({level:b.getDebugLevel(),appenders:[e]})})(JL||(JL={}));var exports;
"undefined"!==typeof exports&&(exports.JL=JL);var define;"function"==typeof define&&define.amd&&define("jsnlog",[],function(){return JL});"function"==typeof __jsnlog_configure&&__jsnlog_configure(JL);

/**!

 @license
 handlebars v4.7.3

Copyright (C) 2011-2019 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function(a,b){"object"==typeof exports&&"object"==typeof module?module.exports=b():"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?exports.Handlebars=b():a.Handlebars=b()}(this,function(){return function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={exports:{},id:d,loaded:!1};return a[d].call(e.exports,e,e.exports,b),e.loaded=!0,e.exports}var c={};return b.m=a,b.c=c,b.p="",b(0)}([function(a,b,c){"use strict";function d(){var a=new h.HandlebarsEnvironment;return n.extend(a,h),a.SafeString=j["default"],a.Exception=l["default"],a.Utils=n,a.escapeExpression=n.escapeExpression,a.VM=p,a.template=function(b){return p.template(b,a)},a}var e=c(1)["default"],f=c(2)["default"];b.__esModule=!0;var g=c(3),h=e(g),i=c(36),j=f(i),k=c(5),l=f(k),m=c(4),n=e(m),o=c(37),p=e(o),q=c(43),r=f(q),s=d();s.create=d,r["default"](s),s["default"]=s,b["default"]=s,a.exports=b["default"]},function(a,b){"use strict";b["default"]=function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);return b["default"]=a,b},b.__esModule=!0},function(a,b){"use strict";b["default"]=function(a){return a&&a.__esModule?a:{"default":a}},b.__esModule=!0},function(a,b,c){"use strict";function d(a,b,c){this.helpers=a||{},this.partials=b||{},this.decorators=c||{},i.registerDefaultHelpers(this),j.registerDefaultDecorators(this)}var e=c(2)["default"];b.__esModule=!0,b.HandlebarsEnvironment=d;var f=c(4),g=c(5),h=e(g),i=c(9),j=c(29),k=c(31),l=e(k),m=c(32),n="4.7.3";b.VERSION=n;var o=8;b.COMPILER_REVISION=o;var p=7;b.LAST_COMPATIBLE_COMPILER_REVISION=p;var q={1:"<= 1.0.rc.2",2:"== 1.0.0-rc.3",3:"== 1.0.0-rc.4",4:"== 1.x.x",5:"== 2.0.0-alpha.x",6:">= 2.0.0-beta.1",7:">= 4.0.0 <4.3.0",8:">= 4.3.0"};b.REVISION_CHANGES=q;var r="[object Object]";d.prototype={constructor:d,logger:l["default"],log:l["default"].log,registerHelper:function(a,b){if(f.toString.call(a)===r){if(b)throw new h["default"]("Arg not supported with multiple helpers");f.extend(this.helpers,a)}else this.helpers[a]=b},unregisterHelper:function(a){delete this.helpers[a]},registerPartial:function(a,b){if(f.toString.call(a)===r)f.extend(this.partials,a);else{if("undefined"==typeof b)throw new h["default"]('Attempting to register a partial called "'+a+'" as undefined');this.partials[a]=b}},unregisterPartial:function(a){delete this.partials[a]},registerDecorator:function(a,b){if(f.toString.call(a)===r){if(b)throw new h["default"]("Arg not supported with multiple decorators");f.extend(this.decorators,a)}else this.decorators[a]=b},unregisterDecorator:function(a){delete this.decorators[a]},resetLoggedPropertyAccesses:function(){m.resetLoggedProperties()}};var s=l["default"].log;b.log=s,b.createFrame=f.createFrame,b.logger=l["default"]},function(a,b){"use strict";function c(a){return k[a]}function d(a){for(var b=1;b<arguments.length;b++)for(var c in arguments[b])Object.prototype.hasOwnProperty.call(arguments[b],c)&&(a[c]=arguments[b][c]);return a}function e(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1}function f(a){if("string"!=typeof a){if(a&&a.toHTML)return a.toHTML();if(null==a)return"";if(!a)return a+"";a=""+a}return m.test(a)?a.replace(l,c):a}function g(a){return!a&&0!==a||!(!p(a)||0!==a.length)}function h(a){var b=d({},a);return b._parent=a,b}function i(a,b){return a.path=b,a}function j(a,b){return(a?a+".":"")+b}b.__esModule=!0,b.extend=d,b.indexOf=e,b.escapeExpression=f,b.isEmpty=g,b.createFrame=h,b.blockParams=i,b.appendContextPath=j;var k={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;","=":"&#x3D;"},l=/[&<>"'`=]/g,m=/[&<>"'`=]/,n=Object.prototype.toString;b.toString=n;var o=function(a){return"function"==typeof a};o(/x/)&&(b.isFunction=o=function(a){return"function"==typeof a&&"[object Function]"===n.call(a)}),b.isFunction=o;var p=Array.isArray||function(a){return!(!a||"object"!=typeof a)&&"[object Array]"===n.call(a)};b.isArray=p},function(a,b,c){"use strict";function d(a,b){var c=b&&b.loc,g=void 0,h=void 0,i=void 0,j=void 0;c&&(g=c.start.line,h=c.end.line,i=c.start.column,j=c.end.column,a+=" - "+g+":"+i);for(var k=Error.prototype.constructor.call(this,a),l=0;l<f.length;l++)this[f[l]]=k[f[l]];Error.captureStackTrace&&Error.captureStackTrace(this,d);try{c&&(this.lineNumber=g,this.endLineNumber=h,e?(Object.defineProperty(this,"column",{value:i,enumerable:!0}),Object.defineProperty(this,"endColumn",{value:j,enumerable:!0})):(this.column=i,this.endColumn=j))}catch(m){}}var e=c(6)["default"];b.__esModule=!0;var f=["description","fileName","lineNumber","endLineNumber","message","name","number","stack"];d.prototype=new Error,b["default"]=d,a.exports=b["default"]},function(a,b,c){a.exports={"default":c(7),__esModule:!0}},function(a,b,c){var d=c(8);a.exports=function(a,b,c){return d.setDesc(a,b,c)}},function(a,b){var c=Object;a.exports={create:c.create,getProto:c.getPrototypeOf,isEnum:{}.propertyIsEnumerable,getDesc:c.getOwnPropertyDescriptor,setDesc:c.defineProperty,setDescs:c.defineProperties,getKeys:c.keys,getNames:c.getOwnPropertyNames,getSymbols:c.getOwnPropertySymbols,each:[].forEach}},function(a,b,c){"use strict";function d(a){h["default"](a),j["default"](a),l["default"](a),n["default"](a),p["default"](a),r["default"](a),t["default"](a)}function e(a,b,c){a.helpers[b]&&(a.hooks[b]=a.helpers[b],c||delete a.helpers[b])}var f=c(2)["default"];b.__esModule=!0,b.registerDefaultHelpers=d,b.moveHelperToHooks=e;var g=c(10),h=f(g),i=c(11),j=f(i),k=c(24),l=f(k),m=c(25),n=f(m),o=c(26),p=f(o),q=c(27),r=f(q),s=c(28),t=f(s)},function(a,b,c){"use strict";b.__esModule=!0;var d=c(4);b["default"]=function(a){a.registerHelper("blockHelperMissing",function(b,c){var e=c.inverse,f=c.fn;if(b===!0)return f(this);if(b===!1||null==b)return e(this);if(d.isArray(b))return b.length>0?(c.ids&&(c.ids=[c.name]),a.helpers.each(b,c)):e(this);if(c.data&&c.ids){var g=d.createFrame(c.data);g.contextPath=d.appendContextPath(c.data.contextPath,c.name),c={data:g}}return f(b,c)})},a.exports=b["default"]},function(a,b,c){(function(d){"use strict";var e=c(12)["default"],f=c(2)["default"];b.__esModule=!0;var g=c(4),h=c(5),i=f(h);b["default"]=function(a){a.registerHelper("each",function(a,b){function c(b,c,d){l&&(l.key=b,l.index=c,l.first=0===c,l.last=!!d,m&&(l.contextPath=m+b)),k+=f(a[b],{data:l,blockParams:g.blockParams([a[b],b],[m+b,null])})}if(!b)throw new i["default"]("Must pass iterator to #each");var f=b.fn,h=b.inverse,j=0,k="",l=void 0,m=void 0;if(b.data&&b.ids&&(m=g.appendContextPath(b.data.contextPath,b.ids[0])+"."),g.isFunction(a)&&(a=a.call(this)),b.data&&(l=g.createFrame(b.data)),a&&"object"==typeof a)if(g.isArray(a))for(var n=a.length;j<n;j++)j in a&&c(j,j,j===a.length-1);else if(d.Symbol&&a[d.Symbol.iterator]){for(var o=[],p=a[d.Symbol.iterator](),q=p.next();!q.done;q=p.next())o.push(q.value);a=o;for(var n=a.length;j<n;j++)c(j,j,j===a.length-1)}else!function(){var b=void 0;e(a).forEach(function(a){void 0!==b&&c(b,j-1),b=a,j++}),void 0!==b&&c(b,j-1,!0)}();return 0===j&&(k=h(this)),k})},a.exports=b["default"]}).call(b,function(){return this}())},function(a,b,c){a.exports={"default":c(13),__esModule:!0}},function(a,b,c){c(14),a.exports=c(20).Object.keys},function(a,b,c){var d=c(15);c(17)("keys",function(a){return function(b){return a(d(b))}})},function(a,b,c){var d=c(16);a.exports=function(a){return Object(d(a))}},function(a,b){a.exports=function(a){if(void 0==a)throw TypeError("Can't call method on  "+a);return a}},function(a,b,c){var d=c(18),e=c(20),f=c(23);a.exports=function(a,b){var c=(e.Object||{})[a]||Object[a],g={};g[a]=b(c),d(d.S+d.F*f(function(){c(1)}),"Object",g)}},function(a,b,c){var d=c(19),e=c(20),f=c(21),g="prototype",h=function(a,b,c){var i,j,k,l=a&h.F,m=a&h.G,n=a&h.S,o=a&h.P,p=a&h.B,q=a&h.W,r=m?e:e[b]||(e[b]={}),s=m?d:n?d[b]:(d[b]||{})[g];m&&(c=b);for(i in c)j=!l&&s&&i in s,j&&i in r||(k=j?s[i]:c[i],r[i]=m&&"function"!=typeof s[i]?c[i]:p&&j?f(k,d):q&&s[i]==k?function(a){var b=function(b){return this instanceof a?new a(b):a(b)};return b[g]=a[g],b}(k):o&&"function"==typeof k?f(Function.call,k):k,o&&((r[g]||(r[g]={}))[i]=k))};h.F=1,h.G=2,h.S=4,h.P=8,h.B=16,h.W=32,a.exports=h},function(a,b){var c=a.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=c)},function(a,b){var c=a.exports={version:"1.2.6"};"number"==typeof __e&&(__e=c)},function(a,b,c){var d=c(22);a.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},function(a,b){a.exports=function(a){if("function"!=typeof a)throw TypeError(a+" is not a function!");return a}},function(a,b){a.exports=function(a){try{return!!a()}catch(b){return!0}}},function(a,b,c){"use strict";var d=c(2)["default"];b.__esModule=!0;var e=c(5),f=d(e);b["default"]=function(a){a.registerHelper("helperMissing",function(){if(1!==arguments.length)throw new f["default"]('Missing helper: "'+arguments[arguments.length-1].name+'"')})},a.exports=b["default"]},function(a,b,c){"use strict";var d=c(2)["default"];b.__esModule=!0;var e=c(4),f=c(5),g=d(f);b["default"]=function(a){a.registerHelper("if",function(a,b){if(2!=arguments.length)throw new g["default"]("#if requires exactly one argument");return e.isFunction(a)&&(a=a.call(this)),!b.hash.includeZero&&!a||e.isEmpty(a)?b.inverse(this):b.fn(this)}),a.registerHelper("unless",function(b,c){if(2!=arguments.length)throw new g["default"]("#unless requires exactly one argument");return a.helpers["if"].call(this,b,{fn:c.inverse,inverse:c.fn,hash:c.hash})})},a.exports=b["default"]},function(a,b){"use strict";b.__esModule=!0,b["default"]=function(a){a.registerHelper("log",function(){for(var b=[void 0],c=arguments[arguments.length-1],d=0;d<arguments.length-1;d++)b.push(arguments[d]);var e=1;null!=c.hash.level?e=c.hash.level:c.data&&null!=c.data.level&&(e=c.data.level),b[0]=e,a.log.apply(a,b)})},a.exports=b["default"]},function(a,b){"use strict";b.__esModule=!0,b["default"]=function(a){a.registerHelper("lookup",function(a,b,c){return a?c.lookupProperty(a,b):a})},a.exports=b["default"]},function(a,b,c){"use strict";var d=c(2)["default"];b.__esModule=!0;var e=c(4),f=c(5),g=d(f);b["default"]=function(a){a.registerHelper("with",function(a,b){if(2!=arguments.length)throw new g["default"]("#with requires exactly one argument");e.isFunction(a)&&(a=a.call(this));var c=b.fn;if(e.isEmpty(a))return b.inverse(this);var d=b.data;return b.data&&b.ids&&(d=e.createFrame(b.data),d.contextPath=e.appendContextPath(b.data.contextPath,b.ids[0])),c(a,{data:d,blockParams:e.blockParams([a],[d&&d.contextPath])})})},a.exports=b["default"]},function(a,b,c){"use strict";function d(a){g["default"](a)}var e=c(2)["default"];b.__esModule=!0,b.registerDefaultDecorators=d;var f=c(30),g=e(f)},function(a,b,c){"use strict";b.__esModule=!0;var d=c(4);b["default"]=function(a){a.registerDecorator("inline",function(a,b,c,e){var f=a;return b.partials||(b.partials={},f=function(e,f){var g=c.partials;c.partials=d.extend({},g,b.partials);var h=a(e,f);return c.partials=g,h}),b.partials[e.args[0]]=e.fn,f})},a.exports=b["default"]},function(a,b,c){"use strict";b.__esModule=!0;var d=c(4),e={methodMap:["debug","info","warn","error"],level:"info",lookupLevel:function(a){if("string"==typeof a){var b=d.indexOf(e.methodMap,a.toLowerCase());a=b>=0?b:parseInt(a,10)}return a},log:function(a){if(a=e.lookupLevel(a),"undefined"!=typeof console&&e.lookupLevel(e.level)<=a){var b=e.methodMap[a];console[b]||(b="log");for(var c=arguments.length,d=Array(c>1?c-1:0),f=1;f<c;f++)d[f-1]=arguments[f];console[b].apply(console,d)}}};b["default"]=e,a.exports=b["default"]},function(a,b,c){"use strict";function d(a){var b=i(null);b.constructor=!1,b.__defineGetter__=!1,b.__defineSetter__=!1,b.__lookupGetter__=!1;var c=i(null);return c.__proto__=!1,{properties:{whitelist:l.createNewLookupObject(c,a.allowedProtoProperties),defaultValue:a.allowProtoPropertiesByDefault},methods:{whitelist:l.createNewLookupObject(b,a.allowedProtoMethods),defaultValue:a.allowProtoMethodsByDefault}}}function e(a,b,c){return"function"==typeof a?f(b.methods,c):f(b.properties,c)}function f(a,b){return void 0!==a.whitelist[b]?a.whitelist[b]===!0:void 0!==a.defaultValue?a.defaultValue:(g(b),!1)}function g(a){o[a]!==!0&&(o[a]=!0,n.log("error",'Handlebars: Access has been denied to resolve the property "'+a+'" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details'))}function h(){j(o).forEach(function(a){delete o[a]})}var i=c(33)["default"],j=c(12)["default"],k=c(1)["default"];b.__esModule=!0,b.createProtoAccessControl=d,b.resultIsAllowed=e,b.resetLoggedProperties=h;var l=c(35),m=c(31),n=k(m),o=i(null)},function(a,b,c){a.exports={"default":c(34),__esModule:!0}},function(a,b,c){var d=c(8);a.exports=function(a,b){return d.create(a,b)}},function(a,b,c){"use strict";function d(){for(var a=arguments.length,b=Array(a),c=0;c<a;c++)b[c]=arguments[c];return f.extend.apply(void 0,[e(null)].concat(b))}var e=c(33)["default"];b.__esModule=!0,b.createNewLookupObject=d;var f=c(4)},function(a,b){"use strict";function c(a){this.string=a}b.__esModule=!0,c.prototype.toString=c.prototype.toHTML=function(){return""+this.string},b["default"]=c,a.exports=b["default"]},function(a,b,c){"use strict";function d(a){var b=a&&a[0]||1,c=v.COMPILER_REVISION;if(!(b>=v.LAST_COMPATIBLE_COMPILER_REVISION&&b<=v.COMPILER_REVISION)){if(b<v.LAST_COMPATIBLE_COMPILER_REVISION){var d=v.REVISION_CHANGES[c],e=v.REVISION_CHANGES[b];throw new u["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version ("+d+") or downgrade your runtime to an older version ("+e+").")}throw new u["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version ("+a[1]+").")}}function e(a,b){function c(c,d,e){e.hash&&(d=s.extend({},d,e.hash),e.ids&&(e.ids[0]=!0)),c=b.VM.resolvePartial.call(this,c,d,e);var f=s.extend({},e,{hooks:this.hooks,protoAccessControl:this.protoAccessControl}),g=b.VM.invokePartial.call(this,c,d,f);if(null==g&&b.compile&&(e.partials[e.name]=b.compile(c,a.compilerOptions,b),g=e.partials[e.name](d,f)),null!=g){if(e.indent){for(var h=g.split("\n"),i=0,j=h.length;i<j&&(h[i]||i+1!==j);i++)h[i]=e.indent+h[i];g=h.join("\n")}return g}throw new u["default"]("The partial "+e.name+" could not be compiled when running in runtime-only mode")}function d(b){function c(b){return""+a.main(g,b,g.helpers,g.partials,f,i,h)}var e=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],f=e.data;d._setup(e),!e.partial&&a.useData&&(f=j(b,f));var h=void 0,i=a.useBlockParams?[]:void 0;return a.useDepths&&(h=e.depths?b!=e.depths[0]?[b].concat(e.depths):e.depths:[b]),(c=k(a.main,c,g,e.depths||[],f,i))(b,e)}if(!b)throw new u["default"]("No environment passed to template");if(!a||!a.main)throw new u["default"]("Unknown template object: "+typeof a);a.main.decorator=a.main_d,b.VM.checkRevision(a.compiler);var e=a.compiler&&7===a.compiler[0],g={strict:function(a,b,c){if(!(a&&b in a))throw new u["default"]('"'+b+'" not defined in '+a,{loc:c});return a[b]},lookupProperty:function(a,b){var c=a[b];return null==c?c:Object.prototype.hasOwnProperty.call(a,b)?c:y.resultIsAllowed(c,g.protoAccessControl,b)?c:void 0},lookup:function(a,b){for(var c=a.length,d=0;d<c;d++){var e=a[d]&&g.lookupProperty(a[d],b);if(null!=e)return a[d][b]}},lambda:function(a,b){return"function"==typeof a?a.call(b):a},escapeExpression:s.escapeExpression,invokePartial:c,fn:function(b){var c=a[b];return c.decorator=a[b+"_d"],c},programs:[],program:function(a,b,c,d,e){var g=this.programs[a],h=this.fn(a);return b||e||d||c?g=f(this,a,h,b,c,d,e):g||(g=this.programs[a]=f(this,a,h)),g},data:function(a,b){for(;a&&b--;)a=a._parent;return a},mergeIfNeeded:function(a,b){var c=a||b;return a&&b&&a!==b&&(c=s.extend({},b,a)),c},nullContext:n({}),noop:b.VM.noop,compilerInfo:a.compiler};return d.isTop=!0,d._setup=function(c){if(c.partial)g.protoAccessControl=c.protoAccessControl,g.helpers=c.helpers,g.partials=c.partials,g.decorators=c.decorators,g.hooks=c.hooks;else{var d=s.extend({},b.helpers,c.helpers);l(d,g),g.helpers=d,a.usePartial&&(g.partials=g.mergeIfNeeded(c.partials,b.partials)),(a.usePartial||a.useDecorators)&&(g.decorators=s.extend({},b.decorators,c.decorators)),g.hooks={},g.protoAccessControl=y.createProtoAccessControl(c);var f=c.allowCallsToHelperMissing||e;w.moveHelperToHooks(g,"helperMissing",f),w.moveHelperToHooks(g,"blockHelperMissing",f)}},d._child=function(b,c,d,e){if(a.useBlockParams&&!d)throw new u["default"]("must pass block params");if(a.useDepths&&!e)throw new u["default"]("must pass parent depths");return f(g,b,a[b],c,0,d,e)},d}function f(a,b,c,d,e,f,g){function h(b){var e=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],h=g;return!g||b==g[0]||b===a.nullContext&&null===g[0]||(h=[b].concat(g)),c(a,b,a.helpers,a.partials,e.data||d,f&&[e.blockParams].concat(f),h)}return h=k(c,h,a,g,d,f),h.program=b,h.depth=g?g.length:0,h.blockParams=e||0,h}function g(a,b,c){return a?a.call||c.name||(c.name=a,a=c.partials[a]):a="@partial-block"===c.name?c.data["partial-block"]:c.partials[c.name],a}function h(a,b,c){var d=c.data&&c.data["partial-block"];c.partial=!0,c.ids&&(c.data.contextPath=c.ids[0]||c.data.contextPath);var e=void 0;if(c.fn&&c.fn!==i&&!function(){c.data=v.createFrame(c.data);var a=c.fn;e=c.data["partial-block"]=function(b){var c=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];return c.data=v.createFrame(c.data),c.data["partial-block"]=d,a(b,c)},a.partials&&(c.partials=s.extend({},c.partials,a.partials))}(),void 0===a&&e&&(a=e),void 0===a)throw new u["default"]("The partial "+c.name+" could not be found");if(a instanceof Function)return a(b,c)}function i(){return""}function j(a,b){return b&&"root"in b||(b=b?v.createFrame(b):{},b.root=a),b}function k(a,b,c,d,e,f){if(a.decorator){var g={};b=a.decorator(b,g,c,d&&d[0],e,f,d),s.extend(b,g)}return b}function l(a,b){o(a).forEach(function(c){var d=a[c];a[c]=m(d,b)})}function m(a,b){var c=b.lookupProperty;return x.wrapHelper(a,function(a){return s.extend({lookupProperty:c},a)})}var n=c(38)["default"],o=c(12)["default"],p=c(1)["default"],q=c(2)["default"];b.__esModule=!0,b.checkRevision=d,b.template=e,b.wrapProgram=f,b.resolvePartial=g,b.invokePartial=h,b.noop=i;var r=c(4),s=p(r),t=c(5),u=q(t),v=c(3),w=c(9),x=c(42),y=c(32)},function(a,b,c){a.exports={"default":c(39),__esModule:!0}},function(a,b,c){c(40),a.exports=c(20).Object.seal},function(a,b,c){var d=c(41);c(17)("seal",function(a){return function(b){return a&&d(b)?a(b):b}})},function(a,b){a.exports=function(a){return"object"==typeof a?null!==a:"function"==typeof a}},function(a,b){"use strict";function c(a,b){if("function"!=typeof a)return a;var c=function(){var c=arguments[arguments.length-1];return arguments[arguments.length-1]=b(c),a.apply(this,arguments)};return c}b.__esModule=!0,b.wrapHelper=c},function(a,b){(function(c){"use strict";b.__esModule=!0,b["default"]=function(a){var b="undefined"!=typeof c?c:window,d=b.Handlebars;a.noConflict=function(){return b.Handlebars===a&&(b.Handlebars=d),a}},a.exports=b["default"]}).call(b,function(){return this}())}])});
/*!

JSZip v3.2.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JSZip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":30,"./utils":32}],2:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":7,"./stream/GenericWorker":28}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};

},{"./utils":32}],5:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],6:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":37}],7:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":28,"./utils":32,"pako":38}],8:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":3,"./ZipFileWorker":8}],10:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.2.0";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":28,"../utils":32}],13:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":32,"readable-stream":16}],14:[function(require,module,exports){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
        } else {
            if (typeof data === "number") {
                // Safeguard for old Node.js versions. On newer versions,
                // Buffer.from(number) / Buffer(number, encoding) already throw.
                throw new Error("The \"data\" argument must not be a number");
            }
            return new Buffer(data, encoding);
        }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

},{}],15:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":undefined}],17:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":32,"./DataReader":18}],18:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":32}],19:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":32,"./DataReader":18}],21:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":32,"./ArrayReader":17}],22:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],24:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":32,"./GenericWorker":28}],25:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":32,"./GenericWorker":28}],27:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":32,"./GenericWorker":28}],28:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(require,module,exports){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

},{"readable-stream":16}],31:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('set-immediate-shim');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("Can't read the data of '" + name + "'. Is it " +
                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null, outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],37:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes () {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no () {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":36}],38:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],42:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":41}],43:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],44:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],45:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],46:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],48:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],49:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":41}],51:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],52:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":41}],53:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],54:[function(require,module,exports){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

},{}]},{},[10])(10)
});
var ol=function(t){var e={};function i(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(r,n,function(e){return t[e]}.bind(null,n));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=5)}([function(t,e,i){"use strict";t.exports=n,t.exports.default=n;var r=i(4);function n(t,e){if(!(this instanceof n))return new n(t,e);this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&this._initFormat(e),this.clear()}function o(t,e,i){if(!i)return e.indexOf(t);for(var r=0;r<e.length;r++)if(i(t,e[r]))return r;return-1}function s(t,e){a(t,0,t.children.length,e,t)}function a(t,e,i,r,n){n||(n=g(null)),n.minX=1/0,n.minY=1/0,n.maxX=-1/0,n.maxY=-1/0;for(var o,s=e;s<i;s++)o=t.children[s],h(n,t.leaf?r(o):o);return n}function h(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function l(t,e){return t.minX-e.minX}function u(t,e){return t.minY-e.minY}function p(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function c(t){return t.maxX-t.minX+(t.maxY-t.minY)}function d(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function f(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function g(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function _(t,e,i,n,o){for(var s,a=[e,i];a.length;)(i=a.pop())-(e=a.pop())<=n||(s=e+Math.ceil((i-e)/n/2)*n,r(t,s,e,i,o),a.push(e,s,s,i))}n.prototype={all:function(){return this._all(this.data,[])},search:function(t){var e=this.data,i=[],r=this.toBBox;if(!f(t,e))return i;for(var n,o,s,a,h=[];e;){for(n=0,o=e.children.length;n<o;n++)s=e.children[n],f(t,a=e.leaf?r(s):s)&&(e.leaf?i.push(s):d(t,a)?this._all(s,i):h.push(s));e=h.pop()}return i},collides:function(t){var e=this.data,i=this.toBBox;if(!f(t,e))return!1;for(var r,n,o,s,a=[];e;){for(r=0,n=e.children.length;r<n;r++)if(o=e.children[r],f(t,s=e.leaf?i(o):o)){if(e.leaf||d(t,s))return!0;a.push(o)}e=a.pop()}return!1},load:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var e=0,i=t.length;e<i;e++)this.insert(t[e]);return this}var r=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===r.height)this._splitRoot(this.data,r);else{if(this.data.height<r.height){var n=this.data;this.data=r,r=n}this._insert(r,this.data.height-r.height-1,!0)}else this.data=r;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=g([]),this},remove:function(t,e){if(!t)return this;for(var i,r,n,s,a=this.data,h=this.toBBox(t),l=[],u=[];a||l.length;){if(a||(a=l.pop(),r=l[l.length-1],i=u.pop(),s=!0),a.leaf&&-1!==(n=o(t,a.children,e)))return a.children.splice(n,1),l.push(a),this._condense(l),this;s||a.leaf||!d(a,h)?r?(i++,a=r.children[i],s=!1):a=null:(l.push(a),u.push(i),i=0,r=a,a=a.children[0])}return this},toBBox:function(t){return t},compareMinX:l,compareMinY:u,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,e){for(var i=[];t;)t.leaf?e.push.apply(e,t.children):i.push.apply(i,t.children),t=i.pop();return e},_build:function(t,e,i,r){var n,o=i-e+1,a=this._maxEntries;if(o<=a)return s(n=g(t.slice(e,i+1)),this.toBBox),n;r||(r=Math.ceil(Math.log(o)/Math.log(a)),a=Math.ceil(o/Math.pow(a,r-1))),(n=g([])).leaf=!1,n.height=r;var h,l,u,p,c=Math.ceil(o/a),d=c*Math.ceil(Math.sqrt(a));for(_(t,e,i,d,this.compareMinX),h=e;h<=i;h+=d)for(_(t,h,u=Math.min(h+d-1,i),c,this.compareMinY),l=h;l<=u;l+=c)p=Math.min(l+c-1,u),n.children.push(this._build(t,l,p,r-1));return s(n,this.toBBox),n},_chooseSubtree:function(t,e,i,r){for(var n,o,s,a,h,l,u,c,d,f;r.push(e),!e.leaf&&r.length-1!==i;){for(u=c=1/0,n=0,o=e.children.length;n<o;n++)h=p(s=e.children[n]),d=t,f=s,(l=(Math.max(f.maxX,d.maxX)-Math.min(f.minX,d.minX))*(Math.max(f.maxY,d.maxY)-Math.min(f.minY,d.minY))-h)<c?(c=l,u=h<u?h:u,a=s):l===c&&h<u&&(u=h,a=s);e=a||e.children[0]}return e},_insert:function(t,e,i){var r=this.toBBox,n=i?t:r(t),o=[],s=this._chooseSubtree(n,this.data,e,o);for(s.children.push(t),h(s,n);e>=0&&o[e].children.length>this._maxEntries;)this._split(o,e),e--;this._adjustParentBBoxes(n,o,e)},_split:function(t,e){var i=t[e],r=i.children.length,n=this._minEntries;this._chooseSplitAxis(i,n,r);var o=this._chooseSplitIndex(i,n,r),a=g(i.children.splice(o,i.children.length-o));a.height=i.height,a.leaf=i.leaf,s(i,this.toBBox),s(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)},_splitRoot:function(t,e){this.data=g([t,e]),this.data.height=t.height+1,this.data.leaf=!1,s(this.data,this.toBBox)},_chooseSplitIndex:function(t,e,i){var r,n,o,s,h,l,u,c,d,f,g,_,y,v;for(l=u=1/0,r=e;r<=i-e;r++)n=a(t,0,r,this.toBBox),o=a(t,r,i,this.toBBox),d=n,f=o,g=void 0,_=void 0,y=void 0,v=void 0,g=Math.max(d.minX,f.minX),_=Math.max(d.minY,f.minY),y=Math.min(d.maxX,f.maxX),v=Math.min(d.maxY,f.maxY),s=Math.max(0,y-g)*Math.max(0,v-_),h=p(n)+p(o),s<l?(l=s,c=r,u=h<u?h:u):s===l&&h<u&&(u=h,c=r);return c},_chooseSplitAxis:function(t,e,i){var r=t.leaf?this.compareMinX:l,n=t.leaf?this.compareMinY:u;this._allDistMargin(t,e,i,r)<this._allDistMargin(t,e,i,n)&&t.children.sort(r)},_allDistMargin:function(t,e,i,r){t.children.sort(r);var n,o,s=this.toBBox,l=a(t,0,e,s),u=a(t,i-e,i,s),p=c(l)+c(u);for(n=e;n<i-e;n++)o=t.children[n],h(l,t.leaf?s(o):o),p+=c(l);for(n=i-e-1;n>=e;n--)o=t.children[n],h(u,t.leaf?s(o):o),p+=c(u);return p},_adjustParentBBoxes:function(t,e,i){for(var r=i;r>=0;r--)h(e[r],t)},_condense:function(t){for(var e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children).splice(e.indexOf(t[i]),1):this.clear():s(t[i],this.toBBox)},_initFormat:function(t){var e=["return a"," - b",";"];this.compareMinX=new Function("a","b",e.join(t[0])),this.compareMinY=new Function("a","b",e.join(t[1])),this.toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}}},,,,function(t,e,i){t.exports=function(){"use strict";function t(t,e,i){var r=t[e];t[e]=t[i],t[i]=r}function e(t,e){return t<e?-1:t>e?1:0}return function(i,r,n,o,s){!function e(i,r,n,o,s){for(;o>n;){if(o-n>600){var a=o-n+1,h=r-n+1,l=Math.log(a),u=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*u*(a-u)/a)*(h-a/2<0?-1:1),c=Math.max(n,Math.floor(r-h*u/a+p)),d=Math.min(o,Math.floor(r+(a-h)*u/a+p));e(i,r,c,d,s)}var f=i[r],g=n,_=o;for(t(i,n,r),s(i[o],f)>0&&t(i,n,o);g<_;){for(t(i,g,_),g++,_--;s(i[g],f)<0;)g++;for(;s(i[_],f)>0;)_--}0===s(i[n],f)?t(i,n,_):t(i,++_,o),_<=r&&(n=_+1),r<=_&&(o=_-1)}}(i,r,n||0,o||i.length-1,s||e)}}()},function(t,e,i){"use strict";function r(){return function(){throw new Error("Unimplemented abstract method.")}()}i.r(e);var n=0;function o(t){return t.ol_uid||(t.ol_uid=String(++n))}var s="5.3.3",a=function(t){function e(e){var i="Assertion failed. See https://openlayers.org/en/"+("latest"===s?s:"v"+s.split("-")[0])+"/doc/errors/#"+e+" for details.";t.call(this,i),this.code=e,this.name="AssertionError",this.message=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),h={ADD:"add",REMOVE:"remove"},l="propertychange",u="function"==typeof Object.assign?Object.assign:function(t,e){var i=arguments;if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var r=Object(t),n=1,o=arguments.length;n<o;++n){var s=i[n];if(null!=s)for(var a in s)s.hasOwnProperty(a)&&(r[a]=s[a])}return r};function p(t){for(var e in t)delete t[e]}function c(t){var e=[];for(var i in t)e.push(t[i]);return e}function d(t){var e;for(e in t)return!1;return!e}function f(t,e,i,r){for(var n,o=0,s=t.length;o<s;++o)if((n=t[o]).listener===e&&n.bindTo===i)return r&&(n.deleteIndex=o),n}function g(t,e){var i=_(t);return i?i[e]:void 0}function _(t,e){var i=t.ol_lm;return!i&&e&&(i=t.ol_lm={}),i}function y(t,e){var i=g(t,e);if(i){for(var r=0,n=i.length;r<n;++r)t.removeEventListener(e,i[r].boundListener),p(i[r]);i.length=0;var o=_(t);o&&(delete o[e],0===Object.keys(o).length&&function(t){delete t.ol_lm}(t))}}function v(t,e,i,r,n){var o=_(t,!0),s=o[e];s||(s=o[e]=[]);var a=f(s,i,r,!1);return a?n||(a.callOnce=!1):(a={bindTo:r,callOnce:!!n,listener:i,target:t,type:e},t.addEventListener(e,function(t){var e=function(e){var i=t.listener,r=t.bindTo||t.target;return t.callOnce&&S(t),i.call(r,e)};return t.boundListener=e,e}(a)),s.push(a)),a}function m(t,e,i,r){return v(t,e,i,r,!0)}function E(t,e,i,r){var n=g(t,e);if(n){var o=f(n,i,r,!0);o&&S(o)}}function S(t){if(t&&t.target){t.target.removeEventListener(t.type,t.boundListener);var e=g(t.target,t.type);if(e){var i="deleteIndex"in t?t.deleteIndex:e.indexOf(t);-1!==i&&e.splice(i,1),0===e.length&&y(t.target,t.type)}p(t)}}var T=function(){this.disposed_=!1};T.prototype.dispose=function(){this.disposed_||(this.disposed_=!0,this.disposeInternal())},T.prototype.disposeInternal=function(){};var R=T;function C(){return!0}function x(){return!1}function w(){}var I=function(t){this.propagationStopped,this.type=t,this.target=null};function O(t){t.stopPropagation()}I.prototype.preventDefault=function(){this.propagationStopped=!0},I.prototype.stopPropagation=function(){this.propagationStopped=!0};var L=I,P=function(t){function e(){t.call(this),this.pendingRemovals_={},this.dispatching_={},this.listeners_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addEventListener=function(t,e){var i=this.listeners_[t];i||(i=this.listeners_[t]=[]),-1===i.indexOf(e)&&i.push(e)},e.prototype.dispatchEvent=function(t){var e="string"==typeof t?new L(t):t,i=e.type;e.target=this;var r,n=this.listeners_[i];if(n){i in this.dispatching_||(this.dispatching_[i]=0,this.pendingRemovals_[i]=0),++this.dispatching_[i];for(var o=0,s=n.length;o<s;++o)if(!1===n[o].call(this,e)||e.propagationStopped){r=!1;break}if(--this.dispatching_[i],0===this.dispatching_[i]){var a=this.pendingRemovals_[i];for(delete this.pendingRemovals_[i];a--;)this.removeEventListener(i,w);delete this.dispatching_[i]}return r}},e.prototype.disposeInternal=function(){!function(t){var e=_(t);if(e)for(var i in e)y(t,i)}(this)},e.prototype.getListeners=function(t){return this.listeners_[t]},e.prototype.hasListener=function(t){return t?t in this.listeners_:Object.keys(this.listeners_).length>0},e.prototype.removeEventListener=function(t,e){var i=this.listeners_[t];if(i){var r=i.indexOf(e);t in this.pendingRemovals_?(i[r]=w,++this.pendingRemovals_[t]):(i.splice(r,1),0===i.length&&delete this.listeners_[t])}},e}(R),M={CHANGE:"change",CLEAR:"clear",CONTEXTMENU:"contextmenu",CLICK:"click",DBLCLICK:"dblclick",DRAGENTER:"dragenter",DRAGOVER:"dragover",DROP:"drop",ERROR:"error",KEYDOWN:"keydown",KEYPRESS:"keypress",LOAD:"load",MOUSEDOWN:"mousedown",MOUSEMOVE:"mousemove",MOUSEOUT:"mouseout",MOUSEUP:"mouseup",MOUSEWHEEL:"mousewheel",MSPOINTERDOWN:"MSPointerDown",RESIZE:"resize",TOUCHSTART:"touchstart",TOUCHMOVE:"touchmove",TOUCHEND:"touchend",WHEEL:"wheel"};var F=function(t){function e(){t.call(this),this.revision_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){++this.revision_,this.dispatchEvent(M.CHANGE)},e.prototype.getRevision=function(){return this.revision_},e.prototype.on=function(t,e){if(Array.isArray(t)){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=v(this,t[n],e);return r}return v(this,t,e)},e.prototype.once=function(t,e){if(Array.isArray(t)){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=m(this,t[n],e);return r}return m(this,t,e)},e.prototype.un=function(t,e){if(Array.isArray(t))for(var i=0,r=t.length;i<r;++i)E(this,t[i],e);else E(this,t,e)},e}(P),b=function(t){function e(e,i,r){t.call(this,e),this.key=i,this.oldValue=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),N={};function A(t){return N.hasOwnProperty(t)?N[t]:N[t]="change:"+t}var G=function(t){function e(e){t.call(this),o(this),this.values_={},void 0!==e&&this.setProperties(e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){var e;return this.values_.hasOwnProperty(t)&&(e=this.values_[t]),e},e.prototype.getKeys=function(){return Object.keys(this.values_)},e.prototype.getProperties=function(){return u({},this.values_)},e.prototype.notify=function(t,e){var i;i=A(t),this.dispatchEvent(new b(i,t,e)),i=l,this.dispatchEvent(new b(i,t,e))},e.prototype.set=function(t,e,i){if(i)this.values_[t]=e;else{var r=this.values_[t];this.values_[t]=e,r!==e&&this.notify(t,r)}},e.prototype.setProperties=function(t,e){for(var i in t)this.set(i,t[i],e)},e.prototype.unset=function(t,e){if(t in this.values_){var i=this.values_[t];delete this.values_[t],e||this.notify(t,i)}},e}(F),D="length",k=function(t){function e(e,i){t.call(this,e),this.element=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),Y=function(t){function e(e,i){t.call(this);var r=i||{};if(this.unique_=!!r.unique,this.array_=e||[],this.unique_)for(var n=0,o=this.array_.length;n<o;++n)this.assertUnique_(this.array_[n],n);this.updateLength_()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clear=function(){for(;this.getLength()>0;)this.pop()},e.prototype.extend=function(t){for(var e=0,i=t.length;e<i;++e)this.push(t[e]);return this},e.prototype.forEach=function(t){for(var e=this.array_,i=0,r=e.length;i<r;++i)t(e[i],i,e)},e.prototype.getArray=function(){return this.array_},e.prototype.item=function(t){return this.array_[t]},e.prototype.getLength=function(){return this.get(D)},e.prototype.insertAt=function(t,e){this.unique_&&this.assertUnique_(e),this.array_.splice(t,0,e),this.updateLength_(),this.dispatchEvent(new k(h.ADD,e))},e.prototype.pop=function(){return this.removeAt(this.getLength()-1)},e.prototype.push=function(t){this.unique_&&this.assertUnique_(t);var e=this.getLength();return this.insertAt(e,t),this.getLength()},e.prototype.remove=function(t){for(var e=this.array_,i=0,r=e.length;i<r;++i)if(e[i]===t)return this.removeAt(i)},e.prototype.removeAt=function(t){var e=this.array_[t];return this.array_.splice(t,1),this.updateLength_(),this.dispatchEvent(new k(h.REMOVE,e)),e},e.prototype.setAt=function(t,e){var i=this.getLength();if(t<i){this.unique_&&this.assertUnique_(e,t);var r=this.array_[t];this.array_[t]=e,this.dispatchEvent(new k(h.REMOVE,r)),this.dispatchEvent(new k(h.ADD,e))}else{for(var n=i;n<t;++n)this.insertAt(n,void 0);this.insertAt(t,e)}},e.prototype.updateLength_=function(){this.set(D,this.array_.length)},e.prototype.assertUnique_=function(t,e){for(var i=0,r=this.array_.length;i<r;++i)if(this.array_[i]===t&&i!==e)throw new a(58)},e}(G),U=function(t){function e(e,i,r){t.call(this,e),this.map=i,this.frameState=void 0!==r?r:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),j=function(t){function e(e,i,r,n,o){t.call(this,e,i,o),this.originalEvent=r,this.pixel=i.getEventPixel(r),this.coordinate=i.getCoordinateFromPixel(this.pixel),this.dragging=void 0!==n&&n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.preventDefault=function(){t.prototype.preventDefault.call(this),this.originalEvent.preventDefault()},e.prototype.stopPropagation=function(){t.prototype.stopPropagation.call(this),this.originalEvent.stopPropagation()},e}(U),X="undefined"!=typeof navigator?navigator.userAgent.toLowerCase():"",B=-1!==X.indexOf("firefox"),V=-1!==X.indexOf("safari")&&-1==X.indexOf("chrom"),W=-1!==X.indexOf("webkit")&&-1==X.indexOf("edge"),K=-1!==X.indexOf("macintosh"),z=window.devicePixelRatio||1,Z=function(){var t=!1;try{t=!!document.createElement("canvas").getContext("2d").setLineDash}catch(t){}return t}(),H=(navigator,"ontouchstart"in window),q="PointerEvent"in window,J=!!navigator.msPointerEnabled,Q={SINGLECLICK:"singleclick",CLICK:M.CLICK,DBLCLICK:M.DBLCLICK,POINTERDRAG:"pointerdrag",POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"},$=function(t){function e(e,i,r,n,o){t.call(this,e,i,r.originalEvent,n,o),this.pointerEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(j),tt={POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"},et=function(t,e){this.dispatcher=t,this.mapping_=e};et.prototype.getEvents=function(){return Object.keys(this.mapping_)},et.prototype.getHandlerForEvent=function(t){return this.mapping_[t]};var it=et,rt=1,nt="mouse";function ot(t){if(!this.isEventSimulatedFromTouch_(t)){rt.toString()in this.pointerMap&&this.cancel(t);var e=ut(t,this.dispatcher);this.pointerMap[rt.toString()]=t,this.dispatcher.down(e,t)}}function st(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.move(e,t)}}function at(t){if(!this.isEventSimulatedFromTouch_(t)){var e=this.pointerMap[rt.toString()];if(e&&e.button===t.button){var i=ut(t,this.dispatcher);this.dispatcher.up(i,t),this.cleanupMouse()}}}function ht(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.enterOver(e,t)}}function lt(t){if(!this.isEventSimulatedFromTouch_(t)){var e=ut(t,this.dispatcher);this.dispatcher.leaveOut(e,t)}}function ut(t,e){var i=e.cloneEvent(t,t),r=i.preventDefault;return i.preventDefault=function(){t.preventDefault(),r()},i.pointerId=rt,i.isPrimary=!0,i.pointerType=nt,i}var pt=function(t){function e(e){var i={mousedown:ot,mousemove:st,mouseup:at,mouseover:ht,mouseout:lt};t.call(this,e,i),this.pointerMap=e.pointerMap,this.lastTouches=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isEventSimulatedFromTouch_=function(t){for(var e=this.lastTouches,i=t.clientX,r=t.clientY,n=0,o=e.length,s=void 0;n<o&&(s=e[n]);n++){var a=Math.abs(i-s[0]),h=Math.abs(r-s[1]);if(a<=25&&h<=25)return!0}return!1},e.prototype.cancel=function(t){var e=ut(t,this.dispatcher);this.dispatcher.cancel(e,t),this.cleanupMouse()},e.prototype.cleanupMouse=function(){delete this.pointerMap[rt.toString()]},e}(it),ct=["","unavailable","touch","pen","mouse"];function dt(t){this.pointerMap[t.pointerId.toString()]=t;var e=this.prepareEvent_(t);this.dispatcher.down(e,t)}function ft(t){var e=this.prepareEvent_(t);this.dispatcher.move(e,t)}function gt(t){var e=this.prepareEvent_(t);this.dispatcher.up(e,t),this.cleanup(t.pointerId)}function _t(t){var e=this.prepareEvent_(t);this.dispatcher.leaveOut(e,t)}function yt(t){var e=this.prepareEvent_(t);this.dispatcher.enterOver(e,t)}function vt(t){var e=this.prepareEvent_(t);this.dispatcher.cancel(e,t),this.cleanup(t.pointerId)}function mt(t){var e=this.dispatcher.makeEvent("lostpointercapture",t,t);this.dispatcher.dispatchEvent(e)}function Et(t){var e=this.dispatcher.makeEvent("gotpointercapture",t,t);this.dispatcher.dispatchEvent(e)}var St=function(t){function e(e){var i={MSPointerDown:dt,MSPointerMove:ft,MSPointerUp:gt,MSPointerOut:_t,MSPointerOver:yt,MSPointerCancel:vt,MSGotPointerCapture:Et,MSLostPointerCapture:mt};t.call(this,e,i),this.pointerMap=e.pointerMap}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.prepareEvent_=function(t){var e=t;return"number"==typeof t.pointerType&&((e=this.dispatcher.cloneEvent(t,t)).pointerType=ct[t.pointerType]),e},e.prototype.cleanup=function(t){delete this.pointerMap[t.toString()]},e}(it);function Tt(t){this.dispatcher.fireNativeEvent(t)}function Rt(t){this.dispatcher.fireNativeEvent(t)}function Ct(t){this.dispatcher.fireNativeEvent(t)}function xt(t){this.dispatcher.fireNativeEvent(t)}function wt(t){this.dispatcher.fireNativeEvent(t)}function It(t){this.dispatcher.fireNativeEvent(t)}function Ot(t){this.dispatcher.fireNativeEvent(t)}function Lt(t){this.dispatcher.fireNativeEvent(t)}var Pt=function(t){function e(e){var i={pointerdown:Tt,pointermove:Rt,pointerup:Ct,pointerout:xt,pointerover:wt,pointercancel:It,gotpointercapture:Lt,lostpointercapture:Ot};t.call(this,e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(it),Mt=!1,Ft=function(t){function e(e,i,r){t.call(this,e),this.originalEvent=i;var n=r||{};this.buttons=function(t){var e;if(t.buttons||Mt)e=t.buttons;else switch(t.which){case 1:e=1;break;case 2:e=4;break;case 3:e=2;break;default:e=0}return e}(n),this.pressure=function(t,e){var i=0;i=t.pressure?t.pressure:e?.5:0;return i}(n,this.buttons),this.bubbles="bubbles"in n&&n.bubbles,this.cancelable="cancelable"in n&&n.cancelable,this.view="view"in n?n.view:null,this.detail="detail"in n?n.detail:null,this.screenX="screenX"in n?n.screenX:0,this.screenY="screenY"in n?n.screenY:0,this.clientX="clientX"in n?n.clientX:0,this.clientY="clientY"in n?n.clientY:0,this.ctrlKey="ctrlKey"in n&&n.ctrlKey,this.altKey="altKey"in n&&n.altKey,this.shiftKey="shiftKey"in n&&n.shiftKey,this.metaKey="metaKey"in n&&n.metaKey,this.button="button"in n?n.button:0,this.relatedTarget="relatedTarget"in n?n.relatedTarget:null,this.pointerId="pointerId"in n?n.pointerId:0,this.width="width"in n?n.width:0,this.height="height"in n?n.height:0,this.tiltX="tiltX"in n?n.tiltX:0,this.tiltY="tiltY"in n?n.tiltY:0,this.pointerType="pointerType"in n?n.pointerType:"",this.hwTimestamp="hwTimestamp"in n?n.hwTimestamp:0,this.isPrimary="isPrimary"in n&&n.isPrimary,i.preventDefault&&(this.preventDefault=function(){i.preventDefault()})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);!function(){try{var t=new MouseEvent("click",{buttons:1});Mt=1===t.buttons}catch(t){}}();var bt=Ft;function Nt(t,e){return t>e?1:t<e?-1:0}function At(t,e){return t.indexOf(e)>=0}function Gt(t,e,i){var r,n=t.length;if(t[0]<=e)return 0;if(e<=t[n-1])return n-1;if(i>0){for(r=1;r<n;++r)if(t[r]<e)return r-1}else if(i<0){for(r=1;r<n;++r)if(t[r]<=e)return r}else for(r=1;r<n;++r){if(t[r]==e)return r;if(t[r]<e)return t[r-1]-e<e-t[r]?r-1:r}return n-1}function Dt(t,e,i){for(;e<i;){var r=t[e];t[e]=t[i],t[i]=r,++e,--i}}function kt(t,e){for(var i=Array.isArray(e)?e:[e],r=i.length,n=0;n<r;n++)t[t.length]=i[n]}function Yt(t,e){for(var i,r=t.length>>>0,n=0;n<r;n++)if(e(i=t[n],n,t))return i;return null}function Ut(t,e){var i=t.length;if(i!==e.length)return!1;for(var r=0;r<i;r++)if(t[r]!==e[r])return!1;return!0}function jt(t,e){var i;return!t.every(function(r,n){return i=n,!e(r,n,t)})?i:-1}function Xt(t){this.vacuumTouches_(t),this.setPrimaryTouch_(t.changedTouches[0]),this.dedupSynthMouse_(t),this.clickCount_++,this.processTouches_(t,this.overDown_)}function Bt(t){this.processTouches_(t,this.moveOverOut_)}function Vt(t){this.dedupSynthMouse_(t),this.processTouches_(t,this.upOut_)}function Wt(t){this.processTouches_(t,this.cancelOut_)}var Kt=function(t){function e(e,i){var r={touchstart:Xt,touchmove:Bt,touchend:Vt,touchcancel:Wt};t.call(this,e,r),this.pointerMap=e.pointerMap,this.mouseSource=i,this.firstTouchId_=void 0,this.clickCount_=0,this.resetId_,this.dedupTimeout_=2500}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isPrimaryTouch_=function(t){return this.firstTouchId_===t.identifier},e.prototype.setPrimaryTouch_=function(t){var e=Object.keys(this.pointerMap).length;(0===e||1===e&&rt.toString()in this.pointerMap)&&(this.firstTouchId_=t.identifier,this.cancelResetClickCount_())},e.prototype.removePrimaryPointer_=function(t){t.isPrimary&&(this.firstTouchId_=void 0,this.resetClickCount_())},e.prototype.resetClickCount_=function(){this.resetId_=setTimeout(this.resetClickCountHandler_.bind(this),200)},e.prototype.resetClickCountHandler_=function(){this.clickCount_=0,this.resetId_=void 0},e.prototype.cancelResetClickCount_=function(){void 0!==this.resetId_&&clearTimeout(this.resetId_)},e.prototype.touchToPointer_=function(t,e){var i=this.dispatcher.cloneEvent(t,e);return i.pointerId=e.identifier+2,i.bubbles=!0,i.cancelable=!0,i.detail=this.clickCount_,i.button=0,i.buttons=1,i.width=e.radiusX||0,i.height=e.radiusY||0,i.pressure=e.force||.5,i.isPrimary=this.isPrimaryTouch_(e),i.pointerType="touch",i.clientX=e.clientX,i.clientY=e.clientY,i.screenX=e.screenX,i.screenY=e.screenY,i},e.prototype.processTouches_=function(t,e){var i=Array.prototype.slice.call(t.changedTouches),r=i.length;function n(){t.preventDefault()}for(var o=0;o<r;++o){var s=this.touchToPointer_(t,i[o]);s.preventDefault=n,e.call(this,t,s)}},e.prototype.findTouch_=function(t,e){for(var i=t.length,r=0;r<i;r++){if(t[r].identifier===e)return!0}return!1},e.prototype.vacuumTouches_=function(t){var e=t.touches,i=Object.keys(this.pointerMap),r=i.length;if(r>=e.length){for(var n=[],o=0;o<r;++o){var s=Number(i[o]),a=this.pointerMap[s];s==rt||this.findTouch_(e,s-2)||n.push(a.out)}for(var h=0;h<n.length;++h)this.cancelOut_(t,n[h])}},e.prototype.overDown_=function(t,e){this.pointerMap[e.pointerId]={target:e.target,out:e,outTarget:e.target},this.dispatcher.over(e,t),this.dispatcher.enter(e,t),this.dispatcher.down(e,t)},e.prototype.moveOverOut_=function(t,e){var i=e,r=this.pointerMap[i.pointerId];if(r){var n=r.out,o=r.outTarget;this.dispatcher.move(i,t),n&&o!==i.target&&(n.relatedTarget=i.target,i.relatedTarget=o,n.target=o,i.target?(this.dispatcher.leaveOut(n,t),this.dispatcher.enterOver(i,t)):(i.target=o,i.relatedTarget=null,this.cancelOut_(t,i))),r.out=i,r.outTarget=i.target}},e.prototype.upOut_=function(t,e){this.dispatcher.up(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},e.prototype.cancelOut_=function(t,e){this.dispatcher.cancel(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},e.prototype.cleanUpPointer_=function(t){delete this.pointerMap[t.pointerId],this.removePrimaryPointer_(t)},e.prototype.dedupSynthMouse_=function(t){var e=this.mouseSource.lastTouches,i=t.changedTouches[0];if(this.isPrimaryTouch_(i)){var r=[i.clientX,i.clientY];e.push(r),setTimeout(function(){var t,i,n;i=r,n=(t=e).indexOf(i),n>-1&&t.splice(n,1)},this.dedupTimeout_)}},e}(it),zt=[["bubbles",!1],["cancelable",!1],["view",null],["detail",null],["screenX",0],["screenY",0],["clientX",0],["clientY",0],["ctrlKey",!1],["altKey",!1],["shiftKey",!1],["metaKey",!1],["button",0],["relatedTarget",null],["buttons",0],["pointerId",0],["width",0],["height",0],["pressure",0],["tiltX",0],["tiltY",0],["pointerType",""],["hwTimestamp",0],["isPrimary",!1],["type",""],["target",null],["currentTarget",null],["which",0]],Zt=function(t){function e(e){t.call(this),this.element_=e,this.pointerMap={},this.eventMap_={},this.eventSourceList_=[],this.registerSources()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.registerSources=function(){if(q)this.registerSource("native",new Pt(this));else if(J)this.registerSource("ms",new St(this));else{var t=new pt(this);this.registerSource("mouse",t),H&&this.registerSource("touch",new Kt(this,t))}this.register_()},e.prototype.registerSource=function(t,e){var i=e,r=i.getEvents();r&&(r.forEach(function(t){var e=i.getHandlerForEvent(t);e&&(this.eventMap_[t]=e.bind(i))}.bind(this)),this.eventSourceList_.push(i))},e.prototype.register_=function(){for(var t=this.eventSourceList_.length,e=0;e<t;e++){var i=this.eventSourceList_[e];this.addEvents_(i.getEvents())}},e.prototype.unregister_=function(){for(var t=this.eventSourceList_.length,e=0;e<t;e++){var i=this.eventSourceList_[e];this.removeEvents_(i.getEvents())}},e.prototype.eventHandler_=function(t){var e=t.type,i=this.eventMap_[e];i&&i(t)},e.prototype.addEvents_=function(t){t.forEach(function(t){v(this.element_,t,this.eventHandler_,this)}.bind(this))},e.prototype.removeEvents_=function(t){t.forEach(function(t){E(this.element_,t,this.eventHandler_,this)}.bind(this))},e.prototype.cloneEvent=function(t,e){for(var i={},r=0,n=zt.length;r<n;r++){var o=zt[r][0];i[o]=t[o]||e[o]||zt[r][1]}return i},e.prototype.down=function(t,e){this.fireEvent(tt.POINTERDOWN,t,e)},e.prototype.move=function(t,e){this.fireEvent(tt.POINTERMOVE,t,e)},e.prototype.up=function(t,e){this.fireEvent(tt.POINTERUP,t,e)},e.prototype.enter=function(t,e){t.bubbles=!1,this.fireEvent(tt.POINTERENTER,t,e)},e.prototype.leave=function(t,e){t.bubbles=!1,this.fireEvent(tt.POINTERLEAVE,t,e)},e.prototype.over=function(t,e){t.bubbles=!0,this.fireEvent(tt.POINTEROVER,t,e)},e.prototype.out=function(t,e){t.bubbles=!0,this.fireEvent(tt.POINTEROUT,t,e)},e.prototype.cancel=function(t,e){this.fireEvent(tt.POINTERCANCEL,t,e)},e.prototype.leaveOut=function(t,e){this.out(t,e),this.contains_(t.target,t.relatedTarget)||this.leave(t,e)},e.prototype.enterOver=function(t,e){this.over(t,e),this.contains_(t.target,t.relatedTarget)||this.enter(t,e)},e.prototype.contains_=function(t,e){return!(!t||!e)&&t.contains(e)},e.prototype.makeEvent=function(t,e,i){return new bt(t,i,e)},e.prototype.fireEvent=function(t,e,i){var r=this.makeEvent(t,e,i);this.dispatchEvent(r)},e.prototype.fireNativeEvent=function(t){var e=this.makeEvent(t.type,t,t);this.dispatchEvent(e)},e.prototype.wrapMouseEvent=function(t,e){return this.makeEvent(t,ut(e,this),e)},e.prototype.disposeInternal=function(){this.unregister_(),t.prototype.disposeInternal.call(this)},e}(P),Ht=function(t){function e(e,i){t.call(this),this.map_=e,this.clickTimeoutId_,this.dragging_=!1,this.dragListenerKeys_=[],this.moveTolerance_=i?i*z:z,this.down_=null;var r=this.map_.getViewport();this.activePointers_=0,this.trackedTouches_={},this.pointerEventHandler_=new Zt(r),this.documentPointerEventHandler_=null,this.pointerdownListenerKey_=v(this.pointerEventHandler_,tt.POINTERDOWN,this.handlePointerDown_,this),this.relayedListenerKey_=v(this.pointerEventHandler_,tt.POINTERMOVE,this.relayEvent_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.emulateClick_=function(t){var e=new $(Q.CLICK,this.map_,t);this.dispatchEvent(e),void 0!==this.clickTimeoutId_?(clearTimeout(this.clickTimeoutId_),this.clickTimeoutId_=void 0,e=new $(Q.DBLCLICK,this.map_,t),this.dispatchEvent(e)):this.clickTimeoutId_=setTimeout(function(){this.clickTimeoutId_=void 0;var e=new $(Q.SINGLECLICK,this.map_,t);this.dispatchEvent(e)}.bind(this),250)},e.prototype.updateActivePointers_=function(t){var e=t;e.type==Q.POINTERUP||e.type==Q.POINTERCANCEL?delete this.trackedTouches_[e.pointerId]:e.type==Q.POINTERDOWN&&(this.trackedTouches_[e.pointerId]=!0),this.activePointers_=Object.keys(this.trackedTouches_).length},e.prototype.handlePointerUp_=function(t){this.updateActivePointers_(t);var e=new $(Q.POINTERUP,this.map_,t);this.dispatchEvent(e),e.propagationStopped||this.dragging_||!this.isMouseActionButton_(t)||this.emulateClick_(this.down_),0===this.activePointers_&&(this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.dragging_=!1,this.down_=null,this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null)},e.prototype.isMouseActionButton_=function(t){return 0===t.button},e.prototype.handlePointerDown_=function(t){this.updateActivePointers_(t);var e=new $(Q.POINTERDOWN,this.map_,t);this.dispatchEvent(e),this.down_=t,0===this.dragListenerKeys_.length&&(this.documentPointerEventHandler_=new Zt(document),this.dragListenerKeys_.push(v(this.documentPointerEventHandler_,Q.POINTERMOVE,this.handlePointerMove_,this),v(this.documentPointerEventHandler_,Q.POINTERUP,this.handlePointerUp_,this),v(this.pointerEventHandler_,Q.POINTERCANCEL,this.handlePointerUp_,this)))},e.prototype.handlePointerMove_=function(t){if(this.isMoving_(t)){this.dragging_=!0;var e=new $(Q.POINTERDRAG,this.map_,t,this.dragging_);this.dispatchEvent(e)}t.preventDefault()},e.prototype.relayEvent_=function(t){var e=!(!this.down_||!this.isMoving_(t));this.dispatchEvent(new $(t.type,this.map_,t,e))},e.prototype.isMoving_=function(t){return this.dragging_||Math.abs(t.clientX-this.down_.clientX)>this.moveTolerance_||Math.abs(t.clientY-this.down_.clientY)>this.moveTolerance_},e.prototype.disposeInternal=function(){this.relayedListenerKey_&&(S(this.relayedListenerKey_),this.relayedListenerKey_=null),this.pointerdownListenerKey_&&(S(this.pointerdownListenerKey_),this.pointerdownListenerKey_=null),this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.documentPointerEventHandler_&&(this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null),this.pointerEventHandler_&&(this.pointerEventHandler_.dispose(),this.pointerEventHandler_=null),t.prototype.disposeInternal.call(this)},e}(P),qt={POSTRENDER:"postrender",MOVESTART:"movestart",MOVEEND:"moveend"},Jt={LAYERGROUP:"layergroup",SIZE:"size",TARGET:"target",VIEW:"view"},Qt={POSTCOMPOSE:"postcompose",PRECOMPOSE:"precompose",RENDER:"render",RENDERCOMPLETE:"rendercomplete"},$t={IDLE:0,LOADING:1,LOADED:2,ERROR:3,EMPTY:4,ABORT:5};function te(t,e){if(!t)throw new a(e)}var ee=function(t,e){this.priorityFunction_=t,this.keyFunction_=e,this.elements_=[],this.priorities_=[],this.queuedElements_={}};ee.prototype.clear=function(){this.elements_.length=0,this.priorities_.length=0,p(this.queuedElements_)},ee.prototype.dequeue=function(){var t=this.elements_,e=this.priorities_,i=t[0];1==t.length?(t.length=0,e.length=0):(t[0]=t.pop(),e[0]=e.pop(),this.siftUp_(0));var r=this.keyFunction_(i);return delete this.queuedElements_[r],i},ee.prototype.enqueue=function(t){te(!(this.keyFunction_(t)in this.queuedElements_),31);var e=this.priorityFunction_(t);return e!=1/0&&(this.elements_.push(t),this.priorities_.push(e),this.queuedElements_[this.keyFunction_(t)]=!0,this.siftDown_(0,this.elements_.length-1),!0)},ee.prototype.getCount=function(){return this.elements_.length},ee.prototype.getLeftChildIndex_=function(t){return 2*t+1},ee.prototype.getRightChildIndex_=function(t){return 2*t+2},ee.prototype.getParentIndex_=function(t){return t-1>>1},ee.prototype.heapify_=function(){var t;for(t=(this.elements_.length>>1)-1;t>=0;t--)this.siftUp_(t)},ee.prototype.isEmpty=function(){return 0===this.elements_.length},ee.prototype.isKeyQueued=function(t){return t in this.queuedElements_},ee.prototype.isQueued=function(t){return this.isKeyQueued(this.keyFunction_(t))},ee.prototype.siftUp_=function(t){for(var e=this.elements_,i=this.priorities_,r=e.length,n=e[t],o=i[t],s=t;t<r>>1;){var a=this.getLeftChildIndex_(t),h=this.getRightChildIndex_(t),l=h<r&&i[h]<i[a]?h:a;e[t]=e[l],i[t]=i[l],t=l}e[t]=n,i[t]=o,this.siftDown_(s,t)},ee.prototype.siftDown_=function(t,e){for(var i=this.elements_,r=this.priorities_,n=i[e],o=r[e];e>t;){var s=this.getParentIndex_(e);if(!(r[s]>o))break;i[e]=i[s],r[e]=r[s],e=s}i[e]=n,r[e]=o},ee.prototype.reprioritize=function(){var t,e,i,r=this.priorityFunction_,n=this.elements_,o=this.priorities_,s=0,a=n.length;for(e=0;e<a;++e)(i=r(t=n[e]))==1/0?delete this.queuedElements_[this.keyFunction_(t)]:(o[s]=i,n[s++]=t);n.length=s,o.length=s,this.heapify_()};var ie=function(t){function e(e,i){t.call(this,function(t){return e.apply(null,t)},function(t){return t[0].getKey()}),this.tileChangeCallback_=i,this.tilesLoading_=0,this.tilesLoadingKeys_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.enqueue=function(e){var i=t.prototype.enqueue.call(this,e);i&&v(e[0],M.CHANGE,this.handleTileChange,this);return i},e.prototype.getTilesLoading=function(){return this.tilesLoading_},e.prototype.handleTileChange=function(t){var e=t.target,i=e.getState();if(i===$t.LOADED||i===$t.ERROR||i===$t.EMPTY||i===$t.ABORT){E(e,M.CHANGE,this.handleTileChange,this);var r=e.getKey();r in this.tilesLoadingKeys_&&(delete this.tilesLoadingKeys_[r],--this.tilesLoading_),this.tileChangeCallback_()}},e.prototype.loadMoreTiles=function(t,e){for(var i,r,n,o=0,s=!1;this.tilesLoading_<t&&o<e&&this.getCount()>0;)n=(r=this.dequeue()[0]).getKey(),(i=r.getState())===$t.ABORT?s=!0:i!==$t.IDLE||n in this.tilesLoadingKeys_||(this.tilesLoadingKeys_[n]=!0,++this.tilesLoading_,++o,r.load());0===o&&s&&this.tileChangeCallback_()},e}(ee),re=42,ne=256;function oe(t,e,i){return Math.min(Math.max(t,e),i)}var se="cosh"in Math?Math.cosh:function(t){var e=Math.exp(t);return(e+1/e)/2};function ae(t,e,i,r,n,o){var s=n-i,a=o-r;if(0!==s||0!==a){var h=((t-i)*s+(e-r)*a)/(s*s+a*a);h>1?(i=n,r=o):h>0&&(i+=s*h,r+=a*h)}return he(t,e,i,r)}function he(t,e,i,r){var n=i-t,o=r-e;return n*n+o*o}function le(t){return t*Math.PI/180}function ue(t,e){var i=t%e;return i*e<0?i+e:i}function pe(t,e,i){return t+i*(e-t)}function ce(t){return t}function de(t,e){return void 0!==t?0:void 0}function fe(t,e){return void 0!==t?t+e:void 0}var ge=0,_e=1,ye="center",ve="resolution",me="rotation";function Ee(t,e,i){var r=void 0!==i?t.toFixed(i):""+t,n=r.indexOf(".");return(n=-1===n?r.length:n)>e?r:new Array(1+e-n).join("0")+r}function Se(t,e){return t[0]+=e[0],t[1]+=e[1],t}function Te(t,e){var i,r,n=t[0],o=t[1],s=e[0],a=e[1],h=s[0],l=s[1],u=a[0],p=a[1],c=u-h,d=p-l,f=0===c&&0===d?0:(c*(n-h)+d*(o-l))/(c*c+d*d||0);return f<=0?(i=h,r=l):f>=1?(i=u,r=p):(i=h+f*c,r=l+f*d),[i,r]}function Re(t,e){for(var i=!0,r=t.length-1;r>=0;--r)if(t[r]!=e[r]){i=!1;break}return i}function Ce(t,e){var i=Math.cos(e),r=Math.sin(e),n=t[0]*i-t[1]*r,o=t[1]*i+t[0]*r;return t[0]=n,t[1]=o,t}function xe(t,e){return t[0]*=e,t[1]*=e,t}function we(t,e){var i=t[0]-e[0],r=t[1]-e[1];return i*i+r*r}function Ie(t,e){return Math.sqrt(we(t,e))}function Oe(t,e){return we(t,Te(t,e))}function Le(t){return Math.pow(t,3)}function Pe(t){return 1-Le(1-t)}function Me(t){return 3*t*t-2*t*t*t}function Fe(t){return t}var be={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"},Ne={UNKNOWN:0,INTERSECTING:1,ABOVE:2,RIGHT:4,BELOW:8,LEFT:16};function Ae(t){for(var e=Be(),i=0,r=t.length;i<r;++i)qe(e,t[i]);return e}function Ge(t,e,i){return i?(i[0]=t[0]-e,i[1]=t[1]-e,i[2]=t[2]+e,i[3]=t[3]+e,i):[t[0]-e,t[1]-e,t[2]+e,t[3]+e]}function De(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t.slice()}function ke(t,e,i){var r,n;return(r=e<t[0]?t[0]-e:t[2]<e?e-t[2]:0)*r+(n=i<t[1]?t[1]-i:t[3]<i?i-t[3]:0)*n}function Ye(t,e){return je(t,e[0],e[1])}function Ue(t,e){return t[0]<=e[0]&&e[2]<=t[2]&&t[1]<=e[1]&&e[3]<=t[3]}function je(t,e,i){return t[0]<=e&&e<=t[2]&&t[1]<=i&&i<=t[3]}function Xe(t,e){var i=t[0],r=t[1],n=t[2],o=t[3],s=e[0],a=e[1],h=Ne.UNKNOWN;return s<i?h|=Ne.LEFT:s>n&&(h|=Ne.RIGHT),a<r?h|=Ne.BELOW:a>o&&(h|=Ne.ABOVE),h===Ne.UNKNOWN&&(h=Ne.INTERSECTING),h}function Be(){return[1/0,1/0,-1/0,-1/0]}function Ve(t,e,i,r,n){return n?(n[0]=t,n[1]=e,n[2]=i,n[3]=r,n):[t,e,i,r]}function We(t){return Ve(1/0,1/0,-1/0,-1/0,t)}function Ke(t,e){var i=t[0],r=t[1];return Ve(i,r,i,r,e)}function ze(t,e,i,r,n){return Qe(We(n),t,e,i,r)}function Ze(t,e){return t[0]==e[0]&&t[2]==e[2]&&t[1]==e[1]&&t[3]==e[3]}function He(t,e){return e[0]<t[0]&&(t[0]=e[0]),e[2]>t[2]&&(t[2]=e[2]),e[1]<t[1]&&(t[1]=e[1]),e[3]>t[3]&&(t[3]=e[3]),t}function qe(t,e){e[0]<t[0]&&(t[0]=e[0]),e[0]>t[2]&&(t[2]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>t[3]&&(t[3]=e[1])}function Je(t,e){for(var i=0,r=e.length;i<r;++i)qe(t,e[i]);return t}function Qe(t,e,i,r,n){for(;i<r;i+=n)$e(t,e[i],e[i+1]);return t}function $e(t,e,i){t[0]=Math.min(t[0],e),t[1]=Math.min(t[1],i),t[2]=Math.max(t[2],e),t[3]=Math.max(t[3],i)}function ti(t,e,i){var r;return(r=e.call(i,ii(t)))?r:(r=e.call(i,ri(t)))?r:(r=e.call(i,ui(t)))?r:(r=e.call(i,li(t)))||!1}function ei(t){var e=0;return di(t)||(e=pi(t)*ai(t)),e}function ii(t){return[t[0],t[1]]}function ri(t){return[t[2],t[1]]}function ni(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]}function oi(t,e){var i;return e===be.BOTTOM_LEFT?i=ii(t):e===be.BOTTOM_RIGHT?i=ri(t):e===be.TOP_LEFT?i=li(t):e===be.TOP_RIGHT?i=ui(t):te(!1,13),i}function si(t,e,i,r,n){var o=e*r[0]/2,s=e*r[1]/2,a=Math.cos(i),h=Math.sin(i),l=o*a,u=o*h,p=s*a,c=s*h,d=t[0],f=t[1],g=d-l+c,_=d-l-c,y=d+l-c,v=d+l+c,m=f-u-p,E=f-u+p,S=f+u+p,T=f+u-p;return Ve(Math.min(g,_,y,v),Math.min(m,E,S,T),Math.max(g,_,y,v),Math.max(m,E,S,T),n)}function ai(t){return t[3]-t[1]}function hi(t,e,i){var r=i||[1/0,1/0,-1/0,-1/0];return ci(t,e)?(t[0]>e[0]?r[0]=t[0]:r[0]=e[0],t[1]>e[1]?r[1]=t[1]:r[1]=e[1],t[2]<e[2]?r[2]=t[2]:r[2]=e[2],t[3]<e[3]?r[3]=t[3]:r[3]=e[3]):We(r),r}function li(t){return[t[0],t[3]]}function ui(t){return[t[2],t[3]]}function pi(t){return t[2]-t[0]}function ci(t,e){return t[0]<=e[2]&&t[2]>=e[0]&&t[1]<=e[3]&&t[3]>=e[1]}function di(t){return t[2]<t[0]||t[3]<t[1]}function fi(t,e){var i=(t[2]-t[0])/2*(e-1),r=(t[3]-t[1])/2*(e-1);t[0]-=i,t[2]+=i,t[1]-=r,t[3]+=r}function gi(t,e,i){var r=[t[0],t[1],t[0],t[3],t[2],t[1],t[2],t[3]];return e(r,r,2),function(t,e,i){return Ve(Math.min.apply(null,t),Math.min.apply(null,e),Math.max.apply(null,t),Math.max.apply(null,e),i)}([r[0],r[2],r[4],r[6]],[r[1],r[3],r[5],r[7]],i)}var _i={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},yi={XY:"XY",XYZ:"XYZ",XYM:"XYM",XYZM:"XYZM"};function vi(t,e,i,r,n,o){for(var s=o||[],a=0,h=e;h<i;h+=r){var l=t[h],u=t[h+1];s[a++]=n[0]*l+n[2]*u+n[4],s[a++]=n[1]*l+n[3]*u+n[5]}return o&&s.length!=a&&(s.length=a),s}
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */
var mi=6371008.8;function Ei(t,e,i){var r=i||mi,n=le(t[1]),o=le(e[1]),s=(o-n)/2,a=le(e[0]-t[0])/2,h=Math.sin(s)*Math.sin(s)+Math.sin(a)*Math.sin(a)*Math.cos(n)*Math.cos(o);return 2*r*Math.atan2(Math.sqrt(h),Math.sqrt(1-h))}var Si={DEGREES:"degrees",FEET:"ft",METERS:"m",PIXELS:"pixels",TILE_PIXELS:"tile-pixels",USFEET:"us-ft"},Ti={};Ti[Si.DEGREES]=2*Math.PI*6370997/360,Ti[Si.FEET]=.3048,Ti[Si.METERS]=1,Ti[Si.USFEET]=1200/3937;var Ri=Si,Ci=function(t){this.code_=t.code,this.units_=t.units,this.extent_=void 0!==t.extent?t.extent:null,this.worldExtent_=void 0!==t.worldExtent?t.worldExtent:null,this.axisOrientation_=void 0!==t.axisOrientation?t.axisOrientation:"enu",this.global_=void 0!==t.global&&t.global,this.canWrapX_=!(!this.global_||!this.extent_),this.getPointResolutionFunc_=t.getPointResolution,this.defaultTileGrid_=null,this.metersPerUnit_=t.metersPerUnit};Ci.prototype.canWrapX=function(){return this.canWrapX_},Ci.prototype.getCode=function(){return this.code_},Ci.prototype.getExtent=function(){return this.extent_},Ci.prototype.getUnits=function(){return this.units_},Ci.prototype.getMetersPerUnit=function(){return this.metersPerUnit_||Ti[this.units_]},Ci.prototype.getWorldExtent=function(){return this.worldExtent_},Ci.prototype.getAxisOrientation=function(){return this.axisOrientation_},Ci.prototype.isGlobal=function(){return this.global_},Ci.prototype.setGlobal=function(t){this.global_=t,this.canWrapX_=!(!t||!this.extent_)},Ci.prototype.getDefaultTileGrid=function(){return this.defaultTileGrid_},Ci.prototype.setDefaultTileGrid=function(t){this.defaultTileGrid_=t},Ci.prototype.setExtent=function(t){this.extent_=t,this.canWrapX_=!(!this.global_||!t)},Ci.prototype.setWorldExtent=function(t){this.worldExtent_=t},Ci.prototype.setGetPointResolution=function(t){this.getPointResolutionFunc_=t},Ci.prototype.getPointResolutionFunc=function(){return this.getPointResolutionFunc_};var xi=Ci,wi=6378137,Ii=Math.PI*wi,Oi=[-Ii,-Ii,Ii,Ii],Li=[-180,-85,180,85],Pi=function(t){function e(e){t.call(this,{code:e,units:Ri.METERS,extent:Oi,global:!0,worldExtent:Li,getPointResolution:function(t,e){return t/se(e[1]/wi)}})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(xi),Mi=[new Pi("EPSG:3857"),new Pi("EPSG:102100"),new Pi("EPSG:102113"),new Pi("EPSG:900913"),new Pi("urn:ogc:def:crs:EPSG:6.18:3:3857"),new Pi("urn:ogc:def:crs:EPSG::3857"),new Pi("http://www.opengis.net/gml/srs/epsg.xml#3857")];function Fi(t,e,i){var r=t.length,n=i>1?i:2,o=e;void 0===o&&(o=n>2?t.slice():new Array(r));for(var s=Ii,a=0;a<r;a+=n){o[a]=s*t[a]/180;var h=wi*Math.log(Math.tan(Math.PI*(t[a+1]+90)/360));h>s?h=s:h<-s&&(h=-s),o[a+1]=h}return o}function bi(t,e,i){var r=t.length,n=i>1?i:2,o=e;void 0===o&&(o=n>2?t.slice():new Array(r));for(var s=0;s<r;s+=n)o[s]=180*t[s]/Ii,o[s+1]=360*Math.atan(Math.exp(t[s+1]/wi))/Math.PI-90;return o}var Ni=[-180,-90,180,90],Ai=6378137*Math.PI/180,Gi=function(t){function e(e,i){t.call(this,{code:e,units:Ri.DEGREES,extent:Ni,axisOrientation:i,global:!0,metersPerUnit:Ai,worldExtent:Ni})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(xi),Di=[new Gi("CRS:84"),new Gi("EPSG:4326","neu"),new Gi("urn:ogc:def:crs:EPSG::4326","neu"),new Gi("urn:ogc:def:crs:EPSG:6.6:4326","neu"),new Gi("urn:ogc:def:crs:OGC:1.3:CRS84"),new Gi("urn:ogc:def:crs:OGC:2:84"),new Gi("http://www.opengis.net/gml/srs/epsg.xml#4326","neu"),new Gi("urn:x-ogc:def:crs:EPSG:4326","neu")],ki={};var Yi,Ui,ji,Xi={};function Bi(t,e,i){var r=t.getCode(),n=e.getCode();r in Xi||(Xi[r]={}),Xi[r][n]=i}function Vi(t,e){var i;return t in Xi&&e in Xi[t]&&(i=Xi[t][e]),i}function Wi(t,e,i){var r;if(void 0!==e){for(var n=0,o=t.length;n<o;++n)e[n]=t[n];r=e}else r=t.slice();return r}function Ki(t,e,i){if(void 0!==e&&t!==e){for(var r=0,n=t.length;r<n;++r)e[r]=t[r];t=e}return t}function zi(t){!function(t,e){ki[t]=e}(t.getCode(),t),Bi(t,t,Wi)}function Zi(t){return"string"==typeof t?ki[t]||null:t||null}function Hi(t,e,i,r){var n,o=(t=Zi(t)).getPointResolutionFunc();if(o)n=o(e,i);else if(t.getUnits()==Ri.DEGREES&&!r||r==Ri.DEGREES)n=e;else{var s=tr(t,Zi("EPSG:4326")),a=[i[0]-e/2,i[1],i[0]+e/2,i[1],i[0],i[1]-e/2,i[0],i[1]+e/2];n=(Ei((a=s(a,a,2)).slice(0,2),a.slice(2,4))+Ei(a.slice(4,6),a.slice(6,8)))/2;var h=r?Ti[r]:t.getMetersPerUnit();void 0!==h&&(n/=h)}return n}function qi(t){!function(t){t.forEach(zi)}(t),t.forEach(function(e){t.forEach(function(t){e!==t&&Bi(e,t,Wi)})})}function Ji(t,e){return t?"string"==typeof t?Zi(t):t:Zi(e)}function Qi(t){return function(e,i,r){for(var n=e.length,o=void 0!==r?r:2,s=void 0!==i?i:new Array(n),a=0;a<n;a+=o){var h=t([e[a],e[a+1]]);s[a]=h[0],s[a+1]=h[1];for(var l=o-1;l>=2;--l)s[a+l]=e[a+l]}return s}}function $i(t,e){if(t===e)return!0;var i=t.getUnits()===e.getUnits();return t.getCode()===e.getCode()?i:tr(t,e)===Wi&&i}function tr(t,e){var i=Vi(t.getCode(),e.getCode());return i||(i=Ki),i}function er(t,e){return tr(Zi(t),Zi(e))}function ir(t,e,i){return er(e,i)(t,void 0,t.length)}function rr(t,e,i){return gi(t,er(e,i))}qi(Mi),qi(Di),Yi=Mi,Ui=Fi,ji=bi,Di.forEach(function(t){Yi.forEach(function(e){Bi(t,e,Ui),Bi(e,t,ji)})});var nr=new Array(6);function or(t){return ar(t,1,0,0,1,0,0)}function sr(t,e){var i=t[0],r=t[1],n=t[2],o=t[3],s=t[4],a=t[5],h=e[0],l=e[1],u=e[2],p=e[3],c=e[4],d=e[5];return t[0]=i*h+n*l,t[1]=r*h+o*l,t[2]=i*u+n*p,t[3]=r*u+o*p,t[4]=i*c+n*d+s,t[5]=r*c+o*d+a,t}function ar(t,e,i,r,n,o,s){return t[0]=e,t[1]=i,t[2]=r,t[3]=n,t[4]=o,t[5]=s,t}function hr(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function lr(t,e){var i=e[0],r=e[1];return e[0]=t[0]*i+t[2]*r+t[4],e[1]=t[1]*i+t[3]*r+t[5],e}function ur(t,e,i){return sr(t,ar(nr,e,0,0,i,0,0))}function pr(t,e,i){return sr(t,ar(nr,1,0,0,1,e,i))}function cr(t,e,i,r,n,o,s,a){var h=Math.sin(o),l=Math.cos(o);return t[0]=r*l,t[1]=n*h,t[2]=-r*h,t[3]=n*l,t[4]=s*r*l-a*r*h+e,t[5]=s*n*h+a*n*l+i,t}var dr=[1,0,0,1,0,0],fr=function(t){function e(){t.call(this),this.extent_=[1/0,1/0,-1/0,-1/0],this.extentRevision_=-1,this.simplifiedGeometryCache={},this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return r()},e.prototype.closestPointXY=function(t,e,i,n){return r()},e.prototype.containsXY=function(t,e){return!1},e.prototype.getClosestPoint=function(t,e){var i=e||[NaN,NaN];return this.closestPointXY(t[0],t[1],i,1/0),i},e.prototype.intersectsCoordinate=function(t){return this.containsXY(t[0],t[1])},e.prototype.computeExtent=function(t){return r()},e.prototype.getExtent=function(t){return this.extentRevision_!=this.getRevision()&&(this.extent_=this.computeExtent(this.extent_),this.extentRevision_=this.getRevision()),function(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t}(this.extent_,t)},e.prototype.rotate=function(t,e){r()},e.prototype.scale=function(t,e,i){r()},e.prototype.simplify=function(t){return this.getSimplifiedGeometry(t*t)},e.prototype.getSimplifiedGeometry=function(t){return r()},e.prototype.getType=function(){return r()},e.prototype.applyTransform=function(t){r()},e.prototype.intersectsExtent=function(t){return r()},e.prototype.translate=function(t,e){r()},e.prototype.transform=function(t,e){var i=Zi(t),r=i.getUnits()==Ri.TILE_PIXELS?function(t,r,n){var o=i.getExtent(),s=i.getWorldExtent(),a=ai(s)/ai(o);return cr(dr,s[0],s[3],a,-a,0,0,0),vi(t,0,t.length,n,dr,r),er(i,e)(t,r,n)}:er(i,e);return this.applyTransform(r),this},e}(G);function gr(t){var e;return t==yi.XY?e=2:t==yi.XYZ||t==yi.XYM?e=3:t==yi.XYZM&&(e=4),e}var _r=function(t){function e(){t.call(this),this.layout=yi.XY,this.stride=2,this.flatCoordinates=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.computeExtent=function(t){return ze(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.getCoordinates=function(){return r()},e.prototype.getFirstCoordinate=function(){return this.flatCoordinates.slice(0,this.stride)},e.prototype.getFlatCoordinates=function(){return this.flatCoordinates},e.prototype.getLastCoordinate=function(){return this.flatCoordinates.slice(this.flatCoordinates.length-this.stride)},e.prototype.getLayout=function(){return this.layout},e.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(p(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<=this.simplifiedGeometryMaxMinSquaredTolerance)return this;var e=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(e))return this.simplifiedGeometryCache[e];var i=this.getSimplifiedGeometryInternal(t);return i.getFlatCoordinates().length<this.flatCoordinates.length?(this.simplifiedGeometryCache[e]=i,i):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)},e.prototype.getSimplifiedGeometryInternal=function(t){return this},e.prototype.getStride=function(){return this.stride},e.prototype.setFlatCoordinates=function(t,e){this.stride=gr(t),this.layout=t,this.flatCoordinates=e},e.prototype.setCoordinates=function(t,e){r()},e.prototype.setLayout=function(t,e,i){var r;if(t)r=gr(t);else{for(var n=0;n<i;++n){if(0===e.length)return this.layout=yi.XY,void(this.stride=2);e=e[0]}t=function(t){var e;2==t?e=yi.XY:3==t?e=yi.XYZ:4==t&&(e=yi.XYZM);return e}(r=e.length)}this.layout=t,this.stride=r},e.prototype.applyTransform=function(t){this.flatCoordinates&&(t(this.flatCoordinates,this.flatCoordinates,this.stride),this.changed())},e.prototype.rotate=function(t,e){var i=this.getFlatCoordinates();if(i){var r=this.getStride();!function(t,e,i,r,n,o,s){for(var a=s||[],h=Math.cos(n),l=Math.sin(n),u=o[0],p=o[1],c=0,d=e;d<i;d+=r){var f=t[d]-u,g=t[d+1]-p;a[c++]=u+f*h-g*l,a[c++]=p+f*l+g*h;for(var _=d+2;_<d+r;++_)a[c++]=t[_]}s&&a.length!=c&&(a.length=c)}(i,0,i.length,r,t,e,i),this.changed()}},e.prototype.scale=function(t,e,i){var r=e;void 0===r&&(r=t);var n=i;n||(n=ni(this.getExtent()));var o=this.getFlatCoordinates();if(o){var s=this.getStride();!function(t,e,i,r,n,o,s,a){for(var h=a||[],l=s[0],u=s[1],p=0,c=e;c<i;c+=r){var d=t[c]-l,f=t[c+1]-u;h[p++]=l+n*d,h[p++]=u+o*f;for(var g=c+2;g<c+r;++g)h[p++]=t[g]}a&&h.length!=p&&(h.length=p)}(o,0,o.length,s,t,r,n,o),this.changed()}},e.prototype.translate=function(t,e){var i=this.getFlatCoordinates();if(i){var r=this.getStride();!function(t,e,i,r,n,o,s){for(var a=s||[],h=0,l=e;l<i;l+=r){a[h++]=t[l]+n,a[h++]=t[l+1]+o;for(var u=l+2;u<l+r;++u)a[h++]=t[u]}s&&a.length!=h&&(a.length=h)}(i,0,i.length,r,t,e,i),this.changed()}},e}(fr);function yr(t,e,i,r){for(var n=0,o=t[i-r],s=t[i-r+1];e<i;e+=r){var a=t[e],h=t[e+1];n+=s*a-o*h,o=a,s=h}return n/2}function vr(t,e,i,r){for(var n=0,o=0,s=i.length;o<s;++o){var a=i[o];n+=yr(t,e,a,r),e=a}return n}function mr(t,e,i,r,n,o,s){var a,h=t[e],l=t[e+1],u=t[i]-h,p=t[i+1]-l;if(0===u&&0===p)a=e;else{var c=((n-h)*u+(o-l)*p)/(u*u+p*p);if(c>1)a=i;else{if(c>0){for(var d=0;d<r;++d)s[d]=pe(t[e+d],t[i+d],c);return void(s.length=r)}a=e}}for(var f=0;f<r;++f)s[f]=t[a+f];s.length=r}function Er(t,e,i,r,n){var o=t[e],s=t[e+1];for(e+=r;e<i;e+=r){var a=t[e],h=t[e+1],l=he(o,s,a,h);l>n&&(n=l),o=a,s=h}return n}function Sr(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];n=Er(t,e,a,r,n),e=a}return n}function Tr(t,e,i,r,n,o,s,a,h,l,u){if(e==i)return l;var p,c;if(0===n){if((c=he(s,a,t[e],t[e+1]))<l){for(p=0;p<r;++p)h[p]=t[e+p];return h.length=r,c}return l}for(var d=u||[NaN,NaN],f=e+r;f<i;)if(mr(t,f-r,f,r,s,a,d),(c=he(s,a,d[0],d[1]))<l){for(l=c,p=0;p<r;++p)h[p]=d[p];h.length=r,f+=r}else f+=r*Math.max((Math.sqrt(c)-Math.sqrt(l))/n|0,1);if(o&&(mr(t,i-r,e,r,s,a,d),(c=he(s,a,d[0],d[1]))<l)){for(l=c,p=0;p<r;++p)h[p]=d[p];h.length=r}return l}function Rr(t,e,i,r,n,o,s,a,h,l,u){for(var p=u||[NaN,NaN],c=0,d=i.length;c<d;++c){var f=i[c];l=Tr(t,e,f,r,n,o,s,a,h,l,p),e=f}return l}function Cr(t,e,i,r){for(var n=0,o=i.length;n<o;++n)t[e++]=i[n];return e}function xr(t,e,i,r){for(var n=0,o=i.length;n<o;++n)for(var s=i[n],a=0;a<r;++a)t[e++]=s[a];return e}function wr(t,e,i,r,n){for(var o=n||[],s=0,a=0,h=i.length;a<h;++a){var l=xr(t,e,i[a],r);o[s++]=l,e=l}return o.length=s,o}function Ir(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=e;a<i;a+=r)o[s++]=t.slice(a,a+r);return o.length=s,o}function Or(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=0,h=i.length;a<h;++a){var l=i[a];o[s++]=Ir(t,e,l,r,o[s]),e=l}return o.length=s,o}function Lr(t,e,i,r,n){for(var o=void 0!==n?n:[],s=0,a=0,h=i.length;a<h;++a){var l=i[a];o[s++]=Or(t,e,l,r,o[s]),e=l[l.length-1]}return o.length=s,o}function Pr(t,e,i,r,n,o,s){var a=(i-e)/r;if(a<3){for(;e<i;e+=r)o[s++]=t[e],o[s++]=t[e+1];return s}var h=new Array(a);h[0]=1,h[a-1]=1;for(var l=[e,i-r],u=0;l.length>0;){for(var p=l.pop(),c=l.pop(),d=0,f=t[c],g=t[c+1],_=t[p],y=t[p+1],v=c+r;v<p;v+=r){var m=ae(t[v],t[v+1],f,g,_,y);m>d&&(u=v,d=m)}d>n&&(h[(u-e)/r]=1,c+r<u&&l.push(c,u),u+r<p&&l.push(u,p))}for(var E=0;E<a;++E)h[E]&&(o[s++]=t[e+E*r],o[s++]=t[e+E*r+1]);return s}function Mr(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h];s=Pr(t,e,u,r,n,o,s),a.push(s),e=u}return s}function Fr(t,e){return e*Math.round(t/e)}function br(t,e,i,r,n,o,s){if(e==i)return s;var a,h,l=Fr(t[e],n),u=Fr(t[e+1],n);e+=r,o[s++]=l,o[s++]=u;do{if(a=Fr(t[e],n),h=Fr(t[e+1],n),(e+=r)==i)return o[s++]=a,o[s++]=h,s}while(a==l&&h==u);for(;e<i;){var p=Fr(t[e],n),c=Fr(t[e+1],n);if(e+=r,p!=a||c!=h){var d=a-l,f=h-u,g=p-l,_=c-u;d*_==f*g&&(d<0&&g<d||d==g||d>0&&g>d)&&(f<0&&_<f||f==_||f>0&&_>f)?(a=p,h=c):(o[s++]=a,o[s++]=h,l=a,u=h,a=p,h=c)}}return o[s++]=a,o[s++]=h,s}function Nr(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h];s=br(t,e,u,r,n,o,s),a.push(s),e=u}return s}var Ar=function(t){function e(e,i){t.call(this),this.maxDelta_=-1,this.maxDeltaRevision_=-1,void 0===i||Array.isArray(e[0])?this.setCoordinates(e,i):this.setFlatCoordinates(i,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Er(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Tr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.getArea=function(){return yr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[];return i.length=Pr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i,0),new e(i,yi.XY)},e.prototype.getType=function(){return _i.LINEAR_RING},e.prototype.intersectsExtent=function(t){return!1},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r),Gr=function(t){function e(e,i){t.call(this),this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){var n=this.flatCoordinates,o=he(t,e,n[0],n[1]);if(o<r){for(var s=this.stride,a=0;a<s;++a)i[a]=n[a];return i.length=s,o}return r},e.prototype.getCoordinates=function(){return this.flatCoordinates?this.flatCoordinates.slice():[]},e.prototype.computeExtent=function(t){return Ke(this.flatCoordinates,t)},e.prototype.getType=function(){return _i.POINT},e.prototype.intersectsExtent=function(t){return je(t,this.flatCoordinates[0],this.flatCoordinates[1])},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,0),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=Cr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r);function Dr(t,e,i,r,n){return!ti(n,function(n){return!kr(t,e,i,r,n[0],n[1])})}function kr(t,e,i,r,n,o){for(var s=0,a=t[i-r],h=t[i-r+1];e<i;e+=r){var l=t[e],u=t[e+1];h<=o?u>o&&(l-a)*(o-h)-(n-a)*(u-h)>0&&s++:u<=o&&(l-a)*(o-h)-(n-a)*(u-h)<0&&s--,a=l,h=u}return 0!==s}function Yr(t,e,i,r,n,o){if(0===i.length)return!1;if(!kr(t,e,i[0],r,n,o))return!1;for(var s=1,a=i.length;s<a;++s)if(kr(t,i[s-1],i[s],r,n,o))return!1;return!0}function Ur(t,e,i,r,n,o,s){for(var a,h,l,u,p,c,d,f=n[o+1],g=[],_=0,y=i.length;_<y;++_){var v=i[_];for(u=t[v-r],c=t[v-r+1],a=e;a<v;a+=r)p=t[a],d=t[a+1],(f<=c&&d<=f||c<=f&&f<=d)&&(l=(f-c)/(d-c)*(p-u)+u,g.push(l)),u=p,c=d}var m=NaN,E=-1/0;for(g.sort(Nt),u=g[0],a=1,h=g.length;a<h;++a){p=g[a];var S=Math.abs(p-u);S>E&&Yr(t,e,i,r,l=(u+p)/2,f)&&(m=l,E=S),u=p}return isNaN(m)&&(m=n[o]),s?(s.push(m,f,E),s):[m,f,E]}function jr(t,e,i,r,n,o){for(var s,a=[t[e],t[e+1]],h=[];e+r<i;e+=r){if(h[0]=t[e+r],h[1]=t[e+r+1],s=n.call(o,a,h))return s;a[0]=h[0],a[1]=h[1]}return!1}function Xr(t,e,i,r,n){var o=Qe([1/0,1/0,-1/0,-1/0],t,e,i,r);return!!ci(n,o)&&(!!Ue(n,o)||(o[0]>=n[0]&&o[2]<=n[2]||(o[1]>=n[1]&&o[3]<=n[3]||jr(t,e,i,r,function(t,e){return function(t,e,i){var r=!1,n=Xe(t,e),o=Xe(t,i);if(n===Ne.INTERSECTING||o===Ne.INTERSECTING)r=!0;else{var s,a,h=t[0],l=t[1],u=t[2],p=t[3],c=e[0],d=e[1],f=i[0],g=i[1],_=(g-d)/(f-c);o&Ne.ABOVE&&!(n&Ne.ABOVE)&&(r=(s=f-(g-p)/_)>=h&&s<=u),r||!(o&Ne.RIGHT)||n&Ne.RIGHT||(r=(a=g-(f-u)*_)>=l&&a<=p),r||!(o&Ne.BELOW)||n&Ne.BELOW||(r=(s=f-(g-l)/_)>=h&&s<=u),r||!(o&Ne.LEFT)||n&Ne.LEFT||(r=(a=g-(f-h)*_)>=l&&a<=p)}return r}(n,t,e)}))))}function Br(t,e,i,r,n){if(!function(t,e,i,r,n){return!!(Xr(t,e,i,r,n)||kr(t,e,i,r,n[0],n[1])||kr(t,e,i,r,n[0],n[3])||kr(t,e,i,r,n[2],n[1])||kr(t,e,i,r,n[2],n[3]))}(t,e,i[0],r,n))return!1;if(1===i.length)return!0;for(var o=1,s=i.length;o<s;++o)if(Dr(t,i[o-1],i[o],r,n)&&!Xr(t,i[o-1],i[o],r,n))return!1;return!0}function Vr(t,e,i,r){for(;e<i-r;){for(var n=0;n<r;++n){var o=t[e+n];t[e+n]=t[i-r+n],t[i-r+n]=o}e+=r,i-=r}}function Wr(t,e,i,r){for(var n=0,o=t[i-r],s=t[i-r+1];e<i;e+=r){var a=t[e],h=t[e+1];n+=(a-o)*(h+s),o=a,s=h}return n>0}function Kr(t,e,i,r,n){for(var o=void 0!==n&&n,s=0,a=i.length;s<a;++s){var h=i[s],l=Wr(t,e,h,r);if(0===s){if(o&&l||!o&&!l)return!1}else if(o&&!l||!o&&l)return!1;e=h}return!0}function zr(t,e,i,r,n){for(var o=void 0!==n&&n,s=0,a=i.length;s<a;++s){var h=i[s],l=Wr(t,e,h,r);(0===s?o&&l||!o&&!l:o&&!l||!o&&l)&&Vr(t,e,h,r),e=h}return e}function Zr(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o)e=zr(t,e,i[o],r,n);return e}var Hr=function(t){function e(e,i,r){t.call(this),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,void 0!==i&&r?(this.setFlatCoordinates(i,e),this.ends_=r):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendLinearRing=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout,this.ends_.slice())},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Sr(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Rr(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.containsXY=function(t,e){return Yr(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)},e.prototype.getArea=function(){return vr(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)},e.prototype.getCoordinates=function(t){var e;return void 0!==t?zr(e=this.getOrientedFlatCoordinates().slice(),0,this.ends_,this.stride,t):e=this.flatCoordinates,Or(e,0,this.ends_,this.stride)},e.prototype.getEnds=function(){return this.ends_},e.prototype.getFlatInteriorPoint=function(){if(this.flatInteriorPointRevision_!=this.getRevision()){var t=ni(this.getExtent());this.flatInteriorPoint_=Ur(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()}return this.flatInteriorPoint_},e.prototype.getInteriorPoint=function(){return new Gr(this.getFlatInteriorPoint(),yi.XYM)},e.prototype.getLinearRingCount=function(){return this.ends_.length},e.prototype.getLinearRing=function(t){return t<0||this.ends_.length<=t?null:new Ar(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)},e.prototype.getLinearRings=function(){for(var t=this.layout,e=this.flatCoordinates,i=this.ends_,r=[],n=0,o=0,s=i.length;o<s;++o){var a=i[o],h=new Ar(e.slice(n,a),t);r.push(h),n=a}return r},e.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var t=this.flatCoordinates;Kr(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=zr(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=Nr(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),i,0,r),new e(i,yi.XY,r)},e.prototype.getType=function(){return _i.POLYGON},e.prototype.intersectsExtent=function(t){return Br(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);var i=wr(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()},e}(_r),qr=Hr;function Jr(t){var e=t[0],i=t[1],r=t[2],n=t[3],o=[e,i,e,n,r,n,r,i,e,i];return new Hr(o,yi.XY,[o.length])}function Qr(t,e,i){for(var r=e||32,n=t.getStride(),o=t.getLayout(),s=t.getCenter(),a=n*(r+1),h=new Array(a),l=0;l<a;l+=n){h[l]=0,h[l+1]=0;for(var u=2;u<n;u++)h[l+u]=s[u]}var p=[h.length],c=new Hr(h,o,p);return $r(c,s,t.getRadius(),i),c}function $r(t,e,i,r){for(var n=t.getFlatCoordinates(),o=t.getStride(),s=n.length/o-1,a=r||0,h=0;h<=s;++h){var l=h*o,u=a+2*ue(h,s)*Math.PI/s;n[l]=e[0]+i*Math.cos(u),n[l+1]=e[1]+i*Math.sin(u)}t.changed()}var tn=0;function en(t,e){setTimeout(function(){t(e)},0)}function rn(t){return!(t.sourceCenter&&t.targetCenter&&!Re(t.sourceCenter,t.targetCenter))&&(t.sourceResolution===t.targetResolution&&t.sourceRotation===t.targetRotation)}var nn=function(t){function e(e){t.call(this);var i=u({},e);this.hints_=[0,0],this.animations_=[],this.updateAnimationKey_,this.updateAnimations_=this.updateAnimations_.bind(this),this.projection_=Ji(i.projection,"EPSG:3857"),this.applyOptions_(i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.applyOptions_=function(t){var e={};e[ye]=void 0!==t.center?t.center:null;var i=function(t){var e,i,r,n=void 0!==t.minZoom?t.minZoom:tn,o=void 0!==t.maxZoom?t.maxZoom:28,s=void 0!==t.zoomFactor?t.zoomFactor:2;if(void 0!==t.resolutions){var a=t.resolutions;i=a[n],r=void 0!==a[o]?a[o]:a[a.length-1],e=function(t){return function(e,i,r){if(void 0!==e){var n=Gt(t,e,r);n=oe(n+i,0,t.length-1);var o=Math.floor(n);if(n!=o&&o<t.length-1){var s=t[o]/t[o+1];return t[o]/Math.pow(s,n-o)}return t[o]}}}(a)}else{var h=Ji(t.projection,"EPSG:3857"),l=h.getExtent(),u=l?Math.max(pi(l),ai(l)):360*Ti[Ri.DEGREES]/h.getMetersPerUnit(),p=u/ne/Math.pow(2,tn),c=p/Math.pow(2,28-tn);void 0!==(i=t.maxResolution)?n=0:i=p/Math.pow(s,n),void 0===(r=t.minResolution)&&(r=void 0!==t.maxZoom?void 0!==t.maxResolution?i/Math.pow(s,o):p/Math.pow(s,o):c),o=n+Math.floor(Math.log(i/r)/Math.log(s)),r=i/Math.pow(s,o-n),e=function(t,e,i){return function(r,n,o){if(void 0!==r){var s=-o/2+.5,a=Math.floor(Math.log(e/r)/Math.log(t)+s),h=Math.max(a+n,0);return void 0!==i&&(h=Math.min(h,i)),e/Math.pow(t,h)}}}(s,i,o-n)}return{constraint:e,maxResolution:i,minResolution:r,minZoom:n,zoomFactor:s}}(t);this.maxResolution_=i.maxResolution,this.minResolution_=i.minResolution,this.zoomFactor_=i.zoomFactor,this.resolutions_=t.resolutions,this.minZoom_=i.minZoom;var r=function(t){return void 0!==t.extent?(e=t.extent,function(t){return t?[oe(t[0],e[0],e[2]),oe(t[1],e[1],e[3])]:void 0}):ce;var e}(t),n=i.constraint,o=function(t){if(void 0===t.enableRotation||t.enableRotation){var e=t.constrainRotation;return void 0===e||!0===e?(o=n||le(5),function(t,e){return void 0!==t?Math.abs(t+e)<=o?0:t+e:void 0}):!1===e?fe:"number"==typeof e?(i=e,r=2*Math.PI/i,function(t,e){return void 0!==t?t=Math.floor((t+e)/r+.5)*r:void 0}):fe}return de;var i,r;var n,o}(t);this.constraints_={center:r,resolution:n,rotation:o},void 0!==t.resolution?e[ve]=t.resolution:void 0!==t.zoom&&(e[ve]=this.constrainResolution(this.maxResolution_,t.zoom-this.minZoom_),this.resolutions_&&(e[ve]=oe(Number(this.getResolution()||e[ve]),this.minResolution_,this.maxResolution_))),e[me]=void 0!==t.rotation?t.rotation:0,this.setProperties(e),this.options_=t},e.prototype.getUpdatedOptions_=function(t){var e=u({},this.options_);return void 0!==e.resolution?e.resolution=this.getResolution():e.zoom=this.getZoom(),e.center=this.getCenter(),e.rotation=this.getRotation(),u({},e,t)},e.prototype.animate=function(t){var e,i=arguments,r=arguments.length;if(r>1&&"function"==typeof arguments[r-1]&&(e=arguments[r-1],--r),!this.isDef()){var n=arguments[r-1];return n.center&&this.setCenter(n.center),void 0!==n.zoom&&this.setZoom(n.zoom),void 0!==n.rotation&&this.setRotation(n.rotation),void(e&&en(e,!0))}for(var o=Date.now(),s=this.getCenter().slice(),a=this.getResolution(),h=this.getRotation(),l=[],u=0;u<r;++u){var p=i[u],c={start:o,complete:!1,anchor:p.anchor,duration:void 0!==p.duration?p.duration:1e3,easing:p.easing||Me};if(p.center&&(c.sourceCenter=s,c.targetCenter=p.center,s=c.targetCenter),void 0!==p.zoom?(c.sourceResolution=a,c.targetResolution=this.constrainResolution(this.maxResolution_,p.zoom-this.minZoom_,0),a=c.targetResolution):p.resolution&&(c.sourceResolution=a,c.targetResolution=p.resolution,a=c.targetResolution),void 0!==p.rotation){c.sourceRotation=h;var d=ue(p.rotation-h+Math.PI,2*Math.PI)-Math.PI;c.targetRotation=h+d,h=c.targetRotation}c.callback=e,rn(c)?c.complete=!0:o+=c.duration,l.push(c)}this.animations_.push(l),this.setHint(ge,1),this.updateAnimations_()},e.prototype.getAnimating=function(){return this.hints_[ge]>0},e.prototype.getInteracting=function(){return this.hints_[_e]>0},e.prototype.cancelAnimations=function(){this.setHint(ge,-this.hints_[ge]);for(var t=0,e=this.animations_.length;t<e;++t){var i=this.animations_[t];i[0].callback&&en(i[0].callback,!1)}this.animations_.length=0},e.prototype.updateAnimations_=function(){if(void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0),this.getAnimating()){for(var t=Date.now(),e=!1,i=this.animations_.length-1;i>=0;--i){for(var r=this.animations_[i],n=!0,o=0,s=r.length;o<s;++o){var a=r[o];if(!a.complete){var h=t-a.start,l=a.duration>0?h/a.duration:1;l>=1?(a.complete=!0,l=1):n=!1;var u=a.easing(l);if(a.sourceCenter){var p=a.sourceCenter[0],c=a.sourceCenter[1],d=p+u*(a.targetCenter[0]-p),f=c+u*(a.targetCenter[1]-c);this.set(ye,[d,f])}if(a.sourceResolution&&a.targetResolution){var g=1===u?a.targetResolution:a.sourceResolution+u*(a.targetResolution-a.sourceResolution);a.anchor&&this.set(ye,this.calculateCenterZoom(g,a.anchor)),this.set(ve,g)}if(void 0!==a.sourceRotation&&void 0!==a.targetRotation){var _=1===u?ue(a.targetRotation+Math.PI,2*Math.PI)-Math.PI:a.sourceRotation+u*(a.targetRotation-a.sourceRotation);a.anchor&&this.set(ye,this.calculateCenterRotate(_,a.anchor)),this.set(me,_)}if(e=!0,!a.complete)break}}if(n){this.animations_[i]=null,this.setHint(ge,-1);var y=r[0].callback;y&&en(y,!0)}}this.animations_=this.animations_.filter(Boolean),e&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_))}},e.prototype.calculateCenterRotate=function(t,e){var i,r=this.getCenter();return void 0!==r&&(Ce(i=[r[0]-e[0],r[1]-e[1]],t-this.getRotation()),Se(i,e)),i},e.prototype.calculateCenterZoom=function(t,e){var i,r=this.getCenter(),n=this.getResolution();void 0!==r&&void 0!==n&&(i=[e[0]-t*(e[0]-r[0])/n,e[1]-t*(e[1]-r[1])/n]);return i},e.prototype.getSizeFromViewport_=function(){var t=[100,100],e='.ol-viewport[data-view="'+o(this)+'"]',i=document.querySelector(e);if(i){var r=getComputedStyle(i);t[0]=parseInt(r.width,10),t[1]=parseInt(r.height,10)}return t},e.prototype.constrainCenter=function(t){return this.constraints_.center(t)},e.prototype.constrainResolution=function(t,e,i){var r=e||0,n=i||0;return this.constraints_.resolution(t,r,n)},e.prototype.constrainRotation=function(t,e){var i=e||0;return this.constraints_.rotation(t,i)},e.prototype.getCenter=function(){return this.get(ye)},e.prototype.getConstraints=function(){return this.constraints_},e.prototype.getHints=function(t){return void 0!==t?(t[0]=this.hints_[0],t[1]=this.hints_[1],t):this.hints_.slice()},e.prototype.calculateExtent=function(t){var e=t||this.getSizeFromViewport_(),i=this.getCenter();te(i,1);var r=this.getResolution();te(void 0!==r,2);var n=this.getRotation();return te(void 0!==n,3),si(i,r,n,e)},e.prototype.getMaxResolution=function(){return this.maxResolution_},e.prototype.getMinResolution=function(){return this.minResolution_},e.prototype.getMaxZoom=function(){return this.getZoomForResolution(this.minResolution_)},e.prototype.setMaxZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({maxZoom:t}))},e.prototype.getMinZoom=function(){return this.getZoomForResolution(this.maxResolution_)},e.prototype.setMinZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({minZoom:t}))},e.prototype.getProjection=function(){return this.projection_},e.prototype.getResolution=function(){return this.get(ve)},e.prototype.getResolutions=function(){return this.resolutions_},e.prototype.getResolutionForExtent=function(t,e){var i=e||this.getSizeFromViewport_(),r=pi(t)/i[0],n=ai(t)/i[1];return Math.max(r,n)},e.prototype.getResolutionForValueFunction=function(t){var e=t||2,i=this.maxResolution_,r=this.minResolution_,n=Math.log(i/r)/Math.log(e);return function(t){return i/Math.pow(e,t*n)}},e.prototype.getRotation=function(){return this.get(me)},e.prototype.getValueForResolutionFunction=function(t){var e=t||2,i=this.maxResolution_,r=this.minResolution_,n=Math.log(i/r)/Math.log(e);return function(t){return Math.log(i/t)/Math.log(e)/n}},e.prototype.getState=function(t){var e=this.getCenter(),i=this.getProjection(),r=this.getResolution(),n=r/t,o=this.getRotation();return{center:[Math.round(e[0]/n)*n,Math.round(e[1]/n)*n],projection:void 0!==i?i:null,resolution:r,rotation:o,zoom:this.getZoom()}},e.prototype.getZoom=function(){var t,e=this.getResolution();return void 0!==e&&(t=this.getZoomForResolution(e)),t},e.prototype.getZoomForResolution=function(t){var e,i,r=this.minZoom_||0;if(this.resolutions_){var n=Gt(this.resolutions_,t,1);r=n,e=this.resolutions_[n],i=n==this.resolutions_.length-1?2:e/this.resolutions_[n+1]}else e=this.maxResolution_,i=this.zoomFactor_;return r+Math.log(e/t)/Math.log(i)},e.prototype.getResolutionForZoom=function(t){return this.constrainResolution(this.maxResolution_,t-this.minZoom_,0)},e.prototype.fit=function(t,e){var i,r=e||{},n=r.size;n||(n=this.getSizeFromViewport_()),te(Array.isArray(t)||"function"==typeof t.getSimplifiedGeometry,24),Array.isArray(t)?(te(!di(t),25),i=Jr(t)):t.getType()===_i.CIRCLE?(i=Jr(t=t.getExtent())).rotate(this.getRotation(),ni(t)):i=t;var o,s=void 0!==r.padding?r.padding:[0,0,0,0],a=void 0===r.constrainResolution||r.constrainResolution,h=void 0!==r.nearest&&r.nearest;o=void 0!==r.minResolution?r.minResolution:void 0!==r.maxZoom?this.constrainResolution(this.maxResolution_,r.maxZoom-this.minZoom_,0):0;for(var l=i.getFlatCoordinates(),u=this.getRotation(),p=Math.cos(-u),c=Math.sin(-u),d=1/0,f=1/0,g=-1/0,_=-1/0,y=i.getStride(),v=0,m=l.length;v<m;v+=y){var E=l[v]*p-l[v+1]*c,S=l[v]*c+l[v+1]*p;d=Math.min(d,E),f=Math.min(f,S),g=Math.max(g,E),_=Math.max(_,S)}var T=this.getResolutionForExtent([d,f,g,_],[n[0]-s[1]-s[3],n[1]-s[0]-s[2]]);if(T=isNaN(T)?o:Math.max(T,o),a){var R=this.constrainResolution(T,0,0);!h&&R<T&&(R=this.constrainResolution(R,-1,0)),T=R}c=-c;var C=(d+g)/2,x=(f+_)/2,I=[(C+=(s[1]-s[3])/2*T)*p-(x+=(s[0]-s[2])/2*T)*c,x*p+C*c],O=r.callback?r.callback:w;void 0!==r.duration?this.animate({resolution:T,center:I,duration:r.duration,easing:r.easing},O):(this.setResolution(T),this.setCenter(I),en(O,!0))},e.prototype.centerOn=function(t,e,i){var r=this.getRotation(),n=Math.cos(-r),o=Math.sin(-r),s=t[0]*n-t[1]*o,a=t[1]*n+t[0]*o,h=this.getResolution(),l=(s+=(e[0]/2-i[0])*h)*n-(a+=(i[1]-e[1]/2)*h)*(o=-o),u=a*n+s*o;this.setCenter([l,u])},e.prototype.isDef=function(){return!!this.getCenter()&&void 0!==this.getResolution()},e.prototype.rotate=function(t,e){if(void 0!==e){var i=this.calculateCenterRotate(t,e);this.setCenter(i)}this.setRotation(t)},e.prototype.setCenter=function(t){this.set(ye,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setHint=function(t,e){return this.hints_[t]+=e,this.changed(),this.hints_[t]},e.prototype.setResolution=function(t){this.set(ve,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setRotation=function(t){this.set(me,t),this.getAnimating()&&this.cancelAnimations()},e.prototype.setZoom=function(t){this.setResolution(this.getResolutionForZoom(t))},e}(G);function on(t,e){var i=document.createElement("canvas");return t&&(i.width=t),e&&(i.height=e),i.getContext("2d")}function sn(t){var e=t.offsetWidth,i=getComputedStyle(t);return e+=parseInt(i.marginLeft,10)+parseInt(i.marginRight,10)}function an(t){var e=t.offsetHeight,i=getComputedStyle(t);return e+=parseInt(i.marginTop,10)+parseInt(i.marginBottom,10)}function hn(t,e){var i=e.parentNode;i&&i.replaceChild(t,e)}function ln(t){return t&&t.parentNode?t.parentNode.removeChild(t):null}function un(t){for(;t.lastChild;)t.removeChild(t.lastChild)}var pn={OPACITY:"opacity",VISIBLE:"visible",EXTENT:"extent",Z_INDEX:"zIndex",MAX_RESOLUTION:"maxResolution",MIN_RESOLUTION:"minResolution",SOURCE:"source"},cn=function(t){function e(e){t.call(this);var i=u({},e);i[pn.OPACITY]=void 0!==e.opacity?e.opacity:1,i[pn.VISIBLE]=void 0===e.visible||e.visible,i[pn.Z_INDEX]=e.zIndex,i[pn.MAX_RESOLUTION]=void 0!==e.maxResolution?e.maxResolution:1/0,i[pn.MIN_RESOLUTION]=void 0!==e.minResolution?e.minResolution:0,this.setProperties(i),this.state_=null,this.type}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return this.type},e.prototype.getLayerState=function(){var t=this.state_||{layer:this,managed:!0};return t.opacity=oe(this.getOpacity(),0,1),t.sourceState=this.getSourceState(),t.visible=this.getVisible(),t.extent=this.getExtent(),t.zIndex=this.getZIndex()||0,t.maxResolution=this.getMaxResolution(),t.minResolution=Math.max(this.getMinResolution(),0),this.state_=t,t},e.prototype.getLayersArray=function(t){return r()},e.prototype.getLayerStatesArray=function(t){return r()},e.prototype.getExtent=function(){return this.get(pn.EXTENT)},e.prototype.getMaxResolution=function(){return this.get(pn.MAX_RESOLUTION)},e.prototype.getMinResolution=function(){return this.get(pn.MIN_RESOLUTION)},e.prototype.getOpacity=function(){return this.get(pn.OPACITY)},e.prototype.getSourceState=function(){return r()},e.prototype.getVisible=function(){return this.get(pn.VISIBLE)},e.prototype.getZIndex=function(){return this.get(pn.Z_INDEX)},e.prototype.setExtent=function(t){this.set(pn.EXTENT,t)},e.prototype.setMaxResolution=function(t){this.set(pn.MAX_RESOLUTION,t)},e.prototype.setMinResolution=function(t){this.set(pn.MIN_RESOLUTION,t)},e.prototype.setOpacity=function(t){this.set(pn.OPACITY,t)},e.prototype.setVisible=function(t){this.set(pn.VISIBLE,t)},e.prototype.setZIndex=function(t){this.set(pn.Z_INDEX,t)},e}(G),dn={UNDEFINED:"undefined",LOADING:"loading",READY:"ready",ERROR:"error"},fn={LAYERS:"layers"},gn=function(t){function e(e){var i=e||{},r=u({},i);delete r.layers;var n=i.layers;t.call(this,r),this.layersListenerKeys_=[],this.listenerKeys_={},v(this,A(fn.LAYERS),this.handleLayersChanged_,this),n?Array.isArray(n)?n=new Y(n.slice(),{unique:!0}):te("function"==typeof n.getArray,43):n=new Y(void 0,{unique:!0}),this.setLayers(n)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleLayerChange_=function(){this.changed()},e.prototype.handleLayersChanged_=function(){this.layersListenerKeys_.forEach(S),this.layersListenerKeys_.length=0;var t=this.getLayers();for(var e in this.layersListenerKeys_.push(v(t,h.ADD,this.handleLayersAdd_,this),v(t,h.REMOVE,this.handleLayersRemove_,this)),this.listenerKeys_)this.listenerKeys_[e].forEach(S);p(this.listenerKeys_);for(var i=t.getArray(),r=0,n=i.length;r<n;r++){var s=i[r];this.listenerKeys_[o(s)]=[v(s,l,this.handleLayerChange_,this),v(s,M.CHANGE,this.handleLayerChange_,this)]}this.changed()},e.prototype.handleLayersAdd_=function(t){var e=t.element;this.listenerKeys_[o(e)]=[v(e,l,this.handleLayerChange_,this),v(e,M.CHANGE,this.handleLayerChange_,this)],this.changed()},e.prototype.handleLayersRemove_=function(t){var e=o(t.element);this.listenerKeys_[e].forEach(S),delete this.listenerKeys_[e],this.changed()},e.prototype.getLayers=function(){return this.get(fn.LAYERS)},e.prototype.setLayers=function(t){this.set(fn.LAYERS,t)},e.prototype.getLayersArray=function(t){var e=void 0!==t?t:[];return this.getLayers().forEach(function(t){t.getLayersArray(e)}),e},e.prototype.getLayerStatesArray=function(t){var e=void 0!==t?t:[],i=e.length;this.getLayers().forEach(function(t){t.getLayerStatesArray(e)});for(var r=this.getLayerState(),n=i,o=e.length;n<o;n++){var s=e[n];s.opacity*=r.opacity,s.visible=s.visible&&r.visible,s.maxResolution=Math.min(s.maxResolution,r.maxResolution),s.minResolution=Math.max(s.minResolution,r.minResolution),void 0!==r.extent&&(void 0!==s.extent?s.extent=hi(s.extent,r.extent):s.extent=r.extent)}return e},e.prototype.getSourceState=function(){return dn.READY},e}(cn);function _n(t,e){return Array.isArray(t)?t:(void 0===e?e=[t,t]:e[0]=e[1]=t,e)}var yn=function(t){function e(e){t.call(this);var i=function(t){var e=null;void 0!==t.keyboardEventTarget&&(e="string"==typeof t.keyboardEventTarget?document.getElementById(t.keyboardEventTarget):t.keyboardEventTarget);var i,r,n,o={},s=t.layers&&"function"==typeof t.layers.getLayers?t.layers:new gn({layers:t.layers});o[Jt.LAYERGROUP]=s,o[Jt.TARGET]=t.target,o[Jt.VIEW]=void 0!==t.view?t.view:new nn,void 0!==t.controls&&(Array.isArray(t.controls)?i=new Y(t.controls.slice()):(te("function"==typeof t.controls.getArray,47),i=t.controls));void 0!==t.interactions&&(Array.isArray(t.interactions)?r=new Y(t.interactions.slice()):(te("function"==typeof t.interactions.getArray,48),r=t.interactions));void 0!==t.overlays?Array.isArray(t.overlays)?n=new Y(t.overlays.slice()):(te("function"==typeof t.overlays.getArray,49),n=t.overlays):n=new Y;return{controls:i,interactions:r,keyboardEventTarget:e,overlays:n,values:o}}(e);this.maxTilesLoading_=void 0!==e.maxTilesLoading?e.maxTilesLoading:16,this.loadTilesWhileAnimating_=void 0!==e.loadTilesWhileAnimating&&e.loadTilesWhileAnimating,this.loadTilesWhileInteracting_=void 0!==e.loadTilesWhileInteracting&&e.loadTilesWhileInteracting,this.pixelRatio_=void 0!==e.pixelRatio?e.pixelRatio:z,this.animationDelayKey_,this.animationDelay_=function(){this.animationDelayKey_=void 0,this.renderFrame_.call(this,Date.now())}.bind(this),this.coordinateToPixelTransform_=[1,0,0,1,0,0],this.pixelToCoordinateTransform_=[1,0,0,1,0,0],this.frameIndex_=0,this.frameState_=null,this.previousExtent_=null,this.viewPropertyListenerKey_=null,this.viewChangeListenerKey_=null,this.layerGroupPropertyListenerKeys_=null,this.viewport_=document.createElement("div"),this.viewport_.className="ol-viewport"+(H?" ol-touch":""),this.viewport_.style.position="relative",this.viewport_.style.overflow="hidden",this.viewport_.style.width="100%",this.viewport_.style.height="100%",this.viewport_.style.msTouchAction="none",this.viewport_.style.touchAction="none",this.overlayContainer_=document.createElement("div"),this.overlayContainer_.className="ol-overlaycontainer",this.viewport_.appendChild(this.overlayContainer_),this.overlayContainerStopEvent_=document.createElement("div"),this.overlayContainerStopEvent_.className="ol-overlaycontainer-stopevent";for(var r=[M.CLICK,M.DBLCLICK,M.MOUSEDOWN,M.TOUCHSTART,M.MSPOINTERDOWN,Q.POINTERDOWN,M.MOUSEWHEEL,M.WHEEL],n=0,o=r.length;n<o;++n)v(this.overlayContainerStopEvent_,r[n],O);for(var s in this.viewport_.appendChild(this.overlayContainerStopEvent_),this.mapBrowserEventHandler_=new Ht(this,e.moveTolerance),Q)v(this.mapBrowserEventHandler_,Q[s],this.handleMapBrowserEvent,this);this.keyboardEventTarget_=i.keyboardEventTarget,this.keyHandlerKeys_=null,v(this.viewport_,M.CONTEXTMENU,this.handleBrowserEvent,this),v(this.viewport_,M.WHEEL,this.handleBrowserEvent,this),v(this.viewport_,M.MOUSEWHEEL,this.handleBrowserEvent,this),this.controls=i.controls||new Y,this.interactions=i.interactions||new Y,this.overlays_=i.overlays,this.overlayIdIndex_={},this.renderer_=this.createRenderer(),this.handleResize_,this.focus_=null,this.postRenderFunctions_=[],this.tileQueue_=new ie(this.getTilePriority.bind(this),this.handleTileChange_.bind(this)),this.skippedFeatureUids_={},v(this,A(Jt.LAYERGROUP),this.handleLayerGroupChanged_,this),v(this,A(Jt.VIEW),this.handleViewChanged_,this),v(this,A(Jt.SIZE),this.handleSizeChanged_,this),v(this,A(Jt.TARGET),this.handleTargetChanged_,this),this.setProperties(i.values),this.controls.forEach(function(t){t.setMap(this)}.bind(this)),v(this.controls,h.ADD,function(t){t.element.setMap(this)},this),v(this.controls,h.REMOVE,function(t){t.element.setMap(null)},this),this.interactions.forEach(function(t){t.setMap(this)}.bind(this)),v(this.interactions,h.ADD,function(t){t.element.setMap(this)},this),v(this.interactions,h.REMOVE,function(t){t.element.setMap(null)},this),this.overlays_.forEach(this.addOverlayInternal_.bind(this)),v(this.overlays_,h.ADD,function(t){this.addOverlayInternal_(t.element)},this),v(this.overlays_,h.REMOVE,function(t){var e=t.element.getId();void 0!==e&&delete this.overlayIdIndex_[e.toString()],t.element.setMap(null)},this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createRenderer=function(){throw new Error("Use a map type that has a createRenderer method")},e.prototype.addControl=function(t){this.getControls().push(t)},e.prototype.addInteraction=function(t){this.getInteractions().push(t)},e.prototype.addLayer=function(t){this.getLayerGroup().getLayers().push(t)},e.prototype.addOverlay=function(t){this.getOverlays().push(t)},e.prototype.addOverlayInternal_=function(t){var e=t.getId();void 0!==e&&(this.overlayIdIndex_[e.toString()]=t),t.setMap(this)},e.prototype.disposeInternal=function(){this.mapBrowserEventHandler_.dispose(),E(this.viewport_,M.CONTEXTMENU,this.handleBrowserEvent,this),E(this.viewport_,M.WHEEL,this.handleBrowserEvent,this),E(this.viewport_,M.MOUSEWHEEL,this.handleBrowserEvent,this),void 0!==this.handleResize_&&(removeEventListener(M.RESIZE,this.handleResize_,!1),this.handleResize_=void 0),this.animationDelayKey_&&(cancelAnimationFrame(this.animationDelayKey_),this.animationDelayKey_=void 0),this.setTarget(null),t.prototype.disposeInternal.call(this)},e.prototype.forEachFeatureAtPixel=function(t,e,i){if(this.frameState_){var r=this.getCoordinateFromPixel(t),n=void 0!==(i=void 0!==i?i:{}).hitTolerance?i.hitTolerance*this.frameState_.pixelRatio:0,o=void 0!==i.layerFilter?i.layerFilter:C;return this.renderer_.forEachFeatureAtCoordinate(r,this.frameState_,n,e,null,o,null)}},e.prototype.getFeaturesAtPixel=function(t,e){var i=null;return this.forEachFeatureAtPixel(t,function(t){i||(i=[]),i.push(t)},e),i},e.prototype.forEachLayerAtPixel=function(t,e,i){if(this.frameState_){var r=i||{},n=void 0!==r.hitTolerance?i.hitTolerance*this.frameState_.pixelRatio:0,o=r.layerFilter||C;return this.renderer_.forEachLayerAtPixel(t,this.frameState_,n,e,null,o,null)}},e.prototype.hasFeatureAtPixel=function(t,e){if(!this.frameState_)return!1;var i=this.getCoordinateFromPixel(t),r=void 0!==(e=void 0!==e?e:{}).layerFilter?e.layerFilter:C,n=void 0!==e.hitTolerance?e.hitTolerance*this.frameState_.pixelRatio:0;return this.renderer_.hasFeatureAtCoordinate(i,this.frameState_,n,r,null)},e.prototype.getEventCoordinate=function(t){return this.getCoordinateFromPixel(this.getEventPixel(t))},e.prototype.getEventPixel=function(t){var e=this.viewport_.getBoundingClientRect(),i="changedTouches"in t?t.changedTouches[0]:t;return[i.clientX-e.left,i.clientY-e.top]},e.prototype.getTarget=function(){return this.get(Jt.TARGET)},e.prototype.getTargetElement=function(){var t=this.getTarget();return void 0!==t?"string"==typeof t?document.getElementById(t):t:null},e.prototype.getCoordinateFromPixel=function(t){var e=this.frameState_;return e?lr(e.pixelToCoordinateTransform,t.slice()):null},e.prototype.getControls=function(){return this.controls},e.prototype.getOverlays=function(){return this.overlays_},e.prototype.getOverlayById=function(t){var e=this.overlayIdIndex_[t.toString()];return void 0!==e?e:null},e.prototype.getInteractions=function(){return this.interactions},e.prototype.getLayerGroup=function(){return this.get(Jt.LAYERGROUP)},e.prototype.getLayers=function(){return this.getLayerGroup().getLayers()},e.prototype.getPixelFromCoordinate=function(t){var e=this.frameState_;return e?lr(e.coordinateToPixelTransform,t.slice(0,2)):null},e.prototype.getRenderer=function(){return this.renderer_},e.prototype.getSize=function(){return this.get(Jt.SIZE)},e.prototype.getView=function(){return this.get(Jt.VIEW)},e.prototype.getViewport=function(){return this.viewport_},e.prototype.getOverlayContainer=function(){return this.overlayContainer_},e.prototype.getOverlayContainerStopEvent=function(){return this.overlayContainerStopEvent_},e.prototype.getTilePriority=function(t,e,i,r){var n=this.frameState_;if(!(n&&e in n.wantedTiles))return 1/0;if(!n.wantedTiles[e][t.getKey()])return 1/0;var o=i[0]-n.focus[0],s=i[1]-n.focus[1];return 65536*Math.log(r)+Math.sqrt(o*o+s*s)/r},e.prototype.handleBrowserEvent=function(t,e){var i=e||t.type,r=new j(i,this,t);this.handleMapBrowserEvent(r)},e.prototype.handleMapBrowserEvent=function(t){if(this.frameState_){this.focus_=t.coordinate,t.frameState=this.frameState_;var e=this.getInteractions().getArray();if(!1!==this.dispatchEvent(t))for(var i=e.length-1;i>=0;i--){var r=e[i];if(r.getActive())if(!r.handleEvent(t))break}}},e.prototype.handlePostRender=function(){var t=this.frameState_,e=this.tileQueue_;if(!e.isEmpty()){var i=this.maxTilesLoading_,r=i;if(t){var n=t.viewHints;n[ge]&&(i=this.loadTilesWhileAnimating_?8:0,r=2),n[_e]&&(i=this.loadTilesWhileInteracting_?8:0,r=2)}e.getTilesLoading()<i&&(e.reprioritize(),e.loadMoreTiles(i,r))}!t||!this.hasListener(Qt.RENDERCOMPLETE)||t.animate||this.tileQueue_.getTilesLoading()||function t(e){for(var i=0,r=e.length;i<r;++i){var n=e[i];if("function"==typeof n.getLayers)return t(n.getLayers().getArray());var o=n.getSource();if(o&&o.loading)return!0}return!1}(this.getLayers().getArray())||this.renderer_.dispatchRenderEvent(Qt.RENDERCOMPLETE,t);for(var o=this.postRenderFunctions_,s=0,a=o.length;s<a;++s)o[s](this,t);o.length=0},e.prototype.handleSizeChanged_=function(){this.render()},e.prototype.handleTargetChanged_=function(){var t;if(this.getTarget()&&(t=this.getTargetElement()),this.keyHandlerKeys_){for(var e=0,i=this.keyHandlerKeys_.length;e<i;++e)S(this.keyHandlerKeys_[e]);this.keyHandlerKeys_=null}if(t){t.appendChild(this.viewport_);var r=this.keyboardEventTarget_?this.keyboardEventTarget_:t;this.keyHandlerKeys_=[v(r,M.KEYDOWN,this.handleBrowserEvent,this),v(r,M.KEYPRESS,this.handleBrowserEvent,this)],this.handleResize_||(this.handleResize_=this.updateSize.bind(this),window.addEventListener(M.RESIZE,this.handleResize_,!1))}else this.renderer_.removeLayerRenderers(),ln(this.viewport_),void 0!==this.handleResize_&&(removeEventListener(M.RESIZE,this.handleResize_,!1),this.handleResize_=void 0);this.updateSize()},e.prototype.handleTileChange_=function(){this.render()},e.prototype.handleViewPropertyChanged_=function(){this.render()},e.prototype.handleViewChanged_=function(){this.viewPropertyListenerKey_&&(S(this.viewPropertyListenerKey_),this.viewPropertyListenerKey_=null),this.viewChangeListenerKey_&&(S(this.viewChangeListenerKey_),this.viewChangeListenerKey_=null);var t=this.getView();t&&(this.viewport_.setAttribute("data-view",o(t)),this.viewPropertyListenerKey_=v(t,l,this.handleViewPropertyChanged_,this),this.viewChangeListenerKey_=v(t,M.CHANGE,this.handleViewPropertyChanged_,this)),this.render()},e.prototype.handleLayerGroupChanged_=function(){this.layerGroupPropertyListenerKeys_&&(this.layerGroupPropertyListenerKeys_.forEach(S),this.layerGroupPropertyListenerKeys_=null);var t=this.getLayerGroup();t&&(this.layerGroupPropertyListenerKeys_=[v(t,l,this.render,this),v(t,M.CHANGE,this.render,this)]),this.render()},e.prototype.isRendered=function(){return!!this.frameState_},e.prototype.renderSync=function(){this.animationDelayKey_&&cancelAnimationFrame(this.animationDelayKey_),this.animationDelay_()},e.prototype.render=function(){void 0===this.animationDelayKey_&&(this.animationDelayKey_=requestAnimationFrame(this.animationDelay_))},e.prototype.removeControl=function(t){return this.getControls().remove(t)},e.prototype.removeInteraction=function(t){return this.getInteractions().remove(t)},e.prototype.removeLayer=function(t){return this.getLayerGroup().getLayers().remove(t)},e.prototype.removeOverlay=function(t){return this.getOverlays().remove(t)},e.prototype.renderFrame_=function(t){var e,i=this.getSize(),r=this.getView(),n=[1/0,1/0,-1/0,-1/0],s=this.frameState_,a=null;if(void 0!==i&&function(t){return t[0]>0&&t[1]>0}(i)&&r&&r.isDef()){for(var h=r.getHints(this.frameState_?this.frameState_.viewHints:void 0),l=this.getLayerGroup().getLayerStatesArray(),u={},p=0,c=l.length;p<c;++p)u[o(l[p].layer)]=l[p];e=r.getState(this.pixelRatio_),a={animate:!1,coordinateToPixelTransform:this.coordinateToPixelTransform_,extent:n,focus:this.focus_?this.focus_:e.center,index:this.frameIndex_++,layerStates:u,layerStatesArray:l,pixelRatio:this.pixelRatio_,pixelToCoordinateTransform:this.pixelToCoordinateTransform_,postRenderFunctions:[],size:i,skippedFeatureUids:this.skippedFeatureUids_,tileQueue:this.tileQueue_,time:t,usedTiles:{},viewState:e,viewHints:h,wantedTiles:{}}}if(a&&(a.extent=si(e.center,e.resolution,e.rotation,a.size,n)),this.frameState_=a,this.renderer_.renderFrame(a),a){if(a.animate&&this.render(),Array.prototype.push.apply(this.postRenderFunctions_,a.postRenderFunctions),s)(!this.previousExtent_||!di(this.previousExtent_)&&!Ze(a.extent,this.previousExtent_))&&(this.dispatchEvent(new U(qt.MOVESTART,this,s)),this.previousExtent_=We(this.previousExtent_));this.previousExtent_&&!a.viewHints[ge]&&!a.viewHints[_e]&&!Ze(a.extent,this.previousExtent_)&&(this.dispatchEvent(new U(qt.MOVEEND,this,a)),De(a.extent,this.previousExtent_))}this.dispatchEvent(new U(qt.POSTRENDER,this,a)),setTimeout(this.handlePostRender.bind(this),0)},e.prototype.setLayerGroup=function(t){this.set(Jt.LAYERGROUP,t)},e.prototype.setSize=function(t){this.set(Jt.SIZE,t)},e.prototype.setTarget=function(t){this.set(Jt.TARGET,t)},e.prototype.setView=function(t){this.set(Jt.VIEW,t)},e.prototype.skipFeature=function(t){this.skippedFeatureUids_[o(t)]=!0,this.render()},e.prototype.updateSize=function(){var t=this.getTargetElement();if(t){var e=getComputedStyle(t);this.setSize([t.offsetWidth-parseFloat(e.borderLeftWidth)-parseFloat(e.paddingLeft)-parseFloat(e.paddingRight)-parseFloat(e.borderRightWidth),t.offsetHeight-parseFloat(e.borderTopWidth)-parseFloat(e.paddingTop)-parseFloat(e.paddingBottom)-parseFloat(e.borderBottomWidth)])}else this.setSize(void 0)},e.prototype.unskipFeature=function(t){delete this.skippedFeatureUids_[o(t)],this.render()},e}(G);var vn,mn,En=function(t){function e(e){t.call(this),this.element=e.element?e.element:null,this.target_=null,this.map_=null,this.listenerKeys=[],this.render=e.render?e.render:w,e.target&&this.setTarget(e.target)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){ln(this.element),t.prototype.disposeInternal.call(this)},e.prototype.getMap=function(){return this.map_},e.prototype.setMap=function(t){this.map_&&ln(this.element);for(var e=0,i=this.listenerKeys.length;e<i;++e)S(this.listenerKeys[e]);(this.listenerKeys.length=0,this.map_=t,this.map_)&&((this.target_?this.target_:t.getOverlayContainerStopEvent()).appendChild(this.element),this.render!==w&&this.listenerKeys.push(v(t,qt.POSTRENDER,this.render,this)),t.render())},e.prototype.setTarget=function(t){this.target_="string"==typeof t?document.getElementById(t):t},e}(G),Sn="ol-hidden",Tn="ol-selectable",Rn="ol-unselectable",Cn="ol-control",xn="ol-collapsed",wn=(mn={},function(t){if(vn||(vn=document.createElement("div").style),!(t in mn)){vn.font=t;var e=vn.fontFamily;if(vn.font="",!e)return null;mn[t]=e.split(/,\s?/)}return mn[t]});function In(t,e){return t.visible&&e>=t.minResolution&&e<t.maxResolution}var On=function(t){function e(e){var i=u({},e);delete i.source,t.call(this,i),this.mapPrecomposeKey_=null,this.mapRenderKey_=null,this.sourceChangeKey_=null,e.map&&this.setMap(e.map),v(this,A(pn.SOURCE),this.handleSourcePropertyChange_,this);var r=e.source?e.source:null;this.setSource(r)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getLayersArray=function(t){var e=t||[];return e.push(this),e},e.prototype.getLayerStatesArray=function(t){var e=t||[];return e.push(this.getLayerState()),e},e.prototype.getSource=function(){return this.get(pn.SOURCE)||null},e.prototype.getSourceState=function(){var t=this.getSource();return t?t.getState():dn.UNDEFINED},e.prototype.handleSourceChange_=function(){this.changed()},e.prototype.handleSourcePropertyChange_=function(){this.sourceChangeKey_&&(S(this.sourceChangeKey_),this.sourceChangeKey_=null);var t=this.getSource();t&&(this.sourceChangeKey_=v(t,M.CHANGE,this.handleSourceChange_,this)),this.changed()},e.prototype.setMap=function(t){this.mapPrecomposeKey_&&(S(this.mapPrecomposeKey_),this.mapPrecomposeKey_=null),t||this.changed(),this.mapRenderKey_&&(S(this.mapRenderKey_),this.mapRenderKey_=null),t&&(this.mapPrecomposeKey_=v(t,Qt.PRECOMPOSE,function(t){var e=t,i=this.getLayerState();i.managed=!1,void 0===this.getZIndex()&&(i.zIndex=1/0),e.frameState.layerStatesArray.push(i),e.frameState.layerStates[o(this)]=i},this),this.mapRenderKey_=v(this,M.CHANGE,t.render,t),this.changed())},e.prototype.setSource=function(t){this.set(pn.SOURCE,t)},e}(cn);function Ln(t){this.updateElement_(t.frameState)}var Pn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Ln,target:i.target}),this.ulElement_=document.createElement("ul"),this.collapsed_=void 0===i.collapsed||i.collapsed,this.overrideCollapsible_=void 0!==i.collapsible,this.collapsible_=void 0===i.collapsible||i.collapsible,this.collapsible_||(this.collapsed_=!1);var r=void 0!==i.className?i.className:"ol-attribution",n=void 0!==i.tipLabel?i.tipLabel:"Attributions",o=void 0!==i.collapseLabel?i.collapseLabel:"»";"string"==typeof o?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=o):this.collapseLabel_=o;var s=void 0!==i.label?i.label:"i";"string"==typeof s?(this.label_=document.createElement("span"),this.label_.textContent=s):this.label_=s;var a=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_,h=document.createElement("button");h.setAttribute("type","button"),h.title=n,h.appendChild(a),v(h,M.CLICK,this.handleClick_,this);var l=r+" "+Rn+" "+Cn+(this.collapsed_&&this.collapsible_?" "+xn:"")+(this.collapsible_?"":" ol-uncollapsible"),u=this.element;u.className=l,u.appendChild(this.ulElement_),u.appendChild(h),this.renderedAttributions_=[],this.renderedVisible_=!0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.collectSourceAttributions_=function(t){for(var e={},i=[],r=t.layerStatesArray,n=t.viewState.resolution,o=0,s=r.length;o<s;++o){var a=r[o];if(In(a,n)){var h=a.layer.getSource();if(h){var l=h.getAttributions();if(l){var u=l(t);if(u)if(this.overrideCollapsible_||!1!==h.getAttributionsCollapsible()||this.setCollapsible(!1),Array.isArray(u))for(var p=0,c=u.length;p<c;++p)u[p]in e||(i.push(u[p]),e[u[p]]=!0);else u in e||(i.push(u),e[u]=!0)}}}}return i},e.prototype.updateElement_=function(t){if(t){var e=this.collectSourceAttributions_(t),i=e.length>0;if(this.renderedVisible_!=i&&(this.element.style.display=i?"":"none",this.renderedVisible_=i),!Ut(e,this.renderedAttributions_)){un(this.ulElement_);for(var r=0,n=e.length;r<n;++r){var o=document.createElement("li");o.innerHTML=e[r],this.ulElement_.appendChild(o)}this.renderedAttributions_=e}}else this.renderedVisible_&&(this.element.style.display="none",this.renderedVisible_=!1)},e.prototype.handleClick_=function(t){t.preventDefault(),this.handleToggle_()},e.prototype.handleToggle_=function(){this.element.classList.toggle(xn),this.collapsed_?hn(this.collapseLabel_,this.label_):hn(this.label_,this.collapseLabel_),this.collapsed_=!this.collapsed_},e.prototype.getCollapsible=function(){return this.collapsible_},e.prototype.setCollapsible=function(t){this.collapsible_!==t&&(this.collapsible_=t,this.element.classList.toggle("ol-uncollapsible"),!t&&this.collapsed_&&this.handleToggle_())},e.prototype.setCollapsed=function(t){this.collapsible_&&this.collapsed_!==t&&this.handleToggle_()},e.prototype.getCollapsed=function(){return this.collapsed_},e}(En);function Mn(t){var e=t.frameState;if(e){var i=e.viewState.rotation;if(i!=this.rotation_){var r="rotate("+i+"rad)";if(this.autoHide_){var n=this.element.classList.contains(Sn);n||0!==i?n&&0!==i&&this.element.classList.remove(Sn):this.element.classList.add(Sn)}this.label_.style.msTransform=r,this.label_.style.webkitTransform=r,this.label_.style.transform=r}this.rotation_=i}}var Fn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Mn,target:i.target});var r=void 0!==i.className?i.className:"ol-rotate",n=void 0!==i.label?i.label:"⇧";this.label_=null,"string"==typeof n?(this.label_=document.createElement("span"),this.label_.className="ol-compass",this.label_.textContent=n):(this.label_=n,this.label_.classList.add("ol-compass"));var o=i.tipLabel?i.tipLabel:"Reset rotation",s=document.createElement("button");s.className=r+"-reset",s.setAttribute("type","button"),s.title=o,s.appendChild(this.label_),v(s,M.CLICK,this.handleClick_,this);var a=r+" "+Rn+" "+Cn,h=this.element;h.className=a,h.appendChild(s),this.callResetNorth_=i.resetNorth?i.resetNorth:void 0,this.duration_=void 0!==i.duration?i.duration:250,this.autoHide_=void 0===i.autoHide||i.autoHide,this.rotation_=void 0,this.autoHide_&&this.element.classList.add(Sn)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t){t.preventDefault(),void 0!==this.callResetNorth_?this.callResetNorth_():this.resetNorth_()},e.prototype.resetNorth_=function(){var t=this.getMap().getView();t&&void 0!==t.getRotation()&&(this.duration_>0?t.animate({rotation:0,duration:this.duration_,easing:Pe}):t.setRotation(0))},e}(En),bn=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),target:i.target});var r=void 0!==i.className?i.className:"ol-zoom",n=void 0!==i.delta?i.delta:1,o=void 0!==i.zoomInLabel?i.zoomInLabel:"+",s=void 0!==i.zoomOutLabel?i.zoomOutLabel:"−",a=void 0!==i.zoomInTipLabel?i.zoomInTipLabel:"Zoom in",h=void 0!==i.zoomOutTipLabel?i.zoomOutTipLabel:"Zoom out",l=document.createElement("button");l.className=r+"-in",l.setAttribute("type","button"),l.title=a,l.appendChild("string"==typeof o?document.createTextNode(o):o),v(l,M.CLICK,this.handleClick_.bind(this,n));var u=document.createElement("button");u.className=r+"-out",u.setAttribute("type","button"),u.title=h,u.appendChild("string"==typeof s?document.createTextNode(s):s),v(u,M.CLICK,this.handleClick_.bind(this,-n));var p=r+" "+Rn+" "+Cn,c=this.element;c.className=p,c.appendChild(l),c.appendChild(u),this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t,e){e.preventDefault(),this.zoomByDelta_(t)},e.prototype.zoomByDelta_=function(t){var e=this.getMap().getView();if(e){var i=e.getResolution();if(i){var r=e.constrainResolution(i,t);this.duration_>0?(e.getAnimating()&&e.cancelAnimations(),e.animate({resolution:r,duration:this.duration_,easing:Pe})):e.setResolution(r)}}},e}(En);var Nn=function(t,e,i){this.decay_=t,this.minVelocity_=e,this.delay_=i,this.points_=[],this.angle_=0,this.initialVelocity_=0};Nn.prototype.begin=function(){this.points_.length=0,this.angle_=0,this.initialVelocity_=0},Nn.prototype.update=function(t,e){this.points_.push(t,e,Date.now())},Nn.prototype.end=function(){if(this.points_.length<6)return!1;var t=Date.now()-this.delay_,e=this.points_.length-3;if(this.points_[e+2]<t)return!1;for(var i=e-3;i>0&&this.points_[i+2]>t;)i-=3;var r=this.points_[e+2]-this.points_[i+2];if(r<1e3/60)return!1;var n=this.points_[e]-this.points_[i],o=this.points_[e+1]-this.points_[i+1];return this.angle_=Math.atan2(o,n),this.initialVelocity_=Math.sqrt(n*n+o*o)/r,this.initialVelocity_>this.minVelocity_},Nn.prototype.getDistance=function(){return(this.minVelocity_-this.initialVelocity_)/this.decay_},Nn.prototype.getAngle=function(){return this.angle_};var An=Nn,Gn={ACTIVE:"active"};function Dn(t,e,i,r){e=t.constrainRotation(e,0),kn(t,e,i,r)}function kn(t,e,i,r){if(void 0!==e){var n=t.getRotation(),o=t.getCenter();void 0!==n&&o&&r>0?t.animate({rotation:e,anchor:i,duration:r,easing:Pe}):t.rotate(e,i)}}function Yn(t,e,i,r){var n=t.getResolution(),o=t.constrainResolution(n,e,0);if(void 0!==o){var s=t.getResolutions();o=oe(o,t.getMinResolution()||s[s.length-1],t.getMaxResolution()||s[0])}if(i&&void 0!==o&&o!==n){var a=t.getCenter(),h=t.calculateCenterZoom(o,i);h=t.constrainCenter(h),i=[(o*a[0]-n*h[0])/(o-n),(o*a[1]-n*h[1])/(o-n)]}Un(t,o,i,r)}function Un(t,e,i,r){if(e){var n=t.getResolution(),o=t.getCenter();if(void 0!==n&&o&&e!==n&&r)t.animate({resolution:e,anchor:i,duration:r,easing:Pe});else{if(i){var s=t.calculateCenterZoom(e,i);t.setCenter(s)}t.setResolution(e)}}}var jn=function(t){function e(e){t.call(this),e.handleEvent&&(this.handleEvent=e.handleEvent),this.map_=null,this.setActive(!0)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getActive=function(){return this.get(Gn.ACTIVE)},e.prototype.getMap=function(){return this.map_},e.prototype.handleEvent=function(t){return!0},e.prototype.setActive=function(t){this.set(Gn.ACTIVE,t)},e.prototype.setMap=function(t){this.map_=t},e}(G);function Xn(t){var e=!1;if(t.type==Q.DBLCLICK){var i=t.originalEvent,r=t.map,n=t.coordinate,o=i.shiftKey?-this.delta_:this.delta_;Yn(r.getView(),o,n,this.duration_),t.preventDefault(),e=!0}return!e}var Bn=function(t){function e(e){t.call(this,{handleEvent:Xn});var i=e||{};this.delta_=i.delta?i.delta:1,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn),Vn=function(t){var e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey},Wn=function(t){var e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},Kn=function(t){return t.target.getTargetElement()===document.activeElement},zn=C,Zn=function(t){var e=t.originalEvent;return 0==e.button&&!(W&&K&&e.ctrlKey)},Hn=x,qn=function(t){return"pointermove"==t.type},Jn=function(t){return t.type==Q.SINGLECLICK},Qn=function(t){var e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey},$n=function(t){var e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},to=function(t){var e=t.originalEvent.target.tagName;return"INPUT"!==e&&"SELECT"!==e&&"TEXTAREA"!==e},eo=function(t){var e=t.pointerEvent;return te(void 0!==e,56),"mouse"==e.pointerType},io=function(t){var e=t.pointerEvent;return te(void 0!==e,56),e.isPrimary&&0===e.button};function ro(t){for(var e=t.length,i=0,r=0,n=0;n<e;n++)i+=t[n].clientX,r+=t[n].clientY;return[i/e,r/e]}var no=function(t){function e(e){var i=e||{};t.call(this,i),i.handleDownEvent&&(this.handleDownEvent=i.handleDownEvent),i.handleDragEvent&&(this.handleDragEvent=i.handleDragEvent),i.handleMoveEvent&&(this.handleMoveEvent=i.handleMoveEvent),i.handleUpEvent&&(this.handleUpEvent=i.handleUpEvent),i.stopDown&&(this.stopDown=i.stopDown),this.handlingDownUpSequence=!1,this.trackedPointers_={},this.targetPointers=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDownEvent=function(t){return!1},e.prototype.handleDragEvent=function(t){},e.prototype.handleEvent=function(t){if(!t.pointerEvent)return!0;var e=!1;if(this.updateTrackedPointers_(t),this.handlingDownUpSequence){if(t.type==Q.POINTERDRAG)this.handleDragEvent(t);else if(t.type==Q.POINTERUP){var i=this.handleUpEvent(t);this.handlingDownUpSequence=i&&this.targetPointers.length>0}}else if(t.type==Q.POINTERDOWN){var r=this.handleDownEvent(t);r&&t.preventDefault(),this.handlingDownUpSequence=r,e=this.stopDown(r)}else t.type==Q.POINTERMOVE&&this.handleMoveEvent(t);return!e},e.prototype.handleMoveEvent=function(t){},e.prototype.handleUpEvent=function(t){return!1},e.prototype.stopDown=function(t){return t},e.prototype.updateTrackedPointers_=function(t){if(function(t){var e=t.type;return e===Q.POINTERDOWN||e===Q.POINTERDRAG||e===Q.POINTERUP}(t)){var e=t.pointerEvent,i=e.pointerId.toString();t.type==Q.POINTERUP?delete this.trackedPointers_[i]:t.type==Q.POINTERDOWN?this.trackedPointers_[i]=e:i in this.trackedPointers_&&(this.trackedPointers_[i]=e),this.targetPointers=c(this.trackedPointers_)}},e}(jn),oo=function(t){function e(e){t.call(this,{stopDown:x});var i=e||{};this.kinetic_=i.kinetic,this.lastCentroid=null,this.lastPointersCount_,this.panning_=!1,this.condition_=i.condition?i.condition:Qn,this.noKinetic_=!1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){this.panning_||(this.panning_=!0,this.getMap().getView().setHint(_e,1));var e=this.targetPointers,i=ro(e);if(e.length==this.lastPointersCount_){if(this.kinetic_&&this.kinetic_.update(i[0],i[1]),this.lastCentroid){var r=this.lastCentroid[0]-i[0],n=i[1]-this.lastCentroid[1],o=t.map.getView(),s=[r,n];xe(s,o.getResolution()),Ce(s,o.getRotation()),Se(s,o.getCenter()),s=o.constrainCenter(s),o.setCenter(s)}}else this.kinetic_&&this.kinetic_.begin();this.lastCentroid=i,this.lastPointersCount_=e.length},e.prototype.handleUpEvent=function(t){var e=t.map,i=e.getView();if(0===this.targetPointers.length){if(!this.noKinetic_&&this.kinetic_&&this.kinetic_.end()){var r=this.kinetic_.getDistance(),n=this.kinetic_.getAngle(),o=i.getCenter(),s=e.getPixelFromCoordinate(o),a=e.getCoordinateFromPixel([s[0]-r*Math.cos(n),s[1]-r*Math.sin(n)]);i.animate({center:i.constrainCenter(a),duration:500,easing:Pe})}return this.panning_&&(this.panning_=!1,i.setHint(_e,-1)),!1}return this.kinetic_&&this.kinetic_.begin(),this.lastCentroid=null,!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>0&&this.condition_(t)){var e=t.map.getView();return this.lastCentroid=null,e.getAnimating()&&e.setCenter(t.frameState.viewState.center),this.kinetic_&&this.kinetic_.begin(),this.noKinetic_=this.targetPointers.length>1,!0}return!1},e}(no),so=function(t){function e(e){var i=e||{};t.call(this,{stopDown:x}),this.condition_=i.condition?i.condition:Wn,this.lastAngle_=void 0,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){if(eo(t)){var e=t.map,i=e.getView();if(i.getConstraints().rotation!==de){var r=e.getSize(),n=t.pixel,o=Math.atan2(r[1]/2-n[1],n[0]-r[0]/2);if(void 0!==this.lastAngle_){var s=o-this.lastAngle_,a=i.getRotation();kn(i,a-s)}this.lastAngle_=o}}},e.prototype.handleUpEvent=function(t){if(!eo(t))return!0;var e=t.map.getView();e.setHint(_e,-1);var i=e.getRotation();return Dn(e,i,void 0,this.duration_),!1},e.prototype.handleDownEvent=function(t){return!!eo(t)&&(!(!Zn(t)||!this.condition_(t))&&(t.map.getView().setHint(_e,1),this.lastAngle_=void 0,!0))},e}(no),ao=function(t){function e(e){t.call(this),this.geometry_=null,this.element_=document.createElement("div"),this.element_.style.position="absolute",this.element_.className="ol-box "+e,this.map_=null,this.startPixel_=null,this.endPixel_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.setMap(null)},e.prototype.render_=function(){var t=this.startPixel_,e=this.endPixel_,i=this.element_.style;i.left=Math.min(t[0],e[0])+"px",i.top=Math.min(t[1],e[1])+"px",i.width=Math.abs(e[0]-t[0])+"px",i.height=Math.abs(e[1]-t[1])+"px"},e.prototype.setMap=function(t){if(this.map_){this.map_.getOverlayContainer().removeChild(this.element_);var e=this.element_.style;e.left=e.top=e.width=e.height="inherit"}this.map_=t,this.map_&&this.map_.getOverlayContainer().appendChild(this.element_)},e.prototype.setPixels=function(t,e){this.startPixel_=t,this.endPixel_=e,this.createOrUpdateGeometry(),this.render_()},e.prototype.createOrUpdateGeometry=function(){var t=this.startPixel_,e=this.endPixel_,i=[t,[t[0],e[1]],e,[e[0],t[1]]].map(this.map_.getCoordinateFromPixel,this.map_);i[4]=i[0].slice(),this.geometry_?this.geometry_.setCoordinates([i]):this.geometry_=new qr([i])},e.prototype.getGeometry=function(){return this.geometry_},e}(R),ho="boxstart",lo="boxdrag",uo="boxend",po=function(t){function e(e,i,r){t.call(this,e),this.coordinate=i,this.mapBrowserEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function co(){var t,e,i=this.getMap(),r=i.getView(),n=i.getSize(),o=this.getGeometry().getExtent();if(this.out_){var s=r.calculateExtent(n),a=(t=[i.getPixelFromCoordinate(ii(o)),i.getPixelFromCoordinate(ui(o))],Je(We(e),t));fi(s,1/r.getResolutionForExtent(a,n)),o=s}var h=r.constrainResolution(r.getResolutionForExtent(o,n)),l=ni(o);l=r.constrainCenter(l),r.animate({resolution:h,center:l,duration:this.duration_,easing:Pe})}var fo=function(t){function e(e){var i=e||{},r=i.condition?i.condition:$n;t.call(this,{condition:r,className:i.className||"ol-dragzoom",onBoxEnd:co}),this.duration_=void 0!==i.duration?i.duration:200,this.out_=void 0!==i.out&&i.out}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(function(t){function e(e){t.call(this);var i=e||{};this.box_=new ao(i.className||"ol-dragbox"),this.minArea_=void 0!==i.minArea?i.minArea:64,this.onBoxEnd_=i.onBoxEnd?i.onBoxEnd:w,this.startPixel_=null,this.condition_=i.condition?i.condition:zn,this.boxEndCondition_=i.boxEndCondition?i.boxEndCondition:this.defaultBoxEndCondition}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.defaultBoxEndCondition=function(t,e,i){var r=i[0]-e[0],n=i[1]-e[1];return r*r+n*n>=this.minArea_},e.prototype.getGeometry=function(){return this.box_.getGeometry()},e.prototype.handleDragEvent=function(t){eo(t)&&(this.box_.setPixels(this.startPixel_,t.pixel),this.dispatchEvent(new po(lo,t.coordinate,t)))},e.prototype.handleUpEvent=function(t){return!eo(t)||(this.box_.setMap(null),this.boxEndCondition_(t,this.startPixel_,t.pixel)&&(this.onBoxEnd_(t),this.dispatchEvent(new po(uo,t.coordinate,t))),!1)},e.prototype.handleDownEvent=function(t){return!!eo(t)&&(!(!Zn(t)||!this.condition_(t))&&(this.startPixel_=t.pixel,this.box_.setMap(t.map),this.box_.setPixels(this.startPixel_,this.startPixel_),this.dispatchEvent(new po(ho,t.coordinate,t)),!0))},e}(no)),go={LEFT:37,UP:38,RIGHT:39,DOWN:40};function _o(t){var e=!1;if(t.type==M.KEYDOWN){var i=t.originalEvent.keyCode;if(this.condition_(t)&&(i==go.DOWN||i==go.LEFT||i==go.RIGHT||i==go.UP)){var r=t.map.getView(),n=r.getResolution()*this.pixelDelta_,o=0,s=0;i==go.DOWN?s=-n:i==go.LEFT?o=-n:i==go.RIGHT?o=n:s=n;var a=[o,s];Ce(a,r.getRotation()),function(t,e,i){var r=t.getCenter();if(r){var n=t.constrainCenter([r[0]+e[0],r[1]+e[1]]);i?t.animate({duration:i,easing:Fe,center:n}):t.setCenter(n)}}(r,a,this.duration_),t.preventDefault(),e=!0}}return!e}var yo=function(t){function e(e){t.call(this,{handleEvent:_o});var i=e||{};this.defaultCondition_=function(t){return Qn(t)&&to(t)},this.condition_=void 0!==i.condition?i.condition:this.defaultCondition_,this.duration_=void 0!==i.duration?i.duration:100,this.pixelDelta_=void 0!==i.pixelDelta?i.pixelDelta:128}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn);function vo(t){var e=!1;if(t.type==M.KEYDOWN||t.type==M.KEYPRESS){var i=t.originalEvent.charCode;if(this.condition_(t)&&(i=="+".charCodeAt(0)||i=="-".charCodeAt(0))){var r=t.map,n=i=="+".charCodeAt(0)?this.delta_:-this.delta_;Yn(r.getView(),n,void 0,this.duration_),t.preventDefault(),e=!0}}return!e}var mo=function(t){function e(e){t.call(this,{handleEvent:vo});var i=e||{};this.condition_=i.condition?i.condition:to,this.delta_=i.delta?i.delta:1,this.duration_=void 0!==i.duration?i.duration:100}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(jn),Eo="trackpad",So="wheel",To=function(t){function e(e){var i=e||{};t.call(this,i),this.delta_=0,this.duration_=void 0!==i.duration?i.duration:250,this.timeout_=void 0!==i.timeout?i.timeout:80,this.useAnchor_=void 0===i.useAnchor||i.useAnchor,this.constrainResolution_=i.constrainResolution||!1,this.condition_=i.condition?i.condition:zn,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_,this.mode_=void 0,this.trackpadEventGap_=400,this.trackpadTimeoutId_,this.trackpadDeltaPerZoom_=300,this.trackpadZoomBuffer_=1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.decrementInteractingHint_=function(){this.trackpadTimeoutId_=void 0,this.getMap().getView().setHint(_e,-1)},e.prototype.handleEvent=function(t){if(!this.condition_(t))return!0;var e=t.type;if(e!==M.WHEEL&&e!==M.MOUSEWHEEL)return!0;t.preventDefault();var i,r=t.map,n=t.originalEvent;if(this.useAnchor_&&(this.lastAnchor_=t.coordinate),t.type==M.WHEEL?(i=n.deltaY,B&&n.deltaMode===WheelEvent.DOM_DELTA_PIXEL&&(i/=z),n.deltaMode===WheelEvent.DOM_DELTA_LINE&&(i*=40)):t.type==M.MOUSEWHEEL&&(i=-n.wheelDeltaY,V&&(i/=3)),0===i)return!1;var o=Date.now();if(void 0===this.startTime_&&(this.startTime_=o),(!this.mode_||o-this.startTime_>this.trackpadEventGap_)&&(this.mode_=Math.abs(i)<4?Eo:So),this.mode_===Eo){var s=r.getView();this.trackpadTimeoutId_?clearTimeout(this.trackpadTimeoutId_):s.setHint(_e,1),this.trackpadTimeoutId_=setTimeout(this.decrementInteractingHint_.bind(this),this.trackpadEventGap_);var a=s.getResolution()*Math.pow(2,i/this.trackpadDeltaPerZoom_),h=s.getMinResolution(),l=s.getMaxResolution(),u=0;if(a<h?(a=Math.max(a,h/this.trackpadZoomBuffer_),u=1):a>l&&(a=Math.min(a,l*this.trackpadZoomBuffer_),u=-1),this.lastAnchor_){var p=s.calculateCenterZoom(a,this.lastAnchor_);s.setCenter(s.constrainCenter(p))}return s.setResolution(a),0===u&&this.constrainResolution_&&s.animate({resolution:s.constrainResolution(a,i>0?-1:1),easing:Pe,anchor:this.lastAnchor_,duration:this.duration_}),u>0?s.animate({resolution:h,easing:Pe,anchor:this.lastAnchor_,duration:500}):u<0&&s.animate({resolution:l,easing:Pe,anchor:this.lastAnchor_,duration:500}),this.startTime_=o,!1}this.delta_+=i;var c=Math.max(this.timeout_-(o-this.startTime_),0);return clearTimeout(this.timeoutId_),this.timeoutId_=setTimeout(this.handleWheelZoom_.bind(this,r),c),!1},e.prototype.handleWheelZoom_=function(t){var e=t.getView();e.getAnimating()&&e.cancelAnimations();Yn(e,-oe(this.delta_,-1,1),this.lastAnchor_,this.duration_),this.mode_=void 0,this.delta_=0,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_=void 0},e.prototype.setMouseAnchor=function(t){this.useAnchor_=t,t||(this.lastAnchor_=null)},e}(jn),Ro=function(t){function e(e){var i=e||{},r=i;r.stopDown||(r.stopDown=x),t.call(this,r),this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.threshold_=void 0!==i.threshold?i.threshold:.3,this.duration_=void 0!==i.duration?i.duration:250}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){var e=0,i=this.targetPointers[0],r=this.targetPointers[1],n=Math.atan2(r.clientY-i.clientY,r.clientX-i.clientX);if(void 0!==this.lastAngle_){var o=n-this.lastAngle_;this.rotationDelta_+=o,!this.rotating_&&Math.abs(this.rotationDelta_)>this.threshold_&&(this.rotating_=!0),e=o}this.lastAngle_=n;var s=t.map,a=s.getView();if(a.getConstraints().rotation!==de){var h=s.getViewport().getBoundingClientRect(),l=ro(this.targetPointers);if(l[0]-=h.left,l[1]-=h.top,this.anchor_=s.getCoordinateFromPixel(l),this.rotating_){var u=a.getRotation();s.render(),kn(a,u+e,this.anchor_)}}},e.prototype.handleUpEvent=function(t){if(this.targetPointers.length<2){var e=t.map.getView();if(e.setHint(_e,-1),this.rotating_){var i=e.getRotation();Dn(e,i,this.anchor_,this.duration_)}return!1}return!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>=2){var e=t.map;return this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.handlingDownUpSequence||e.getView().setHint(_e,1),!0}return!1},e}(no),Co=function(t){function e(e){var i=e||{},r=i;r.stopDown||(r.stopDown=x),t.call(this,r),this.constrainResolution_=i.constrainResolution||!1,this.anchor_=null,this.duration_=void 0!==i.duration?i.duration:400,this.lastDistance_=void 0,this.lastScaleDelta_=1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDragEvent=function(t){var e=1,i=this.targetPointers[0],r=this.targetPointers[1],n=i.clientX-r.clientX,o=i.clientY-r.clientY,s=Math.sqrt(n*n+o*o);void 0!==this.lastDistance_&&(e=this.lastDistance_/s),this.lastDistance_=s;var a=t.map,h=a.getView(),l=h.getResolution(),u=h.getMaxResolution(),p=h.getMinResolution(),c=l*e;c>u?(e=u/l,c=u):c<p&&(e=p/l,c=p),1!=e&&(this.lastScaleDelta_=e);var d=a.getViewport().getBoundingClientRect(),f=ro(this.targetPointers);f[0]-=d.left,f[1]-=d.top,this.anchor_=a.getCoordinateFromPixel(f),a.render(),Un(h,c,this.anchor_)},e.prototype.handleUpEvent=function(t){if(this.targetPointers.length<2){var e=t.map.getView();e.setHint(_e,-1);var i=e.getResolution();if(this.constrainResolution_||i<e.getMinResolution()||i>e.getMaxResolution()){var r=this.lastScaleDelta_-1;!function(t,e,i,r,n){e=t.constrainResolution(e,0,n),Un(t,e,i,r)}(e,i,this.anchor_,this.duration_,r)}return!1}return!0},e.prototype.handleDownEvent=function(t){if(this.targetPointers.length>=2){var e=t.map;return this.anchor_=null,this.lastDistance_=void 0,this.lastScaleDelta_=1,this.handlingDownUpSequence||e.getView().setHint(_e,1),!0}return!1},e}(no);function xo(t){var e=t||{},i=new Y,r=new An(-.005,.05,100);return(void 0===e.altShiftDragRotate||e.altShiftDragRotate)&&i.push(new so),(void 0===e.doubleClickZoom||e.doubleClickZoom)&&i.push(new Bn({delta:e.zoomDelta,duration:e.zoomDuration})),(void 0===e.dragPan||e.dragPan)&&i.push(new oo({condition:e.onFocusOnly?Kn:void 0,kinetic:r})),(void 0===e.pinchRotate||e.pinchRotate)&&i.push(new Ro),(void 0===e.pinchZoom||e.pinchZoom)&&i.push(new Co({constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.keyboard||e.keyboard)&&(i.push(new yo),i.push(new mo({delta:e.zoomDelta,duration:e.zoomDuration}))),(void 0===e.mouseWheelZoom||e.mouseWheelZoom)&&i.push(new To({condition:e.onFocusOnly?Kn:void 0,constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.shiftDragZoom||e.shiftDragZoom)&&i.push(new fo({duration:e.zoomDuration})),i}var wo=.5,Io=function(t){function e(e,i,r,n){t.call(this),this.extent=e,this.pixelRatio_=r,this.resolution=i,this.state=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){this.dispatchEvent(M.CHANGE)},e.prototype.getExtent=function(){return this.extent},e.prototype.getImage=function(){return r()},e.prototype.getPixelRatio=function(){return this.pixelRatio_},e.prototype.getResolution=function(){return this.resolution},e.prototype.getState=function(){return this.state},e.prototype.load=function(){r()},e}(P),Oo={IDLE:0,LOADING:1,LOADED:2,ERROR:3},Lo=function(t){function e(e,i,r,n,o){var s=void 0!==o?Oo.IDLE:Oo.LOADED;t.call(this,e,i,r,s),this.loader_=void 0!==o?o:null,this.canvas_=n,this.error_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getError=function(){return this.error_},e.prototype.handleLoad_=function(t){t?(this.error_=t,this.state=Oo.ERROR):this.state=Oo.LOADED,this.changed()},e.prototype.load=function(){this.state==Oo.IDLE&&(this.state=Oo.LOADING,this.changed(),this.loader_(this.handleLoad_.bind(this)))},e.prototype.getImage=function(){return this.canvas_},e}(Io),Po={IMAGE:"IMAGE",TILE:"TILE",VECTOR_TILE:"VECTOR_TILE",VECTOR:"VECTOR"},Mo={IMAGE:"image",VECTOR:"vector"},Fo=function(t){function e(e,i,r,n,o){t.call(this,e),this.vectorContext=i,this.frameState=r,this.context=n,this.glContext=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),bo=function(t){function e(e){t.call(this),this.highWaterMark=void 0!==e?e:2048,this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){return this.getCount()>this.highWaterMark},e.prototype.clear=function(){this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null,this.dispatchEvent(M.CLEAR)},e.prototype.containsKey=function(t){return this.entries_.hasOwnProperty(t)},e.prototype.forEach=function(t,e){for(var i=this.oldest_;i;)t.call(e,i.value_,i.key_,this),i=i.newer},e.prototype.get=function(t){var e=this.entries_[t];return te(void 0!==e,15),e===this.newest_?e.value_:(e===this.oldest_?(this.oldest_=this.oldest_.newer,this.oldest_.older=null):(e.newer.older=e.older,e.older.newer=e.newer),e.newer=null,e.older=this.newest_,this.newest_.newer=e,this.newest_=e,e.value_)},e.prototype.remove=function(t){var e=this.entries_[t];return te(void 0!==e,15),e===this.newest_?(this.newest_=e.older,this.newest_&&(this.newest_.newer=null)):e===this.oldest_?(this.oldest_=e.newer,this.oldest_&&(this.oldest_.older=null)):(e.newer.older=e.older,e.older.newer=e.newer),delete this.entries_[t],--this.count_,e.value_},e.prototype.getCount=function(){return this.count_},e.prototype.getKeys=function(){var t,e=new Array(this.count_),i=0;for(t=this.newest_;t;t=t.older)e[i++]=t.key_;return e},e.prototype.getValues=function(){var t,e=new Array(this.count_),i=0;for(t=this.newest_;t;t=t.older)e[i++]=t.value_;return e},e.prototype.peekLast=function(){return this.oldest_.value_},e.prototype.peekLastKey=function(){return this.oldest_.key_},e.prototype.peekFirstKey=function(){return this.newest_.key_},e.prototype.pop=function(){var t=this.oldest_;return delete this.entries_[t.key_],t.newer&&(t.newer.older=null),this.oldest_=t.newer,this.oldest_||(this.newest_=null),--this.count_,t.value_},e.prototype.replace=function(t,e){this.get(t),this.entries_[t].value_=e},e.prototype.set=function(t,e){te(!(t in this.entries_),16);var i={key_:t,newer:null,older:this.newest_,value_:e};this.newest_?this.newest_.newer=i:this.oldest_=i,this.newest_=i,this.entries_[t]=i,++this.count_},e.prototype.setSize=function(t){this.highWaterMark=t},e.prototype.prune=function(){for(;this.canExpireCache();)this.pop()},e}(P),No=[0,0,0,1],Ao=[],Go=[0,0,0,1],Do=[0,0,0,0],ko=new bo,Yo={},Uo=null,jo={},Xo=function(){var t,e,i=60,r=Yo,n="32px ",o=["monospace","serif"],s=o.length,a="wmytzilWMYTZIL@#/&?$%10";function h(t){for(var i=Bo(),r=100;r<=700;r+=300){for(var h=r+" ",l=!0,u=0;u<s;++u){var p=o[u];if(i.font=h+n+p,e=i.measureText(a).width,t!=p){i.font=h+n+t+","+p;var c=i.measureText(a).width;l=l&&c!=e}}if(l)return!0}return!1}function l(){var e=!0;for(var n in r)r[n]<i&&(h(n)?(r[n]=i,p(jo),Uo=null,ko.clear()):(++r[n],e=!1));e&&(clearInterval(t),t=void 0)}return function(e){var n=wn(e);if(n)for(var o=0,s=n.length;o<s;++o){var a=n[o];a in r||(r[a]=i,h(a)||(r[a]=0,void 0===t&&(t=setInterval(l,32))))}}}();function Bo(){return Uo||(Uo=on(1,1)),Uo}var Vo,Wo,Ko=(Wo=jo,function(t){var e=Wo[t];return null==e&&(Vo||((Vo=document.createElement("span")).textContent="M",Vo.style.margin=Vo.style.padding="0 !important",Vo.style.position="absolute !important",Vo.style.left="-99999px !important"),Vo.style.font=t,document.body.appendChild(Vo),e=Wo[t]=Vo.offsetHeight,document.body.removeChild(Vo)),e});function zo(t,e){var i=Bo();return t!=i.font&&(i.font=t),i.measureText(e).width}function Zo(t,e,i,r){0!==e&&(t.translate(i,r),t.rotate(e),t.translate(-i,-r))}var Ho=[1,0,0,1,0,0];function qo(t,e,i,r,n,o,s,a,h,l,u){var p;1!=i&&(p=t.globalAlpha,t.globalAlpha=p*i),e&&t.setTransform.apply(t,e),t.drawImage(r,n,o,s,a,h,l,s*u,a*u),p&&(t.globalAlpha=p),e&&t.setTransform.apply(t,Ho)}var Jo=/^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i,Qo=/^([a-z]*)$/i;function $o(t){return"string"==typeof t?t:rs(t)}var ts=function(){var t={},e=0;return function(i){var r;if(t.hasOwnProperty(i))r=t[i];else{if(e>=1024){var n=0;for(var o in t)0==(3&n++)&&(delete t[o],--e)}r=function(t){var e,i,r,n,o;Qo.exec(t)&&(t=function(t){var e=document.createElement("div");if(e.style.color=t,""!==e.style.color){document.body.appendChild(e);var i=getComputedStyle(e).color;return document.body.removeChild(e),i}return""}(t));if(Jo.exec(t)){var s,a=t.length-1;s=a<=4?1:2;var h=4===a||8===a;e=parseInt(t.substr(1+0*s,s),16),i=parseInt(t.substr(1+1*s,s),16),r=parseInt(t.substr(1+2*s,s),16),n=h?parseInt(t.substr(1+3*s,s),16):255,1==s&&(e=(e<<4)+e,i=(i<<4)+i,r=(r<<4)+r,h&&(n=(n<<4)+n)),o=[e,i,r,n/255]}else 0==t.indexOf("rgba(")?is(o=t.slice(5,-1).split(",").map(Number)):0==t.indexOf("rgb(")?((o=t.slice(4,-1).split(",").map(Number)).push(1),is(o)):te(!1,14);return o}(i),t[i]=r,++e}return r}}();function es(t){return Array.isArray(t)?t:ts(t)}function is(t){return t[0]=oe(t[0]+.5|0,0,255),t[1]=oe(t[1]+.5|0,0,255),t[2]=oe(t[2]+.5|0,0,255),t[3]=oe(t[3],0,1),t}function rs(t){var e=t[0];e!=(0|e)&&(e=e+.5|0);var i=t[1];i!=(0|i)&&(i=i+.5|0);var r=t[2];return r!=(0|r)&&(r=r+.5|0),"rgba("+e+","+i+","+r+","+(void 0===t[3]?1:t[3])+")"}function ns(t){return Array.isArray(t)?rs(t):t}var os=function(){};os.prototype.drawCustom=function(t,e,i){},os.prototype.drawGeometry=function(t){},os.prototype.setStyle=function(t){},os.prototype.drawCircle=function(t,e){},os.prototype.drawFeature=function(t,e){},os.prototype.drawGeometryCollection=function(t,e){},os.prototype.drawLineString=function(t,e){},os.prototype.drawMultiLineString=function(t,e){},os.prototype.drawMultiPoint=function(t,e){},os.prototype.drawMultiPolygon=function(t,e){},os.prototype.drawPoint=function(t,e){},os.prototype.drawPolygon=function(t,e){},os.prototype.drawText=function(t,e){},os.prototype.setFillStrokeStyle=function(t,e){},os.prototype.setImageStyle=function(t,e){},os.prototype.setTextStyle=function(t,e){};var ss=os,as=function(t){function e(e,i,r,n,o){t.call(this),this.context_=e,this.pixelRatio_=i,this.extent_=r,this.transform_=n,this.viewRotation_=o,this.contextFillState_=null,this.contextStrokeState_=null,this.contextTextState_=null,this.fillState_=null,this.strokeState_=null,this.image_=null,this.imageAnchorX_=0,this.imageAnchorY_=0,this.imageHeight_=0,this.imageOpacity_=0,this.imageOriginX_=0,this.imageOriginY_=0,this.imageRotateWithView_=!1,this.imageRotation_=0,this.imageScale_=0,this.imageWidth_=0,this.text_="",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=!1,this.textRotation_=0,this.textScale_=0,this.textFillState_=null,this.textStrokeState_=null,this.textState_=null,this.pixelCoordinates_=[],this.tmpLocalTransform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawImages_=function(t,e,i,r){if(this.image_){var n=vi(t,e,i,2,this.transform_,this.pixelCoordinates_),o=this.context_,s=this.tmpLocalTransform_,a=o.globalAlpha;1!=this.imageOpacity_&&(o.globalAlpha=a*this.imageOpacity_);var h=this.imageRotation_;this.imageRotateWithView_&&(h+=this.viewRotation_);for(var l=0,u=n.length;l<u;l+=2){var p=n[l]-this.imageAnchorX_,c=n[l+1]-this.imageAnchorY_;if(0!==h||1!=this.imageScale_){var d=p+this.imageAnchorX_,f=c+this.imageAnchorY_;cr(s,d,f,this.imageScale_,this.imageScale_,h,-d,-f),o.setTransform.apply(o,s)}o.drawImage(this.image_,this.imageOriginX_,this.imageOriginY_,this.imageWidth_,this.imageHeight_,p,c,this.imageWidth_,this.imageHeight_)}0===h&&1==this.imageScale_||o.setTransform(1,0,0,1,0,0),1!=this.imageOpacity_&&(o.globalAlpha=a)}},e.prototype.drawText_=function(t,e,i,r){if(this.textState_&&""!==this.text_){this.textFillState_&&this.setContextFillState_(this.textFillState_),this.textStrokeState_&&this.setContextStrokeState_(this.textStrokeState_),this.setContextTextState_(this.textState_);var n=vi(t,e,i,r,this.transform_,this.pixelCoordinates_),o=this.context_,s=this.textRotation_;for(this.textRotateWithView_&&(s+=this.viewRotation_);e<i;e+=r){var a=n[e]+this.textOffsetX_,h=n[e+1]+this.textOffsetY_;if(0!==s||1!=this.textScale_){var l=cr(this.tmpLocalTransform_,a,h,this.textScale_,this.textScale_,s,-a,-h);o.setTransform.apply(o,l)}this.textStrokeState_&&o.strokeText(this.text_,a,h),this.textFillState_&&o.fillText(this.text_,a,h)}0===s&&1==this.textScale_||o.setTransform(1,0,0,1,0,0)}},e.prototype.moveToLineTo_=function(t,e,i,r,n){var o=this.context_,s=vi(t,e,i,r,this.transform_,this.pixelCoordinates_);o.moveTo(s[0],s[1]);var a=s.length;n&&(a-=2);for(var h=2;h<a;h+=2)o.lineTo(s[h],s[h+1]);return n&&o.closePath(),i},e.prototype.drawRings_=function(t,e,i,r){for(var n=0,o=i.length;n<o;++n)e=this.moveToLineTo_(t,e,i[n],r,!0);return e},e.prototype.drawCircle=function(t){if(ci(this.extent_,t.getExtent())){if(this.fillState_||this.strokeState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=function(t,e,i){var r=t.getFlatCoordinates();if(r){var n=t.getStride();return vi(r,0,r.length,n,e,i)}return null}(t,this.transform_,this.pixelCoordinates_),i=e[2]-e[0],r=e[3]-e[1],n=Math.sqrt(i*i+r*r),o=this.context_;o.beginPath(),o.arc(e[0],e[1],n,0,2*Math.PI),this.fillState_&&o.fill(),this.strokeState_&&o.stroke()}""!==this.text_&&this.drawText_(t.getCenter(),0,2,2)}},e.prototype.setStyle=function(t){this.setFillStrokeStyle(t.getFill(),t.getStroke()),this.setImageStyle(t.getImage()),this.setTextStyle(t.getText())},e.prototype.drawGeometry=function(t){switch(t.getType()){case _i.POINT:this.drawPoint(t);break;case _i.LINE_STRING:this.drawLineString(t);break;case _i.POLYGON:this.drawPolygon(t);break;case _i.MULTI_POINT:this.drawMultiPoint(t);break;case _i.MULTI_LINE_STRING:this.drawMultiLineString(t);break;case _i.MULTI_POLYGON:this.drawMultiPolygon(t);break;case _i.GEOMETRY_COLLECTION:this.drawGeometryCollection(t);break;case _i.CIRCLE:this.drawCircle(t)}},e.prototype.drawFeature=function(t,e){var i=e.getGeometryFunction()(t);i&&ci(this.extent_,i.getExtent())&&(this.setStyle(e),this.drawGeometry(i))},e.prototype.drawGeometryCollection=function(t){for(var e=t.getGeometriesArray(),i=0,r=e.length;i<r;++i)this.drawGeometry(e[i])},e.prototype.drawPoint=function(t){var e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),""!==this.text_&&this.drawText_(e,0,e.length,i)},e.prototype.drawMultiPoint=function(t){var e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),""!==this.text_&&this.drawText_(e,0,e.length,i)},e.prototype.drawLineString=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var e=this.context_,i=t.getFlatCoordinates();e.beginPath(),this.moveToLineTo_(i,0,i.length,t.getStride(),!1),e.stroke()}if(""!==this.text_){var r=t.getFlatMidpoint();this.drawText_(r,0,2,2)}}},e.prototype.drawMultiLineString=function(t){var e=t.getExtent();if(ci(this.extent_,e)){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var i=this.context_,r=t.getFlatCoordinates(),n=0,o=t.getEnds(),s=t.getStride();i.beginPath();for(var a=0,h=o.length;a<h;++a)n=this.moveToLineTo_(r,n,o[a],s,!1);i.stroke()}if(""!==this.text_){var l=t.getFlatMidpoints();this.drawText_(l,0,l.length,2)}}},e.prototype.drawPolygon=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=this.context_;e.beginPath(),this.drawRings_(t.getOrientedFlatCoordinates(),0,t.getEnds(),t.getStride()),this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(""!==this.text_){var i=t.getFlatInteriorPoint();this.drawText_(i,0,2,2)}}},e.prototype.drawMultiPolygon=function(t){if(ci(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var e=this.context_,i=t.getOrientedFlatCoordinates(),r=0,n=t.getEndss(),o=t.getStride();e.beginPath();for(var s=0,a=n.length;s<a;++s){var h=n[s];r=this.drawRings_(i,r,h,o)}this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(""!==this.text_){var l=t.getFlatInteriorPoints();this.drawText_(l,0,l.length,2)}}},e.prototype.setContextFillState_=function(t){var e=this.context_,i=this.contextFillState_;i?i.fillStyle!=t.fillStyle&&(i.fillStyle=e.fillStyle=t.fillStyle):(e.fillStyle=t.fillStyle,this.contextFillState_={fillStyle:t.fillStyle})},e.prototype.setContextStrokeState_=function(t){var e=this.context_,i=this.contextStrokeState_;i?(i.lineCap!=t.lineCap&&(i.lineCap=e.lineCap=t.lineCap),Z&&(Ut(i.lineDash,t.lineDash)||e.setLineDash(i.lineDash=t.lineDash),i.lineDashOffset!=t.lineDashOffset&&(i.lineDashOffset=e.lineDashOffset=t.lineDashOffset)),i.lineJoin!=t.lineJoin&&(i.lineJoin=e.lineJoin=t.lineJoin),i.lineWidth!=t.lineWidth&&(i.lineWidth=e.lineWidth=t.lineWidth),i.miterLimit!=t.miterLimit&&(i.miterLimit=e.miterLimit=t.miterLimit),i.strokeStyle!=t.strokeStyle&&(i.strokeStyle=e.strokeStyle=t.strokeStyle)):(e.lineCap=t.lineCap,Z&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineJoin=t.lineJoin,e.lineWidth=t.lineWidth,e.miterLimit=t.miterLimit,e.strokeStyle=t.strokeStyle,this.contextStrokeState_={lineCap:t.lineCap,lineDash:t.lineDash,lineDashOffset:t.lineDashOffset,lineJoin:t.lineJoin,lineWidth:t.lineWidth,miterLimit:t.miterLimit,strokeStyle:t.strokeStyle})},e.prototype.setContextTextState_=function(t){var e=this.context_,i=this.contextTextState_,r=t.textAlign?t.textAlign:"center";i?(i.font!=t.font&&(i.font=e.font=t.font),i.textAlign!=r&&(i.textAlign=e.textAlign=r),i.textBaseline!=t.textBaseline&&(i.textBaseline=e.textBaseline=t.textBaseline)):(e.font=t.font,e.textAlign=r,e.textBaseline=t.textBaseline,this.contextTextState_={font:t.font,textAlign:r,textBaseline:t.textBaseline})},e.prototype.setFillStrokeStyle=function(t,e){if(t){var i=t.getColor();this.fillState_={fillStyle:ns(i||No)}}else this.fillState_=null;if(e){var r=e.getColor(),n=e.getLineCap(),o=e.getLineDash(),s=e.getLineDashOffset(),a=e.getLineJoin(),h=e.getWidth(),l=e.getMiterLimit();this.strokeState_={lineCap:void 0!==n?n:"round",lineDash:o||Ao,lineDashOffset:s||0,lineJoin:void 0!==a?a:"round",lineWidth:this.pixelRatio_*(void 0!==h?h:1),miterLimit:void 0!==l?l:10,strokeStyle:ns(r||Go)}}else this.strokeState_=null},e.prototype.setImageStyle=function(t){if(t){var e=t.getAnchor(),i=t.getImage(1),r=t.getOrigin(),n=t.getSize();this.imageAnchorX_=e[0],this.imageAnchorY_=e[1],this.imageHeight_=n[1],this.image_=i,this.imageOpacity_=t.getOpacity(),this.imageOriginX_=r[0],this.imageOriginY_=r[1],this.imageRotateWithView_=t.getRotateWithView(),this.imageRotation_=t.getRotation(),this.imageScale_=t.getScale()*this.pixelRatio_,this.imageWidth_=n[0]}else this.image_=null},e.prototype.setTextStyle=function(t){if(t){var e=t.getFill();if(e){var i=e.getColor();this.textFillState_={fillStyle:ns(i||No)}}else this.textFillState_=null;var r=t.getStroke();if(r){var n=r.getColor(),o=r.getLineCap(),s=r.getLineDash(),a=r.getLineDashOffset(),h=r.getLineJoin(),l=r.getWidth(),u=r.getMiterLimit();this.textStrokeState_={lineCap:void 0!==o?o:"round",lineDash:s||Ao,lineDashOffset:a||0,lineJoin:void 0!==h?h:"round",lineWidth:void 0!==l?l:1,miterLimit:void 0!==u?u:10,strokeStyle:ns(n||Go)}}else this.textStrokeState_=null;var p=t.getFont(),c=t.getOffsetX(),d=t.getOffsetY(),f=t.getRotateWithView(),g=t.getRotation(),_=t.getScale(),y=t.getText(),v=t.getTextAlign(),m=t.getTextBaseline();this.textState_={font:void 0!==p?p:"10px sans-serif",textAlign:void 0!==v?v:"center",textBaseline:void 0!==m?m:"middle"},this.text_=void 0!==y?y:"",this.textOffsetX_=void 0!==c?this.pixelRatio_*c:0,this.textOffsetY_=void 0!==d?this.pixelRatio_*d:0,this.textRotateWithView_=void 0!==f&&f,this.textRotation_=void 0!==g?g:0,this.textScale_=this.pixelRatio_*(void 0!==_?_:1)}else this.text_=""},e}(ss),hs=function(){this.cache_={},this.cacheSize_=0,this.maxCacheSize_=32};function ls(t,e,i){return e+":"+t+":"+(i?$o(i):"null")}hs.prototype.clear=function(){this.cache_={},this.cacheSize_=0},hs.prototype.expire=function(){if(this.cacheSize_>this.maxCacheSize_){var t=0;for(var e in this.cache_){var i=this.cache_[e];0!=(3&t++)||i.hasListener()||(delete this.cache_[e],--this.cacheSize_)}}},hs.prototype.get=function(t,e,i){var r=ls(t,e,i);return r in this.cache_?this.cache_[r]:null},hs.prototype.set=function(t,e,i,r){var n=ls(t,e,i);this.cache_[n]=r,++this.cacheSize_},hs.prototype.setSize=function(t){this.maxCacheSize_=t,this.expire()};var us=new hs;function ps(t,e){us.expire()}function cs(t,e){return t.zIndex-e.zIndex}var ds=[],fs=function(t){function e(e){t.call(this,e);var i=e.getViewport();this.context_=on(),this.canvas_=this.context_.canvas,this.canvas_.style.width="100%",this.canvas_.style.height="100%",this.canvas_.style.display="block",this.canvas_.className=Rn,i.insertBefore(this.canvas_,i.childNodes[0]||null),this.renderedVisible_=!0,this.transform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.dispatchRenderEvent=function(t,e){var i=this.getMap(),r=this.context_;if(i.hasListener(t)){var n=e.extent,o=e.pixelRatio,s=e.viewState.rotation,a=this.getTransform(e),h=new as(r,o,n,a,s),l=new Fo(t,h,e,r,null);i.dispatchEvent(l)}},e.prototype.getTransform=function(t){var e=t.viewState,i=this.canvas_.width/2,r=this.canvas_.height/2,n=t.pixelRatio/e.resolution,o=-n,s=-e.rotation,a=-e.center[0],h=-e.center[1];return cr(this.transform_,i,r,n,o,s,a,h)},e.prototype.renderFrame=function(t){if(t){var e=this.context_,i=t.pixelRatio,r=Math.round(t.size[0]*i),n=Math.round(t.size[1]*i);this.canvas_.width!=r||this.canvas_.height!=n?(this.canvas_.width=r,this.canvas_.height=n):e.clearRect(0,0,r,n);var o=t.viewState.rotation;this.calculateMatrices2D(t),this.dispatchRenderEvent(Qt.PRECOMPOSE,t);var s=t.layerStatesArray;!function(t,e){var i,r=t.length,n=Array(t.length);for(i=0;i<r;i++)n[i]={index:i,value:t[i]};for(n.sort(function(t,i){return e(t.value,i.value)||t.index-i.index}),i=0;i<t.length;i++)t[i]=n[i].value}(s,cs),o&&(e.save(),Zo(e,o,r/2,n/2));var a,h,l=t.viewState.resolution;for(a=0,h=s.length;a<h;++a){var u=s[a],p=u.layer,c=this.getLayerRenderer(p);In(u,l)&&u.sourceState==dn.READY&&(c.prepareFrame(t,u)&&c.composeFrame(t,u,e))}o&&e.restore(),this.dispatchRenderEvent(Qt.POSTCOMPOSE,t),this.renderedVisible_||(this.canvas_.style.display="",this.renderedVisible_=!0),this.scheduleRemoveUnusedLayerRenderers(t),this.scheduleExpireIconCache(t)}else this.renderedVisible_&&(this.canvas_.style.display="none",this.renderedVisible_=!1)},e.prototype.forEachLayerAtPixel=function(t,e,i,r,n,o,s){var a,h,l=e.viewState.resolution,u=e.layerStatesArray,p=u.length,c=lr(e.pixelToCoordinateTransform,t.slice());for(h=p-1;h>=0;--h){var d=u[h],f=d.layer;if(In(d,l)&&o.call(s,f))if(a=this.getLayerRenderer(f).forEachLayerAtCoordinate(c,e,i,r,n))return a}},e.prototype.registerLayerRenderers=function(e){t.prototype.registerLayerRenderers.call(this,e);for(var i=0,r=e.length;i<r;++i){var n=e[i];At(ds,n)||ds.push(n)}},e}(function(t){function e(e){t.call(this),this.map_=e,this.layerRenderers_={},this.layerRendererListeners_={},this.layerRendererConstructors_=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.dispatchRenderEvent=function(t,e){r()},e.prototype.registerLayerRenderers=function(t){this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_,t)},e.prototype.calculateMatrices2D=function(t){var e=t.viewState,i=t.coordinateToPixelTransform,r=t.pixelToCoordinateTransform;cr(i,t.size[0]/2,t.size[1]/2,1/e.resolution,-1/e.resolution,-e.rotation,-e.center[0],-e.center[1]),function(t){var e,i=(e=t)[0]*e[3]-e[1]*e[2];te(0!==i,32);var r=t[0],n=t[1],o=t[2],s=t[3],a=t[4],h=t[5];t[0]=s/i,t[1]=-n/i,t[2]=-o/i,t[3]=r/i,t[4]=(o*h-s*a)/i,t[5]=-(r*h-n*a)/i}(hr(r,i))},e.prototype.removeLayerRenderers=function(){for(var t in this.layerRenderers_)this.removeLayerRendererByKey_(t).dispose()},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n,s,a){var h,l=e.viewState,u=l.resolution;function p(t,i){var s=e.layerStates[o(i)].managed;if(!(o(t)in e.skippedFeatureUids)||s)return r.call(n,t,s?i:null)}var c=l.projection,d=t;if(c.canWrapX()){var f=c.getExtent(),g=pi(f),_=t[0];if(_<f[0]||_>f[2])d=[_+g*Math.ceil((f[0]-_)/g),t[1]]}var y,v=e.layerStatesArray;for(y=v.length-1;y>=0;--y){var m=v[y],E=m.layer;if(In(m,u)&&s.call(a,E)){var S=this.getLayerRenderer(E),T=E.getSource();if(T&&(h=S.forEachFeatureAtCoordinate(T.getWrapX()?d:t,e,i,p)),h)return h}}},e.prototype.forEachLayerAtPixel=function(t,e,i,n,o,s,a){return r()},e.prototype.hasFeatureAtCoordinate=function(t,e,i,r,n){return void 0!==this.forEachFeatureAtCoordinate(t,e,i,C,this,r,n)},e.prototype.getLayerRenderer=function(t){var e=o(t);if(e in this.layerRenderers_)return this.layerRenderers_[e];for(var i,r=0,n=this.layerRendererConstructors_.length;r<n;++r){var s=this.layerRendererConstructors_[r];if(s.handles(t)){i=s.create(this,t);break}}if(!i)throw new Error("Unable to create renderer for layer: "+t.getType());return this.layerRenderers_[e]=i,this.layerRendererListeners_[e]=v(i,M.CHANGE,this.handleLayerRendererChange_,this),i},e.prototype.getLayerRendererByKey=function(t){return this.layerRenderers_[t]},e.prototype.getLayerRenderers=function(){return this.layerRenderers_},e.prototype.getMap=function(){return this.map_},e.prototype.handleLayerRendererChange_=function(){this.map_.render()},e.prototype.removeLayerRendererByKey_=function(t){var e=this.layerRenderers_[t];return delete this.layerRenderers_[t],S(this.layerRendererListeners_[t]),delete this.layerRendererListeners_[t],e},e.prototype.removeUnusedLayerRenderers_=function(t,e){for(var i in this.layerRenderers_)e&&i in e.layerStates||this.removeLayerRendererByKey_(i).dispose()},e.prototype.renderFrame=function(t){r()},e.prototype.scheduleExpireIconCache=function(t){t.postRenderFunctions.push(ps)},e.prototype.scheduleRemoveUnusedLayerRenderers=function(t){for(var e in this.layerRenderers_)if(!(e in t.layerStates))return void t.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this))},e}(R)),gs=function(t){function e(e){t.call(this,e),this.renderedResolution,this.transform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clip=function(t,e,i){var r=e.pixelRatio,n=e.size[0]*r,o=e.size[1]*r,s=e.viewState.rotation,a=li(i),h=ui(i),l=ri(i),u=ii(i);lr(e.coordinateToPixelTransform,a),lr(e.coordinateToPixelTransform,h),lr(e.coordinateToPixelTransform,l),lr(e.coordinateToPixelTransform,u),t.save(),Zo(t,-s,n/2,o/2),t.beginPath(),t.moveTo(a[0]*r,a[1]*r),t.lineTo(h[0]*r,h[1]*r),t.lineTo(l[0]*r,l[1]*r),t.lineTo(u[0]*r,u[1]*r),t.clip(),Zo(t,s,n/2,o/2)},e.prototype.dispatchComposeEvent_=function(t,e,i,r){var n=this.getLayer();if(n.hasListener(t)){var o=i.size[0]*i.pixelRatio,s=i.size[1]*i.pixelRatio,a=i.viewState.rotation;Zo(e,-a,o/2,s/2);var h=void 0!==r?r:this.getTransform(i,0),l=new as(e,i.pixelRatio,i.extent,h,i.viewState.rotation),u=new Fo(t,l,i,e,null);n.dispatchEvent(u),Zo(e,a,o/2,s/2)}},e.prototype.forEachLayerAtCoordinate=function(t,e,i,r,n){return this.forEachFeatureAtCoordinate(t,e,i,C)?r.call(n,this.getLayer(),null):void 0},e.prototype.postCompose=function(t,e,i,r){this.dispatchComposeEvent_(Qt.POSTCOMPOSE,t,e,r)},e.prototype.preCompose=function(t,e,i){this.dispatchComposeEvent_(Qt.PRECOMPOSE,t,e,i)},e.prototype.dispatchRenderEvent=function(t,e,i){this.dispatchComposeEvent_(Qt.RENDER,t,e,i)},e.prototype.getTransform=function(t,e){var i=t.viewState,r=t.pixelRatio,n=r*t.size[0]/2,o=r*t.size[1]/2,s=r/i.resolution,a=-s,h=-i.rotation,l=-i.center[0]+e,u=-i.center[1];return cr(this.transform_,n,o,s,a,h,l,u)},e.prototype.composeFrame=function(t,e,i){r()},e.prototype.prepareFrame=function(t,e){return r()},e}(function(t){function e(e){t.call(this),this.layer_=e}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createLoadedTileFinder=function(t,e,i){return function(r,n){return t.forEachLoadedTile(e,r,n,function(t){i[r]||(i[r]={}),i[r][t.tileCoord.toString()]=t})}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r){},e.prototype.getLayer=function(){return this.layer_},e.prototype.handleImageChange_=function(t){t.target.getState()===Oo.LOADED&&this.renderIfReadyAndVisible()},e.prototype.hasFeatureAtCoordinate=function(t,e){return!1},e.prototype.loadImage=function(t){var e=t.getState();return e!=Oo.LOADED&&e!=Oo.ERROR&&v(t,M.CHANGE,this.handleImageChange_,this),e==Oo.IDLE&&(t.load(),e=t.getState()),e==Oo.LOADED},e.prototype.renderIfReadyAndVisible=function(){var t=this.getLayer();t.getVisible()&&t.getSourceState()==dn.READY&&this.changed()},e.prototype.scheduleExpireCache=function(t,e){if(e.canExpireCache()){var i=function(t,e,i){var r=o(t);r in i.usedTiles&&t.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,e);t.postRenderFunctions.push(i)}},e.prototype.updateUsedTiles=function(t,e,i,r){var n=o(e),s=i.toString();n in t?s in t[n]?t[n][s].extend(r):t[n][s]=r:(t[n]={},t[n][s]=r)},e.prototype.manageTilePyramid=function(t,e,i,r,n,s,a,h,l,u){var p=o(e);p in t.wantedTiles||(t.wantedTiles[p]={});var c,d,f,g,_,y,v=t.wantedTiles[p],m=t.tileQueue;for(y=i.getMinZoom();y<=a;++y)for(d=i.getTileRangeForExtentAndZ(s,y,d),f=i.getResolution(y),g=d.minX;g<=d.maxX;++g)for(_=d.minY;_<=d.maxY;++_)a-y<=h?((c=e.getTile(y,g,_,r,n)).getState()==$t.IDLE&&(v[c.getKey()]=!0,m.isKeyQueued(c.getKey())||m.enqueue([c,p,i.getTileCoordCenter(c.tileCoord),f])),void 0!==l&&l.call(u,c)):e.useTile(y,g,_,n)},e}(F)),_s=function(t){function e(e){t.call(this,e),this.coordinateToCanvasPixelTransform=[1,0,0,1,0,0],this.hitCanvasContext_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.composeFrame=function(t,e,i){this.preCompose(i,t);var r=this.getImage();if(r){var n=e.extent,o=void 0!==n&&!Ue(n,t.extent)&&ci(n,t.extent);o&&this.clip(i,t,n);var s=this.getImageTransform(),a=i.globalAlpha;i.globalAlpha=e.opacity;var h=s[4],l=s[5],u=r.width*s[0],p=r.height*s[3];u>=.5&&p>=.5&&i.drawImage(r,0,0,+r.width,+r.height,Math.round(h),Math.round(l),Math.round(u),Math.round(p)),i.globalAlpha=a,o&&i.restore()}this.postCompose(i,t,e)},e.prototype.getImage=function(){return r()},e.prototype.getImageTransform=function(){return r()},e.prototype.forEachLayerAtCoordinate=function(t,e,i,r,n){if(this.getImage()){var o=lr(this.coordinateToCanvasPixelTransform,t.slice());xe(o,e.viewState.resolution/this.renderedResolution),this.hitCanvasContext_||(this.hitCanvasContext_=on(1,1)),this.hitCanvasContext_.clearRect(0,0,1,1),this.hitCanvasContext_.drawImage(this.getImage(),o[0],o[1],1,1,0,0,1,1);var s=this.hitCanvasContext_.getImageData(0,0,1,1).data;return s[3]>0?r.call(n,this.getLayer(),s):void 0}},e}(gs),ys=function(t){function e(i){if(t.call(this,i),this.image_=null,this.imageTransform_=[1,0,0,1,0,0],this.skippedFeatures_=[],this.vectorRenderer_=null,i.getType()===Po.VECTOR)for(var r=0,n=ds.length;r<n;++r){var o=ds[r];if(o!==e&&o.handles(i)){this.vectorRenderer_=new o(i);break}}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.vectorRenderer_&&this.vectorRenderer_.dispose(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.image_?this.image_.getImage():null},e.prototype.getImageTransform=function(){return this.imageTransform_},e.prototype.prepareFrame=function(t,e){var i,r=t.pixelRatio,n=t.size,o=t.viewState,s=o.center,a=o.resolution,h=this.getLayer().getSource(),l=t.viewHints,p=this.vectorRenderer_,c=t.extent;if(p||void 0===e.extent||(c=hi(c,e.extent)),!l[ge]&&!l[_e]&&!di(c)){var d=o.projection,f=this.skippedFeatures_;if(p){var g=p.context,_=u({},t,{size:[pi(c)/a,ai(c)/a],viewState:u({},t.viewState,{rotation:0})}),y=Object.keys(_.skippedFeatureUids).sort();i=new Lo(c,a,r,g.canvas,function(t){!p.prepareFrame(_,e)||!p.replayGroupChanged&&Ut(f,y)||(g.canvas.width=_.size[0]*r,g.canvas.height=_.size[1]*r,p.compose(g,_,e),f=y,t())})}else i=h.getImage(c,a,r,d);i&&this.loadImage(i)&&(this.image_=i,this.skippedFeatures_=f)}if(this.image_){var v=(i=this.image_).getExtent(),m=i.getResolution(),E=i.getPixelRatio(),S=r*m/(a*E),T=cr(this.imageTransform_,r*n[0]/2,r*n[1]/2,S,S,0,E*(v[0]-s[0])/m,E*(s[1]-v[3])/m);cr(this.coordinateToCanvasPixelTransform,r*n[0]/2-T[4],r*n[1]/2-T[5],r/a,-r/a,0,-s[0],-s[1]),this.renderedResolution=m*r/E}return!!this.image_},e.prototype.forEachFeatureAtCoordinate=function(e,i,r,n){return this.vectorRenderer_?this.vectorRenderer_.forEachFeatureAtCoordinate(e,i,r,n):t.prototype.forEachFeatureAtCoordinate.call(this,e,i,r,n)},e}(_s);ys.handles=function(t){return t.getType()===Po.IMAGE||t.getType()===Po.VECTOR&&t.getRenderMode()===Mo.IMAGE},ys.create=function(t,e){return new ys(e)};var vs=ys,ms=function(t,e,i,r){this.minX=t,this.maxX=e,this.minY=i,this.maxY=r};function Es(t,e,i,r,n){return void 0!==n?(n.minX=t,n.maxX=e,n.minY=i,n.maxY=r,n):new ms(t,e,i,r)}ms.prototype.contains=function(t){return this.containsXY(t[1],t[2])},ms.prototype.containsTileRange=function(t){return this.minX<=t.minX&&t.maxX<=this.maxX&&this.minY<=t.minY&&t.maxY<=this.maxY},ms.prototype.containsXY=function(t,e){return this.minX<=t&&t<=this.maxX&&this.minY<=e&&e<=this.maxY},ms.prototype.equals=function(t){return this.minX==t.minX&&this.minY==t.minY&&this.maxX==t.maxX&&this.maxY==t.maxY},ms.prototype.extend=function(t){t.minX<this.minX&&(this.minX=t.minX),t.maxX>this.maxX&&(this.maxX=t.maxX),t.minY<this.minY&&(this.minY=t.minY),t.maxY>this.maxY&&(this.maxY=t.maxY)},ms.prototype.getHeight=function(){return this.maxY-this.minY+1},ms.prototype.getSize=function(){return[this.getWidth(),this.getHeight()]},ms.prototype.getWidth=function(){return this.maxX-this.minX+1},ms.prototype.intersects=function(t){return this.minX<=t.maxX&&this.maxX>=t.minX&&this.minY<=t.maxY&&this.maxY>=t.minY};var Ss=ms,Ts=function(t){function e(e,i){t.call(this,e),this.context=i?null:on(),this.oversampling_,this.renderedExtent_=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=[1/0,1/0,-1/0,-1/0],this.tmpTileRange_=new Ss(0,0,0,0),this.imageTransform_=[1,0,0,1,0,0],this.zDirection=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isDrawableTile_=function(t){var e=this.getLayer(),i=t.getState(),r=e.getUseInterimTilesOnError();return i==$t.LOADED||i==$t.EMPTY||i==$t.ERROR&&!r},e.prototype.getTile=function(t,e,i,r,n){var o=this.getLayer(),s=o.getSource().getTile(t,e,i,r,n);return s.getState()==$t.ERROR&&(o.getUseInterimTilesOnError()?o.getPreload()>0&&(this.newTiles_=!0):s.setState($t.LOADED)),this.isDrawableTile_(s)||(s=s.getInterimTile()),s},e.prototype.prepareFrame=function(t,e){var i=t.pixelRatio,r=t.size,n=t.viewState,s=n.projection,a=n.resolution,h=n.center,l=this.getLayer(),u=l.getSource(),p=u.getRevision(),c=u.getTileGridForProjection(s),d=c.getZForResolution(a,this.zDirection),f=c.getResolution(d),g=Math.round(a/f)||1,_=t.extent;if(void 0!==e.extent&&(_=hi(_,e.extent)),di(_))return!1;var y=c.getTileRangeForExtentAndZ(_,d),v=c.getTileRangeExtent(d,y),m=u.getTilePixelRatio(i),E={};E[d]={};var S,T,R,C=this.createLoadedTileFinder(u,s,E),x=t.viewHints,w=x[ge]||x[_e],I=this.tmpExtent,O=this.tmpTileRange_;for(this.newTiles_=!1,T=y.minX;T<=y.maxX;++T)for(R=y.minY;R<=y.maxY;++R)if(!(Date.now()-t.time>16&&w)){if(S=this.getTile(d,T,R,i,s),this.isDrawableTile_(S)){var L=o(this);if(S.getState()==$t.LOADED){E[d][S.tileCoord.toString()]=S;var P=S.inTransition(L);this.newTiles_||!P&&-1!==this.renderedTiles.indexOf(S)||(this.newTiles_=!0)}if(1===S.getAlpha(L,t.time))continue}var M=c.getTileCoordChildTileRange(S.tileCoord,O,I),F=!1;M&&(F=C(d+1,M)),F||c.forEachTileCoordParentTileRange(S.tileCoord,C,null,O,I)}var b=f*i/m*g;if(!(this.renderedResolution&&Date.now()-t.time>16&&w)&&(this.newTiles_||!this.renderedExtent_||!Ue(this.renderedExtent_,_)||this.renderedRevision!=p||g!=this.oversampling_||!w&&b!=this.renderedResolution)){var N=this.context;if(N){var A=u.getTilePixelSize(d,i,s),G=Math.round(y.getWidth()*A[0]/g),D=Math.round(y.getHeight()*A[1]/g),k=N.canvas;k.width!=G||k.height!=D?(this.oversampling_=g,k.width=G,k.height=D):((this.renderedExtent_&&!Ze(v,this.renderedExtent_)||this.renderedRevision!=p)&&N.clearRect(0,0,G,D),g=this.oversampling_)}this.renderedTiles.length=0;var Y,U,j,X,B,V,W,K,z,Z,H=Object.keys(E).map(Number);for(H.sort(function(t,e){return t===d?1:e===d?-1:t>e?1:t<e?-1:0}),X=0,B=H.length;X<B;++X)for(var q in j=H[X],U=u.getTilePixelSize(j,i,s),Y=c.getResolution(j)/f,W=m*u.getGutterForProjection(s),K=E[j])S=K[q],T=((V=c.getTileCoordExtent(S.getTileCoord(),I))[0]-v[0])/f*m/g,R=(v[3]-V[3])/f*m/g,z=U[0]*Y/g,Z=U[1]*Y/g,this.drawTileImage(S,t,e,T,R,z,Z,W,d===j),this.renderedTiles.push(S);this.renderedRevision=p,this.renderedResolution=f*i/m*g,this.renderedExtent_=v}var J=this.renderedResolution/a,Q=cr(this.imageTransform_,i*r[0]/2,i*r[1]/2,J,J,0,(this.renderedExtent_[0]-h[0])/this.renderedResolution*i,(h[1]-this.renderedExtent_[3])/this.renderedResolution*i);return cr(this.coordinateToCanvasPixelTransform,i*r[0]/2-Q[4],i*r[1]/2-Q[5],i/a,-i/a,0,-h[0],-h[1]),this.updateUsedTiles(t.usedTiles,u,d,y),this.manageTilePyramid(t,u,c,i,s,_,d,l.getPreload()),this.scheduleExpireCache(t,u),this.renderedTiles.length>0},e.prototype.drawTileImage=function(t,e,i,r,n,s,a,h,l){var u=this.getTileImage(t);if(u){var p=o(this),c=l?t.getAlpha(p,e.time):1,d=this.getLayer().getSource();1!==c||d.getOpaque(e.viewState.projection)||this.context.clearRect(r,n,s,a);var f=c!==this.context.globalAlpha;f&&(this.context.save(),this.context.globalAlpha=c),this.context.drawImage(u,h,h,u.width-2*h,u.height-2*h,r,n,s,a),f&&this.context.restore(),1!==c?e.animate=!0:l&&t.endTransition(p)}},e.prototype.getImage=function(){var t=this.context;return t?t.canvas:null},e.prototype.getImageTransform=function(){return this.imageTransform_},e.prototype.getTileImage=function(t){return t.getImage()},e}(_s);Ts.handles=function(t){return t.getType()===Po.TILE},Ts.create=function(t,e){return new Ts(e)},Ts.prototype.getLayer;var Rs=Ts,Cs=i(0),xs=i.n(Cs),ws=function(){};ws.prototype.getReplay=function(t,e){return r()},ws.prototype.isEmpty=function(){return r()},ws.prototype.addDeclutter=function(t){return r()};var Is=ws,Os={CIRCLE:"Circle",DEFAULT:"Default",IMAGE:"Image",LINE_STRING:"LineString",POLYGON:"Polygon",TEXT:"Text"};function Ls(t,e,i,r){for(var n=t[e],o=t[e+1],s=0,a=e+r;a<i;a+=r){var h=t[a],l=t[a+1];s+=Math.sqrt((h-n)*(h-n)+(l-o)*(l-o)),n=h,o=l}return s}function Ps(t,e,i,r,n,o,s,a){for(var h,l,u,p=[],c=t[e]>t[i-r],d=n.length,f=t[e],g=t[e+1],_=t[e+=r],y=t[e+1],v=0,m=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2)),E="",S=0,T=0;T<d;++T){l=c?d-T-1:T;var R=n.charAt(l),C=o(E=c?R+E:E+R)-S;S+=C;for(var x=s+C/2;e<i-r&&v+m<x;)f=_,g=y,_=t[e+=r],y=t[e+1],v+=m,m=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2));var w=x-v,I=Math.atan2(y-g,_-f);if(c&&(I+=I>0?-Math.PI:Math.PI),void 0!==u){var O=I-u;if(O+=O>Math.PI?-2*Math.PI:O<-Math.PI?2*Math.PI:0,Math.abs(O)>a)return null}var L=w/m,P=pe(f,_,L),M=pe(g,y,L);u==I?(c&&(h[0]=P,h[1]=M,h[2]=C/2),h[4]=E):(S=C,h=[P,M,C/2,I,E=R],c?p.unshift(h):p.push(h),u=I),s+=C}return p}var Ms={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_CHARS:5,DRAW_IMAGE:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,STROKE:12},Fs=[Ms.FILL],bs=[Ms.STROKE],Ns=[Ms.BEGIN_PATH],As=[Ms.CLOSE_PATH],Gs=Ms,Ds=[Os.POLYGON,Os.CIRCLE,Os.LINE_STRING,Os.IMAGE,Os.TEXT,Os.DEFAULT],ks={left:0,end:0,center:.5,right:1,start:1,top:0,middle:.5,hanging:.2,alphabetic:.8,ideographic:.8,bottom:1},Ys=[1/0,1/0,-1/0,-1/0],Us=[1,0,0,1,0,0],js=function(t){function e(e,i,r,n,o,s){t.call(this),this.declutterTree=s,this.tolerance=e,this.maxExtent=i,this.overlaps=o,this.pixelRatio=n,this.maxLineWidth=0,this.resolution=r,this.alignFill_,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_=null,this.bufferedMaxExtent_=null,this.instructions=[],this.coordinates=[],this.coordinateCache_={},this.renderedTransform_=[1,0,0,1,0,0],this.hitDetectionInstructions=[],this.pixelCoordinates_=null,this.state={},this.viewRotation_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.replayTextBackground_=function(t,e,i,r,n,o,s){t.beginPath(),t.moveTo.apply(t,e),t.lineTo.apply(t,i),t.lineTo.apply(t,r),t.lineTo.apply(t,n),t.lineTo.apply(t,e),o&&(this.alignFill_=o[2],this.fill_(t)),s&&(this.setStrokeStyle_(t,s),t.stroke())},e.prototype.replayImage_=function(t,e,i,r,n,o,s,a,h,l,u,p,c,d,f,g,_,y){var v=_||y;e-=n*=c,i-=o*=c;var m,E,S,T,R=f+l>r.width?r.width-l:f,C=a+u>r.height?r.height-u:a,x=g[3]+R*c+g[1],w=g[0]+C*c+g[2],I=e-g[3],O=i-g[0];(v||0!==p)&&(m=[I,O],E=[I+x,O],S=[I+x,O+w],T=[I,O+w]);var L=null;if(0!==p){var P=e+n,M=i+o;L=cr(Us,P,M,1,1,p,-P,-M),We(Ys),qe(Ys,lr(Us,m)),qe(Ys,lr(Us,E)),qe(Ys,lr(Us,S)),qe(Ys,lr(Us,T))}else Ve(I,O,I+x,O+w,Ys);var F=t.canvas,b=y?y[2]*c/2:0,N=Ys[0]-b<=F.width&&Ys[2]+b>=0&&Ys[1]-b<=F.height&&Ys[3]+b>=0;if(d&&(e=Math.round(e),i=Math.round(i)),s){if(!N&&1==s[4])return;He(s,Ys);var A=N?[t,L?L.slice(0):null,h,r,l,u,R,C,e,i,c]:null;A&&v&&A.push(_,y,m,E,S,T),s.push(A)}else N&&(v&&this.replayTextBackground_(t,m,E,S,T,_,y),qo(t,L,h,r,l,u,R,C,e,i,c))},e.prototype.applyPixelRatio=function(t){var e=this.pixelRatio;return 1==e?t:t.map(function(t){return t*e})},e.prototype.appendFlatCoordinates=function(t,e,i,r,n,o){var s=this.coordinates.length,a=this.getBufferedMaxExtent();o&&(e+=r);var h,l,u,p=[t[e],t[e+1]],c=[NaN,NaN],d=!0;for(h=e+r;h<i;h+=r)c[0]=t[h],c[1]=t[h+1],(u=Xe(a,c))!==l?(d&&(this.coordinates[s++]=p[0],this.coordinates[s++]=p[1]),this.coordinates[s++]=c[0],this.coordinates[s++]=c[1],d=!1):u===Ne.INTERSECTING?(this.coordinates[s++]=c[0],this.coordinates[s++]=c[1],d=!1):d=!0,p[0]=c[0],p[1]=c[1],l=u;return(n&&d||h===e+r)&&(this.coordinates[s++]=p[0],this.coordinates[s++]=p[1]),s},e.prototype.drawCustomCoordinates_=function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o],h=this.appendFlatCoordinates(t,e,a,r,!1,!1);n.push(h),e=a}return e},e.prototype.drawCustom=function(t,e,i){this.beginGeometry(t,e);var r,n,o,s,a,h=t.getType(),l=t.getStride(),u=this.coordinates.length;if(h==_i.MULTI_POLYGON){r=(t=t).getOrientedFlatCoordinates(),s=[];var p=t.getEndss();a=0;for(var c=0,d=p.length;c<d;++c){var f=[];a=this.drawCustomCoordinates_(r,a,p[c],l,f),s.push(f)}this.instructions.push([Gs.CUSTOM,u,s,t,i,Lr])}else h==_i.POLYGON||h==_i.MULTI_LINE_STRING?(o=[],r=h==_i.POLYGON?t.getOrientedFlatCoordinates():t.getFlatCoordinates(),a=this.drawCustomCoordinates_(r,0,t.getEnds(),l,o),this.instructions.push([Gs.CUSTOM,u,o,t,i,Or])):h==_i.LINE_STRING||h==_i.MULTI_POINT?(r=t.getFlatCoordinates(),n=this.appendFlatCoordinates(r,0,r.length,l,!1,!1),this.instructions.push([Gs.CUSTOM,u,n,t,i,Ir])):h==_i.POINT&&(r=t.getFlatCoordinates(),this.coordinates.push(r[0],r[1]),n=this.coordinates.length,this.instructions.push([Gs.CUSTOM,u,n,t,i]));this.endGeometry(t,e)},e.prototype.beginGeometry=function(t,e){this.beginGeometryInstruction1_=[Gs.BEGIN_GEOMETRY,e,0],this.instructions.push(this.beginGeometryInstruction1_),this.beginGeometryInstruction2_=[Gs.BEGIN_GEOMETRY,e,0],this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)},e.prototype.finish=function(){},e.prototype.fill_=function(t){if(this.alignFill_){var e=lr(this.renderedTransform_,[0,0]),i=512*this.pixelRatio;t.translate(e[0]%i,e[1]%i),t.rotate(this.viewRotation_)}t.fill(),this.alignFill_&&t.setTransform.apply(t,Ho)},e.prototype.setStrokeStyle_=function(t,e){t.strokeStyle=e[1],t.lineWidth=e[2],t.lineCap=e[3],t.lineJoin=e[4],t.miterLimit=e[5],Z&&(t.lineDashOffset=e[7],t.setLineDash(e[6]))},e.prototype.renderDeclutter_=function(t,e){if(t&&t.length>5){var i=t[4];if(1==i||i==t.length-5){var r={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};if(!this.declutterTree.collides(r)){this.declutterTree.insert(r);for(var n=5,o=t.length;n<o;++n){var s=t[n];s&&(s.length>11&&this.replayTextBackground_(s[0],s[13],s[14],s[15],s[16],s[11],s[12]),qo.apply(void 0,s))}}t.length=5,We(t)}}},e.prototype.replay_=function(t,e,i,r,n,s,a){var h;this.pixelCoordinates_&&Ut(e,this.renderedTransform_)?h=this.pixelCoordinates_:(this.pixelCoordinates_||(this.pixelCoordinates_=[]),h=vi(this.coordinates,0,this.coordinates.length,2,e,this.pixelCoordinates_),hr(this.renderedTransform_,e));for(var l,u,p,c,f,g,_,y,v,m,E,S,T=!d(i),R=0,C=r.length,x=0,w=0,I=0,O=null,L=null,P=this.coordinateCache_,M=this.viewRotation_,F={context:t,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:M},b=this.instructions!=r||this.overlaps?0:200;R<C;){var N=r[R];switch(N[0]){case Gs.BEGIN_GEOMETRY:m=N[1],T&&i[o(m)]||!m.getGeometry()?R=N[2]:void 0===a||ci(a,m.getGeometry().getExtent())?++R:R=N[2]+1;break;case Gs.BEGIN_PATH:w>b&&(this.fill_(t),w=0),I>b&&(t.stroke(),I=0),w||I||(t.beginPath(),c=f=NaN),++R;break;case Gs.CIRCLE:var A=h[x=N[1]],G=h[x+1],D=h[x+2]-A,k=h[x+3]-G,Y=Math.sqrt(D*D+k*k);t.moveTo(A+Y,G),t.arc(A,G,Y,0,2*Math.PI,!0),++R;break;case Gs.CLOSE_PATH:t.closePath(),++R;break;case Gs.CUSTOM:x=N[1],l=N[2];var U=N[3],j=N[4],X=6==N.length?N[5]:void 0;F.geometry=U,F.feature=m,R in P||(P[R]=[]);var B=P[R];X?X(h,x,l,2,B):(B[0]=h[x],B[1]=h[x+1],B.length=2),j(B,F),++R;break;case Gs.DRAW_IMAGE:x=N[1],l=N[2],v=N[3],u=N[4],p=N[5],y=s?null:N[6];var V=N[7],W=N[8],K=N[9],z=N[10],Z=N[11],H=N[12],q=N[13],J=N[14],Q=void 0,$=void 0,tt=void 0;for(N.length>16?(Q=N[15],$=N[16],tt=N[17]):(Q=Do,$=tt=!1),Z&&(H+=M);x<l;x+=2)this.replayImage_(t,h[x],h[x+1],v,u,p,y,V,W,K,z,H,q,n,J,Q,$?O:null,tt?L:null);this.renderDeclutter_(y,m),++R;break;case Gs.DRAW_CHARS:var et=N[1],it=N[2],rt=N[3];y=s?null:N[4];var nt=N[5],ot=N[6],st=N[7],at=N[8],ht=N[9],lt=N[10],ut=N[11],pt=N[12],ct=N[13],dt=N[14],ft=Ls(h,et,it,2),gt=at(pt);if(nt||gt<=ft){var _t=this.textStates[ct].textAlign,yt=Ps(h,et,it,2,pt,at,(ft-gt)*ks[_t],st);if(yt){var vt=void 0,mt=void 0,Et=void 0,St=void 0,Tt=void 0;if(lt)for(vt=0,mt=yt.length;vt<mt;++vt)Et=(Tt=yt[vt])[4],St=this.getImage(Et,ct,"",lt),u=Tt[2]+ut,p=rt*St.height+2*(.5-rt)*ut-ht,this.replayImage_(t,Tt[0],Tt[1],St,u,p,y,St.height,1,0,0,Tt[3],dt,!1,St.width,Do,null,null);if(ot)for(vt=0,mt=yt.length;vt<mt;++vt)Et=(Tt=yt[vt])[4],St=this.getImage(Et,ct,ot,""),u=Tt[2],p=rt*St.height-ht,this.replayImage_(t,Tt[0],Tt[1],St,u,p,y,St.height,1,0,0,Tt[3],dt,!1,St.width,Do,null,null)}}this.renderDeclutter_(y,m),++R;break;case Gs.END_GEOMETRY:if(void 0!==s){var Rt=s(m=N[1]);if(Rt)return Rt}++R;break;case Gs.FILL:b?w++:this.fill_(t),++R;break;case Gs.MOVE_TO_LINE_TO:for(x=N[1],l=N[2],E=h[x],_=(S=h[x+1])+.5|0,(g=E+.5|0)===c&&_===f||(t.moveTo(E,S),c=g,f=_),x+=2;x<l;x+=2)g=(E=h[x])+.5|0,_=(S=h[x+1])+.5|0,x!=l-2&&g===c&&_===f||(t.lineTo(E,S),c=g,f=_);++R;break;case Gs.SET_FILL_STYLE:O=N,this.alignFill_=N[2],w&&(this.fill_(t),w=0,I&&(t.stroke(),I=0)),t.fillStyle=N[1],++R;break;case Gs.SET_STROKE_STYLE:L=N,I&&(t.stroke(),I=0),this.setStrokeStyle_(t,N),++R;break;case Gs.STROKE:b?I++:t.stroke(),++R;break;default:++R}}w&&this.fill_(t),I&&t.stroke()},e.prototype.replay=function(t,e,i,r,n){this.viewRotation_=i,this.replay_(t,e,r,this.instructions,n,void 0,void 0)},e.prototype.replayHitDetection=function(t,e,i,r,n,o){return this.viewRotation_=i,this.replay_(t,e,r,this.hitDetectionInstructions,!0,n,o)},e.prototype.reverseHitDetectionInstructions=function(){var t,e=this.hitDetectionInstructions;e.reverse();var i,r,n=e.length,o=-1;for(t=0;t<n;++t)(r=(i=e[t])[0])==Gs.END_GEOMETRY?o=t:r==Gs.BEGIN_GEOMETRY&&(i[2]=t,Dt(this.hitDetectionInstructions,o,t),o=-1)},e.prototype.setFillStrokeStyle=function(t,e){var i=this.state;if(t){var r=t.getColor();i.fillStyle=ns(r||No)}else i.fillStyle=void 0;if(e){var n=e.getColor();i.strokeStyle=ns(n||Go);var o=e.getLineCap();i.lineCap=void 0!==o?o:"round";var s=e.getLineDash();i.lineDash=s?s.slice():Ao;var a=e.getLineDashOffset();i.lineDashOffset=a||0;var h=e.getLineJoin();i.lineJoin=void 0!==h?h:"round";var l=e.getWidth();i.lineWidth=void 0!==l?l:1;var u=e.getMiterLimit();i.miterLimit=void 0!==u?u:10,i.lineWidth>this.maxLineWidth&&(this.maxLineWidth=i.lineWidth,this.bufferedMaxExtent_=null)}else i.strokeStyle=void 0,i.lineCap=void 0,i.lineDash=null,i.lineDashOffset=void 0,i.lineJoin=void 0,i.lineWidth=void 0,i.miterLimit=void 0},e.prototype.createFill=function(t,e){var i=t.fillStyle,r=[Gs.SET_FILL_STYLE,i];return"string"!=typeof i&&r.push(!0),r},e.prototype.applyStroke=function(t){this.instructions.push(this.createStroke(t))},e.prototype.createStroke=function(t){return[Gs.SET_STROKE_STYLE,t.strokeStyle,t.lineWidth*this.pixelRatio,t.lineCap,t.lineJoin,t.miterLimit,this.applyPixelRatio(t.lineDash),t.lineDashOffset*this.pixelRatio]},e.prototype.updateFillStyle=function(t,e,i){var r=t.fillStyle;"string"==typeof r&&t.currentFillStyle==r||(void 0!==r&&this.instructions.push(e.call(this,t,i)),t.currentFillStyle=r)},e.prototype.updateStrokeStyle=function(t,e){var i=t.strokeStyle,r=t.lineCap,n=t.lineDash,o=t.lineDashOffset,s=t.lineJoin,a=t.lineWidth,h=t.miterLimit;(t.currentStrokeStyle!=i||t.currentLineCap!=r||n!=t.currentLineDash&&!Ut(t.currentLineDash,n)||t.currentLineDashOffset!=o||t.currentLineJoin!=s||t.currentLineWidth!=a||t.currentMiterLimit!=h)&&(void 0!==i&&e.call(this,t),t.currentStrokeStyle=i,t.currentLineCap=r,t.currentLineDash=n,t.currentLineDashOffset=o,t.currentLineJoin=s,t.currentLineWidth=a,t.currentMiterLimit=h)},e.prototype.endGeometry=function(t,e){this.beginGeometryInstruction1_[2]=this.instructions.length,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length,this.beginGeometryInstruction2_=null;var i=[Gs.END_GEOMETRY,e];this.instructions.push(i),this.hitDetectionInstructions.push(i)},e.prototype.getBufferedMaxExtent=function(){if(!this.bufferedMaxExtent_&&(this.bufferedMaxExtent_=De(this.maxExtent),this.maxLineWidth>0)){var t=this.resolution*(this.maxLineWidth+1)/2;Ge(this.bufferedMaxExtent_,t,this.bufferedMaxExtent_)}return this.bufferedMaxExtent_},e}(ss),Xs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s),this.declutterGroup_=null,this.hitDetectionImage_=null,this.image_=null,this.anchorX_=void 0,this.anchorY_=void 0,this.height_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.scale_=void 0,this.width_=void 0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawCoordinates_=function(t,e,i,r){return this.appendFlatCoordinates(t,e,i,r,!1,!1)},e.prototype.drawPoint=function(t,e){if(this.image_){this.beginGeometry(t,e);var i=t.getFlatCoordinates(),r=t.getStride(),n=this.coordinates.length,o=this.drawCoordinates_(i,0,i.length,r);this.instructions.push([Gs.DRAW_IMAGE,n,o,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.width_]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_]),this.endGeometry(t,e)}},e.prototype.drawMultiPoint=function(t,e){if(this.image_){this.beginGeometry(t,e);var i=t.getFlatCoordinates(),r=t.getStride(),n=this.coordinates.length,o=this.drawCoordinates_(i,0,i.length,r);this.instructions.push([Gs.DRAW_IMAGE,n,o,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.width_]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_]),this.endGeometry(t,e)}},e.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.anchorX_=void 0,this.anchorY_=void 0,this.hitDetectionImage_=null,this.image_=null,this.height_=void 0,this.scale_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.width_=void 0},e.prototype.setImageStyle=function(t,e){var i=t.getAnchor(),r=t.getSize(),n=t.getHitDetectionImage(1),o=t.getImage(1),s=t.getOrigin();this.anchorX_=i[0],this.anchorY_=i[1],this.declutterGroup_=e,this.hitDetectionImage_=n,this.image_=o,this.height_=r[1],this.opacity_=t.getOpacity(),this.originX_=s[0],this.originY_=s[1],this.rotateWithView_=t.getRotateWithView(),this.rotation_=t.getRotation(),this.scale_=t.getScale(),this.width_=r[0]},e}(js),Bs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawFlatCoordinates_=function(t,e,i,r){var n=this.coordinates.length,o=this.appendFlatCoordinates(t,e,i,r,!1,!1),s=[Gs.MOVE_TO_LINE_TO,n,o];return this.instructions.push(s),this.hitDetectionInstructions.push(s),i},e.prototype.drawLineString=function(t,e){var i=this.state,r=i.strokeStyle,n=i.lineWidth;if(void 0!==r&&void 0!==n){this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Ns);var o=t.getFlatCoordinates(),s=t.getStride();this.drawFlatCoordinates_(o,0,o.length,s),this.hitDetectionInstructions.push(bs),this.endGeometry(t,e)}},e.prototype.drawMultiLineString=function(t,e){var i=this.state,r=i.strokeStyle,n=i.lineWidth;if(void 0!==r&&void 0!==n){this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Ns);for(var o=t.getEnds(),s=t.getFlatCoordinates(),a=t.getStride(),h=0,l=0,u=o.length;l<u;++l)h=this.drawFlatCoordinates_(s,h,o[l],a);this.hitDetectionInstructions.push(bs),this.endGeometry(t,e)}},e.prototype.finish=function(){var t=this.state;null!=t.lastStroke&&t.lastStroke!=this.coordinates.length&&this.instructions.push(bs),this.reverseHitDetectionInstructions(),this.state=null},e.prototype.applyStroke=function(e){null!=e.lastStroke&&e.lastStroke!=this.coordinates.length&&(this.instructions.push(bs),e.lastStroke=this.coordinates.length),e.lastStroke=0,t.prototype.applyStroke.call(this,e),this.instructions.push(Ns)},e}(js),Vs=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawFlatCoordinatess_=function(t,e,i,r){var n=this.state,o=void 0!==n.fillStyle,s=null!=n.strokeStyle,a=i.length;this.instructions.push(Ns),this.hitDetectionInstructions.push(Ns);for(var h=0;h<a;++h){var l=i[h],u=this.coordinates.length,p=this.appendFlatCoordinates(t,e,l,r,!0,!s),c=[Gs.MOVE_TO_LINE_TO,u,p];this.instructions.push(c),this.hitDetectionInstructions.push(c),s&&(this.instructions.push(As),this.hitDetectionInstructions.push(As)),e=l}return o&&(this.instructions.push(Fs),this.hitDetectionInstructions.push(Fs)),s&&(this.instructions.push(bs),this.hitDetectionInstructions.push(bs)),e},e.prototype.drawCircle=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);var o=t.getFlatCoordinates(),s=t.getStride(),a=this.coordinates.length;this.appendFlatCoordinates(o,0,o.length,s,!1,!1);var h=[Gs.CIRCLE,a];this.instructions.push(Ns,h),this.hitDetectionInstructions.push(Ns,h),this.hitDetectionInstructions.push(Fs),void 0!==i.fillStyle&&this.instructions.push(Fs),void 0!==i.strokeStyle&&(this.instructions.push(bs),this.hitDetectionInstructions.push(bs)),this.endGeometry(t,e)}},e.prototype.drawPolygon=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);var o=t.getEnds(),s=t.getOrientedFlatCoordinates(),a=t.getStride();this.drawFlatCoordinatess_(s,0,o,a),this.endGeometry(t,e)}},e.prototype.drawMultiPolygon=function(t,e){var i=this.state,r=i.fillStyle,n=i.strokeStyle;if(void 0!==r||void 0!==n){this.setFillStrokeStyles_(t),this.beginGeometry(t,e),void 0!==i.fillStyle&&this.hitDetectionInstructions.push([Gs.SET_FILL_STYLE,$o(No)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Gs.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);for(var o=t.getEndss(),s=t.getOrientedFlatCoordinates(),a=t.getStride(),h=0,l=0,u=o.length;l<u;++l)h=this.drawFlatCoordinatess_(s,h,o[l],a);this.endGeometry(t,e)}},e.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.state=null;var t=this.tolerance;if(0!==t)for(var e=this.coordinates,i=0,r=e.length;i<r;++i)e[i]=Fr(e[i],t)},e.prototype.setFillStrokeStyles_=function(t){var e=this.state;void 0!==e.fillStyle&&this.updateFillStyle(e,this.createFill,t),void 0!==e.strokeStyle&&this.updateStrokeStyle(e,this.applyStroke)},e}(js);function Ws(t,e,i,r,n){var o,s,a,h,l,u,p,c,d,f=i,g=i,_=0,y=0,v=i;for(o=i;o<r;o+=n){var m=e[o],E=e[o+1];void 0!==h&&(c=m-h,d=E-l,a=Math.sqrt(c*c+d*d),void 0!==u&&(y+=s,Math.acos((u*c+p*d)/(s*a))>t&&(y>_&&(_=y,f=v,g=o),y=0,v=o-n)),s=a,u=c,p=d),h=m,l=E}return(y+=a)>_?[v,o]:[f,g]}var Ks="point",zs="line";var Zs={Circle:Vs,Default:js,Image:Xs,LineString:Bs,Polygon:Vs,Text:function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,n,o,s),this.declutterGroup_,this.labels_=null,this.text_="",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=void 0,this.textRotation_=0,this.textFillState_=null,this.fillStates={},this.textStrokeState_=null,this.strokeStates={},this.textState_={},this.textStates={},this.textKey_="",this.fillKey_="",this.strokeKey_="",this.widths_={},ko.prune()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.drawText=function(t,e){var i=this.textFillState_,r=this.textStrokeState_,n=this.textState_;if(""!==this.text_&&n&&(i||r)){var o,s,a=this.coordinates.length,h=t.getType(),l=null,u=2,p=2;if(n.placement===zs){if(!ci(this.getBufferedMaxExtent(),t.getExtent()))return;var c;if(l=t.getFlatCoordinates(),p=t.getStride(),h==_i.LINE_STRING)c=[l.length];else if(h==_i.MULTI_LINE_STRING)c=t.getEnds();else if(h==_i.POLYGON)c=t.getEnds().slice(0,1);else if(h==_i.MULTI_POLYGON){var d=t.getEndss();for(c=[],o=0,s=d.length;o<s;++o)c.push(d[o][0])}this.beginGeometry(t,e);for(var f,g=n.textAlign,_=0,y=0,v=c.length;y<v;++y){if(null==g){var m=Ws(n.maxAngle,l,_,c[y],p);_=m[0],f=m[1]}else f=c[y];for(o=_;o<f;o+=p)this.coordinates.push(l[o],l[o+1]);u=this.coordinates.length,_=c[y],this.drawChars_(a,u,this.declutterGroup_),a=u}this.endGeometry(t,e)}else{var E=this.getImage(this.text_,this.textKey_,this.fillKey_,this.strokeKey_),S=E.width/this.pixelRatio;switch(h){case _i.POINT:case _i.MULTI_POINT:u=(l=t.getFlatCoordinates()).length;break;case _i.LINE_STRING:l=t.getFlatMidpoint();break;case _i.CIRCLE:l=t.getCenter();break;case _i.MULTI_LINE_STRING:u=(l=t.getFlatMidpoints()).length;break;case _i.POLYGON:if(l=t.getFlatInteriorPoint(),!n.overflow&&l[2]/this.resolution<S)return;p=3;break;case _i.MULTI_POLYGON:var T=t.getFlatInteriorPoints();for(l=[],o=0,s=T.length;o<s;o+=3)(n.overflow||T[o+2]/this.resolution>=S)&&l.push(T[o],T[o+1]);if(0==(u=l.length))return}u=this.appendFlatCoordinates(l,0,u,p,!1,!1),(n.backgroundFill||n.backgroundStroke)&&(this.setFillStrokeStyle(n.backgroundFill,n.backgroundStroke),n.backgroundFill&&(this.updateFillStyle(this.state,this.createFill,t),this.hitDetectionInstructions.push(this.createFill(this.state,t))),n.backgroundStroke&&(this.updateStrokeStyle(this.state,this.applyStroke),this.hitDetectionInstructions.push(this.createStroke(this.state)))),this.beginGeometry(t,e),this.drawTextImage_(E,a,u),this.endGeometry(t,e)}}},e.prototype.getImage=function(t,e,i,r){var n,o=r+e+t+i+this.pixelRatio;if(!ko.containsKey(o)){var s=r?this.strokeStates[r]||this.textStrokeState_:null,a=i?this.fillStates[i]||this.textFillState_:null,h=this.textStates[e]||this.textState_,l=this.pixelRatio,u=h.scale*l,p=ks[h.textAlign||"center"],c=r&&s.lineWidth?s.lineWidth:0,d=t.split("\n"),f=d.length,g=[],_=function(t,e,i){for(var r=e.length,n=0,o=0;o<r;++o){var s=zo(t,e[o]);n=Math.max(n,s),i.push(s)}return n}(h.font,d,g),y=Ko(h.font),v=y*f,m=_+c,E=on(Math.ceil(m*u),Math.ceil((v+c)*u));n=E.canvas,ko.set(o,n),1!=u&&E.scale(u,u),E.font=h.font,r&&(E.strokeStyle=s.strokeStyle,E.lineWidth=c,E.lineCap=s.lineCap,E.lineJoin=s.lineJoin,E.miterLimit=s.miterLimit,Z&&s.lineDash.length&&(E.setLineDash(s.lineDash),E.lineDashOffset=s.lineDashOffset)),i&&(E.fillStyle=a.fillStyle),E.textBaseline="middle",E.textAlign="center";var S,T=.5-p,R=p*n.width/u+T*c;if(r)for(S=0;S<f;++S)E.strokeText(d[S],R+T*g[S],.5*(c+y)+S*y);if(i)for(S=0;S<f;++S)E.fillText(d[S],R+T*g[S],.5*(c+y)+S*y)}return ko.get(o)},e.prototype.drawTextImage_=function(t,e,i){var r=this.textState_,n=this.textStrokeState_,o=this.pixelRatio,s=ks[r.textAlign||"center"],a=ks[r.textBaseline],h=n&&n.lineWidth?n.lineWidth:0,l=s*t.width/o+2*(.5-s)*h,u=a*t.height/o+2*(.5-a)*h;this.instructions.push([Gs.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*o,(u-this.textOffsetY_)*o,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1,t.width,r.padding==Do?Do:r.padding.map(function(t){return t*o}),!!r.backgroundFill,!!r.backgroundStroke]),this.hitDetectionInstructions.push([Gs.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*o,(u-this.textOffsetY_)*o,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1/o,t.width,r.padding,!!r.backgroundFill,!!r.backgroundStroke])},e.prototype.drawChars_=function(t,e,i){var r=this.textStrokeState_,n=this.textState_,o=this.textFillState_,s=this.strokeKey_;r&&(s in this.strokeStates||(this.strokeStates[s]={strokeStyle:r.strokeStyle,lineCap:r.lineCap,lineDashOffset:r.lineDashOffset,lineWidth:r.lineWidth,lineJoin:r.lineJoin,miterLimit:r.miterLimit,lineDash:r.lineDash}));var a=this.textKey_;this.textKey_ in this.textStates||(this.textStates[this.textKey_]={font:n.font,textAlign:n.textAlign||"center",scale:n.scale});var h=this.fillKey_;o&&(h in this.fillStates||(this.fillStates[h]={fillStyle:o.fillStyle}));var l=this.pixelRatio,u=ks[n.textBaseline],p=this.textOffsetY_*l,c=this.text_,d=n.font,f=n.scale,g=r?r.lineWidth*f/2:0,_=this.widths_[d];_||(this.widths_[d]=_={}),this.instructions.push([Gs.DRAW_CHARS,t,e,u,i,n.overflow,h,n.maxAngle,function(t){var e=_[t];return e||(e=_[t]=zo(d,t)),e*f*l},p,s,g*l,c,a,1]),this.hitDetectionInstructions.push([Gs.DRAW_CHARS,t,e,u,i,n.overflow,h,n.maxAngle,function(t){var e=_[t];return e||(e=_[t]=zo(d,t)),e*f},p,s,g,c,a,1/l])},e.prototype.setTextStyle=function(t,e){var i,r,n;if(t){this.declutterGroup_=e;var s=t.getFill();s?((r=this.textFillState_)||(r=this.textFillState_={}),r.fillStyle=ns(s.getColor()||No)):r=this.textFillState_=null;var a=t.getStroke();if(a){(n=this.textStrokeState_)||(n=this.textStrokeState_={});var h=a.getLineDash(),l=a.getLineDashOffset(),u=a.getWidth(),p=a.getMiterLimit();n.lineCap=a.getLineCap()||"round",n.lineDash=h?h.slice():Ao,n.lineDashOffset=void 0===l?0:l,n.lineJoin=a.getLineJoin()||"round",n.lineWidth=void 0===u?1:u,n.miterLimit=void 0===p?10:p,n.strokeStyle=ns(a.getColor()||Go)}else n=this.textStrokeState_=null;i=this.textState_;var c=t.getFont()||"10px sans-serif";Xo(c);var d=t.getScale();i.overflow=t.getOverflow(),i.font=c,i.maxAngle=t.getMaxAngle(),i.placement=t.getPlacement(),i.textAlign=t.getTextAlign(),i.textBaseline=t.getTextBaseline()||"middle",i.backgroundFill=t.getBackgroundFill(),i.backgroundStroke=t.getBackgroundStroke(),i.padding=t.getPadding()||Do,i.scale=void 0===d?1:d;var f=t.getOffsetX(),g=t.getOffsetY(),_=t.getRotateWithView(),y=t.getRotation();this.text_=t.getText()||"",this.textOffsetX_=void 0===f?0:f,this.textOffsetY_=void 0===g?0:g,this.textRotateWithView_=void 0!==_&&_,this.textRotation_=void 0===y?0:y,this.strokeKey_=n?("string"==typeof n.strokeStyle?n.strokeStyle:o(n.strokeStyle))+n.lineCap+n.lineDashOffset+"|"+n.lineWidth+n.lineJoin+n.miterLimit+"["+n.lineDash.join()+"]":"",this.textKey_=i.font+i.scale+(i.textAlign||"?"),this.fillKey_=r?"string"==typeof r.fillStyle?r.fillStyle:"|"+o(r.fillStyle):""}else this.text_=""},e}(js)},Hs=function(t){function e(e,i,r,n,o,s,a){t.call(this),this.declutterTree_=s,this.declutterGroup_=null,this.tolerance_=e,this.maxExtent_=i,this.overlaps_=o,this.pixelRatio_=n,this.resolution_=r,this.renderBuffer_=a,this.replaysByZIndex_={},this.hitDetectionContext_=on(1,1),this.hitDetectionTransform_=[1,0,0,1,0,0]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addDeclutter=function(t){var e=null;return this.declutterTree_&&(t?(e=this.declutterGroup_)[4]++:(e=this.declutterGroup_=[1/0,1/0,-1/0,-1/0]).push(1)),e},e.prototype.clip=function(t,e){var i=this.getClipCoords(e);t.beginPath(),t.moveTo(i[0],i[1]),t.lineTo(i[2],i[3]),t.lineTo(i[4],i[5]),t.lineTo(i[6],i[7]),t.clip()},e.prototype.hasReplays=function(t){for(var e in this.replaysByZIndex_)for(var i=this.replaysByZIndex_[e],r=0,n=t.length;r<n;++r)if(t[r]in i)return!0;return!1},e.prototype.finish=function(){for(var t in this.replaysByZIndex_){var e=this.replaysByZIndex_[t];for(var i in e)e[i].finish()}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n,o,s){var a,h=2*(r=Math.round(r))+1,l=cr(this.hitDetectionTransform_,r+.5,r+.5,1/e,-1/e,-i,-t[0],-t[1]),u=this.hitDetectionContext_;u.canvas.width!==h||u.canvas.height!==h?(u.canvas.width=h,u.canvas.height=h):u.clearRect(0,0,h,h),void 0!==this.renderBuffer_&&(qe(a=[1/0,1/0,-1/0,-1/0],t),Ge(a,e*(this.renderBuffer_+r),a));var p,c,d=function(t){if(void 0!==qs[t])return qs[t];for(var e=2*t+1,i=new Array(e),r=0;r<e;r++)i[r]=new Array(e);var n=t,o=0,s=0;for(;n>=o;)Js(i,t+n,t+o),Js(i,t+o,t+n),Js(i,t-o,t+n),Js(i,t-n,t+o),Js(i,t-n,t-o),Js(i,t-o,t-n),Js(i,t+o,t-n),Js(i,t+n,t-o),2*((s+=1+2*++o)-n)+1>0&&(s+=1-2*(n-=1));return qs[t]=i,i}(r);function f(t){for(var e=u.getImageData(0,0,h,h).data,i=0;i<h;i++)for(var r=0;r<h;r++)if(d[i][r]&&e[4*(r*h+i)+3]>0){var n=void 0;return(!p||c!=Os.IMAGE&&c!=Os.TEXT||-1!==p.indexOf(t))&&(n=o(t)),n||void u.clearRect(0,0,h,h)}}this.declutterTree_&&(p=this.declutterTree_.all().map(function(t){return t.value}));var g,_,y,v,m,E=Object.keys(this.replaysByZIndex_).map(Number);for(E.sort(Nt),g=E.length-1;g>=0;--g){var S=E[g].toString();for(y=this.replaysByZIndex_[S],_=Ds.length-1;_>=0;--_)if(void 0!==(v=y[c=Ds[_]]))if(!s||c!=Os.IMAGE&&c!=Os.TEXT){if(m=v.replayHitDetection(u,l,i,n,f,a))return m}else{var T=s[S];T?T.push(v,l.slice(0)):s[S]=[v,l.slice(0)]}}},e.prototype.getClipCoords=function(t){var e=this.maxExtent_,i=e[0],r=e[1],n=e[2],o=e[3],s=[i,r,i,o,n,o,n,r];return vi(s,0,8,2,t,s),s},e.prototype.getReplay=function(t,e){var i=void 0!==t?t.toString():"0",r=this.replaysByZIndex_[i];void 0===r&&(r={},this.replaysByZIndex_[i]=r);var n=r[e];void 0===n&&(n=new(0,Zs[e])(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_,this.overlaps_,this.declutterTree_),r[e]=n);return n},e.prototype.getReplays=function(){return this.replaysByZIndex_},e.prototype.isEmpty=function(){return d(this.replaysByZIndex_)},e.prototype.replay=function(t,e,i,r,n,o,s){var a=Object.keys(this.replaysByZIndex_).map(Number);a.sort(Nt),t.save(),this.clip(t,e);var h,l,u,p,c,d,f=o||Ds;for(h=0,l=a.length;h<l;++h){var g=a[h].toString();for(c=this.replaysByZIndex_[g],u=0,p=f.length;u<p;++u){var _=f[u];if(d=c[_],void 0!==d)if(!s||_!=Os.IMAGE&&_!=Os.TEXT)d.replay(t,e,i,r,n);else{var y=s[g];y?y.push(d,e.slice(0)):s[g]=[d,e.slice(0)]}}}t.restore()},e}(Is),qs={0:[[!0]]};function Js(t,e,i){var r,n=Math.floor(t.length/2);if(e>=n)for(r=n;r<e;r++)t[r][i]=!0;else if(e<n)for(r=e+1;r<n;r++)t[r][i]=!0}var Qs=Hs,$s=.5,ta={Point:function(t,e,i,r){var n=i.getImage();if(n){if(n.getImageState()!=Oo.LOADED)return;var o=t.getReplay(i.getZIndex(),Os.IMAGE);o.setImageStyle(n,t.addDeclutter(!1)),o.drawPoint(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!!n)),a.drawText(e,r)}},LineString:function(t,e,i,r){var n=i.getStroke();if(n){var o=t.getReplay(i.getZIndex(),Os.LINE_STRING);o.setFillStrokeStyle(null,n),o.drawLineString(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!1)),a.drawText(e,r)}},Polygon:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(n||o){var s=t.getReplay(i.getZIndex(),Os.POLYGON);s.setFillStrokeStyle(n,o),s.drawPolygon(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}},MultiPoint:function(t,e,i,r){var n=i.getImage();if(n){if(n.getImageState()!=Oo.LOADED)return;var o=t.getReplay(i.getZIndex(),Os.IMAGE);o.setImageStyle(n,t.addDeclutter(!1)),o.drawMultiPoint(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!!n)),a.drawText(e,r)}},MultiLineString:function(t,e,i,r){var n=i.getStroke();if(n){var o=t.getReplay(i.getZIndex(),Os.LINE_STRING);o.setFillStrokeStyle(null,n),o.drawMultiLineString(e,r)}var s=i.getText();if(s){var a=t.getReplay(i.getZIndex(),Os.TEXT);a.setTextStyle(s,t.addDeclutter(!1)),a.drawText(e,r)}},MultiPolygon:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(o||n){var s=t.getReplay(i.getZIndex(),Os.POLYGON);s.setFillStrokeStyle(n,o),s.drawMultiPolygon(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}},GeometryCollection:function(t,e,i,r){var n,o,s=e.getGeometriesArray();for(n=0,o=s.length;n<o;++n){var a=ta[s[n].getType()];a(t,s[n],i,r)}},Circle:function(t,e,i,r){var n=i.getFill(),o=i.getStroke();if(n||o){var s=t.getReplay(i.getZIndex(),Os.CIRCLE);s.setFillStrokeStyle(n,o),s.drawCircle(e,r)}var a=i.getText();if(a){var h=t.getReplay(i.getZIndex(),Os.TEXT);h.setTextStyle(a,t.addDeclutter(!1)),h.drawText(e,r)}}};function ea(t,e){return parseInt(o(t),10)-parseInt(o(e),10)}function ia(t,e){var i=ra(t,e);return i*i}function ra(t,e){return $s*t/e}function na(t,e,i,r,n,o){var s=!1,a=i.getImage();if(a){var h=a.getImageState();h==Oo.LOADED||h==Oo.ERROR?a.unlistenImageChange(n,o):(h==Oo.IDLE&&a.load(),h=a.getImageState(),a.listenImageChange(n,o),s=!0)}return function(t,e,i,r){var n=i.getGeometryFunction()(e);if(!n)return;var o=n.getSimplifiedGeometry(r);if(i.getRenderer())!function t(e,i,r,n){if(i.getType()==_i.GEOMETRY_COLLECTION){for(var o=i.getGeometries(),s=0,a=o.length;s<a;++s)t(e,o[s],r,n);return}var h=e.getReplay(r.getZIndex(),Os.DEFAULT);h.drawCustom(i,n,r.getRenderer())}(t,o,i,e);else{var s=ta[o.getType()];s(t,o,i,e)}}(t,e,i,r),s}var oa=function(t){function e(e){t.call(this,e),this.declutterTree_=e.getDeclutter()?xs()(9,void 0):null,this.dirty_=!1,this.renderedRevision_=-1,this.renderedResolution_=NaN,this.renderedExtent_=[1/0,1/0,-1/0,-1/0],this.renderedRenderOrder_=null,this.replayGroup_=null,this.replayGroupChanged=!0,this.context=on(),v(ko,M.CLEAR,this.handleFontsChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){E(ko,M.CLEAR,this.handleFontsChanged_,this),t.prototype.disposeInternal.call(this)},e.prototype.compose=function(t,e,i){var r=e.extent,n=e.pixelRatio,o=i.managed?e.skippedFeatureUids:{},s=e.viewState,a=s.projection,h=s.rotation,l=a.getExtent(),u=this.getLayer().getSource(),p=this.getTransform(e,0),c=i.extent,d=void 0!==c;d&&this.clip(t,e,c);var f=this.replayGroup_;if(f&&!f.isEmpty()){this.declutterTree_&&this.declutterTree_.clear();var g,_=this.getLayer(),y=0,v=0,m=1!==i.opacity,E=_.hasListener(Qt.RENDER);if(m||E){var S=t.canvas.width,T=t.canvas.height;if(h){var R=Math.round(Math.sqrt(S*S+T*T));y=(R-S)/2,v=(R-T)/2,S=T=R}this.context.canvas.width=S,this.context.canvas.height=T,g=this.context}else g=t;var C=g.globalAlpha;m||(g.globalAlpha=i.opacity),g!=t&&g.translate(y,v);var x=e.viewHints,w=!(x[ge]||x[_e]),I=e.size[0]*n,O=e.size[1]*n;if(Zo(g,-h,I/2,O/2),f.replay(g,p,h,o,w),u.getWrapX()&&a.canWrapX()&&!Ue(l,r)){for(var L,P=r[0],M=pi(l),F=0;P<l[0];)L=M*--F,p=this.getTransform(e,L),f.replay(g,p,h,o,w),P+=M;for(F=0,P=r[2];P>l[2];)L=M*++F,p=this.getTransform(e,L),f.replay(g,p,h,o,w),P-=M}if(Zo(g,h,I/2,O/2),E&&this.dispatchRenderEvent(g,e,p),g!=t){if(m){var b=t.globalAlpha;t.globalAlpha=i.opacity,t.drawImage(g.canvas,-y,-v),t.globalAlpha=b}else t.drawImage(g.canvas,-y,-v);g.translate(-y,-v)}m||(g.globalAlpha=C)}d&&t.restore()},e.prototype.composeFrame=function(t,e,i){var r=this.getTransform(t,0);this.preCompose(i,t,r),this.compose(i,t,e),this.postCompose(i,t,e,r)},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n){if(this.replayGroup_){var s=e.viewState.resolution,a=e.viewState.rotation,h=this.getLayer(),l={};return this.replayGroup_.forEachFeatureAtCoordinate(t,s,a,i,{},function(t){var e=o(t);if(!(e in l))return l[e]=!0,r.call(n,t,h)},null)}},e.prototype.handleFontsChanged_=function(t){var e=this.getLayer();e.getVisible()&&this.replayGroup_&&e.changed()},e.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},e.prototype.prepareFrame=function(t,e){var i=this.getLayer(),r=i.getSource(),n=t.viewHints[ge],o=t.viewHints[_e],s=i.getUpdateWhileAnimating(),a=i.getUpdateWhileInteracting();if(!this.dirty_&&!s&&n||!a&&o)return!0;var h=t.extent,l=t.viewState,u=l.projection,p=l.resolution,c=t.pixelRatio,d=i.getRevision(),f=i.getRenderBuffer(),g=i.getRenderOrder();void 0===g&&(g=ea);var _=Ge(h,f*p),y=l.projection.getExtent();if(r.getWrapX()&&l.projection.canWrapX()&&!Ue(y,t.extent)){var v=pi(y),m=Math.max(pi(_)/2,v);_[0]=y[0]-m,_[2]=y[2]+m}if(!this.dirty_&&this.renderedResolution_==p&&this.renderedRevision_==d&&this.renderedRenderOrder_==g&&Ue(this.renderedExtent_,_))return this.replayGroupChanged=!1,!0;this.replayGroup_=null,this.dirty_=!1;var E=new Qs(ra(p,c),_,p,c,r.getOverlaps(),this.declutterTree_,i.getRenderBuffer());r.loadFeatures(_,p,u);var S=function(t){var e,r=t.getStyleFunction()||i.getStyleFunction();if(r&&(e=r(t,p)),e){var n=this.renderFeature(t,p,c,e,E);this.dirty_=this.dirty_||n}}.bind(this);if(g){var T=[];r.forEachFeatureInExtent(_,function(t){T.push(t)}),T.sort(g);for(var R=0,C=T.length;R<C;++R)S(T[R])}else r.forEachFeatureInExtent(_,S);return E.finish(),this.renderedResolution_=p,this.renderedRevision_=d,this.renderedRenderOrder_=g,this.renderedExtent_=_,this.replayGroup_=E,this.replayGroupChanged=!0,!0},e.prototype.renderFeature=function(t,e,i,r,n){if(!r)return!1;var o=!1;if(Array.isArray(r))for(var s=0,a=r.length;s<a;++s)o=na(n,t,r[s],ia(e,i),this.handleStyleImageChange_,this)||o;else o=na(n,t,r,ia(e,i),this.handleStyleImageChange_,this);return o},e}(gs);oa.handles=function(t){return t.getType()===Po.VECTOR},oa.create=function(t,e){return new oa(e)};var sa=oa,aa={IMAGE:"image",HYBRID:"hybrid",VECTOR:"vector"},ha={image:[Os.POLYGON,Os.CIRCLE,Os.LINE_STRING,Os.IMAGE,Os.TEXT],hybrid:[Os.POLYGON,Os.LINE_STRING]},la={image:[Os.DEFAULT],hybrid:[Os.IMAGE,Os.TEXT,Os.DEFAULT],vector:Ds},ua=function(t){function e(e){t.call(this,e,!0),this.declutterTree_=e.getDeclutter()?xs()(9,void 0):null,this.dirty_=!1,this.renderedLayerRevision_,this.tmpTransform_=[1,0,0,1,0,0];var i=e.getRenderMode();this.zDirection=i===aa.VECTOR?1:0,i!==aa.VECTOR&&(this.context=on()),v(ko,M.CLEAR,this.handleFontsChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){E(ko,M.CLEAR,this.handleFontsChanged_,this),t.prototype.disposeInternal.call(this)},e.prototype.getTile=function(e,i,r,n,o){var s=t.prototype.getTile.call(this,e,i,r,n,o);return s.getState()===$t.LOADED&&(this.createReplayGroup_(s,n,o),this.context&&this.renderTileImage_(s,n,o)),s},e.prototype.getTileImage=function(t){var e=this.getLayer();return t.getImage(e)},e.prototype.prepareFrame=function(e,i){var r=this.getLayer().getRevision();return this.renderedLayerRevision_!=r&&(this.renderedTiles.length=0),this.renderedLayerRevision_=r,t.prototype.prepareFrame.call(this,e,i)},e.prototype.createReplayGroup_=function(t,e,i){var r=this,n=this.getLayer(),o=n.getRevision(),s=n.getRenderOrder()||null,a=t.getReplayState(n);if(a.dirty||a.renderedRevision!=o||a.renderedRenderOrder!=s){for(var h=n.getSource(),l=h.getTileGrid(),u=h.getTileGridForProjection(i).getResolution(t.tileCoord[0]),p=t.extent,c=function(o,c){var d=t.getTile(t.tileKeys[o]);if(d.getState()==$t.LOADED){var f=d.tileCoord,g=l.getTileCoordExtent(f),_=hi(p,g),y=Ze(g,_)?null:Ge(_,n.getRenderBuffer()*u,r.tmpExtent),v=d.getProjection(),m=!1;$i(i,v)||(m=!0,d.setProjection(i)),a.dirty=!1;var E=new Qs(0,_,u,e,h.getOverlaps(),r.declutterTree_,n.getRenderBuffer()),S=ia(u,e),T=function(t){var e,i=t.getStyleFunction()||n.getStyleFunction();if(i&&(e=i(t,u)),e){var r=this.renderFeature(t,S,e,E);this.dirty_=this.dirty_||r,a.dirty=a.dirty||r}},R=d.getFeatures();s&&s!==a.renderedRenderOrder&&R.sort(s);for(var C=0,x=R.length;C<x;++C){var w=R[C];m&&(v.getUnits()==Ri.TILE_PIXELS&&(v.setWorldExtent(g),v.setExtent(d.getExtent())),w.getGeometry().transform(v,i)),y&&!ci(y,w.getGeometry().getExtent())||T.call(r,w)}E.finish(),d.setReplayGroup(n,t.tileCoord.toString(),E)}},d=0,f=t.tileKeys.length;d<f;++d)c(d);a.renderedRevision=o,a.renderedRenderOrder=s}},e.prototype.forEachFeatureAtCoordinate=function(t,e,i,r,n){var s=e.viewState.resolution,a=e.viewState.rotation;i=null==i?0:i;var h,l,u,p,c=this.getLayer(),d={},f=this.renderedTiles;for(u=0,p=f.length;u<p;++u){var g=f[u];if(Ye(h=Ge(g.extent,i*s,h),t))for(var _=0,y=g.tileKeys.length;_<y;++_){var v=g.getTile(g.tileKeys[_]);if(v.getState()==$t.LOADED){var m=v.getReplayGroup(c,g.tileCoord.toString());l=l||m.forEachFeatureAtCoordinate(t,s,a,i,{},function(t){var e=o(t);if(!(e in d))return d[e]=!0,r.call(n,t,c)},null)}}}return l},e.prototype.getReplayTransform_=function(t,e){var i=this.getLayer().getSource().getTileGrid(),r=t.tileCoord,n=i.getResolution(r[0]),o=e.viewState,s=e.pixelRatio,a=o.resolution/s,h=i.getTileCoordExtent(r,this.tmpExtent),l=o.center,u=li(h),p=e.size,c=Math.round(s*p[0]/2),d=Math.round(s*p[1]/2);return cr(this.tmpTransform_,c,d,n/a,n/a,o.rotation,(u[0]-l[0])/n,(l[1]-u[1])/n)},e.prototype.handleFontsChanged_=function(t){var e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()},e.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},e.prototype.postCompose=function(e,i,r){var n=this.getLayer(),o=n.getRenderMode();if(o!=aa.IMAGE){var s,a,h=n.getDeclutter()?{}:null,l=n.getSource(),u=la[o],p=i.pixelRatio,c=i.viewState.rotation,d=i.size;c&&Zo(e,-c,s=Math.round(p*d[0]/2),a=Math.round(p*d[1]/2)),h&&this.declutterTree_.clear();for(var f=i.viewHints,g=!(f[ge]||f[_e]),_=this.renderedTiles,y=l.getTileGridForProjection(i.viewState.projection),v=[],m=[],E=_.length-1;E>=0;--E){var S=_[E];if(S.getState()!=$t.ABORT)for(var T=S.tileCoord,R=y.getTileCoordExtent(T,this.tmpExtent)[0]-S.extent[0],C=void 0,x=0,w=S.tileKeys.length;x<w;++x){var I=S.getTile(S.tileKeys[x]);if(I.getState()==$t.LOADED){var O=I.getReplayGroup(n,T.toString());if(O&&O.hasReplays(u)){C||(C=this.getTransform(i,R));var L=I.tileCoord[0],P=O.getClipCoords(C);e.save(),e.globalAlpha=r.opacity;for(var M=0,F=v.length;M<F;++M){var b=v[M];L<m[M]&&(e.beginPath(),e.moveTo(P[0],P[1]),e.lineTo(P[2],P[3]),e.lineTo(P[4],P[5]),e.lineTo(P[6],P[7]),e.moveTo(b[6],b[7]),e.lineTo(b[4],b[5]),e.lineTo(b[2],b[3]),e.lineTo(b[0],b[1]),e.clip())}O.replay(e,C,c,{},g,u,h),e.restore(),v.push(P),m.push(L)}}}}h&&function(t,e,i,r){for(var n=Object.keys(t).map(Number).sort(Nt),o={},s=0,a=n.length;s<a;++s)for(var h=t[n[s].toString()],l=0,u=h.length;l<u;){var p=h[l++],c=h[l++];p.replay(e,c,i,o,r)}}(h,e,c,g),c&&Zo(e,c,s,a)}t.prototype.postCompose.call(this,e,i,r)},e.prototype.renderFeature=function(t,e,i,r){if(!i)return!1;var n=!1;if(Array.isArray(i))for(var o=0,s=i.length;o<s;++o)n=na(r,t,i[o],e,this.handleStyleImageChange_,this)||n;else n=na(r,t,i,e,this.handleStyleImageChange_,this);return n},e.prototype.renderTileImage_=function(t,e,i){var r=this.getLayer(),n=t.getReplayState(r),o=r.getRevision(),s=ha[r.getRenderMode()];if(s&&n.renderedTileRevision!==o){n.renderedTileRevision=o;var a=t.wrappedTileCoord,h=a[0],l=r.getSource(),u=l.getTileGridForProjection(i),p=u.getResolution(h),c=t.getContext(r),d=l.getTilePixelSize(h,e,i);c.canvas.width=d[0],c.canvas.height=d[1];for(var f=u.getTileCoordExtent(a,this.tmpExtent),g=0,_=t.tileKeys.length;g<_;++g){var y=t.getTile(t.tileKeys[g]);if(y.getState()==$t.LOADED){var v=e/p,m=or(this.tmpTransform_);ur(m,v,-v),pr(m,-f[0],-f[3]),y.getReplayGroup(r,t.tileCoord.toString()).replay(c,m,0,{},!0,s)}}}},e}(Rs);ua.handles=function(t){return t.getType()===Po.VECTOR_TILE},ua.create=function(t,e){return new ua(e)};var pa=ua,ca=function(t){function e(e){(e=u({},e)).controls||(e.controls=function(t){var e=t||{},i=new Y;return(void 0===e.zoom||e.zoom)&&i.push(new bn(e.zoomOptions)),(void 0===e.rotate||e.rotate)&&i.push(new Fn(e.rotateOptions)),(void 0===e.attribution||e.attribution)&&i.push(new Pn(e.attributionOptions)),i}()),e.interactions||(e.interactions=xo()),t.call(this,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createRenderer=function(){var t=new fs(this);return t.registerLayerRenderers([vs,Rs,sa,pa]),t},e}(yn),da={BOTTOM_LEFT:"bottom-left",BOTTOM_CENTER:"bottom-center",BOTTOM_RIGHT:"bottom-right",CENTER_LEFT:"center-left",CENTER_CENTER:"center-center",CENTER_RIGHT:"center-right",TOP_LEFT:"top-left",TOP_CENTER:"top-center",TOP_RIGHT:"top-right"},fa={ELEMENT:"element",MAP:"map",OFFSET:"offset",POSITION:"position",POSITIONING:"positioning"},ga=function(t){function e(e){t.call(this),this.options=e,this.id=e.id,this.insertFirst=void 0===e.insertFirst||e.insertFirst,this.stopEvent=void 0===e.stopEvent||e.stopEvent,this.element=document.createElement("div"),this.element.className=void 0!==e.className?e.className:"ol-overlay-container "+Tn,this.element.style.position="absolute",this.autoPan=void 0!==e.autoPan&&e.autoPan,this.autoPanAnimation=e.autoPanAnimation||{},this.autoPanMargin=void 0!==e.autoPanMargin?e.autoPanMargin:20,this.rendered={bottom_:"",left_:"",right_:"",top_:"",visible:!0},this.mapPostrenderListenerKey=null,v(this,A(fa.ELEMENT),this.handleElementChanged,this),v(this,A(fa.MAP),this.handleMapChanged,this),v(this,A(fa.OFFSET),this.handleOffsetChanged,this),v(this,A(fa.POSITION),this.handlePositionChanged,this),v(this,A(fa.POSITIONING),this.handlePositioningChanged,this),void 0!==e.element&&this.setElement(e.element),this.setOffset(void 0!==e.offset?e.offset:[0,0]),this.setPositioning(void 0!==e.positioning?e.positioning:da.TOP_LEFT),void 0!==e.position&&this.setPosition(e.position)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getElement=function(){return this.get(fa.ELEMENT)},e.prototype.getId=function(){return this.id},e.prototype.getMap=function(){return this.get(fa.MAP)},e.prototype.getOffset=function(){return this.get(fa.OFFSET)},e.prototype.getPosition=function(){return this.get(fa.POSITION)},e.prototype.getPositioning=function(){return this.get(fa.POSITIONING)},e.prototype.handleElementChanged=function(){un(this.element);var t=this.getElement();t&&this.element.appendChild(t)},e.prototype.handleMapChanged=function(){this.mapPostrenderListenerKey&&(ln(this.element),S(this.mapPostrenderListenerKey),this.mapPostrenderListenerKey=null);var t=this.getMap();if(t){this.mapPostrenderListenerKey=v(t,qt.POSTRENDER,this.render,this),this.updatePixelPosition();var e=this.stopEvent?t.getOverlayContainerStopEvent():t.getOverlayContainer();this.insertFirst?e.insertBefore(this.element,e.childNodes[0]||null):e.appendChild(this.element)}},e.prototype.render=function(){this.updatePixelPosition()},e.prototype.handleOffsetChanged=function(){this.updatePixelPosition()},e.prototype.handlePositionChanged=function(){this.updatePixelPosition(),this.get(fa.POSITION)&&this.autoPan&&this.panIntoView()},e.prototype.handlePositioningChanged=function(){this.updatePixelPosition()},e.prototype.setElement=function(t){this.set(fa.ELEMENT,t)},e.prototype.setMap=function(t){this.set(fa.MAP,t)},e.prototype.setOffset=function(t){this.set(fa.OFFSET,t)},e.prototype.setPosition=function(t){this.set(fa.POSITION,t)},e.prototype.panIntoView=function(){var t=this.getMap();if(t&&t.getTargetElement()){var e=this.getRect(t.getTargetElement(),t.getSize()),i=this.getElement(),r=this.getRect(i,[sn(i),an(i)]),n=this.autoPanMargin;if(!Ue(e,r)){var o=r[0]-e[0],s=e[2]-r[2],a=r[1]-e[1],h=e[3]-r[3],l=[0,0];if(o<0?l[0]=o-n:s<0&&(l[0]=Math.abs(s)+n),a<0?l[1]=a-n:h<0&&(l[1]=Math.abs(h)+n),0!==l[0]||0!==l[1]){var u=t.getView().getCenter(),p=t.getPixelFromCoordinate(u),c=[p[0]+l[0],p[1]+l[1]];t.getView().animate({center:t.getCoordinateFromPixel(c),duration:this.autoPanAnimation.duration,easing:this.autoPanAnimation.easing})}}}},e.prototype.getRect=function(t,e){var i=t.getBoundingClientRect(),r=i.left+window.pageXOffset,n=i.top+window.pageYOffset;return[r,n,r+e[0],n+e[1]]},e.prototype.setPositioning=function(t){this.set(fa.POSITIONING,t)},e.prototype.setVisible=function(t){this.rendered.visible!==t&&(this.element.style.display=t?"":"none",this.rendered.visible=t)},e.prototype.updatePixelPosition=function(){var t=this.getMap(),e=this.getPosition();if(t&&t.isRendered()&&e){var i=t.getPixelFromCoordinate(e),r=t.getSize();this.updateRenderedPosition(i,r)}else this.setVisible(!1)},e.prototype.updateRenderedPosition=function(t,e){var i=this.element.style,r=this.getOffset(),n=this.getPositioning();this.setVisible(!0);var o=r[0],s=r[1];if(n==da.BOTTOM_RIGHT||n==da.CENTER_RIGHT||n==da.TOP_RIGHT){""!==this.rendered.left_&&(this.rendered.left_=i.left="");var a=Math.round(e[0]-t[0]-o)+"px";this.rendered.right_!=a&&(this.rendered.right_=i.right=a)}else{""!==this.rendered.right_&&(this.rendered.right_=i.right=""),n!=da.BOTTOM_CENTER&&n!=da.CENTER_CENTER&&n!=da.TOP_CENTER||(o-=this.element.offsetWidth/2);var h=Math.round(t[0]+o)+"px";this.rendered.left_!=h&&(this.rendered.left_=i.left=h)}if(n==da.BOTTOM_LEFT||n==da.BOTTOM_CENTER||n==da.BOTTOM_RIGHT){""!==this.rendered.top_&&(this.rendered.top_=i.top="");var l=Math.round(e[1]-t[1]-s)+"px";this.rendered.bottom_!=l&&(this.rendered.bottom_=i.bottom=l)}else{""!==this.rendered.bottom_&&(this.rendered.bottom_=i.bottom=""),n!=da.CENTER_LEFT&&n!=da.CENTER_CENTER&&n!=da.CENTER_RIGHT||(s-=this.element.offsetHeight/2);var u=Math.round(t[1]+s)+"px";this.rendered.top_!=u&&(this.rendered.top_=i.top=u)}},e.prototype.getOptions=function(){return this.options},e}(G);function _a(t){this.validateExtent_(),this.updateBox_()}var ya=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||_a,target:i.target}),this.collapsed_=void 0===i.collapsed||i.collapsed,this.collapsible_=void 0===i.collapsible||i.collapsible,this.collapsible_||(this.collapsed_=!1);var r=void 0!==i.className?i.className:"ol-overviewmap",n=void 0!==i.tipLabel?i.tipLabel:"Overview map",o=void 0!==i.collapseLabel?i.collapseLabel:"«";"string"==typeof o?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=o):this.collapseLabel_=o;var s=void 0!==i.label?i.label:"»";"string"==typeof s?(this.label_=document.createElement("span"),this.label_.textContent=s):this.label_=s;var a=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_,h=document.createElement("button");h.setAttribute("type","button"),h.title=n,h.appendChild(a),v(h,M.CLICK,this.handleClick_,this),this.ovmapDiv_=document.createElement("div"),this.ovmapDiv_.className="ol-overviewmap-map",this.ovmap_=new ca({controls:new Y,interactions:new Y,view:i.view});var l=this.ovmap_;i.layers&&i.layers.forEach(function(t){l.addLayer(t)}.bind(this));var u=document.createElement("div");u.className="ol-overviewmap-box",u.style.boxSizing="border-box",this.boxOverlay_=new ga({position:[0,0],positioning:da.BOTTOM_LEFT,element:u}),this.ovmap_.addOverlay(this.boxOverlay_);var p=r+" "+Rn+" "+Cn+(this.collapsed_&&this.collapsible_?" "+xn:"")+(this.collapsible_?"":" ol-uncollapsible"),c=this.element;c.className=p,c.appendChild(this.ovmapDiv_),c.appendChild(h);var d=this,f=this.boxOverlay_,g=this.boxOverlay_.getElement(),_=function(t){var e,i={clientX:(e=t).clientX-g.offsetWidth/2,clientY:e.clientY+g.offsetHeight/2},r=l.getEventCoordinate(i);f.setPosition(r)},y=function(t){var e=l.getEventCoordinate(t);d.getMap().getView().setCenter(e),window.removeEventListener("mousemove",_),window.removeEventListener("mouseup",y)};g.addEventListener("mousedown",function(){window.addEventListener("mousemove",_),window.addEventListener("mouseup",y)})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setMap=function(e){var i=this.getMap();if(e!==i){if(i){var r=i.getView();r&&this.unbindView_(r),this.ovmap_.setTarget(null)}if(t.prototype.setMap.call(this,e),e){this.ovmap_.setTarget(this.ovmapDiv_),this.listenerKeys.push(v(e,l,this.handleMapPropertyChange_,this)),0===this.ovmap_.getLayers().getLength()&&this.ovmap_.setLayerGroup(e.getLayerGroup());var n=e.getView();n&&(this.bindView_(n),n.isDef()&&(this.ovmap_.updateSize(),this.resetExtent_()))}}},e.prototype.handleMapPropertyChange_=function(t){if(t.key===Jt.VIEW){var e=t.oldValue;e&&this.unbindView_(e);var i=this.getMap().getView();this.bindView_(i)}},e.prototype.bindView_=function(t){v(t,A(me),this.handleRotationChanged_,this)},e.prototype.unbindView_=function(t){E(t,A(me),this.handleRotationChanged_,this)},e.prototype.handleRotationChanged_=function(){this.ovmap_.getView().setRotation(this.getMap().getView().getRotation())},e.prototype.validateExtent_=function(){var t=this.getMap(),e=this.ovmap_;if(t.isRendered()&&e.isRendered()){var i=t.getSize(),r=t.getView().calculateExtent(i),n=e.getSize(),o=e.getView().calculateExtent(n),s=e.getPixelFromCoordinate(li(r)),a=e.getPixelFromCoordinate(ri(r)),h=Math.abs(s[0]-a[0]),l=Math.abs(s[1]-a[1]),u=n[0],p=n[1];h<.1*u||l<.1*p||h>.75*u||l>.75*p?this.resetExtent_():Ue(o,r)||this.recenter_()}},e.prototype.resetExtent_=function(){var t=this.getMap(),e=this.ovmap_,i=t.getSize(),r=t.getView().calculateExtent(i),n=e.getView(),o=Math.log(7.5)/Math.LN2;fi(r,1/(.1*Math.pow(2,o/2))),n.fit(r)},e.prototype.recenter_=function(){var t=this.getMap(),e=this.ovmap_,i=t.getView();e.getView().setCenter(i.getCenter())},e.prototype.updateBox_=function(){var t=this.getMap(),e=this.ovmap_;if(t.isRendered()&&e.isRendered()){var i=t.getSize(),r=t.getView(),n=e.getView(),o=r.getRotation(),s=this.boxOverlay_,a=this.boxOverlay_.getElement(),h=r.calculateExtent(i),l=n.getResolution(),u=ii(h),p=ui(h),c=this.calculateCoordinateRotate_(o,u);s.setPosition(c),a&&(a.style.width=Math.abs((u[0]-p[0])/l)+"px",a.style.height=Math.abs((p[1]-u[1])/l)+"px")}},e.prototype.calculateCoordinateRotate_=function(t,e){var i,r=this.getMap().getView().getCenter();return r&&(Ce(i=[e[0]-r[0],e[1]-r[1]],t),Se(i,r)),i},e.prototype.handleClick_=function(t){t.preventDefault(),this.handleToggle_()},e.prototype.handleToggle_=function(){this.element.classList.toggle(xn),this.collapsed_?hn(this.collapseLabel_,this.label_):hn(this.label_,this.collapseLabel_),this.collapsed_=!this.collapsed_;var t=this.ovmap_;this.collapsed_||t.isRendered()||(t.updateSize(),this.resetExtent_(),m(t,qt.POSTRENDER,function(t){this.updateBox_()},this))},e.prototype.getCollapsible=function(){return this.collapsible_},e.prototype.setCollapsible=function(t){this.collapsible_!==t&&(this.collapsible_=t,this.element.classList.toggle("ol-uncollapsible"),!t&&this.collapsed_&&this.handleToggle_())},e.prototype.setCollapsed=function(t){this.collapsible_&&this.collapsed_!==t&&this.handleToggle_()},e.prototype.getCollapsed=function(){return this.collapsed_},e.prototype.getOverviewMap=function(){return this.ovmap_},e}(En),va="units",ma={DEGREES:"degrees",IMPERIAL:"imperial",NAUTICAL:"nautical",METRIC:"metric",US:"us"},Ea=[1,2,5];function Sa(t){var e=t.frameState;this.viewState_=e?e.viewState:null,this.updateElement_()}var Ta=function(t){function e(e){var i=e||{},r=void 0!==i.className?i.className:"ol-scale-line";t.call(this,{element:document.createElement("div"),render:i.render||Sa,target:i.target}),this.innerElement_=document.createElement("div"),this.innerElement_.className=r+"-inner",this.element.className=r+" "+Rn,this.element.appendChild(this.innerElement_),this.viewState_=null,this.minWidth_=void 0!==i.minWidth?i.minWidth:64,this.renderedVisible_=!1,this.renderedWidth_=void 0,this.renderedHTML_="",v(this,A(va),this.handleUnitsChanged_,this),this.setUnits(i.units||ma.METRIC)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getUnits=function(){return this.get(va)},e.prototype.handleUnitsChanged_=function(){this.updateElement_()},e.prototype.setUnits=function(t){this.set(va,t)},e.prototype.updateElement_=function(){var t=this.viewState_;if(t){var e=t.center,i=t.projection,r=this.getUnits(),n=r==ma.DEGREES?Ri.DEGREES:Ri.METERS,o=Hi(i,t.resolution,e,n);i.getUnits()!=Ri.DEGREES&&i.getMetersPerUnit()&&n==Ri.METERS&&(o*=i.getMetersPerUnit());var s=this.minWidth_*o,a="";if(r==ma.DEGREES){var h=Ti[Ri.DEGREES];i.getUnits()==Ri.DEGREES?s*=h:o/=h,s<h/60?(a="″",o*=3600):s<h?(a="′",o*=60):a="°"}else r==ma.IMPERIAL?s<.9144?(a="in",o/=.0254):s<1609.344?(a="ft",o/=.3048):(a="mi",o/=1609.344):r==ma.NAUTICAL?(o/=1852,a="nm"):r==ma.METRIC?s<.001?(a="μm",o*=1e6):s<1?(a="mm",o*=1e3):s<1e3?a="m":(a="km",o/=1e3):r==ma.US?s<.9144?(a="in",o*=39.37):s<1609.344?(a="ft",o/=.30480061):(a="mi",o/=1609.3472):te(!1,33);for(var l,u,p=3*Math.floor(Math.log(this.minWidth_*o)/Math.log(10));;){if(l=Ea[(p%3+3)%3]*Math.pow(10,Math.floor(p/3)),u=Math.round(l/o),isNaN(u))return this.element.style.display="none",void(this.renderedVisible_=!1);if(u>=this.minWidth_)break;++p}var c=l+" "+a;this.renderedHTML_!=c&&(this.innerElement_.innerHTML=c,this.renderedHTML_=c),this.renderedWidth_!=u&&(this.innerElement_.style.width=u+"px",this.renderedWidth_=u),this.renderedVisible_||(this.element.style.display="",this.renderedVisible_=!0)}else this.renderedVisible_&&(this.element.style.display="none",this.renderedVisible_=!1)},e}(En),Ra={VERTICAL:0,HORIZONTAL:1};function Ca(t){if(t.frameState){this.sliderInitialized_||this.initSlider_();var e=t.frameState.viewState.resolution;e!==this.currentResolution_&&(this.currentResolution_=e,this.setThumbPosition_(e))}}var xa=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),render:i.render||Ca}),this.dragListenerKeys_=[],this.currentResolution_=void 0,this.direction_=Ra.VERTICAL,this.dragging_,this.heightLimit_=0,this.widthLimit_=0,this.previousX_,this.previousY_,this.thumbSize_=null,this.sliderInitialized_=!1,this.duration_=void 0!==i.duration?i.duration:200;var r=void 0!==i.className?i.className:"ol-zoomslider",n=document.createElement("button");n.setAttribute("type","button"),n.className=r+"-thumb "+Rn;var o=this.element;o.className=r+" "+Rn+" "+Cn,o.appendChild(n),this.dragger_=new Zt(o),v(this.dragger_,tt.POINTERDOWN,this.handleDraggerStart_,this),v(this.dragger_,tt.POINTERMOVE,this.handleDraggerDrag_,this),v(this.dragger_,tt.POINTERUP,this.handleDraggerEnd_,this),v(o,M.CLICK,this.handleContainerClick_,this),v(n,M.CLICK,O)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.dragger_.dispose(),t.prototype.disposeInternal.call(this)},e.prototype.setMap=function(e){t.prototype.setMap.call(this,e),e&&e.render()},e.prototype.initSlider_=function(){var t=this.element,e=t.offsetWidth,i=t.offsetHeight,r=t.firstElementChild,n=getComputedStyle(r),o=r.offsetWidth+parseFloat(n.marginRight)+parseFloat(n.marginLeft),s=r.offsetHeight+parseFloat(n.marginTop)+parseFloat(n.marginBottom);this.thumbSize_=[o,s],e>i?(this.direction_=Ra.HORIZONTAL,this.widthLimit_=e-o):(this.direction_=Ra.VERTICAL,this.heightLimit_=i-s),this.sliderInitialized_=!0},e.prototype.handleContainerClick_=function(t){var e=this.getMap().getView(),i=this.getRelativePosition_(t.offsetX-this.thumbSize_[0]/2,t.offsetY-this.thumbSize_[1]/2),r=this.getResolutionForPosition_(i);e.animate({resolution:e.constrainResolution(r),duration:this.duration_,easing:Pe})},e.prototype.handleDraggerStart_=function(t){if(!this.dragging_&&t.originalEvent.target===this.element.firstElementChild&&(this.getMap().getView().setHint(_e,1),this.previousX_=t.clientX,this.previousY_=t.clientY,this.dragging_=!0,0===this.dragListenerKeys_.length)){var e=this.handleDraggerDrag_,i=this.handleDraggerEnd_;this.dragListenerKeys_.push(v(document,M.MOUSEMOVE,e,this),v(document,tt.POINTERMOVE,e,this),v(document,M.MOUSEUP,i,this),v(document,tt.POINTERUP,i,this))}},e.prototype.handleDraggerDrag_=function(t){if(this.dragging_){var e=this.element.firstElementChild,i=t.clientX-this.previousX_+parseFloat(e.style.left),r=t.clientY-this.previousY_+parseFloat(e.style.top),n=this.getRelativePosition_(i,r);this.currentResolution_=this.getResolutionForPosition_(n),this.getMap().getView().setResolution(this.currentResolution_),this.setThumbPosition_(this.currentResolution_),this.previousX_=t.clientX,this.previousY_=t.clientY}},e.prototype.handleDraggerEnd_=function(t){if(this.dragging_){var e=this.getMap().getView();e.setHint(_e,-1),e.animate({resolution:e.constrainResolution(this.currentResolution_),duration:this.duration_,easing:Pe}),this.dragging_=!1,this.previousX_=void 0,this.previousY_=void 0,this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0}},e.prototype.setThumbPosition_=function(t){var e=this.getPositionForResolution_(t),i=this.element.firstElementChild;this.direction_==Ra.HORIZONTAL?i.style.left=this.widthLimit_*e+"px":i.style.top=this.heightLimit_*e+"px"},e.prototype.getRelativePosition_=function(t,e){return oe(this.direction_===Ra.HORIZONTAL?t/this.widthLimit_:e/this.heightLimit_,0,1)},e.prototype.getResolutionForPosition_=function(t){return this.getMap().getView().getResolutionForValueFunction()(1-t)},e.prototype.getPositionForResolution_=function(t){return 1-this.getMap().getView().getValueForResolutionFunction()(t)},e}(En),wa=function(t){function e(e){var i=e||{};t.call(this,{element:document.createElement("div"),target:i.target}),this.extent=i.extent?i.extent:null;var r=void 0!==i.className?i.className:"ol-zoom-extent",n=void 0!==i.label?i.label:"E",o=void 0!==i.tipLabel?i.tipLabel:"Fit to extent",s=document.createElement("button");s.setAttribute("type","button"),s.title=o,s.appendChild("string"==typeof n?document.createTextNode(n):n),v(s,M.CLICK,this.handleClick_,this);var a=r+" "+Rn+" "+Cn,h=this.element;h.className=a,h.appendChild(s)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleClick_=function(t){t.preventDefault(),this.handleZoomToExtent()},e.prototype.handleZoomToExtent=function(){var t=this.getMap().getView(),e=this.extent?this.extent:t.getProjection().getExtent();t.fit(e)},e}(En);function Ia(t){return"function"==typeof t?t:(Array.isArray(t)?e=t:(te("function"==typeof t.getZIndex,41),e=[t]),function(){return e});var e}var Oa=function(t){function e(e){if(t.call(this),this.id_=void 0,this.geometryName_="geometry",this.style_=null,this.styleFunction_=void 0,this.geometryChangeKey_=null,v(this,A(this.geometryName_),this.handleGeometryChanged_,this),e)if("function"==typeof e.getSimplifiedGeometry){var i=e;this.setGeometry(i)}else{var r=e;this.setProperties(r)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e(this.getProperties());t.setGeometryName(this.getGeometryName());var i=this.getGeometry();i&&t.setGeometry(i.clone());var r=this.getStyle();return r&&t.setStyle(r),t},e.prototype.getGeometry=function(){return this.get(this.geometryName_)},e.prototype.getId=function(){return this.id_},e.prototype.getGeometryName=function(){return this.geometryName_},e.prototype.getStyle=function(){return this.style_},e.prototype.getStyleFunction=function(){return this.styleFunction_},e.prototype.handleGeometryChange_=function(){this.changed()},e.prototype.handleGeometryChanged_=function(){this.geometryChangeKey_&&(S(this.geometryChangeKey_),this.geometryChangeKey_=null);var t=this.getGeometry();t&&(this.geometryChangeKey_=v(t,M.CHANGE,this.handleGeometryChange_,this)),this.changed()},e.prototype.setGeometry=function(t){this.set(this.geometryName_,t)},e.prototype.setStyle=function(t){this.style_=t,this.styleFunction_=t?Ia(t):void 0,this.changed()},e.prototype.setId=function(t){this.id_=t,this.changed()},e.prototype.setGeometryName=function(t){E(this,A(this.geometryName_),this.handleGeometryChanged_,this),this.geometryName_=t,v(this,A(this.geometryName_),this.handleGeometryChanged_,this),this.handleGeometryChanged_()},e}(G),La=function(t){function e(e,i){t.call(this),i&&!Array.isArray(e[0])?this.setFlatCoordinates(i,e):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendPoint=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){if(r<ke(this.getExtent(),t,e))return r;for(var n=this.flatCoordinates,o=this.stride,s=0,a=n.length;s<a;s+=o){var h=he(t,e,n[s],n[s+1]);if(h<r){r=h;for(var l=0;l<o;++l)i[l]=n[s+l];i.length=o}}return r},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getPoint=function(t){var e=this.flatCoordinates?this.flatCoordinates.length/this.stride:0;return t<0||e<=t?null:new Gr(this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride),this.layout)},e.prototype.getPoints=function(){for(var t=this.flatCoordinates,e=this.layout,i=this.stride,r=[],n=0,o=t.length;n<o;n+=i){var s=new Gr(t.slice(n,n+i),e);r.push(s)}return r},e.prototype.getType=function(){return _i.MULTI_POINT},e.prototype.intersectsExtent=function(t){for(var e=this.flatCoordinates,i=this.stride,r=0,n=e.length;r<n;r+=i){if(je(t,e[r],e[r+1]))return!0}return!1},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r);function Pa(t,e,i,r,n,o){var s=NaN,a=NaN,h=(i-e)/r;if(1===h)s=t[e],a=t[e+1];else if(2==h)s=(1-n)*t[e]+n*t[e+r],a=(1-n)*t[e+1]+n*t[e+r+1];else if(0!==h){for(var l=t[e],u=t[e+1],p=0,c=[0],d=e+r;d<i;d+=r){var f=t[d],g=t[d+1];p+=Math.sqrt((f-l)*(f-l)+(g-u)*(g-u)),c.push(p),l=f,u=g}var _=n*p,y=function(t,e,i){for(var r,n,o=i||Nt,s=0,a=t.length,h=!1;s<a;)(n=+o(t[r=s+(a-s>>1)],e))<0?s=r+1:(a=r,h=!n);return h?s:~s}(c,_);if(y<0){var v=(_-c[-y-2])/(c[-y-1]-c[-y-2]),m=e+(-y-2)*r;s=pe(t[m],t[m+r],v),a=pe(t[m+1],t[m+r+1],v)}else s=t[e+y*r],a=t[e+y*r+1]}return o?(o[0]=s,o[1]=a,o):[s,a]}function Ma(t,e,i,r,n,o){if(i==e)return null;var s;if(n<t[e+r-1])return o?((s=t.slice(e,e+r))[r-1]=n,s):null;if(t[i-1]<n)return o?((s=t.slice(i-r,i))[r-1]=n,s):null;if(n==t[e+r-1])return t.slice(e,e+r);for(var a=e/r,h=i/r;a<h;){var l=a+h>>1;n<t[(l+1)*r-1]?h=l:a=l+1}var u=t[a*r-1];if(n==u)return t.slice((a-1)*r,(a-1)*r+r);var p=(n-u)/(t[(a+1)*r-1]-u);s=[];for(var c=0;c<r-1;++c)s.push(pe(t[(a-1)*r+c],t[a*r+c],p));return s.push(n),s}var Fa=function(t){function e(e,i){t.call(this),this.flatMidpoint_=null,this.flatMidpointRevision_=-1,this.maxDelta_=-1,this.maxDeltaRevision_=-1,void 0===i||Array.isArray(e[0])?this.setCoordinates(e,i):this.setFlatCoordinates(i,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendCoordinate=function(t){this.flatCoordinates?kt(this.flatCoordinates,t):this.flatCoordinates=t.slice(),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Er(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Tr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,t,e,i,r))},e.prototype.forEachSegment=function(t){return jr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.getCoordinateAtM=function(t,e){if(this.layout!=yi.XYM&&this.layout!=yi.XYZM)return null;var i=void 0!==e&&e;return Ma(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i)},e.prototype.getCoordinates=function(){return Ir(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getCoordinateAt=function(t,e){return Pa(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,e)},e.prototype.getLength=function(){return Ls(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},e.prototype.getFlatMidpoint=function(){return this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_),this.flatMidpointRevision_=this.getRevision()),this.flatMidpoint_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[];return i.length=Pr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i,0),new e(i,yi.XY)},e.prototype.getType=function(){return _i.LINE_STRING},e.prototype.intersectsExtent=function(t){return Xr(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=xr(this.flatCoordinates,0,t,this.stride),this.changed()},e}(_r),ba=function(t){function e(e,i,r){if(t.call(this),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(e[0]))this.setCoordinates(e,i);else if(void 0!==i&&r)this.setFlatCoordinates(i,e),this.ends_=r;else{for(var n=this.getLayout(),o=e,s=[],a=[],h=0,l=o.length;h<l;++h){var u=o[h];0===h&&(n=u.getLayout()),kt(s,u.getFlatCoordinates()),a.push(s.length)}this.setFlatCoordinates(n,s),this.ends_=a}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendLineString=function(t){this.flatCoordinates?kt(this.flatCoordinates,t.getFlatCoordinates().slice()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),this.layout,this.ends_.slice())},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Sr(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Rr(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,r))},e.prototype.getCoordinateAtM=function(t,e,i){if(this.layout!=yi.XYM&&this.layout!=yi.XYZM||0===this.flatCoordinates.length)return null;var r=void 0!==e&&e,n=void 0!==i&&i;return function(t,e,i,r,n,o,s){if(s)return Ma(t,e,i[i.length-1],r,n,o);var a;if(n<t[r-1])return o?((a=t.slice(0,r))[r-1]=n,a):null;if(t[t.length-1]<n)return o?((a=t.slice(t.length-r))[r-1]=n,a):null;for(var h=0,l=i.length;h<l;++h){var u=i[h];if(e!=u){if(n<t[e+r-1])return null;if(n<=t[u-1])return Ma(t,e,u,r,n,!1);e=u}}return null}(this.flatCoordinates,0,this.ends_,this.stride,t,r,n)},e.prototype.getCoordinates=function(){return Or(this.flatCoordinates,0,this.ends_,this.stride)},e.prototype.getEnds=function(){return this.ends_},e.prototype.getLineString=function(t){return t<0||this.ends_.length<=t?null:new Fa(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)},e.prototype.getLineStrings=function(){for(var t=this.flatCoordinates,e=this.ends_,i=this.layout,r=[],n=0,o=0,s=e.length;o<s;++o){var a=e[o],h=new Fa(t.slice(n,a),i);r.push(h),n=a}return r},e.prototype.getFlatMidpoints=function(){for(var t=[],e=this.flatCoordinates,i=0,r=this.ends_,n=this.stride,o=0,s=r.length;o<s;++o){var a=r[o];kt(t,Pa(e,i,a,n,.5)),i=a}return t},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=Mr(this.flatCoordinates,0,this.ends_,this.stride,t,i,0,r),new e(i,yi.XY,r)},e.prototype.getType=function(){return _i.MULTI_LINE_STRING},e.prototype.intersectsExtent=function(t){return function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){if(Xr(t,e,i[o],r,n))return!0;e=i[o]}return!1}(this.flatCoordinates,0,this.ends_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);var i=wr(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()},e}(_r);var Na=function(t){function e(e,i,r){if(t.call(this),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!r&&!Array.isArray(e[0])){for(var n=this.getLayout(),o=e,s=[],a=[],h=0,l=o.length;h<l;++h){var u=o[h];0===h&&(n=u.getLayout());for(var p=s.length,c=u.getEnds(),d=0,f=c.length;d<f;++d)c[d]+=p;kt(s,u.getFlatCoordinates()),a.push(c)}i=n,e=s,r=a}void 0!==i&&r?(this.setFlatCoordinates(i,e),this.endss_=r):this.setCoordinates(e,i)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.appendPolygon=function(t){var e;if(this.flatCoordinates){var i=this.flatCoordinates.length;kt(this.flatCoordinates,t.getFlatCoordinates());for(var r=0,n=(e=t.getEnds().slice()).length;r<n;++r)e[r]+=i}else this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();this.endss_.push(e),this.changed()},e.prototype.clone=function(){for(var t=this.endss_.length,i=new Array(t),r=0;r<t;++r)i[r]=this.endss_[r].slice();return new e(this.flatCoordinates.slice(),this.layout,i)},e.prototype.closestPointXY=function(t,e,i,r){return r<ke(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];n=Sr(t,e,a,r,n),e=a[a.length-1]}return n}(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),function(t,e,i,r,n,o,s,a,h,l,u){for(var p=u||[NaN,NaN],c=0,d=i.length;c<d;++c){var f=i[c];l=Rr(t,e,f,r,n,o,s,a,h,l,p),e=f[f.length-1]}return l}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,r))},e.prototype.containsXY=function(t,e){return function(t,e,i,r,n,o){if(0===i.length)return!1;for(var s=0,a=i.length;s<a;++s){var h=i[s];if(Yr(t,e,h,r,n,o))return!0;e=h[h.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)},e.prototype.getArea=function(){return function(t,e,i,r){for(var n=0,o=0,s=i.length;o<s;++o){var a=i[o];n+=vr(t,e,a,r),e=a[a.length-1]}return n}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)},e.prototype.getCoordinates=function(t){var e;return void 0!==t?Zr(e=this.getOrientedFlatCoordinates().slice(),0,this.endss_,this.stride,t):e=this.flatCoordinates,Lr(e,0,this.endss_,this.stride)},e.prototype.getEndss=function(){return this.endss_},e.prototype.getFlatInteriorPoints=function(){if(this.flatInteriorPointsRevision_!=this.getRevision()){var t=function(t,e,i,r){for(var n=[],o=[1/0,1/0,-1/0,-1/0],s=0,a=i.length;s<a;++s){var h=i[s];o=ze(t,e,h[0],r),n.push((o[0]+o[2])/2,(o[1]+o[3])/2),e=h[h.length-1]}return n}(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=function(t,e,i,r,n){for(var o=[],s=0,a=i.length;s<a;++s){var h=i[s];o=Ur(t,e,h,r,n,2*s,o),e=h[h.length-1]}return o}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_},e.prototype.getInteriorPoints=function(){return new La(this.getFlatInteriorPoints().slice(),yi.XYM)},e.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var t=this.flatCoordinates;!function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o)if(!Kr(t,e,i[o],r,n))return!1;return!0}(t,0,this.endss_,this.stride)?(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=Zr(this.orientedFlatCoordinates_,0,this.endss_,this.stride)):this.orientedFlatCoordinates_=t,this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},e.prototype.getSimplifiedGeometryInternal=function(t){var i=[],r=[];return i.length=function(t,e,i,r,n,o,s,a){for(var h=0,l=i.length;h<l;++h){var u=i[h],p=[];s=Nr(t,e,u,r,n,o,s,p),a.push(p),e=u[u.length-1]}return s}(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),i,0,r),new e(i,yi.XY,r)},e.prototype.getPolygon=function(t){if(t<0||this.endss_.length<=t)return null;var e;if(0===t)e=0;else{var i=this.endss_[t-1];e=i[i.length-1]}var r=this.endss_[t].slice(),n=r[r.length-1];if(0!==e)for(var o=0,s=r.length;o<s;++o)r[o]-=e;return new qr(this.flatCoordinates.slice(e,n),this.layout,r)},e.prototype.getPolygons=function(){for(var t=this.layout,e=this.flatCoordinates,i=this.endss_,r=[],n=0,o=0,s=i.length;o<s;++o){var a=i[o].slice(),h=a[a.length-1];if(0!==n)for(var l=0,u=a.length;l<u;++l)a[l]-=n;var p=new qr(e.slice(n,h),t,a);r.push(p),n=h}return r},e.prototype.getType=function(){return _i.MULTI_POLYGON},e.prototype.intersectsExtent=function(t){return function(t,e,i,r,n){for(var o=0,s=i.length;o<s;++o){var a=i[o];if(Br(t,e,a,r,n))return!0;e=a[a.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)},e.prototype.setCoordinates=function(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);var i=function(t,e,i,r,n){for(var o=n||[],s=0,a=0,h=i.length;a<h;++a){var l=wr(t,e,i[a],r,o[s]);o[s++]=l,e=l[l.length-1]}return o.length=s,o}(this.flatCoordinates,0,t,this.stride,this.endss_);if(0===i.length)this.flatCoordinates.length=0;else{var r=i[i.length-1];this.flatCoordinates.length=0===r.length?0:r[r.length-1]}this.changed()},e}(_r),Aa=function(t){function e(e,i,r){if(t.call(this),void 0!==r&&void 0===i)this.setFlatCoordinates(r,e);else{var n=i||0;this.setCenterAndRadius(e,n,r)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.flatCoordinates.slice(),void 0,this.layout)},e.prototype.closestPointXY=function(t,e,i,r){var n=this.flatCoordinates,o=t-n[0],s=e-n[1],a=o*o+s*s;if(a<r){if(0===a)for(var h=0;h<this.stride;++h)i[h]=n[h];else{var l=this.getRadius()/Math.sqrt(a);i[0]=n[0]+l*o,i[1]=n[1]+l*s;for(var u=2;u<this.stride;++u)i[u]=n[u]}return i.length=this.stride,a}return r},e.prototype.containsXY=function(t,e){var i=this.flatCoordinates,r=t-i[0],n=e-i[1];return r*r+n*n<=this.getRadiusSquared_()},e.prototype.getCenter=function(){return this.flatCoordinates.slice(0,this.stride)},e.prototype.computeExtent=function(t){var e=this.flatCoordinates,i=e[this.stride]-e[0];return Ve(e[0]-i,e[1]-i,e[0]+i,e[1]+i,t)},e.prototype.getRadius=function(){return Math.sqrt(this.getRadiusSquared_())},e.prototype.getRadiusSquared_=function(){var t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e},e.prototype.getType=function(){return _i.CIRCLE},e.prototype.intersectsExtent=function(t){if(ci(t,this.getExtent())){var e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||(t[1]<=e[1]&&t[3]>=e[1]||ti(t,this.intersectsCoordinate,this))}return!1},e.prototype.setCenter=function(t){var e=this.stride,i=this.flatCoordinates[e]-this.flatCoordinates[0],r=t.slice();r[e]=r[0]+i;for(var n=1;n<e;++n)r[e+n]=t[n];this.setFlatCoordinates(this.layout,r),this.changed()},e.prototype.setCenterAndRadius=function(t,e,i){this.setLayout(i,t,0),this.flatCoordinates||(this.flatCoordinates=[]);var r=this.flatCoordinates,n=Cr(r,0,t,this.stride);r[n++]=r[0]+e;for(var o=1,s=this.stride;o<s;++o)r[n++]=r[o];r.length=n,this.changed()},e.prototype.getCoordinates=function(){return null},e.prototype.setCoordinates=function(t,e){},e.prototype.setRadius=function(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()},e}(_r);Aa.prototype.transform;var Ga=Aa;function Da(t){for(var e=[],i=0,r=t.length;i<r;++i)e.push(t[i].clone());return e}var ka=function(t){function e(e){t.call(this),this.geometries_=e||null,this.listenGeometriesChange_()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.unlistenGeometriesChange_=function(){if(this.geometries_)for(var t=0,e=this.geometries_.length;t<e;++t)E(this.geometries_[t],M.CHANGE,this.changed,this)},e.prototype.listenGeometriesChange_=function(){if(this.geometries_)for(var t=0,e=this.geometries_.length;t<e;++t)v(this.geometries_[t],M.CHANGE,this.changed,this)},e.prototype.clone=function(){var t=new e(null);return t.setGeometries(this.geometries_),t},e.prototype.closestPointXY=function(t,e,i,r){if(r<ke(this.getExtent(),t,e))return r;for(var n=this.geometries_,o=0,s=n.length;o<s;++o)r=n[o].closestPointXY(t,e,i,r);return r},e.prototype.containsXY=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)if(i[r].containsXY(t,e))return!0;return!1},e.prototype.computeExtent=function(t){We(t);for(var e=this.geometries_,i=0,r=e.length;i<r;++i)He(t,e[i].getExtent());return t},e.prototype.getGeometries=function(){return Da(this.geometries_)},e.prototype.getGeometriesArray=function(){return this.geometries_},e.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(p(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;var i=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(i))return this.simplifiedGeometryCache[i];for(var r=[],n=this.geometries_,o=!1,s=0,a=n.length;s<a;++s){var h=n[s],l=h.getSimplifiedGeometry(t);r.push(l),l!==h&&(o=!0)}if(o){var u=new e(null);return u.setGeometriesArray(r),this.simplifiedGeometryCache[i]=u,u}return this.simplifiedGeometryMaxMinSquaredTolerance=t,this},e.prototype.getType=function(){return _i.GEOMETRY_COLLECTION},e.prototype.intersectsExtent=function(t){for(var e=this.geometries_,i=0,r=e.length;i<r;++i)if(e[i].intersectsExtent(t))return!0;return!1},e.prototype.isEmpty=function(){return 0===this.geometries_.length},e.prototype.rotate=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)i[r].rotate(t,e);this.changed()},e.prototype.scale=function(t,e,i){var r=i;r||(r=ni(this.getExtent()));for(var n=this.geometries_,o=0,s=n.length;o<s;++o)n[o].scale(t,e,r);this.changed()},e.prototype.setGeometries=function(t){this.setGeometriesArray(Da(t))},e.prototype.setGeometriesArray=function(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()},e.prototype.applyTransform=function(t){for(var e=this.geometries_,i=0,r=e.length;i<r;++i)e[i].applyTransform(t);this.changed()},e.prototype.translate=function(t,e){for(var i=this.geometries_,r=0,n=i.length;r<n;++r)i[r].translate(t,e);this.changed()},e.prototype.disposeInternal=function(){this.unlistenGeometriesChange_(),t.prototype.disposeInternal.call(this)},e}(fr),Ya={ARRAY_BUFFER:"arraybuffer",JSON:"json",TEXT:"text",XML:"xml"};function Ua(t,e){return function(t,e,i,r){return function(n,o,s){var a=new XMLHttpRequest;a.open("GET","function"==typeof t?t(n,o,s):t,!0),e.getType()==Ya.ARRAY_BUFFER&&(a.responseType="arraybuffer"),a.onload=function(t){if(!a.status||a.status>=200&&a.status<300){var n,o=e.getType();o==Ya.JSON||o==Ya.TEXT?n=a.responseText:o==Ya.XML?(n=a.responseXML)||(n=(new DOMParser).parseFromString(a.responseText,"application/xml")):o==Ya.ARRAY_BUFFER&&(n=a.response),n?i.call(this,e.readFeatures(n,{featureProjection:s}),e.readProjection(n),e.getLastExtent()):r.call(this)}else r.call(this)}.bind(this),a.onerror=function(){r.call(this)}.bind(this),a.send()}}(t,e,function(t,e){"function"==typeof this.addFeatures&&this.addFeatures(t)},w)}var ja=function(){this.dataProjection=null,this.defaultFeatureProjection=null};ja.prototype.getReadOptions=function(t,e){var i;return e&&(i={dataProjection:e.dataProjection?e.dataProjection:this.readProjection(t),featureProjection:e.featureProjection}),this.adaptOptions(i)},ja.prototype.adaptOptions=function(t){return u({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection},t)},ja.prototype.getLastExtent=function(){return null},ja.prototype.getType=function(){return r()},ja.prototype.readFeature=function(t,e){return r()},ja.prototype.readFeatures=function(t,e){return r()},ja.prototype.readGeometry=function(t,e){return r()},ja.prototype.readProjection=function(t){return r()},ja.prototype.writeFeature=function(t,e){return r()},ja.prototype.writeFeatures=function(t,e){return r()},ja.prototype.writeGeometry=function(t,e){return r()};var Xa=ja;function Ba(t,e,i){var r,n=i?Zi(i.featureProjection):null,o=i?Zi(i.dataProjection):null;if(r=n&&o&&!$i(n,o)?Array.isArray(t)?rr(t,o,n):(e?t.clone():t).transform(e?n:o,e?o:n):t,e&&i&&void 0!==i.decimals&&!Array.isArray(r)){var s=Math.pow(10,i.decimals);r===t&&(r=t.clone()),r.applyTransform(function(t){for(var e=0,i=t.length;e<i;++e)t[e]=Math.round(t[e]*s)/s;return t})}return r}function Va(t){if("string"==typeof t){var e=JSON.parse(t);return e||null}return null!==t?t:null}var Wa=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.JSON},e.prototype.readFeature=function(t,e){return this.readFeatureFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readFeatures=function(t,e){return this.readFeaturesFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readFeatureFromObject=function(t,e){return r()},e.prototype.readFeaturesFromObject=function(t,e){return r()},e.prototype.readGeometry=function(t,e){return this.readGeometryFromObject(Va(t),this.getReadOptions(t,e))},e.prototype.readGeometryFromObject=function(t,e){return r()},e.prototype.readProjection=function(t){return this.readProjectionFromObject(Va(t))},e.prototype.readProjectionFromObject=function(t){return r()},e.prototype.writeFeature=function(t,e){return JSON.stringify(this.writeFeatureObject(t,e))},e.prototype.writeFeatureObject=function(t,e){return r()},e.prototype.writeFeatures=function(t,e){return JSON.stringify(this.writeFeaturesObject(t,e))},e.prototype.writeFeaturesObject=function(t,e){return r()},e.prototype.writeGeometry=function(t,e){return JSON.stringify(this.writeGeometryObject(t,e))},e.prototype.writeGeometryObject=function(t,e){return r()},e}(Xa);function Ka(t,e){if(!t)return null;var i;switch(t.type){case _i.POINT:i=function(t){return new Gr(t.coordinates)}(t);break;case _i.LINE_STRING:i=function(t){return new Fa(t.coordinates)}(t);break;case _i.POLYGON:i=function(t){return new qr(t.coordinates)}(t);break;case _i.MULTI_POINT:i=function(t){return new La(t.coordinates)}(t);break;case _i.MULTI_LINE_STRING:i=function(t){return new ba(t.coordinates)}(t);break;case _i.MULTI_POLYGON:i=function(t){return new Na(t.coordinates)}(t);break;case _i.GEOMETRY_COLLECTION:i=function(t,e){var i=t.geometries.map(function(t){return Ka(t,e)});return new ka(i)}(t);break;default:throw new Error("Unsupported GeoJSON type: "+t.type)}return Ba(i,!1,e)}function za(t,e){var i,r=(t=Ba(t,!0,e)).getType();switch(r){case _i.POINT:i=function(t,e){return{type:"Point",coordinates:t.getCoordinates()}}(t);break;case _i.LINE_STRING:i=function(t,e){return{type:"LineString",coordinates:t.getCoordinates()}}(t);break;case _i.POLYGON:i=function(t,e){var i;e&&(i=e.rightHanded);return{type:"Polygon",coordinates:t.getCoordinates(i)}}(t,e);break;case _i.MULTI_POINT:i=function(t,e){return{type:"MultiPoint",coordinates:t.getCoordinates()}}(t);break;case _i.MULTI_LINE_STRING:i=function(t,e){return{type:"MultiLineString",coordinates:t.getCoordinates()}}(t);break;case _i.MULTI_POLYGON:i=function(t,e){var i;e&&(i=e.rightHanded);return{type:"MultiPolygon",coordinates:t.getCoordinates(i)}}(t,e);break;case _i.GEOMETRY_COLLECTION:i=function(t,e){return{type:"GeometryCollection",geometries:t.getGeometriesArray().map(function(t){var i=u({},e);return delete i.featureProjection,za(t,i)})}}(t,e);break;case _i.CIRCLE:i={type:"GeometryCollection",geometries:[]};break;default:throw new Error("Unsupported geometry type: "+r)}return i}var Za=function(t){function e(e){var i=e||{};t.call(this),this.dataProjection=Zi(i.dataProjection?i.dataProjection:"EPSG:4326"),i.featureProjection&&(this.defaultFeatureProjection=Zi(i.featureProjection)),this.geometryName_=i.geometryName,this.extractGeometryName_=i.extractGeometryName}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeatureFromObject=function(t,e){var i=null,r=Ka((i="Feature"===t.type?t:{type:"Feature",geometry:t,properties:null}).geometry,e),n=new Oa;return this.geometryName_?n.setGeometryName(this.geometryName_):this.extractGeometryName_&&"geometry_name"in i!==void 0&&n.setGeometryName(i.geometry_name),n.setGeometry(r),"id"in i&&n.setId(i.id),i.properties&&n.setProperties(i.properties),n},e.prototype.readFeaturesFromObject=function(t,e){var i=null;if("FeatureCollection"===t.type){i=[];for(var r=t.features,n=0,o=r.length;n<o;++n)i.push(this.readFeatureFromObject(r[n],e))}else i=[this.readFeatureFromObject(t,e)];return i},e.prototype.readGeometryFromObject=function(t,e){return Ka(t,e)},e.prototype.readProjectionFromObject=function(t){var e,i=t.crs;return i?"name"==i.type?e=Zi(i.properties.name):te(!1,36):e=this.dataProjection,e},e.prototype.writeFeatureObject=function(t,e){e=this.adaptOptions(e);var i={type:"Feature",geometry:null,properties:null},r=t.getId();void 0!==r&&(i.id=r);var n=t.getGeometry();n&&(i.geometry=za(n,e));var o=t.getProperties();return delete o[t.getGeometryName()],d(o)||(i.properties=o),i},e.prototype.writeFeaturesObject=function(t,e){e=this.adaptOptions(e);for(var i=[],r=0,n=t.length;r<n;++r)i.push(this.writeFeatureObject(t[r],e));return{type:"FeatureCollection",features:i}},e.prototype.writeGeometryObject=function(t,e){return za(t,this.adaptOptions(e))},e}(Wa),Ha=document.implementation.createDocument("","",null),qa="http://www.w3.org/2001/XMLSchema-instance";function Ja(t,e){return Ha.createElementNS(t,e)}function Qa(t,e){return function t(e,i,r){if(e.nodeType==Node.CDATA_SECTION_NODE||e.nodeType==Node.TEXT_NODE)i?r.push(String(e.nodeValue).replace(/(\r\n|\r|\n)/g,"")):r.push(e.nodeValue);else{var n;for(n=e.firstChild;n;n=n.nextSibling)t(n,i,r)}return r}(t,e,[]).join("")}function $a(t){return"documentElement"in t}function th(t){return(new DOMParser).parseFromString(t,"application/xml")}function eh(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&kt(r[r.length-1],n)}}function ih(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&r[r.length-1].push(n)}}function rh(t,e){return function(i,r){var n=t.call(void 0!==e?e:this,i,r);void 0!==n&&(r[r.length-1]=n)}}function nh(t,e,i){return function(r,n){var o=t.call(void 0!==i?i:this,r,n);if(void 0!==o){var s=n[n.length-1],a=void 0!==e?e:r.localName;(a in s?s[a]:s[a]=[]).push(o)}}}function oh(t,e,i){return function(r,n){var o=t.call(void 0!==i?i:this,r,n);void 0!==o&&(n[n.length-1][void 0!==e?e:r.localName]=o)}}function sh(t,e){return function(i,r,n){t.call(void 0!==e?e:this,i,r,n),n[n.length-1].node.appendChild(i)}}function ah(t,e){var i,r;return function(e,n,o){if(void 0===i){i={};var s={};s[e.localName]=t,i[e.namespaceURI]=s,r=hh(e.localName)}fh(i,r,n,o)}}function hh(t,e){var i=t;return function(t,r,n){var o=r[r.length-1].node,s=i;return void 0===s&&(s=n),Ja(void 0!==e?e:o.namespaceURI,s)}}var lh=hh();function uh(t,e){for(var i=e.length,r=new Array(i),n=0;n<i;++n)r[n]=t[e[n]];return r}function ph(t,e,i){var r,n,o=void 0!==i?i:{};for(r=0,n=t.length;r<n;++r)o[t[r]]=e;return o}function ch(t,e,i,r){var n;for(n=e.firstElementChild;n;n=n.nextElementSibling){var o=t[n.namespaceURI];if(void 0!==o){var s=o[n.localName];void 0!==s&&s.call(r,n,i)}}}function dh(t,e,i,r,n){return r.push(t),ch(e,i,r,n),r.pop()}function fh(t,e,i,r,n,o){for(var s,a,h=(void 0!==n?n:i).length,l=0;l<h;++l)void 0!==(s=i[l])&&void 0!==(a=e.call(void 0!==o?o:this,s,r,void 0!==n?n[l]:void 0))&&t[a.namespaceURI][a.localName].call(o,a,s,r)}function gh(t,e,i,r,n,o,s){return n.push(t),fh(e,i,r,n,o,s),n.pop()}var _h=function(t){function e(){t.call(this),this.xmlSerializer_=new XMLSerializer}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.XML},e.prototype.readFeature=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readFeatureFromDocument(i,e)}return $a(t)?this.readFeatureFromDocument(t,e):this.readFeatureFromNode(t,e)}return null},e.prototype.readFeatureFromDocument=function(t,e){var i=this.readFeaturesFromDocument(t,e);return i.length>0?i[0]:null},e.prototype.readFeatureFromNode=function(t,e){return null},e.prototype.readFeatures=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readFeaturesFromDocument(i,e)}return $a(t)?this.readFeaturesFromDocument(t,e):this.readFeaturesFromNode(t,e)}return[]},e.prototype.readFeaturesFromDocument=function(t,e){for(var i=[],r=t.firstChild;r;r=r.nextSibling)r.nodeType==Node.ELEMENT_NODE&&kt(i,this.readFeaturesFromNode(r,e));return i},e.prototype.readFeaturesFromNode=function(t,e){return r()},e.prototype.readGeometry=function(t,e){if(t){if("string"==typeof t){var i=th(t);return this.readGeometryFromDocument(i,e)}return $a(t)?this.readGeometryFromDocument(t,e):this.readGeometryFromNode(t,e)}return null},e.prototype.readGeometryFromDocument=function(t,e){return null},e.prototype.readGeometryFromNode=function(t,e){return null},e.prototype.readProjection=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readProjectionFromDocument(e)}return $a(t)?this.readProjectionFromDocument(t):this.readProjectionFromNode(t)}return null},e.prototype.readProjectionFromDocument=function(t){return this.dataProjection},e.prototype.readProjectionFromNode=function(t){return this.dataProjection},e.prototype.writeFeature=function(t,e){var i=this.writeFeatureNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeFeatureNode=function(t,e){return null},e.prototype.writeFeatures=function(t,e){var i=this.writeFeaturesNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeFeaturesNode=function(t,e){return null},e.prototype.writeGeometry=function(t,e){var i=this.writeGeometryNode(t,e);return this.xmlSerializer_.serializeToString(i)},e.prototype.writeGeometryNode=function(t,e){return null},e}(Xa),yh="http://www.opengis.net/gml",vh=/^[\s\xa0]*$/,mh=function(t){function e(e){t.call(this);var i=e||{};this.featureType=i.featureType,this.featureNS=i.featureNS,this.srsName=i.srsName,this.schemaLocation="",this.FEATURE_COLLECTION_PARSERS={},this.FEATURE_COLLECTION_PARSERS[this.namespace]={featureMember:ih(this.readFeaturesInternal),featureMembers:rh(this.readFeaturesInternal)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeaturesInternal=function(t,e){var i=t.localName,r=null;if("FeatureCollection"==i)r=dh([],this.FEATURE_COLLECTION_PARSERS,t,e,this);else if("featureMembers"==i||"featureMember"==i){var n=e[0],o=n.featureType,s=n.featureNS;if(!o&&t.childNodes){o=[],s={};for(var a=0,h=t.childNodes.length;a<h;++a){var l=t.childNodes[a];if(1===l.nodeType){var u=l.nodeName.split(":").pop();if(-1===o.indexOf(u)){var p="",c=0,d=l.namespaceURI;for(var f in s){if(s[f]===d){p=f;break}++c}p||(s[p="p"+c]=d),o.push(p+":"+u)}}}"featureMember"!=i&&(n.featureType=o,n.featureNS=s)}if("string"==typeof s){var g=s;(s={}).p0=g}var _={},y=Array.isArray(o)?o:[o];for(var v in s){for(var m={},E=0,S=y.length;E<S;++E){(-1===y[E].indexOf(":")?"p0":y[E].split(":")[0])===v&&(m[y[E].split(":").pop()]="featureMembers"==i?ih(this.readFeatureElement,this):rh(this.readFeatureElement,this))}_[s[v]]=m}r=dh("featureMember"==i?void 0:[],_,t,e)}return null===r&&(r=[]),r},e.prototype.readGeometryElement=function(t,e){var i=e[0];i.srsName=t.firstElementChild.getAttribute("srsName"),i.srsDimension=t.firstElementChild.getAttribute("srsDimension");var r=dh(null,this.GEOMETRY_PARSERS,t,e,this);return r?Ba(r,!1,i):void 0},e.prototype.readFeatureElementInternal=function(t,e,i){for(var r,n={},o=t.firstElementChild;o;o=o.nextElementSibling){var s=void 0,a=o.localName;0===o.childNodes.length||1===o.childNodes.length&&(3===o.firstChild.nodeType||4===o.firstChild.nodeType)?(s=Qa(o,!1),vh.test(s)&&(s=void 0)):(i&&(s=this.readGeometryElement(o,e)),s?"boundedBy"!==a&&(r=a):s=this.readFeatureElementInternal(o,e,!1)),n[a]?(n[a]instanceof Array||(n[a]=[n[a]]),n[a].push(s)):n[a]=s;var h=o.attributes.length;if(h>0){n[a]={_content_:n[a]};for(var l=0;l<h;l++){var u=o.attributes[l].name;n[a][u]=o.attributes[l].value}}}if(i){var p=new Oa(n);r&&p.setGeometryName(r);var c=t.getAttribute("fid")||function(t,e,i){return t.getAttributeNS(e,i)||""}(t,this.namespace,"id");return c&&p.setId(c),p}return n},e.prototype.readFeatureElement=function(t,e){return this.readFeatureElementInternal(t,e,!0)},e.prototype.readPoint=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);if(i)return new Gr(i,yi.XYZ)},e.prototype.readMultiPoint=function(t,e){var i=dh([],this.MULTIPOINT_PARSERS_,t,e,this);return i?new La(i):void 0},e.prototype.readMultiLineString=function(t,e){var i=dh([],this.MULTILINESTRING_PARSERS_,t,e,this);if(i)return new ba(i)},e.prototype.readMultiPolygon=function(t,e){var i=dh([],this.MULTIPOLYGON_PARSERS_,t,e,this);if(i)return new Na(i)},e.prototype.pointMemberParser_=function(t,e){ch(this.POINTMEMBER_PARSERS_,t,e,this)},e.prototype.lineStringMemberParser_=function(t,e){ch(this.LINESTRINGMEMBER_PARSERS_,t,e,this)},e.prototype.polygonMemberParser_=function(t,e){ch(this.POLYGONMEMBER_PARSERS_,t,e,this)},e.prototype.readLineString=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);return i?new Fa(i,yi.XYZ):void 0},e.prototype.readFlatLinearRing_=function(t,e){var i=dh(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this);return i||void 0},e.prototype.readLinearRing=function(t,e){var i=this.readFlatCoordinatesFromNode_(t,e);if(i)return new Ar(i,yi.XYZ)},e.prototype.readPolygon=function(t,e){var i=dh([null],this.FLAT_LINEAR_RINGS_PARSERS,t,e,this);if(i&&i[0]){var r,n,o=i[0],s=[o.length];for(r=1,n=i.length;r<n;++r)kt(o,i[r]),s.push(o.length);return new qr(o,yi.XYZ,s)}},e.prototype.readFlatCoordinatesFromNode_=function(t,e){return dh(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this)},e.prototype.readGeometryFromNode=function(t,e){var i=this.readGeometryElement(t,[this.getReadOptions(t,e||{})]);return i||null},e.prototype.readFeaturesFromNode=function(t,e){var i={featureType:this.featureType,featureNS:this.featureNS};return e&&u(i,this.getReadOptions(t,e)),this.readFeaturesInternal(t,[i])||[]},e.prototype.readProjectionFromNode=function(t){return Zi(this.srsName?this.srsName:t.firstElementChild.getAttribute("srsName"))},e}(_h);mh.prototype.namespace=yh,mh.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{}},mh.prototype.MULTIPOINT_PARSERS_={"http://www.opengis.net/gml":{pointMember:ih(mh.prototype.pointMemberParser_),pointMembers:ih(mh.prototype.pointMemberParser_)}},mh.prototype.MULTILINESTRING_PARSERS_={"http://www.opengis.net/gml":{lineStringMember:ih(mh.prototype.lineStringMemberParser_),lineStringMembers:ih(mh.prototype.lineStringMemberParser_)}},mh.prototype.MULTIPOLYGON_PARSERS_={"http://www.opengis.net/gml":{polygonMember:ih(mh.prototype.polygonMemberParser_),polygonMembers:ih(mh.prototype.polygonMemberParser_)}},mh.prototype.POINTMEMBER_PARSERS_={"http://www.opengis.net/gml":{Point:ih(mh.prototype.readFlatCoordinatesFromNode_)}},mh.prototype.LINESTRINGMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ih(mh.prototype.readLineString)}},mh.prototype.POLYGONMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ih(mh.prototype.readPolygon)}},mh.prototype.RING_PARSERS={"http://www.opengis.net/gml":{LinearRing:rh(mh.prototype.readFlatLinearRing_)}};var Eh=mh;function Sh(t){return Th(Qa(t,!1))}function Th(t){var e=/^\s*(true|1)|(false|0)\s*$/.exec(t);return e?void 0!==e[1]||!1:void 0}function Rh(t){var e=Qa(t,!1),i=Date.parse(e);return isNaN(i)?void 0:i/1e3}function Ch(t){return xh(Qa(t,!1))}function xh(t){var e=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);return e?parseFloat(e[1]):void 0}function wh(t){return Ih(Qa(t,!1))}function Ih(t){var e=/^\s*(\d+)\s*$/.exec(t);return e?parseInt(e[1],10):void 0}function Oh(t){return Qa(t,!1).trim()}function Lh(t,e){bh(t,e?"1":"0")}function Ph(t,e){t.appendChild(Ha.createCDATASection(e))}function Mh(t,e){var i=e.toPrecision();t.appendChild(Ha.createTextNode(i))}function Fh(t,e){var i=e.toString();t.appendChild(Ha.createTextNode(i))}function bh(t,e){t.appendChild(Ha.createTextNode(e))}var Nh=yh+" http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",Ah={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"},Gh=function(t){function e(e){var i=e||{};t.call(this,i),this.surface_=void 0!==i.surface&&i.surface,this.curve_=void 0!==i.curve&&i.curve,this.multiCurve_=void 0===i.multiCurve||i.multiCurve,this.multiSurface_=void 0===i.multiSurface||i.multiSurface,this.schemaLocation=i.schemaLocation?i.schemaLocation:Nh,this.hasZ=void 0!==i.hasZ&&i.hasZ}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readMultiCurve_=function(t,e){var i=dh([],this.MULTICURVE_PARSERS_,t,e,this);return i?new ba(i):void 0},e.prototype.readMultiSurface_=function(t,e){var i=dh([],this.MULTISURFACE_PARSERS_,t,e,this);if(i)return new Na(i)},e.prototype.curveMemberParser_=function(t,e){ch(this.CURVEMEMBER_PARSERS_,t,e,this)},e.prototype.surfaceMemberParser_=function(t,e){ch(this.SURFACEMEMBER_PARSERS_,t,e,this)},e.prototype.readPatch_=function(t,e){return dh([null],this.PATCHES_PARSERS_,t,e,this)},e.prototype.readSegment_=function(t,e){return dh([null],this.SEGMENTS_PARSERS_,t,e,this)},e.prototype.readPolygonPatch_=function(t,e){return dh([null],this.FLAT_LINEAR_RINGS_PARSERS,t,e,this)},e.prototype.readLineStringSegment_=function(t,e){return dh([null],this.GEOMETRY_FLAT_COORDINATES_PARSERS,t,e,this)},e.prototype.interiorParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&e[e.length-1].push(i)},e.prototype.exteriorParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&(e[e.length-1][0]=i)},e.prototype.readSurface_=function(t,e){var i=dh([null],this.SURFACE_PARSERS_,t,e,this);if(i&&i[0]){var r,n,o=i[0],s=[o.length];for(r=1,n=i.length;r<n;++r)kt(o,i[r]),s.push(o.length);return new qr(o,yi.XYZ,s)}},e.prototype.readCurve_=function(t,e){var i=dh([null],this.CURVE_PARSERS_,t,e,this);return i?new Fa(i,yi.XYZ):void 0},e.prototype.readEnvelope_=function(t,e){var i=dh([null],this.ENVELOPE_PARSERS_,t,e,this);return Ve(i[1][0],i[1][1],i[2][0],i[2][1])},e.prototype.readFlatPos_=function(t,e){for(var i,r=Qa(t,!1),n=/^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/,o=[];i=n.exec(r);)o.push(parseFloat(i[1])),r=r.substr(i[0].length);if(""===r){var s,a,h=e[0].srsName,l="enu";if(h)l=Zi(h).getAxisOrientation();if("neu"===l)for(s=0,a=o.length;s<a;s+=3){var u=o[s],p=o[s+1];o[s]=p,o[s+1]=u}var c=o.length;if(2==c&&o.push(0),0!==c)return o}},e.prototype.readFlatPosList_=function(t,e){var i=Qa(t,!1).replace(/^\s*|\s*$/g,""),r=e[0],n=r.srsName,o=r.srsDimension,s="enu";n&&(s=Zi(n).getAxisOrientation());var a,h,l,u=i.split(/\s+/),p=2;t.getAttribute("srsDimension")?p=Ih(t.getAttribute("srsDimension")):t.getAttribute("dimension")?p=Ih(t.getAttribute("dimension")):t.parentNode.getAttribute("srsDimension")?p=Ih(t.parentNode.getAttribute("srsDimension")):o&&(p=Ih(o));for(var c=[],d=0,f=u.length;d<f;d+=p)a=parseFloat(u[d]),h=parseFloat(u[d+1]),l=3===p?parseFloat(u[d+2]):0,"en"===s.substr(0,2)?c.push(a,h,l):c.push(h,a,l);return c},e.prototype.writePos_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=n?"3":"2";t.setAttribute("srsDimension",o);var s=r.srsName,a="enu";s&&(a=Zi(s).getAxisOrientation());var h,l=e.getCoordinates();(h="en"===a.substr(0,2)?l[0]+" "+l[1]:l[1]+" "+l[0],n)&&(h+=" "+(l[2]||0));bh(t,h)},e.prototype.getCoords_=function(t,e,i){var r="enu";e&&(r=Zi(e).getAxisOrientation());var n="en"===r.substr(0,2)?t[0]+" "+t[1]:t[1]+" "+t[0];i&&(n+=" "+(t[2]||0));return n},e.prototype.writePosList_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=n?"3":"2";t.setAttribute("srsDimension",o);for(var s,a=r.srsName,h=e.getCoordinates(),l=h.length,u=new Array(l),p=0;p<l;++p)s=h[p],u[p]=this.getCoords_(s,a,n);bh(t,u.join(" "))},e.prototype.writePoint_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=Ja(t.namespaceURI,"pos");t.appendChild(n),this.writePos_(n,e,i)},e.prototype.writeEnvelope=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=[e[0]+" "+e[1],e[2]+" "+e[3]];gh({node:t},this.ENVELOPE_SERIALIZERS_,lh,n,i,["lowerCorner","upperCorner"],this)},e.prototype.writeLinearRing_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=Ja(t.namespaceURI,"posList");t.appendChild(n),this.writePosList_(n,e,i)},e.prototype.RING_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1],n=r.node,o=r.exteriorWritten;return void 0===o&&(r.exteriorWritten=!0),Ja(n.namespaceURI,void 0!==o?"interior":"exterior")},e.prototype.writeSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;if("PolygonPatch"!==t.nodeName&&o&&t.setAttribute("srsName",o),"Polygon"===t.nodeName||"PolygonPatch"===t.nodeName){var s=e.getLinearRings();gh({node:t,hasZ:n,srsName:o},this.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,s,i,void 0,this)}else if("Surface"===t.nodeName){var a=Ja(t.namespaceURI,"patches");t.appendChild(a),this.writeSurfacePatches_(a,e,i)}},e.prototype.writeCurveOrLineString_=function(t,e,i){var r=i[i.length-1].srsName;if("LineStringSegment"!==t.nodeName&&r&&t.setAttribute("srsName",r),"LineString"===t.nodeName||"LineStringSegment"===t.nodeName){var n=Ja(t.namespaceURI,"posList");t.appendChild(n),this.writePosList_(n,e,i)}else if("Curve"===t.nodeName){var o=Ja(t.namespaceURI,"segments");t.appendChild(o),this.writeCurveSegments_(o,e,i)}},e.prototype.writeMultiSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.surface;o&&t.setAttribute("srsName",o);var a=e.getPolygons();gh({node:t,hasZ:n,srsName:o,surface:s},this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeMultiPoint_=function(t,e,i){var r=i[i.length-1],n=r.srsName,o=r.hasZ;n&&t.setAttribute("srsName",n);var s=e.getPoints();gh({node:t,hasZ:o,srsName:n},this.POINTMEMBER_SERIALIZERS_,hh("pointMember"),s,i,void 0,this)},e.prototype.writeMultiCurveOrLineString_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.curve;o&&t.setAttribute("srsName",o);var a=e.getLineStrings();gh({node:t,hasZ:n,srsName:o,curve:s},this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeRing_=function(t,e,i){var r=Ja(t.namespaceURI,"LinearRing");t.appendChild(r),this.writeLinearRing_(r,e,i)},e.prototype.writeSurfaceOrPolygonMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i))},e.prototype.writePointMember_=function(t,e,i){var r=Ja(t.namespaceURI,"Point");t.appendChild(r),this.writePoint_(r,e,i)},e.prototype.writeLineStringOrCurveMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeCurveOrLineString_(r,e,i))},e.prototype.writeSurfacePatches_=function(t,e,i){var r=Ja(t.namespaceURI,"PolygonPatch");t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i)},e.prototype.writeCurveSegments_=function(t,e,i){var r=Ja(t.namespaceURI,"LineStringSegment");t.appendChild(r),this.writeCurveOrLineString_(r,e,i)},e.prototype.writeGeometryElement=function(t,e,i){var r,n=i[i.length-1],o=u({},n);o.node=t,r=Array.isArray(e)?n.dataProjection?rr(e,n.featureProjection,n.dataProjection):e:Ba(e,!0,n),gh(o,this.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[r],i,void 0,this)},e.prototype.writeFeatureElement=function(t,e,i){var r=e.getId();r&&t.setAttribute("fid",r);var n=i[i.length-1],o=n.featureNS,s=e.getGeometryName();n.serializers||(n.serializers={},n.serializers[o]={});var a=e.getProperties(),h=[],l=[];for(var p in a){var c=a[p];null!==c&&(h.push(p),l.push(c),p==s||"function"==typeof c.getSimplifiedGeometry?p in n.serializers[o]||(n.serializers[o][p]=sh(this.writeGeometryElement,this)):p in n.serializers[o]||(n.serializers[o][p]=sh(bh)))}var d=u({},n);d.node=t,gh(d,n.serializers,hh(void 0,o),l,i,h)},e.prototype.writeFeatureMembers_=function(t,e,i){var r=i[i.length-1],n=r.featureType,o=r.featureNS,s={};s[o]={},s[o][n]=sh(this.writeFeatureElement,this);var a=u({},r);a.node=t,gh(a,s,hh(n,o),e,i)},e.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1].node;return Ja(this.namespace,Ah[r.nodeName])},e.prototype.GEOMETRY_NODE_FACTORY_=function(t,e,i){var r,n=e[e.length-1],o=n.multiSurface,s=n.surface,a=n.curve,h=n.multiCurve;return Array.isArray(t)?r="Envelope":"MultiPolygon"===(r=t.getType())&&!0===o?r="MultiSurface":"Polygon"===r&&!0===s?r="Surface":"LineString"===r&&!0===a?r="Curve":"MultiLineString"===r&&!0===h&&(r="MultiCurve"),Ja(this.namespace,r)},e.prototype.writeGeometryNode=function(t,e){e=this.adaptOptions(e);var i=Ja(this.namespace,"geom"),r={node:i,hasZ:this.hasZ,srsName:this.srsName,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_};return e&&u(r,e),this.writeGeometryElement(i,t,[r]),i},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja(this.namespace,"featureMembers");i.setAttributeNS(qa,"xsi:schemaLocation",this.schemaLocation);var r={srsName:this.srsName,hasZ:this.hasZ,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_,featureNS:this.featureNS,featureType:this.featureType};return e&&u(r,e),this.writeFeatureMembers_(i,t,[r]),i},e}(Eh);Gh.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{pos:rh(Gh.prototype.readFlatPos_),posList:rh(Gh.prototype.readFlatPosList_)}},Gh.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{interior:Gh.prototype.interiorParser_,exterior:Gh.prototype.exteriorParser_}},Gh.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{Point:rh(Eh.prototype.readPoint),MultiPoint:rh(Eh.prototype.readMultiPoint),LineString:rh(Eh.prototype.readLineString),MultiLineString:rh(Eh.prototype.readMultiLineString),LinearRing:rh(Eh.prototype.readLinearRing),Polygon:rh(Eh.prototype.readPolygon),MultiPolygon:rh(Eh.prototype.readMultiPolygon),Surface:rh(Gh.prototype.readSurface_),MultiSurface:rh(Gh.prototype.readMultiSurface_),Curve:rh(Gh.prototype.readCurve_),MultiCurve:rh(Gh.prototype.readMultiCurve_),Envelope:rh(Gh.prototype.readEnvelope_)}},Gh.prototype.MULTICURVE_PARSERS_={"http://www.opengis.net/gml":{curveMember:ih(Gh.prototype.curveMemberParser_),curveMembers:ih(Gh.prototype.curveMemberParser_)}},Gh.prototype.MULTISURFACE_PARSERS_={"http://www.opengis.net/gml":{surfaceMember:ih(Gh.prototype.surfaceMemberParser_),surfaceMembers:ih(Gh.prototype.surfaceMemberParser_)}},Gh.prototype.CURVEMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ih(Eh.prototype.readLineString),Curve:ih(Gh.prototype.readCurve_)}},Gh.prototype.SURFACEMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ih(Eh.prototype.readPolygon),Surface:ih(Gh.prototype.readSurface_)}},Gh.prototype.SURFACE_PARSERS_={"http://www.opengis.net/gml":{patches:rh(Gh.prototype.readPatch_)}},Gh.prototype.CURVE_PARSERS_={"http://www.opengis.net/gml":{segments:rh(Gh.prototype.readSegment_)}},Gh.prototype.ENVELOPE_PARSERS_={"http://www.opengis.net/gml":{lowerCorner:ih(Gh.prototype.readFlatPosList_),upperCorner:ih(Gh.prototype.readFlatPosList_)}},Gh.prototype.PATCHES_PARSERS_={"http://www.opengis.net/gml":{PolygonPatch:rh(Gh.prototype.readPolygonPatch_)}},Gh.prototype.SEGMENTS_PARSERS_={"http://www.opengis.net/gml":{LineStringSegment:rh(Gh.prototype.readLineStringSegment_)}},Gh.prototype.writeFeatures,Gh.prototype.RING_SERIALIZERS_={"http://www.opengis.net/gml":{exterior:sh(Gh.prototype.writeRing_),interior:sh(Gh.prototype.writeRing_)}},Gh.prototype.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:sh(bh),upperCorner:sh(bh)}},Gh.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:sh(Gh.prototype.writeSurfaceOrPolygonMember_),polygonMember:sh(Gh.prototype.writeSurfaceOrPolygonMember_)}},Gh.prototype.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:sh(Gh.prototype.writePointMember_)}},Gh.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:sh(Gh.prototype.writeLineStringOrCurveMember_),curveMember:sh(Gh.prototype.writeLineStringOrCurveMember_)}},Gh.prototype.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:sh(Gh.prototype.writeCurveOrLineString_),MultiCurve:sh(Gh.prototype.writeMultiCurveOrLineString_),Point:sh(Gh.prototype.writePoint_),MultiPoint:sh(Gh.prototype.writeMultiPoint_),LineString:sh(Gh.prototype.writeCurveOrLineString_),MultiLineString:sh(Gh.prototype.writeMultiCurveOrLineString_),LinearRing:sh(Gh.prototype.writeLinearRing_),Polygon:sh(Gh.prototype.writeSurfaceOrPolygon_),MultiPolygon:sh(Gh.prototype.writeMultiSurfaceOrPolygon_),Surface:sh(Gh.prototype.writeSurfaceOrPolygon_),MultiSurface:sh(Gh.prototype.writeMultiSurfaceOrPolygon_),Envelope:sh(Gh.prototype.writeEnvelope)}};var Dh=Gh,kh=Dh;kh.prototype.writeFeatures,kh.prototype.writeFeaturesNode;var Yh=kh,Uh=[null,"http://www.topografix.com/GPX/1/0","http://www.topografix.com/GPX/1/1"],jh={rte:gl,trk:_l,wpt:yl},Xh=ph(Uh,{rte:ih(gl),trk:ih(_l),wpt:ih(yl)}),Bh=ph(Uh,{text:oh(Oh,"linkText"),type:oh(Oh,"linkType")}),Vh=ph(Uh,{rte:sh(function(t,e,i){var r=i[0],n=e.getProperties(),o={node:t};o.properties=n;var s=e.getGeometry();if(s.getType()==_i.LINE_STRING){var a=Ba(s,!0,r);o.geometryLayout=a.getLayout(),n.rtept=a.getCoordinates()}var h=i[i.length-1].node,l=tl[h.namespaceURI],u=uh(n,l);gh(o,el,lh,u,i,l)}),trk:sh(function(t,e,i){var r=i[0],n=e.getProperties(),o={node:t};o.properties=n;var s=e.getGeometry();if(s.getType()==_i.MULTI_LINE_STRING){var a=Ba(s,!0,r);n.trkseg=a.getLineStrings()}var h=i[i.length-1].node,l=rl[h.namespaceURI],u=uh(n,l);gh(o,nl,lh,u,i,l)}),wpt:sh(function(t,e,i){var r=i[0],n=i[i.length-1];n.properties=e.getProperties();var o=e.getGeometry();if(o.getType()==_i.POINT){var s=Ba(o,!0,r);n.geometryLayout=s.getLayout(),ml(t,s.getCoordinates(),i)}})}),Wh=function(t){function e(e){t.call(this);var i=e||{};this.dataProjection=Zi("EPSG:4326"),this.readExtensions_=i.readExtensions}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleReadExtensions_=function(t){t||(t=[]);for(var e=0,i=t.length;e<i;++e){var r=t[e];if(this.readExtensions_){var n=r.get("extensionsNode_")||null;this.readExtensions_(r,n)}r.set("extensionsNode_",void 0)}},e.prototype.readFeatureFromNode=function(t,e){if(!At(Uh,t.namespaceURI))return null;var i=jh[t.localName];if(!i)return null;var r=i(t,[this.getReadOptions(t,e)]);return r?(this.handleReadExtensions_([r]),r):null},e.prototype.readFeaturesFromNode=function(t,e){if(!At(Uh,t.namespaceURI))return[];if("gpx"==t.localName){var i=dh([],Xh,t,[this.getReadOptions(t,e)]);return i?(this.handleReadExtensions_(i),i):[]}return[]},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja("http://www.topografix.com/GPX/1/1","gpx");return i.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xsi",qa),i.setAttributeNS(qa,"xsi:schemaLocation","http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"),i.setAttribute("version","1.1"),i.setAttribute("creator","OpenLayers"),gh({node:i},Vh,ul,t,[e]),i},e}(_h),Kh=ph(Uh,{name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,number:oh(wh),extensions:fl,type:oh(Oh),rtept:function(t,e){var i=dh({},zh,t,e);if(i){var r=e[e.length-1],n=r.flatCoordinates,o=r.layoutOptions;pl(n,o,t,i)}}}),zh=ph(Uh,{ele:oh(Ch),time:oh(Rh)}),Zh=ph(Uh,{name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,number:oh(wh),type:oh(Oh),extensions:fl,trkseg:function(t,e){var i=e[e.length-1];ch(Hh,t,e);var r=i.flatCoordinates;i.ends.push(r.length)}}),Hh=ph(Uh,{trkpt:function(t,e){var i=dh({},qh,t,e);if(i){var r=e[e.length-1],n=r.flatCoordinates,o=r.layoutOptions;pl(n,o,t,i)}}}),qh=ph(Uh,{ele:oh(Ch),time:oh(Rh)}),Jh=ph(Uh,{ele:oh(Ch),time:oh(Rh),magvar:oh(Ch),geoidheight:oh(Ch),name:oh(Oh),cmt:oh(Oh),desc:oh(Oh),src:oh(Oh),link:dl,sym:oh(Oh),type:oh(Oh),fix:oh(Oh),sat:oh(wh),hdop:oh(Ch),vdop:oh(Ch),pdop:oh(Ch),ageofdgpsdata:oh(Ch),dgpsid:oh(wh),extensions:fl}),Qh=["text","type"],$h=ph(Uh,{text:sh(bh),type:sh(bh)}),tl=ph(Uh,["name","cmt","desc","src","link","number","type","rtept"]),el=ph(Uh,{name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),number:sh(Fh),type:sh(bh),rtept:ah(sh(ml))}),il=ph(Uh,["ele","time"]),rl=ph(Uh,["name","cmt","desc","src","link","number","type","trkseg"]),nl=ph(Uh,{name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),number:sh(Fh),type:sh(bh),trkseg:ah(sh(function(t,e,i){var r={node:t};r.geometryLayout=e.getLayout(),r.properties={},gh(r,sl,ol,e.getCoordinates(),i)}))}),ol=hh("trkpt"),sl=ph(Uh,{trkpt:sh(ml)}),al=ph(Uh,["ele","time","magvar","geoidheight","name","cmt","desc","src","link","sym","type","fix","sat","hdop","vdop","pdop","ageofdgpsdata","dgpsid"]),hl=ph(Uh,{ele:sh(Mh),time:sh(function(t,e){var i=new Date(1e3*e),r=i.getUTCFullYear()+"-"+Ee(i.getUTCMonth()+1,2)+"-"+Ee(i.getUTCDate(),2)+"T"+Ee(i.getUTCHours(),2)+":"+Ee(i.getUTCMinutes(),2)+":"+Ee(i.getUTCSeconds(),2)+"Z";t.appendChild(Ha.createTextNode(r))}),magvar:sh(Mh),geoidheight:sh(Mh),name:sh(bh),cmt:sh(bh),desc:sh(bh),src:sh(bh),link:sh(vl),sym:sh(bh),type:sh(bh),fix:sh(bh),sat:sh(Fh),hdop:sh(Mh),vdop:sh(Mh),pdop:sh(Mh),ageofdgpsdata:sh(Mh),dgpsid:sh(Fh)}),ll={Point:"wpt",LineString:"rte",MultiLineString:"trk"};function ul(t,e,i){var r=t.getGeometry();if(r){var n=ll[r.getType()];if(n)return Ja(e[e.length-1].node.namespaceURI,n)}}function pl(t,e,i,r){return t.push(parseFloat(i.getAttribute("lon")),parseFloat(i.getAttribute("lat"))),"ele"in r?(t.push(r.ele),delete r.ele,e.hasZ=!0):t.push(0),"time"in r?(t.push(r.time),delete r.time,e.hasM=!0):t.push(0),t}function cl(t,e,i){var r=yi.XY,n=2;if(t.hasZ&&t.hasM?(r=yi.XYZM,n=4):t.hasZ?(r=yi.XYZ,n=3):t.hasM&&(r=yi.XYM,n=3),4!==n){for(var o=0,s=e.length/4;o<s;o++)e[o*n]=e[4*o],e[o*n+1]=e[4*o+1],t.hasZ&&(e[o*n+2]=e[4*o+2]),t.hasM&&(e[o*n+2]=e[4*o+3]);if(e.length=e.length/4*n,i)for(var a=0,h=i.length;a<h;a++)i[a]=i[a]/4*n}return r}function dl(t,e){var i=e[e.length-1],r=t.getAttribute("href");null!==r&&(i.link=r),ch(Bh,t,e)}function fl(t,e){e[e.length-1].extensionsNode_=t}function gl(t,e){var i=e[0],r=dh({flatCoordinates:[],layoutOptions:{}},Kh,t,e);if(r){var n=r.flatCoordinates;delete r.flatCoordinates;var o=r.layoutOptions;delete r.layoutOptions;var s=cl(o,n),a=new Fa(n,s);Ba(a,!1,i);var h=new Oa(a);return h.setProperties(r),h}}function _l(t,e){var i=e[0],r=dh({flatCoordinates:[],ends:[],layoutOptions:{}},Zh,t,e);if(r){var n=r.flatCoordinates;delete r.flatCoordinates;var o=r.ends;delete r.ends;var s=r.layoutOptions;delete r.layoutOptions;var a=cl(s,n,o),h=new ba(n,a,o);Ba(h,!1,i);var l=new Oa(h);return l.setProperties(r),l}}function yl(t,e){var i=e[0],r=dh({},Jh,t,e);if(r){var n={},o=pl([],n,t,r),s=cl(n,o),a=new Gr(o,s);Ba(a,!1,i);var h=new Oa(a);return h.setProperties(r),h}}function vl(t,e,i){t.setAttribute("href",e);var r=i[i.length-1].properties,n=[r.linkText,r.linkType];gh({node:t},$h,lh,n,i,Qh)}function ml(t,e,i){var r=i[i.length-1],n=r.node.namespaceURI,o=r.properties;switch(t.setAttributeNS(null,"lat",String(e[1])),t.setAttributeNS(null,"lon",String(e[0])),r.geometryLayout){case yi.XYZM:0!==e[3]&&(o.time=e[3]);case yi.XYZ:0!==e[2]&&(o.ele=e[2]);break;case yi.XYM:0!==e[2]&&(o.time=e[2])}var s="rtept"==t.nodeName?il[n]:al[n],a=uh(o,s);gh({node:t,properties:o},hl,lh,a,i,s)}var El=Wh,Sl=function(t){var e=t||{};this.color_=void 0!==e.color?e.color:null,this.checksum_=void 0};Sl.prototype.clone=function(){var t=this.getColor();return new Sl({color:Array.isArray(t)?t.slice():t||void 0})},Sl.prototype.getColor=function(){return this.color_},Sl.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},Sl.prototype.getChecksum=function(){if(void 0===this.checksum_){var t=this.color_;t?Array.isArray(t)||"string"==typeof t?this.checksum_="f"+$o(t):this.checksum_=o(this.color_):this.checksum_="f-"}return this.checksum_};var Tl=Sl,Rl={FRACTION:"fraction",PIXELS:"pixels"},Cl=function(t){function e(e,i,r,n,o,s){t.call(this),this.hitDetectionImage_=null,this.image_=e||new Image,null!==n&&(this.image_.crossOrigin=n),this.canvas_=s?document.createElement("canvas"):null,this.color_=s,this.imageListenerKeys_=null,this.imageState_=o,this.size_=r,this.src_=i,this.tainted_}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isTainted_=function(){if(void 0===this.tainted_&&this.imageState_===Oo.LOADED){this.tainted_=!1;var t=on(1,1);try{t.drawImage(this.image_,0,0),t.getImageData(0,0,1,1)}catch(t){this.tainted_=!0}}return!0===this.tainted_},e.prototype.dispatchChangeEvent_=function(){this.dispatchEvent(M.CHANGE)},e.prototype.handleImageError_=function(){this.imageState_=Oo.ERROR,this.unlistenImage_(),this.dispatchChangeEvent_()},e.prototype.handleImageLoad_=function(){this.imageState_=Oo.LOADED,this.size_&&(this.image_.width=this.size_[0],this.image_.height=this.size_[1]),this.size_=[this.image_.width,this.image_.height],this.unlistenImage_(),this.replaceColor_(),this.dispatchChangeEvent_()},e.prototype.getImage=function(t){return this.canvas_?this.canvas_:this.image_},e.prototype.getImageState=function(){return this.imageState_},e.prototype.getHitDetectionImage=function(t){if(!this.hitDetectionImage_)if(this.isTainted_()){var e=this.size_[0],i=this.size_[1],r=on(e,i);r.fillRect(0,0,e,i),this.hitDetectionImage_=r.canvas}else this.hitDetectionImage_=this.image_;return this.hitDetectionImage_},e.prototype.getSize=function(){return this.size_},e.prototype.getSrc=function(){return this.src_},e.prototype.load=function(){if(this.imageState_==Oo.IDLE){this.imageState_=Oo.LOADING,this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)];try{this.image_.src=this.src_}catch(t){this.handleImageError_()}}},e.prototype.replaceColor_=function(){if(this.color_&&!this.isTainted_()){this.canvas_.width=this.image_.width,this.canvas_.height=this.image_.height;var t=this.canvas_.getContext("2d");t.drawImage(this.image_,0,0);for(var e=t.getImageData(0,0,this.image_.width,this.image_.height),i=e.data,r=this.color_[0]/255,n=this.color_[1]/255,o=this.color_[2]/255,s=0,a=i.length;s<a;s+=4)i[s]*=r,i[s+1]*=n,i[s+2]*=o;t.putImageData(e,0,0)}},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(P);var xl={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"},wl=function(t){this.opacity_=t.opacity,this.rotateWithView_=t.rotateWithView,this.rotation_=t.rotation,this.scale_=t.scale};wl.prototype.clone=function(){return new wl({opacity:this.getOpacity(),scale:this.getScale(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})},wl.prototype.getOpacity=function(){return this.opacity_},wl.prototype.getRotateWithView=function(){return this.rotateWithView_},wl.prototype.getRotation=function(){return this.rotation_},wl.prototype.getScale=function(){return this.scale_},wl.prototype.getSnapToPixel=function(){return!1},wl.prototype.getAnchor=function(){return r()},wl.prototype.getImage=function(t){return r()},wl.prototype.getHitDetectionImage=function(t){return r()},wl.prototype.getImageState=function(){return r()},wl.prototype.getImageSize=function(){return r()},wl.prototype.getHitDetectionImageSize=function(){return r()},wl.prototype.getOrigin=function(){return r()},wl.prototype.getSize=function(){return r()},wl.prototype.setOpacity=function(t){this.opacity_=t},wl.prototype.setRotateWithView=function(t){this.rotateWithView_=t},wl.prototype.setRotation=function(t){this.rotation_=t},wl.prototype.setScale=function(t){this.scale_=t},wl.prototype.setSnapToPixel=function(t){},wl.prototype.listenImageChange=function(t,e){return r()},wl.prototype.load=function(){r()},wl.prototype.unlistenImageChange=function(t,e){r()};var Il=wl,Ol=function(t){function e(e){var i=e||{},r=void 0!==i.opacity?i.opacity:1,n=void 0!==i.rotation?i.rotation:0,s=void 0!==i.scale?i.scale:1,a=void 0!==i.rotateWithView&&i.rotateWithView;t.call(this,{opacity:r,rotation:n,scale:s,rotateWithView:a}),this.anchor_=void 0!==i.anchor?i.anchor:[.5,.5],this.normalizedAnchor_=null,this.anchorOrigin_=void 0!==i.anchorOrigin?i.anchorOrigin:xl.TOP_LEFT,this.anchorXUnits_=void 0!==i.anchorXUnits?i.anchorXUnits:Rl.FRACTION,this.anchorYUnits_=void 0!==i.anchorYUnits?i.anchorYUnits:Rl.FRACTION,this.crossOrigin_=void 0!==i.crossOrigin?i.crossOrigin:null;var h=void 0!==i.img?i.img:null,l=void 0!==i.imgSize?i.imgSize:null,u=i.src;te(!(void 0!==u&&h),4),te(!h||h&&l,5),void 0!==u&&0!==u.length||!h||(u=h.src||o(h)),te(void 0!==u&&u.length>0,6);var p=void 0!==i.src?Oo.IDLE:Oo.LOADED;this.color_=void 0!==i.color?es(i.color):null,this.iconImage_=function(t,e,i,r,n,o){var s=us.get(e,r,o);return s||(s=new Cl(t,e,i,r,n,o),us.set(e,r,o,s)),s}(h,u,l,this.crossOrigin_,p,this.color_),this.offset_=void 0!==i.offset?i.offset:[0,0],this.offsetOrigin_=void 0!==i.offsetOrigin?i.offsetOrigin:xl.TOP_LEFT,this.origin_=null,this.size_=void 0!==i.size?i.size:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e({anchor:this.anchor_.slice(),anchorOrigin:this.anchorOrigin_,anchorXUnits:this.anchorXUnits_,anchorYUnits:this.anchorYUnits_,crossOrigin:this.crossOrigin_,color:this.color_&&this.color_.slice?this.color_.slice():this.color_||void 0,src:this.getSrc(),offset:this.offset_.slice(),offsetOrigin:this.offsetOrigin_,size:null!==this.size_?this.size_.slice():void 0,opacity:this.getOpacity(),scale:this.getScale(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})},e.prototype.getAnchor=function(){if(this.normalizedAnchor_)return this.normalizedAnchor_;var t=this.anchor_,e=this.getSize();if(this.anchorXUnits_==Rl.FRACTION||this.anchorYUnits_==Rl.FRACTION){if(!e)return null;t=this.anchor_.slice(),this.anchorXUnits_==Rl.FRACTION&&(t[0]*=e[0]),this.anchorYUnits_==Rl.FRACTION&&(t[1]*=e[1])}if(this.anchorOrigin_!=xl.TOP_LEFT){if(!e)return null;t===this.anchor_&&(t=this.anchor_.slice()),this.anchorOrigin_!=xl.TOP_RIGHT&&this.anchorOrigin_!=xl.BOTTOM_RIGHT||(t[0]=-t[0]+e[0]),this.anchorOrigin_!=xl.BOTTOM_LEFT&&this.anchorOrigin_!=xl.BOTTOM_RIGHT||(t[1]=-t[1]+e[1])}return this.normalizedAnchor_=t,this.normalizedAnchor_},e.prototype.setAnchor=function(t){this.anchor_=t,this.normalizedAnchor_=null},e.prototype.getColor=function(){return this.color_},e.prototype.getImage=function(t){return this.iconImage_.getImage(t)},e.prototype.getImageSize=function(){return this.iconImage_.getSize()},e.prototype.getHitDetectionImageSize=function(){return this.getImageSize()},e.prototype.getImageState=function(){return this.iconImage_.getImageState()},e.prototype.getHitDetectionImage=function(t){return this.iconImage_.getHitDetectionImage(t)},e.prototype.getOrigin=function(){if(this.origin_)return this.origin_;var t=this.offset_;if(this.offsetOrigin_!=xl.TOP_LEFT){var e=this.getSize(),i=this.iconImage_.getSize();if(!e||!i)return null;t=t.slice(),this.offsetOrigin_!=xl.TOP_RIGHT&&this.offsetOrigin_!=xl.BOTTOM_RIGHT||(t[0]=i[0]-e[0]-t[0]),this.offsetOrigin_!=xl.BOTTOM_LEFT&&this.offsetOrigin_!=xl.BOTTOM_RIGHT||(t[1]=i[1]-e[1]-t[1])}return this.origin_=t,this.origin_},e.prototype.getSrc=function(){return this.iconImage_.getSrc()},e.prototype.getSize=function(){return this.size_?this.size_:this.iconImage_.getSize()},e.prototype.listenImageChange=function(t,e){return v(this.iconImage_,M.CHANGE,t,e)},e.prototype.load=function(){this.iconImage_.load()},e.prototype.unlistenImageChange=function(t,e){E(this.iconImage_,M.CHANGE,t,e)},e}(Il),Ll=function(t){var e=t||{};this.color_=void 0!==e.color?e.color:null,this.lineCap_=e.lineCap,this.lineDash_=void 0!==e.lineDash?e.lineDash:null,this.lineDashOffset_=e.lineDashOffset,this.lineJoin_=e.lineJoin,this.miterLimit_=e.miterLimit,this.width_=e.width,this.checksum_=void 0};Ll.prototype.clone=function(){var t=this.getColor();return new Ll({color:Array.isArray(t)?t.slice():t||void 0,lineCap:this.getLineCap(),lineDash:this.getLineDash()?this.getLineDash().slice():void 0,lineDashOffset:this.getLineDashOffset(),lineJoin:this.getLineJoin(),miterLimit:this.getMiterLimit(),width:this.getWidth()})},Ll.prototype.getColor=function(){return this.color_},Ll.prototype.getLineCap=function(){return this.lineCap_},Ll.prototype.getLineDash=function(){return this.lineDash_},Ll.prototype.getLineDashOffset=function(){return this.lineDashOffset_},Ll.prototype.getLineJoin=function(){return this.lineJoin_},Ll.prototype.getMiterLimit=function(){return this.miterLimit_},Ll.prototype.getWidth=function(){return this.width_},Ll.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},Ll.prototype.setLineCap=function(t){this.lineCap_=t,this.checksum_=void 0},Ll.prototype.setLineDash=function(t){this.lineDash_=t,this.checksum_=void 0},Ll.prototype.setLineDashOffset=function(t){this.lineDashOffset_=t,this.checksum_=void 0},Ll.prototype.setLineJoin=function(t){this.lineJoin_=t,this.checksum_=void 0},Ll.prototype.setMiterLimit=function(t){this.miterLimit_=t,this.checksum_=void 0},Ll.prototype.setWidth=function(t){this.width_=t,this.checksum_=void 0},Ll.prototype.getChecksum=function(){return void 0===this.checksum_&&(this.checksum_="s",this.color_?"string"==typeof this.color_?this.checksum_+=this.color_:this.checksum_+=o(this.color_):this.checksum_+="-",this.checksum_+=","+(void 0!==this.lineCap_?this.lineCap_.toString():"-")+","+(this.lineDash_?this.lineDash_.toString():"-")+","+(void 0!==this.lineDashOffset_?this.lineDashOffset_:"-")+","+(void 0!==this.lineJoin_?this.lineJoin_:"-")+","+(void 0!==this.miterLimit_?this.miterLimit_.toString():"-")+","+(void 0!==this.width_?this.width_.toString():"-")),this.checksum_};var Pl=Ll,Ml=function(t){function e(e){var i=void 0!==e.rotateWithView&&e.rotateWithView;t.call(this,{opacity:1,rotateWithView:i,rotation:void 0!==e.rotation?e.rotation:0,scale:1}),this.checksums_=null,this.canvas_=null,this.hitDetectionCanvas_=null,this.fill_=void 0!==e.fill?e.fill:null,this.origin_=[0,0],this.points_=e.points,this.radius_=void 0!==e.radius?e.radius:e.radius1,this.radius2_=e.radius2,this.angle_=void 0!==e.angle?e.angle:0,this.stroke_=void 0!==e.stroke?e.stroke:null,this.anchor_=null,this.size_=null,this.imageSize_=null,this.hitDetectionImageSize_=null,this.atlasManager_=e.atlasManager,this.render_(this.atlasManager_)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e({fill:this.getFill()?this.getFill().clone():void 0,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),stroke:this.getStroke()?this.getStroke().clone():void 0,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},e.prototype.getAnchor=function(){return this.anchor_},e.prototype.getAngle=function(){return this.angle_},e.prototype.getFill=function(){return this.fill_},e.prototype.getHitDetectionImage=function(t){return this.hitDetectionCanvas_},e.prototype.getImage=function(t){return this.canvas_},e.prototype.getImageSize=function(){return this.imageSize_},e.prototype.getHitDetectionImageSize=function(){return this.hitDetectionImageSize_},e.prototype.getImageState=function(){return Oo.LOADED},e.prototype.getOrigin=function(){return this.origin_},e.prototype.getPoints=function(){return this.points_},e.prototype.getRadius=function(){return this.radius_},e.prototype.getRadius2=function(){return this.radius2_},e.prototype.getSize=function(){return this.size_},e.prototype.getStroke=function(){return this.stroke_},e.prototype.listenImageChange=function(t,e){},e.prototype.load=function(){},e.prototype.unlistenImageChange=function(t,e){},e.prototype.render_=function(t){var e,i,r="",n="",o=0,s=null,a=0,h=0;this.stroke_&&(null===(i=this.stroke_.getColor())&&(i=Go),i=ns(i),void 0===(h=this.stroke_.getWidth())&&(h=1),s=this.stroke_.getLineDash(),a=this.stroke_.getLineDashOffset(),Z||(s=null,a=0),void 0===(n=this.stroke_.getLineJoin())&&(n="round"),void 0===(r=this.stroke_.getLineCap())&&(r="round"),void 0===(o=this.stroke_.getMiterLimit())&&(o=10));var l=2*(this.radius_+h)+1,u={strokeStyle:i,strokeWidth:h,size:l,lineCap:r,lineDash:s,lineDashOffset:a,lineJoin:n,miterLimit:o};if(void 0===t){var p=on(l,l);this.canvas_=p.canvas,e=l=this.canvas_.width,this.draw_(u,p,0,0),this.createHitDetectionCanvas_(u)}else{l=Math.round(l);var c,d=!this.fill_;d&&(c=this.drawHitDetectionCanvas_.bind(this,u));var f=this.getChecksum(),g=t.add(f,l,l,this.draw_.bind(this,u),c);this.canvas_=g.image,this.origin_=[g.offsetX,g.offsetY],e=g.image.width,d?(this.hitDetectionCanvas_=g.hitImage,this.hitDetectionImageSize_=[g.hitImage.width,g.hitImage.height]):(this.hitDetectionCanvas_=this.canvas_,this.hitDetectionImageSize_=[e,e])}this.anchor_=[l/2,l/2],this.size_=[l,l],this.imageSize_=[e,e]},e.prototype.draw_=function(t,e,i,r){var n,o,s;e.setTransform(1,0,0,1,0,0),e.translate(i,r),e.beginPath();var a=this.points_;if(a===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{var h=void 0!==this.radius2_?this.radius2_:this.radius_;for(h!==this.radius_&&(a*=2),n=0;n<=a;n++)o=2*n*Math.PI/a-Math.PI/2+this.angle_,s=n%2==0?this.radius_:h,e.lineTo(t.size/2+s*Math.cos(o),t.size/2+s*Math.sin(o))}if(this.fill_){var l=this.fill_.getColor();null===l&&(l=No),e.fillStyle=ns(l),e.fill()}this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineCap=t.lineCap,e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.stroke()),e.closePath()},e.prototype.createHitDetectionCanvas_=function(t){if(this.hitDetectionImageSize_=[t.size,t.size],this.fill_)this.hitDetectionCanvas_=this.canvas_;else{var e=on(t.size,t.size);this.hitDetectionCanvas_=e.canvas,this.drawHitDetectionCanvas_(t,e,0,0)}},e.prototype.drawHitDetectionCanvas_=function(t,e,i,r){e.setTransform(1,0,0,1,0,0),e.translate(i,r),e.beginPath();var n=this.points_;if(n===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{var o,s,a,h=void 0!==this.radius2_?this.radius2_:this.radius_;for(h!==this.radius_&&(n*=2),o=0;o<=n;o++)a=2*o*Math.PI/n-Math.PI/2+this.angle_,s=o%2==0?this.radius_:h,e.lineTo(t.size/2+s*Math.cos(a),t.size/2+s*Math.sin(a))}e.fillStyle=$o(No),e.fill(),this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.stroke()),e.closePath()},e.prototype.getChecksum=function(){var t=this.stroke_?this.stroke_.getChecksum():"-",e=this.fill_?this.fill_.getChecksum():"-";if(!this.checksums_||t!=this.checksums_[1]||e!=this.checksums_[2]||this.radius_!=this.checksums_[3]||this.radius2_!=this.checksums_[4]||this.angle_!=this.checksums_[5]||this.points_!=this.checksums_[6]){var i="r"+t+e+(void 0!==this.radius_?this.radius_.toString():"-")+(void 0!==this.radius2_?this.radius2_.toString():"-")+(void 0!==this.angle_?this.angle_.toString():"-")+(void 0!==this.points_?this.points_.toString():"-");this.checksums_=[i,t,e,this.radius_,this.radius2_,this.angle_,this.points_]}return this.checksums_[0]},e}(Il),Fl=function(t){function e(e){var i=e||{};t.call(this,{points:1/0,fill:i.fill,radius:i.radius,stroke:i.stroke,atlasManager:i.atlasManager})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){var t=new e({fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,radius:this.getRadius(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},e.prototype.setRadius=function(t){this.radius_=t,this.render_(this.atlasManager_)},e}(Ml),bl=function(t){var e=t||{};this.geometry_=null,this.geometryFunction_=Dl,void 0!==e.geometry&&this.setGeometry(e.geometry),this.fill_=void 0!==e.fill?e.fill:null,this.image_=void 0!==e.image?e.image:null,this.renderer_=void 0!==e.renderer?e.renderer:null,this.stroke_=void 0!==e.stroke?e.stroke:null,this.text_=void 0!==e.text?e.text:null,this.zIndex_=e.zIndex};bl.prototype.clone=function(){var t=this.getGeometry();return t&&"object"==typeof t&&(t=t.clone()),new bl({geometry:t,fill:this.getFill()?this.getFill().clone():void 0,image:this.getImage()?this.getImage().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,text:this.getText()?this.getText().clone():void 0,zIndex:this.getZIndex()})},bl.prototype.getRenderer=function(){return this.renderer_},bl.prototype.setRenderer=function(t){this.renderer_=t},bl.prototype.getGeometry=function(){return this.geometry_},bl.prototype.getGeometryFunction=function(){return this.geometryFunction_},bl.prototype.getFill=function(){return this.fill_},bl.prototype.setFill=function(t){this.fill_=t},bl.prototype.getImage=function(){return this.image_},bl.prototype.setImage=function(t){this.image_=t},bl.prototype.getStroke=function(){return this.stroke_},bl.prototype.setStroke=function(t){this.stroke_=t},bl.prototype.getText=function(){return this.text_},bl.prototype.setText=function(t){this.text_=t},bl.prototype.getZIndex=function(){return this.zIndex_},bl.prototype.setGeometry=function(t){"function"==typeof t?this.geometryFunction_=t:"string"==typeof t?this.geometryFunction_=function(e){return e.get(t)}:t?void 0!==t&&(this.geometryFunction_=function(){return t}):this.geometryFunction_=Dl,this.geometry_=t},bl.prototype.setZIndex=function(t){this.zIndex_=t};var Nl=null;function Al(t,e){if(!Nl){var i=new Tl({color:"rgba(255,255,255,0.4)"}),r=new Pl({color:"#3399CC",width:1.25});Nl=[new bl({image:new Fl({fill:i,stroke:r,radius:5}),fill:i,stroke:r})]}return Nl}function Gl(){var t={},e=[255,255,255,1],i=[0,153,255,1];return t[_i.POLYGON]=[new bl({fill:new Tl({color:[255,255,255,.5]})})],t[_i.MULTI_POLYGON]=t[_i.POLYGON],t[_i.LINE_STRING]=[new bl({stroke:new Pl({color:e,width:5})}),new bl({stroke:new Pl({color:i,width:3})})],t[_i.MULTI_LINE_STRING]=t[_i.LINE_STRING],t[_i.CIRCLE]=t[_i.POLYGON].concat(t[_i.LINE_STRING]),t[_i.POINT]=[new bl({image:new Fl({radius:6,fill:new Tl({color:i}),stroke:new Pl({color:e,width:1.5})}),zIndex:1/0})],t[_i.MULTI_POINT]=t[_i.POINT],t[_i.GEOMETRY_COLLECTION]=t[_i.POLYGON].concat(t[_i.LINE_STRING],t[_i.POINT]),t}function Dl(t){return t.getGeometry()}var kl=bl,Yl=function(t){var e=t||{};this.font_=e.font,this.rotation_=e.rotation,this.rotateWithView_=e.rotateWithView,this.scale_=e.scale,this.text_=e.text,this.textAlign_=e.textAlign,this.textBaseline_=e.textBaseline,this.fill_=void 0!==e.fill?e.fill:new Tl({color:"#333"}),this.maxAngle_=void 0!==e.maxAngle?e.maxAngle:Math.PI/4,this.placement_=void 0!==e.placement?e.placement:Ks,this.overflow_=!!e.overflow,this.stroke_=void 0!==e.stroke?e.stroke:null,this.offsetX_=void 0!==e.offsetX?e.offsetX:0,this.offsetY_=void 0!==e.offsetY?e.offsetY:0,this.backgroundFill_=e.backgroundFill?e.backgroundFill:null,this.backgroundStroke_=e.backgroundStroke?e.backgroundStroke:null,this.padding_=void 0===e.padding?null:e.padding};Yl.prototype.clone=function(){return new Yl({font:this.getFont(),placement:this.getPlacement(),maxAngle:this.getMaxAngle(),overflow:this.getOverflow(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),scale:this.getScale(),text:this.getText(),textAlign:this.getTextAlign(),textBaseline:this.getTextBaseline(),fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,offsetX:this.getOffsetX(),offsetY:this.getOffsetY(),backgroundFill:this.getBackgroundFill()?this.getBackgroundFill().clone():void 0,backgroundStroke:this.getBackgroundStroke()?this.getBackgroundStroke().clone():void 0})},Yl.prototype.getOverflow=function(){return this.overflow_},Yl.prototype.getFont=function(){return this.font_},Yl.prototype.getMaxAngle=function(){return this.maxAngle_},Yl.prototype.getPlacement=function(){return this.placement_},Yl.prototype.getOffsetX=function(){return this.offsetX_},Yl.prototype.getOffsetY=function(){return this.offsetY_},Yl.prototype.getFill=function(){return this.fill_},Yl.prototype.getRotateWithView=function(){return this.rotateWithView_},Yl.prototype.getRotation=function(){return this.rotation_},Yl.prototype.getScale=function(){return this.scale_},Yl.prototype.getStroke=function(){return this.stroke_},Yl.prototype.getText=function(){return this.text_},Yl.prototype.getTextAlign=function(){return this.textAlign_},Yl.prototype.getTextBaseline=function(){return this.textBaseline_},Yl.prototype.getBackgroundFill=function(){return this.backgroundFill_},Yl.prototype.getBackgroundStroke=function(){return this.backgroundStroke_},Yl.prototype.getPadding=function(){return this.padding_},Yl.prototype.setOverflow=function(t){this.overflow_=t},Yl.prototype.setFont=function(t){this.font_=t},Yl.prototype.setMaxAngle=function(t){this.maxAngle_=t},Yl.prototype.setOffsetX=function(t){this.offsetX_=t},Yl.prototype.setOffsetY=function(t){this.offsetY_=t},Yl.prototype.setPlacement=function(t){this.placement_=t},Yl.prototype.setFill=function(t){this.fill_=t},Yl.prototype.setRotation=function(t){this.rotation_=t},Yl.prototype.setScale=function(t){this.scale_=t},Yl.prototype.setStroke=function(t){this.stroke_=t},Yl.prototype.setText=function(t){this.text_=t},Yl.prototype.setTextAlign=function(t){this.textAlign_=t},Yl.prototype.setTextBaseline=function(t){this.textBaseline_=t},Yl.prototype.setBackgroundFill=function(t){this.backgroundFill_=t},Yl.prototype.setBackgroundStroke=function(t){this.backgroundStroke_=t},Yl.prototype.setPadding=function(t){this.padding_=t};var Ul,jl,Xl,Bl,Vl,Wl,Kl,zl=Yl,Zl=["http://www.google.com/kml/ext/2.2"],Hl=[null,"http://earth.google.com/kml/2.0","http://earth.google.com/kml/2.1","http://earth.google.com/kml/2.2","http://www.opengis.net/kml/2.2"],ql={fraction:Rl.FRACTION,pixels:Rl.PIXELS,insetPixels:Rl.PIXELS},Jl=ph(Hl,{ExtendedData:Vu,Region:Wu,MultiGeometry:oh(Au,"geometry"),LineString:oh(Fu,"geometry"),LinearRing:oh(bu,"geometry"),Point:oh(Gu,"geometry"),Polygon:oh(ku,"geometry"),Style:oh(Uu),StyleMap:function(t,e){var i=vu(t,e);if(!i)return;var r=e[e.length-1];Array.isArray(i)?r.Style=i:"string"==typeof i?r.styleUrl=i:te(!1,38)},address:oh(Oh),description:oh(Oh),name:oh(Oh),open:oh(Sh),phoneNumber:oh(Oh),styleUrl:oh(gu),visibility:oh(Sh)},ph(Zl,{MultiTrack:oh(function(t,e){var i=dh([],xu,t,e);if(!i)return;return new ba(i)},"geometry"),Track:oh(Iu,"geometry")})),Ql=ph(Hl,{ExtendedData:Vu,Region:Wu,Link:function(t,e){ch($l,t,e)},address:oh(Oh),description:oh(Oh),name:oh(Oh),open:oh(Sh),phoneNumber:oh(Oh),visibility:oh(Sh)}),$l=ph(Hl,{href:oh(gu)}),tu=ph(Hl,{LatLonAltBox:function(t,e){var i=dh({},Zu,t,e);if(!i)return;var r=e[e.length-1],n=[parseFloat(i.west),parseFloat(i.south),parseFloat(i.east),parseFloat(i.north)];r.extent=n,r.altitudeMode=i.altitudeMode,r.minAltitude=parseFloat(i.minAltitude),r.maxAltitude=parseFloat(i.maxAltitude)},Lod:function(t,e){var i=dh({},Hu,t,e);if(!i)return;var r=e[e.length-1];r.minLodPixels=parseFloat(i.minLodPixels),r.maxLodPixels=parseFloat(i.maxLodPixels),r.minFadeExtent=parseFloat(i.minFadeExtent),r.maxFadeExtent=parseFloat(i.maxFadeExtent)}}),eu=ph(Hl,["Document","Placemark"]),iu=ph(Hl,{Document:sh(function(t,e,i){gh({node:t},tp,ep,e,i,void 0,this)}),Placemark:sh(xp)}),ru=null;var nu,ou=null;var su,au=null;var hu=null;var lu=null;var uu=null;var pu=function(t){function e(e){t.call(this);var i=e||{};uu||(ru=new Tl({color:Ul=[255,255,255,1]}),jl=[20,2],Xl=Rl.PIXELS,Bl=Rl.PIXELS,Vl=[64,64],Wl="https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png",Kl=.5,ou=new Ol({anchor:jl,anchorOrigin:xl.BOTTOM_LEFT,anchorXUnits:Xl,anchorYUnits:Bl,crossOrigin:"anonymous",rotation:0,scale:Kl,size:Vl,src:Wl}),nu="NO_IMAGE",au=new Pl({color:Ul,width:1}),su=new Pl({color:[51,51,51,1],width:2}),hu=new zl({font:"bold 16px Helvetica",fill:ru,stroke:su,scale:.8}),lu=new kl({fill:ru,image:ou,text:hu,stroke:au,zIndex:0}),uu=[lu]),this.dataProjection=Zi("EPSG:4326"),this.defaultStyle_=i.defaultStyle?i.defaultStyle:uu,this.extractStyles_=void 0===i.extractStyles||i.extractStyles,this.writeStyles_=void 0===i.writeStyles||i.writeStyles,this.sharedStyles_={},this.showPointNames_=void 0===i.showPointNames||i.showPointNames}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readDocumentOrFolder_=function(t,e){var i=dh([],ph(Hl,{Document:eh(this.readDocumentOrFolder_,this),Folder:eh(this.readDocumentOrFolder_,this),Placemark:ih(this.readPlacemark_,this),Style:this.readSharedStyle_.bind(this),StyleMap:this.readSharedStyleMap_.bind(this)}),t,e,this);return i||void 0},e.prototype.readPlacemark_=function(t,e){var i=dh({geometry:null},Jl,t,e);if(i){var r=new Oa,n=t.getAttribute("id");null!==n&&r.setId(n);var o=e[0],s=i.geometry;if(s&&Ba(s,!1,o),r.setGeometry(s),delete i.geometry,this.extractStyles_){var a=function(t,e,i,r,n){return function(o,s){var a,h=n,l="";if(h){var u=o.getGeometry();u&&(h=u.getType()===_i.POINT)}if(h&&(l=o.get("name"),h=h&&!!l),t)return h?(a=cu(t[0],l),t.concat(a)):t;if(e){var p=function t(e,i,r){return Array.isArray(e)?e:"string"==typeof e?(!(e in r)&&"#"+e in r&&(e="#"+e),t(r[e],i,r)):i}(e,i,r);return h?(a=cu(p[0],l),p.concat(a)):p}return h?(a=cu(i[0],l),i.concat(a)):i}}(i.Style,i.styleUrl,this.defaultStyle_,this.sharedStyles_,this.showPointNames_);r.setStyle(a)}return delete i.Style,r.setProperties(i),r}},e.prototype.readSharedStyle_=function(t,e){var i=t.getAttribute("id");if(null!==i){var r=Uu(t,e);if(r){var n,o=t.baseURI;if(o&&"about:blank"!=o||(o=window.location.href),o)n=new URL("#"+i,o).href;else n="#"+i;this.sharedStyles_[n]=r}}},e.prototype.readSharedStyleMap_=function(t,e){var i=t.getAttribute("id");if(null!==i){var r=vu(t,e);if(r){var n,o=t.baseURI;if(o&&"about:blank"!=o||(o=window.location.href),o)n=new URL("#"+i,o).href;else n="#"+i;this.sharedStyles_[n]=r}}},e.prototype.readFeatureFromNode=function(t,e){if(!At(Hl,t.namespaceURI))return null;var i=this.readPlacemark_(t,[this.getReadOptions(t,e)]);return i||null},e.prototype.readFeaturesFromNode=function(t,e){if(!At(Hl,t.namespaceURI))return[];var i,r=t.localName;if("Document"==r||"Folder"==r)return(i=this.readDocumentOrFolder_(t,[this.getReadOptions(t,e)]))||[];if("Placemark"==r){var n=this.readPlacemark_(t,[this.getReadOptions(t,e)]);return n?[n]:[]}if("kml"==r){i=[];for(var o=t.firstElementChild;o;o=o.nextElementSibling){var s=this.readFeaturesFromNode(o,e);s&&kt(i,s)}return i}return[]},e.prototype.readName=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readNameFromDocument(e)}return $a(t)?this.readNameFromDocument(t):this.readNameFromNode(t)}},e.prototype.readNameFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE){var i=this.readNameFromNode(e);if(i)return i}},e.prototype.readNameFromNode=function(t){for(var e=t.firstElementChild;e;e=e.nextElementSibling)if(At(Hl,e.namespaceURI)&&"name"==e.localName)return Oh(e);for(var i=t.firstElementChild;i;i=i.nextElementSibling){var r=i.localName;if(At(Hl,i.namespaceURI)&&("Document"==r||"Folder"==r||"Placemark"==r||"kml"==r)){var n=this.readNameFromNode(i);if(n)return n}}},e.prototype.readNetworkLinks=function(t){var e=[];if("string"==typeof t){var i=th(t);kt(e,this.readNetworkLinksFromDocument(i))}else $a(t)?kt(e,this.readNetworkLinksFromDocument(t)):kt(e,this.readNetworkLinksFromNode(t));return e},e.prototype.readNetworkLinksFromDocument=function(t){for(var e=[],i=t.firstChild;i;i=i.nextSibling)i.nodeType==Node.ELEMENT_NODE&&kt(e,this.readNetworkLinksFromNode(i));return e},e.prototype.readNetworkLinksFromNode=function(t){for(var e=[],i=t.firstElementChild;i;i=i.nextElementSibling)if(At(Hl,i.namespaceURI)&&"NetworkLink"==i.localName){var r=dh({},Ql,i,[]);e.push(r)}for(var n=t.firstElementChild;n;n=n.nextElementSibling){var o=n.localName;!At(Hl,n.namespaceURI)||"Document"!=o&&"Folder"!=o&&"kml"!=o||kt(e,this.readNetworkLinksFromNode(n))}return e},e.prototype.readRegion=function(t){var e=[];if("string"==typeof t){var i=th(t);kt(e,this.readRegionFromDocument(i))}else $a(t)?kt(e,this.readRegionFromDocument(t)):kt(e,this.readRegionFromNode(t));return e},e.prototype.readRegionFromDocument=function(t){for(var e=[],i=t.firstChild;i;i=i.nextSibling)i.nodeType==Node.ELEMENT_NODE&&kt(e,this.readRegionFromNode(i));return e},e.prototype.readRegionFromNode=function(t){for(var e=[],i=t.firstElementChild;i;i=i.nextElementSibling)if(At(Hl,i.namespaceURI)&&"Region"==i.localName){var r=dh({},tu,i,[]);e.push(r)}for(var n=t.firstElementChild;n;n=n.nextElementSibling){var o=n.localName;!At(Hl,n.namespaceURI)||"Document"!=o&&"Folder"!=o&&"kml"!=o||kt(e,this.readRegionFromNode(n))}return e},e.prototype.writeFeaturesNode=function(t,e){e=this.adaptOptions(e);var i=Ja(Hl[4],"kml"),r="http://www.w3.org/2000/xmlns/";i.setAttributeNS(r,"xmlns:gx",Zl[0]),i.setAttributeNS(r,"xmlns:xsi",qa),i.setAttributeNS(qa,"xsi:schemaLocation","http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd");var n={node:i},o={};t.length>1?o.Document=t:1==t.length&&(o.Placemark=t[0]);var s=eu[i.namespaceURI],a=uh(o,s);return gh(n,iu,lh,a,[e],s,this),i},e}(_h);function cu(t,e){var i=null,r=[0,0],n="start";if(t.getImage()){var o=t.getImage().getImageSize();if(null===o&&(o=Vl),2==o.length){var s=t.getImage().getScale();r[0]=s*o[0]/2,r[1]=-s*o[1]/2,n="left"}}if(null!==t.getText()){var a=t.getText();(i=a.clone()).setFont(a.getFont()||hu.getFont()),i.setScale(a.getScale()||hu.getScale()),i.setFill(a.getFill()||hu.getFill()),i.setStroke(a.getStroke()||su)}else i=hu.clone();return i.setText(e),i.setOffsetX(r[0]),i.setOffsetY(r[1]),i.setTextAlign(n),new kl({text:i})}function du(t){var e=Qa(t,!1),i=/^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);if(i){var r=i[1];return[parseInt(r.substr(6,2),16),parseInt(r.substr(4,2),16),parseInt(r.substr(2,2),16),parseInt(r.substr(0,2),16)/255]}}function fu(t){for(var e,i=Qa(t,!1),r=[],n=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;e=n.exec(i);){var o=parseFloat(e[1]),s=parseFloat(e[2]),a=e[3]?parseFloat(e[3]):0;r.push(o,s,a),i=i.substr(e[0].length)}if(""===i)return r}function gu(t){var e=Qa(t,!1).trim(),i=t.baseURI;return i&&"about:blank"!=i||(i=window.location.href),i?new URL(e,i).href:e}function _u(t){return Ch(t)}var yu=ph(Hl,{Pair:function(t,e){var i=dh({},Ku,t,e);if(!i)return;var r=i.key;if(r&&"normal"==r){var n=i.styleUrl;n&&(e[e.length-1]=n);var o=i.Style;o&&(e[e.length-1]=o)}}});function vu(t,e){return dh(void 0,yu,t,e)}var mu=ph(Hl,{Icon:oh(function(t,e){var i=dh({},Ou,t,e);return i||null}),heading:oh(Ch),hotSpot:oh(function(t){var e,i=t.getAttribute("xunits"),r=t.getAttribute("yunits");return e="insetPixels"!==i?"insetPixels"!==r?xl.BOTTOM_LEFT:xl.TOP_LEFT:"insetPixels"!==r?xl.BOTTOM_RIGHT:xl.TOP_RIGHT,{x:parseFloat(t.getAttribute("x")),xunits:ql[i],y:parseFloat(t.getAttribute("y")),yunits:ql[r],origin:e}}),scale:oh(_u)});var Eu=ph(Hl,{color:oh(du),scale:oh(_u)});var Su=ph(Hl,{color:oh(du),width:oh(Ch)});var Tu=ph(Hl,{color:oh(du),fill:oh(Sh),outline:oh(Sh)});var Ru=ph(Hl,{coordinates:rh(fu)});function Cu(t,e){return dh(null,Ru,t,e)}var xu=ph(Zl,{Track:ih(Iu)});var wu=ph(Hl,{when:function(t,e){var i=e[e.length-1].whens,r=Qa(t,!1),n=Date.parse(r);i.push(isNaN(n)?0:n)}},ph(Zl,{coord:function(t,e){var i=e[e.length-1].flatCoordinates,r=Qa(t,!1),n=/^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);if(n){var o=parseFloat(n[1]),s=parseFloat(n[2]),a=parseFloat(n[3]);i.push(o,s,a,0)}else i.push(0,0,0,0)}}));function Iu(t,e){var i=dh({flatCoordinates:[],whens:[]},wu,t,e);if(i){for(var r=i.flatCoordinates,n=i.whens,o=0,s=Math.min(r.length,n.length);o<s;++o)r[4*o+3]=n[o];return new Fa(r,yi.XYZM)}}var Ou=ph(Hl,{href:oh(gu)},ph(Zl,{x:oh(Ch),y:oh(Ch),w:oh(Ch),h:oh(Ch)}));var Lu=ph(Hl,{coordinates:rh(fu)});function Pu(t,e){return dh(null,Lu,t,e)}var Mu=ph(Hl,{extrude:oh(Sh),tessellate:oh(Sh),altitudeMode:oh(Oh)});function Fu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new Fa(r,yi.XYZ);return n.setProperties(i),n}}function bu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new qr(r,yi.XYZ,[r.length]);return n.setProperties(i),n}}var Nu=ph(Hl,{LineString:ih(Fu),LinearRing:ih(bu),MultiGeometry:ih(Au),Point:ih(Gu),Polygon:ih(ku)});function Au(t,e){var i,r=dh([],Nu,t,e);if(!r)return null;if(0===r.length)return new ka(r);for(var n,o,s=!0,a=r[0].getType(),h=1,l=r.length;h<l;++h)if(r[h].getType()!=a){s=!1;break}if(s)if(a==_i.POINT){var u=r[0];n=u.getLayout(),o=u.getFlatCoordinates();for(var p=1,c=r.length;p<c;++p)kt(o,r[p].getFlatCoordinates());ju(i=new La(o,n),r)}else a==_i.LINE_STRING?ju(i=new ba(r),r):a==_i.POLYGON?ju(i=new Na(r),r):a==_i.GEOMETRY_COLLECTION?i=new ka(r):te(!1,37);else i=new ka(r);return i}function Gu(t,e){var i=dh({},Mu,t,e),r=Pu(t,e);if(r){var n=new Gr(r,yi.XYZ);return n.setProperties(i),n}}var Du=ph(Hl,{innerBoundaryIs:function(t,e){var i=dh(void 0,qu,t,e);if(i){var r=e[e.length-1];r.push(i)}},outerBoundaryIs:function(t,e){var i=dh(void 0,Ju,t,e);if(i){var r=e[e.length-1];r[0]=i}}});function ku(t,e){var i=dh({},Mu,t,e),r=dh([null],Du,t,e);if(r&&r[0]){for(var n=r[0],o=[n.length],s=1,a=r.length;s<a;++s)kt(n,r[s]),o.push(n.length);var h=new qr(n,yi.XYZ,o);return h.setProperties(i),h}}var Yu=ph(Hl,{IconStyle:function(t,e){var i=dh({},mu,t,e);if(i){var r,n,o,s,a=e[e.length-1],h="Icon"in i?i.Icon:{},l=!("Icon"in i)||Object.keys(h).length>0,u=h.href;u?r=u:l&&(r=Wl);var p,c=xl.BOTTOM_LEFT,d=i.hotSpot;d?(n=[d.x,d.y],o=d.xunits,s=d.yunits,c=d.origin):r===Wl?(n=jl,o=Xl,s=Bl):/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(r)&&(n=[.5,0],o=Rl.FRACTION,s=Rl.FRACTION);var f,g=h.x,_=h.y;void 0!==g&&void 0!==_&&(p=[g,_]);var y,v=h.w,m=h.h;void 0!==v&&void 0!==m&&(f=[v,m]);var E=i.heading;void 0!==E&&(y=le(E));var S=i.scale;if(l){r==Wl&&(f=Vl,void 0===S&&(S=Kl));var T=new Ol({anchor:n,anchorOrigin:c,anchorXUnits:o,anchorYUnits:s,crossOrigin:"anonymous",offset:p,offsetOrigin:xl.BOTTOM_LEFT,rotation:y,scale:S,size:f,src:r});a.imageStyle=T}else a.imageStyle=nu}},LabelStyle:function(t,e){var i=dh({},Eu,t,e);if(i){var r=e[e.length-1],n=new zl({fill:new Tl({color:"color"in i?i.color:Ul}),scale:i.scale});r.textStyle=n}},LineStyle:function(t,e){var i=dh({},Su,t,e);if(i){var r=e[e.length-1],n=new Pl({color:"color"in i?i.color:Ul,width:"width"in i?i.width:1});r.strokeStyle=n}},PolyStyle:function(t,e){var i=dh({},Tu,t,e);if(i){var r=e[e.length-1],n=new Tl({color:"color"in i?i.color:Ul});r.fillStyle=n;var o=i.fill;void 0!==o&&(r.fill=o);var s=i.outline;void 0!==s&&(r.outline=s)}}});function Uu(t,e){var i=dh({},Yu,t,e);if(!i)return null;var r,n="fillStyle"in i?i.fillStyle:ru,o=i.fill;void 0===o||o||(n=null),"imageStyle"in i?i.imageStyle!=nu&&(r=i.imageStyle):r=ou;var s="textStyle"in i?i.textStyle:hu,a="strokeStyle"in i?i.strokeStyle:au,h=i.outline;return void 0===h||h||(a=null),[new kl({fill:n,image:r,stroke:a,text:s,zIndex:void 0})]}function ju(t,e){var i,r,n,o=e.length,s=new Array(e.length),a=new Array(e.length),h=new Array(e.length);i=r=n=!1;for(var l=0;l<o;++l){var u=e[l];s[l]=u.get("extrude"),a[l]=u.get("tessellate"),h[l]=u.get("altitudeMode"),i=i||void 0!==s[l],r=r||void 0!==a[l],n=n||h[l]}i&&t.set("extrude",s),r&&t.set("tessellate",a),n&&t.set("altitudeMode",h)}var Xu=ph(Hl,{displayName:oh(Oh),value:oh(Oh)});var Bu=ph(Hl,{Data:function(t,e){var i=t.getAttribute("name");ch(Xu,t,e);var r=e[e.length-1];null!==i?r[i]=r.value:null!==r.displayName&&(r[r.displayName]=r.value),delete r.value},SchemaData:function(t,e){ch(zu,t,e)}});function Vu(t,e){ch(Bu,t,e)}function Wu(t,e){ch(tu,t,e)}var Ku=ph(Hl,{Style:oh(Uu),key:oh(Oh),styleUrl:oh(gu)});var zu=ph(Hl,{SimpleData:function(t,e){var i=t.getAttribute("name");if(null!==i){var r=Oh(t),n=e[e.length-1];n[i]=r}}});var Zu=ph(Hl,{altitudeMode:oh(Oh),minAltitude:oh(Ch),maxAltitude:oh(Ch),north:oh(Ch),south:oh(Ch),east:oh(Ch),west:oh(Ch)});var Hu=ph(Hl,{minLodPixels:oh(Ch),maxLodPixels:oh(Ch),minFadeExtent:oh(Ch),maxFadeExtent:oh(Ch)});var qu=ph(Hl,{LinearRing:rh(Cu)});var Ju=ph(Hl,{LinearRing:rh(Cu)});function Qu(t,e){for(var i=es(e),r=[255*(4==i.length?i[3]:1),i[2],i[1],i[0]],n=0;n<4;++n){var o=Math.floor(r[n]).toString(16);r[n]=1==o.length?"0"+o:o}bh(t,r.join(""))}var $u=ph(Hl,{Data:sh(function(t,e,i){t.setAttribute("name",e.name);var r={node:t},n=e.value;"object"==typeof n?(null!==n&&n.displayName&&gh(r,$u,lh,[n.displayName],i,["displayName"]),null!==n&&n.value&&gh(r,$u,lh,[n.value],i,["value"])):gh(r,$u,lh,[n],i,["value"])}),value:sh(function(t,e){bh(t,e)}),displayName:sh(function(t,e){Ph(t,e)})});var tp=ph(Hl,{Placemark:sh(xp)}),ep=function(t,e,i){return Ja(e[e.length-1].node.namespaceURI,"Placemark")};var ip=hh("Data");var rp=ph(Hl,["href"],ph(Zl,["x","y","w","h"])),np=ph(Hl,{href:sh(bh)},ph(Zl,{x:sh(Mh),y:sh(Mh),w:sh(Mh),h:sh(Mh)})),op=function(t,e,i){return Ja(Zl[0],"gx:"+i)};var sp=ph(Hl,["scale","heading","Icon","hotSpot"]),ap=ph(Hl,{Icon:sh(function(t,e,i){var r={node:t},n=i[i.length-1].node,o=rp[n.namespaceURI],s=uh(e,o);gh(r,np,lh,s,i,o),s=uh(e,o=rp[Zl[0]]),gh(r,np,op,s,i,o)}),heading:sh(Mh),hotSpot:sh(function(t,e){t.setAttribute("x",String(e.x)),t.setAttribute("y",String(e.y)),t.setAttribute("xunits",e.xunits),t.setAttribute("yunits",e.yunits)}),scale:sh(Ap)});var hp=ph(Hl,["color","scale"]),lp=ph(Hl,{color:sh(Qu),scale:sh(Ap)});var up=ph(Hl,["color","width"]),pp=ph(Hl,{color:sh(Qu),width:sh(Mh)});var cp={Point:"Point",LineString:"LineString",LinearRing:"LinearRing",Polygon:"Polygon",MultiPoint:"MultiGeometry",MultiLineString:"MultiGeometry",MultiPolygon:"MultiGeometry",GeometryCollection:"MultiGeometry"},dp=function(t,e,i){if(t)return Ja(e[e.length-1].node.namespaceURI,cp[t.getType()])},fp=hh("Point"),gp=hh("LineString"),_p=hh("LinearRing"),yp=hh("Polygon"),vp=ph(Hl,{LineString:sh(Op),Point:sh(Op),Polygon:sh(Fp),GeometryCollection:sh(mp)});function mp(t,e,i){var r,n,o={node:t},s=e.getType();s==_i.GEOMETRY_COLLECTION?(r=e.getGeometries(),n=dp):s==_i.MULTI_POINT?(r=e.getPoints(),n=fp):s==_i.MULTI_LINE_STRING?(r=e.getLineStrings(),n=gp):s==_i.MULTI_POLYGON?(r=e.getPolygons(),n=yp):te(!1,39),gh(o,vp,n,r,i)}var Ep=ph(Hl,{LinearRing:sh(Op)});function Sp(t,e,i){gh({node:t},Ep,_p,[e],i)}var Tp=ph(Hl,{ExtendedData:sh(function(t,e,i){for(var r={node:t},n=e.names,o=e.values,s=n.length,a=0;a<s;a++)gh(r,$u,ip,[{name:n[a],value:o[a]}],i)}),MultiGeometry:sh(mp),LineString:sh(Op),LinearRing:sh(Op),Point:sh(Op),Polygon:sh(Fp),Style:sh(function(t,e,i){var r={node:t},n={},o=e.getFill(),s=e.getStroke(),a=e.getImage(),h=e.getText();a&&"function"==typeof a.getSrc&&(n.IconStyle=a);h&&(n.LabelStyle=h);s&&(n.LineStyle=s);o&&(n.PolyStyle=o);var l=i[i.length-1].node,u=Gp[l.namespaceURI],p=uh(n,u);gh(r,Dp,lh,p,i,u)}),address:sh(bh),description:sh(bh),name:sh(bh),open:sh(Lh),phoneNumber:sh(bh),styleUrl:sh(bh),visibility:sh(Lh)}),Rp=ph(Hl,["name","open","visibility","address","phoneNumber","description","styleUrl","Style"]),Cp=hh("ExtendedData");function xp(t,e,i){var r={node:t};e.getId()&&t.setAttribute("id",e.getId());var n=e.getProperties(),o={address:1,description:1,name:1,open:1,phoneNumber:1,styleUrl:1,visibility:1};o[e.getGeometryName()]=1;var s=Object.keys(n||{}).sort().filter(function(t){return!o[t]});if(s.length>0){var a=uh(n,s);gh(r,Tp,Cp,[{names:s,values:a}],i)}var h=e.getStyleFunction();if(h){var l=h(e,0);if(l){var u=Array.isArray(l)?l[0]:l;this.writeStyles_&&(n.Style=u);var p=u.getText();p&&(n.name=p.getText())}}var c=i[i.length-1].node,d=Rp[c.namespaceURI],f=uh(n,d);gh(r,Tp,lh,f,i,d);var g=i[0],_=e.getGeometry();_&&(_=Ba(_,!0,g)),gh(r,Tp,dp,[_],i)}var wp=ph(Hl,["extrude","tessellate","altitudeMode","coordinates"]),Ip=ph(Hl,{extrude:sh(Lh),tessellate:sh(Lh),altitudeMode:sh(bh),coordinates:sh(function(t,e,i){var r,n=i[i.length-1],o=n.layout,s=n.stride;o==yi.XY||o==yi.XYM?r=2:o==yi.XYZ||o==yi.XYZM?r=3:te(!1,34);var a=e.length,h="";if(a>0){h+=e[0];for(var l=1;l<r;++l)h+=","+e[l];for(var u=s;u<a;u+=s){h+=" "+e[u];for(var p=1;p<r;++p)h+=","+e[u+p]}}bh(t,h)})});function Op(t,e,i){var r=e.getFlatCoordinates(),n={node:t};n.layout=e.getLayout(),n.stride=e.getStride();var o=e.getProperties();o.coordinates=r;var s=i[i.length-1].node,a=wp[s.namespaceURI],h=uh(o,a);gh(n,Ip,lh,h,i,a)}var Lp=ph(Hl,{outerBoundaryIs:sh(Sp),innerBoundaryIs:sh(Sp)}),Pp=hh("innerBoundaryIs"),Mp=hh("outerBoundaryIs");function Fp(t,e,i){var r=e.getLinearRings(),n=r.shift(),o={node:t};gh(o,Lp,Pp,r,i),gh(o,Lp,Mp,[n],i)}var bp=ph(Hl,{color:sh(Qu)}),Np=hh("color");function Ap(t,e){Mh(t,Math.round(1e6*e)/1e6)}var Gp=ph(Hl,["IconStyle","LabelStyle","LineStyle","PolyStyle"]),Dp=ph(Hl,{IconStyle:sh(function(t,e,i){var r={node:t},n={},o=e.getSrc(),s=e.getSize(),a=e.getImageSize(),h={href:o};if(s){h.w=s[0],h.h=s[1];var l=e.getAnchor(),u=e.getOrigin();if(u&&a&&0!==u[0]&&u[1]!==s[1]&&(h.x=u[0],h.y=a[1]-(u[1]+s[1])),l&&(l[0]!==s[0]/2||l[1]!==s[1]/2)){var p={x:l[0],xunits:Rl.PIXELS,y:s[1]-l[1],yunits:Rl.PIXELS};n.hotSpot=p}}n.Icon=h;var c=e.getScale();1!==c&&(n.scale=c);var d=e.getRotation();0!==d&&(n.heading=d);var f=i[i.length-1].node,g=sp[f.namespaceURI],_=uh(n,g);gh(r,ap,lh,_,i,g)}),LabelStyle:sh(function(t,e,i){var r={node:t},n={},o=e.getFill();o&&(n.color=o.getColor());var s=e.getScale();s&&1!==s&&(n.scale=s);var a=i[i.length-1].node,h=hp[a.namespaceURI],l=uh(n,h);gh(r,lp,lh,l,i,h)}),LineStyle:sh(function(t,e,i){var r={node:t},n={color:e.getColor(),width:e.getWidth()},o=i[i.length-1].node,s=up[o.namespaceURI],a=uh(n,s);gh(r,pp,lh,a,i,s)}),PolyStyle:sh(function(t,e,i){gh({node:t},bp,Np,[e.getColor()],i)})});var kp=pu,Yp=yh+" http://schemas.opengis.net/gml/2.1.2/feature.xsd",Up={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"},jp=function(t){function e(e){var i=e||{};t.call(this,i),this.FEATURE_COLLECTION_PARSERS[yh].featureMember=ih(this.readFeaturesInternal),this.schemaLocation=i.schemaLocation?i.schemaLocation:Yp}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFlatCoordinates_=function(t,e){var i=Qa(t,!1).replace(/^\s*|\s*$/g,""),r=e[0].srsName,n="enu";if(r){var o=Zi(r);o&&(n=o.getAxisOrientation())}for(var s=i.trim().split(/\s+/),a=[],h=0,l=s.length;h<l;h++){var u=s[h].split(/,+/),p=parseFloat(u[0]),c=parseFloat(u[1]),d=3===u.length?parseFloat(u[2]):0;"en"===n.substr(0,2)?a.push(p,c,d):a.push(c,p,d)}return a},e.prototype.readBox_=function(t,e){var i=dh([null],this.BOX_PARSERS_,t,e,this);return Ve(i[1][0],i[1][1],i[1][3],i[1][4])},e.prototype.innerBoundaryIsParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&e[e.length-1].push(i)},e.prototype.outerBoundaryIsParser_=function(t,e){var i=dh(void 0,this.RING_PARSERS,t,e,this);i&&(e[e.length-1][0]=i)},e.prototype.GEOMETRY_NODE_FACTORY_=function(t,e,i){var r,n=e[e.length-1],o=n.multiSurface,s=n.surface,a=n.multiCurve;return Array.isArray(t)?r="Envelope":"MultiPolygon"===(r=t.getType())&&!0===o?r="MultiSurface":"Polygon"===r&&!0===s?r="Surface":"MultiLineString"===r&&!0===a&&(r="MultiCurve"),Ja("http://www.opengis.net/gml",r)},e.prototype.writeFeatureElement=function(t,e,i){var r=e.getId();r&&t.setAttribute("fid",r);var n=i[i.length-1],o=n.featureNS,s=e.getGeometryName();n.serializers||(n.serializers={},n.serializers[o]={});var a=e.getProperties(),h=[],l=[];for(var p in a){var c=a[p];null!==c&&(h.push(p),l.push(c),p==s||"function"==typeof c.getSimplifiedGeometry?p in n.serializers[o]||(n.serializers[o][p]=sh(this.writeGeometryElement,this)):p in n.serializers[o]||(n.serializers[o][p]=sh(bh)))}var d=u({},n);d.node=t,gh(d,n.serializers,hh(void 0,o),l,i,h)},e.prototype.writeCurveOrLineString_=function(t,e,i){var r=i[i.length-1].srsName;if("LineStringSegment"!==t.nodeName&&r&&t.setAttribute("srsName",r),"LineString"===t.nodeName||"LineStringSegment"===t.nodeName){var n=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(n),this.writeCoordinates_(n,e,i)}else if("Curve"===t.nodeName){var o=Ja(t.namespaceURI,"segments");t.appendChild(o),this.writeCurveSegments_(o,e,i)}},e.prototype.writeLineStringOrCurveMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeCurveOrLineString_(r,e,i))},e.prototype.writeMultiCurveOrLineString_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.curve;o&&t.setAttribute("srsName",o);var a=e.getLineStrings();gh({node:t,hasZ:n,srsName:o,curve:s},this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeGeometryElement=function(t,e,i){var r,n=i[i.length-1],o=u({},n);o.node=t,r=Array.isArray(e)?n.dataProjection?rr(e,n.featureProjection,n.dataProjection):e:Ba(e,!0,n),gh(o,this.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[r],i,void 0,this)},e.prototype.createCoordinatesNode_=function(t){var e=Ja(t,"coordinates");return e.setAttribute("decimal","."),e.setAttribute("cs",","),e.setAttribute("ts"," "),e},e.prototype.writeCoordinates_=function(t,e,i){for(var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=e.getCoordinates(),a=s.length,h=new Array(a),l=0;l<a;++l){var u=s[l];h[l]=this.getCoords_(u,o,n)}bh(t,h.join(" "))},e.prototype.writeCurveSegments_=function(t,e,i){var r=Ja(t.namespaceURI,"LineStringSegment");t.appendChild(r),this.writeCurveOrLineString_(r,e,i)},e.prototype.writeSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;if("PolygonPatch"!==t.nodeName&&o&&t.setAttribute("srsName",o),"Polygon"===t.nodeName||"PolygonPatch"===t.nodeName){var s=e.getLinearRings();gh({node:t,hasZ:n,srsName:o},this.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,s,i,void 0,this)}else if("Surface"===t.nodeName){var a=Ja(t.namespaceURI,"patches");t.appendChild(a),this.writeSurfacePatches_(a,e,i)}},e.prototype.RING_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1],n=r.node,o=r.exteriorWritten;return void 0===o&&(r.exteriorWritten=!0),Ja(n.namespaceURI,void 0!==o?"innerBoundaryIs":"outerBoundaryIs")},e.prototype.writeSurfacePatches_=function(t,e,i){var r=Ja(t.namespaceURI,"PolygonPatch");t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i)},e.prototype.writeRing_=function(t,e,i){var r=Ja(t.namespaceURI,"LinearRing");t.appendChild(r),this.writeLinearRing_(r,e,i)},e.prototype.getCoords_=function(t,e,i){var r="enu";e&&(r=Zi(e).getAxisOrientation());var n="en"===r.substr(0,2)?t[0]+","+t[1]:t[1]+","+t[0];i&&(n+=","+(t[2]||0));return n},e.prototype.writePoint_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;o&&t.setAttribute("srsName",o);var s=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(s);var a=e.getCoordinates();bh(s,this.getCoords_(a,o,n))},e.prototype.writeMultiPoint_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName;o&&t.setAttribute("srsName",o);var s=e.getPoints();gh({node:t,hasZ:n,srsName:o},this.POINTMEMBER_SERIALIZERS_,hh("pointMember"),s,i,void 0,this)},e.prototype.writePointMember_=function(t,e,i){var r=Ja(t.namespaceURI,"Point");t.appendChild(r),this.writePoint_(r,e,i)},e.prototype.writeLinearRing_=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=this.createCoordinatesNode_(t.namespaceURI);t.appendChild(n),this.writeCoordinates_(n,e,i)},e.prototype.writeMultiSurfaceOrPolygon_=function(t,e,i){var r=i[i.length-1],n=r.hasZ,o=r.srsName,s=r.surface;o&&t.setAttribute("srsName",o);var a=e.getPolygons();gh({node:t,hasZ:n,srsName:o,surface:s},this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,a,i,void 0,this)},e.prototype.writeSurfaceOrPolygonMember_=function(t,e,i){var r=this.GEOMETRY_NODE_FACTORY_(e,i);r&&(t.appendChild(r),this.writeSurfaceOrPolygon_(r,e,i))},e.prototype.writeEnvelope=function(t,e,i){var r=i[i.length-1].srsName;r&&t.setAttribute("srsName",r);var n=[e[0]+" "+e[1],e[2]+" "+e[3]];gh({node:t},this.ENVELOPE_SERIALIZERS_,lh,n,i,["lowerCorner","upperCorner"],this)},e.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(t,e,i){var r=e[e.length-1].node;return Ja("http://www.opengis.net/gml",Up[r.nodeName])},e}(Eh);jp.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml":{coordinates:rh(jp.prototype.readFlatCoordinates_)}},jp.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml":{innerBoundaryIs:jp.prototype.innerBoundaryIsParser_,outerBoundaryIs:jp.prototype.outerBoundaryIsParser_}},jp.prototype.BOX_PARSERS_={"http://www.opengis.net/gml":{coordinates:ih(jp.prototype.readFlatCoordinates_)}},jp.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml":{Point:rh(Eh.prototype.readPoint),MultiPoint:rh(Eh.prototype.readMultiPoint),LineString:rh(Eh.prototype.readLineString),MultiLineString:rh(Eh.prototype.readMultiLineString),LinearRing:rh(Eh.prototype.readLinearRing),Polygon:rh(Eh.prototype.readPolygon),MultiPolygon:rh(Eh.prototype.readMultiPolygon),Box:rh(jp.prototype.readBox_)}},jp.prototype.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:sh(jp.prototype.writeCurveOrLineString_),MultiCurve:sh(jp.prototype.writeMultiCurveOrLineString_),Point:sh(jp.prototype.writePoint_),MultiPoint:sh(jp.prototype.writeMultiPoint_),LineString:sh(jp.prototype.writeCurveOrLineString_),MultiLineString:sh(jp.prototype.writeMultiCurveOrLineString_),LinearRing:sh(jp.prototype.writeLinearRing_),Polygon:sh(jp.prototype.writeSurfaceOrPolygon_),MultiPolygon:sh(jp.prototype.writeMultiSurfaceOrPolygon_),Surface:sh(jp.prototype.writeSurfaceOrPolygon_),MultiSurface:sh(jp.prototype.writeMultiSurfaceOrPolygon_),Envelope:sh(jp.prototype.writeEnvelope)}},jp.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:sh(jp.prototype.writeLineStringOrCurveMember_),curveMember:sh(jp.prototype.writeLineStringOrCurveMember_)}},jp.prototype.RING_SERIALIZERS_={"http://www.opengis.net/gml":{outerBoundaryIs:sh(jp.prototype.writeRing_),innerBoundaryIs:sh(jp.prototype.writeRing_)}},jp.prototype.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:sh(jp.prototype.writePointMember_)}},jp.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:sh(jp.prototype.writeSurfaceOrPolygonMember_),polygonMember:sh(jp.prototype.writeSurfaceOrPolygonMember_)}},jp.prototype.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:sh(bh),upperCorner:sh(bh)}};var Xp=jp,Bp=function(t){this.tagName_=t};Bp.prototype.getTagName=function(){return this.tagName_};var Vp=Bp,Wp=function(t){function e(e,i){t.call(this,e),this.conditions=i,te(this.conditions.length>=2,57)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Vp),Kp=function(t){function e(e){t.call(this,"And",Array.prototype.slice.call(arguments))}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Wp),zp=function(t){function e(e,i,r){t.call(this,"BBOX"),this.geometryName=e,this.extent=i,this.srsName=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Vp);var Zp={"http://www.opengis.net/gml":{boundedBy:oh(Eh.prototype.readGeometryElement,"bounds")}},Hp={"http://www.opengis.net/wfs":{totalInserted:oh(wh),totalUpdated:oh(wh),totalDeleted:oh(wh)}},qp={"http://www.opengis.net/wfs":{TransactionSummary:oh(function(t,e){return dh({},Hp,t,e)},"transactionSummary"),InsertResults:oh(function(t,e){return dh([],hc,t,e)},"insertIds")}},Jp={"http://www.opengis.net/wfs":{PropertyName:sh(bh)}},Qp={"http://www.opengis.net/wfs":{Insert:sh(function(t,e,i){var r=i[i.length-1],n=r.featureType,o=r.featureNS,s=r.gmlVersion,a=Ja(o,n);t.appendChild(a),2===s?Xp.prototype.writeFeatureElement(a,e,i):Dh.prototype.writeFeatureElement(a,e,i)}),Update:sh(function(t,e,i){var r=i[i.length-1];te(void 0!==e.getId(),27);var n=r.featureType,o=r.featurePrefix,s=r.featureNS,a=uc(o,n),h=e.getGeometryName();t.setAttribute("typeName",a),t.setAttributeNS(tc,"xmlns:"+o,s);var l=e.getId();if(void 0!==l){for(var u=e.getKeys(),p=[],c=0,d=u.length;c<d;c++){var f=e.get(u[c]);if(void 0!==f){var g=u[c];f&&"function"==typeof f.getSimplifiedGeometry&&(g=h),p.push({name:g,value:f})}}gh({gmlVersion:r.gmlVersion,node:t,hasZ:r.hasZ,srsName:r.srsName},Qp,hh("Property"),p,i),lc(t,l,i)}}),Delete:sh(function(t,e,i){var r=i[i.length-1];te(void 0!==e.getId(),26);var n=r.featureType,o=r.featurePrefix,s=r.featureNS,a=uc(o,n);t.setAttribute("typeName",a),t.setAttributeNS(tc,"xmlns:"+o,s);var h=e.getId();void 0!==h&&lc(t,h,i)}),Property:sh(function(t,e,i){var r=Ja(ic,"Name"),n=i[i.length-1].gmlVersion;if(t.appendChild(r),bh(r,e.name),void 0!==e.value&&null!==e.value){var o=Ja(ic,"Value");t.appendChild(o),e.value&&"function"==typeof e.value.getSimplifiedGeometry?2===n?Xp.prototype.writeGeometryElement(o,e.value,i):Dh.prototype.writeGeometryElement(o,e.value,i):bh(o,e.value)}}),Native:sh(function(t,e,i){e.vendorId&&t.setAttribute("vendorId",e.vendorId);void 0!==e.safeToIgnore&&t.setAttribute("safeToIgnore",String(e.safeToIgnore));void 0!==e.value&&bh(t,e.value)})}},$p="feature",tc="http://www.w3.org/2000/xmlns/",ec="http://www.opengis.net/ogc",ic="http://www.opengis.net/wfs",rc="http://www.opengis.net/fes",nc={"1.1.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd","1.0.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"},oc="1.1.0",sc=function(t){function e(e){t.call(this);var i=e||{};this.featureType_=i.featureType,this.featureNS_=i.featureNS,this.gmlFormat_=i.gmlFormat?i.gmlFormat:new Dh,this.schemaLocation_=i.schemaLocation?i.schemaLocation:nc[oc]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getFeatureType=function(){return this.featureType_},e.prototype.setFeatureType=function(t){this.featureType_=t},e.prototype.readFeaturesFromNode=function(t,e){var i={node:t};u(i,{featureType:this.featureType_,featureNS:this.featureNS_}),u(i,this.getReadOptions(t,e||{}));var r=[i];this.gmlFormat_.FEATURE_COLLECTION_PARSERS[yh].featureMember=ih(Eh.prototype.readFeaturesInternal);var n=dh([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,t,r,this.gmlFormat_);return n||(n=[]),n},e.prototype.readTransactionResponse=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readTransactionResponseFromDocument(e)}return $a(t)?this.readTransactionResponseFromDocument(t):this.readTransactionResponseFromNode(t)}},e.prototype.readFeatureCollectionMetadata=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readFeatureCollectionMetadataFromDocument(e)}return $a(t)?this.readFeatureCollectionMetadataFromDocument(t):this.readFeatureCollectionMetadataFromNode(t)}},e.prototype.readFeatureCollectionMetadataFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFeatureCollectionMetadataFromNode(e)},e.prototype.readFeatureCollectionMetadataFromNode=function(t){var e={},i=Ih(t.getAttribute("numberOfFeatures"));return e.numberOfFeatures=i,dh(e,Zp,t,[],this.gmlFormat_)},e.prototype.readTransactionResponseFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readTransactionResponseFromNode(e)},e.prototype.readTransactionResponseFromNode=function(t){return dh({},qp,t,[])},e.prototype.writeGetFeature=function(t){var e,i,r,n,o=Ja(ic,"GetFeature");if(o.setAttribute("service","WFS"),o.setAttribute("version","1.1.0"),t&&(t.handle&&o.setAttribute("handle",t.handle),t.outputFormat&&o.setAttribute("outputFormat",t.outputFormat),void 0!==t.maxFeatures&&o.setAttribute("maxFeatures",String(t.maxFeatures)),t.resultType&&o.setAttribute("resultType",t.resultType),void 0!==t.startIndex&&o.setAttribute("startIndex",String(t.startIndex)),void 0!==t.count&&o.setAttribute("count",String(t.count)),void 0!==t.viewParams&&o.setAttribute("viewParams ",t.viewParams),e=t.filter,t.bbox)){te(t.geometryName,12);var s=(i=t.geometryName,r=t.bbox,n=t.srsName,new zp(i,r,n));e=e?function(t){var e=[null].concat(Array.prototype.slice.call(arguments));return new(Function.prototype.bind.apply(Kp,e))}(e,s):s}o.setAttributeNS(qa,"xsi:schemaLocation",this.schemaLocation_);var a={node:o};return u(a,{srsName:t.srsName,featureNS:t.featureNS?t.featureNS:this.featureNS_,featurePrefix:t.featurePrefix,geometryName:t.geometryName,filter:e,propertyNames:t.propertyNames?t.propertyNames:[]}),te(Array.isArray(t.featureTypes),11),function(t,e,i){var r=i[i.length-1],n=u({},r);n.node=t,gh(n,pc,hh("Query"),e,i)}(o,t.featureTypes,[a]),o},e.prototype.writeTransaction=function(t,e,i,r){var n,o,s=[],a=Ja(ic,"Transaction"),h=r.version?r.version:oc,l="1.0.0"===h?2:3;a.setAttribute("service","WFS"),a.setAttribute("version",h),r&&(n=r.gmlOptions?r.gmlOptions:{},r.handle&&a.setAttribute("handle",r.handle));var p=nc[h];a.setAttributeNS(qa,"xsi:schemaLocation",p);var c=r.featurePrefix?r.featurePrefix:$p;return t&&(o=u({node:a},{featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,hasZ:r.hasZ,srsName:r.srsName}),u(o,n),gh(o,Qp,hh("Insert"),t,s)),e&&(o=u({node:a},{featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,hasZ:r.hasZ,srsName:r.srsName}),u(o,n),gh(o,Qp,hh("Update"),e,s)),i&&gh({node:a,featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,srsName:r.srsName},Qp,hh("Delete"),i,s),r.nativeElements&&gh({node:a,featureNS:r.featureNS,featureType:r.featureType,featurePrefix:c,gmlVersion:l,srsName:r.srsName},Qp,hh("Native"),r.nativeElements,s),a},e.prototype.readProjectionFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readProjectionFromNode(e);return null},e.prototype.readProjectionFromNode=function(t){if(t.firstElementChild&&t.firstElementChild.firstElementChild)for(var e=(t=t.firstElementChild.firstElementChild).firstElementChild;e;e=e.nextElementSibling)if(0!==e.childNodes.length&&(1!==e.childNodes.length||3!==e.firstChild.nodeType)){var i=[{}];return this.gmlFormat_.readGeometryElement(e,i),Zi(i.pop().srsName)}return null},e}(_h);var ac={"http://www.opengis.net/ogc":{FeatureId:ih(function(t,e){return t.getAttribute("fid")})}};var hc={"http://www.opengis.net/wfs":{Feature:function(t,e){ch(ac,t,e)}}};function lc(t,e,i){var r=Ja(ec,"Filter"),n=Ja(ec,"FeatureId");r.appendChild(n),n.setAttribute("fid",e),t.appendChild(r)}function uc(t,e){var i=(t=t||$p)+":";return 0===e.indexOf(i)?e:i+e}var pc={"http://www.opengis.net/wfs":{Query:sh(function(t,e,i){var r,n=i[i.length-1],o=n.featurePrefix,s=n.featureNS,a=n.propertyNames,h=n.srsName;r=o?uc(o,e):e;t.setAttribute("typeName",r),h&&t.setAttribute("srsName",h);s&&t.setAttributeNS(tc,"xmlns:"+o,s);var l=u({},n);l.node=t,gh(l,Jp,hh("PropertyName"),a,i);var p=n.filter;if(p){var c=Ja(ec,"Filter");t.appendChild(c),cc(c,p,i)}})},"http://www.opengis.net/ogc":{During:sh(function(t,e,i){var r=Ja(rc,"ValueReference");bh(r,e.propertyName),t.appendChild(r);var n=Ja(yh,"TimePeriod");t.appendChild(n);var o=Ja(yh,"begin");n.appendChild(o),vc(o,e.begin);var s=Ja(yh,"end");n.appendChild(s),vc(s,e.end)}),And:sh(dc),Or:sh(dc),Not:sh(function(t,e,i){var r={node:t},n=e.condition;gh(r,pc,hh(n.getTagName()),[n],i)}),BBOX:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.extent,i)}),Contains:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),Intersects:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),Within:sh(function(t,e,i){i[i.length-1].srsName=e.srsName,_c(t,e.geometryName),Dh.prototype.writeGeometryElement(t,e.geometry,i)}),PropertyIsEqualTo:sh(fc),PropertyIsNotEqualTo:sh(fc),PropertyIsLessThan:sh(fc),PropertyIsLessThanOrEqualTo:sh(fc),PropertyIsGreaterThan:sh(fc),PropertyIsGreaterThanOrEqualTo:sh(fc),PropertyIsNull:sh(function(t,e,i){_c(t,e.propertyName)}),PropertyIsBetween:sh(function(t,e,i){_c(t,e.propertyName);var r=Ja(ec,"LowerBoundary");t.appendChild(r),yc(r,""+e.lowerBoundary);var n=Ja(ec,"UpperBoundary");t.appendChild(n),yc(n,""+e.upperBoundary)}),PropertyIsLike:sh(function(t,e,i){t.setAttribute("wildCard",e.wildCard),t.setAttribute("singleChar",e.singleChar),t.setAttribute("escapeChar",e.escapeChar),void 0!==e.matchCase&&t.setAttribute("matchCase",e.matchCase.toString());_c(t,e.propertyName),yc(t,""+e.pattern)})}};function cc(t,e,i){gh({node:t},pc,hh(e.getTagName()),[e],i)}function dc(t,e,i){for(var r={node:t},n=e.conditions,o=0,s=n.length;o<s;++o){var a=n[o];gh(r,pc,hh(a.getTagName()),[a],i)}}function fc(t,e,i){void 0!==e.matchCase&&t.setAttribute("matchCase",e.matchCase.toString()),_c(t,e.propertyName),yc(t,""+e.expression)}function gc(t,e,i){var r=Ja(ec,t);bh(r,i),e.appendChild(r)}function _c(t,e){gc("PropertyName",t,e)}function yc(t,e){gc("Literal",t,e)}function vc(t,e){var i=Ja(yh,"TimeInstant");t.appendChild(i);var r=Ja(yh,"timePosition");i.appendChild(r),bh(r,e)}var mc=sc;function Ec(t){return"string"==typeof t?t:""}var Sc=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getType=function(){return Ya.TEXT},e.prototype.readFeature=function(t,e){return this.readFeatureFromText(Ec(t),this.adaptOptions(e))},e.prototype.readFeatureFromText=function(t,e){return r()},e.prototype.readFeatures=function(t,e){return this.readFeaturesFromText(Ec(t),this.adaptOptions(e))},e.prototype.readFeaturesFromText=function(t,e){return r()},e.prototype.readGeometry=function(t,e){return this.readGeometryFromText(Ec(t),this.adaptOptions(e))},e.prototype.readGeometryFromText=function(t,e){return r()},e.prototype.readProjection=function(t){return this.readProjectionFromText(Ec(t))},e.prototype.readProjectionFromText=function(t){return this.dataProjection},e.prototype.writeFeature=function(t,e){return this.writeFeatureText(t,this.adaptOptions(e))},e.prototype.writeFeatureText=function(t,e){return r()},e.prototype.writeFeatures=function(t,e){return this.writeFeaturesText(t,this.adaptOptions(e))},e.prototype.writeFeaturesText=function(t,e){return r()},e.prototype.writeGeometry=function(t,e){return this.writeGeometryText(t,this.adaptOptions(e))},e.prototype.writeGeometryText=function(t,e){return r()},e}(Xa),Tc={POINT:Gr,LINESTRING:Fa,POLYGON:qr,MULTIPOINT:La,MULTILINESTRING:ba,MULTIPOLYGON:Na},Rc="EMPTY",Cc="Z",xc="M",wc=1,Ic=2,Oc=3,Lc=4,Pc=5,Mc=6,Fc={};for(var bc in _i)Fc[bc]=_i[bc].toUpperCase();var Nc=function(t){this.wkt=t,this.index_=-1};Nc.prototype.isAlpha_=function(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"},Nc.prototype.isNumeric_=function(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)},Nc.prototype.isWhiteSpace_=function(t){return" "==t||"\t"==t||"\r"==t||"\n"==t},Nc.prototype.nextChar_=function(){return this.wkt.charAt(++this.index_)},Nc.prototype.nextToken=function(){var t,e=this.nextChar_(),i=this.index_,r=e;if("("==e)t=Ic;else if(","==e)t=Pc;else if(")"==e)t=Oc;else if(this.isNumeric_(e)||"-"==e)t=Lc,r=this.readNumber_();else if(this.isAlpha_(e))t=wc,r=this.readText_();else{if(this.isWhiteSpace_(e))return this.nextToken();if(""!==e)throw new Error("Unexpected character: "+e);t=Mc}return{position:i,value:r,type:t}},Nc.prototype.readNumber_=function(){var t,e=this.index_,i=!1,r=!1;do{"."==t?i=!0:"e"!=t&&"E"!=t||(r=!0),t=this.nextChar_()}while(this.isNumeric_(t,i)||!r&&("e"==t||"E"==t)||r&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))},Nc.prototype.readText_=function(){var t,e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()};var Ac=function(t){this.lexer_=t,this.token_,this.layout_=yi.XY};function Gc(t){var e=t.getCoordinates();return 0===e.length?"":e.join(" ")}function Dc(t){for(var e=t.getCoordinates(),i=[],r=0,n=e.length;r<n;++r)i.push(e[r].join(" "));return i.join(",")}function kc(t){for(var e=[],i=t.getLinearRings(),r=0,n=i.length;r<n;++r)e.push("("+Dc(i[r])+")");return e.join(",")}Ac.prototype.consume_=function(){this.token_=this.lexer_.nextToken()},Ac.prototype.isTokenType=function(t){return this.token_.type==t},Ac.prototype.match=function(t){var e=this.isTokenType(t);return e&&this.consume_(),e},Ac.prototype.parse=function(){return this.consume_(),this.parseGeometry_()},Ac.prototype.parseGeometryLayout_=function(){var t=yi.XY,e=this.token_;if(this.isTokenType(wc)){var i=e.value;i===Cc?t=yi.XYZ:i===xc?t=yi.XYM:"ZM"===i&&(t=yi.XYZM),t!==yi.XY&&this.consume_()}return t},Ac.prototype.parseGeometryCollectionText_=function(){if(this.match(Ic)){var t=[];do{t.push(this.parseGeometry_())}while(this.match(Pc));if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePointText_=function(){if(this.match(Ic)){var t=this.parsePoint_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())},Ac.prototype.parseLineStringText_=function(){if(this.match(Ic)){var t=this.parsePointList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePolygonText_=function(){if(this.match(Ic)){var t=this.parseLineStringTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiPointText_=function(){var t;if(this.match(Ic)){if(t=this.token_.type==Ic?this.parsePointTextList_():this.parsePointList_(),this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiLineStringText_=function(){if(this.match(Ic)){var t=this.parseLineStringTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parseMultiPolygonText_=function(){if(this.match(Ic)){var t=this.parsePolygonTextList_();if(this.match(Oc))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePoint_=function(){for(var t=[],e=this.layout_.length,i=0;i<e;++i){var r=this.token_;if(!this.match(Lc))break;t.push(r.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())},Ac.prototype.parsePointList_=function(){for(var t=[this.parsePoint_()];this.match(Pc);)t.push(this.parsePoint_());return t},Ac.prototype.parsePointTextList_=function(){for(var t=[this.parsePointText_()];this.match(Pc);)t.push(this.parsePointText_());return t},Ac.prototype.parseLineStringTextList_=function(){for(var t=[this.parseLineStringText_()];this.match(Pc);)t.push(this.parseLineStringText_());return t},Ac.prototype.parsePolygonTextList_=function(){for(var t=[this.parsePolygonText_()];this.match(Pc);)t.push(this.parsePolygonText_());return t},Ac.prototype.isEmptyGeometry_=function(){var t=this.isTokenType(wc)&&this.token_.value==Rc;return t&&this.consume_(),t},Ac.prototype.formatErrorMessage_=function(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"},Ac.prototype.parseGeometry_=function(){var t=this.token_;if(this.match(wc)){var e=t.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==e){var i=this.parseGeometryCollectionText_();return new ka(i)}var r,n=Tc[e];if(!n)throw new Error("Invalid geometry type: "+e);switch(e){case"POINT":r=this.parsePointText_();break;case"LINESTRING":r=this.parseLineStringText_();break;case"POLYGON":r=this.parsePolygonText_();break;case"MULTIPOINT":r=this.parseMultiPointText_();break;case"MULTILINESTRING":r=this.parseMultiLineStringText_();break;case"MULTIPOLYGON":r=this.parseMultiPolygonText_();break;default:throw new Error("Invalid geometry type: "+e)}return r||(r=n===Tc.POINT?[NaN,NaN]:[]),new n(r,this.layout_)}throw new Error(this.formatErrorMessage_())};var Yc={Point:Gc,LineString:Dc,Polygon:kc,MultiPoint:function(t){for(var e=[],i=t.getPoints(),r=0,n=i.length;r<n;++r)e.push("("+Gc(i[r])+")");return e.join(",")},MultiLineString:function(t){for(var e=[],i=t.getLineStrings(),r=0,n=i.length;r<n;++r)e.push("("+Dc(i[r])+")");return e.join(",")},MultiPolygon:function(t){for(var e=[],i=t.getPolygons(),r=0,n=i.length;r<n;++r)e.push("("+kc(i[r])+")");return e.join(",")},GeometryCollection:function(t){for(var e=[],i=t.getGeometries(),r=0,n=i.length;r<n;++r)e.push(Uc(i[r]));return e.join(",")}};function Uc(t){var e=t.getType(),i=(0,Yc[e])(t);if(e=e.toUpperCase(),"function"==typeof t.getFlatCoordinates){var r=function(t){var e=t.getLayout(),i="";return e!==yi.XYZ&&e!==yi.XYZM||(i+=Cc),e!==yi.XYM&&e!==yi.XYZM||(i+=xc),i}(t);r.length>0&&(e+=" "+r)}return 0===i.length?e+" "+Rc:e+"("+i+")"}var jc=function(t){function e(e){t.call(this);var i=e||{};this.splitCollection_=void 0!==i.splitCollection&&i.splitCollection}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.parse_=function(t){var e=new Nc(t);return new Ac(e).parse()},e.prototype.readFeatureFromText=function(t,e){var i=this.readGeometryFromText(t,e);if(i){var r=new Oa;return r.setGeometry(i),r}return null},e.prototype.readFeaturesFromText=function(t,e){for(var i=[],r=this.readGeometryFromText(t,e),n=[],o=0,s=(i=this.splitCollection_&&r.getType()==_i.GEOMETRY_COLLECTION?r.getGeometriesArray():[r]).length;o<s;++o){var a=new Oa;a.setGeometry(i[o]),n.push(a)}return n},e.prototype.readGeometryFromText=function(t,e){var i=this.parse_(t);return i?Ba(i,!1,e):null},e.prototype.writeFeatureText=function(t,e){var i=t.getGeometry();return i?this.writeGeometryText(i,e):""},e.prototype.writeFeaturesText=function(t,e){if(1==t.length)return this.writeFeatureText(t[0],e);for(var i=[],r=0,n=t.length;r<n;++r)i.push(t[r].getGeometry());var o=new ka(i);return this.writeGeometryText(o,e)},e.prototype.writeGeometryText=function(t,e){return Uc(Ba(t,!0,e))},e}(Sc),Xc="http://www.w3.org/1999/xlink";function Bc(t){return t.getAttributeNS(Xc,"href")}var Vc=function(){};Vc.prototype.read=function(t){if(t){if("string"==typeof t){var e=th(t);return this.readFromDocument(e)}return $a(t)?this.readFromDocument(t):this.readFromNode(t)}return null},Vc.prototype.readFromDocument=function(t){},Vc.prototype.readFromNode=function(t){};var Wc=Vc,Kc=[null,"http://www.opengis.net/wms"],zc=ph(Kc,{Service:oh(function(t,e){return dh({},qc,t,e)}),Capability:oh(function(t,e){return dh({},Zc,t,e)})}),Zc=ph(Kc,{Request:oh(function(t,e){return dh({},nd,t,e)}),Exception:oh(function(t,e){return dh([],td,t,e)}),Layer:oh(function(t,e){return dh({},ed,t,e)})}),Hc=function(t){function e(){t.call(this),this.version=void 0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){this.version=t.getAttribute("version").trim();var e=dh({version:this.version},zc,t,[]);return e||null},e}(Wc),qc=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),KeywordList:oh(fd),OnlineResource:oh(Bc),ContactInformation:oh(function(t,e){return dh({},Jc,t,e)}),Fees:oh(Oh),AccessConstraints:oh(Oh),LayerLimit:oh(wh),MaxWidth:oh(wh),MaxHeight:oh(wh)}),Jc=ph(Kc,{ContactPersonPrimary:oh(function(t,e){return dh({},Qc,t,e)}),ContactPosition:oh(Oh),ContactAddress:oh(function(t,e){return dh({},$c,t,e)}),ContactVoiceTelephone:oh(Oh),ContactFacsimileTelephone:oh(Oh),ContactElectronicMailAddress:oh(Oh)}),Qc=ph(Kc,{ContactPerson:oh(Oh),ContactOrganization:oh(Oh)}),$c=ph(Kc,{AddressType:oh(Oh),Address:oh(Oh),City:oh(Oh),StateOrProvince:oh(Oh),PostCode:oh(Oh),Country:oh(Oh)}),td=ph(Kc,{Format:ih(Oh)}),ed=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),KeywordList:oh(fd),CRS:nh(Oh),EX_GeographicBoundingBox:oh(function(t,e){var i=dh({},rd,t,e);if(!i)return;var r=i.westBoundLongitude,n=i.southBoundLatitude,o=i.eastBoundLongitude,s=i.northBoundLatitude;if(void 0===r||void 0===n||void 0===o||void 0===s)return;return[r,n,o,s]}),BoundingBox:nh(function(t,e){var i=[xh(t.getAttribute("minx")),xh(t.getAttribute("miny")),xh(t.getAttribute("maxx")),xh(t.getAttribute("maxy"))],r=[xh(t.getAttribute("resx")),xh(t.getAttribute("resy"))];return{crs:t.getAttribute("CRS"),extent:i,res:r}}),Dimension:nh(function(t,e){return{name:t.getAttribute("name"),units:t.getAttribute("units"),unitSymbol:t.getAttribute("unitSymbol"),default:t.getAttribute("default"),multipleValues:Th(t.getAttribute("multipleValues")),nearestValue:Th(t.getAttribute("nearestValue")),current:Th(t.getAttribute("current")),values:Oh(t)}}),Attribution:oh(function(t,e){return dh({},id,t,e)}),AuthorityURL:nh(function(t,e){var i=pd(t,e);if(i)return i.name=t.getAttribute("name"),i;return}),Identifier:nh(Oh),MetadataURL:nh(function(t,e){var i=pd(t,e);if(i)return i.type=t.getAttribute("type"),i;return}),DataURL:nh(pd),FeatureListURL:nh(pd),Style:nh(function(t,e){return dh({},hd,t,e)}),MinScaleDenominator:oh(Ch),MaxScaleDenominator:oh(Ch),Layer:nh(function(t,e){var i=e[e.length-1],r=dh({},ed,t,e);if(!r)return;var n=Th(t.getAttribute("queryable"));void 0===n&&(n=i.queryable);r.queryable=void 0!==n&&n;var o=Ih(t.getAttribute("cascaded"));void 0===o&&(o=i.cascaded);r.cascaded=o;var s=Th(t.getAttribute("opaque"));void 0===s&&(s=i.opaque);r.opaque=void 0!==s&&s;var a=Th(t.getAttribute("noSubsets"));void 0===a&&(a=i.noSubsets);r.noSubsets=void 0!==a&&a;var h=xh(t.getAttribute("fixedWidth"));h||(h=i.fixedWidth);r.fixedWidth=h;var l=xh(t.getAttribute("fixedHeight"));l||(l=i.fixedHeight);r.fixedHeight=l,["Style","CRS","AuthorityURL"].forEach(function(t){if(t in i){var e=r[t]||[];r[t]=e.concat(i[t])}});return["EX_GeographicBoundingBox","BoundingBox","Dimension","Attribution","MinScaleDenominator","MaxScaleDenominator"].forEach(function(t){if(!(t in r)){var e=i[t];r[t]=e}}),r})}),id=ph(Kc,{Title:oh(Oh),OnlineResource:oh(Bc),LogoURL:oh(dd)}),rd=ph(Kc,{westBoundLongitude:oh(Ch),eastBoundLongitude:oh(Ch),southBoundLatitude:oh(Ch),northBoundLatitude:oh(Ch)}),nd=ph(Kc,{GetCapabilities:oh(cd),GetMap:oh(cd),GetFeatureInfo:oh(cd)}),od=ph(Kc,{Format:nh(Oh),DCPType:nh(function(t,e){return dh({},sd,t,e)})}),sd=ph(Kc,{HTTP:oh(function(t,e){return dh({},ad,t,e)})}),ad=ph(Kc,{Get:oh(pd),Post:oh(pd)}),hd=ph(Kc,{Name:oh(Oh),Title:oh(Oh),Abstract:oh(Oh),LegendURL:nh(dd),StyleSheetURL:oh(pd),StyleURL:oh(pd)}),ld=ph(Kc,{Format:oh(Oh),OnlineResource:oh(Bc)}),ud=ph(Kc,{Keyword:ih(Oh)});function pd(t,e){return dh({},ld,t,e)}function cd(t,e){return dh({},od,t,e)}function dd(t,e){var i=pd(t,e);if(i){var r=[Ih(t.getAttribute("width")),Ih(t.getAttribute("height"))];return i.size=r,i}}function fd(t,e){return dh([],ud,t,e)}var gd=Hc,_d=function(t){function e(e){t.call(this);var i=e||{};this.featureNS_="http://mapserver.gis.umn.edu/mapserver",this.gmlFormat_=new Xp,this.layers_=i.layers?i.layers:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getLayers=function(){return this.layers_},e.prototype.setLayers=function(t){this.layers_=t},e.prototype.readFeatures_=function(t,e){t.setAttribute("namespaceURI",this.featureNS_);var i=t.localName,r=[];if(0===t.childNodes.length)return r;if("msGMLOutput"==i)for(var n=0,o=t.childNodes.length;n<o;n++){var s=t.childNodes[n];if(s.nodeType===Node.ELEMENT_NODE){var a=s,h=e[0],l=a.localName.replace("_layer","");if(!this.layers_||At(this.layers_,l)){var u=l+"_feature";h.featureType=u,h.featureNS=this.featureNS_;var p={};p[u]=ih(this.gmlFormat_.readFeatureElement,this.gmlFormat_);var c=ph([h.featureNS,null],p);a.setAttribute("namespaceURI",this.featureNS_);var d=dh([],c,a,e,this.gmlFormat_);d&&kt(r,d)}}}if("FeatureCollection"==i){var f=dh([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,t,[{}],this.gmlFormat_);f&&(r=f)}return r},e.prototype.readFeaturesFromNode=function(t,e){var i={};return e&&u(i,this.getReadOptions(t,e)),this.readFeatures_(t,[i])},e}(_h),yd=[null,"http://www.opengis.net/ows/1.1"],vd=ph(yd,{ServiceIdentification:oh(function(t,e){return dh({},Md,t,e)}),ServiceProvider:oh(function(t,e){return dh({},Fd,t,e)}),OperationsMetadata:oh(function(t,e){return dh({},Id,t,e)})}),md=function(t){function e(){t.call(this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){var e=dh({},vd,t,[]);return e||null},e}(Wc),Ed=ph(yd,{DeliveryPoint:oh(Oh),City:oh(Oh),AdministrativeArea:oh(Oh),PostalCode:oh(Oh),Country:oh(Oh),ElectronicMailAddress:oh(Oh)}),Sd=ph(yd,{Value:nh(function(t,e){return Oh(t)})}),Td=ph(yd,{AllowedValues:oh(function(t,e){return dh({},Sd,t,e)})}),Rd=ph(yd,{Phone:oh(function(t,e){return dh({},Od,t,e)}),Address:oh(function(t,e){return dh({},Ed,t,e)})}),Cd=ph(yd,{HTTP:oh(function(t,e){return dh({},xd,t,e)})}),xd=ph(yd,{Get:nh(function(t,e){var i=Bc(t);if(!i)return;return dh({href:i},Ld,t,e)}),Post:void 0}),wd=ph(yd,{DCP:oh(function(t,e){return dh({},Cd,t,e)})}),Id=ph(yd,{Operation:function(t,e){var i=t.getAttribute("name"),r=dh({},wd,t,e);if(!r)return;e[e.length-1][i]=r}}),Od=ph(yd,{Voice:oh(Oh),Facsimile:oh(Oh)}),Ld=ph(yd,{Constraint:nh(function(t,e){var i=t.getAttribute("name");if(!i)return;return dh({name:i},Td,t,e)})}),Pd=ph(yd,{IndividualName:oh(Oh),PositionName:oh(Oh),ContactInfo:oh(function(t,e){return dh({},Rd,t,e)})}),Md=ph(yd,{Abstract:oh(Oh),AccessConstraints:oh(Oh),Fees:oh(Oh),Title:oh(Oh),ServiceTypeVersion:oh(Oh),ServiceType:oh(Oh)}),Fd=ph(yd,{ProviderName:oh(Oh),ProviderSite:oh(Bc),ServiceContact:oh(function(t,e){return dh({},Pd,t,e)})});var bd=md,Nd=[null,"http://www.opengis.net/wmts/1.0"],Ad=[null,"http://www.opengis.net/ows/1.1"],Gd=ph(Nd,{Contents:oh(function(t,e){return dh({},kd,t,e)})}),Dd=function(t){function e(){t.call(this),this.owsParser_=new bd}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFromDocument=function(t){for(var e=t.firstChild;e;e=e.nextSibling)if(e.nodeType==Node.ELEMENT_NODE)return this.readFromNode(e);return null},e.prototype.readFromNode=function(t){var e=t.getAttribute("version").trim(),i=this.owsParser_.readFromNode(t);return i?(i.version=e,(i=dh(i,Gd,t,[]))||null):null},e}(Wc),kd=ph(Nd,{Layer:nh(function(t,e){return dh({},Yd,t,e)}),TileMatrixSet:nh(function(t,e){return dh({},Kd,t,e)})}),Yd=ph(Nd,{Style:nh(function(t,e){var i=dh({},Ud,t,e);if(!i)return;var r="true"===t.getAttribute("isDefault");return i.isDefault=r,i}),Format:nh(Oh),TileMatrixSetLink:nh(function(t,e){return dh({},jd,t,e)}),Dimension:nh(function(t,e){return dh({},Vd,t,e)}),ResourceURL:nh(function(t,e){var i=t.getAttribute("format"),r=t.getAttribute("template"),n=t.getAttribute("resourceType"),o={};i&&(o.format=i);r&&(o.template=r);n&&(o.resourceType=n);return o})},ph(Ad,{Title:oh(Oh),Abstract:oh(Oh),WGS84BoundingBox:oh(function(t,e){var i=dh([],Wd,t,e);if(2!=i.length)return;return Ae(i)}),Identifier:oh(Oh)})),Ud=ph(Nd,{LegendURL:nh(function(t,e){var i={};return i.format=t.getAttribute("format"),i.href=Bc(t),i})},ph(Ad,{Title:oh(Oh),Identifier:oh(Oh)})),jd=ph(Nd,{TileMatrixSet:oh(Oh),TileMatrixSetLimits:oh(function(t,e){return dh([],Xd,t,e)})}),Xd=ph(Nd,{TileMatrixLimits:ih(function(t,e){return dh({},Bd,t,e)})}),Bd=ph(Nd,{TileMatrix:oh(Oh),MinTileRow:oh(wh),MaxTileRow:oh(wh),MinTileCol:oh(wh),MaxTileCol:oh(wh)}),Vd=ph(Nd,{Default:oh(Oh),Value:nh(Oh)},ph(Ad,{Identifier:oh(Oh)})),Wd=ph(Ad,{LowerCorner:ih(Zd),UpperCorner:ih(Zd)}),Kd=ph(Nd,{WellKnownScaleSet:oh(Oh),TileMatrix:nh(function(t,e){return dh({},zd,t,e)})},ph(Ad,{SupportedCRS:oh(Oh),Identifier:oh(Oh)})),zd=ph(Nd,{TopLeftCorner:oh(Zd),ScaleDenominator:oh(Ch),TileWidth:oh(wh),TileHeight:oh(wh),MatrixWidth:oh(wh),MatrixHeight:oh(wh)},ph(Ad,{Identifier:oh(Oh)}));function Zd(t,e){var i=Oh(t).split(/\s+/);if(i&&2==i.length){var r=+i[0],n=+i[1];if(!isNaN(r)&&!isNaN(n))return[r,n]}}var Hd=Dd,qd={Point:function(t,e,i){var r=t.coordinates;e&&i&&ef(r,e,i);return new Gr(r)},LineString:function(t,e){var i=Jd(t.arcs,e);return new Fa(i)},Polygon:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r)i[r]=Jd(t.arcs[r],e);return new qr(i)},MultiPoint:function(t,e,i){var r=t.coordinates;if(e&&i)for(var n=0,o=r.length;n<o;++n)ef(r[n],e,i);return new La(r)},MultiLineString:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r)i[r]=Jd(t.arcs[r],e);return new ba(i)},MultiPolygon:function(t,e){for(var i=[],r=0,n=t.arcs.length;r<n;++r){for(var o=t.arcs[r],s=[],a=0,h=o.length;a<h;++a)s[a]=Jd(o[a],e);i[r]=s}return new Na(i)}};function Jd(t,e){for(var i,r,n=[],o=0,s=t.length;o<s;++o)i=t[o],o>0&&n.pop(),r=i>=0?e[i]:e[~i].slice().reverse(),n.push.apply(n,r);for(var a=0,h=n.length;a<h;++a)n[a]=n[a].slice();return n}function Qd(t,e,i,r,n,o,s){for(var a=t.geometries,h=[],l=0,u=a.length;l<u;++l)h[l]=$d(a[l],e,i,r,n,o,s);return h}function $d(t,e,i,r,n,o,s){var a,h=t.type,l=qd[h];a="Point"===h||"MultiPoint"===h?l(t,i,r):l(t,e);var u=new Oa;u.setGeometry(Ba(a,!1,s)),void 0!==t.id&&u.setId(t.id);var p=t.properties;return n&&(p||(p={}),p[n]=o),p&&u.setProperties(p),u}function tf(t,e,i){for(var r=0,n=0,o=0,s=t.length;o<s;++o){var a=t[o];r+=a[0],n+=a[1],a[0]=r,a[1]=n,ef(a,e,i)}}function ef(t,e,i){t[0]=t[0]*e[0]+i[0],t[1]=t[1]*e[1]+i[1]}var rf=function(t){function e(e){t.call(this);var i=e||{};this.layerName_=i.layerName,this.layers_=i.layers?i.layers:null,this.dataProjection=Zi(i.dataProjection?i.dataProjection:"EPSG:4326")}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.readFeaturesFromObject=function(t,e){if("Topology"==t.type){var i,r=t,n=null,o=null;r.transform&&(n=(i=r.transform).scale,o=i.translate);var s=r.arcs;i&&function(t,e,i){for(var r=0,n=t.length;r<n;++r)tf(t[r],e,i)}(s,n,o);var a,h=[],l=r.objects,u=this.layerName_;for(var p in l)this.layers_&&-1==this.layers_.indexOf(p)||("GeometryCollection"===l[p].type?(a=l[p],h.push.apply(h,Qd(a,s,n,o,u,p,e))):(a=l[p],h.push($d(a,s,n,o,u,p,e))));return h}return[]},e.prototype.readProjectionFromObject=function(t){return this.dataProjection},e}(Wa),nf=function(t){function e(e){var i=e||{};t.call(this,i),this.schemaLocation=i.schemaLocation?i.schemaLocation:this.namespace+" http://schemas.opengis.net/gml/3.2.1/gml.xsd"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Dh);nf.prototype.namespace="http://www.opengis.net/gml/3.2",nf.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS={"http://www.opengis.net/gml/3.2":{pos:rh(Dh.prototype.readFlatPos_),posList:rh(Dh.prototype.readFlatPosList_)}},nf.prototype.FLAT_LINEAR_RINGS_PARSERS={"http://www.opengis.net/gml/3.2":{interior:Dh.prototype.interiorParser_,exterior:Dh.prototype.exteriorParser_}},nf.prototype.GEOMETRY_PARSERS={"http://www.opengis.net/gml/3.2":{Point:rh(Eh.prototype.readPoint),MultiPoint:rh(Eh.prototype.readMultiPoint),LineString:rh(Eh.prototype.readLineString),MultiLineString:rh(Eh.prototype.readMultiLineString),LinearRing:rh(Eh.prototype.readLinearRing),Polygon:rh(Eh.prototype.readPolygon),MultiPolygon:rh(Eh.prototype.readMultiPolygon),Surface:rh(nf.prototype.readSurface_),MultiSurface:rh(Dh.prototype.readMultiSurface_),Curve:rh(nf.prototype.readCurve_),MultiCurve:rh(Dh.prototype.readMultiCurve_),Envelope:rh(nf.prototype.readEnvelope_)}},nf.prototype.MULTICURVE_PARSERS_={"http://www.opengis.net/gml/3.2":{curveMember:ih(Dh.prototype.curveMemberParser_),curveMembers:ih(Dh.prototype.curveMemberParser_)}},nf.prototype.MULTISURFACE_PARSERS_={"http://www.opengis.net/gml/3.2":{surfaceMember:ih(Dh.prototype.surfaceMemberParser_),surfaceMembers:ih(Dh.prototype.surfaceMemberParser_)}},nf.prototype.CURVEMEMBER_PARSERS_={"http://www.opengis.net/gml/3.2":{LineString:ih(Eh.prototype.readLineString),Curve:ih(Dh.prototype.readCurve_)}},nf.prototype.SURFACEMEMBER_PARSERS_={"http://www.opengis.net/gml/3.2":{Polygon:ih(Eh.prototype.readPolygon),Surface:ih(Dh.prototype.readSurface_)}},nf.prototype.SURFACE_PARSERS_={"http://www.opengis.net/gml/3.2":{patches:rh(Dh.prototype.readPatch_)}},nf.prototype.CURVE_PARSERS_={"http://www.opengis.net/gml/3.2":{segments:rh(Dh.prototype.readSegment_)}},nf.prototype.ENVELOPE_PARSERS_={"http://www.opengis.net/gml/3.2":{lowerCorner:ih(Dh.prototype.readFlatPosList_),upperCorner:ih(Dh.prototype.readFlatPosList_)}},nf.prototype.PATCHES_PARSERS_={"http://www.opengis.net/gml/3.2":{PolygonPatch:rh(Dh.prototype.readPolygonPatch_)}},nf.prototype.SEGMENTS_PARSERS_={"http://www.opengis.net/gml/3.2":{LineStringSegment:rh(Dh.prototype.readLineStringSegment_)}},nf.prototype.MULTIPOINT_PARSERS_={"http://www.opengis.net/gml/3.2":{pointMember:ih(Eh.prototype.pointMemberParser_),pointMembers:ih(Eh.prototype.pointMemberParser_)}},nf.prototype.MULTILINESTRING_PARSERS_={"http://www.opengis.net/gml/3.2":{lineStringMember:ih(Eh.prototype.lineStringMemberParser_),lineStringMembers:ih(Eh.prototype.lineStringMemberParser_)}},nf.prototype.MULTIPOLYGON_PARSERS_={"http://www.opengis.net/gml/3.2":{polygonMember:ih(Eh.prototype.polygonMemberParser_),polygonMembers:ih(Eh.prototype.polygonMemberParser_)}},nf.prototype.POINTMEMBER_PARSERS_={"http://www.opengis.net/gml/3.2":{Point:ih(Eh.prototype.readFlatCoordinatesFromNode_)}},nf.prototype.LINESTRINGMEMBER_PARSERS_={"http://www.opengis.net/gml/3.2":{LineString:ih(Eh.prototype.readLineString)}},nf.prototype.POLYGONMEMBER_PARSERS_={"http://www.opengis.net/gml/3.2":{Polygon:ih(Eh.prototype.readPolygon)}},nf.prototype.RING_PARSERS={"http://www.opengis.net/gml/3.2":{LinearRing:rh(Eh.prototype.readFlatLinearRing_)}},nf.prototype.RING_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{exterior:sh(Dh.prototype.writeRing_),interior:sh(Dh.prototype.writeRing_)}},nf.prototype.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{lowerCorner:sh(bh),upperCorner:sh(bh)}},nf.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{surfaceMember:sh(Dh.prototype.writeSurfaceOrPolygonMember_),polygonMember:sh(Dh.prototype.writeSurfaceOrPolygonMember_)}},nf.prototype.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{pointMember:sh(Dh.prototype.writePointMember_)}},nf.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{lineStringMember:sh(Dh.prototype.writeLineStringOrCurveMember_),curveMember:sh(Dh.prototype.writeLineStringOrCurveMember_)}},nf.prototype.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml/3.2":{Curve:sh(Dh.prototype.writeCurveOrLineString_),MultiCurve:sh(Dh.prototype.writeMultiCurveOrLineString_),Point:sh(nf.prototype.writePoint_),MultiPoint:sh(Dh.prototype.writeMultiPoint_),LineString:sh(Dh.prototype.writeCurveOrLineString_),MultiLineString:sh(Dh.prototype.writeMultiCurveOrLineString_),LinearRing:sh(Dh.prototype.writeLinearRing_),Polygon:sh(Dh.prototype.writeSurfaceOrPolygon_),MultiPolygon:sh(Dh.prototype.writeMultiSurfaceOrPolygon_),Surface:sh(Dh.prototype.writeSurfaceOrPolygon_),MultiSurface:sh(Dh.prototype.writeMultiSurfaceOrPolygon_),Envelope:sh(Dh.prototype.writeEnvelope)}};var of=nf,sf="renderOrder",af=function(t){function e(e){var i=e||{},r=u({},i);delete r.style,delete r.renderBuffer,delete r.updateWhileAnimating,delete r.updateWhileInteracting,t.call(this,r),this.declutter_=void 0!==i.declutter&&i.declutter,this.renderBuffer_=void 0!==i.renderBuffer?i.renderBuffer:100,this.style_=null,this.styleFunction_=void 0,this.setStyle(i.style),this.updateWhileAnimating_=void 0!==i.updateWhileAnimating&&i.updateWhileAnimating,this.updateWhileInteracting_=void 0!==i.updateWhileInteracting&&i.updateWhileInteracting,this.renderMode_=i.renderMode||Mo.VECTOR,this.type=Po.VECTOR}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDeclutter=function(){return this.declutter_},e.prototype.setDeclutter=function(t){this.declutter_=t},e.prototype.getRenderBuffer=function(){return this.renderBuffer_},e.prototype.getRenderOrder=function(){return this.get(sf)},e.prototype.getStyle=function(){return this.style_},e.prototype.getStyleFunction=function(){return this.styleFunction_},e.prototype.getUpdateWhileAnimating=function(){return this.updateWhileAnimating_},e.prototype.getUpdateWhileInteracting=function(){return this.updateWhileInteracting_},e.prototype.setRenderOrder=function(t){this.set(sf,t)},e.prototype.setStyle=function(t){this.style_=void 0!==t?t:Al,this.styleFunction_=null===t?void 0:function(t){var e;if("function"==typeof t)e=t;else{var i;Array.isArray(t)?i=t:(te("function"==typeof t.getZIndex,41),i=[t]),e=function(){return i}}return e}(this.style_),this.changed()},e.prototype.getRenderMode=function(){return this.renderMode_},e}(On);af.prototype.getSource;var hf=af;function lf(t,e){return[[-1/0,-1/0,1/0,1/0]]}function uf(t){return t?Array.isArray(t)?function(e){return t}:"function"==typeof t?t:function(e){return[t]}:null}var pf=function(t){function e(e){t.call(this),this.projection_=Zi(e.projection),this.attributions_=uf(e.attributions),this.attributionsCollapsible_=void 0===e.attributionsCollapsible||e.attributionsCollapsible,this.loading=!1,this.state_=void 0!==e.state?e.state:dn.READY,this.wrapX_=void 0!==e.wrapX&&e.wrapX}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getAttributions=function(){return this.attributions_},e.prototype.getAttributionsCollapsible=function(){return this.attributionsCollapsible_},e.prototype.getProjection=function(){return this.projection_},e.prototype.getResolutions=function(){return r()},e.prototype.getState=function(){return this.state_},e.prototype.getWrapX=function(){return this.wrapX_},e.prototype.refresh=function(){this.changed()},e.prototype.setAttributions=function(t){this.attributions_=uf(t),this.changed()},e.prototype.setState=function(t){this.state_=t,this.changed()},e}(G),cf={ADDFEATURE:"addfeature",CHANGEFEATURE:"changefeature",CLEAR:"clear",REMOVEFEATURE:"removefeature"},df=function(t){this.rbush_=xs()(t,void 0),this.items_={}};df.prototype.insert=function(t,e){var i={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};this.rbush_.insert(i),this.items_[o(e)]=i},df.prototype.load=function(t,e){for(var i=new Array(e.length),r=0,n=e.length;r<n;r++){var s=t[r],a=e[r],h={minX:s[0],minY:s[1],maxX:s[2],maxY:s[3],value:a};i[r]=h,this.items_[o(a)]=h}this.rbush_.load(i)},df.prototype.remove=function(t){var e=o(t),i=this.items_[e];return delete this.items_[e],null!==this.rbush_.remove(i)},df.prototype.update=function(t,e){var i=this.items_[o(e)];Ze([i.minX,i.minY,i.maxX,i.maxY],t)||(this.remove(e),this.insert(t,e))},df.prototype.getAll=function(){return this.rbush_.all().map(function(t){return t.value})},df.prototype.getInExtent=function(t){var e={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]};return this.rbush_.search(e).map(function(t){return t.value})},df.prototype.forEach=function(t,e){return this.forEach_(this.getAll(),t,e)},df.prototype.forEachInExtent=function(t,e,i){return this.forEach_(this.getInExtent(t),e,i)},df.prototype.forEach_=function(t,e,i){for(var r,n=0,o=t.length;n<o;n++)if(r=e.call(i,t[n]))return r;return r},df.prototype.isEmpty=function(){return d(this.items_)},df.prototype.clear=function(){this.rbush_.clear(),this.items_={}},df.prototype.getExtent=function(t){var e=this.rbush_.toJSON();return Ve(e.minX,e.minY,e.maxX,e.maxY,t)},df.prototype.concat=function(t){for(var e in this.rbush_.load(t.rbush_.all()),t.items_)this.items_[e]=t.items_[e]};var ff=df,gf=function(t){function e(e,i){t.call(this,e),this.feature=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),_f=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:void 0,state:dn.READY,wrapX:void 0===i.wrapX||i.wrapX}),this.loader_=w,this.format_=i.format,this.overlaps_=null==i.overlaps||i.overlaps,this.url_=i.url,void 0!==i.loader?this.loader_=i.loader:void 0!==this.url_&&(te(this.format_,7),this.loader_=Ua(this.url_,this.format_)),this.strategy_=void 0!==i.strategy?i.strategy:lf;var r,n,o=void 0===i.useSpatialIndex||i.useSpatialIndex;this.featuresRtree_=o?new ff:null,this.loadedExtentsRtree_=new ff,this.nullGeometryFeatures_={},this.idIndex_={},this.undefIdIndex_={},this.featureChangeKeys_={},this.featuresCollection_=null,Array.isArray(i.features)?n=i.features:i.features&&(n=(r=i.features).getArray()),o||void 0!==r||(r=new Y(n)),void 0!==n&&this.addFeaturesInternal(n),void 0!==r&&this.bindFeaturesCollection_(r)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature=function(t){this.addFeatureInternal(t),this.changed()},e.prototype.addFeatureInternal=function(t){var e=o(t);if(this.addToIndex_(e,t)){this.setupChangeEvents_(e,t);var i=t.getGeometry();if(i){var r=i.getExtent();this.featuresRtree_&&this.featuresRtree_.insert(r,t)}else this.nullGeometryFeatures_[e]=t;this.dispatchEvent(new gf(cf.ADDFEATURE,t))}},e.prototype.setupChangeEvents_=function(t,e){this.featureChangeKeys_[t]=[v(e,M.CHANGE,this.handleFeatureChange_,this),v(e,l,this.handleFeatureChange_,this)]},e.prototype.addToIndex_=function(t,e){var i=!0,r=e.getId();return void 0!==r?r.toString()in this.idIndex_?i=!1:this.idIndex_[r.toString()]=e:(te(!(t in this.undefIdIndex_),30),this.undefIdIndex_[t]=e),i},e.prototype.addFeatures=function(t){this.addFeaturesInternal(t),this.changed()},e.prototype.addFeaturesInternal=function(t){for(var e=[],i=[],r=[],n=0,s=t.length;n<s;n++){var a=t[n],h=o(a);this.addToIndex_(h,a)&&i.push(a)}for(var l=0,u=i.length;l<u;l++){var p=i[l],c=o(p);this.setupChangeEvents_(c,p);var d=p.getGeometry();if(d){var f=d.getExtent();e.push(f),r.push(p)}else this.nullGeometryFeatures_[c]=p}this.featuresRtree_&&this.featuresRtree_.load(e,r);for(var g=0,_=i.length;g<_;g++)this.dispatchEvent(new gf(cf.ADDFEATURE,i[g]))},e.prototype.bindFeaturesCollection_=function(t){var e=!1;v(this,cf.ADDFEATURE,function(i){e||(e=!0,t.push(i.feature),e=!1)}),v(this,cf.REMOVEFEATURE,function(i){e||(e=!0,t.remove(i.feature),e=!1)}),v(t,h.ADD,function(t){e||(e=!0,this.addFeature(t.element),e=!1)},this),v(t,h.REMOVE,function(t){e||(e=!0,this.removeFeature(t.element),e=!1)},this),this.featuresCollection_=t},e.prototype.clear=function(t){if(t){for(var e in this.featureChangeKeys_){this.featureChangeKeys_[e].forEach(S)}this.featuresCollection_||(this.featureChangeKeys_={},this.idIndex_={},this.undefIdIndex_={})}else if(this.featuresRtree_)for(var i in this.featuresRtree_.forEach(this.removeFeatureInternal,this),this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[i]);this.featuresCollection_&&this.featuresCollection_.clear(),this.featuresRtree_&&this.featuresRtree_.clear(),this.loadedExtentsRtree_.clear(),this.nullGeometryFeatures_={};var r=new gf(cf.CLEAR);this.dispatchEvent(r),this.changed()},e.prototype.forEachFeature=function(t){if(this.featuresRtree_)return this.featuresRtree_.forEach(t);this.featuresCollection_&&this.featuresCollection_.forEach(t)},e.prototype.forEachFeatureAtCoordinateDirect=function(t,e){var i=[t[0],t[1],t[0],t[1]];return this.forEachFeatureInExtent(i,function(i){return i.getGeometry().intersectsCoordinate(t)?e(i):void 0})},e.prototype.forEachFeatureInExtent=function(t,e){if(this.featuresRtree_)return this.featuresRtree_.forEachInExtent(t,e);this.featuresCollection_&&this.featuresCollection_.forEach(e)},e.prototype.forEachFeatureIntersectingExtent=function(t,e){return this.forEachFeatureInExtent(t,function(i){if(i.getGeometry().intersectsExtent(t)){var r=e(i);if(r)return r}})},e.prototype.getFeaturesCollection=function(){return this.featuresCollection_},e.prototype.getFeatures=function(){var t;return this.featuresCollection_?t=this.featuresCollection_.getArray():this.featuresRtree_&&(t=this.featuresRtree_.getAll(),d(this.nullGeometryFeatures_)||kt(t,c(this.nullGeometryFeatures_))),t},e.prototype.getFeaturesAtCoordinate=function(t){var e=[];return this.forEachFeatureAtCoordinateDirect(t,function(t){e.push(t)}),e},e.prototype.getFeaturesInExtent=function(t){return this.featuresRtree_.getInExtent(t)},e.prototype.getClosestFeatureToCoordinate=function(t,e){var i=t[0],r=t[1],n=null,o=[NaN,NaN],s=1/0,a=[-1/0,-1/0,1/0,1/0],h=e||C;return this.featuresRtree_.forEachInExtent(a,function(t){if(h(t)){var e=t.getGeometry(),l=s;if((s=e.closestPointXY(i,r,o,s))<l){n=t;var u=Math.sqrt(s);a[0]=i-u,a[1]=r-u,a[2]=i+u,a[3]=r+u}}}),n},e.prototype.getExtent=function(t){return this.featuresRtree_.getExtent(t)},e.prototype.getFeatureById=function(t){var e=this.idIndex_[t.toString()];return void 0!==e?e:null},e.prototype.getFormat=function(){return this.format_},e.prototype.getOverlaps=function(){return this.overlaps_},e.prototype.getUrl=function(){return this.url_},e.prototype.handleFeatureChange_=function(t){var e=t.target,i=o(e),r=e.getGeometry();if(r){var n=r.getExtent();i in this.nullGeometryFeatures_?(delete this.nullGeometryFeatures_[i],this.featuresRtree_&&this.featuresRtree_.insert(n,e)):this.featuresRtree_&&this.featuresRtree_.update(n,e)}else i in this.nullGeometryFeatures_||(this.featuresRtree_&&this.featuresRtree_.remove(e),this.nullGeometryFeatures_[i]=e);var s=e.getId();if(void 0!==s){var a=s.toString();i in this.undefIdIndex_?(delete this.undefIdIndex_[i],this.idIndex_[a]=e):this.idIndex_[a]!==e&&(this.removeFromIdIndex_(e),this.idIndex_[a]=e)}else i in this.undefIdIndex_||(this.removeFromIdIndex_(e),this.undefIdIndex_[i]=e);this.changed(),this.dispatchEvent(new gf(cf.CHANGEFEATURE,e))},e.prototype.hasFeature=function(t){var e=t.getId();return void 0!==e?e in this.idIndex_:o(t)in this.undefIdIndex_},e.prototype.isEmpty=function(){return this.featuresRtree_.isEmpty()&&d(this.nullGeometryFeatures_)},e.prototype.loadFeatures=function(t,e,i){var r=this,n=this.loadedExtentsRtree_,o=this.strategy_(t,e);this.loading=!1;for(var s=function(t,s){var a=o[t];n.forEachInExtent(a,function(t){return Ue(t.extent,a)})||(r.loader_.call(r,a,e,i),n.insert(a,{extent:a.slice()}),r.loading=r.loader_!==w)},a=0,h=o.length;a<h;++a)s(a)},e.prototype.removeLoadedExtent=function(t){var e,i=this.loadedExtentsRtree_;i.forEachInExtent(t,function(i){if(Ze(i.extent,t))return e=i,!0}),e&&i.remove(e)},e.prototype.removeFeature=function(t){var e=o(t);e in this.nullGeometryFeatures_?delete this.nullGeometryFeatures_[e]:this.featuresRtree_&&this.featuresRtree_.remove(t),this.removeFeatureInternal(t),this.changed()},e.prototype.removeFeatureInternal=function(t){var e=o(t);this.featureChangeKeys_[e].forEach(S),delete this.featureChangeKeys_[e];var i=t.getId();void 0!==i?delete this.idIndex_[i.toString()]:delete this.undefIdIndex_[e],this.dispatchEvent(new gf(cf.REMOVEFEATURE,t))},e.prototype.removeFromIdIndex_=function(t){var e=!1;for(var i in this.idIndex_)if(this.idIndex_[i]===t){delete this.idIndex_[i],e=!0;break}return e},e.prototype.setLoader=function(t){this.loader_=t},e}(pf),yf={POINT:"Point",LINE_STRING:"LineString",POLYGON:"Polygon",CIRCLE:"Circle"},vf="drawstart",mf="drawend",Ef=function(t){function e(e,i){t.call(this,e),this.feature=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);var Sf=function(t){function e(e){var i=e;i.stopDown||(i.stopDown=x),t.call(this,i),this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=function(t){var e;t===_i.POINT||t===_i.MULTI_POINT?e=yf.POINT:t===_i.LINE_STRING||t===_i.MULTI_LINE_STRING?e=yf.LINE_STRING:t===_i.POLYGON||t===_i.MULTI_POLYGON?e=yf.POLYGON:t===_i.CIRCLE&&(e=yf.CIRCLE);return e}(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_===yf.POLYGON?3:2,this.maxPoints_=e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:C;var r,n=e.geometryFunction;if(!n)if(this.type_===_i.CIRCLE)n=function(t,e){var i=e||new Ga([NaN,NaN]),r=we(t[0],t[1]);return i.setCenterAndRadius(t[0],Math.sqrt(r)),i};else{var o,s=this.mode_;s===yf.POINT?o=Gr:s===yf.LINE_STRING?o=Fa:s===yf.POLYGON&&(o=qr),n=function(t,e){var i=e;return i?s===yf.POLYGON?t[0].length?i.setCoordinates([t[0].concat([t[0][0]])]):i.setCoordinates([]):i.setCoordinates(t):i=new o(t),i}}this.geometryFunction_=n,this.dragVertexDelay_=void 0!==e.dragVertexDelay?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new hf({source:new _f({useSpatialIndex:!1,wrapX:!!e.wrapX&&e.wrapX}),style:e.style?e.style:(r=Gl(),function(t,e){return r[t.getGeometry().getType()]}),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:Qn,this.freehandCondition_,e.freehand?this.freehandCondition_=zn:this.freehandCondition_=e.freehandCondition?e.freehandCondition:$n,v(this,A(Gn.ACTIVE),this.updateState_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setMap=function(e){t.prototype.setMap.call(this,e),this.updateState_()},e.prototype.getOverlay=function(){return this.overlay_},e.prototype.handleEvent=function(e){e.originalEvent.type===M.CONTEXTMENU&&e.preventDefault(),this.freehand_=this.mode_!==yf.POINT&&this.freehandCondition_(e);var i=e.type===Q.POINTERMOVE,r=!0;!this.freehand_&&this.lastDragTime_&&e.type===Q.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,i=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0));return this.freehand_&&e.type===Q.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(e),r=!1):this.freehand_&&e.type===Q.POINTERDOWN?r=!1:i?(r=e.type===Q.POINTERMOVE)&&this.freehand_?r=this.handlePointerMove_(e):(e.pointerEvent.pointerType==nt||e.type===Q.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(e):e.type===Q.DBLCLICK&&(r=!1),t.prototype.handleEvent.call(this,e)&&r},e.prototype.handleDownEvent=function(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t),!0):!!this.condition_(t)&&(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(function(){this.handlePointerMove_(new $(Q.POINTERMOVE,t.map,t.pointerEvent,!1,t.frameState))}.bind(this),this.dragVertexDelay_),this.downPx_=t.pixel,!0)},e.prototype.handleUpEvent=function(t){var e=!0;this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);var i=this.mode_===yf.CIRCLE;return this.shouldHandle_?(this.finishCoordinate_?this.freehand_||i?this.finishDrawing():this.atFinish_(t)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t):(this.startDrawing_(t),this.mode_===yf.POINT&&this.finishDrawing()),e=!1):this.freehand_&&(this.finishCoordinate_=null,this.abortDrawing_()),!e&&this.stopClick_&&t.stopPropagation(),e},e.prototype.handlePointerMove_=function(t){if(this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){var e=this.downPx_,i=t.pixel,r=e[0]-i[0],n=e[1]-i[1],o=r*r+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return!0}return this.finishCoordinate_?this.modifyDrawing_(t):this.createOrUpdateSketchPoint_(t),!0},e.prototype.atFinish_=function(t){var e=!1;if(this.sketchFeature_){var i=!1,r=[this.finishCoordinate_];if(this.mode_===yf.LINE_STRING)i=this.sketchCoords_.length>this.minPoints_;else if(this.mode_===yf.POLYGON){var n=this.sketchCoords_;i=n[0].length>this.minPoints_,r=[n[0][0],n[0][n[0].length-2]]}if(i)for(var o=t.map,s=0,a=r.length;s<a;s++){var h=r[s],l=o.getPixelFromCoordinate(h),u=t.pixel,p=u[0]-l[0],c=u[1]-l[1],d=this.freehand_?1:this.snapTolerance_;if(e=Math.sqrt(p*p+c*c)<=d){this.finishCoordinate_=h;break}}}return e},e.prototype.createOrUpdateSketchPoint_=function(t){var e=t.coordinate.slice();this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new Oa(new Gr(e)),this.updateSketchFeatures_())},e.prototype.startDrawing_=function(t){var e=t.coordinate;this.finishCoordinate_=e,this.mode_===yf.POINT?this.sketchCoords_=e.slice():this.mode_===yf.POLYGON?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Oa(new Fa(this.sketchLineCoords_)));var i=this.geometryFunction_(this.sketchCoords_);this.sketchFeature_=new Oa,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new Ef(vf,this.sketchFeature_))},e.prototype.modifyDrawing_=function(t){var e,i,r,n=t.coordinate,o=this.sketchFeature_.getGeometry();(this.mode_===yf.POINT?i=this.sketchCoords_:this.mode_===yf.POLYGON?(i=(e=this.sketchCoords_[0])[e.length-1],this.atFinish_(t)&&(n=this.finishCoordinate_.slice())):i=(e=this.sketchCoords_)[e.length-1],i[0]=n[0],i[1]=n[1],this.geometryFunction_(this.sketchCoords_,o),this.sketchPoint_)&&this.sketchPoint_.getGeometry().setCoordinates(n);if(o.getType()==_i.POLYGON&&this.mode_!==yf.POLYGON){this.sketchLine_||(this.sketchLine_=new Oa);var s=o.getLinearRing(0);(r=this.sketchLine_.getGeometry())?(r.setFlatCoordinates(s.getLayout(),s.getFlatCoordinates()),r.changed()):(r=new Fa(s.getFlatCoordinates(),s.getLayout()),this.sketchLine_.setGeometry(r))}else this.sketchLineCoords_&&(r=this.sketchLine_.getGeometry()).setCoordinates(this.sketchLineCoords_);this.updateSketchFeatures_()},e.prototype.addToDrawing_=function(t){var e,i,r=t.coordinate,n=this.sketchFeature_.getGeometry();this.mode_===yf.LINE_STRING?(this.finishCoordinate_=r.slice(),(i=this.sketchCoords_).length>=this.maxPoints_&&(this.freehand_?i.pop():e=!0),i.push(r.slice()),this.geometryFunction_(i,n)):this.mode_===yf.POLYGON&&((i=this.sketchCoords_[0]).length>=this.maxPoints_&&(this.freehand_?i.pop():e=!0),i.push(r.slice()),e&&(this.finishCoordinate_=i[0]),this.geometryFunction_(this.sketchCoords_,n)),this.updateSketchFeatures_(),e&&this.finishDrawing()},e.prototype.removeLastPoint=function(){if(this.sketchFeature_){var t,e=this.sketchFeature_.getGeometry();this.mode_===yf.LINE_STRING?((t=this.sketchCoords_).splice(-2,1),this.geometryFunction_(t,e),t.length>=2&&(this.finishCoordinate_=t[t.length-2].slice())):this.mode_===yf.POLYGON&&((t=this.sketchCoords_[0]).splice(-2,1),this.sketchLine_.getGeometry().setCoordinates(t),this.geometryFunction_(this.sketchCoords_,e)),0===t.length&&(this.finishCoordinate_=null),this.updateSketchFeatures_()}},e.prototype.finishDrawing=function(){var t=this.abortDrawing_();if(t){var e=this.sketchCoords_,i=t.getGeometry();this.mode_===yf.LINE_STRING?(e.pop(),this.geometryFunction_(e,i)):this.mode_===yf.POLYGON&&(e[0].pop(),this.geometryFunction_(e,i),e=i.getCoordinates()),this.type_===_i.MULTI_POINT?t.setGeometry(new La([e])):this.type_===_i.MULTI_LINE_STRING?t.setGeometry(new ba([e])):this.type_===_i.MULTI_POLYGON&&t.setGeometry(new Na([e])),this.dispatchEvent(new Ef(mf,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}},e.prototype.abortDrawing_=function(){this.finishCoordinate_=null;var t=this.sketchFeature_;return t&&(this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0)),t},e.prototype.extend=function(t){var e=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=e.getCoordinates();var i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.updateSketchFeatures_(),this.dispatchEvent(new Ef(vf,this.sketchFeature_))},e.prototype.updateSketchFeatures_=function(){var t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);var e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)},e.prototype.updateState_=function(){var t=this.getMap(),e=this.getActive();t&&e||this.abortDrawing_(),this.overlay_.setMap(e?t:null)},e}(no),Tf="translatestart",Rf="translating",Cf="translateend",xf=function(t){function e(e,i,r){t.call(this,e),this.features=i,this.coordinate=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),wf=function(t){function e(e){var i,r=e||{};if(t.call(this,r),this.lastCoordinate_=null,this.features_=void 0!==r.features?r.features:null,r.layers)if("function"==typeof r.layers)i=r.layers;else{var n=r.layers;i=function(t){return At(n,t)}}else i=C;this.layerFilter_=i,this.hitTolerance_=r.hitTolerance?r.hitTolerance:0,this.lastFeature_=null,v(this,A(Gn.ACTIVE),this.handleActiveChanged_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleDownEvent=function(t){if(this.lastFeature_=this.featuresAtPixel_(t.pixel,t.map),!this.lastCoordinate_&&this.lastFeature_){this.lastCoordinate_=t.coordinate,this.handleMoveEvent(t);var e=this.features_||new Y([this.lastFeature_]);return this.dispatchEvent(new xf(Tf,e,t.coordinate)),!0}return!1},e.prototype.handleUpEvent=function(t){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(t);var e=this.features_||new Y([this.lastFeature_]);return this.dispatchEvent(new xf(Cf,e,t.coordinate)),!0}return!1},e.prototype.handleDragEvent=function(t){if(this.lastCoordinate_){var e=t.coordinate,i=e[0]-this.lastCoordinate_[0],r=e[1]-this.lastCoordinate_[1],n=this.features_||new Y([this.lastFeature_]);n.forEach(function(t){var e=t.getGeometry();e.translate(i,r),t.setGeometry(e)}),this.lastCoordinate_=e,this.dispatchEvent(new xf(Rf,n,e))}},e.prototype.handleMoveEvent=function(t){var e=t.map.getViewport();this.featuresAtPixel_(t.pixel,t.map)?(e.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),e.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):e.classList.remove("ol-grab","ol-grabbing")},e.prototype.featuresAtPixel_=function(t,e){return e.forEachFeatureAtPixel(t,function(t){if(!this.features_||At(this.features_.getArray(),t))return t}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})},e.prototype.getHitTolerance=function(){return this.hitTolerance_},e.prototype.setHitTolerance=function(t){this.hitTolerance_=t},e.prototype.setMap=function(e){var i=this.getMap();t.prototype.setMap.call(this,e),this.updateState_(i)},e.prototype.handleActiveChanged_=function(){this.updateState_(null)},e.prototype.updateState_=function(t){var e=this.getMap(),i=this.getActive();e&&i||(e=e||t)&&e.getViewport().classList.remove("ol-grab","ol-grabbing")},e}(no);function If(t){return t.feature?t.feature:t.element?t.element:void 0}var Of=function(t){function e(e){var i=e||{},r=i;r.handleDownEvent||(r.handleDownEvent=C),r.stopDown||(r.stopDown=x),t.call(this,r),this.source_=i.source?i.source:null,this.vertex_=void 0===i.vertex||i.vertex,this.edge_=void 0===i.edge||i.edge,this.features_=i.features?i.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelCoordinate_=null,this.pixelTolerance_=void 0!==i.pixelTolerance?i.pixelTolerance:10,this.sortByDistance_=function(t,e){var i=Oe(this.pixelCoordinate_,t.segment),r=Oe(this.pixelCoordinate_,e.segment);return i-r}.bind(this),this.rBush_=new ff,this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_,Circle:this.writeCircleGeometry_}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature=function(t,e){var i=void 0===e||e,r=o(t),n=t.getGeometry();if(n){var s=this.SEGMENT_WRITERS_[n.getType()];s&&(this.indexedFeaturesExtents_[r]=n.getExtent([1/0,1/0,-1/0,-1/0]),s.call(this,t,n))}i&&(this.featureChangeListenerKeys_[r]=v(t,M.CHANGE,this.handleFeatureChange_,this))},e.prototype.forEachFeatureAdd_=function(t){this.addFeature(t)},e.prototype.forEachFeatureRemove_=function(t){this.removeFeature(t)},e.prototype.getFeatures_=function(){var t;return this.features_?t=this.features_:this.source_&&(t=this.source_.getFeatures()),t},e.prototype.handleEvent=function(e){var i=this.snapTo(e.pixel,e.coordinate,e.map);return i.snapped&&(e.coordinate=i.vertex.slice(0,2),e.pixel=i.vertexPixel),t.prototype.handleEvent.call(this,e)},e.prototype.handleFeatureAdd_=function(t){var e=If(t);this.addFeature(e)},e.prototype.handleFeatureRemove_=function(t){var e=If(t);this.removeFeature(e)},e.prototype.handleFeatureChange_=function(t){var e=t.target;if(this.handlingDownUpSequence){var i=o(e);i in this.pendingFeatures_||(this.pendingFeatures_[i]=e)}else this.updateFeature_(e)},e.prototype.handleUpEvent=function(t){var e=c(this.pendingFeatures_);return e.length&&(e.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1},e.prototype.removeFeature=function(t,e){var i=void 0===e||e,r=o(t),n=this.indexedFeaturesExtents_[r];if(n){var s=this.rBush_,a=[];s.forEachInExtent(n,function(e){t===e.feature&&a.push(e)});for(var h=a.length-1;h>=0;--h)s.remove(a[h])}i&&(S(this.featureChangeListenerKeys_[r]),delete this.featureChangeListenerKeys_[r])},e.prototype.setMap=function(e){var i=this.getMap(),r=this.featuresListenerKeys_,n=this.getFeatures_();i&&(r.forEach(S),r.length=0,n.forEach(this.forEachFeatureRemove_.bind(this))),t.prototype.setMap.call(this,e),e&&(this.features_?r.push(v(this.features_,h.ADD,this.handleFeatureAdd_,this),v(this.features_,h.REMOVE,this.handleFeatureRemove_,this)):this.source_&&r.push(v(this.source_,cf.ADDFEATURE,this.handleFeatureAdd_,this),v(this.source_,cf.REMOVEFEATURE,this.handleFeatureRemove_,this)),n.forEach(this.forEachFeatureAdd_.bind(this)))},e.prototype.snapTo=function(t,e,i){var r=Ae([i.getCoordinateFromPixel([t[0]-this.pixelTolerance_,t[1]+this.pixelTolerance_]),i.getCoordinateFromPixel([t[0]+this.pixelTolerance_,t[1]-this.pixelTolerance_])]),n=this.rBush_.getInExtent(r);this.vertex_&&!this.edge_&&(n=n.filter(function(t){return t.feature.getGeometry().getType()!==_i.CIRCLE}));var o,s,a,h,l=!1,u=null,p=null;if(n.length>0){this.pixelCoordinate_=e,n.sort(this.sortByDistance_);var c=n[0].segment,d=n[0].feature.getGeometry().getType()===_i.CIRCLE;this.vertex_&&!this.edge_?(o=i.getPixelFromCoordinate(c[0]),s=i.getPixelFromCoordinate(c[1]),a=we(t,o),h=we(t,s),Math.sqrt(Math.min(a,h))<=this.pixelTolerance_&&(l=!0,u=a>h?c[1]:c[0],p=i.getPixelFromCoordinate(u))):this.edge_&&(u=d?function(t,e){var i=e.getRadius(),r=e.getCenter(),n=r[0],o=r[1],s=t[0]-n,a=t[1]-o;0===s&&0===a&&(s=1);var h=Math.sqrt(s*s+a*a);return[n+i*s/h,o+i*a/h]}(e,n[0].feature.getGeometry()):Te(e,c),Ie(t,p=i.getPixelFromCoordinate(u))<=this.pixelTolerance_&&(l=!0,this.vertex_&&!d&&(o=i.getPixelFromCoordinate(c[0]),s=i.getPixelFromCoordinate(c[1]),a=we(p,o),h=we(p,s),Math.sqrt(Math.min(a,h))<=this.pixelTolerance_&&(u=a>h?c[1]:c[0],p=i.getPixelFromCoordinate(u))))),l&&(p=[Math.round(p[0]),Math.round(p[1])])}return{snapped:l,vertex:u,vertexPixel:p}},e.prototype.updateFeature_=function(t){this.removeFeature(t,!1),this.addFeature(t,!1)},e.prototype.writeCircleGeometry_=function(t,e){for(var i=Qr(e).getCoordinates()[0],r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeGeometryCollectionGeometry_=function(t,e){for(var i=e.getGeometriesArray(),r=0;r<i.length;++r){var n=this.SEGMENT_WRITERS_[i[r].getType()];n&&n.call(this,t,i[r])}},e.prototype.writeLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeMultiLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writeMultiPointGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r){var o=i[r],s={feature:t,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},e.prototype.writeMultiPolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length;s<a;++s)for(var h=o[s],l=0,u=h.length-1;l<u;++l){var p=h.slice(l,l+2),c={feature:t,segment:p};this.rBush_.insert(Ae(p),c)}},e.prototype.writePointGeometry_=function(t,e){var i=e.getCoordinates(),r={feature:t,segment:[i,i]};this.rBush_.insert(e.getExtent(),r)},e.prototype.writePolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,segment:h};this.rBush_.insert(Ae(h),l)}},e}(no),Lf={SELECT:"select"},Pf=function(t){function e(e,i,r,n){t.call(this,e),this.selected=i,this.deselected=r,this.mapBrowserEvent=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function Mf(t){if(!this.condition_(t))return!0;var e=this.addCondition_(t),i=this.removeCondition_(t),r=this.toggleCondition_(t),n=!e&&!i&&!r,o=t.map,s=this.getFeatures(),a=[],h=[];if(n){p(this.featureLayerAssociation_),o.forEachFeatureAtPixel(t.pixel,function(t,e){if(this.filter_(t,e))return h.push(t),this.addFeatureLayerAssociation_(t,e),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(var l=s.getLength()-1;l>=0;--l){var u=s.item(l),c=h.indexOf(u);c>-1?h.splice(c,1):(s.remove(u),a.push(u))}0!==h.length&&s.extend(h)}else{o.forEachFeatureAtPixel(t.pixel,function(t,n){if(this.filter_(t,n))return!e&&!r||At(s.getArray(),t)?(i||r)&&At(s.getArray(),t)&&(a.push(t),this.removeFeatureLayerAssociation_(t)):(h.push(t),this.addFeatureLayerAssociation_(t,n)),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(var d=a.length-1;d>=0;--d)s.remove(a[d]);s.extend(h)}return(h.length>0||a.length>0)&&this.dispatchEvent(new Pf(Lf.SELECT,h,a,t)),qn(t)}function Ff(){var t=Gl();return kt(t[_i.POLYGON],t[_i.LINE_STRING]),kt(t[_i.GEOMETRY_COLLECTION],t[_i.LINE_STRING]),function(e,i){return e.getGeometry()?t[e.getGeometry().getType()]:null}}var bf=function(t){function e(e){t.call(this,{handleEvent:Mf});var i=e||{};this.condition_=i.condition?i.condition:Jn,this.addCondition_=i.addCondition?i.addCondition:Hn,this.removeCondition_=i.removeCondition?i.removeCondition:Hn,this.toggleCondition_=i.toggleCondition?i.toggleCondition:$n,this.multi_=!!i.multi&&i.multi,this.filter_=i.filter?i.filter:C,this.hitTolerance_=i.hitTolerance?i.hitTolerance:0;var r,n=new hf({source:new _f({useSpatialIndex:!1,features:i.features,wrapX:i.wrapX}),style:i.style?i.style:Ff(),updateWhileAnimating:!0,updateWhileInteracting:!0});if(this.featureOverlay_=n,i.layers)if("function"==typeof i.layers)r=i.layers;else{var o=i.layers;r=function(t){return At(o,t)}}else r=C;this.layerFilter_=r,this.featureLayerAssociation_={};var s=this.getFeatures();v(s,h.ADD,this.addFeature_,this),v(s,h.REMOVE,this.removeFeature_,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeatureLayerAssociation_=function(t,e){this.featureLayerAssociation_[o(t)]=e},e.prototype.getFeatures=function(){return this.featureOverlay_.getSource().getFeaturesCollection()},e.prototype.getHitTolerance=function(){return this.hitTolerance_},e.prototype.getLayer=function(t){return this.featureLayerAssociation_[o(t)]},e.prototype.getOverlay=function(){return this.featureOverlay_},e.prototype.setHitTolerance=function(t){this.hitTolerance_=t},e.prototype.setMap=function(e){var i=this.getMap(),r=this.getFeatures();i&&r.forEach(i.unskipFeature.bind(i)),t.prototype.setMap.call(this,e),this.featureOverlay_.setMap(e),e&&r.forEach(e.skipFeature.bind(e))},e.prototype.addFeature_=function(t){var e=this.getMap();e&&e.skipFeature(t.element)},e.prototype.removeFeature_=function(t){var e=this.getMap();e&&e.unskipFeature(t.element)},e.prototype.removeFeatureLayerAssociation_=function(t){delete this.featureLayerAssociation_[o(t)]},e}(jn),Nf=1,Af="modifystart",Gf="modifyend",Df=function(t){function e(e,i,r){t.call(this,e),this.features=i,this.mapBrowserEvent=r}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function kf(t,e){return t.index-e.index}function Yf(t,e){var i=e.geometry;if(i.getType()===_i.CIRCLE){var r=i;if(e.index===Nf){var n=we(r.getCenter(),t),o=Math.sqrt(n)-r.getRadius();return o*o}}return Oe(t,e.segment)}function Uf(t,e){var i=e.geometry;return i.getType()===_i.CIRCLE&&e.index===Nf?i.getClosestPoint(t):Te(t,e.segment)}function jf(){var t=Gl();return function(e,i){return t[_i.POINT]}}var Xf=function(t){function e(e){var i;if(t.call(this,e),this.condition_=e.condition?e.condition:io,this.defaultDeleteCondition_=function(t){return Vn(t)&&Jn(t)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:zn,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.modified_=!1,this.rBush_=new ff,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new hf({source:new _f({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:jf(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,Circle:this.writeCircleGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_},this.source_=null,e.source?(this.source_=e.source,i=new Y(this.source_.getFeatures()),v(this.source_,cf.ADDFEATURE,this.handleSourceAdd_,this),v(this.source_,cf.REMOVEFEATURE,this.handleSourceRemove_,this)):i=e.features,!i)throw new Error("The modify interaction requires features or a source");this.features_=i,this.features_.forEach(this.addFeature_.bind(this)),v(this.features_,h.ADD,this.handleFeatureAdd_,this),v(this.features_,h.REMOVE,this.handleFeatureRemove_,this),this.lastPointerEvent_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.addFeature_=function(t){var e=t.getGeometry();e&&e.getType()in this.SEGMENT_WRITERS_&&this.SEGMENT_WRITERS_[e.getType()].call(this,t,e);var i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),v(t,M.CHANGE,this.handleFeatureChange_,this)},e.prototype.willModifyFeatures_=function(t){this.modified_||(this.modified_=!0,this.dispatchEvent(new Df(Af,this.features_,t)))},e.prototype.removeFeature_=function(t){this.removeFeatureSegmentData_(t),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),E(t,M.CHANGE,this.handleFeatureChange_,this)},e.prototype.removeFeatureSegmentData_=function(t){var e=this.rBush_,i=[];e.forEach(function(e){t===e.feature&&i.push(e)});for(var r=i.length-1;r>=0;--r)e.remove(i[r])},e.prototype.setActive=function(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),t.prototype.setActive.call(this,e)},e.prototype.setMap=function(e){this.overlay_.setMap(e),t.prototype.setMap.call(this,e)},e.prototype.getOverlay=function(){return this.overlay_},e.prototype.handleSourceAdd_=function(t){t.feature&&this.features_.push(t.feature)},e.prototype.handleSourceRemove_=function(t){t.feature&&this.features_.remove(t.feature)},e.prototype.handleFeatureAdd_=function(t){this.addFeature_(t.element)},e.prototype.handleFeatureChange_=function(t){if(!this.changingFeature_){var e=t.target;this.removeFeature_(e),this.addFeature_(e)}},e.prototype.handleFeatureRemove_=function(t){var e=t.element;this.removeFeature_(e)},e.prototype.writePointGeometry_=function(t,e){var i=e.getCoordinates(),r={feature:t,geometry:e,segment:[i,i]};this.rBush_.insert(e.getExtent(),r)},e.prototype.writeMultiPointGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r){var o=i[r],s={feature:t,geometry:e,depth:[r],index:r,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},e.prototype.writeLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length-1;r<n;++r){var o=i.slice(r,r+2),s={feature:t,geometry:e,index:r,segment:o};this.rBush_.insert(Ae(o),s)}},e.prototype.writeMultiLineStringGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,geometry:e,depth:[r],index:s,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writePolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length-1;s<a;++s){var h=o.slice(s,s+2),l={feature:t,geometry:e,depth:[r],index:s,segment:h};this.rBush_.insert(Ae(h),l)}},e.prototype.writeMultiPolygonGeometry_=function(t,e){for(var i=e.getCoordinates(),r=0,n=i.length;r<n;++r)for(var o=i[r],s=0,a=o.length;s<a;++s)for(var h=o[s],l=0,u=h.length-1;l<u;++l){var p=h.slice(l,l+2),c={feature:t,geometry:e,depth:[s,r],index:l,segment:p};this.rBush_.insert(Ae(p),c)}},e.prototype.writeCircleGeometry_=function(t,e){var i=e.getCenter(),r={feature:t,geometry:e,index:0,segment:[i,i]},n={feature:t,geometry:e,index:Nf,segment:[i,i]},o=[r,n];r.featureSegments=n.featureSegments=o,this.rBush_.insert(Ke(i),r),this.rBush_.insert(e.getExtent(),n)},e.prototype.writeGeometryCollectionGeometry_=function(t,e){for(var i=e.getGeometriesArray(),r=0;r<i.length;++r)this.SEGMENT_WRITERS_[i[r].getType()].call(this,t,i[r])},e.prototype.createOrUpdateVertexFeature_=function(t){var e=this.vertexFeature_;e?e.getGeometry().setCoordinates(t):(e=new Oa(new Gr(t)),this.vertexFeature_=e,this.overlay_.getSource().addFeature(e));return e},e.prototype.handleEvent=function(e){return!e.pointerEvent||(this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=Q.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(i=!(e.type!=Q.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==Q.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),t.prototype.handleEvent.call(this,e)&&!i);var i},e.prototype.handleDragEvent=function(t){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(t);for(var e=t.coordinate,i=0,r=this.dragSegments_.length;i<r;++i){for(var n=this.dragSegments_[i],o=n[0],s=o.depth,a=o.geometry,h=void 0,l=o.segment,u=n[1];e.length<a.getStride();)e.push(l[u][e.length]);switch(a.getType()){case _i.POINT:h=e,l[0]=l[1]=e;break;case _i.MULTI_POINT:(h=a.getCoordinates())[o.index]=e,l[0]=l[1]=e;break;case _i.LINE_STRING:(h=a.getCoordinates())[o.index+u]=e,l[u]=e;break;case _i.MULTI_LINE_STRING:case _i.POLYGON:(h=a.getCoordinates())[s[0]][o.index+u]=e,l[u]=e;break;case _i.MULTI_POLYGON:(h=a.getCoordinates())[s[1]][s[0]][o.index+u]=e,l[u]=e;break;case _i.CIRCLE:l[0]=l[1]=e,0===o.index?(this.changingFeature_=!0,a.setCenter(e),this.changingFeature_=!1):(this.changingFeature_=!0,a.setRadius(Ie(a.getCenter(),e)),this.changingFeature_=!1)}h&&this.setGeometryCoordinates_(a,h)}this.createOrUpdateVertexFeature_(e)},e.prototype.handleDownEvent=function(t){if(!this.condition_(t))return!1;this.handlePointerAtPixel_(t.pixel,t.map);var e=t.map.getCoordinateFromPixel(t.pixel);this.dragSegments_.length=0,this.modified_=!1;var i=this.vertexFeature_;if(i){var r=[],n=i.getGeometry().getCoordinates(),s=Ae([n]),a=this.rBush_.getInExtent(s),h={};a.sort(kf);for(var l=0,u=a.length;l<u;++l){var p=a[l],c=p.segment,d=o(p.feature),f=p.depth;if(f&&(d+="-"+f.join("-")),h[d]||(h[d]=new Array(2)),p.geometry.getType()===_i.CIRCLE&&p.index===Nf)Re(Uf(e,p),n)&&!h[d][0]&&(this.dragSegments_.push([p,0]),h[d][0]=p);else if(Re(c[0],n)&&!h[d][0])this.dragSegments_.push([p,0]),h[d][0]=p;else if(Re(c[1],n)&&!h[d][1]){if((p.geometry.getType()===_i.LINE_STRING||p.geometry.getType()===_i.MULTI_LINE_STRING)&&h[d][0]&&0===h[d][0].index)continue;this.dragSegments_.push([p,1]),h[d][1]=p}else this.insertVertexCondition_(t)&&o(c)in this.vertexSegments_&&!h[d][0]&&!h[d][1]&&r.push([p,n])}r.length&&this.willModifyFeatures_(t);for(var g=r.length-1;g>=0;--g)this.insertVertex_.apply(this,r[g])}return!!this.vertexFeature_},e.prototype.handleUpEvent=function(t){for(var e=this.dragSegments_.length-1;e>=0;--e){var i=this.dragSegments_[e][0],r=i.geometry;if(r.getType()===_i.CIRCLE){var n=r.getCenter(),o=i.featureSegments[0],s=i.featureSegments[1];o.segment[0]=o.segment[1]=n,s.segment[0]=s.segment[1]=n,this.rBush_.update(Ke(n),o),this.rBush_.update(r.getExtent(),s)}else this.rBush_.update(Ae(i.segment),i)}return this.modified_&&(this.dispatchEvent(new Df(Gf,this.features_,t)),this.modified_=!1),!1},e.prototype.handlePointerMove_=function(t){this.lastPixel_=t.pixel,this.handlePointerAtPixel_(t.pixel,t.map)},e.prototype.handlePointerAtPixel_=function(t,e){var i=e.getCoordinateFromPixel(t),r=Ge(Ke(i),e.getView().getResolution()*this.pixelTolerance_),n=this.rBush_.getInExtent(r);if(n.length>0){n.sort(function(t,e){return Yf(i,t)-Yf(i,e)});var s=n[0],a=s.segment,h=Uf(i,s),l=e.getPixelFromCoordinate(h),u=Ie(t,l);if(u<=this.pixelTolerance_){var p={};if(s.geometry.getType()===_i.CIRCLE&&s.index===Nf)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(h);else{var c=e.getPixelFromCoordinate(a[0]),d=e.getPixelFromCoordinate(a[1]),f=we(l,c),g=we(l,d);u=Math.sqrt(Math.min(f,g)),this.snappedToVertex_=u<=this.pixelTolerance_,this.snappedToVertex_&&(h=f>g?a[1]:a[0]),this.createOrUpdateVertexFeature_(h);for(var _=1,y=n.length;_<y;++_){var v=n[_].segment;if(!(Re(a[0],v[0])&&Re(a[1],v[1])||Re(a[0],v[1])&&Re(a[1],v[0])))break;p[o(v)]=!0}}return p[o(a)]=!0,void(this.vertexSegments_=p)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)},e.prototype.insertVertex_=function(t,e){for(var i,r=t.segment,n=t.feature,o=t.geometry,s=t.depth,a=t.index;e.length<o.getStride();)e.push(0);switch(o.getType()){case _i.MULTI_LINE_STRING:case _i.POLYGON:(i=o.getCoordinates())[s[0]].splice(a+1,0,e);break;case _i.MULTI_POLYGON:(i=o.getCoordinates())[s[1]][s[0]].splice(a+1,0,e);break;case _i.LINE_STRING:(i=o.getCoordinates()).splice(a+1,0,e);break;default:return}this.setGeometryCoordinates_(o,i);var h=this.rBush_;h.remove(t),this.updateSegmentIndices_(o,a,s,1);var l={segment:[r[0],e],feature:n,geometry:o,depth:s,index:a};h.insert(Ae(l.segment),l),this.dragSegments_.push([l,1]);var u={segment:[e,r[1]],feature:n,geometry:o,depth:s,index:a+1};h.insert(Ae(u.segment),u),this.dragSegments_.push([u,0]),this.ignoreNextSingleClick_=!0},e.prototype.removePoint=function(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=Q.POINTERDRAG){var t=this.lastPointerEvent_;return this.willModifyFeatures_(t),this.removeVertex_(),this.dispatchEvent(new Df(Gf,this.features_,t)),this.modified_=!1,!0}return!1},e.prototype.removeVertex_=function(){var t,e,i,r,n,s,a,h,l,u,p,c=this.dragSegments_,d={},f=!1;for(n=c.length-1;n>=0;--n)p=o((u=(i=c[n])[0]).feature),u.depth&&(p+="-"+u.depth.join("-")),p in d||(d[p]={}),0===i[1]?(d[p].right=u,d[p].index=u.index):1==i[1]&&(d[p].left=u,d[p].index=u.index+1);for(p in d){switch(l=d[p].right,a=d[p].left,(h=(s=d[p].index)-1)<0&&(h=0),t=e=(r=(u=void 0!==a?a:l).geometry).getCoordinates(),f=!1,r.getType()){case _i.MULTI_LINE_STRING:e[u.depth[0]].length>2&&(e[u.depth[0]].splice(s,1),f=!0);break;case _i.LINE_STRING:e.length>2&&(e.splice(s,1),f=!0);break;case _i.MULTI_POLYGON:t=t[u.depth[1]];case _i.POLYGON:(t=t[u.depth[0]]).length>4&&(s==t.length-1&&(s=0),t.splice(s,1),f=!0,0===s&&(t.pop(),t.push(t[0]),h=t.length-1))}if(f){this.setGeometryCoordinates_(r,e);var g=[];if(void 0!==a&&(this.rBush_.remove(a),g.push(a.segment[0])),void 0!==l&&(this.rBush_.remove(l),g.push(l.segment[1])),void 0!==a&&void 0!==l){var _={depth:u.depth,feature:u.feature,geometry:u.geometry,index:h,segment:g};this.rBush_.insert(Ae(_.segment),_)}this.updateSegmentIndices_(r,s,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),c.length=0}}return f},e.prototype.setGeometryCoordinates_=function(t,e){this.changingFeature_=!0,t.setCoordinates(e),this.changingFeature_=!1},e.prototype.updateSegmentIndices_=function(t,e,i,r){this.rBush_.forEachInExtent(t.getExtent(),function(n){n.geometry===t&&(void 0===i||void 0===n.depth||Ut(n.depth,i))&&n.index>e&&(n.index+=r)})},e}(no),Bf="addfeatures",Vf=function(t){function e(e,i,r,n){t.call(this,e),this.features=r,this.file=i,this.projection=n}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function Wf(t){for(var e=t.dataTransfer.files,i=0,r=e.length;i<r;++i){var n=e.item(i),o=new FileReader;o.addEventListener(M.LOAD,this.handleResult_.bind(this,n)),o.readAsText(n)}}function Kf(t){t.stopPropagation(),t.preventDefault(),t.dataTransfer.dropEffect="copy"}var zf=function(t){function e(e){var i=e||{};t.call(this,{handleEvent:C}),this.formatConstructors_=i.formatConstructors?i.formatConstructors:[],this.projection_=i.projection?Zi(i.projection):null,this.dropListenKeys_=null,this.source_=i.source||null,this.target=i.target?i.target:null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.handleResult_=function(t,e){var i=e.target.result,r=this.getMap(),n=this.projection_;n||(n=r.getView().getProjection());for(var o=this.formatConstructors_,s=[],a=0,h=o.length;a<h;++a){var l=new o[a];if((s=this.tryReadFeatures_(l,i,{featureProjection:n}))&&s.length>0)break}this.source_&&(this.source_.clear(),this.source_.addFeatures(s)),this.dispatchEvent(new Vf(Bf,t,s,n))},e.prototype.registerListeners_=function(){var t=this.getMap();if(t){var e=this.target?this.target:t.getViewport();this.dropListenKeys_=[v(e,M.DROP,Wf,this),v(e,M.DRAGENTER,Kf,this),v(e,M.DRAGOVER,Kf,this),v(e,M.DROP,Kf,this)]}},e.prototype.setActive=function(e){t.prototype.setActive.call(this,e),e?this.registerListeners_():this.unregisterListeners_()},e.prototype.setMap=function(e){this.unregisterListeners_(),t.prototype.setMap.call(this,e),this.getActive()&&this.registerListeners_()},e.prototype.tryReadFeatures_=function(t,e,i){try{return t.readFeatures(e,i)}catch(t){return null}},e.prototype.unregisterListeners_=function(){this.dropListenKeys_&&(this.dropListenKeys_.forEach(S),this.dropListenKeys_=null)},e}(jn),Zf="preload",Hf="useInterimTilesOnError",qf=function(t){function e(e){var i=e||{},r=u({},i);delete r.preload,delete r.useInterimTilesOnError,t.call(this,r),this.setPreload(void 0!==i.preload?i.preload:0),this.setUseInterimTilesOnError(void 0===i.useInterimTilesOnError||i.useInterimTilesOnError),this.type=Po.TILE}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getPreload=function(){return this.get(Zf)},e.prototype.setPreload=function(t){this.set(Zf,t)},e.prototype.getUseInterimTilesOnError=function(){return this.get(Hf)},e.prototype.setUseInterimTilesOnError=function(t){this.set(Hf,t)},e}(On);qf.prototype.getSource;var Jf=qf,Qf=function(t){function e(e){var i=e||{};t.call(this,i),this.type=Po.IMAGE}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(On);Qf.prototype.getSource;var $f=Qf;var tg=function(t){function e(e){t.call(this,{attributions:e.attributions,wrapX:e.wrapX}),this.resolution=void 0,this.distance=void 0!==e.distance?e.distance:20,this.features=[],this.geometryFunction=e.geometryFunction||function(t){var e=t.getGeometry();return te(e.getType()==_i.POINT,10),e},this.source=e.source,v(this.source,M.CHANGE,this.refresh,this)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDistance=function(){return this.distance},e.prototype.getSource=function(){return this.source},e.prototype.loadFeatures=function(t,e,i){this.source.loadFeatures(t,e,i),e!==this.resolution&&(this.clear(),this.resolution=e,this.cluster(),this.addFeatures(this.features))},e.prototype.setDistance=function(t){this.distance=t,this.refresh()},e.prototype.refresh=function(){this.clear(),this.cluster(),this.addFeatures(this.features),t.prototype.refresh.call(this)},e.prototype.cluster=function(){if(void 0!==this.resolution){this.features.length=0;for(var t=[1/0,1/0,-1/0,-1/0],e=this.distance*this.resolution,i=this.source.getFeatures(),r={},n=0,s=i.length;n<s;n++){var a=i[n];if(!(o(a)in r)){var h=this.geometryFunction(a);if(h){Ke(h.getCoordinates(),t),Ge(t,e,t);var l=this.source.getFeaturesInExtent(t);l=l.filter(function(t){var e=o(t);return!(e in r)&&(r[e]=!0,!0)}),this.features.push(this.createCluster(l))}}}}},e.prototype.createCluster=function(t){for(var e=[0,0],i=t.length-1;i>=0;--i){var r=this.geometryFunction(t[i]);r?Se(e,r.getCoordinates()):t.splice(i,1)}xe(e,1/t.length);var n=new Oa(new Gr(e));return n.set("features",t),n},e}(_f),eg=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,r,Oo.IDLE),this.src_=n,this.image_=new Image,null!==o&&(this.image_.crossOrigin=o),this.imageListenerKeys_=null,this.state=Oo.IDLE,this.imageLoadFunction_=s}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getImage=function(){return this.image_},e.prototype.handleImageError_=function(){this.state=Oo.ERROR,this.unlistenImage_(),this.changed()},e.prototype.handleImageLoad_=function(){void 0===this.resolution&&(this.resolution=ai(this.extent)/this.image_.height),this.state=Oo.LOADED,this.unlistenImage_(),this.changed()},e.prototype.load=function(){this.state!=Oo.IDLE&&this.state!=Oo.ERROR||(this.state=Oo.LOADING,this.changed(),this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)],this.imageLoadFunction_(this,this.src_))},e.prototype.setImage=function(t){this.image_=t},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(Io);function ig(t,e,i,r){var n=ir(i,e,t),o=Hi(e,r,i),s=e.getMetersPerUnit();void 0!==s&&(o*=s);var a=t.getMetersPerUnit();void 0!==a&&(o/=a);var h=t.getExtent();if(!h||Ye(h,n)){var l=Hi(t,o,n)/o;isFinite(l)&&l>0&&(o/=l)}return o}function rg(t,e,i,r){var n=i-t,o=r-e,s=Math.sqrt(n*n+o*o);return[Math.round(i+n/s),Math.round(r+o/s)]}function ng(t,e,i,r,n,o,s,a,h,l,u){var p=on(Math.round(i*t),Math.round(i*e));if(0===h.length)return p.canvas;p.scale(i,i);var c=[1/0,1/0,-1/0,-1/0];h.forEach(function(t,e,i){He(c,t.extent)});var d=pi(c),f=ai(c),g=on(Math.round(i*d/r),Math.round(i*f/r)),_=i/r;h.forEach(function(t,e,i){var r=t.extent[0]-c[0],n=-(t.extent[3]-c[3]),o=pi(t.extent),s=ai(t.extent);g.drawImage(t.image,l,l,t.image.width-2*l,t.image.height-2*l,r*_,n*_,o*_,s*_)});var y=li(s);return a.getTriangles().forEach(function(t,e,n){var s=t.source,a=t.target,h=s[0][0],l=s[0][1],u=s[1][0],d=s[1][1],f=s[2][0],_=s[2][1],v=(a[0][0]-y[0])/o,m=-(a[0][1]-y[1])/o,E=(a[1][0]-y[0])/o,S=-(a[1][1]-y[1])/o,T=(a[2][0]-y[0])/o,R=-(a[2][1]-y[1])/o,C=h,x=l;h=0,l=0;var w=function(t){for(var e=t.length,i=0;i<e;i++){for(var r=i,n=Math.abs(t[i][i]),o=i+1;o<e;o++){var s=Math.abs(t[o][i]);s>n&&(n=s,r=o)}if(0===n)return null;var a=t[r];t[r]=t[i],t[i]=a;for(var h=i+1;h<e;h++)for(var l=-t[h][i]/t[i][i],u=i;u<e+1;u++)i==u?t[h][u]=0:t[h][u]+=l*t[i][u]}for(var p=new Array(e),c=e-1;c>=0;c--){p[c]=t[c][e]/t[c][c];for(var d=c-1;d>=0;d--)t[d][e]-=t[d][c]*p[c]}return p}([[u-=C,d-=x,0,0,E-v],[f-=C,_-=x,0,0,T-v],[0,0,u,d,S-m],[0,0,f,_,R-m]]);if(w){p.save(),p.beginPath();var I=(v+E+T)/3,O=(m+S+R)/3,L=rg(I,O,v,m),P=rg(I,O,E,S),M=rg(I,O,T,R);p.moveTo(P[0],P[1]),p.lineTo(L[0],L[1]),p.lineTo(M[0],M[1]),p.clip(),p.transform(w[0],w[2],w[1],w[3],v,m),p.translate(c[0]-C,c[3]-x),p.scale(r/i,-r/i),p.drawImage(g.canvas,0,0),p.restore()}}),u&&(p.save(),p.strokeStyle="black",p.lineWidth=1,a.getTriangles().forEach(function(t,e,i){var r=t.target,n=(r[0][0]-y[0])/o,s=-(r[0][1]-y[1])/o,a=(r[1][0]-y[0])/o,h=-(r[1][1]-y[1])/o,l=(r[2][0]-y[0])/o,u=-(r[2][1]-y[1])/o;p.beginPath(),p.moveTo(a,h),p.lineTo(n,s),p.lineTo(l,u),p.closePath(),p.stroke()}),p.restore()),p.canvas}var og=function(t,e,i,r,n){this.sourceProj_=t,this.targetProj_=e;var o={},s=er(this.targetProj_,this.sourceProj_);this.transformInv_=function(t){var e=t[0]+"/"+t[1];return o[e]||(o[e]=s(t)),o[e]},this.maxSourceExtent_=r,this.errorThresholdSquared_=n*n,this.triangles_=[],this.wrapsXInSource_=!1,this.canWrapXInSource_=this.sourceProj_.canWrapX()&&!!r&&!!this.sourceProj_.getExtent()&&pi(r)==pi(this.sourceProj_.getExtent()),this.sourceWorldWidth_=this.sourceProj_.getExtent()?pi(this.sourceProj_.getExtent()):null,this.targetWorldWidth_=this.targetProj_.getExtent()?pi(this.targetProj_.getExtent()):null;var a=li(i),h=ui(i),l=ri(i),u=ii(i),p=this.transformInv_(a),c=this.transformInv_(h),d=this.transformInv_(l),f=this.transformInv_(u);if(this.addQuad_(a,h,l,u,p,c,d,f,10),this.wrapsXInSource_){var g=1/0;this.triangles_.forEach(function(t,e,i){g=Math.min(g,t.source[0][0],t.source[1][0],t.source[2][0])}),this.triangles_.forEach(function(t){if(Math.max(t.source[0][0],t.source[1][0],t.source[2][0])-g>this.sourceWorldWidth_/2){var e=[[t.source[0][0],t.source[0][1]],[t.source[1][0],t.source[1][1]],[t.source[2][0],t.source[2][1]]];e[0][0]-g>this.sourceWorldWidth_/2&&(e[0][0]-=this.sourceWorldWidth_),e[1][0]-g>this.sourceWorldWidth_/2&&(e[1][0]-=this.sourceWorldWidth_),e[2][0]-g>this.sourceWorldWidth_/2&&(e[2][0]-=this.sourceWorldWidth_);var i=Math.min(e[0][0],e[1][0],e[2][0]);Math.max(e[0][0],e[1][0],e[2][0])-i<this.sourceWorldWidth_/2&&(t.source=e)}}.bind(this))}o={}};og.prototype.addTriangle_=function(t,e,i,r,n,o){this.triangles_.push({source:[r,n,o],target:[t,e,i]})},og.prototype.addQuad_=function(t,e,i,r,n,o,s,a,h){var l=Ae([n,o,s,a]),u=this.sourceWorldWidth_?pi(l)/this.sourceWorldWidth_:null,p=this.sourceWorldWidth_,c=this.sourceProj_.canWrapX()&&u>.5&&u<1,d=!1;if(h>0){if(this.targetProj_.isGlobal()&&this.targetWorldWidth_)d=pi(Ae([t,e,i,r]))/this.targetWorldWidth_>.25||d;!c&&this.sourceProj_.isGlobal()&&u&&(d=u>.25||d)}if(d||!this.maxSourceExtent_||ci(l,this.maxSourceExtent_)){if(!(d||isFinite(n[0])&&isFinite(n[1])&&isFinite(o[0])&&isFinite(o[1])&&isFinite(s[0])&&isFinite(s[1])&&isFinite(a[0])&&isFinite(a[1]))){if(!(h>0))return;d=!0}if(h>0){if(!d){var f,g=[(t[0]+i[0])/2,(t[1]+i[1])/2],_=this.transformInv_(g);if(c)f=(ue(n[0],p)+ue(s[0],p))/2-ue(_[0],p);else f=(n[0]+s[0])/2-_[0];var y=(n[1]+s[1])/2-_[1];d=f*f+y*y>this.errorThresholdSquared_}if(d){if(Math.abs(t[0]-i[0])<=Math.abs(t[1]-i[1])){var v=[(e[0]+i[0])/2,(e[1]+i[1])/2],m=this.transformInv_(v),E=[(r[0]+t[0])/2,(r[1]+t[1])/2],S=this.transformInv_(E);this.addQuad_(t,e,v,E,n,o,m,S,h-1),this.addQuad_(E,v,i,r,S,m,s,a,h-1)}else{var T=[(t[0]+e[0])/2,(t[1]+e[1])/2],R=this.transformInv_(T),C=[(i[0]+r[0])/2,(i[1]+r[1])/2],x=this.transformInv_(C);this.addQuad_(t,T,C,r,n,R,x,a,h-1),this.addQuad_(T,e,i,C,R,o,s,x,h-1)}return}}if(c){if(!this.canWrapXInSource_)return;this.wrapsXInSource_=!0}this.addTriangle_(t,i,r,n,s,a),this.addTriangle_(t,e,i,n,o,s)}},og.prototype.calculateSourceExtent=function(){var t=[1/0,1/0,-1/0,-1/0];return this.triangles_.forEach(function(e,i,r){var n=e.source;qe(t,n[0]),qe(t,n[1]),qe(t,n[2])}),t},og.prototype.getTriangles=function(){return this.triangles_};var sg=og,ag=function(t){function e(e,i,r,n,o,s){var a=e.getExtent(),h=i.getExtent(),l=h?hi(r,h):r,u=ig(e,i,ni(l),n),p=new sg(e,i,l,a,u*wo),c=s(p.calculateSourceExtent(),u,o),d=Oo.LOADED;c&&(d=Oo.IDLE);var f=c?c.getPixelRatio():1;t.call(this,r,n,f,d),this.targetProj_=i,this.maxSourceExtent_=a,this.triangulation_=p,this.targetResolution_=n,this.targetExtent_=r,this.sourceImage_=c,this.sourcePixelRatio_=f,this.canvas_=null,this.sourceListenerKey_=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==Oo.LOADING&&this.unlistenSource_(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.canvas_},e.prototype.getProjection=function(){return this.targetProj_},e.prototype.reproject_=function(){var t=this.sourceImage_.getState();if(t==Oo.LOADED){var e=pi(this.targetExtent_)/this.targetResolution_,i=ai(this.targetExtent_)/this.targetResolution_;this.canvas_=ng(e,i,this.sourcePixelRatio_,this.sourceImage_.getResolution(),this.maxSourceExtent_,this.targetResolution_,this.targetExtent_,this.triangulation_,[{extent:this.sourceImage_.getExtent(),image:this.sourceImage_.getImage()}],0)}this.state=t,this.changed()},e.prototype.load=function(){if(this.state==Oo.IDLE){this.state=Oo.LOADING,this.changed();var t=this.sourceImage_.getState();t==Oo.LOADED||t==Oo.ERROR?this.reproject_():(this.sourceListenerKey_=v(this.sourceImage_,M.CHANGE,function(t){var e=this.sourceImage_.getState();e!=Oo.LOADED&&e!=Oo.ERROR||(this.unlistenSource_(),this.reproject_())},this),this.sourceImage_.load())}},e.prototype.unlistenSource_=function(){S(this.sourceListenerKey_),this.sourceListenerKey_=null},e}(Io),hg="imageloadstart",lg="imageloadend",ug="imageloaderror",pg=function(t){function e(e,i){t.call(this,e),this.image=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L);function cg(t,e){t.getImage().src=e}var dg=function(t){function e(e){t.call(this,{attributions:e.attributions,projection:e.projection,state:e.state}),this.resolutions_=void 0!==e.resolutions?e.resolutions:null,this.reprojectedImage_=null,this.reprojectedRevision_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getResolutions=function(){return this.resolutions_},e.prototype.findNearestResolution=function(t){if(this.resolutions_){var e=Gt(this.resolutions_,t,0);t=this.resolutions_[e]}return t},e.prototype.getImage=function(t,e,i,r){var n=this.getProjection();if(n&&r&&!$i(n,r)){if(this.reprojectedImage_){if(this.reprojectedRevision_==this.getRevision()&&$i(this.reprojectedImage_.getProjection(),r)&&this.reprojectedImage_.getResolution()==e&&Ze(this.reprojectedImage_.getExtent(),t))return this.reprojectedImage_;this.reprojectedImage_.dispose(),this.reprojectedImage_=null}return this.reprojectedImage_=new ag(n,r,t,e,i,function(t,e,i){return this.getImageInternal(t,e,i,n)}.bind(this)),this.reprojectedRevision_=this.getRevision(),this.reprojectedImage_}return n&&(r=n),this.getImageInternal(t,e,i,r)},e.prototype.getImageInternal=function(t,e,i,n){return r()},e.prototype.handleImageChange=function(t){var e=t.target;switch(e.getState()){case Oo.LOADING:this.loading=!0,this.dispatchEvent(new pg(hg,e));break;case Oo.LOADED:this.loading=!1,this.dispatchEvent(new pg(lg,e));break;case Oo.ERROR:this.loading=!1,this.dispatchEvent(new pg(ug,e))}},e}(pf),fg="carmentaserver",gg="geoserver",_g="mapserver",yg="qgis";function vg(t,e){var i=[];Object.keys(e).forEach(function(t){null!==e[t]&&void 0!==e[t]&&i.push(t+"="+encodeURIComponent(e[t]))});var r=i.join("&");return(t=-1===(t=t.replace(/[?&]$/,"")).indexOf("?")?t+"?":t+"&")+r}var mg=[101,101],Eg=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:i.projection,resolutions:i.resolutions}),this.crossOrigin_=void 0!==i.crossOrigin?i.crossOrigin:null,this.url_=i.url,this.imageLoadFunction_=void 0!==i.imageLoadFunction?i.imageLoadFunction:cg,this.params_=i.params||{},this.v13_=!0,this.updateV13_(),this.serverType_=i.serverType,this.hidpi_=void 0===i.hidpi||i.hidpi,this.image_=null,this.imageSize_=[0,0],this.renderedRevision_=0,this.ratio_=void 0!==i.ratio?i.ratio:1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getGetFeatureInfoUrl=function(t,e,i,r){if(void 0!==this.url_){var n=Zi(i),o=this.getProjection();o&&o!==n&&(e=ig(o,n,t,e),t=ir(t,n,o));var s=si(t,e,0,mg),a={SERVICE:"WMS",VERSION:"1.3.0",REQUEST:"GetFeatureInfo",FORMAT:"image/png",TRANSPARENT:!0,QUERY_LAYERS:this.params_.LAYERS};u(a,this.params_,r);var h=Math.floor((t[0]-s[0])/e),l=Math.floor((s[3]-t[1])/e);return a[this.v13_?"I":"X"]=h,a[this.v13_?"J":"Y"]=l,this.getRequestUrl_(s,mg,1,o||n,a)}},e.prototype.getParams=function(){return this.params_},e.prototype.getImageInternal=function(t,e,i,r){if(void 0===this.url_)return null;e=this.findNearestResolution(e),1==i||this.hidpi_&&void 0!==this.serverType_||(i=1);var n=e/i,o=ni(t),s=si(o,n,0,[Math.ceil(pi(t)/n),Math.ceil(ai(t)/n)]),a=si(o,n,0,[Math.ceil(this.ratio_*pi(t)/n),Math.ceil(this.ratio_*ai(t)/n)]),h=this.image_;if(h&&this.renderedRevision_==this.getRevision()&&h.getResolution()==e&&h.getPixelRatio()==i&&Ue(h.getExtent(),s))return h;var l={SERVICE:"WMS",VERSION:"1.3.0",REQUEST:"GetMap",FORMAT:"image/png",TRANSPARENT:!0};u(l,this.params_),this.imageSize_[0]=Math.round(pi(a)/n),this.imageSize_[1]=Math.round(ai(a)/n);var p=this.getRequestUrl_(a,this.imageSize_,i,r,l);return this.image_=new eg(a,e,i,p,this.crossOrigin_,this.imageLoadFunction_),this.renderedRevision_=this.getRevision(),v(this.image_,M.CHANGE,this.handleImageChange,this),this.image_},e.prototype.getImageLoadFunction=function(){return this.imageLoadFunction_},e.prototype.getRequestUrl_=function(t,e,i,r,n){if(te(void 0!==this.url_,9),n[this.v13_?"CRS":"SRS"]=r.getCode(),"STYLES"in this.params_||(n.STYLES=""),1!=i)switch(this.serverType_){case gg:var o=90*i+.5|0;"FORMAT_OPTIONS"in n?n.FORMAT_OPTIONS+=";dpi:"+o:n.FORMAT_OPTIONS="dpi:"+o;break;case _g:n.MAP_RESOLUTION=90*i;break;case fg:case yg:n.DPI=90*i;break;default:te(!1,8)}n.WIDTH=e[0],n.HEIGHT=e[1];var s,a=r.getAxisOrientation();return s=this.v13_&&"ne"==a.substr(0,2)?[t[1],t[0],t[3],t[2]]:t,n.BBOX=s.join(","),vg(this.url_,n)},e.prototype.getUrl=function(){return this.url_},e.prototype.setImageLoadFunction=function(t){this.image_=null,this.imageLoadFunction_=t,this.changed()},e.prototype.setUrl=function(t){t!=this.url_&&(this.url_=t,this.image_=null,this.changed())},e.prototype.updateParams=function(t){u(this.params_,t),this.updateV13_(),this.image_=null,this.changed()},e.prototype.updateV13_=function(){var t=this.params_.VERSION||"1.3.0";this.v13_=function(t,e){for(var i=(""+t).split("."),r=(""+e).split("."),n=0;n<Math.max(i.length,r.length);n++){var o=parseInt(i[n]||"0",10),s=parseInt(r[n]||"0",10);if(o>s)return 1;if(s>o)return-1}return 0}(t,"1.3")>=0},e}(dg);function Sg(t,e,i,r){return void 0!==r?(r[0]=t,r[1]=e,r[2]=i,r):[t,e,i]}function Tg(t,e,i){return t+"/"+e+"/"+i}function Rg(t){return Tg(t[0],t[1],t[2])}function Cg(t,e){var i=/\{z\}/g,r=/\{x\}/g,n=/\{y\}/g,o=/\{-y\}/g;return function(s,a,h){return s?t.replace(i,s[0].toString()).replace(r,s[1].toString()).replace(n,function(){return(-s[2]-1).toString()}).replace(o,function(){var t=s[0],i=e.getFullTileRange(t);return te(i,55),(i.getHeight()+s[2]).toString()}):void 0}}function xg(t){return 1===t.length?t[0]:function(e,i,r){if(e){var n=ue(function(t){return(t[1]<<t[0])+t[2]}(e),t.length);return t[n](e,i,r)}}}function wg(t,e,i){}function Ig(t){var e=[],i=/\{([a-z])-([a-z])\}/.exec(t);if(i){var r,n=i[1].charCodeAt(0),o=i[2].charCodeAt(0);for(r=n;r<=o;++r)e.push(t.replace(i[0],String.fromCharCode(r)));return e}if(i=i=/\{(\d+)-(\d+)\}/.exec(t)){for(var s=parseInt(i[2],10),a=parseInt(i[1],10);a<=s;a++)e.push(t.replace(i[0],a.toString()));return e}return e.push(t),e}var Og=function(t){function e(e,i,r){t.call(this);var n=r||{};this.tileCoord=e,this.state=i,this.interimTile=null,this.key="",this.transition_=void 0===n.transition?250:n.transition,this.transitionStarts_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.changed=function(){this.dispatchEvent(M.CHANGE)},e.prototype.getKey=function(){return this.key+"/"+this.tileCoord},e.prototype.getInterimTile=function(){if(!this.interimTile)return this;var t=this.interimTile;do{if(t.getState()==$t.LOADED)return t;t=t.interimTile}while(t);return this},e.prototype.refreshInterimChain=function(){if(this.interimTile){var t=this.interimTile,e=this;do{if(t.getState()==$t.LOADED){t.interimTile=null;break}t.getState()==$t.LOADING?e=t:t.getState()==$t.IDLE?e.interimTile=t.interimTile:e=t,t=e.interimTile}while(t)}},e.prototype.getTileCoord=function(){return this.tileCoord},e.prototype.getState=function(){return this.state},e.prototype.setState=function(t){this.state=t,this.changed()},e.prototype.load=function(){},e.prototype.getAlpha=function(t,e){if(!this.transition_)return 1;var i=this.transitionStarts_[t];if(i){if(-1===i)return 1}else i=e,this.transitionStarts_[t]=i;var r=e-i+1e3/60;return r>=this.transition_?1:Le(r/this.transition_)},e.prototype.inTransition=function(t){return!!this.transition_&&-1!==this.transitionStarts_[t]},e.prototype.endTransition=function(t){this.transition_&&(this.transitionStarts_[t]=-1)},e}(P);function Lg(){var t=on(1,1);return t.fillStyle="rgba(0,0,0,0)",t.fillRect(0,0,1,1),t.canvas}var Pg=function(t){function e(e,i,r,n,o,s){t.call(this,e,i,s),this.crossOrigin_=n,this.src_=r,this.image_=new Image,null!==n&&(this.image_.crossOrigin=n),this.imageListenerKeys_=null,this.tileLoadFunction_=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==$t.LOADING&&(this.unlistenImage_(),this.image_=Lg()),this.interimTile&&this.interimTile.dispose(),this.state=$t.ABORT,this.changed(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.image_},e.prototype.getKey=function(){return this.src_},e.prototype.handleImageError_=function(){this.state=$t.ERROR,this.unlistenImage_(),this.image_=Lg(),this.changed()},e.prototype.handleImageLoad_=function(){var t=this.image_;t.naturalWidth&&t.naturalHeight?this.state=$t.LOADED:this.state=$t.EMPTY,this.unlistenImage_(),this.changed()},e.prototype.load=function(){this.state==$t.ERROR&&(this.state=$t.IDLE,this.image_=new Image,null!==this.crossOrigin_&&(this.image_.crossOrigin=this.crossOrigin_)),this.state==$t.IDLE&&(this.state=$t.LOADING,this.changed(),this.imageListenerKeys_=[m(this.image_,M.ERROR,this.handleImageError_,this),m(this.image_,M.LOAD,this.handleImageLoad_,this)],this.tileLoadFunction_(this,this.src_))},e.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null},e}(Og),Mg=function(t){function e(e){t.call(this,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.expireCache=function(t){for(;this.canExpireCache();){var e=this.peekLast(),i=e.tileCoord[0].toString();if(i in t&&t[i].contains(e.tileCoord))break;this.pop().dispose()}},e.prototype.pruneExceptNewestZ=function(){if(0!==this.getCount()){var t=function(t){return t.split("/").map(Number)}(this.peekFirstKey())[0];this.forEach(function(e){e.tileCoord[0]!==t&&(this.remove(Rg(e.tileCoord)),e.dispose())},this)}},e}(bo),Fg=function(t){function e(e,i,r,n,o,s,a,h,l,u,p){t.call(this,o,$t.IDLE),this.renderEdges_=void 0!==p&&p,this.pixelRatio_=a,this.gutter_=h,this.canvas_=null,this.sourceTileGrid_=i,this.targetTileGrid_=n,this.wrappedTileCoord_=s||o,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;var c=n.getTileCoordExtent(this.wrappedTileCoord_),d=this.targetTileGrid_.getExtent(),f=this.sourceTileGrid_.getExtent(),g=d?hi(c,d):c;if(0!==ei(g)){var _=e.getExtent();_&&(f=f?hi(f,_):_);var y=n.getResolution(this.wrappedTileCoord_[0]),v=ig(e,r,ni(g),y);if(!isFinite(v)||v<=0)this.state=$t.EMPTY;else{var m=void 0!==u?u:wo;if(this.triangulation_=new sg(e,r,g,f,v*m),0!==this.triangulation_.getTriangles().length){this.sourceZ_=i.getZForResolution(v);var E=this.triangulation_.calculateSourceExtent();if(f&&(e.canWrapX()?(E[1]=oe(E[1],f[1],f[3]),E[3]=oe(E[3],f[1],f[3])):E=hi(E,f)),ei(E)){for(var S=i.getTileRangeForExtentAndZ(E,this.sourceZ_),T=S.minX;T<=S.maxX;T++)for(var R=S.minY;R<=S.maxY;R++){var C=l(this.sourceZ_,T,R,a);C&&this.sourceTiles_.push(C)}0===this.sourceTiles_.length&&(this.state=$t.EMPTY)}else this.state=$t.EMPTY}else this.state=$t.EMPTY}}else this.state=$t.EMPTY}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.disposeInternal=function(){this.state==$t.LOADING&&this.unlistenSources_(),t.prototype.disposeInternal.call(this)},e.prototype.getImage=function(){return this.canvas_},e.prototype.reproject_=function(){var t=[];if(this.sourceTiles_.forEach(function(e,i,r){e&&e.getState()==$t.LOADED&&t.push({extent:this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),image:e.getImage()})}.bind(this)),this.sourceTiles_.length=0,0===t.length)this.state=$t.ERROR;else{var e=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(e),r="number"==typeof i?i:i[0],n="number"==typeof i?i:i[1],o=this.targetTileGrid_.getResolution(e),s=this.sourceTileGrid_.getResolution(this.sourceZ_),a=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=ng(r,n,this.pixelRatio_,s,this.sourceTileGrid_.getExtent(),o,a,this.triangulation_,t,this.gutter_,this.renderEdges_),this.state=$t.LOADED}this.changed()},e.prototype.load=function(){if(this.state==$t.IDLE){this.state=$t.LOADING,this.changed();var t=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(function(e,i,r){var n=e.getState();if(n==$t.IDLE||n==$t.LOADING){t++;var o=v(e,M.CHANGE,function(i){var r=e.getState();r!=$t.LOADED&&r!=$t.ERROR&&r!=$t.EMPTY||(S(o),0===--t&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(o)}}.bind(this)),this.sourceTiles_.forEach(function(t,e,i){t.getState()==$t.IDLE&&t.load()}),0===t&&setTimeout(this.reproject_.bind(this),0)}},e.prototype.unlistenSources_=function(){this.sourcesListenerKeys_.forEach(S),this.sourcesListenerKeys_=null},e}(Og),bg=[0,0,0],Ng=function(t){var e,i,r,n;if(this.minZoom=void 0!==t.minZoom?t.minZoom:0,this.resolutions_=t.resolutions,te((e=this.resolutions_,i=!0,r=function(t,e){return e-t}||Nt,e.every(function(t,n){if(0===n)return!0;var o=r(e[n-1],t);return!(o>0||i&&0===o)})),17),!t.origins)for(var o=0,s=this.resolutions_.length-1;o<s;++o)if(n){if(this.resolutions_[o]/this.resolutions_[o+1]!==n){n=void 0;break}}else n=this.resolutions_[o]/this.resolutions_[o+1];this.zoomFactor_=n,this.maxZoom=this.resolutions_.length-1,this.origin_=void 0!==t.origin?t.origin:null,this.origins_=null,void 0!==t.origins&&(this.origins_=t.origins,te(this.origins_.length==this.resolutions_.length,20));var a=t.extent;void 0===a||this.origin_||this.origins_||(this.origin_=li(a)),te(!this.origin_&&this.origins_||this.origin_&&!this.origins_,18),this.tileSizes_=null,void 0!==t.tileSizes&&(this.tileSizes_=t.tileSizes,te(this.tileSizes_.length==this.resolutions_.length,19)),this.tileSize_=void 0!==t.tileSize?t.tileSize:this.tileSizes_?null:ne,te(!this.tileSize_&&this.tileSizes_||this.tileSize_&&!this.tileSizes_,22),this.extent_=void 0!==a?a:null,this.fullTileRanges_=null,this.tmpSize_=[0,0],void 0!==t.sizes?this.fullTileRanges_=t.sizes.map(function(t,e){return new Ss(Math.min(0,t[0]),Math.max(t[0]-1,-1),Math.min(0,t[1]),Math.max(t[1]-1,-1))},this):a&&this.calculateTileRanges_(a)};Ng.prototype.forEachTileCoord=function(t,e,i){for(var r=this.getTileRangeForExtentAndZ(t,e),n=r.minX,o=r.maxX;n<=o;++n)for(var s=r.minY,a=r.maxY;s<=a;++s)i([e,n,s])},Ng.prototype.forEachTileCoordParentTileRange=function(t,e,i,r,n){var o,s,a,h=null,l=t[0]-1;for(2===this.zoomFactor_?(s=t[1],a=t[2]):h=this.getTileCoordExtent(t,n);l>=this.minZoom;){if(o=2===this.zoomFactor_?Es(s=Math.floor(s/2),s,a=Math.floor(a/2),a,r):this.getTileRangeForExtentAndZ(h,l,r),e.call(i,l,o))return!0;--l}return!1},Ng.prototype.getExtent=function(){return this.extent_},Ng.prototype.getMaxZoom=function(){return this.maxZoom},Ng.prototype.getMinZoom=function(){return this.minZoom},Ng.prototype.getOrigin=function(t){return this.origin_?this.origin_:this.origins_[t]},Ng.prototype.getResolution=function(t){return this.resolutions_[t]},Ng.prototype.getResolutions=function(){return this.resolutions_},Ng.prototype.getTileCoordChildTileRange=function(t,e,i){if(t[0]<this.maxZoom){if(2===this.zoomFactor_){var r=2*t[1],n=2*t[2];return Es(r,r+1,n,n+1,e)}var o=this.getTileCoordExtent(t,i);return this.getTileRangeForExtentAndZ(o,t[0]+1,e)}return null},Ng.prototype.getTileRangeExtent=function(t,e,i){var r=this.getOrigin(t),n=this.getResolution(t),o=_n(this.getTileSize(t),this.tmpSize_),s=r[0]+e.minX*o[0]*n,a=r[0]+(e.maxX+1)*o[0]*n;return Ve(s,r[1]+e.minY*o[1]*n,a,r[1]+(e.maxY+1)*o[1]*n,i)},Ng.prototype.getTileRangeForExtentAndZ=function(t,e,i){var r=bg;this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,r);var n=r[1],o=r[2];return this.getTileCoordForXYAndZ_(t[2],t[3],e,!0,r),Es(n,r[1],o,r[2],i)},Ng.prototype.getTileCoordCenter=function(t){var e=this.getOrigin(t[0]),i=this.getResolution(t[0]),r=_n(this.getTileSize(t[0]),this.tmpSize_);return[e[0]+(t[1]+.5)*r[0]*i,e[1]+(t[2]+.5)*r[1]*i]},Ng.prototype.getTileCoordExtent=function(t,e){var i=this.getOrigin(t[0]),r=this.getResolution(t[0]),n=_n(this.getTileSize(t[0]),this.tmpSize_),o=i[0]+t[1]*n[0]*r,s=i[1]+t[2]*n[1]*r;return Ve(o,s,o+n[0]*r,s+n[1]*r,e)},Ng.prototype.getTileCoordForCoordAndResolution=function(t,e,i){return this.getTileCoordForXYAndResolution_(t[0],t[1],e,!1,i)},Ng.prototype.getTileCoordForXYAndResolution_=function(t,e,i,r,n){var o=this.getZForResolution(i),s=i/this.getResolution(o),a=this.getOrigin(o),h=_n(this.getTileSize(o),this.tmpSize_),l=r?.5:0,u=r?0:.5,p=Math.floor((t-a[0])/i+l),c=Math.floor((e-a[1])/i+u),d=s*p/h[0],f=s*c/h[1];return r?(d=Math.ceil(d)-1,f=Math.ceil(f)-1):(d=Math.floor(d),f=Math.floor(f)),Sg(o,d,f,n)},Ng.prototype.getTileCoordForXYAndZ_=function(t,e,i,r,n){var o=this.getOrigin(i),s=this.getResolution(i),a=_n(this.getTileSize(i),this.tmpSize_),h=r?.5:0,l=r?0:.5,u=Math.floor((t-o[0])/s+h),p=Math.floor((e-o[1])/s+l),c=u/a[0],d=p/a[1];return r?(c=Math.ceil(c)-1,d=Math.ceil(d)-1):(c=Math.floor(c),d=Math.floor(d)),Sg(i,c,d,n)},Ng.prototype.getTileCoordForCoordAndZ=function(t,e,i){return this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,i)},Ng.prototype.getTileCoordResolution=function(t){return this.resolutions_[t[0]]},Ng.prototype.getTileSize=function(t){return this.tileSize_?this.tileSize_:this.tileSizes_[t]},Ng.prototype.getFullTileRange=function(t){return this.fullTileRanges_?this.fullTileRanges_[t]:null},Ng.prototype.getZForResolution=function(t,e){return oe(Gt(this.resolutions_,t,e||0),this.minZoom,this.maxZoom)},Ng.prototype.calculateTileRanges_=function(t){for(var e=this.resolutions_.length,i=new Array(e),r=this.minZoom;r<e;++r)i[r]=this.getTileRangeForExtentAndZ(t,r);this.fullTileRanges_=i};var Ag=Ng;function Gg(t){var e=t.getDefaultTileGrid();return e||(e=function(t,e,i,r){return function(t,e,i,r){var n=void 0!==r?r:be.TOP_LEFT,o=Dg(t,e,i);return new Ag({extent:t,origin:oi(t,n),resolutions:o,tileSize:i})}(kg(t),e,i,r)}(t),t.setDefaultTileGrid(e)),e}function Dg(t,e,i){for(var r=void 0!==e?e:re,n=ai(t),o=pi(t),s=_n(void 0!==i?i:ne),a=Math.max(o/s[0],n/s[1]),h=r+1,l=new Array(h),u=0;u<h;++u)l[u]=a/Math.pow(2,u);return l}function kg(t){var e=(t=Zi(t)).getExtent();if(!e){var i=180*Ti[Ri.DEGREES]/t.getMetersPerUnit();e=Ve(-i,-i,i,i)}return e}var Yg=function(t){function e(e){t.call(this,{attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,projection:e.projection,state:e.state,wrapX:e.wrapX}),this.opaque_=void 0!==e.opaque&&e.opaque,this.tilePixelRatio_=void 0!==e.tilePixelRatio?e.tilePixelRatio:1,this.tileGrid=void 0!==e.tileGrid?e.tileGrid:null,this.tileCache=new Mg(e.cacheSize),this.tmpSize=[0,0],this.key_=e.key||"",this.tileOptions={transition:e.transition}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){return this.tileCache.canExpireCache()},e.prototype.expireCache=function(t,e){var i=this.getTileCacheForProjection(t);i&&i.expireCache(e)},e.prototype.forEachLoadedTile=function(t,e,i,r){var n=this.getTileCacheForProjection(t);if(!n)return!1;for(var o,s,a,h=!0,l=i.minX;l<=i.maxX;++l)for(var u=i.minY;u<=i.maxY;++u)s=Tg(e,l,u),a=!1,n.containsKey(s)&&(a=(o=n.get(s)).getState()===$t.LOADED)&&(a=!1!==r(o)),a||(h=!1);return h},e.prototype.getGutterForProjection=function(t){return 0},e.prototype.getKey=function(){return this.key_},e.prototype.setKey=function(t){this.key_!==t&&(this.key_=t,this.changed())},e.prototype.getOpaque=function(t){return this.opaque_},e.prototype.getResolutions=function(){return this.tileGrid.getResolutions()},e.prototype.getTile=function(t,e,i,n,o){return r()},e.prototype.getTileGrid=function(){return this.tileGrid},e.prototype.getTileGridForProjection=function(t){return this.tileGrid?this.tileGrid:Gg(t)},e.prototype.getTileCacheForProjection=function(t){var e=this.getProjection();return e&&!$i(e,t)?null:this.tileCache},e.prototype.getTilePixelRatio=function(t){return this.tilePixelRatio_},e.prototype.getTilePixelSize=function(t,e,i){var r,n,o,s=this.getTileGridForProjection(i),a=this.getTilePixelRatio(e),h=_n(s.getTileSize(t),this.tmpSize);return 1==a?h:(r=h,n=a,void 0===(o=this.tmpSize)&&(o=[0,0]),o[0]=r[0]*n+.5|0,o[1]=r[1]*n+.5|0,o)},e.prototype.getTileCoordForTileUrlFunction=function(t,e){var i=void 0!==e?e:this.getProjection(),r=this.getTileGridForProjection(i);return this.getWrapX()&&i.isGlobal()&&(t=function(t,e,i){var r=e[0],n=t.getTileCoordCenter(e),o=kg(i);if(Ye(o,n))return e;var s=pi(o),a=Math.ceil((o[0]-n[0])/s);return n[0]+=s*a,t.getTileCoordForCoordAndZ(n,r)}(r,t,i)),function(t,e){var i=t[0],r=t[1],n=t[2];if(e.getMinZoom()>i||i>e.getMaxZoom())return!1;var o,s=e.getExtent();return!(o=s?e.getTileRangeForExtentAndZ(s,i):e.getFullTileRange(i))||o.containsXY(r,n)}(t,r)?t:null},e.prototype.refresh=function(){this.tileCache.clear(),this.changed()},e.prototype.useTile=function(t,e,i,r){},e}(pf),Ug=function(t){function e(e,i){t.call(this,e),this.tile=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(L),jg={TILELOADSTART:"tileloadstart",TILELOADEND:"tileloadend",TILELOADERROR:"tileloaderror"};function Xg(t,e){t.getImage().src=e}var Bg=function(t){function e(e){t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,opaque:e.opaque,projection:e.projection,state:e.state,tileGrid:e.tileGrid,tileLoadFunction:e.tileLoadFunction?e.tileLoadFunction:Xg,tilePixelRatio:e.tilePixelRatio,tileUrlFunction:e.tileUrlFunction,url:e.url,urls:e.urls,wrapX:e.wrapX,transition:e.transition,key:e.key,attributionsCollapsible:e.attributionsCollapsible}),this.crossOrigin=void 0!==e.crossOrigin?e.crossOrigin:null,this.tileClass=void 0!==e.tileClass?e.tileClass:Pg,this.tileCacheForProjection={},this.tileGridForProjection={},this.reprojectionErrorThreshold_=e.reprojectionErrorThreshold,this.renderReprojectionEdges_=!1}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.canExpireCache=function(){if(this.tileCache.canExpireCache())return!0;for(var t in this.tileCacheForProjection)if(this.tileCacheForProjection[t].canExpireCache())return!0;return!1},e.prototype.expireCache=function(t,e){var i=this.getTileCacheForProjection(t);for(var r in this.tileCache.expireCache(this.tileCache==i?e:{}),this.tileCacheForProjection){var n=this.tileCacheForProjection[r];n.expireCache(n==i?e:{})}},e.prototype.getGutterForProjection=function(t){return this.getProjection()&&t&&!$i(this.getProjection(),t)?0:this.getGutter()},e.prototype.getGutter=function(){return 0},e.prototype.getOpaque=function(e){return!(this.getProjection()&&e&&!$i(this.getProjection(),e))&&t.prototype.getOpaque.call(this,e)},e.prototype.getTileGridForProjection=function(t){var e=this.getProjection();if(!this.tileGrid||e&&!$i(e,t)){var i=o(t);return i in this.tileGridForProjection||(this.tileGridForProjection[i]=Gg(t)),this.tileGridForProjection[i]}return this.tileGrid},e.prototype.getTileCacheForProjection=function(t){var e=this.getProjection();if(!e||$i(e,t))return this.tileCache;var i=o(t);return i in this.tileCacheForProjection||(this.tileCacheForProjection[i]=new Mg(this.tileCache.highWaterMark)),this.tileCacheForProjection[i]},e.prototype.createTile_=function(t,e,i,r,n,o){var s=[t,e,i],a=this.getTileCoordForTileUrlFunction(s,n),h=a?this.tileUrlFunction(a,r,n):void 0,l=new this.tileClass(s,void 0!==h?$t.IDLE:$t.EMPTY,void 0!==h?h:"",this.crossOrigin,this.tileLoadFunction,this.tileOptions);return l.key=o,v(l,M.CHANGE,this.handleTileChange,this),l},e.prototype.getTile=function(t,e,i,r,n){var o=this.getProjection();if(o&&n&&!$i(o,n)){var s,a=this.getTileCacheForProjection(n),h=[t,e,i],l=Rg(h);a.containsKey(l)&&(s=a.get(l));var u=this.getKey();if(s&&s.key==u)return s;var p=this.getTileGridForProjection(o),c=this.getTileGridForProjection(n),d=this.getTileCoordForTileUrlFunction(h,n),f=new Fg(o,p,n,c,h,d,this.getTilePixelRatio(r),this.getGutter(),function(t,e,i,r){return this.getTileInternal(t,e,i,r,o)}.bind(this),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_);return f.key=u,s?(f.interimTile=s,f.refreshInterimChain(),a.replace(l,f)):a.set(l,f),f}return this.getTileInternal(t,e,i,r,o||n)},e.prototype.getTileInternal=function(t,e,i,r,n){var o=null,s=Tg(t,e,i),a=this.getKey();if(this.tileCache.containsKey(s)){if((o=this.tileCache.get(s)).key!=a){var h=o;o=this.createTile_(t,e,i,r,n,a),h.getState()==$t.IDLE?o.interimTile=h.interimTile:o.interimTile=h,o.refreshInterimChain(),this.tileCache.replace(s,o)}}else o=this.createTile_(t,e,i,r,n,a),this.tileCache.set(s,o);return o},e.prototype.setRenderReprojectionEdges=function(t){if(this.renderReprojectionEdges_!=t){for(var e in this.renderReprojectionEdges_=t,this.tileCacheForProjection)this.tileCacheForProjection[e].clear();this.changed()}},e.prototype.setTileGridForProjection=function(t,e){var i=Zi(t);if(i){var r=o(i);r in this.tileGridForProjection||(this.tileGridForProjection[r]=e)}},e}(function(t){function e(e){t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,opaque:e.opaque,projection:e.projection,state:e.state,tileGrid:e.tileGrid,tilePixelRatio:e.tilePixelRatio,wrapX:e.wrapX,transition:e.transition,key:e.key,attributionsCollapsible:e.attributionsCollapsible}),this.generateTileUrlFunction_=!e.tileUrlFunction,this.tileLoadFunction=e.tileLoadFunction,this.tileUrlFunction=e.tileUrlFunction?e.tileUrlFunction.bind(this):wg,this.urls=null,e.urls?this.setUrls(e.urls):e.url&&this.setUrl(e.url),e.tileUrlFunction&&this.setTileUrlFunction(e.tileUrlFunction,this.key_),this.tileLoadingKeys_={}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getTileLoadFunction=function(){return this.tileLoadFunction},e.prototype.getTileUrlFunction=function(){return this.tileUrlFunction},e.prototype.getUrls=function(){return this.urls},e.prototype.handleTileChange=function(t){var e,i=t.target,r=o(i),n=i.getState();n==$t.LOADING?(this.tileLoadingKeys_[r]=!0,e=jg.TILELOADSTART):r in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[r],e=n==$t.ERROR?jg.TILELOADERROR:n==$t.LOADED||n==$t.ABORT?jg.TILELOADEND:void 0),null!=e&&this.dispatchEvent(new Ug(e,i))},e.prototype.setTileLoadFunction=function(t){this.tileCache.clear(),this.tileLoadFunction=t,this.changed()},e.prototype.setTileUrlFunction=function(t,e){this.tileUrlFunction=t,this.tileCache.pruneExceptNewestZ(),void 0!==e?this.setKey(e):this.changed()},e.prototype.setUrl=function(t){var e=this.urls=Ig(t);this.setUrls(e)},e.prototype.setUrls=function(t){this.urls=t;var e=t.join("\n");this.generateTileUrlFunction_?this.setTileUrlFunction(function(t,e){for(var i=t.length,r=new Array(i),n=0;n<i;++n)r[n]=Cg(t[n],e);return xg(r)}(t,this.tileGrid),e):this.setKey(e)},e.prototype.useTile=function(t,e,i){var r=Tg(t,e,i);this.tileCache.containsKey(r)&&this.tileCache.get(r)},e}(Yg)),Vg={KVP:"KVP",REST:"REST"},Wg=function(t){function e(e){t.call(this,{extent:e.extent,origin:e.origin,origins:e.origins,resolutions:e.resolutions,tileSize:e.tileSize,tileSizes:e.tileSizes,sizes:e.sizes}),this.matrixIds_=e.matrixIds}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getMatrixId=function(t){return this.matrixIds_[t]},e.prototype.getMatrixIds=function(){return this.matrixIds_},e}(Ag);var Kg=function(t){function e(e){var i=void 0!==e.requestEncoding?e.requestEncoding:Vg.KVP,r=e.tileGrid,n=e.urls;void 0===n&&void 0!==e.url&&(n=Ig(e.url)),t.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,crossOrigin:e.crossOrigin,projection:e.projection,reprojectionErrorThreshold:e.reprojectionErrorThreshold,tileClass:e.tileClass,tileGrid:r,tileLoadFunction:e.tileLoadFunction,tilePixelRatio:e.tilePixelRatio,tileUrlFunction:wg,urls:n,wrapX:void 0!==e.wrapX&&e.wrapX,transition:e.transition}),this.version_=void 0!==e.version?e.version:"1.0.0",this.format_=void 0!==e.format?e.format:"image/jpeg",this.dimensions_=void 0!==e.dimensions?e.dimensions:{},this.layer_=e.layer,this.matrixSet_=e.matrixSet,this.style_=e.style,this.requestEncoding_=i,this.setKey(this.getKeyForDimensions_()),n&&n.length>0&&(this.tileUrlFunction=xg(n.map(zg.bind(this))))}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setUrls=function(t){this.urls=t;var e=t.join("\n");this.setTileUrlFunction(xg(t.map(zg.bind(this))),e)},e.prototype.getDimensions=function(){return this.dimensions_},e.prototype.getFormat=function(){return this.format_},e.prototype.getLayer=function(){return this.layer_},e.prototype.getMatrixSet=function(){return this.matrixSet_},e.prototype.getRequestEncoding=function(){return this.requestEncoding_},e.prototype.getStyle=function(){return this.style_},e.prototype.getVersion=function(){return this.version_},e.prototype.getKeyForDimensions_=function(){var t=0,e=[];for(var i in this.dimensions_)e[t++]=i+"-"+this.dimensions_[i];return e.join("/")},e.prototype.updateDimensions=function(t){u(this.dimensions_,t),this.setKey(this.getKeyForDimensions_())},e}(Bg);function zg(t){var e=this.requestEncoding_,i={layer:this.layer_,style:this.style_,tilematrixset:this.matrixSet_};e==Vg.KVP&&u(i,{Service:"WMTS",Request:"GetTile",Version:this.version_,Format:this.format_}),t=e==Vg.KVP?vg(t,i):t.replace(/\{(\w+?)\}/g,function(t,e){return e.toLowerCase()in i?i[e.toLowerCase()]:t});var r=this.tileGrid,n=this.dimensions_;return function(i,o,s){if(i){var a={TileMatrix:r.getMatrixId(i[0]),TileCol:i[1],TileRow:-i[2]-1};u(a,n);var h=t;return h=e==Vg.KVP?vg(h,a):h.replace(/\{(\w+?)\}/g,function(t,e){return a[e]})}}}var Zg=function(t){function e(e){var i=e||{};t.call(this,{attributions:i.attributions,projection:i.projection,resolutions:i.resolutions,state:i.state}),this.canvasFunction_=i.canvasFunction,this.canvas_=null,this.renderedRevision_=0,this.ratio_=void 0!==i.ratio?i.ratio:1.5}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getImageInternal=function(t,e,i,r){e=this.findNearestResolution(e);var n=this.canvas_;if(n&&this.renderedRevision_==this.getRevision()&&n.getResolution()==e&&n.getPixelRatio()==i&&Ue(n.getExtent(),t))return n;fi(t=t.slice(),this.ratio_);var o=[pi(t)/e*i,ai(t)/e*i],s=this.canvasFunction_.call(this,t,e,i,o,r);return s&&(n=new Lo(t,e,i,s)),this.canvas_=n,this.renderedRevision_=this.getRevision(),n},e}(dg);i.d(e,"array",function(){return Hg}),i.d(e,"asserts",function(){return qg}),i.d(e,"color",function(){return Jg}),i.d(e,"math",function(){return Qg}),i.d(e,"string",function(){return $g}),i.d(e,"control",function(){return t_}),i.d(e,"events",function(){return e_}),i.d(e,"extent",function(){return i_}),i.d(e,"geom",function(){return r_}),i.d(e,"featureloader",function(){return n_}),i.d(e,"format",function(){return o_}),i.d(e,"interaction",function(){return s_}),i.d(e,"layer",function(){return a_}),i.d(e,"Observable",function(){return h_}),i.d(e,"Object",function(){return l_}),i.d(e,"proj",function(){return u_}),i.d(e,"render",function(){return p_}),i.d(e,"source",function(){return c_}),i.d(e,"style",function(){return d_}),i.d(e,"xml",function(){return f_}),i.d(e,"VERSION",function(){return s}),i.d(e,"Map",function(){return ca}),i.d(e,"View",function(){return nn}),i.d(e,"Overlay",function(){return ga}),i.d(e,"OverlayPositioning",function(){return da}),i.d(e,"Feature",function(){return Oa}),i.d(e,"Collection",function(){return Y}),i.d(e,"MapEventType",function(){return qt}),i.d(e,"MapBrowserEventType",function(){return Q}),i.d(e,"Image",function(){return eg}),Oa.createStyleFunction=Ia;const Hg={};Hg.extend=kt,Hg.includes=At;const qg={};qg.assert=te;const Jg={};Jg.asArray=es,Jg.asString=$o;const Qg={};Qg.toRadians=le;const $g={};$g.padNumber=Ee;const t_={};t_.OverviewMap=ya,t_.ScaleLine=Ta,t_.Zoom=bn,t_.ZoomSlider=xa,t_.ZoomSlider.render=Ca,t_.ZoomToExtent=wa;const e_={};e_.EventType=M,e_.listen=v,e_.unlisten=E,e_.condition={shiftKeyOnly:$n};const i_={};i_.getWidth=pi,i_.getHeight=ai,i_.containsCoordinate=Ye,i_.containsExtent=Ue,i_.buffer=Ge,i_.boundingExtent=Ae;const r_={};r_.Point=Gr,r_.MultiPoint=La,r_.LineString=Fa,r_.MultiLineString=ba,r_.Polygon=qr,r_.MultiPolygon=Na,r_.GeometryCollection=ka,r_.Circle=Ga,r_.GeometryType=_i,r_.GeometryLayout=yi,r_.flat={deflateCoordinates:xr,inflateCoordinates:Ir,linearRingLength:function(t,e,i,r){var n=Ls(t,e,i,r),o=t[i-r]-t[e],s=t[i-r+1]-t[e+1];return n+=Math.sqrt(o*o+s*s)}};const n_={};n_.xhr=Ua;const o_={};o_.Feature=Oa,o_.Feature.transformWithOptions=Ba,o_.GeoJSON=Za,o_.GMLBase=Eh,o_.GML=Yh,o_.GML2=Xp,o_.GML3=Dh,o_.GML32=of,o_.GPX=El,o_.KML=kp,o_.WFS=mc,o_.WKT=jc,o_.WMSCapabilities=gd,o_.WMSGetFeatureInfo=_d,o_.WMTSCapabilities=Hd,o_.TopoJSON=rf,o_.xsd={readDecimal:Ch,readBoolean:Sh,readString:Oh,readNonNegativeInteger:wh,readDateTime:Rh,writeStringTextNode:bh,writeCDATASection:Ph,writeDecimalTextNode:Mh,writeBooleanTextNode:Lh,writeNonNegativeIntegerTextNode:Fh};const s_={};s_.defaults=xo,s_.Draw=Sf,s_.Pointer=no,s_.Translate=wf,s_.Snap=Of,s_.Select=bf,s_.Modify=Xf,s_.DragAndDrop=zf,s_.DoubleClickZoom=Bn;const a_={};a_.Layer=On,a_.Tile=Jf,a_.Image=$f,a_.Vector=hf;const h_={unByKey:function(t){if(Array.isArray(t))for(var e=0,i=t.length;e<i;++e)S(t[e]);else S(t)}},l_={};l_.getChangeEventType=A;const u_={};u_.METERS_PER_UNIT=Ti,u_.Projection=xi,u_.addEquivalentProjections=qi,u_.get=Zi,u_.transform=ir,u_.transformExtent=rr,u_.getTransform=er,u_.Units=Ri,u_.proj4={register:function(t){var e,i,r,n,o,s,a,h,l=Object.keys(t.defs),u=l.length;for(e=0;e<u;++e){var p=l[e];if(!Zi(p)){var c=t.defs(p);zi(new xi({code:p,axisOrientation:c.axis,metersPerUnit:c.to_meter,units:c.units}))}}for(e=0;e<u;++e){var d=l[e],f=Zi(d);for(i=0;i<u;++i){var g=l[i],_=Zi(g);if(!Vi(d,g))if(t.defs[d]===t.defs[g])qi([f,_]);else{var y=t(d,g);r=f,n=_,o=y.forward,s=y.inverse,a=void 0,h=void 0,a=Zi(r),h=Zi(n),Bi(a,h,Qi(o)),Bi(h,a,Qi(s))}}}}},u_.EPSG4326={METERS_PER_UNIT:Ai,PROJECTIONS:Di};const p_={toContext:function(t,e){var i=t.canvas,r=e||{},n=r.pixelRatio||z,o=r.size;o&&(i.width=o[0]*n,i.height=o[1]*n,i.style.width=o[0]+"px",i.style.height=o[1]+"px");var s=[0,0,i.width,i.height],a=ur([1,0,0,1,0,0],n,n);return new as(t,n,s,a,0)}};p_.EventType=Qt;const c_={};c_.Vector=_f,c_.Cluster=tg,c_.ImageWMS=Eg,c_.WMTS=Kg,c_.WMTS.optionsFromCapabilities=function(t,e){var i=Yt(t.Contents.Layer,function(t,i,r){return t.Identifier==e.layer});if(null===i)return null;var r,n=t.Contents.TileMatrixSet;(r=i.TileMatrixSetLink.length>1?jt(i.TileMatrixSetLink,"projection"in e?function(t,i,r){var o=Yt(n,function(e){return e.Identifier==t.TileMatrixSet}).SupportedCRS,s=Zi(o.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(o),a=Zi(e.projection);return s&&a?$i(s,a):o==e.projection}:function(t,i,r){return t.TileMatrixSet==e.matrixSet}):0)<0&&(r=0);var o=i.TileMatrixSetLink[r].TileMatrixSet,s=i.TileMatrixSetLink[r].TileMatrixSetLimits,a=i.Format[0];"format"in e&&(a=e.format),(r=jt(i.Style,function(t,i,r){return"style"in e?t.Title==e.style:t.isDefault}))<0&&(r=0);var h=i.Style[r].Identifier,l={};"Dimension"in i&&i.Dimension.forEach(function(t,e,i){var r=t.Identifier,n=t.Default;void 0===n&&(n=t.Value[0]),l[r]=n});var u,p=Yt(t.Contents.TileMatrixSet,function(t,e,i){return t.Identifier==o}),c=p.SupportedCRS;if(c&&(u=Zi(c.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(c)),"projection"in e){var d=Zi(e.projection);d&&(u&&!$i(d,u)||(u=d))}var f,g,_=i.WGS84BoundingBox;if(void 0!==_){var y=Zi("EPSG:4326").getExtent();g=_[0]==y[0]&&_[2]==y[2],f=rr(_,"EPSG:4326",u);var v=u.getExtent();v&&(Ue(v,f)||(f=void 0))}var m=function(t,e,i){var r=[],n=[],o=[],s=[],a=[],h=void 0!==i?i:[],l=t.SupportedCRS,u=Zi(l.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||Zi(l),p=u.getMetersPerUnit(),c="ne"==u.getAxisOrientation().substr(0,2);return t.TileMatrix.sort(function(t,e){return e.ScaleDenominator-t.ScaleDenominator}),t.TileMatrix.forEach(function(e){if(!(h.length>0)||Yt(h,function(i){return e.Identifier==i.TileMatrix||-1===e.Identifier.indexOf(":")&&t.Identifier+":"+e.Identifier===i.TileMatrix})){n.push(e.Identifier);var i=28e-5*e.ScaleDenominator/p,l=e.TileWidth,u=e.TileHeight;c?o.push([e.TopLeftCorner[1],e.TopLeftCorner[0]]):o.push(e.TopLeftCorner),r.push(i),s.push(l==u?l:[l,u]),a.push([e.MatrixWidth,-e.MatrixHeight])}}),new Wg({extent:e,origins:o,resolutions:r,matrixIds:n,tileSizes:s,sizes:a})}(p,f,s),E=[],S=e.requestEncoding;if(S=void 0!==S?S:"","OperationsMetadata"in t&&"GetTile"in t.OperationsMetadata)for(var T=t.OperationsMetadata.GetTile.DCP.HTTP.Get,R=0,C=T.length;R<C;++R)if(T[R].Constraint){var x=Yt(T[R].Constraint,function(t){return"GetEncoding"==t.name}).AllowedValues.Value;if(""===S&&(S=x[0]),S!==Vg.KVP)break;At(x,Vg.KVP)&&E.push(T[R].href)}else T[R].href&&(S=Vg.KVP,E.push(T[R].href));return 0===E.length&&(S=Vg.REST,i.ResourceURL.forEach(function(t){"tile"===t.resourceType&&(a=t.format,E.push(t.template))})),{urls:E,layer:e.layer,matrixSet:o,format:a,projection:u,requestEncoding:S,tileGrid:m,style:h,dimensions:l,wrapX:g,crossOrigin:e.crossOrigin}},c_.TileEventType=jg,c_.VectorEventType=cf,c_.ImageCanvas=Zg,c_.Image={defaultImageLoadFunction:cg};const d_={};d_.Style=kl,d_.RegularShape=Ml,d_.Circle=Fl,d_.Fill=Tl,d_.Icon=Ol,d_.Stroke=Pl,d_.Style=kl,d_.Text=zl,d_.IconAnchorUnits=Rl,d_.IconOrigin=xl;const f_={};f_.parse=th,f_.parseNode=ch,f_.createElementNS=Ja,f_.pushParseAndPop=dh,f_.pushSerializeAndPop=gh,f_.makeStructureNS=ph,f_.getAllTextContent=Qa,f_.makeChildAppender=sh,f_.makeReplacer=rh,f_.makeSequence=uh,f_.makeArrayPusher=ih,f_.makeArrayExtender=eh,f_.makeArraySerializer=ah,f_.makeObjectPropertySetter=oh,f_.makeSimpleNodeFactory=hh,f_.OBJECT_PROPERTY_NODE_FACTORY=lh,f_.XML_SCHEMA_INSTANCE_URI=qa,f_.DOCUMENT=Ha}]);
/*
Name: autoComplete
Author: Raymond Camden & Andy Matthews
Contributors: Jim Pease (@jmpease)
Website: http://raymondcamden.com/
http://andyMatthews.net
Packed With: http://jsutility.pjoneil.net/
Version: 1.4
Modificado por Fernando Lacunza
*/

var TC = TC || {};
TC.UI = TC.UI || {};

(function() {    

    var isPlainObject = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
    };

    var isFunction = function(fn) {
        return typeof fn == 'function';
    };

    var extend = function() {
        // Variables
        var extended = {};
        var deep = false;
        var i = 0;

        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }

        // Merge the object into the extended object
        var merge = function(obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    // If property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(extended[prop], obj[prop]);
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };

        // Loop through each object and conduct a merge
        for (; i < arguments.length; i++) {
            merge(arguments[i]);
        }

        return extended;

    };    

    var autocomplete = {
        defaults: {
            method: 'GET',
            cancelRequests: false,
            target: null,
            source: null,
            callback: null,
            link: null,
            minLength: 0,
            matchFromStart: true
        },
        openXHR: {},
        cache: {}
    },
        
        buildItems = function(inputText, data, settings) {
            var html = [];
            if (data) {
                if (settings.buildHTML) {

                    settings.target.innerHTML = settings.buildHTML({ results: data });

                    //var template = document.createElement('template');
                    //template.innerHTML = settings.buildHTML({ results: data });

                    //(template.content ? template.content : template).childNodes.forEach(function(childNode) {
                    //    settings.target.appendChild(childNode);
                    //});                    
                }
                else {
                    for (var i = 0; i < data.length; i++) {
                        var elm = data[i];
                        // are we working with objects or strings?
                        if (isPlainObject(elm)) {
                            html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm.id) + '">' + elm.label + '</a></li>';
                        } else {
                            html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm) + '">' + elm + '</a></li>';
                        }
                    }

                    var template = document.createElement('template');
                    template.innerHTML = html.join('');

                    settings.target.appendChild(template.content ? template.content.firstChild : template.firstChild);
                }

            }


            // is there a callback?
            if (settings.callback !== null && isFunction(settings.callback)) {
                attachCallback(settings);
            }

            if (inputText.value.length > 0) {
                inputText.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
            } else {
                inputText.dispatchEvent(new CustomEvent("targetCleared.autocomplete"));
            }
        },
        attachCallback = function(settings) {
            settings.target.querySelectorAll('li a').forEach(function(element) {
                element.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    settings.callback(e);
                });
            });

            //$('li a', $(settings.target)).on('click.autocomplete', function(e) {
            //    e.stopPropagation();
            //    e.preventDefault();
            //    settings.callback(e);
            //});
        },
        clearTarget = function(inputText, target) {
            //$target.html('').closest("fieldset").removeClass("ui-search-active");
            target.innerHTML = '';

            /* provisional el tema del fieldset */
            //document.querySelector("fieldset.ui-search-active").classList.remove("ui-search-active");

            inputText.dispatchEvent(new CustomEvent("targetCleared.autocomplete"));
        },
        handleInput = function(e) {
            var inputText = e.target,
                id = inputText.getAttribute("id"),
                text,
                data,
                autocomplete = inputText.getAttribute("autocomplete"),
                element_text,
                re;
            if (autocomplete) {
                var settings = this.settings;
                var openXHR = autocomplete.openXHR;
                // get the current text of the input field
                text = inputText.value;
                // if we don't have enough text zero out the target
                if (text.length < settings.minLength) {
                    clearTarget(inputText, settings.target);
                } else {
                    // are we looking at a source array or remote data?
                    if (Array.isArray(settings.source)) {
                        data = settings.source.sort().filter(function(element) {
                            // matching from start, or anywhere in the string?
                            if (settings.matchFromStart) {
                                // from start
                                element_text, re = new RegExp('^' + text, 'i');
                            } else {
                                // anywhere
                                element_text, re = new RegExp(text, 'i');
                            }
                            if (isPlainObject(element)) {
                                element_text = element.label;
                            } else {
                                element_text = element;
                            }
                            return re.test(element_text);
                        });
                        buildItems(inputText, data, settings);
                    }
                    // Accept a function as source.
                    // Function needs to call the callback, which is the first parameter.
                    // source:function(text,callback) { mydata = [1,2]; callback(mydata); }
                    else if (typeof settings.source === 'function') {
                        if (arguments && arguments[0]) {
                            if ([37, 39].indexOf(arguments[0].keyCode) > -1) {
                                return;
                            }
                        }

                        settings.source(text, function(data) {
                            buildItems(inputText, data, settings);
                        });

                    } else {

                        const beforeSend = function(jqXHR) {
                            if (settings.cancelRequests) {
                                if (openXHR[id]) {
                                    // If we have an open XML HTTP Request for this autoComplete ID, abort it
                                    openXHR[id].abort();
                                } else {
                                    // Set a loading indicator as a temporary stop-gap to the response time issue
                                    settings.target.innerHTML = '<li><a href="#">Searching...</a></li>';

                                    /* pendiente */
                                    //settings.target.closest("fieldset").addClass("ui-search-active");
                                }
                                // Set this request to the open XML HTTP Request list for this ID
                                openXHR[id] = jqXHR;
                            }
                        };

                        const complete = function() {
                            // Clear this ID's open XML HTTP Request from the list
                            if (settings.cancelRequests) {
                                openXHR[id] = null;
                            }
                        };

                        var xhr = new XMLHttpRequest();
                        xhr.overrideMimeType("application/json");
                        xhr.open('GET', url, true);
                        xhr.onload = function() {
                            complete();
                            var jsonResponse = JSON.parse(req.responseText);
                            buildItems(inputText, jsonResponse, settings);
                        };
                        xhr.onerror = function(error) {
                            complete();
                        };
                        beforeSend(xhr);
                        xhr.send(null);                        
                    }
                }
            }
        },
        methods = {
            init: function(options) {
                var el = this;
                var autocomplete = { settings: null };
                autocomplete.settings = extend({}, autocomplete.defaults, options);                

                el.setAttribute("autocomplete", true);

                var settings = autocomplete.settings;

                el.removeEventListener("keyup", handleInput);
                el.addEventListener("keyup", handleInput);

                if (el.parentNode.querySelector('.ui-input-clear')) {
                    el.parentNode.querySelector('.ui-input-clear').addEventListener('click', function(e) {
                        clearTarget(el, settings.target);
                    });
                }

                return el;                
            },
            // Allow dynamic update of source and link
            update: function(initialOptions, newOptions) {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    this.settings = extend(this.settings, newOptions);                    
                }
                return this;
            },
            // Method to forcibly clear our target
            clear: function(options) {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    clearTarget(this, this.settings.target);
                }
                return this;
            },
            // Method to destroy (cleanup) plugin
            destroy: function() {
                var autocomplete = this.getAttribute("autocomplete");
                if (autocomplete) {
                    clearTarget(this, this.settings.target);
                    this.removeAttribute("autocomplete");
                    this.removeEventListener("keyup", handleInput);
                    //this.removeEventListener(".autocomplete");
                }
                return this;
            }
        };  

    TC.UI.autocomplete = function (method) {    
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            this.settings = arguments[0];
            return methods.init.apply(this, arguments);
        }
    };

})(TC);

/*!
 * Draggabilly PACKAGED v2.2.0
 * Make that shiz draggable
 * https://draggabilly.desandro.com
 * MIT license
 */

!function(i,e){"function"==typeof define&&define.amd?define("jquery-bridget/jquery-bridget",["jquery"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("jquery")):i.jQueryBridget=e(i,i.jQuery)}(window,function(t,i){"use strict";var c=Array.prototype.slice,e=t.console,p=void 0===e?function(){}:function(t){e.error(t)};function n(d,o,u){(u=u||i||t.jQuery)&&(o.prototype.option||(o.prototype.option=function(t){u.isPlainObject(t)&&(this.options=u.extend(!0,this.options,t))}),u.fn[d]=function(t){if("string"==typeof t){var i=c.call(arguments,1);return s=i,a="$()."+d+'("'+(r=t)+'")',(e=this).each(function(t,i){var e=u.data(i,d);if(e){var n=e[r];if(n&&"_"!=r.charAt(0)){var o=n.apply(e,s);h=void 0===h?o:h}else p(a+" is not a valid method")}else p(d+" not initialized. Cannot call methods, i.e. "+a)}),void 0!==h?h:e}var e,r,s,h,a,n;return n=t,this.each(function(t,i){var e=u.data(i,d);e?(e.option(n),e._init()):(e=new o(i,n),u.data(i,d,e))}),this},r(u))}function r(t){!t||t&&t.bridget||(t.bridget=n)}return r(i||t.jQuery),n}),function(t,i){"use strict";"function"==typeof define&&define.amd?define("get-size/get-size",[],function(){return i()}):"object"==typeof module&&module.exports?module.exports=i():t.getSize=i()}(window,function(){"use strict";function m(t){var i=parseFloat(t);return-1==t.indexOf("%")&&!isNaN(i)&&i}var e="undefined"==typeof console?function(){}:function(t){console.error(t)},y=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],b=y.length;function E(t){var i=getComputedStyle(t);return i||e("Style returned "+i+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),i}var _,x=!1;function P(t){if(function(){if(!x){x=!0;var t=document.createElement("div");t.style.width="200px",t.style.padding="1px 2px 3px 4px",t.style.borderStyle="solid",t.style.borderWidth="1px 2px 3px 4px",t.style.boxSizing="border-box";var i=document.body||document.documentElement;i.appendChild(t);var e=E(t);P.isBoxSizeOuter=_=200==m(e.width),i.removeChild(t)}}(),"string"==typeof t&&(t=document.querySelector(t)),t&&"object"==typeof t&&t.nodeType){var i=E(t);if("none"==i.display)return function(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},i=0;i<b;i++)t[y[i]]=0;return t}();var e={};e.width=t.offsetWidth,e.height=t.offsetHeight;for(var n=e.isBorderBox="border-box"==i.boxSizing,o=0;o<b;o++){var r=y[o],s=i[r],h=parseFloat(s);e[r]=isNaN(h)?0:h}var a=e.paddingLeft+e.paddingRight,d=e.paddingTop+e.paddingBottom,u=e.marginLeft+e.marginRight,c=e.marginTop+e.marginBottom,p=e.borderLeftWidth+e.borderRightWidth,f=e.borderTopWidth+e.borderBottomWidth,g=n&&_,l=m(i.width);!1!==l&&(e.width=l+(g?0:a+p));var v=m(i.height);return!1!==v&&(e.height=v+(g?0:d+f)),e.innerWidth=e.width-(a+p),e.innerHeight=e.height-(d+f),e.outerWidth=e.width+u,e.outerHeight=e.height+c,e}}return P}),function(t,i){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",i):"object"==typeof module&&module.exports?module.exports=i():t.EvEmitter=i()}("undefined"!=typeof window?window:this,function(){function t(){}var i=t.prototype;return i.on=function(t,i){if(t&&i){var e=this._events=this._events||{},n=e[t]=e[t]||[];return-1==n.indexOf(i)&&n.push(i),this}},i.once=function(t,i){if(t&&i){this.on(t,i);var e=this._onceEvents=this._onceEvents||{};return(e[t]=e[t]||{})[i]=!0,this}},i.off=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){var n=e.indexOf(i);return-1!=n&&e.splice(n,1),this}},i.emitEvent=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){e=e.slice(0),i=i||[];for(var n=this._onceEvents&&this._onceEvents[t],o=0;o<e.length;o++){var r=e[o];n&&n[r]&&(this.off(t,r),delete n[r]),r.apply(this,i)}return this}},i.allOff=function(){delete this._events,delete this._onceEvents},t}),function(i,e){"function"==typeof define&&define.amd?define("unipointer/unipointer",["ev-emitter/ev-emitter"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("ev-emitter")):i.Unipointer=e(i,i.EvEmitter)}(window,function(o,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindStartEvent=function(t){this._bindStartEvent(t,!0)},e.unbindStartEvent=function(t){this._bindStartEvent(t,!1)},e._bindStartEvent=function(t,i){var e=(i=void 0===i||i)?"addEventListener":"removeEventListener",n="mousedown";o.PointerEvent?n="pointerdown":"ontouchstart"in o&&(n="touchstart"),t[e](n,this)},e.handleEvent=function(t){var i="on"+t.type;this[i]&&this[i](t)},e.getTouch=function(t){for(var i=0;i<t.length;i++){var e=t[i];if(e.identifier==this.pointerIdentifier)return e}},e.onmousedown=function(t){var i=t.button;i&&0!==i&&1!==i||this._pointerDown(t,t)},e.ontouchstart=function(t){this._pointerDown(t,t.changedTouches[0])},e.onpointerdown=function(t){this._pointerDown(t,t)},e._pointerDown=function(t,i){t.button||this.isPointerDown||(this.isPointerDown=!0,this.pointerIdentifier=void 0!==i.pointerId?i.pointerId:i.identifier,this.pointerDown(t,i))},e.pointerDown=function(t,i){this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i])};var n={mousedown:["mousemove","mouseup"],touchstart:["touchmove","touchend","touchcancel"],pointerdown:["pointermove","pointerup","pointercancel"]};return e._bindPostStartEvents=function(t){if(t){var i=n[t.type];i.forEach(function(t){o.addEventListener(t,this)},this),this._boundPointerEvents=i}},e._unbindPostStartEvents=function(){this._boundPointerEvents&&(this._boundPointerEvents.forEach(function(t){o.removeEventListener(t,this)},this),delete this._boundPointerEvents)},e.onmousemove=function(t){this._pointerMove(t,t)},e.onpointermove=function(t){t.pointerId==this.pointerIdentifier&&this._pointerMove(t,t)},e.ontouchmove=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerMove(t,i)},e._pointerMove=function(t,i){this.pointerMove(t,i)},e.pointerMove=function(t,i){this.emitEvent("pointerMove",[t,i])},e.onmouseup=function(t){this._pointerUp(t,t)},e.onpointerup=function(t){t.pointerId==this.pointerIdentifier&&this._pointerUp(t,t)},e.ontouchend=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerUp(t,i)},e._pointerUp=function(t,i){this._pointerDone(),this.pointerUp(t,i)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i])},e._pointerDone=function(){this._pointerReset(),this._unbindPostStartEvents(),this.pointerDone()},e._pointerReset=function(){this.isPointerDown=!1,delete this.pointerIdentifier},e.pointerDone=function(){},e.onpointercancel=function(t){t.pointerId==this.pointerIdentifier&&this._pointerCancel(t,t)},e.ontouchcancel=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerCancel(t,i)},e._pointerCancel=function(t,i){this._pointerDone(),this.pointerCancel(t,i)},e.pointerCancel=function(t,i){this.emitEvent("pointerCancel",[t,i])},i.getPointerPoint=function(t){return{x:t.pageX,y:t.pageY}},i}),function(i,e){"function"==typeof define&&define.amd?define("unidragger/unidragger",["unipointer/unipointer"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("unipointer")):i.Unidragger=e(i,i.Unipointer)}(window,function(r,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindHandles=function(){this._bindHandles(!0)},e.unbindHandles=function(){this._bindHandles(!1)},e._bindHandles=function(t){for(var i=(t=void 0===t||t)?"addEventListener":"removeEventListener",e=t?this._touchActionValue:"",n=0;n<this.handles.length;n++){var o=this.handles[n];this._bindStartEvent(o,t),o[i]("click",this),r.PointerEvent&&(o.style.touchAction=e)}},e._touchActionValue="none",e.pointerDown=function(t,i){this.okayPointerDown(t)&&(this.pointerDownPointer=i,t.preventDefault(),this.pointerDownBlur(),this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i]))};var o={TEXTAREA:!0,INPUT:!0,SELECT:!0,OPTION:!0},s={radio:!0,checkbox:!0,button:!0,submit:!0,image:!0,file:!0};return e.okayPointerDown=function(t){var i=o[t.target.nodeName],e=s[t.target.type],n=!i||e;return n||this._pointerReset(),n},e.pointerDownBlur=function(){var t=document.activeElement;t&&t.blur&&t!=document.body&&t.blur()},e.pointerMove=function(t,i){var e=this._dragPointerMove(t,i);this.emitEvent("pointerMove",[t,i,e]),this._dragMove(t,i,e)},e._dragPointerMove=function(t,i){var e={x:i.pageX-this.pointerDownPointer.pageX,y:i.pageY-this.pointerDownPointer.pageY};return!this.isDragging&&this.hasDragStarted(e)&&this._dragStart(t,i),e},e.hasDragStarted=function(t){return 3<Math.abs(t.x)||3<Math.abs(t.y)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i]),this._dragPointerUp(t,i)},e._dragPointerUp=function(t,i){this.isDragging?this._dragEnd(t,i):this._staticClick(t,i)},e._dragStart=function(t,i){this.isDragging=!0,this.isPreventingClicks=!0,this.dragStart(t,i)},e.dragStart=function(t,i){this.emitEvent("dragStart",[t,i])},e._dragMove=function(t,i,e){this.isDragging&&this.dragMove(t,i,e)},e.dragMove=function(t,i,e){t.preventDefault(),this.emitEvent("dragMove",[t,i,e])},e._dragEnd=function(t,i){this.isDragging=!1,setTimeout(function(){delete this.isPreventingClicks}.bind(this)),this.dragEnd(t,i)},e.dragEnd=function(t,i){this.emitEvent("dragEnd",[t,i])},e.onclick=function(t){this.isPreventingClicks&&t.preventDefault()},e._staticClick=function(t,i){this.isIgnoringMouseUp&&"mouseup"==t.type||(this.staticClick(t,i),"mouseup"!=t.type&&(this.isIgnoringMouseUp=!0,setTimeout(function(){delete this.isIgnoringMouseUp}.bind(this),400)))},e.staticClick=function(t,i){this.emitEvent("staticClick",[t,i])},i.getPointerPoint=t.getPointerPoint,i}),function(e,n){"function"==typeof define&&define.amd?define(["get-size/get-size","unidragger/unidragger"],function(t,i){return n(e,t,i)}):"object"==typeof module&&module.exports?module.exports=n(e,require("get-size"),require("unidragger")):e.Draggabilly=n(e,e.getSize,e.Unidragger)}(window,function(r,a,t){function e(t,i){for(var e in i)t[e]=i[e];return t}var n=r.jQuery;function i(t,i){this.element="string"==typeof t?document.querySelector(t):t,n&&(this.$element=n(this.element)),this.options=e({},this.constructor.defaults),this.option(i),this._create()}var o=i.prototype=Object.create(t.prototype);i.defaults={},o.option=function(t){e(this.options,t)};var s={relative:!0,absolute:!0,fixed:!0};function d(t,i,e){return e=e||"round",i?Math[e](t/i)*i:t}return o._create=function(){this.position={},this._getPosition(),this.startPoint={x:0,y:0},this.dragPoint={x:0,y:0},this.startPosition=e({},this.position);var t=getComputedStyle(this.element);s[t.position]||(this.element.style.position="relative"),this.on("pointerDown",this.onPointerDown),this.on("pointerMove",this.onPointerMove),this.on("pointerUp",this.onPointerUp),this.enable(),this.setHandles()},o.setHandles=function(){this.handles=this.options.handle?this.element.querySelectorAll(this.options.handle):[this.element],this.bindHandles()},o.dispatchEvent=function(t,i,e){var n=[i].concat(e);this.emitEvent(t,n),this.dispatchJQueryEvent(t,i,e)},o.dispatchJQueryEvent=function(t,i,e){var n=r.jQuery;if(n&&this.$element){var o=n.Event(i);o.type=t,this.$element.trigger(o,e)}},o._getPosition=function(){var t=getComputedStyle(this.element),i=this._getPositionCoord(t.left,"width"),e=this._getPositionCoord(t.top,"height");this.position.x=isNaN(i)?0:i,this.position.y=isNaN(e)?0:e,this._addTransformPosition(t)},o._getPositionCoord=function(t,i){if(-1!=t.indexOf("%")){var e=a(this.element.parentNode);return e?parseFloat(t)/100*e[i]:0}return parseInt(t,10)},o._addTransformPosition=function(t){var i=t.transform;if(0===i.indexOf("matrix")){var e=i.split(","),n=0===i.indexOf("matrix3d")?12:4,o=parseInt(e[n],10),r=parseInt(e[n+1],10);this.position.x+=o,this.position.y+=r}},o.onPointerDown=function(t,i){this.element.classList.add("is-pointer-down"),this.dispatchJQueryEvent("pointerDown",t,[i])},o.dragStart=function(t,i){this.isEnabled&&(this._getPosition(),this.measureContainment(),this.startPosition.x=this.position.x,this.startPosition.y=this.position.y,this.setLeftTop(),this.dragPoint.x=0,this.dragPoint.y=0,this.element.classList.add("is-dragging"),this.dispatchEvent("dragStart",t,[i]),this.animate())},o.measureContainment=function(){var t=this.getContainer();if(t){var i=a(this.element),e=a(t),n=this.element.getBoundingClientRect(),o=t.getBoundingClientRect(),r=e.borderLeftWidth+e.borderRightWidth,s=e.borderTopWidth+e.borderBottomWidth,h=this.relativeStartPosition={x:n.left-(o.left+e.borderLeftWidth),y:n.top-(o.top+e.borderTopWidth)};this.containSize={width:e.width-r-h.x-i.width,height:e.height-s-h.y-i.height}}},o.getContainer=function(){var t=this.options.containment;if(t)return t instanceof HTMLElement?t:"string"==typeof t?document.querySelector(t):this.element.parentNode},o.onPointerMove=function(t,i,e){this.dispatchJQueryEvent("pointerMove",t,[i,e])},o.dragMove=function(t,i,e){if(this.isEnabled){var n=e.x,o=e.y,r=this.options.grid,s=r&&r[0],h=r&&r[1];n=d(n,s),o=d(o,h),n=this.containDrag("x",n,s),o=this.containDrag("y",o,h),n="y"==this.options.axis?0:n,o="x"==this.options.axis?0:o,this.position.x=this.startPosition.x+n,this.position.y=this.startPosition.y+o,this.dragPoint.x=n,this.dragPoint.y=o,this.dispatchEvent("dragMove",t,[i,e])}},o.containDrag=function(t,i,e){if(!this.options.containment)return i;var n="x"==t?"width":"height",o=d(-this.relativeStartPosition[t],e,"ceil"),r=this.containSize[n];return r=d(r,e,"floor"),Math.max(o,Math.min(r,i))},o.onPointerUp=function(t,i){this.element.classList.remove("is-pointer-down"),this.dispatchJQueryEvent("pointerUp",t,[i])},o.dragEnd=function(t,i){this.isEnabled&&(this.element.style.transform="",this.setLeftTop(),this.element.classList.remove("is-dragging"),this.dispatchEvent("dragEnd",t,[i]))},o.animate=function(){if(this.isDragging){this.positionDrag();var t=this;requestAnimationFrame(function(){t.animate()})}},o.setLeftTop=function(){this.element.style.left=this.position.x+"px",this.element.style.top=this.position.y+"px"},o.positionDrag=function(){this.element.style.transform="translate3d( "+this.dragPoint.x+"px, "+this.dragPoint.y+"px, 0)"},o.staticClick=function(t,i){this.dispatchEvent("staticClick",t,[i])},o.setPosition=function(t,i){this.position.x=t,this.position.y=i,this.setLeftTop()},o.enable=function(){this.isEnabled=!0},o.disable=function(){this.isEnabled=!1,this.isDragging&&this.dragEnd()},o.destroy=function(){this.disable(),this.element.style.transform="",this.element.style.left="",this.element.style.top="",this.element.style.position="",this.unbindHandles(),this.$element&&this.$element.removeData("draggabilly")},o._init=function(){},n&&n.bridget&&n.bridget("draggabilly",i),i});
/*! Sortable 1.10.2 - MIT | git://github.com/SortableJS/Sortable.git */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).Sortable=e()}(this,function(){"use strict";function o(t){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}function I(i){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},e=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(r).filter(function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),e.forEach(function(t){var e,n,o;e=i,o=r[n=t],n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o})}return i}function l(t,e){if(null==t)return{};var n,o,i=function(t,e){if(null==t)return{};var n,o,i={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],0<=e.indexOf(n)||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],0<=e.indexOf(n)||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}function e(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function t(t){if("undefined"!=typeof window&&window.navigator)return!!navigator.userAgent.match(t)}var w=t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i),E=t(/Edge/i),c=t(/firefox/i),s=t(/safari/i)&&!t(/chrome/i)&&!t(/android/i),n=t(/iP(ad|od|hone)/i),i=t(/chrome/i)&&t(/android/i),r={capture:!1,passive:!1};function u(t,e,n){t.addEventListener(e,n,!w&&r)}function d(t,e,n){t.removeEventListener(e,n,!w&&r)}function h(t,e){if(e){if(">"===e[0]&&(e=e.substring(1)),t)try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return!1}return!1}}function P(t,e,n,o){if(t){n=n||document;do{if(null!=e&&(">"===e[0]?t.parentNode===n&&h(t,e):h(t,e))||o&&t===n)return t;if(t===n)break}while(t=(i=t).host&&i!==document&&i.host.nodeType?i.host:i.parentNode)}var i;return null}var f,p=/\s+/g;function k(t,e,n){if(t&&e)if(t.classList)t.classList[n?"add":"remove"](e);else{var o=(" "+t.className+" ").replace(p," ").replace(" "+e+" "," ");t.className=(o+(n?" "+e:"")).replace(p," ")}}function R(t,e,n){var o=t&&t.style;if(o){if(void 0===n)return document.defaultView&&document.defaultView.getComputedStyle?n=document.defaultView.getComputedStyle(t,""):t.currentStyle&&(n=t.currentStyle),void 0===e?n:n[e];e in o||-1!==e.indexOf("webkit")||(e="-webkit-"+e),o[e]=n+("string"==typeof n?"":"px")}}function v(t,e){var n="";if("string"==typeof t)n=t;else do{var o=R(t,"transform");o&&"none"!==o&&(n=o+" "+n)}while(!e&&(t=t.parentNode));var i=window.DOMMatrix||window.WebKitCSSMatrix||window.CSSMatrix||window.MSCSSMatrix;return i&&new i(n)}function g(t,e,n){if(t){var o=t.getElementsByTagName(e),i=0,r=o.length;if(n)for(;i<r;i++)n(o[i],i);return o}return[]}function N(){var t=document.scrollingElement;return t||document.documentElement}function X(t,e,n,o,i){if(t.getBoundingClientRect||t===window){var r,a,l,s,c,u,d;if(d=t!==window&&t!==N()?(a=(r=t.getBoundingClientRect()).top,l=r.left,s=r.bottom,c=r.right,u=r.height,r.width):(l=a=0,s=window.innerHeight,c=window.innerWidth,u=window.innerHeight,window.innerWidth),(e||n)&&t!==window&&(i=i||t.parentNode,!w))do{if(i&&i.getBoundingClientRect&&("none"!==R(i,"transform")||n&&"static"!==R(i,"position"))){var h=i.getBoundingClientRect();a-=h.top+parseInt(R(i,"border-top-width")),l-=h.left+parseInt(R(i,"border-left-width")),s=a+r.height,c=l+r.width;break}}while(i=i.parentNode);if(o&&t!==window){var f=v(i||t),p=f&&f.a,g=f&&f.d;f&&(s=(a/=g)+(u/=g),c=(l/=p)+(d/=p))}return{top:a,left:l,bottom:s,right:c,width:d,height:u}}}function Y(t,e,n){for(var o=H(t,!0),i=X(t)[e];o;){var r=X(o)[n];if(!("top"===n||"left"===n?r<=i:i<=r))return o;if(o===N())break;o=H(o,!1)}return!1}function m(t,e,n){for(var o=0,i=0,r=t.children;i<r.length;){if("none"!==r[i].style.display&&r[i]!==Rt.ghost&&r[i]!==Rt.dragged&&P(r[i],n.draggable,t,!1)){if(o===e)return r[i];o++}i++}return null}function B(t,e){for(var n=t.lastElementChild;n&&(n===Rt.ghost||"none"===R(n,"display")||e&&!h(n,e));)n=n.previousElementSibling;return n||null}function F(t,e){var n=0;if(!t||!t.parentNode)return-1;for(;t=t.previousElementSibling;)"TEMPLATE"===t.nodeName.toUpperCase()||t===Rt.clone||e&&!h(t,e)||n++;return n}function b(t){var e=0,n=0,o=N();if(t)do{var i=v(t),r=i.a,a=i.d;e+=t.scrollLeft*r,n+=t.scrollTop*a}while(t!==o&&(t=t.parentNode));return[e,n]}function H(t,e){if(!t||!t.getBoundingClientRect)return N();var n=t,o=!1;do{if(n.clientWidth<n.scrollWidth||n.clientHeight<n.scrollHeight){var i=R(n);if(n.clientWidth<n.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||n.clientHeight<n.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!n.getBoundingClientRect||n===document.body)return N();if(o||e)return n;o=!0}}}while(n=n.parentNode);return N()}function y(t,e){return Math.round(t.top)===Math.round(e.top)&&Math.round(t.left)===Math.round(e.left)&&Math.round(t.height)===Math.round(e.height)&&Math.round(t.width)===Math.round(e.width)}function D(e,n){return function(){if(!f){var t=arguments;1===t.length?e.call(this,t[0]):e.apply(this,t),f=setTimeout(function(){f=void 0},n)}}}function L(t,e,n){t.scrollLeft+=e,t.scrollTop+=n}function S(t){var e=window.Polymer,n=window.jQuery||window.Zepto;return e&&e.dom?e.dom(t).cloneNode(!0):n?n(t).clone(!0)[0]:t.cloneNode(!0)}function _(t,e){R(t,"position","absolute"),R(t,"top",e.top),R(t,"left",e.left),R(t,"width",e.width),R(t,"height",e.height)}function C(t){R(t,"position",""),R(t,"top",""),R(t,"left",""),R(t,"width",""),R(t,"height","")}var j="Sortable"+(new Date).getTime();function T(){var e,o=[];return{captureAnimationState:function(){o=[],this.options.animation&&[].slice.call(this.el.children).forEach(function(t){if("none"!==R(t,"display")&&t!==Rt.ghost){o.push({target:t,rect:X(t)});var e=I({},o[o.length-1].rect);if(t.thisAnimationDuration){var n=v(t,!0);n&&(e.top-=n.f,e.left-=n.e)}t.fromRect=e}})},addAnimationState:function(t){o.push(t)},removeAnimationState:function(t){o.splice(function(t,e){for(var n in t)if(t.hasOwnProperty(n))for(var o in e)if(e.hasOwnProperty(o)&&e[o]===t[n][o])return Number(n);return-1}(o,{target:t}),1)},animateAll:function(t){var c=this;if(!this.options.animation)return clearTimeout(e),void("function"==typeof t&&t());var u=!1,d=0;o.forEach(function(t){var e=0,n=t.target,o=n.fromRect,i=X(n),r=n.prevFromRect,a=n.prevToRect,l=t.rect,s=v(n,!0);s&&(i.top-=s.f,i.left-=s.e),n.toRect=i,n.thisAnimationDuration&&y(r,i)&&!y(o,i)&&(l.top-i.top)/(l.left-i.left)==(o.top-i.top)/(o.left-i.left)&&(e=function(t,e,n,o){return Math.sqrt(Math.pow(e.top-t.top,2)+Math.pow(e.left-t.left,2))/Math.sqrt(Math.pow(e.top-n.top,2)+Math.pow(e.left-n.left,2))*o.animation}(l,r,a,c.options)),y(i,o)||(n.prevFromRect=o,n.prevToRect=i,e||(e=c.options.animation),c.animate(n,l,i,e)),e&&(u=!0,d=Math.max(d,e),clearTimeout(n.animationResetTimer),n.animationResetTimer=setTimeout(function(){n.animationTime=0,n.prevFromRect=null,n.fromRect=null,n.prevToRect=null,n.thisAnimationDuration=null},e),n.thisAnimationDuration=e)}),clearTimeout(e),u?e=setTimeout(function(){"function"==typeof t&&t()},d):"function"==typeof t&&t(),o=[]},animate:function(t,e,n,o){if(o){R(t,"transition",""),R(t,"transform","");var i=v(this.el),r=i&&i.a,a=i&&i.d,l=(e.left-n.left)/(r||1),s=(e.top-n.top)/(a||1);t.animatingX=!!l,t.animatingY=!!s,R(t,"transform","translate3d("+l+"px,"+s+"px,0)"),function(t){t.offsetWidth}(t),R(t,"transition","transform "+o+"ms"+(this.options.easing?" "+this.options.easing:"")),R(t,"transform","translate3d(0,0,0)"),"number"==typeof t.animated&&clearTimeout(t.animated),t.animated=setTimeout(function(){R(t,"transition",""),R(t,"transform",""),t.animated=!1,t.animatingX=!1,t.animatingY=!1},o)}}}}var x=[],M={initializeByDefault:!0},O={mount:function(t){for(var e in M)!M.hasOwnProperty(e)||e in t||(t[e]=M[e]);x.push(t)},pluginEvent:function(e,n,o){var t=this;this.eventCanceled=!1,o.cancel=function(){t.eventCanceled=!0};var i=e+"Global";x.forEach(function(t){n[t.pluginName]&&(n[t.pluginName][i]&&n[t.pluginName][i](I({sortable:n},o)),n.options[t.pluginName]&&n[t.pluginName][e]&&n[t.pluginName][e](I({sortable:n},o)))})},initializePlugins:function(o,i,r,t){for(var e in x.forEach(function(t){var e=t.pluginName;if(o.options[e]||t.initializeByDefault){var n=new t(o,i,o.options);n.sortable=o,n.options=o.options,o[e]=n,a(r,n.defaults)}}),o.options)if(o.options.hasOwnProperty(e)){var n=this.modifyOption(o,e,o.options[e]);void 0!==n&&(o.options[e]=n)}},getEventProperties:function(e,n){var o={};return x.forEach(function(t){"function"==typeof t.eventProperties&&a(o,t.eventProperties.call(n[t.pluginName],e))}),o},modifyOption:function(e,n,o){var i;return x.forEach(function(t){e[t.pluginName]&&t.optionListeners&&"function"==typeof t.optionListeners[n]&&(i=t.optionListeners[n].call(e[t.pluginName],o))}),i}};function A(t){var e=t.sortable,n=t.rootEl,o=t.name,i=t.targetEl,r=t.cloneEl,a=t.toEl,l=t.fromEl,s=t.oldIndex,c=t.newIndex,u=t.oldDraggableIndex,d=t.newDraggableIndex,h=t.originalEvent,f=t.putSortable,p=t.extraEventProperties;if(e=e||n&&n[j]){var g,v=e.options,m="on"+o.charAt(0).toUpperCase()+o.substr(1);!window.CustomEvent||w||E?(g=document.createEvent("Event")).initEvent(o,!0,!0):g=new CustomEvent(o,{bubbles:!0,cancelable:!0}),g.to=a||n,g.from=l||n,g.item=i||n,g.clone=r,g.oldIndex=s,g.newIndex=c,g.oldDraggableIndex=u,g.newDraggableIndex=d,g.originalEvent=h,g.pullMode=f?f.lastPutMode:void 0;var b=I({},p,O.getEventProperties(o,e));for(var y in b)g[y]=b[y];n&&n.dispatchEvent(g),v[m]&&v[m].call(e,g)}}function K(t,e,n){var o=2<arguments.length&&void 0!==n?n:{},i=o.evt,r=l(o,["evt"]);O.pluginEvent.bind(Rt)(t,e,I({dragEl:z,parentEl:G,ghostEl:U,rootEl:q,nextEl:V,lastDownEl:Z,cloneEl:Q,cloneHidden:$,dragStarted:dt,putSortable:it,activeSortable:Rt.active,originalEvent:i,oldIndex:J,oldDraggableIndex:et,newIndex:tt,newDraggableIndex:nt,hideGhostForTarget:Nt,unhideGhostForTarget:It,cloneNowHidden:function(){$=!0},cloneNowShown:function(){$=!1},dispatchSortableEvent:function(t){W({sortable:e,name:t,originalEvent:i})}},r))}function W(t){A(I({putSortable:it,cloneEl:Q,targetEl:z,rootEl:q,oldIndex:J,oldDraggableIndex:et,newIndex:tt,newDraggableIndex:nt},t))}var z,G,U,q,V,Z,Q,$,J,tt,et,nt,ot,it,rt,at,lt,st,ct,ut,dt,ht,ft,pt,gt,vt=!1,mt=!1,bt=[],yt=!1,wt=!1,Et=[],Dt=!1,St=[],_t="undefined"!=typeof document,Ct=n,Tt=E||w?"cssFloat":"float",xt=_t&&!i&&!n&&"draggable"in document.createElement("div"),Mt=function(){if(_t){if(w)return!1;var t=document.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}}(),Ot=function(t,e){var n=R(t),o=parseInt(n.width)-parseInt(n.paddingLeft)-parseInt(n.paddingRight)-parseInt(n.borderLeftWidth)-parseInt(n.borderRightWidth),i=m(t,0,e),r=m(t,1,e),a=i&&R(i),l=r&&R(r),s=a&&parseInt(a.marginLeft)+parseInt(a.marginRight)+X(i).width,c=l&&parseInt(l.marginLeft)+parseInt(l.marginRight)+X(r).width;if("flex"===n.display)return"column"===n.flexDirection||"column-reverse"===n.flexDirection?"vertical":"horizontal";if("grid"===n.display)return n.gridTemplateColumns.split(" ").length<=1?"vertical":"horizontal";if(i&&a.float&&"none"!==a.float){var u="left"===a.float?"left":"right";return!r||"both"!==l.clear&&l.clear!==u?"horizontal":"vertical"}return i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||o<=s&&"none"===n[Tt]||r&&"none"===n[Tt]&&o<s+c)?"vertical":"horizontal"},At=function(t){function s(a,l){return function(t,e,n,o){var i=t.options.group.name&&e.options.group.name&&t.options.group.name===e.options.group.name;if(null==a&&(l||i))return!0;if(null==a||!1===a)return!1;if(l&&"clone"===a)return a;if("function"==typeof a)return s(a(t,e,n,o),l)(t,e,n,o);var r=(l?t:e).options.group.name;return!0===a||"string"==typeof a&&a===r||a.join&&-1<a.indexOf(r)}}var e={},n=t.group;n&&"object"==o(n)||(n={name:n}),e.name=n.name,e.checkPull=s(n.pull,!0),e.checkPut=s(n.put),e.revertClone=n.revertClone,t.group=e},Nt=function(){!Mt&&U&&R(U,"display","none")},It=function(){!Mt&&U&&R(U,"display","")};_t&&document.addEventListener("click",function(t){if(mt)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),mt=!1},!0);function Pt(t){if(z){var e=function(r,a){var l;return bt.some(function(t){if(!B(t)){var e=X(t),n=t[j].options.emptyInsertThreshold,o=r>=e.left-n&&r<=e.right+n,i=a>=e.top-n&&a<=e.bottom+n;return n&&o&&i?l=t:void 0}}),l}((t=t.touches?t.touches[0]:t).clientX,t.clientY);if(e){var n={};for(var o in t)t.hasOwnProperty(o)&&(n[o]=t[o]);n.target=n.rootEl=e,n.preventDefault=void 0,n.stopPropagation=void 0,e[j]._onDragOver(n)}}}function kt(t){z&&z.parentNode[j]._isOutsideThisEl(t.target)}function Rt(t,e){if(!t||!t.nodeType||1!==t.nodeType)throw"Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));this.el=t,this.options=e=a({},e),t[j]=this;var n={group:null,sort:!0,disabled:!1,store:null,handle:null,draggable:/^[uo]l$/i.test(t.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return Ot(t,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,delayOnTouchOnly:!1,touchStartThreshold:(Number.parseInt?Number:window).parseInt(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==Rt.supportPointer&&"PointerEvent"in window,emptyInsertThreshold:5};for(var o in O.initializePlugins(this,t,n),n)o in e||(e[o]=n[o]);for(var i in At(e),this)"_"===i.charAt(0)&&"function"==typeof this[i]&&(this[i]=this[i].bind(this));this.nativeDraggable=!e.forceFallback&&xt,this.nativeDraggable&&(this.options.touchStartThreshold=1),e.supportPointer?u(t,"pointerdown",this._onTapStart):(u(t,"mousedown",this._onTapStart),u(t,"touchstart",this._onTapStart)),this.nativeDraggable&&(u(t,"dragover",this),u(t,"dragenter",this)),bt.push(this.el),e.store&&e.store.get&&this.sort(e.store.get(this)||[]),a(this,T())}function Xt(t,e,n,o,i,r,a,l){var s,c,u=t[j],d=u.options.onMove;return!window.CustomEvent||w||E?(s=document.createEvent("Event")).initEvent("move",!0,!0):s=new CustomEvent("move",{bubbles:!0,cancelable:!0}),s.to=e,s.from=t,s.dragged=n,s.draggedRect=o,s.related=i||e,s.relatedRect=r||X(e),s.willInsertAfter=l,s.originalEvent=a,t.dispatchEvent(s),d&&(c=d.call(u,s,a)),c}function Yt(t){t.draggable=!1}function Bt(){Dt=!1}function Ft(t){for(var e=t.tagName+t.className+t.src+t.href+t.textContent,n=e.length,o=0;n--;)o+=e.charCodeAt(n);return o.toString(36)}function Ht(t){return setTimeout(t,0)}function Lt(t){return clearTimeout(t)}Rt.prototype={constructor:Rt,_isOutsideThisEl:function(t){this.el.contains(t)||t===this.el||(ht=null)},_getDirection:function(t,e){return"function"==typeof this.options.direction?this.options.direction.call(this,t,e,z):this.options.direction},_onTapStart:function(e){if(e.cancelable){var n=this,o=this.el,t=this.options,i=t.preventOnFilter,r=e.type,a=e.touches&&e.touches[0]||e.pointerType&&"touch"===e.pointerType&&e,l=(a||e).target,s=e.target.shadowRoot&&(e.path&&e.path[0]||e.composedPath&&e.composedPath()[0])||l,c=t.filter;if(function(t){St.length=0;var e=t.getElementsByTagName("input"),n=e.length;for(;n--;){var o=e[n];o.checked&&St.push(o)}}(o),!z&&!(/mousedown|pointerdown/.test(r)&&0!==e.button||t.disabled||s.isContentEditable||(l=P(l,t.draggable,o,!1))&&l.animated||Z===l)){if(J=F(l),et=F(l,t.draggable),"function"==typeof c){if(c.call(this,e,l,this))return W({sortable:n,rootEl:s,name:"filter",targetEl:l,toEl:o,fromEl:o}),K("filter",n,{evt:e}),void(i&&e.cancelable&&e.preventDefault())}else if(c&&(c=c.split(",").some(function(t){if(t=P(s,t.trim(),o,!1))return W({sortable:n,rootEl:t,name:"filter",targetEl:l,fromEl:o,toEl:o}),K("filter",n,{evt:e}),!0})))return void(i&&e.cancelable&&e.preventDefault());t.handle&&!P(s,t.handle,o,!1)||this._prepareDragStart(e,a,l)}}},_prepareDragStart:function(t,e,n){var o,i=this,r=i.el,a=i.options,l=r.ownerDocument;if(n&&!z&&n.parentNode===r){var s=X(n);if(q=r,G=(z=n).parentNode,V=z.nextSibling,Z=n,ot=a.group,rt={target:Rt.dragged=z,clientX:(e||t).clientX,clientY:(e||t).clientY},ct=rt.clientX-s.left,ut=rt.clientY-s.top,this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,z.style["will-change"]="all",o=function(){K("delayEnded",i,{evt:t}),Rt.eventCanceled?i._onDrop():(i._disableDelayedDragEvents(),!c&&i.nativeDraggable&&(z.draggable=!0),i._triggerDragStart(t,e),W({sortable:i,name:"choose",originalEvent:t}),k(z,a.chosenClass,!0))},a.ignore.split(",").forEach(function(t){g(z,t.trim(),Yt)}),u(l,"dragover",Pt),u(l,"mousemove",Pt),u(l,"touchmove",Pt),u(l,"mouseup",i._onDrop),u(l,"touchend",i._onDrop),u(l,"touchcancel",i._onDrop),c&&this.nativeDraggable&&(this.options.touchStartThreshold=4,z.draggable=!0),K("delayStart",this,{evt:t}),!a.delay||a.delayOnTouchOnly&&!e||this.nativeDraggable&&(E||w))o();else{if(Rt.eventCanceled)return void this._onDrop();u(l,"mouseup",i._disableDelayedDrag),u(l,"touchend",i._disableDelayedDrag),u(l,"touchcancel",i._disableDelayedDrag),u(l,"mousemove",i._delayedDragTouchMoveHandler),u(l,"touchmove",i._delayedDragTouchMoveHandler),a.supportPointer&&u(l,"pointermove",i._delayedDragTouchMoveHandler),i._dragStartTimer=setTimeout(o,a.delay)}}},_delayedDragTouchMoveHandler:function(t){var e=t.touches?t.touches[0]:t;Math.max(Math.abs(e.clientX-this._lastX),Math.abs(e.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))&&this._disableDelayedDrag()},_disableDelayedDrag:function(){z&&Yt(z),clearTimeout(this._dragStartTimer),this._disableDelayedDragEvents()},_disableDelayedDragEvents:function(){var t=this.el.ownerDocument;d(t,"mouseup",this._disableDelayedDrag),d(t,"touchend",this._disableDelayedDrag),d(t,"touchcancel",this._disableDelayedDrag),d(t,"mousemove",this._delayedDragTouchMoveHandler),d(t,"touchmove",this._delayedDragTouchMoveHandler),d(t,"pointermove",this._delayedDragTouchMoveHandler)},_triggerDragStart:function(t,e){e=e||"touch"==t.pointerType&&t,!this.nativeDraggable||e?this.options.supportPointer?u(document,"pointermove",this._onTouchMove):u(document,e?"touchmove":"mousemove",this._onTouchMove):(u(z,"dragend",this),u(q,"dragstart",this._onDragStart));try{document.selection?Ht(function(){document.selection.empty()}):window.getSelection().removeAllRanges()}catch(t){}},_dragStarted:function(t,e){if(vt=!1,q&&z){K("dragStarted",this,{evt:e}),this.nativeDraggable&&u(document,"dragover",kt);var n=this.options;t||k(z,n.dragClass,!1),k(z,n.ghostClass,!0),Rt.active=this,t&&this._appendGhost(),W({sortable:this,name:"start",originalEvent:e})}else this._nulling()},_emulateDragOver:function(){if(at){this._lastX=at.clientX,this._lastY=at.clientY,Nt();for(var t=document.elementFromPoint(at.clientX,at.clientY),e=t;t&&t.shadowRoot&&(t=t.shadowRoot.elementFromPoint(at.clientX,at.clientY))!==e;)e=t;if(z.parentNode[j]._isOutsideThisEl(t),e)do{if(e[j]){if(e[j]._onDragOver({clientX:at.clientX,clientY:at.clientY,target:t,rootEl:e})&&!this.options.dragoverBubble)break}t=e}while(e=e.parentNode);It()}},_onTouchMove:function(t){if(rt){var e=this.options,n=e.fallbackTolerance,o=e.fallbackOffset,i=t.touches?t.touches[0]:t,r=U&&v(U,!0),a=U&&r&&r.a,l=U&&r&&r.d,s=Ct&&gt&&b(gt),c=(i.clientX-rt.clientX+o.x)/(a||1)+(s?s[0]-Et[0]:0)/(a||1),u=(i.clientY-rt.clientY+o.y)/(l||1)+(s?s[1]-Et[1]:0)/(l||1);if(!Rt.active&&!vt){if(n&&Math.max(Math.abs(i.clientX-this._lastX),Math.abs(i.clientY-this._lastY))<n)return;this._onDragStart(t,!0)}if(U){r?(r.e+=c-(lt||0),r.f+=u-(st||0)):r={a:1,b:0,c:0,d:1,e:c,f:u};var d="matrix(".concat(r.a,",").concat(r.b,",").concat(r.c,",").concat(r.d,",").concat(r.e,",").concat(r.f,")");R(U,"webkitTransform",d),R(U,"mozTransform",d),R(U,"msTransform",d),R(U,"transform",d),lt=c,st=u,at=i}t.cancelable&&t.preventDefault()}},_appendGhost:function(){if(!U){var t=this.options.fallbackOnBody?document.body:q,e=X(z,!0,Ct,!0,t),n=this.options;if(Ct){for(gt=t;"static"===R(gt,"position")&&"none"===R(gt,"transform")&&gt!==document;)gt=gt.parentNode;gt!==document.body&&gt!==document.documentElement?(gt===document&&(gt=N()),e.top+=gt.scrollTop,e.left+=gt.scrollLeft):gt=N(),Et=b(gt)}k(U=z.cloneNode(!0),n.ghostClass,!1),k(U,n.fallbackClass,!0),k(U,n.dragClass,!0),R(U,"transition",""),R(U,"transform",""),R(U,"box-sizing","border-box"),R(U,"margin",0),R(U,"top",e.top),R(U,"left",e.left),R(U,"width",e.width),R(U,"height",e.height),R(U,"opacity","0.8"),R(U,"position",Ct?"absolute":"fixed"),R(U,"zIndex","100000"),R(U,"pointerEvents","none"),Rt.ghost=U,t.appendChild(U),R(U,"transform-origin",ct/parseInt(U.style.width)*100+"% "+ut/parseInt(U.style.height)*100+"%")}},_onDragStart:function(t,e){var n=this,o=t.dataTransfer,i=n.options;K("dragStart",this,{evt:t}),Rt.eventCanceled?this._onDrop():(K("setupClone",this),Rt.eventCanceled||((Q=S(z)).draggable=!1,Q.style["will-change"]="",this._hideClone(),k(Q,this.options.chosenClass,!1),Rt.clone=Q),n.cloneId=Ht(function(){K("clone",n),Rt.eventCanceled||(n.options.removeCloneOnHide||q.insertBefore(Q,z),n._hideClone(),W({sortable:n,name:"clone"}))}),e||k(z,i.dragClass,!0),e?(mt=!0,n._loopId=setInterval(n._emulateDragOver,50)):(d(document,"mouseup",n._onDrop),d(document,"touchend",n._onDrop),d(document,"touchcancel",n._onDrop),o&&(o.effectAllowed="move",i.setData&&i.setData.call(n,o,z)),u(document,"drop",n),R(z,"transform","translateZ(0)")),vt=!0,n._dragStartId=Ht(n._dragStarted.bind(n,e,t)),u(document,"selectstart",n),dt=!0,s&&R(document.body,"user-select","none"))},_onDragOver:function(n){var o,i,r,a,l=this.el,s=n.target,e=this.options,t=e.group,c=Rt.active,u=ot===t,d=e.sort,h=it||c,f=this,p=!1;if(!Dt){if(void 0!==n.preventDefault&&n.cancelable&&n.preventDefault(),s=P(s,e.draggable,l,!0),M("dragOver"),Rt.eventCanceled)return p;if(z.contains(n.target)||s.animated&&s.animatingX&&s.animatingY||f._ignoreWhileAnimating===s)return A(!1);if(mt=!1,c&&!e.disabled&&(u?d||(r=!q.contains(z)):it===this||(this.lastPutMode=ot.checkPull(this,c,z,n))&&t.checkPut(this,c,z,n))){if(a="vertical"===this._getDirection(n,s),o=X(z),M("dragOverValid"),Rt.eventCanceled)return p;if(r)return G=q,O(),this._hideClone(),M("revert"),Rt.eventCanceled||(V?q.insertBefore(z,V):q.appendChild(z)),A(!0);var g=B(l,e.draggable);if(!g||function(t,e,n){var o=X(B(n.el,n.options.draggable));return e?t.clientX>o.right+10||t.clientX<=o.right&&t.clientY>o.bottom&&t.clientX>=o.left:t.clientX>o.right&&t.clientY>o.top||t.clientX<=o.right&&t.clientY>o.bottom+10}(n,a,this)&&!g.animated){if(g===z)return A(!1);if(g&&l===n.target&&(s=g),s&&(i=X(s)),!1!==Xt(q,l,z,o,s,i,n,!!s))return O(),l.appendChild(z),G=l,N(),A(!0)}else if(s.parentNode===l){i=X(s);var v,m,b,y=z.parentNode!==l,w=!function(t,e,n){var o=n?t.left:t.top,i=n?t.right:t.bottom,r=n?t.width:t.height,a=n?e.left:e.top,l=n?e.right:e.bottom,s=n?e.width:e.height;return o===a||i===l||o+r/2===a+s/2}(z.animated&&z.toRect||o,s.animated&&s.toRect||i,a),E=a?"top":"left",D=Y(s,"top","top")||Y(z,"top","top"),S=D?D.scrollTop:void 0;if(ht!==s&&(m=i[E],yt=!1,wt=!w&&e.invertSwap||y),0!==(v=function(t,e,n,o,i,r,a,l){var s=o?t.clientY:t.clientX,c=o?n.height:n.width,u=o?n.top:n.left,d=o?n.bottom:n.right,h=!1;if(!a)if(l&&pt<c*i){if(!yt&&(1===ft?u+c*r/2<s:s<d-c*r/2)&&(yt=!0),yt)h=!0;else if(1===ft?s<u+pt:d-pt<s)return-ft}else if(u+c*(1-i)/2<s&&s<d-c*(1-i)/2)return function(t){return F(z)<F(t)?1:-1}(e);if((h=h||a)&&(s<u+c*r/2||d-c*r/2<s))return u+c/2<s?1:-1;return 0}(n,s,i,a,w?1:e.swapThreshold,null==e.invertedSwapThreshold?e.swapThreshold:e.invertedSwapThreshold,wt,ht===s)))for(var _=F(z);_-=v,(b=G.children[_])&&("none"===R(b,"display")||b===U););if(0===v||b===s)return A(!1);ft=v;var C=(ht=s).nextElementSibling,T=!1,x=Xt(q,l,z,o,s,i,n,T=1===v);if(!1!==x)return 1!==x&&-1!==x||(T=1===x),Dt=!0,setTimeout(Bt,30),O(),T&&!C?l.appendChild(z):s.parentNode.insertBefore(z,T?C:s),D&&L(D,0,S-D.scrollTop),G=z.parentNode,void 0===m||wt||(pt=Math.abs(m-X(s)[E])),N(),A(!0)}if(l.contains(z))return A(!1)}return!1}function M(t,e){K(t,f,I({evt:n,isOwner:u,axis:a?"vertical":"horizontal",revert:r,dragRect:o,targetRect:i,canSort:d,fromSortable:h,target:s,completed:A,onMove:function(t,e){return Xt(q,l,z,o,t,X(t),n,e)},changed:N},e))}function O(){M("dragOverAnimationCapture"),f.captureAnimationState(),f!==h&&h.captureAnimationState()}function A(t){return M("dragOverCompleted",{insertion:t}),t&&(u?c._hideClone():c._showClone(f),f!==h&&(k(z,it?it.options.ghostClass:c.options.ghostClass,!1),k(z,e.ghostClass,!0)),it!==f&&f!==Rt.active?it=f:f===Rt.active&&it&&(it=null),h===f&&(f._ignoreWhileAnimating=s),f.animateAll(function(){M("dragOverAnimationComplete"),f._ignoreWhileAnimating=null}),f!==h&&(h.animateAll(),h._ignoreWhileAnimating=null)),(s===z&&!z.animated||s===l&&!s.animated)&&(ht=null),e.dragoverBubble||n.rootEl||s===document||(z.parentNode[j]._isOutsideThisEl(n.target),t||Pt(n)),!e.dragoverBubble&&n.stopPropagation&&n.stopPropagation(),p=!0}function N(){tt=F(z),nt=F(z,e.draggable),W({sortable:f,name:"change",toEl:l,newIndex:tt,newDraggableIndex:nt,originalEvent:n})}},_ignoreWhileAnimating:null,_offMoveEvents:function(){d(document,"mousemove",this._onTouchMove),d(document,"touchmove",this._onTouchMove),d(document,"pointermove",this._onTouchMove),d(document,"dragover",Pt),d(document,"mousemove",Pt),d(document,"touchmove",Pt)},_offUpEvents:function(){var t=this.el.ownerDocument;d(t,"mouseup",this._onDrop),d(t,"touchend",this._onDrop),d(t,"pointerup",this._onDrop),d(t,"touchcancel",this._onDrop),d(document,"selectstart",this)},_onDrop:function(t){var e=this.el,n=this.options;tt=F(z),nt=F(z,n.draggable),K("drop",this,{evt:t}),G=z&&z.parentNode,tt=F(z),nt=F(z,n.draggable),Rt.eventCanceled||(yt=wt=vt=!1,clearInterval(this._loopId),clearTimeout(this._dragStartTimer),Lt(this.cloneId),Lt(this._dragStartId),this.nativeDraggable&&(d(document,"drop",this),d(e,"dragstart",this._onDragStart)),this._offMoveEvents(),this._offUpEvents(),s&&R(document.body,"user-select",""),R(z,"transform",""),t&&(dt&&(t.cancelable&&t.preventDefault(),n.dropBubble||t.stopPropagation()),U&&U.parentNode&&U.parentNode.removeChild(U),(q===G||it&&"clone"!==it.lastPutMode)&&Q&&Q.parentNode&&Q.parentNode.removeChild(Q),z&&(this.nativeDraggable&&d(z,"dragend",this),Yt(z),z.style["will-change"]="",dt&&!vt&&k(z,it?it.options.ghostClass:this.options.ghostClass,!1),k(z,this.options.chosenClass,!1),W({sortable:this,name:"unchoose",toEl:G,newIndex:null,newDraggableIndex:null,originalEvent:t}),q!==G?(0<=tt&&(W({rootEl:G,name:"add",toEl:G,fromEl:q,originalEvent:t}),W({sortable:this,name:"remove",toEl:G,originalEvent:t}),W({rootEl:G,name:"sort",toEl:G,fromEl:q,originalEvent:t}),W({sortable:this,name:"sort",toEl:G,originalEvent:t})),it&&it.save()):tt!==J&&0<=tt&&(W({sortable:this,name:"update",toEl:G,originalEvent:t}),W({sortable:this,name:"sort",toEl:G,originalEvent:t})),Rt.active&&(null!=tt&&-1!==tt||(tt=J,nt=et),W({sortable:this,name:"end",toEl:G,originalEvent:t}),this.save())))),this._nulling()},_nulling:function(){K("nulling",this),q=z=G=U=V=Q=Z=$=rt=at=dt=tt=nt=J=et=ht=ft=it=ot=Rt.dragged=Rt.ghost=Rt.clone=Rt.active=null,St.forEach(function(t){t.checked=!0}),St.length=lt=st=0},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":z&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="move");t.cancelable&&t.preventDefault()}(t));break;case"selectstart":t.preventDefault()}},toArray:function(){for(var t,e=[],n=this.el.children,o=0,i=n.length,r=this.options;o<i;o++)P(t=n[o],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||Ft(t));return e},sort:function(t){var o={},i=this.el;this.toArray().forEach(function(t,e){var n=i.children[e];P(n,this.options.draggable,i,!1)&&(o[t]=n)},this),t.forEach(function(t){o[t]&&(i.removeChild(o[t]),i.appendChild(o[t]))})},save:function(){var t=this.options.store;t&&t.set&&t.set(this)},closest:function(t,e){return P(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var n=this.options;if(void 0===e)return n[t];var o=O.modifyOption(this,t,e);n[t]=void 0!==o?o:e,"group"===t&&At(n)},destroy:function(){K("destroy",this);var t=this.el;t[j]=null,d(t,"mousedown",this._onTapStart),d(t,"touchstart",this._onTapStart),d(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(d(t,"dragover",this),d(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable")}),this._onDrop(),this._disableDelayedDragEvents(),bt.splice(bt.indexOf(this.el),1),this.el=t=null},_hideClone:function(){if(!$){if(K("hideClone",this),Rt.eventCanceled)return;R(Q,"display","none"),this.options.removeCloneOnHide&&Q.parentNode&&Q.parentNode.removeChild(Q),$=!0}},_showClone:function(t){if("clone"===t.lastPutMode){if($){if(K("showClone",this),Rt.eventCanceled)return;q.contains(z)&&!this.options.group.revertClone?q.insertBefore(Q,z):V?q.insertBefore(Q,V):q.appendChild(Q),this.options.group.revertClone&&this.animate(z,Q),R(Q,"display",""),$=!1}}else this._hideClone()}},_t&&u(document,"touchmove",function(t){(Rt.active||vt)&&t.cancelable&&t.preventDefault()}),Rt.utils={on:u,off:d,css:R,find:g,is:function(t,e){return!!P(t,e,t,!1)},extend:function(t,e){if(t&&e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t},throttle:D,closest:P,toggleClass:k,clone:S,index:F,nextTick:Ht,cancelNextTick:Lt,detectDirection:Ot,getChild:m},Rt.get=function(t){return t[j]},Rt.mount=function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];e[0].constructor===Array&&(e=e[0]),e.forEach(function(t){if(!t.prototype||!t.prototype.constructor)throw"Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t));t.utils&&(Rt.utils=I({},Rt.utils,t.utils)),O.mount(t)})},Rt.create=function(t,e){return new Rt(t,e)};var jt,Kt,Wt,zt,Gt,Ut,qt=[],Vt=!(Rt.version="1.10.2");function Zt(){qt.forEach(function(t){clearInterval(t.pid)}),qt=[]}function Qt(){clearInterval(Ut)}function $t(t){var e=t.originalEvent,n=t.putSortable,o=t.dragEl,i=t.activeSortable,r=t.dispatchSortableEvent,a=t.hideGhostForTarget,l=t.unhideGhostForTarget;if(e){var s=n||i;a();var c=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:e,u=document.elementFromPoint(c.clientX,c.clientY);l(),s&&!s.el.contains(u)&&(r("spill"),this.onSpill({dragEl:o,putSortable:n}))}}var Jt,te=D(function(n,t,e,o){if(t.scroll){var i,r=(n.touches?n.touches[0]:n).clientX,a=(n.touches?n.touches[0]:n).clientY,l=t.scrollSensitivity,s=t.scrollSpeed,c=N(),u=!1;Kt!==e&&(Kt=e,Zt(),jt=t.scroll,i=t.scrollFn,!0===jt&&(jt=H(e,!0)));var d=0,h=jt;do{var f=h,p=X(f),g=p.top,v=p.bottom,m=p.left,b=p.right,y=p.width,w=p.height,E=void 0,D=void 0,S=f.scrollWidth,_=f.scrollHeight,C=R(f),T=f.scrollLeft,x=f.scrollTop;D=f===c?(E=y<S&&("auto"===C.overflowX||"scroll"===C.overflowX||"visible"===C.overflowX),w<_&&("auto"===C.overflowY||"scroll"===C.overflowY||"visible"===C.overflowY)):(E=y<S&&("auto"===C.overflowX||"scroll"===C.overflowX),w<_&&("auto"===C.overflowY||"scroll"===C.overflowY));var M=E&&(Math.abs(b-r)<=l&&T+y<S)-(Math.abs(m-r)<=l&&!!T),O=D&&(Math.abs(v-a)<=l&&x+w<_)-(Math.abs(g-a)<=l&&!!x);if(!qt[d])for(var A=0;A<=d;A++)qt[A]||(qt[A]={});qt[d].vx==M&&qt[d].vy==O&&qt[d].el===f||(qt[d].el=f,qt[d].vx=M,qt[d].vy=O,clearInterval(qt[d].pid),0==M&&0==O||(u=!0,qt[d].pid=setInterval(function(){o&&0===this.layer&&Rt.active._onTouchMove(Gt);var t=qt[this.layer].vy?qt[this.layer].vy*s:0,e=qt[this.layer].vx?qt[this.layer].vx*s:0;"function"==typeof i&&"continue"!==i.call(Rt.dragged.parentNode[j],e,t,n,Gt,qt[this.layer].el)||L(qt[this.layer].el,e,t)}.bind({layer:d}),24))),d++}while(t.bubbleScroll&&h!==c&&(h=H(h,!1)));Vt=u}},30);function ee(){}function ne(){}ee.prototype={startIndex:null,dragStart:function(t){var e=t.oldDraggableIndex;this.startIndex=e},onSpill:function(t){var e=t.dragEl,n=t.putSortable;this.sortable.captureAnimationState(),n&&n.captureAnimationState();var o=m(this.sortable.el,this.startIndex,this.options);o?this.sortable.el.insertBefore(e,o):this.sortable.el.appendChild(e),this.sortable.animateAll(),n&&n.animateAll()},drop:$t},a(ee,{pluginName:"revertOnSpill"}),ne.prototype={onSpill:function(t){var e=t.dragEl,n=t.putSortable||this.sortable;n.captureAnimationState(),e.parentNode&&e.parentNode.removeChild(e),n.animateAll()},drop:$t},a(ne,{pluginName:"removeOnSpill"});var oe,ie,re,ae,le,se=[],ce=[],ue=!1,de=!1,he=!1;function fe(o,i){ce.forEach(function(t,e){var n=i.children[t.sortableIndex+(o?Number(e):0)];n?i.insertBefore(t,n):i.appendChild(t)})}function pe(){se.forEach(function(t){t!==re&&t.parentNode&&t.parentNode.removeChild(t)})}return Rt.mount(new function(){function t(){for(var t in this.defaults={scroll:!0,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0},this)"_"===t.charAt(0)&&"function"==typeof this[t]&&(this[t]=this[t].bind(this))}return t.prototype={dragStarted:function(t){var e=t.originalEvent;this.sortable.nativeDraggable?u(document,"dragover",this._handleAutoScroll):this.options.supportPointer?u(document,"pointermove",this._handleFallbackAutoScroll):e.touches?u(document,"touchmove",this._handleFallbackAutoScroll):u(document,"mousemove",this._handleFallbackAutoScroll)},dragOverCompleted:function(t){var e=t.originalEvent;this.options.dragOverBubble||e.rootEl||this._handleAutoScroll(e)},drop:function(){this.sortable.nativeDraggable?d(document,"dragover",this._handleAutoScroll):(d(document,"pointermove",this._handleFallbackAutoScroll),d(document,"touchmove",this._handleFallbackAutoScroll),d(document,"mousemove",this._handleFallbackAutoScroll)),Qt(),Zt(),clearTimeout(f),f=void 0},nulling:function(){Gt=Kt=jt=Vt=Ut=Wt=zt=null,qt.length=0},_handleFallbackAutoScroll:function(t){this._handleAutoScroll(t,!0)},_handleAutoScroll:function(e,n){var o=this,i=(e.touches?e.touches[0]:e).clientX,r=(e.touches?e.touches[0]:e).clientY,t=document.elementFromPoint(i,r);if(Gt=e,n||E||w||s){te(e,this.options,t,n);var a=H(t,!0);!Vt||Ut&&i===Wt&&r===zt||(Ut&&Qt(),Ut=setInterval(function(){var t=H(document.elementFromPoint(i,r),!0);t!==a&&(a=t,Zt()),te(e,o.options,t,n)},10),Wt=i,zt=r)}else{if(!this.options.bubbleScroll||H(t,!0)===N())return void Zt();te(e,this.options,H(t,!1),!1)}}},a(t,{pluginName:"scroll",initializeByDefault:!0})}),Rt.mount(ne,ee),Rt.mount(new function(){function t(){this.defaults={swapClass:"sortable-swap-highlight"}}return t.prototype={dragStart:function(t){var e=t.dragEl;Jt=e},dragOverValid:function(t){var e=t.completed,n=t.target,o=t.onMove,i=t.activeSortable,r=t.changed,a=t.cancel;if(i.options.swap){var l=this.sortable.el,s=this.options;if(n&&n!==l){var c=Jt;Jt=!1!==o(n)?(k(n,s.swapClass,!0),n):null,c&&c!==Jt&&k(c,s.swapClass,!1)}r(),e(!0),a()}},drop:function(t){var e=t.activeSortable,n=t.putSortable,o=t.dragEl,i=n||this.sortable,r=this.options;Jt&&k(Jt,r.swapClass,!1),Jt&&(r.swap||n&&n.options.swap)&&o!==Jt&&(i.captureAnimationState(),i!==e&&e.captureAnimationState(),function(t,e){var n,o,i=t.parentNode,r=e.parentNode;if(!i||!r||i.isEqualNode(e)||r.isEqualNode(t))return;n=F(t),o=F(e),i.isEqualNode(r)&&n<o&&o++;i.insertBefore(e,i.children[n]),r.insertBefore(t,r.children[o])}(o,Jt),i.animateAll(),i!==e&&e.animateAll())},nulling:function(){Jt=null}},a(t,{pluginName:"swap",eventProperties:function(){return{swapItem:Jt}}})}),Rt.mount(new function(){function t(o){for(var t in this)"_"===t.charAt(0)&&"function"==typeof this[t]&&(this[t]=this[t].bind(this));o.options.supportPointer?u(document,"pointerup",this._deselectMultiDrag):(u(document,"mouseup",this._deselectMultiDrag),u(document,"touchend",this._deselectMultiDrag)),u(document,"keydown",this._checkKeyDown),u(document,"keyup",this._checkKeyUp),this.defaults={selectedClass:"sortable-selected",multiDragKey:null,setData:function(t,e){var n="";se.length&&ie===o?se.forEach(function(t,e){n+=(e?", ":"")+t.textContent}):n=e.textContent,t.setData("Text",n)}}}return t.prototype={multiDragKeyDown:!1,isMultiDrag:!1,delayStartGlobal:function(t){var e=t.dragEl;re=e},delayEnded:function(){this.isMultiDrag=~se.indexOf(re)},setupClone:function(t){var e=t.sortable,n=t.cancel;if(this.isMultiDrag){for(var o=0;o<se.length;o++)ce.push(S(se[o])),ce[o].sortableIndex=se[o].sortableIndex,ce[o].draggable=!1,ce[o].style["will-change"]="",k(ce[o],this.options.selectedClass,!1),se[o]===re&&k(ce[o],this.options.chosenClass,!1);e._hideClone(),n()}},clone:function(t){var e=t.sortable,n=t.rootEl,o=t.dispatchSortableEvent,i=t.cancel;this.isMultiDrag&&(this.options.removeCloneOnHide||se.length&&ie===e&&(fe(!0,n),o("clone"),i()))},showClone:function(t){var e=t.cloneNowShown,n=t.rootEl,o=t.cancel;this.isMultiDrag&&(fe(!1,n),ce.forEach(function(t){R(t,"display","")}),e(),le=!1,o())},hideClone:function(t){var e=this,n=(t.sortable,t.cloneNowHidden),o=t.cancel;this.isMultiDrag&&(ce.forEach(function(t){R(t,"display","none"),e.options.removeCloneOnHide&&t.parentNode&&t.parentNode.removeChild(t)}),n(),le=!0,o())},dragStartGlobal:function(t){t.sortable;!this.isMultiDrag&&ie&&ie.multiDrag._deselectMultiDrag(),se.forEach(function(t){t.sortableIndex=F(t)}),se=se.sort(function(t,e){return t.sortableIndex-e.sortableIndex}),he=!0},dragStarted:function(t){var e=this,n=t.sortable;if(this.isMultiDrag){if(this.options.sort&&(n.captureAnimationState(),this.options.animation)){se.forEach(function(t){t!==re&&R(t,"position","absolute")});var o=X(re,!1,!0,!0);se.forEach(function(t){t!==re&&_(t,o)}),ue=de=!0}n.animateAll(function(){ue=de=!1,e.options.animation&&se.forEach(function(t){C(t)}),e.options.sort&&pe()})}},dragOver:function(t){var e=t.target,n=t.completed,o=t.cancel;de&&~se.indexOf(e)&&(n(!1),o())},revert:function(t){var e=t.fromSortable,n=t.rootEl,o=t.sortable,i=t.dragRect;1<se.length&&(se.forEach(function(t){o.addAnimationState({target:t,rect:de?X(t):i}),C(t),t.fromRect=i,e.removeAnimationState(t)}),de=!1,function(o,i){se.forEach(function(t,e){var n=i.children[t.sortableIndex+(o?Number(e):0)];n?i.insertBefore(t,n):i.appendChild(t)})}(!this.options.removeCloneOnHide,n))},dragOverCompleted:function(t){var e=t.sortable,n=t.isOwner,o=t.insertion,i=t.activeSortable,r=t.parentEl,a=t.putSortable,l=this.options;if(o){if(n&&i._hideClone(),ue=!1,l.animation&&1<se.length&&(de||!n&&!i.options.sort&&!a)){var s=X(re,!1,!0,!0);se.forEach(function(t){t!==re&&(_(t,s),r.appendChild(t))}),de=!0}if(!n)if(de||pe(),1<se.length){var c=le;i._showClone(e),i.options.animation&&!le&&c&&ce.forEach(function(t){i.addAnimationState({target:t,rect:ae}),t.fromRect=ae,t.thisAnimationDuration=null})}else i._showClone(e)}},dragOverAnimationCapture:function(t){var e=t.dragRect,n=t.isOwner,o=t.activeSortable;if(se.forEach(function(t){t.thisAnimationDuration=null}),o.options.animation&&!n&&o.multiDrag.isMultiDrag){ae=a({},e);var i=v(re,!0);ae.top-=i.f,ae.left-=i.e}},dragOverAnimationComplete:function(){de&&(de=!1,pe())},drop:function(t){var e=t.originalEvent,n=t.rootEl,o=t.parentEl,i=t.sortable,r=t.dispatchSortableEvent,a=t.oldIndex,l=t.putSortable,s=l||this.sortable;if(e){var c=this.options,u=o.children;if(!he)if(c.multiDragKey&&!this.multiDragKeyDown&&this._deselectMultiDrag(),k(re,c.selectedClass,!~se.indexOf(re)),~se.indexOf(re))se.splice(se.indexOf(re),1),oe=null,A({sortable:i,rootEl:n,name:"deselect",targetEl:re,originalEvt:e});else{if(se.push(re),A({sortable:i,rootEl:n,name:"select",targetEl:re,originalEvt:e}),e.shiftKey&&oe&&i.el.contains(oe)){var d,h,f=F(oe),p=F(re);if(~f&&~p&&f!==p)for(d=f<p?(h=f,p):(h=p,f+1);h<d;h++)~se.indexOf(u[h])||(k(u[h],c.selectedClass,!0),se.push(u[h]),A({sortable:i,rootEl:n,name:"select",targetEl:u[h],originalEvt:e}))}else oe=re;ie=s}if(he&&this.isMultiDrag){if((o[j].options.sort||o!==n)&&1<se.length){var g=X(re),v=F(re,":not(."+this.options.selectedClass+")");if(!ue&&c.animation&&(re.thisAnimationDuration=null),s.captureAnimationState(),!ue&&(c.animation&&(re.fromRect=g,se.forEach(function(t){if(t.thisAnimationDuration=null,t!==re){var e=de?X(t):g;t.fromRect=e,s.addAnimationState({target:t,rect:e})}})),pe(),se.forEach(function(t){u[v]?o.insertBefore(t,u[v]):o.appendChild(t),v++}),a===F(re))){var m=!1;se.forEach(function(t){t.sortableIndex===F(t)||(m=!0)}),m&&r("update")}se.forEach(function(t){C(t)}),s.animateAll()}ie=s}(n===o||l&&"clone"!==l.lastPutMode)&&ce.forEach(function(t){t.parentNode&&t.parentNode.removeChild(t)})}},nullingGlobal:function(){this.isMultiDrag=he=!1,ce.length=0},destroyGlobal:function(){this._deselectMultiDrag(),d(document,"pointerup",this._deselectMultiDrag),d(document,"mouseup",this._deselectMultiDrag),d(document,"touchend",this._deselectMultiDrag),d(document,"keydown",this._checkKeyDown),d(document,"keyup",this._checkKeyUp)},_deselectMultiDrag:function(t){if(!(void 0!==he&&he||ie!==this.sortable||t&&P(t.target,this.options.draggable,this.sortable.el,!1)||t&&0!==t.button))for(;se.length;){var e=se[0];k(e,this.options.selectedClass,!1),se.shift(),A({sortable:this.sortable,rootEl:this.sortable.el,name:"deselect",targetEl:e,originalEvt:t})}},_checkKeyDown:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!0)},_checkKeyUp:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!1)}},a(t,{pluginName:"multiDrag",utils:{select:function(t){var e=t.parentNode[j];e&&e.options.multiDrag&&!~se.indexOf(t)&&(ie&&ie!==e&&(ie.multiDrag._deselectMultiDrag(),ie=e),k(t,e.options.selectedClass,!0),se.push(t))},deselect:function(t){var e=t.parentNode[j],n=se.indexOf(t);e&&e.options.multiDrag&&~n&&(k(t,e.options.selectedClass,!1),se.splice(n,1))}},eventProperties:function(){var n=this,o=[],i=[];return se.forEach(function(t){var e;o.push({multiDragElement:t,index:t.sortableIndex}),e=de&&t!==re?-1:de?F(t,":not(."+n.options.selectedClass+")"):F(t),i.push({multiDragElement:t,index:e})}),{items:e(se),clones:[].concat(ce),oldIndicies:o,newIndicies:i}},optionListeners:{multiDragKey:function(t){return"ctrl"===(t=t.toLowerCase())?t="Control":1<t.length&&(t=t.charAt(0).toUpperCase()+t.substr(1)),t}}})}),Rt});
var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=['<table style="border:0;border-collapse:collapse;">'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+';"></td>');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();
(function (n) { n([], function () { var f = -1, e = -2, i = -3, n = -4, r = -5, h = function (s, h) { var l, c, a; h = h || {}; l = h.verbose || !1; l && console.log("Normalize the JSON Object"); s = typeof s == "string" ? this.JSON.parse(s) : s; l && console.log("Creating a empty dictionary"); c = { strings: [], integers: [], floats: [] }; l && console.log("Creating the AST"); var y = function v(s) { var y, w, a, p, h; if (l && console.log("Calling recursiveAstBuilder with " + this.JSON.stringify(s)), y = typeof s, s === null) return { type: "null", index: i }; if (typeof s == "undefined") return { type: "undefined", index: r }; if (s instanceof Array) { a = ["@"]; for (w in s) s.hasOwnProperty(w) && a.push(v(s[w])); return a } if (y === "object") { a = ["$"]; for (p in s) s.hasOwnProperty(p) && (a.push(v(p)), a.push(v(s[p]))); return a } if (s === "") return { type: "empty", index: n }; if (y === "string") return h = u.call(c.strings, s), h == -1 && (c.strings.push(o(s)), h = c.strings.length - 1), { type: "strings", index: h }; if (y === "number" && s % 1 == 0) return h = u.call(c.integers, s), h == -1 && (c.integers.push(t(s)), h = c.integers.length - 1), { type: "integers", index: h }; if (y === "number") return h = u.call(c.floats, s), h == -1 && (c.floats.push(s), h = c.floats.length - 1), { type: "floats", index: h }; if (y === "boolean") return { type: "boolean", index: s ? f : e }; throw new Error("Unexpected argument of type " + typeof s); }(s), p = c.strings.length, w = c.integers.length, k = c.floats.length; return (l && console.log("Parsing the dictionary"), a = c.strings.join("|"), a += "^" + c.integers.join("|"), a += "^" + c.floats.join("|"), l && console.log("Parsing the structure"), a += "^" + function b(u) { var e, s, f, o; if (l && console.log("Calling a recursiveParser with " + this.JSON.stringify(u)), u instanceof Array) { e = u.shift(); for (s in u) u.hasOwnProperty(s) && (e += b(u[s]) + "|"); return (e[e.length - 1] === "|" ? e.slice(0, -1) : e) + "]" } if (f = u.type, o = u.index, f === "strings") return t(o); if (f === "integers") return t(p + o); if (f === "floats") return t(p + w + o); if (f === "boolean") return u.index; if (f === "null") return i; if (f === "undefined") return r; if (f === "empty") return n; throw new TypeError("The item is alien!"); }(y), l && console.log("Ending parser"), h.debug) ? { dictionary: c, ast: y, packed: a } : a }, c = function (t, u) { var p, v, o, w, h, a, k, c; if (u = u || {}, p = t.split("^"), u.verbose && console.log("Building dictionary"), v = [], o = p[0], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the strings dictionary"), h = 0, w = o.length; h < w; h++) v.push(l(o[h])); if (o = p[1], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the integers dictionary"), h = 0, w = o.length; h < w; h++) v.push(s(o[h])); if (o = p[2], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the floats dictionary"), h = 0, w = o.length; h < w; h++) v.push(parseFloat(o[h])); o = null; u.verbose && console.log("Tokenizing the structure"); var b = "", y = [], g = p[3].length; for (h = 0; h < g; h++) a = p[3].charAt(h), a === "|" || a === "$" || a === "@" || a === "]" ? (b && (y.push(s(b)), b = ""), a !== "|" && y.push(a)) : b += a; return k = y.length, c = 0, u.verbose && console.log("Starting recursive parser"), function d() { var h = y[c++], t, s, o; if (u.verbose && console.log("Reading collection type " + (h === "$" ? "object" : "Array")), h === "@") { for (t = []; c < k; c++) { if (o = y[c], u.verbose && console.log("Read " + o + " symbol"), o === "]") return t; if (o === "@" || o === "$") t.push(d()); else switch (o) { case f: t.push(!0); break; case e: t.push(!1); break; case i: t.push(null); break; case r: t.push(undefined); break; case n: t.push(""); break; default: t.push(v[o]) } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } if (h === "$") { for (t = {}; c < k; c++) { if (s = y[c], s === "]") return t; if (s = s === n ? "" : v[s], o = y[++c], o === "@" || o === "$") t[s] = d(); else switch (o) { case f: t[s] = !0; break; case e: t[s] = !1; break; case i: t[s] = null; break; case r: t[s] = undefined; break; case n: t[s] = ""; break; default: t[s] = v[o] } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } throw new TypeError("Bad token " + h + " isn't a type"); }() }, a = function (s, h) { var c = typeof h, l; if (c === "boolean") return h ? f : e; if (h === null) return i; if (typeof h == "undefined") return r; if (h === "") return n; if (c === "string" && (h = o(h), l = u.call(s.strings, h), l === -1 && (s.strings.push(h), l = s.strings.length - 1)), c !== "string" && c !== "number") throw new Error("The type is not a JSON type"); return c === "string" ? h = o(h) : h % 1 == 0 && (h = t(h)), h = c === "number" ? t(h) : o(h), l = u.call(s[c], h), l === -1 && (s[c].push(h), l = s[c].length - 1), c === "number" ? "+" + l : l }, o = function (n) { return typeof n != "string" ? n : n.replace(/[\+ \|\^\%]/g, function (n) { return { " ": "+", "+": "%2B", "|": "%7C", "^": "%5E", "%": "%25" }[n] }) }, l = function (n) { return typeof n != "string" ? n : n.replace(/\+|%2B|%7C|%5E|%25/g, function (n) { return { "+": " ", "%2B": "+", "%7C": "|", "%5E": "^", "%25": "%" }[n] }) }, t = function (n) { return Number.prototype.toString.call(n, 36).toUpperCase() }, s = function (n) { return parseInt(n, 36) }, u = Array.prototype.indexOf || function (n, t) { for (var i = t || 0, r = this.length; i < r; i++) if (this[i] === n) return i; return -1 }; return { JSON: JSON, pack: h, unpack: c } }) })(typeof define == "undefined" || !define.amd ? function (n, t) { var i = t(), r; if (typeof exports != "undefined") for (r in i) exports[r] = i[r]; else window.jsonpack = i } : define);
/*!
 * UAParser.js v0.7.21
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2019 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */
(function(window,undefined){"use strict";var LIBVERSION="0.7.21",EMPTY="",UNKNOWN="?",FUNC_TYPE="function",UNDEF_TYPE="undefined",OBJ_TYPE="object",STR_TYPE="string",MAJOR="major",MODEL="model",NAME="name",TYPE="type",VENDOR="vendor",VERSION="version",ARCHITECTURE="architecture",CONSOLE="console",MOBILE="mobile",TABLET="tablet",SMARTTV="smarttv",WEARABLE="wearable",EMBEDDED="embedded";var util={extend:function(regexes,extensions){var mergedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){mergedRegexes[i]=extensions[i].concat(regexes[i])}else{mergedRegexes[i]=regexes[i]}}return mergedRegexes},has:function(str1,str2){if(typeof str1==="string"){return str2.toLowerCase().indexOf(str1.toLowerCase())!==-1}else{return false}},lowerize:function(str){return str.toLowerCase()},major:function(version){return typeof version===STR_TYPE?version.replace(/[^\d\.]/g,"").split(".")[0]:undefined},trim:function(str){return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}};var mapper={rgx:function(ua,arrays){var i=0,j,k,p,q,matches,match;while(i<arrays.length&&!matches){var regex=arrays[i],props=arrays[i+1];j=k=0;while(j<regex.length&&!matches){matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];if(typeof q===OBJ_TYPE&&q.length>0){if(q.length==2){if(typeof q[1]==FUNC_TYPE){this[q[0]]=q[1].call(this,match)}else{this[q[0]]=q[1]}}else if(q.length==3){if(typeof q[1]===FUNC_TYPE&&!(q[1].exec&&q[1].test)){this[q[0]]=match?q[1].call(this,match,q[2]):undefined}else{this[q[0]]=match?match.replace(q[1],q[2]):undefined}}else if(q.length==4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined}}else{this[q]=match?match:undefined}}}}i+=2}},str:function(str,map){for(var i in map){if(typeof map[i]===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(util.has(map[i][j],str)){return i===UNKNOWN?undefined:i}}}else if(util.has(map[i],str)){return i===UNKNOWN?undefined:i}}return str}};var maps={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}};var regexes={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[NAME,VERSION],[/(opios)[\/\s]+([\w\.]+)/i],[[NAME,"Opera Mini"],VERSION],[/\s(opr)\/([\w\.]+)/i],[[NAME,"Opera"],VERSION],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,/(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i,/(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]*)/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i],[NAME,VERSION],[/(konqueror)\/([\w\.]+)/i],[[NAME,"Konqueror"],VERSION],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[NAME,"IE"],VERSION],[/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i],[[NAME,"Edge"],VERSION],[/(yabrowser)\/([\w\.]+)/i],[[NAME,"Yandex"],VERSION],[/(Avast)\/([\w\.]+)/i],[[NAME,"Avast Secure Browser"],VERSION],[/(AVG)\/([\w\.]+)/i],[[NAME,"AVG Secure Browser"],VERSION],[/(puffin)\/([\w\.]+)/i],[[NAME,"Puffin"],VERSION],[/(focus)\/([\w\.]+)/i],[[NAME,"Firefox Focus"],VERSION],[/(opt)\/([\w\.]+)/i],[[NAME,"Opera Touch"],VERSION],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[NAME,"UCBrowser"],VERSION],[/(comodo_dragon)\/([\w\.]+)/i],[[NAME,/_/g," "],VERSION],[/(windowswechat qbcore)\/([\w\.]+)/i],[[NAME,"WeChat(Win) Desktop"],VERSION],[/(micromessenger)\/([\w\.]+)/i],[[NAME,"WeChat"],VERSION],[/(brave)\/([\w\.]+)/i],[[NAME,"Brave"],VERSION],[/(qqbrowserlite)\/([\w\.]+)/i],[NAME,VERSION],[/(QQ)\/([\d\.]+)/i],[NAME,VERSION],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(baiduboxapp)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(2345Explorer)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(MetaSr)[\/\s]?([\w\.]+)/i],[NAME],[/(LBBROWSER)/i],[NAME],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[VERSION,[NAME,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[VERSION,[NAME,"Facebook"]],[/safari\s(line)\/([\w\.]+)/i,/android.+(line)\/([\w\.]+)\/iab/i],[NAME,VERSION],[/headlesschrome(?:\/([\w\.]+)|\s)/i],[VERSION,[NAME,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[NAME,/(.+)/,"$1 WebView"],VERSION],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[NAME,/(.+(?:g|us))(.+)/,"$1 $2"],VERSION],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[VERSION,[NAME,"Android Browser"]],[/(sailfishbrowser)\/([\w\.]+)/i],[[NAME,"Sailfish Browser"],VERSION],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[NAME,VERSION],[/(dolfin)\/([\w\.]+)/i],[[NAME,"Dolphin"],VERSION],[/(qihu|qhbrowser|qihoobrowser|360browser)/i],[[NAME,"360 Browser"]],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[NAME,"Chrome"],VERSION],[/(coast)\/([\w\.]+)/i],[[NAME,"Opera Coast"],VERSION],[/fxios\/([\w\.-]+)/i],[VERSION,[NAME,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[VERSION,[NAME,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[VERSION,NAME],[/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[[NAME,"GSA"],VERSION],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[NAME,[VERSION,mapper.str,maps.browser.oldsafari.version]],[/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[/(navigator|netscape)\/([\w\.-]+)/i],[[NAME,"Netscape"],VERSION],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]*)/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[NAME,VERSION]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[[ARCHITECTURE,"amd64"]],[/(ia32(?=;))/i],[[ARCHITECTURE,util.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[[ARCHITECTURE,"ia32"]],[/windows\s(ce|mobile);\sppc;/i],[[ARCHITECTURE,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[[ARCHITECTURE,/ower/,"",util.lowerize]],[/(sun4\w)[;\)]/i],[[ARCHITECTURE,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[[ARCHITECTURE,util.lowerize]]],device:[[/\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i],[MODEL,VENDOR,[TYPE,TABLET]],[/applecoremedia\/[\w\.]+ \((ipad)/],[MODEL,[VENDOR,"Apple"],[TYPE,TABLET]],[/(apple\s{0,1}tv)/i],[[MODEL,"Apple TV"],[VENDOR,"Apple"],[TYPE,SMARTTV]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(kf[A-z]+)\sbuild\/.+silk\//i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],[[MODEL,mapper.str,maps.device.amazon.model],[VENDOR,"Amazon"],[TYPE,MOBILE]],[/android.+aft([bms])\sbuild/i],[MODEL,[VENDOR,"Amazon"],[TYPE,SMARTTV]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[MODEL,VENDOR,[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);/i],[MODEL,[VENDOR,"Apple"],[TYPE,MOBILE]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/\(bb10;\s(\w+)/i],[MODEL,[VENDOR,"BlackBerry"],[TYPE,MOBILE]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i],[MODEL,[VENDOR,"Asus"],[TYPE,TABLET]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[VENDOR,"Sony"],[MODEL,"Xperia Tablet"],[TYPE,TABLET]],[/android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[MODEL,[VENDOR,"Sony"],[TYPE,MOBILE]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[VENDOR,MODEL,[TYPE,CONSOLE]],[/android.+;\s(shield)\sbuild/i],[MODEL,[VENDOR,"Nvidia"],[TYPE,CONSOLE]],[/(playstation\s[34portablevi]+)/i],[MODEL,[VENDOR,"Sony"],[TYPE,CONSOLE]],[/(sprint\s(\w+))/i],[[VENDOR,mapper.str,maps.device.sprint.vendor],[MODEL,mapper.str,maps.device.sprint.model],[TYPE,MOBILE]],[/(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,/(zte)-(\w*)/i,/(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],[VENDOR,[MODEL,/_/g," "],[TYPE,MOBILE]],[/(nexus\s9)/i],[MODEL,[VENDOR,"HTC"],[TYPE,TABLET]],[/d\/huawei([\w\s-]+)[;\)]/i,/(nexus\s6p|vog-l29|ane-lx1|eml-l29)/i],[MODEL,[VENDOR,"Huawei"],[TYPE,MOBILE]],[/android.+(bah2?-a?[lw]\d{2})/i],[MODEL,[VENDOR,"Huawei"],[TYPE,TABLET]],[/(microsoft);\s(lumia[\s\w]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[MODEL,[VENDOR,"Microsoft"],[TYPE,CONSOLE]],[/(kin\.[onetw]{3})/i],[[MODEL,/\./g," "],[VENDOR,"Microsoft"],[TYPE,MOBILE]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w*)/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[MODEL,[VENDOR,"Motorola"],[TYPE,MOBILE]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[MODEL,[VENDOR,"Motorola"],[TYPE,TABLET]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[VENDOR,util.trim],[MODEL,util.trim],[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,"SmartTV"],[VENDOR,"Samsung"],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i],[MODEL,[VENDOR,"Sharp"],[TYPE,SMARTTV]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,TABLET]],[/smart-tv.+(samsung)/i],[VENDOR,[TYPE,SMARTTV],MODEL],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,/sec-((sgh\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,MOBILE]],[/sie-(\w*)/i],[MODEL,[VENDOR,"Siemens"],[TYPE,MOBILE]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]*)/i],[[VENDOR,"Nokia"],MODEL,[TYPE,MOBILE]],[/android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i],[MODEL,[VENDOR,"Acer"],[TYPE,TABLET]],[/android.+([vl]k\-?\d{3})\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,TABLET]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[VENDOR,"LG"],MODEL,[TYPE,TABLET]],[/(lg) netcast\.tv/i],[VENDOR,MODEL,[TYPE,SMARTTV]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w*)/i,/android.+lg(\-?[\d\w]+)\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,MOBILE]],[/(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[MODEL,[VENDOR,"Lenovo"],[TYPE,TABLET]],[/(lenovo)[_\s-]?([\w-]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/linux;.+((jolla));/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/((pebble))app\/[\d\.]+\s/i],[VENDOR,MODEL,[TYPE,WEARABLE]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/crkey/i],[[MODEL,"Chromecast"],[VENDOR,"Google"],[TYPE,SMARTTV]],[/android.+;\s(glass)\s\d/i],[MODEL,[VENDOR,"Google"],[TYPE,WEARABLE]],[/android.+;\s(pixel c)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,TABLET]],[/android.+;\s(pixel( [23])?( xl)?)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,MOBILE]],[/android.+;\s(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,/android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,MOBILE]],[/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,TABLET]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[MODEL,[VENDOR,"Meizu"],[TYPE,MOBILE]],[/(mz)-([\w-]{2,})/i],[[VENDOR,"Meizu"],MODEL,[TYPE,MOBILE]],[/android.+a000(1)\s+build/i,/android.+oneplus\s(a\d{4})[\s)]/i],[MODEL,[VENDOR,"OnePlus"],[TYPE,MOBILE]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[MODEL,[VENDOR,"RCA"],[TYPE,TABLET]],[/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],[MODEL,[VENDOR,"Dell"],[TYPE,TABLET]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[MODEL,[VENDOR,"Verizon"],[TYPE,TABLET]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],[[VENDOR,"Barnes & Noble"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[MODEL,[VENDOR,"NuVision"],[TYPE,TABLET]],[/android.+;\s(k88)\sbuild/i],[MODEL,[VENDOR,"ZTE"],[TYPE,TABLET]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[MODEL,[VENDOR,"Swiss"],[TYPE,MOBILE]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[MODEL,[VENDOR,"Swiss"],[TYPE,TABLET]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[MODEL,[VENDOR,"Zeki"],[TYPE,TABLET]],[/(android).+[;\/]\s+([YR]\d{2})\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],[[VENDOR,"Dragon Touch"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],[MODEL,[VENDOR,"Insignia"],[TYPE,TABLET]],[/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],[MODEL,[VENDOR,"NextBook"],[TYPE,TABLET]],[/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[VENDOR,"Voice"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],[[VENDOR,"LvTel"],MODEL,[TYPE,MOBILE]],[/android.+;\s(PH-1)\s/i],[MODEL,[VENDOR,"Essential"],[TYPE,MOBILE]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[MODEL,[VENDOR,"Envizen"],[TYPE,TABLET]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],[MODEL,[VENDOR,"MachSpeed"],[TYPE,TABLET]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[MODEL,[VENDOR,"Rotor"],[TYPE,TABLET]],[/android.+(KS(.+))\s+build/i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[TYPE,util.lowerize],VENDOR,MODEL],[/[\s\/\(](smart-?tv)[;\)]/i],[[TYPE,SMARTTV]],[/(android[\w\.\s\-]{0,9});.+build/i],[MODEL,[VENDOR,"Generic"]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[VERSION,[NAME,"EdgeHTML"]],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[VERSION,[NAME,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9}).+(gecko)/i],[VERSION,NAME]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[NAME,VERSION],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[NAME,[VERSION,mapper.str,maps.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[NAME,"Windows"],[VERSION,mapper.str,maps.os.windows.version]],[/\((bb)(10);/i],[[NAME,"BlackBerry"],VERSION],[/(blackberry)\w*\/?([\w\.]*)/i,/(tizen|kaios)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i],[NAME,VERSION],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],[[NAME,"Symbian"],VERSION],[/\((series40);/i],[NAME],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[NAME,"Firefox OS"],VERSION],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w*)/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,/(hurd|linux)\s?([\w\.]*)/i,/(gnu)\s?([\w\.]*)/i],[NAME,VERSION],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[NAME,"Chromium OS"],VERSION],[/(sunos)\s?([\w\.\d]*)/i],[[NAME,"Solaris"],VERSION],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],[NAME,VERSION],[/(haiku)\s(\w+)/i],[NAME,VERSION],[/cfnetwork\/.+darwin/i,/ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],[[VERSION,/_/g,"."],[NAME,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]*)/i,/(macintosh|mac(?=_powerpc)\s)/i],[[NAME,"Mac OS"],[VERSION,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]*)/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,/(unix)\s?([\w\.]*)/i],[NAME,VERSION]]};var UAParser=function(uastring,extensions){if(typeof uastring==="object"){extensions=uastring;uastring=undefined}if(!(this instanceof UAParser)){return new UAParser(uastring,extensions).getResult()}var ua=uastring||(window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:EMPTY);var rgxmap=extensions?util.extend(regexes,extensions):regexes;this.getBrowser=function(){var browser={name:undefined,version:undefined};mapper.rgx.call(browser,ua,rgxmap.browser);browser.major=util.major(browser.version);return browser};this.getCPU=function(){var cpu={architecture:undefined};mapper.rgx.call(cpu,ua,rgxmap.cpu);return cpu};this.getDevice=function(){var device={vendor:undefined,model:undefined,type:undefined};mapper.rgx.call(device,ua,rgxmap.device);return device};this.getEngine=function(){var engine={name:undefined,version:undefined};mapper.rgx.call(engine,ua,rgxmap.engine);return engine};this.getOS=function(){var os={name:undefined,version:undefined};mapper.rgx.call(os,ua,rgxmap.os);return os};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return ua};this.setUA=function(uastring){ua=uastring;return this};return this};UAParser.VERSION=LIBVERSION;UAParser.BROWSER={NAME:NAME,MAJOR:MAJOR,VERSION:VERSION};UAParser.CPU={ARCHITECTURE:ARCHITECTURE};UAParser.DEVICE={MODEL:MODEL,VENDOR:VENDOR,TYPE:TYPE,CONSOLE:CONSOLE,MOBILE:MOBILE,SMARTTV:SMARTTV,TABLET:TABLET,WEARABLE:WEARABLE,EMBEDDED:EMBEDDED};UAParser.ENGINE={NAME:NAME,VERSION:VERSION};UAParser.OS={NAME:NAME,VERSION:VERSION};if(typeof exports!==UNDEF_TYPE){if(typeof module!==UNDEF_TYPE&&module.exports){exports=module.exports=UAParser}exports.UAParser=UAParser}else{if(typeof define==="function"&&define.amd){define(function(){return UAParser})}else if(window){window.UAParser=UAParser}}var $=window&&(window.jQuery||window.Zepto);if($&&!$.ua){var parser=new UAParser;$.ua=parser.getResult();$.ua.get=function(){return parser.getUA()};$.ua.set=function(uastring){parser.setUA(uastring);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop]}}}})(typeof window==="object"?window:this);
!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):t.proj4=s()}(this,function(){"use strict";function t(t,s){if(t[s])return t[s];for(var i,a=Object.keys(t),h=s.toLowerCase().replace(dt,""),e=-1;++e<a.length;)if(i=a[e],i.toLowerCase().replace(dt,"")===h)return t[i]}function s(t){if("string"!=typeof t)throw new Error("not a string");this.text=t.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=_t}function i(t){return new s(t).output()}function a(t,s,i){Array.isArray(s)&&(i.unshift(s),s=null);var a=s?{}:t,e=i.reduce(function(t,s){return h(s,t),t},a);s&&(t[s]=e)}function h(t,s){if(Array.isArray(t)){var i=t.shift();if("PARAMETER"===i&&(i=t.shift()),1===t.length)return Array.isArray(t[0])?(s[i]={},void h(t[0],s[i])):void(s[i]=t[0]);if(t.length)if("TOWGS84"!==i){Array.isArray(i)||(s[i]={});var e;switch(i){case"UNIT":case"PRIMEM":case"VERT_DATUM":return s[i]={name:t[0].toLowerCase(),convert:t[1]},void(3===t.length&&h(t[2],s[i]));case"SPHEROID":case"ELLIPSOID":return s[i]={name:t[0],a:t[1],rf:t[2]},void(4===t.length&&h(t[3],s[i]));case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"EDATUM":case"ENGINEERINGDATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":case"COMPD_CS":case"COMPOUNDCRS":case"ENGINEERINGCRS":case"ENGCRS":case"FITTED_CS":case"LOCAL_DATUM":case"DATUM":return t[0]=["name",t[0]],void a(s,i,t);default:for(e=-1;++e<t.length;)if(!Array.isArray(t[e]))return h(t,s[i]);return a(s,i,t)}}else s[i]=t;else s[i]=!0}else s[t]=!0}function e(t,s){var i=s[0],a=s[1];!(i in t)&&a in t&&(t[i]=t[a],3===s.length&&(t[i]=s[2](t[i])))}function n(t){return t*At}function r(t){function s(s){return s*(t.to_meter||1)}"GEOGCS"===t.type?t.projName="longlat":"LOCAL_CS"===t.type?(t.projName="identity",t.local=!0):"object"==typeof t.PROJECTION?t.projName=Object.keys(t.PROJECTION)[0]:t.projName=t.PROJECTION,t.UNIT&&(t.units=t.UNIT.name.toLowerCase(),"metre"===t.units&&(t.units="meter"),t.UNIT.convert&&("GEOGCS"===t.type?t.DATUM&&t.DATUM.SPHEROID&&(t.to_meter=t.UNIT.convert*t.DATUM.SPHEROID.a):t.to_meter=t.UNIT.convert));var i=t.GEOGCS;"GEOGCS"===t.type&&(i=t),i&&(i.DATUM?t.datumCode=i.DATUM.name.toLowerCase():t.datumCode=i.name.toLowerCase(),"d_"===t.datumCode.slice(0,2)&&(t.datumCode=t.datumCode.slice(2)),"new_zealand_geodetic_datum_1949"!==t.datumCode&&"new_zealand_1949"!==t.datumCode||(t.datumCode="nzgd49"),"wgs_1984"===t.datumCode&&("Mercator_Auxiliary_Sphere"===t.PROJECTION&&(t.sphere=!0),t.datumCode="wgs84"),"_ferro"===t.datumCode.slice(-6)&&(t.datumCode=t.datumCode.slice(0,-6)),"_jakarta"===t.datumCode.slice(-8)&&(t.datumCode=t.datumCode.slice(0,-8)),~t.datumCode.indexOf("belge")&&(t.datumCode="rnb72"),i.DATUM&&i.DATUM.SPHEROID&&(t.ellps=i.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===t.ellps.toLowerCase().slice(0,13)&&(t.ellps="intl"),t.a=i.DATUM.SPHEROID.a,t.rf=parseFloat(i.DATUM.SPHEROID.rf,10)),i.DATUM&&i.DATUM.TOWGS84&&(t.datum_params=i.DATUM.TOWGS84),~t.datumCode.indexOf("osgb_1936")&&(t.datumCode="osgb36"),~t.datumCode.indexOf("osni_1952")&&(t.datumCode="osni52"),(~t.datumCode.indexOf("tm65")||~t.datumCode.indexOf("geodetic_datum_of_1965"))&&(t.datumCode="ire65"),"ch1903+"===t.datumCode&&(t.datumCode="ch1903"),~t.datumCode.indexOf("israel")&&(t.datumCode="isr93")),t.b&&!isFinite(t.b)&&(t.b=t.a);[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_2","Standard_Parallel_2"],["false_easting","False_Easting"],["false_northing","False_Northing"],["central_meridian","Central_Meridian"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_Of_Center"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",n],["longitude_of_center","Longitude_Of_Center"],["longitude_of_center","Longitude_of_center"],["longc","longitude_of_center",n],["x0","false_easting",s],["y0","false_northing",s],["long0","central_meridian",n],["lat0","latitude_of_origin",n],["lat0","standard_parallel_1",n],["lat1","standard_parallel_1",n],["lat2","standard_parallel_2",n],["azimuth","Azimuth"],["alpha","azimuth",n],["srsCode","name"]].forEach(function(s){return e(t,s)}),t.long0||!t.longc||"Albers_Conic_Equal_Area"!==t.projName&&"Lambert_Azimuthal_Equal_Area"!==t.projName||(t.long0=t.longc),t.lat_ts||!t.lat1||"Stereographic_South_Pole"!==t.projName&&"Polar Stereographic (variant B)"!==t.projName||(t.lat0=n(t.lat1>0?90:-90),t.lat_ts=t.lat1)}function o(t){var s=this;if(2===arguments.length){var i=arguments[1];"string"==typeof i?"+"===i.charAt(0)?o[t]=yt(arguments[1]):o[t]=Ct(arguments[1]):o[t]=i}else if(1===arguments.length){if(Array.isArray(t))return t.map(function(t){Array.isArray(t)?o.apply(s,t):o(t)});if("string"==typeof t){if(t in o)return o[t]}else"EPSG"in t?o["EPSG:"+t.EPSG]=t:"ESRI"in t?o["ESRI:"+t.ESRI]=t:"IAU2000"in t?o["IAU2000:"+t.IAU2000]=t:console.log(t);return}}function l(t){return"string"==typeof t}function M(t){return t in o}function c(t){return Et.some(function(s){return t.indexOf(s)>-1})}function u(s){var i=t(s,"authority");if(i){var a=t(i,"epsg");return a&&Pt.indexOf(a)>-1}}function f(s){var i=t(s,"extension");if(i)return t(i,"proj4")}function m(t){return"+"===t[0]}function p(t){if(!l(t))return t;if(M(t))return o[t];if(c(t)){var s=Ct(t);if(u(s))return o["EPSG:3857"];var i=f(s);return i?yt(i):s}return m(t)?yt(t):void 0}function d(t){return t}function y(t,s){var i=Tt.length;return t.names?(Tt[i]=t,t.names.forEach(function(t){Gt[t.toLowerCase()]=i}),this):(console.log(s),!0)}function _(t,s,i,a){var h=t*t,e=s*s,n=(h-e)/h,r=0;return a?(h=(t*=1-n*(et+n*(nt+n*rt)))*t,n=0):r=Math.sqrt(n),{es:n,e:r,ep2:(h-e)/e}}function x(s,i,a,h,e){if(!s){var n=t(zt,h);n||(n=Lt),s=n.a,i=n.b,a=n.rf}return a&&!i&&(i=(1-1/a)*s),(0===a||Math.abs(s-i)<ot)&&(e=!0,i=s),{a:s,b:i,rf:a,sphere:e}}function v(t,s,i,a,h,e){var n={};return n.datum_type=void 0===t||"none"===t?it:st,s&&(n.datum_params=s.map(parseFloat),0===n.datum_params[0]&&0===n.datum_params[1]&&0===n.datum_params[2]||(n.datum_type=$),n.datum_params.length>3&&(0===n.datum_params[3]&&0===n.datum_params[4]&&0===n.datum_params[5]&&0===n.datum_params[6]||(n.datum_type=tt,n.datum_params[3]*=at,n.datum_params[4]*=at,n.datum_params[5]*=at,n.datum_params[6]=n.datum_params[6]/1e6+1))),n.a=i,n.b=a,n.es=h,n.ep2=e,n}function Projection(s,i){if(!(this instanceof Projection))return new Projection(s);i=i||function(t){if(t)throw t};var a=p(s);if("object"==typeof a){var h=Projection.projections.get(a.projName);if(h){if(a.datumCode&&"none"!==a.datumCode){var e=t(Dt,a.datumCode);e&&(a.datum_params=e.towgs84?e.towgs84.split(","):null,a.ellps=e.ellipse,a.datumName=e.datumName?e.datumName:a.datumCode)}a.k0=a.k0||1,a.axis=a.axis||"enu",a.ellps=a.ellps||"wgs84";var n=x(a.a,a.b,a.rf,a.ellps,a.sphere),r=_(n.a,n.b,n.rf,a.R_A),o=a.datum||v(a.datumCode,a.datum_params,n.a,n.b,r.es,r.ep2);Nt(this,a),Nt(this,h),this.a=n.a,this.b=n.b,this.rf=n.rf,this.sphere=n.sphere,this.es=r.es,this.e=r.e,this.ep2=r.ep2,this.datum=o,this.init(),i(null,this)}else i(s)}else i(s)}function g(t,s){return t.datum_type===s.datum_type&&(!(t.a!==s.a||Math.abs(t.es-s.es)>5e-11)&&(t.datum_type===$?t.datum_params[0]===s.datum_params[0]&&t.datum_params[1]===s.datum_params[1]&&t.datum_params[2]===s.datum_params[2]:t.datum_type!==tt||t.datum_params[0]===s.datum_params[0]&&t.datum_params[1]===s.datum_params[1]&&t.datum_params[2]===s.datum_params[2]&&t.datum_params[3]===s.datum_params[3]&&t.datum_params[4]===s.datum_params[4]&&t.datum_params[5]===s.datum_params[5]&&t.datum_params[6]===s.datum_params[6]))}function b(t,s,i){var a,h,e,n,r=t.x,o=t.y,l=t.z?t.z:0;if(o<-ht&&o>-1.001*ht)o=-ht;else if(o>ht&&o<1.001*ht)o=ht;else{if(o<-ht)return{x:-1/0,y:-1/0,z:t.z};if(o>ht)return{x:1/0,y:1/0,z:t.z}}return r>Math.PI&&(r-=2*Math.PI),h=Math.sin(o),n=Math.cos(o),e=h*h,a=i/Math.sqrt(1-s*e),{x:(a+l)*n*Math.cos(r),y:(a+l)*n*Math.sin(r),z:(a*(1-s)+l)*h}}function w(t,s,i,a){var h,e,n,r,o,l,M,c,u,f,m,p,d,y,_,x,v=t.x,g=t.y,b=t.z?t.z:0;if(h=Math.sqrt(v*v+g*g),e=Math.sqrt(v*v+g*g+b*b),h/i<1e-12){if(y=0,e/i<1e-12)return _=ht,x=-a,{x:t.x,y:t.y,z:t.z}}else y=Math.atan2(g,v);n=b/e,c=(r=h/e)*(1-s)*(o=1/Math.sqrt(1-s*(2-s)*r*r)),u=n*o,d=0;do{d++,l=s*(M=i/Math.sqrt(1-s*u*u))/(M+(x=h*c+b*u-M*(1-s*u*u))),p=(m=n*(o=1/Math.sqrt(1-l*(2-l)*r*r)))*c-(f=r*(1-l)*o)*u,c=f,u=m}while(p*p>1e-24&&d<30);return _=Math.atan(m/Math.abs(f)),{x:y,y:_,z:x}}function A(t,s,i){if(s===$)return{x:t.x+i[0],y:t.y+i[1],z:t.z+i[2]};if(s===tt){var a=i[0],h=i[1],e=i[2],n=i[3],r=i[4],o=i[5],l=i[6];return{x:l*(t.x-o*t.y+r*t.z)+a,y:l*(o*t.x+t.y-n*t.z)+h,z:l*(-r*t.x+n*t.y+t.z)+e}}}function C(t,s,i){if(s===$)return{x:t.x-i[0],y:t.y-i[1],z:t.z-i[2]};if(s===tt){var a=i[0],h=i[1],e=i[2],n=i[3],r=i[4],o=i[5],l=i[6],M=(t.x-a)/l,c=(t.y-h)/l,u=(t.z-e)/l;return{x:M+o*c-r*u,y:-o*M+c+n*u,z:r*M-n*c+u}}}function E(t){return t===$||t===tt}function P(t){if("function"==typeof Number.isFinite){if(Number.isFinite(t))return;throw new TypeError("coordinates must be finite numbers")}if("number"!=typeof t||t!==t||!isFinite(t))throw new TypeError("coordinates must be finite numbers")}function N(t,s){return(t.datum.datum_type===$||t.datum.datum_type===tt)&&"WGS84"!==s.datumCode||(s.datum.datum_type===$||s.datum.datum_type===tt)&&"WGS84"!==t.datumCode}function S(t,s,i){var a;return Array.isArray(i)&&(i=Ft(i)),Qt(i),t.datum&&s.datum&&N(t,s)&&(i=S(t,a=new Projection("WGS84"),i),t=a),"enu"!==t.axis&&(i=Ut(t,!1,i)),"longlat"===t.projName?i={x:i.x*lt,y:i.y*lt,z:i.z||0}:(t.to_meter&&(i={x:i.x*t.to_meter,y:i.y*t.to_meter,z:i.z||0}),i=t.inverse(i)),t.from_greenwich&&(i.x+=t.from_greenwich),i=Bt(t.datum,s.datum,i),s.from_greenwich&&(i={x:i.x-s.from_greenwich,y:i.y,z:i.z||0}),"longlat"===s.projName?i={x:i.x*Mt,y:i.y*Mt,z:i.z||0}:(i=s.forward(i),s.to_meter&&(i={x:i.x/s.to_meter,y:i.y/s.to_meter,z:i.z||0})),"enu"!==s.axis?Ut(s,!0,i):i}function k(t,s,i){var a,h,e;return Array.isArray(i)?(a=S(t,s,i)||{x:NaN,y:NaN},i.length>2?void 0!==t.name&&"geocent"===t.name||void 0!==s.name&&"geocent"===s.name?"number"==typeof a.z?[a.x,a.y,a.z].concat(i.splice(3)):[a.x,a.y,i[2]].concat(i.splice(3)):[a.x,a.y].concat(i.splice(2)):[a.x,a.y]):(h=S(t,s,i),2===(e=Object.keys(i)).length?h:(e.forEach(function(a){if(void 0!==t.name&&"geocent"===t.name||void 0!==s.name&&"geocent"===s.name){if("x"===a||"y"===a||"z"===a)return}else if("x"===a||"y"===a)return;h[a]=i[a]}),h))}function q(t){return t instanceof Projection?t:t.oProj?t.oProj:Projection(t)}function I(t,s,i){t=q(t);var a,h=!1;return void 0===s?(s=t,t=Wt,h=!0):(void 0!==s.x||Array.isArray(s))&&(i=s,s=t,t=Wt,h=!0),s=q(s),i?k(t,s,i):(a={forward:function(i){return k(t,s,i)},inverse:function(i){return k(s,t,i)}},h&&(a.oProj=s),a)}function O(t,s){return s=s||5,D(j({lat:t[1],lon:t[0]}),s)}function R(t){var s=z(Q(t.toUpperCase()));return s.lat&&s.lon?[s.lon,s.lat]:[(s.left+s.right)/2,(s.top+s.bottom)/2]}function G(t){return t*(Math.PI/180)}function T(t){return t/Math.PI*180}function j(t){var s,i,a,h,e,n,r,o=t.lat,l=t.lon,M=6378137,c=G(o),u=G(l);r=Math.floor((l+180)/6)+1,180===l&&(r=60),o>=56&&o<64&&l>=3&&l<12&&(r=32),o>=72&&o<84&&(l>=0&&l<9?r=31:l>=9&&l<21?r=33:l>=21&&l<33?r=35:l>=33&&l<42&&(r=37)),n=G(6*(r-1)-180+3),s=M/Math.sqrt(1-.00669438*Math.sin(c)*Math.sin(c)),i=Math.tan(c)*Math.tan(c),a=.006739496752268451*Math.cos(c)*Math.cos(c);var f=.9996*s*((h=Math.cos(c)*(u-n))+(1-i+a)*h*h*h/6+(5-18*i+i*i+72*a-.39089081163157013)*h*h*h*h*h/120)+5e5,m=.9996*((e=M*(.9983242984503243*c-.002514607064228144*Math.sin(2*c)+2639046602129982e-21*Math.sin(4*c)-3.418046101696858e-9*Math.sin(6*c)))+s*Math.tan(c)*(h*h/2+(5-i+9*a+4*a*a)*h*h*h*h/24+(61-58*i+i*i+600*a-2.2240339282485886)*h*h*h*h*h*h/720));return o<0&&(m+=1e7),{northing:Math.round(m),easting:Math.round(f),zoneNumber:r,zoneLetter:L(o)}}function z(t){var s=t.northing,i=t.easting,a=t.zoneLetter,h=t.zoneNumber;if(h<0||h>60)return null;var e,n,r,o,l,M,c,u,f=6378137,m=(1-Math.sqrt(.99330562))/(1+Math.sqrt(.99330562)),p=i-5e5,d=s;a<"N"&&(d-=1e7),M=6*(h-1)-180+3,u=(c=d/.9996/6367449.145945056)+(3*m/2-27*m*m*m/32)*Math.sin(2*c)+(21*m*m/16-55*m*m*m*m/32)*Math.sin(4*c)+151*m*m*m/96*Math.sin(6*c),e=f/Math.sqrt(1-.00669438*Math.sin(u)*Math.sin(u)),n=Math.tan(u)*Math.tan(u),r=.006739496752268451*Math.cos(u)*Math.cos(u),o=.99330562*f/Math.pow(1-.00669438*Math.sin(u)*Math.sin(u),1.5),l=p/(.9996*e);var y=u-e*Math.tan(u)/o*(l*l/2-(5+3*n+10*r-4*r*r-.06065547077041606)*l*l*l*l/24+(61+90*n+298*r+45*n*n-1.6983531815716497-3*r*r)*l*l*l*l*l*l/720);y=T(y);var _=(l-(1+2*n+r)*l*l*l/6+(5-2*r+28*n-3*r*r+.05391597401814761+24*n*n)*l*l*l*l*l/120)/Math.cos(u);_=M+T(_);var x;if(t.accuracy){var v=z({northing:t.northing+t.accuracy,easting:t.easting+t.accuracy,zoneLetter:t.zoneLetter,zoneNumber:t.zoneNumber});x={top:v.lat,right:v.lon,bottom:y,left:_}}else x={lat:y,lon:_};return x}function L(t){var s="Z";return 84>=t&&t>=72?s="X":72>t&&t>=64?s="W":64>t&&t>=56?s="V":56>t&&t>=48?s="U":48>t&&t>=40?s="T":40>t&&t>=32?s="S":32>t&&t>=24?s="R":24>t&&t>=16?s="Q":16>t&&t>=8?s="P":8>t&&t>=0?s="N":0>t&&t>=-8?s="M":-8>t&&t>=-16?s="L":-16>t&&t>=-24?s="K":-24>t&&t>=-32?s="J":-32>t&&t>=-40?s="H":-40>t&&t>=-48?s="G":-48>t&&t>=-56?s="F":-56>t&&t>=-64?s="E":-64>t&&t>=-72?s="D":-72>t&&t>=-80&&(s="C"),s}function D(t,s){var i="00000"+t.easting,a="00000"+t.northing;return t.zoneNumber+t.zoneLetter+B(t.easting,t.northing,t.zoneNumber)+i.substr(i.length-5,s)+a.substr(a.length-5,s)}function B(t,s,i){var a=U(i);return F(Math.floor(t/1e5),Math.floor(s/1e5)%20,a)}function U(t){var s=t%Ht;return 0===s&&(s=Ht),s}function F(t,s,i){var a=i-1,h=Kt.charCodeAt(a),e=Xt.charCodeAt(a),n=h+t-1,r=e+s,o=!1;return n>$t&&(n=n-$t+Jt-1,o=!0),(n===Vt||h<Vt&&n>Vt||(n>Vt||h<Vt)&&o)&&n++,(n===Zt||h<Zt&&n>Zt||(n>Zt||h<Zt)&&o)&&++n===Vt&&n++,n>$t&&(n=n-$t+Jt-1),r>Yt?(r=r-Yt+Jt-1,o=!0):o=!1,(r===Vt||e<Vt&&r>Vt||(r>Vt||e<Vt)&&o)&&r++,(r===Zt||e<Zt&&r>Zt||(r>Zt||e<Zt)&&o)&&++r===Vt&&r++,r>Yt&&(r=r-Yt+Jt-1),String.fromCharCode(n)+String.fromCharCode(r)}function Q(t){if(t&&0===t.length)throw"MGRSPoint coverting from nothing";for(var s,i=t.length,a=null,h="",e=0;!/[A-Z]/.test(s=t.charAt(e));){if(e>=2)throw"MGRSPoint bad conversion from: "+t;h+=s,e++}var n=parseInt(h,10);if(0===e||e+3>i)throw"MGRSPoint bad conversion from: "+t;var r=t.charAt(e++);if(r<="A"||"B"===r||"Y"===r||r>="Z"||"I"===r||"O"===r)throw"MGRSPoint zone letter "+r+" not handled: "+t;a=t.substring(e,e+=2);for(var o=U(n),l=W(a.charAt(0),o),M=H(a.charAt(1),o);M<K(r);)M+=2e6;var c=i-e;if(c%2!=0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+t;var u,f,m,p,d,y=c/2,_=0,x=0;return y>0&&(u=1e5/Math.pow(10,y),f=t.substring(e,e+y),_=parseFloat(f)*u,m=t.substring(e+y),x=parseFloat(m)*u),p=_+l,d=x+M,{easting:p,northing:d,zoneLetter:r,zoneNumber:n,accuracy:u}}function W(t,s){for(var i=Kt.charCodeAt(s-1),a=1e5,h=!1;i!==t.charCodeAt(0);){if(++i===Vt&&i++,i===Zt&&i++,i>$t){if(h)throw"Bad character: "+t;i=Jt,h=!0}a+=1e5}return a}function H(t,s){if(t>"V")throw"MGRSPoint given invalid Northing "+t;for(var i=Xt.charCodeAt(s-1),a=0,h=!1;i!==t.charCodeAt(0);){if(++i===Vt&&i++,i===Zt&&i++,i>Yt){if(h)throw"Bad character: "+t;i=Jt,h=!0}a+=1e5}return a}function K(t){var s;switch(t){case"C":s=11e5;break;case"D":s=2e6;break;case"E":s=28e5;break;case"F":s=37e5;break;case"G":s=46e5;break;case"H":s=55e5;break;case"J":s=64e5;break;case"K":s=73e5;break;case"L":s=82e5;break;case"M":s=91e5;break;case"N":s=0;break;case"P":s=8e5;break;case"Q":s=17e5;break;case"R":s=26e5;break;case"S":s=35e5;break;case"T":s=44e5;break;case"U":s=53e5;break;case"V":s=62e5;break;case"W":s=7e6;break;case"X":s=79e5;break;default:s=-1}if(s>=0)return s;throw"Invalid zone letter: "+t}function Point(t,s,i){if(!(this instanceof Point))return new Point(t,s,i);if(Array.isArray(t))this.x=t[0],this.y=t[1],this.z=t[2]||0;else if("object"==typeof t)this.x=t.x,this.y=t.y,this.z=t.z||0;else if("string"==typeof t&&void 0===s){var a=t.split(",");this.x=parseFloat(a[0],10),this.y=parseFloat(a[1],10),this.z=parseFloat(a[2],10)||0}else this.x=t,this.y=s,this.z=i||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}function X(t){var s,i=[];return i[0]=t*Ts,s=t*t,i[0]+=s*js,i[1]=s*Ls,s*=t,i[0]+=s*zs,i[1]+=s*Ds,i[2]=s*Bs,i}function J(t,s){var i=t+t;return t+s[0]*Math.sin(i)+s[1]*Math.sin(i+i)+s[2]*Math.sin(i+i+i)}function V(t,s,i,a){var h;return t<ot?(a.value=ri.AREA_0,h=0):(h=Math.atan2(s,i),Math.abs(h)<=ct?a.value=ri.AREA_0:h>ct&&h<=ht+ct?(a.value=ri.AREA_1,h-=ht):h>ht+ct||h<=-(ht+ct)?(a.value=ri.AREA_2,h=h>=0?h-ft:h+ft):(a.value=ri.AREA_3,h+=ht)),h}function Z(t,s){var i=t+s;return i<-ft?i+=ut:i>+ft&&(i-=ut),i}function Y(t,s,i,a){for(var h=s;a;--a){var e=t(h);if(h-=e,Math.abs(e)<i)break}return h}var $=1,tt=2,st=4,it=5,at=484813681109536e-20,ht=Math.PI/2,et=.16666666666666666,nt=.04722222222222222,rt=.022156084656084655,ot=1e-10,lt=.017453292519943295,Mt=57.29577951308232,ct=Math.PI/4,ut=2*Math.PI,ft=3.14159265359,mt={};mt.greenwich=0,mt.lisbon=-9.131906111111,mt.paris=2.337229166667,mt.bogota=-74.080916666667,mt.madrid=-3.687938888889,mt.rome=12.452333333333,mt.bern=7.439583333333,mt.jakarta=106.807719444444,mt.ferro=-17.666666666667,mt.brussels=4.367975,mt.stockholm=18.058277777778,mt.athens=23.7163375,mt.oslo=10.722916666667;var pt={ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937}},dt=/[\s_\-\/\(\)]/g,yt=function(s){var i,a,h,e={},n=s.split("+").map(function(t){return t.trim()}).filter(function(t){return t}).reduce(function(t,s){var i=s.split("=");return i.push(!0),t[i[0].toLowerCase()]=i[1],t},{}),r={proj:"projName",datum:"datumCode",rf:function(t){e.rf=parseFloat(t)},lat_0:function(t){e.lat0=t*lt},lat_1:function(t){e.lat1=t*lt},lat_2:function(t){e.lat2=t*lt},lat_ts:function(t){e.lat_ts=t*lt},lon_0:function(t){e.long0=t*lt},lon_1:function(t){e.long1=t*lt},lon_2:function(t){e.long2=t*lt},alpha:function(t){e.alpha=parseFloat(t)*lt},lonc:function(t){e.longc=t*lt},x_0:function(t){e.x0=parseFloat(t)},y_0:function(t){e.y0=parseFloat(t)},k_0:function(t){e.k0=parseFloat(t)},k:function(t){e.k0=parseFloat(t)},a:function(t){e.a=parseFloat(t)},b:function(t){e.b=parseFloat(t)},r_a:function(){e.R_A=!0},zone:function(t){e.zone=parseInt(t,10)},south:function(){e.utmSouth=!0},towgs84:function(t){e.datum_params=t.split(",").map(function(t){return parseFloat(t)})},to_meter:function(t){e.to_meter=parseFloat(t)},units:function(s){e.units=s;var i=t(pt,s);i&&(e.to_meter=i.to_meter)},from_greenwich:function(t){e.from_greenwich=t*lt},pm:function(s){var i=t(mt,s);e.from_greenwich=(i||parseFloat(s))*lt},nadgrids:function(t){"@null"===t?e.datumCode="none":e.nadgrids=t},axis:function(t){3===t.length&&-1!=="ewnsud".indexOf(t.substr(0,1))&&-1!=="ewnsud".indexOf(t.substr(1,1))&&-1!=="ewnsud".indexOf(t.substr(2,1))&&(e.axis=t)}};for(i in n)a=n[i],i in r?"function"==typeof(h=r[i])?h(a):e[h]=a:e[i]=a;return"string"==typeof e.datumCode&&"WGS84"!==e.datumCode&&(e.datumCode=e.datumCode.toLowerCase()),e},_t=1,xt=/\s/,vt=/[A-Za-z]/,gt=/[A-Za-z84]/,bt=/[,\]]/,wt=/[\d\.E\-\+]/;s.prototype.readCharicter=function(){var t=this.text[this.place++];if(4!==this.state)for(;xt.test(t);){if(this.place>=this.text.length)return;t=this.text[this.place++]}switch(this.state){case _t:return this.neutral(t);case 2:return this.keyword(t);case 4:return this.quoted(t);case 5:return this.afterquote(t);case 3:return this.number(t);case-1:return}},s.prototype.afterquote=function(t){if('"'===t)return this.word+='"',void(this.state=4);if(bt.test(t))return this.word=this.word.trim(),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in afterquote yet, index '+this.place)},s.prototype.afterItem=function(t){return","===t?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=_t)):"]"===t?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=_t,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=-1))):void 0},s.prototype.number=function(t){if(!wt.test(t)){if(bt.test(t))return this.word=parseFloat(this.word),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in number yet, index '+this.place)}this.word+=t},s.prototype.quoted=function(t){'"'!==t?this.word+=t:this.state=5},s.prototype.keyword=function(t){if(gt.test(t))this.word+=t;else{if("["===t){var s=[];return s.push(this.word),this.level++,null===this.root?this.root=s:this.currentObject.push(s),this.stack.push(this.currentObject),this.currentObject=s,void(this.state=_t)}if(!bt.test(t))throw new Error("havn't handled \""+t+'" in keyword yet, index '+this.place);this.afterItem(t)}},s.prototype.neutral=function(t){if(vt.test(t))return this.word=t,void(this.state=2);if('"'===t)return this.word="",void(this.state=4);if(wt.test(t))return this.word=t,void(this.state=3);{if(!bt.test(t))throw new Error("havn't handled \""+t+'" in neutral yet, index '+this.place);this.afterItem(t)}},s.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(-1===this.state)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};var At=.017453292519943295,Ct=function(t){var s=i(t),a=s.shift(),e=s.shift();s.unshift(["name",e]),s.unshift(["type",a]);var n={};return h(s,n),r(n),n};!function(t){t("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),t("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),t("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),t.WGS84=t["EPSG:4326"],t["EPSG:3785"]=t["EPSG:3857"],t.GOOGLE=t["EPSG:3857"],t["EPSG:900913"]=t["EPSG:3857"],t["EPSG:102113"]=t["EPSG:3857"]}(o);var Et=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"],Pt=["3857","900913","3785","102113"],Nt=function(t,s){t=t||{};var i,a;if(!s)return t;for(a in s)void 0!==(i=s[a])&&(t[a]=i);return t},St=function(t,s,i){var a=t*s;return i/Math.sqrt(1-a*a)},kt=function(t){return t<0?-1:1},qt=function(t){return Math.abs(t)<=ft?t:t-kt(t)*ut},It=function(t,s,i){var a=t*i,h=.5*t;return a=Math.pow((1-a)/(1+a),h),Math.tan(.5*(ht-s))/a},Ot=function(t,s){for(var i,a,h=.5*t,e=ht-2*Math.atan(s),n=0;n<=15;n++)if(i=t*Math.sin(e),a=ht-2*Math.atan(s*Math.pow((1-i)/(1+i),h))-e,e+=a,Math.abs(a)<=1e-10)return e;return-9999},Rt=[{init:function(){var t=this.b/this.a;this.es=1-t*t,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=St(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1)},forward:function(t){var s=t.x,i=t.y;if(i*Mt>90&&i*Mt<-90&&s*Mt>180&&s*Mt<-180)return null;var a,h;if(Math.abs(Math.abs(i)-ht)<=ot)return null;if(this.sphere)a=this.x0+this.a*this.k0*qt(s-this.long0),h=this.y0+this.a*this.k0*Math.log(Math.tan(ct+.5*i));else{var e=Math.sin(i),n=It(this.e,i,e);a=this.x0+this.a*this.k0*qt(s-this.long0),h=this.y0-this.a*this.k0*Math.log(n)}return t.x=a,t.y=h,t},inverse:function(t){var s,i,a=t.x-this.x0,h=t.y-this.y0;if(this.sphere)i=ht-2*Math.atan(Math.exp(-h/(this.a*this.k0)));else{var e=Math.exp(-h/(this.a*this.k0));if(-9999===(i=Ot(this.e,e)))return null}return s=qt(this.long0+a/(this.a*this.k0)),t.x=s,t.y=i,t},names:["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"]},{init:function(){},forward:d,inverse:d,names:["longlat","identity"]}],Gt={},Tt=[],jt={start:function(){Rt.forEach(y)},add:y,get:function(t){if(!t)return!1;var s=t.toLowerCase();return void 0!==Gt[s]&&Tt[Gt[s]]?Tt[Gt[s]]:void 0}},zt={};zt.MERIT={a:6378137,rf:298.257,ellipseName:"MERIT 1983"},zt.SGS85={a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},zt.GRS80={a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},zt.IAU76={a:6378140,rf:298.257,ellipseName:"IAU 1976"},zt.airy={a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},zt.APL4={a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},zt.NWL9D={a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},zt.mod_airy={a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},zt.andrae={a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},zt.aust_SA={a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},zt.GRS67={a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},zt.bessel={a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},zt.bess_nam={a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},zt.clrk66={a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},zt.clrk80={a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},zt.clrk58={a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},zt.CPM={a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},zt.delmbr={a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},zt.engelis={a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},zt.evrst30={a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},zt.evrst48={a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},zt.evrst56={a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},zt.evrst69={a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},zt.evrstSS={a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},zt.fschr60={a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},zt.fschr60m={a:6378155,rf:298.3,ellipseName:"Fischer 1960"},zt.fschr68={a:6378150,rf:298.3,ellipseName:"Fischer 1968"},zt.helmert={a:6378200,rf:298.3,ellipseName:"Helmert 1906"},zt.hough={a:6378270,rf:297,ellipseName:"Hough"},zt.intl={a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},zt.kaula={a:6378163,rf:298.24,ellipseName:"Kaula 1961"},zt.lerch={a:6378139,rf:298.257,ellipseName:"Lerch 1979"},zt.mprts={a:6397300,rf:191,ellipseName:"Maupertius 1738"},zt.new_intl={a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},zt.plessis={a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},zt.krass={a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},zt.SEasia={a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},zt.walbeck={a:6376896,b:6355834.8467,ellipseName:"Walbeck"},zt.WGS60={a:6378165,rf:298.3,ellipseName:"WGS 60"},zt.WGS66={a:6378145,rf:298.25,ellipseName:"WGS 66"},zt.WGS7={a:6378135,rf:298.26,ellipseName:"WGS 72"};var Lt=zt.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"};zt.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"};var Dt={};Dt.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},Dt.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},Dt.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},Dt.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},Dt.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},Dt.potsdam={towgs84:"606.0,23.0,413.0",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},Dt.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},Dt.hermannskogel={towgs84:"653.0,-212.0,449.0",ellipse:"bessel",datumName:"Hermannskogel"},Dt.osni52={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"airy",datumName:"Irish National"},Dt.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},Dt.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},Dt.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},Dt.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},Dt.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},Dt.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},Dt.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},Dt.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"},Projection.projections=jt,Projection.projections.start();var Bt=function(t,s,i){return g(t,s)?i:t.datum_type===it||s.datum_type===it?i:t.es!==s.es||t.a!==s.a||E(t.datum_type)||E(s.datum_type)?(i=b(i,t.es,t.a),E(t.datum_type)&&(i=A(i,t.datum_type,t.datum_params)),E(s.datum_type)&&(i=C(i,s.datum_type,s.datum_params)),w(i,s.es,s.a,s.b)):i},Ut=function(t,s,i){var a,h,e,n=i.x,r=i.y,o=i.z||0,l={};for(e=0;e<3;e++)if(!s||2!==e||void 0!==i.z)switch(0===e?(a=n,h="x"):1===e?(a=r,h="y"):(a=o,h="z"),t.axis[e]){case"e":l[h]=a;break;case"w":l[h]=-a;break;case"n":l[h]=a;break;case"s":l[h]=-a;break;case"u":void 0!==i[h]&&(l.z=a);break;case"d":void 0!==i[h]&&(l.z=-a);break;default:return null}return l},Ft=function(t){var s={x:t[0],y:t[1]};return t.length>2&&(s.z=t[2]),t.length>3&&(s.m=t[3]),s},Qt=function(t){P(t.x),P(t.y)},Wt=Projection("WGS84"),Ht=6,Kt="AJSAJS",Xt="AFAFAF",Jt=65,Vt=73,Zt=79,Yt=86,$t=90,ts={forward:O,inverse:function(t){var s=z(Q(t.toUpperCase()));return s.lat&&s.lon?[s.lon,s.lat,s.lon,s.lat]:[s.left,s.bottom,s.right,s.top]},toPoint:R};Point.fromMGRS=function(t){return new Point(R(t))},Point.prototype.toMGRS=function(t){return O([this.x,this.y],t)};var ss=.01068115234375,is=function(t){var s=[];s[0]=1-t*(.25+t*(.046875+t*(.01953125+t*ss))),s[1]=t*(.75-t*(.046875+t*(.01953125+t*ss)));var i=t*t;return s[2]=i*(.46875-t*(.013020833333333334+.007120768229166667*t)),i*=t,s[3]=i*(.3645833333333333-.005696614583333333*t),s[4]=i*t*.3076171875,s},as=function(t,s,i,a){return i*=s,s*=s,a[0]*t-i*(a[1]+s*(a[2]+s*(a[3]+s*a[4])))},hs=function(t,s,i){for(var a=1/(1-s),h=t,e=20;e;--e){var n=Math.sin(h),r=1-s*n*n;if(r=(as(h,n,Math.cos(h),i)-t)*(r*Math.sqrt(r))*a,h-=r,Math.abs(r)<ot)return h}return h},es={init:function(){this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.es&&(this.en=is(this.es),this.ml0=as(this.lat0,Math.sin(this.lat0),Math.cos(this.lat0),this.en))},forward:function(t){var s,i,a,h=t.x,e=t.y,n=qt(h-this.long0),r=Math.sin(e),o=Math.cos(e);if(this.es){var l=o*n,M=Math.pow(l,2),c=this.ep2*Math.pow(o,2),u=Math.pow(c,2),f=Math.abs(o)>ot?Math.tan(e):0,m=Math.pow(f,2),p=Math.pow(m,2);s=1-this.es*Math.pow(r,2),l/=Math.sqrt(s);var d=as(e,r,o,this.en);i=this.a*(this.k0*l*(1+M/6*(1-m+c+M/20*(5-18*m+p+14*c-58*m*c+M/42*(61+179*p-p*m-479*m)))))+this.x0,a=this.a*(this.k0*(d-this.ml0+r*n*l/2*(1+M/12*(5-m+9*c+4*u+M/30*(61+p-58*m+270*c-330*m*c+M/56*(1385+543*p-p*m-3111*m))))))+this.y0}else{var y=o*Math.sin(n);if(Math.abs(Math.abs(y)-1)<ot)return 93;if(i=.5*this.a*this.k0*Math.log((1+y)/(1-y))+this.x0,a=o*Math.cos(n)/Math.sqrt(1-Math.pow(y,2)),(y=Math.abs(a))>=1){if(y-1>ot)return 93;a=0}else a=Math.acos(a);e<0&&(a=-a),a=this.a*this.k0*(a-this.lat0)+this.y0}return t.x=i,t.y=a,t},inverse:function(t){var s,i,a,h,e=(t.x-this.x0)*(1/this.a),n=(t.y-this.y0)*(1/this.a);if(this.es)if(s=this.ml0+n/this.k0,i=hs(s,this.es,this.en),Math.abs(i)<ht){var r=Math.sin(i),o=Math.cos(i),l=Math.abs(o)>ot?Math.tan(i):0,M=this.ep2*Math.pow(o,2),c=Math.pow(M,2),u=Math.pow(l,2),f=Math.pow(u,2);s=1-this.es*Math.pow(r,2);var m=e*Math.sqrt(s)/this.k0,p=Math.pow(m,2);a=i-(s*=l)*p/(1-this.es)*.5*(1-p/12*(5+3*u-9*M*u+M-4*c-p/30*(61+90*u-252*M*u+45*f+46*M-p/56*(1385+3633*u+4095*f+1574*f*u)))),h=qt(this.long0+m*(1-p/6*(1+2*u+M-p/20*(5+28*u+24*f+8*M*u+6*M-p/42*(61+662*u+1320*f+720*f*u))))/o)}else a=ht*kt(n),h=0;else{var d=Math.exp(e/this.k0),y=.5*(d-1/d),_=this.lat0+n/this.k0,x=Math.cos(_);s=Math.sqrt((1-Math.pow(x,2))/(1+Math.pow(y,2))),a=Math.asin(s),n<0&&(a=-a),h=0===y&&0===x?0:qt(Math.atan2(y,x)+this.long0)}return t.x=h,t.y=a,t},names:["Transverse_Mercator","Transverse Mercator","tmerc"]},ns=function(t){var s=Math.exp(t);return s=(s-1/s)/2},rs=function(t,s){t=Math.abs(t),s=Math.abs(s);var i=Math.max(t,s),a=Math.min(t,s)/(i||1);return i*Math.sqrt(1+Math.pow(a,2))},os=function(t){var s=1+t,i=s-1;return 0===i?t:t*Math.log(s)/i},ls=function(t){var s=Math.abs(t);return s=os(s*(1+s/(rs(1,s)+1))),t<0?-s:s},Ms=function(t,s){for(var i,a=2*Math.cos(2*s),h=t.length-1,e=t[h],n=0;--h>=0;)i=a*e-n+t[h],n=e,e=i;return s+i*Math.sin(2*s)},cs=function(t,s){for(var i,a=2*Math.cos(s),h=t.length-1,e=t[h],n=0;--h>=0;)i=a*e-n+t[h],n=e,e=i;return Math.sin(s)*i},us=function(t){var s=Math.exp(t);return s=(s+1/s)/2},fs=function(t,s,i){for(var a,h,e=Math.sin(s),n=Math.cos(s),r=ns(i),o=us(i),l=2*n*o,M=-2*e*r,c=t.length-1,u=t[c],f=0,m=0,p=0;--c>=0;)a=m,h=f,u=l*(m=u)-a-M*(f=p)+t[c],p=M*m-h+l*f;return l=e*o,M=n*r,[l*u-M*p,l*p+M*u]},ms={init:function(){if(void 0===this.es||this.es<=0)throw new Error("incorrect elliptical usage");this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.cgb=[],this.cbg=[],this.utg=[],this.gtu=[];var t=this.es/(1+Math.sqrt(1-this.es)),s=t/(2-t),i=s;this.cgb[0]=s*(2+s*(-2/3+s*(s*(116/45+s*(26/45+s*(-2854/675)))-2))),this.cbg[0]=s*(s*(2/3+s*(4/3+s*(-82/45+s*(32/45+s*(4642/4725)))))-2),i*=s,this.cgb[1]=i*(7/3+s*(s*(-227/45+s*(2704/315+s*(2323/945)))-1.6)),this.cbg[1]=i*(5/3+s*(-16/15+s*(-13/9+s*(904/315+s*(-1522/945))))),i*=s,this.cgb[2]=i*(56/15+s*(-136/35+s*(-1262/105+s*(73814/2835)))),this.cbg[2]=i*(-26/15+s*(34/21+s*(1.6+s*(-12686/2835)))),i*=s,this.cgb[3]=i*(4279/630+s*(-332/35+s*(-399572/14175))),this.cbg[3]=i*(1237/630+s*(s*(-24832/14175)-2.4)),i*=s,this.cgb[4]=i*(4174/315+s*(-144838/6237)),this.cbg[4]=i*(-734/315+s*(109598/31185)),i*=s,this.cgb[5]=i*(601676/22275),this.cbg[5]=i*(444337/155925),i=Math.pow(s,2),this.Qn=this.k0/(1+s)*(1+i*(.25+i*(1/64+i/256))),this.utg[0]=s*(s*(2/3+s*(-37/96+s*(1/360+s*(81/512+s*(-96199/604800)))))-.5),this.gtu[0]=s*(.5+s*(-2/3+s*(5/16+s*(41/180+s*(-127/288+s*(7891/37800)))))),this.utg[1]=i*(-1/48+s*(-1/15+s*(437/1440+s*(-46/105+s*(1118711/3870720))))),this.gtu[1]=i*(13/48+s*(s*(557/1440+s*(281/630+s*(-1983433/1935360)))-.6)),i*=s,this.utg[2]=i*(-17/480+s*(37/840+s*(209/4480+s*(-5569/90720)))),this.gtu[2]=i*(61/240+s*(-103/140+s*(15061/26880+s*(167603/181440)))),i*=s,this.utg[3]=i*(-4397/161280+s*(11/504+s*(830251/7257600))),this.gtu[3]=i*(49561/161280+s*(-179/168+s*(6601661/7257600))),i*=s,this.utg[4]=i*(-4583/161280+s*(108847/3991680)),this.gtu[4]=i*(34729/80640+s*(-3418889/1995840)),i*=s,this.utg[5]=-.03233083094085698*i,this.gtu[5]=.6650675310896665*i;var a=Ms(this.cbg,this.lat0);this.Zb=-this.Qn*(a+cs(this.gtu,2*a))},forward:function(t){var s=qt(t.x-this.long0),i=t.y;i=Ms(this.cbg,i);var a=Math.sin(i),h=Math.cos(i),e=Math.sin(s),n=Math.cos(s);i=Math.atan2(a,n*h),s=Math.atan2(e*h,rs(a,h*n)),s=ls(Math.tan(s));var r=fs(this.gtu,2*i,2*s);i+=r[0],s+=r[1];var o,l;return Math.abs(s)<=2.623395162778?(o=this.a*(this.Qn*s)+this.x0,l=this.a*(this.Qn*i+this.Zb)+this.y0):(o=1/0,l=1/0),t.x=o,t.y=l,t},inverse:function(t){var s=(t.x-this.x0)*(1/this.a),i=(t.y-this.y0)*(1/this.a);i=(i-this.Zb)/this.Qn,s/=this.Qn;var a,h;if(Math.abs(s)<=2.623395162778){var e=fs(this.utg,2*i,2*s);i+=e[0],s+=e[1],s=Math.atan(ns(s));var n=Math.sin(i),r=Math.cos(i),o=Math.sin(s),l=Math.cos(s);i=Math.atan2(n*l,rs(o,l*r)),s=Math.atan2(o,l*r),a=qt(s+this.long0),h=Ms(this.cgb,i)}else a=1/0,h=1/0;return t.x=a,t.y=h,t},names:["Extended_Transverse_Mercator","Extended Transverse Mercator","etmerc"]},ps=function(t,s){if(void 0===t){if((t=Math.floor(30*(qt(s)+Math.PI)/Math.PI)+1)<0)return 0;if(t>60)return 60}return t},ds={init:function(){var t=ps(this.zone,this.long0);if(void 0===t)throw new Error("unknown utm zone");this.lat0=0,this.long0=(6*Math.abs(t)-183)*lt,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,ms.init.apply(this),this.forward=ms.forward,this.inverse=ms.inverse},names:["Universal Transverse Mercator System","utm"],dependsOn:"etmerc"},ys=function(t,s){return Math.pow((1-t)/(1+t),s)},_s=20,xs={init:function(){var t=Math.sin(this.lat0),s=Math.cos(this.lat0);s*=s,this.rc=Math.sqrt(1-this.es)/(1-this.es*t*t),this.C=Math.sqrt(1+this.es*s*s/(1-this.es)),this.phic0=Math.asin(t/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+ct)/(Math.pow(Math.tan(.5*this.lat0+ct),this.C)*ys(this.e*t,this.ratexp))},forward:function(t){var s=t.x,i=t.y;return t.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*i+ct),this.C)*ys(this.e*Math.sin(i),this.ratexp))-ht,t.x=this.C*s,t},inverse:function(t){for(var s=t.x/this.C,i=t.y,a=Math.pow(Math.tan(.5*i+ct)/this.K,1/this.C),h=_s;h>0&&(i=2*Math.atan(a*ys(this.e*Math.sin(t.y),-.5*this.e))-ht,!(Math.abs(i-t.y)<1e-14));--h)t.y=i;return h?(t.x=s,t.y=i,t):null},names:["gauss"]},vs={init:function(){xs.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))},forward:function(t){var s,i,a,h;return t.x=qt(t.x-this.long0),xs.forward.apply(this,[t]),s=Math.sin(t.y),i=Math.cos(t.y),a=Math.cos(t.x),h=this.k0*this.R2/(1+this.sinc0*s+this.cosc0*i*a),t.x=h*i*Math.sin(t.x),t.y=h*(this.cosc0*s-this.sinc0*i*a),t.x=this.a*t.x+this.x0,t.y=this.a*t.y+this.y0,t},inverse:function(t){var s,i,a,h,e;if(t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,t.x/=this.k0,t.y/=this.k0,e=Math.sqrt(t.x*t.x+t.y*t.y)){var n=2*Math.atan2(e,this.R2);s=Math.sin(n),i=Math.cos(n),h=Math.asin(i*this.sinc0+t.y*s*this.cosc0/e),a=Math.atan2(t.x*s,e*this.cosc0*i-t.y*this.sinc0*s)}else h=this.phic0,a=0;return t.x=a,t.y=h,xs.inverse.apply(this,[t]),t.x=qt(t.x+this.long0),t},names:["Stereographic_North_Pole","Oblique_Stereographic","Polar_Stereographic","sterea","Oblique Stereographic Alternative","Double_Stereographic"]},gs={init:function(){this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=ot&&(this.k0=.5*(1+kt(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=ot&&(this.lat0>0?this.con=1:this.con=-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=ot&&(this.k0=.5*this.cons*St(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/It(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=St(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-ht,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))},forward:function(t){var s,i,a,h,e,n,r=t.x,o=t.y,l=Math.sin(o),M=Math.cos(o),c=qt(r-this.long0);return Math.abs(Math.abs(r-this.long0)-Math.PI)<=ot&&Math.abs(o+this.lat0)<=ot?(t.x=NaN,t.y=NaN,t):this.sphere?(s=2*this.k0/(1+this.sinlat0*l+this.coslat0*M*Math.cos(c)),t.x=this.a*s*M*Math.sin(c)+this.x0,t.y=this.a*s*(this.coslat0*l-this.sinlat0*M*Math.cos(c))+this.y0,t):(i=2*Math.atan(this.ssfn_(o,l,this.e))-ht,h=Math.cos(i),a=Math.sin(i),Math.abs(this.coslat0)<=ot?(e=It(this.e,o*this.con,this.con*l),n=2*this.a*this.k0*e/this.cons,t.x=this.x0+n*Math.sin(r-this.long0),t.y=this.y0-this.con*n*Math.cos(r-this.long0),t):(Math.abs(this.sinlat0)<ot?(s=2*this.a*this.k0/(1+h*Math.cos(c)),t.y=s*a):(s=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*a+this.cosX0*h*Math.cos(c))),t.y=s*(this.cosX0*a-this.sinX0*h*Math.cos(c))+this.y0),t.x=s*h*Math.sin(c)+this.x0,t))},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s,i,a,h,e,n=Math.sqrt(t.x*t.x+t.y*t.y);if(this.sphere){var r=2*Math.atan(n/(2*this.a*this.k0));return s=this.long0,i=this.lat0,n<=ot?(t.x=s,t.y=i,t):(i=Math.asin(Math.cos(r)*this.sinlat0+t.y*Math.sin(r)*this.coslat0/n),s=qt(Math.abs(this.coslat0)<ot?this.lat0>0?this.long0+Math.atan2(t.x,-1*t.y):this.long0+Math.atan2(t.x,t.y):this.long0+Math.atan2(t.x*Math.sin(r),n*this.coslat0*Math.cos(r)-t.y*this.sinlat0*Math.sin(r))),t.x=s,t.y=i,t)}if(Math.abs(this.coslat0)<=ot){if(n<=ot)return i=this.lat0,s=this.long0,t.x=s,t.y=i,t;t.x*=this.con,t.y*=this.con,a=n*this.cons/(2*this.a*this.k0),i=this.con*Ot(this.e,a),s=this.con*qt(this.con*this.long0+Math.atan2(t.x,-1*t.y))}else h=2*Math.atan(n*this.cosX0/(2*this.a*this.k0*this.ms1)),s=this.long0,n<=ot?e=this.X0:(e=Math.asin(Math.cos(h)*this.sinX0+t.y*Math.sin(h)*this.cosX0/n),s=qt(this.long0+Math.atan2(t.x*Math.sin(h),n*this.cosX0*Math.cos(h)-t.y*this.sinX0*Math.sin(h)))),i=-1*Ot(this.e,Math.tan(.5*(ht+e)));return t.x=s,t.y=i,t},names:["stere","Stereographic_South_Pole","Polar Stereographic (variant B)"],ssfn_:function(t,s,i){return s*=i,Math.tan(.5*(ht+t))*Math.pow((1-s)/(1+s),.5*i)}},bs={init:function(){var t=this.lat0;this.lambda0=this.long0;var s=Math.sin(t),i=this.a,a=1/this.rf,h=2*a-Math.pow(a,2),e=this.e=Math.sqrt(h);this.R=this.k0*i*Math.sqrt(1-h)/(1-h*Math.pow(s,2)),this.alpha=Math.sqrt(1+h/(1-h)*Math.pow(Math.cos(t),4)),this.b0=Math.asin(s/this.alpha);var n=Math.log(Math.tan(Math.PI/4+this.b0/2)),r=Math.log(Math.tan(Math.PI/4+t/2)),o=Math.log((1+e*s)/(1-e*s));this.K=n-this.alpha*r+this.alpha*e/2*o},forward:function(t){var s=Math.log(Math.tan(Math.PI/4-t.y/2)),i=this.e/2*Math.log((1+this.e*Math.sin(t.y))/(1-this.e*Math.sin(t.y))),a=-this.alpha*(s+i)+this.K,h=2*(Math.atan(Math.exp(a))-Math.PI/4),e=this.alpha*(t.x-this.lambda0),n=Math.atan(Math.sin(e)/(Math.sin(this.b0)*Math.tan(h)+Math.cos(this.b0)*Math.cos(e))),r=Math.asin(Math.cos(this.b0)*Math.sin(h)-Math.sin(this.b0)*Math.cos(h)*Math.cos(e));return t.y=this.R/2*Math.log((1+Math.sin(r))/(1-Math.sin(r)))+this.y0,t.x=this.R*n+this.x0,t},inverse:function(t){for(var s=t.x-this.x0,i=t.y-this.y0,a=s/this.R,h=2*(Math.atan(Math.exp(i/this.R))-Math.PI/4),e=Math.asin(Math.cos(this.b0)*Math.sin(h)+Math.sin(this.b0)*Math.cos(h)*Math.cos(a)),n=Math.atan(Math.sin(a)/(Math.cos(this.b0)*Math.cos(a)-Math.sin(this.b0)*Math.tan(h))),r=this.lambda0+n/this.alpha,o=0,l=e,M=-1e3,c=0;Math.abs(l-M)>1e-7;){if(++c>20)return;o=1/this.alpha*(Math.log(Math.tan(Math.PI/4+e/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(l))/2)),M=l,l=2*Math.atan(Math.exp(o))-Math.PI/2}return t.x=r,t.y=l,t},names:["somerc"]},ws={init:function(){this.no_off=this.no_off||!1,this.no_rot=this.no_rot||!1,isNaN(this.k0)&&(this.k0=1);var t=Math.sin(this.lat0),s=Math.cos(this.lat0),i=this.e*t;this.bl=Math.sqrt(1+this.es/(1-this.es)*Math.pow(s,4)),this.al=this.a*this.bl*this.k0*Math.sqrt(1-this.es)/(1-i*i);var a=It(this.e,this.lat0,t),h=this.bl/s*Math.sqrt((1-this.es)/(1-i*i));h*h<1&&(h=1);var e,n;if(isNaN(this.longc)){var r=It(this.e,this.lat1,Math.sin(this.lat1)),o=It(this.e,this.lat2,Math.sin(this.lat2));this.lat0>=0?this.el=(h+Math.sqrt(h*h-1))*Math.pow(a,this.bl):this.el=(h-Math.sqrt(h*h-1))*Math.pow(a,this.bl);var l=Math.pow(r,this.bl),M=Math.pow(o,this.bl);n=.5*((e=this.el/l)-1/e);var c=(this.el*this.el-M*l)/(this.el*this.el+M*l),u=(M-l)/(M+l),f=qt(this.long1-this.long2);this.long0=.5*(this.long1+this.long2)-Math.atan(c*Math.tan(.5*this.bl*f)/u)/this.bl,this.long0=qt(this.long0);var m=qt(this.long1-this.long0);this.gamma0=Math.atan(Math.sin(this.bl*m)/n),this.alpha=Math.asin(h*Math.sin(this.gamma0))}else e=this.lat0>=0?h+Math.sqrt(h*h-1):h-Math.sqrt(h*h-1),this.el=e*Math.pow(a,this.bl),n=.5*(e-1/e),this.gamma0=Math.asin(Math.sin(this.alpha)/h),this.long0=this.longc-Math.asin(n*Math.tan(this.gamma0))/this.bl;this.no_off?this.uc=0:this.lat0>=0?this.uc=this.al/this.bl*Math.atan2(Math.sqrt(h*h-1),Math.cos(this.alpha)):this.uc=-1*this.al/this.bl*Math.atan2(Math.sqrt(h*h-1),Math.cos(this.alpha))},forward:function(t){var s,i,a,h=t.x,e=t.y,n=qt(h-this.long0);if(Math.abs(Math.abs(e)-ht)<=ot)a=e>0?-1:1,i=this.al/this.bl*Math.log(Math.tan(ct+a*this.gamma0*.5)),s=-1*a*ht*this.al/this.bl;else{var r=It(this.e,e,Math.sin(e)),o=this.el/Math.pow(r,this.bl),l=.5*(o-1/o),M=.5*(o+1/o),c=Math.sin(this.bl*n),u=(l*Math.sin(this.gamma0)-c*Math.cos(this.gamma0))/M;i=Math.abs(Math.abs(u)-1)<=ot?Number.POSITIVE_INFINITY:.5*this.al*Math.log((1-u)/(1+u))/this.bl,s=Math.abs(Math.cos(this.bl*n))<=ot?this.al*this.bl*n:this.al*Math.atan2(l*Math.cos(this.gamma0)+c*Math.sin(this.gamma0),Math.cos(this.bl*n))/this.bl}return this.no_rot?(t.x=this.x0+s,t.y=this.y0+i):(s-=this.uc,t.x=this.x0+i*Math.cos(this.alpha)+s*Math.sin(this.alpha),t.y=this.y0+s*Math.cos(this.alpha)-i*Math.sin(this.alpha)),t},inverse:function(t){var s,i;this.no_rot?(i=t.y-this.y0,s=t.x-this.x0):(i=(t.x-this.x0)*Math.cos(this.alpha)-(t.y-this.y0)*Math.sin(this.alpha),s=(t.y-this.y0)*Math.cos(this.alpha)+(t.x-this.x0)*Math.sin(this.alpha),s+=this.uc);var a=Math.exp(-1*this.bl*i/this.al),h=.5*(a-1/a),e=.5*(a+1/a),n=Math.sin(this.bl*s/this.al),r=(n*Math.cos(this.gamma0)+h*Math.sin(this.gamma0))/e,o=Math.pow(this.el/Math.sqrt((1+r)/(1-r)),1/this.bl);return Math.abs(r-1)<ot?(t.x=this.long0,t.y=ht):Math.abs(r+1)<ot?(t.x=this.long0,t.y=-1*ht):(t.y=Ot(this.e,o),t.x=qt(this.long0-Math.atan2(h*Math.cos(this.gamma0)-n*Math.sin(this.gamma0),Math.cos(this.bl*s/this.al))/this.bl)),t},names:["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","omerc"]},As={init:function(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<ot)){var t=this.b/this.a;this.e=Math.sqrt(1-t*t);var s=Math.sin(this.lat1),i=Math.cos(this.lat1),a=St(this.e,s,i),h=It(this.e,this.lat1,s),e=Math.sin(this.lat2),n=Math.cos(this.lat2),r=St(this.e,e,n),o=It(this.e,this.lat2,e),l=It(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>ot?this.ns=Math.log(a/r)/Math.log(h/o):this.ns=s,isNaN(this.ns)&&(this.ns=s),this.f0=a/(this.ns*Math.pow(h,this.ns)),this.rh=this.a*this.f0*Math.pow(l,this.ns),this.title||(this.title="Lambert Conformal Conic")}},forward:function(t){var s=t.x,i=t.y;Math.abs(2*Math.abs(i)-Math.PI)<=ot&&(i=kt(i)*(ht-2*ot));var a,h,e=Math.abs(Math.abs(i)-ht);if(e>ot)a=It(this.e,i,Math.sin(i)),h=this.a*this.f0*Math.pow(a,this.ns);else{if((e=i*this.ns)<=0)return null;h=0}var n=this.ns*qt(s-this.long0);return t.x=this.k0*(h*Math.sin(n))+this.x0,t.y=this.k0*(this.rh-h*Math.cos(n))+this.y0,t},inverse:function(t){var s,i,a,h,e,n=(t.x-this.x0)/this.k0,r=this.rh-(t.y-this.y0)/this.k0;this.ns>0?(s=Math.sqrt(n*n+r*r),i=1):(s=-Math.sqrt(n*n+r*r),i=-1);var o=0;if(0!==s&&(o=Math.atan2(i*n,i*r)),0!==s||this.ns>0){if(i=1/this.ns,a=Math.pow(s/(this.a*this.f0),i),-9999===(h=Ot(this.e,a)))return null}else h=-ht;return e=qt(o/this.ns+this.long0),t.x=e,t.y=h,t},names:["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_2SP","lcc"]},Cs={init:function(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq},forward:function(t){var s,i,a,h,e,n,r,o=t.x,l=t.y,M=qt(o-this.long0);return s=Math.pow((1+this.e*Math.sin(l))/(1-this.e*Math.sin(l)),this.alfa*this.e/2),i=2*(Math.atan(this.k*Math.pow(Math.tan(l/2+this.s45),this.alfa)/s)-this.s45),a=-M*this.alfa,h=Math.asin(Math.cos(this.ad)*Math.sin(i)+Math.sin(this.ad)*Math.cos(i)*Math.cos(a)),e=Math.asin(Math.cos(i)*Math.sin(a)/Math.cos(h)),n=this.n*e,r=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(h/2+this.s45),this.n),t.y=r*Math.cos(n)/1,t.x=r*Math.sin(n)/1,this.czech||(t.y*=-1,t.x*=-1),t},inverse:function(t){var s,i,a,h,e,n,r,o=t.x;t.x=t.y,t.y=o,this.czech||(t.y*=-1,t.x*=-1),e=Math.sqrt(t.x*t.x+t.y*t.y),h=Math.atan2(t.y,t.x)/Math.sin(this.s0),a=2*(Math.atan(Math.pow(this.ro0/e,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),s=Math.asin(Math.cos(this.ad)*Math.sin(a)-Math.sin(this.ad)*Math.cos(a)*Math.cos(h)),i=Math.asin(Math.cos(a)*Math.sin(h)/Math.cos(s)),t.x=this.long0-i/this.alfa,n=s,r=0;var l=0;do{t.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(s/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(n))/(1-this.e*Math.sin(n)),this.e/2))-this.s45),Math.abs(n-t.y)<1e-10&&(r=1),n=t.y,l+=1}while(0===r&&l<15);return l>=15?null:t},names:["Krovak","krovak"]},Es=function(t,s,i,a,h){return t*h-s*Math.sin(2*h)+i*Math.sin(4*h)-a*Math.sin(6*h)},Ps=function(t){return 1-.25*t*(1+t/16*(3+1.25*t))},Ns=function(t){return.375*t*(1+.25*t*(1+.46875*t))},Ss=function(t){return.05859375*t*t*(1+.75*t)},ks=function(t){return t*t*t*(35/3072)},qs=function(t,s,i){var a=s*i;return t/Math.sqrt(1-a*a)},Is=function(t){return Math.abs(t)<ht?t:t-kt(t)*Math.PI},Os=function(t,s,i,a,h){var e,n;e=t/s;for(var r=0;r<15;r++)if(n=(t-(s*e-i*Math.sin(2*e)+a*Math.sin(4*e)-h*Math.sin(6*e)))/(s-2*i*Math.cos(2*e)+4*a*Math.cos(4*e)-6*h*Math.cos(6*e)),e+=n,Math.abs(n)<=1e-10)return e;return NaN},Rs={init:function(){this.sphere||(this.e0=Ps(this.es),this.e1=Ns(this.es),this.e2=Ss(this.es),this.e3=ks(this.es),this.ml0=this.a*Es(this.e0,this.e1,this.e2,this.e3,this.lat0))},forward:function(t){var s,i,a=t.x,h=t.y;if(a=qt(a-this.long0),this.sphere)s=this.a*Math.asin(Math.cos(h)*Math.sin(a)),i=this.a*(Math.atan2(Math.tan(h),Math.cos(a))-this.lat0);else{var e=Math.sin(h),n=Math.cos(h),r=qs(this.a,this.e,e),o=Math.tan(h)*Math.tan(h),l=a*Math.cos(h),M=l*l,c=this.es*n*n/(1-this.es);s=r*l*(1-M*o*(1/6-(8-o+8*c)*M/120)),i=this.a*Es(this.e0,this.e1,this.e2,this.e3,h)-this.ml0+r*e/n*M*(.5+(5-o+6*c)*M/24)}return t.x=s+this.x0,t.y=i+this.y0,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s,i,a=t.x/this.a,h=t.y/this.a;if(this.sphere){var e=h+this.lat0;s=Math.asin(Math.sin(e)*Math.cos(a)),i=Math.atan2(Math.tan(a),Math.cos(e))}else{var n=this.ml0/this.a+h,r=Os(n,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(r)-ht)<=ot)return t.x=this.long0,t.y=ht,h<0&&(t.y*=-1),t;var o=qs(this.a,this.e,Math.sin(r)),l=o*o*o/this.a/this.a*(1-this.es),M=Math.pow(Math.tan(r),2),c=a*this.a/o,u=c*c;s=r-o*Math.tan(r)/l*c*c*(.5-(1+3*M)*c*c/24),i=c*(1-u*(M/3+(1+3*M)*M*u/15))/Math.cos(r)}return t.x=qt(i+this.long0),t.y=Is(s),t},names:["Cassini","Cassini_Soldner","cass"]},Gs=function(t,s){var i;return t>1e-7?(i=t*s,(1-t*t)*(s/(1-i*i)-.5/t*Math.log((1-i)/(1+i)))):2*s},Ts=.3333333333333333,js=.17222222222222222,zs=.10257936507936508,Ls=.06388888888888888,Ds=.0664021164021164,Bs=.016415012942191543,Us={init:function(){var t=Math.abs(this.lat0);if(Math.abs(t-ht)<ot?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(t)<ot?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0){var s;switch(this.qp=Gs(this.e,1),this.mmf=.5/(1-this.es),this.apa=X(this.es),this.mode){case this.N_POLE:case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),s=Math.sin(this.lat0),this.sinb1=Gs(this.e,s)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*s*s)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))},forward:function(t){var s,i,a,h,e,n,r,o,l,M,c=t.x,u=t.y;if(c=qt(c-this.long0),this.sphere){if(e=Math.sin(u),M=Math.cos(u),a=Math.cos(c),this.mode===this.OBLIQ||this.mode===this.EQUIT){if((i=this.mode===this.EQUIT?1+M*a:1+this.sinph0*e+this.cosph0*M*a)<=ot)return null;s=(i=Math.sqrt(2/i))*M*Math.sin(c),i*=this.mode===this.EQUIT?e:this.cosph0*e-this.sinph0*M*a}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(a=-a),Math.abs(u+this.phi0)<ot)return null;i=ct-.5*u,s=(i=2*(this.mode===this.S_POLE?Math.cos(i):Math.sin(i)))*Math.sin(c),i*=a}}else{switch(r=0,o=0,l=0,a=Math.cos(c),h=Math.sin(c),e=Math.sin(u),n=Gs(this.e,e),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(r=n/this.qp,o=Math.sqrt(1-r*r)),this.mode){case this.OBLIQ:l=1+this.sinb1*r+this.cosb1*o*a;break;case this.EQUIT:l=1+o*a;break;case this.N_POLE:l=ht+u,n=this.qp-n;break;case this.S_POLE:l=u-ht,n=this.qp+n}if(Math.abs(l)<ot)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:l=Math.sqrt(2/l),i=this.mode===this.OBLIQ?this.ymf*l*(this.cosb1*r-this.sinb1*o*a):(l=Math.sqrt(2/(1+o*a)))*r*this.ymf,s=this.xmf*l*o*h;break;case this.N_POLE:case this.S_POLE:n>=0?(s=(l=Math.sqrt(n))*h,i=a*(this.mode===this.S_POLE?l:-l)):s=i=0}}return t.x=this.a*s+this.x0,t.y=this.a*i+this.y0,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s,i,a,h,e,n,r,o=t.x/this.a,l=t.y/this.a;if(this.sphere){var M,c=0,u=0;if(M=Math.sqrt(o*o+l*l),(i=.5*M)>1)return null;switch(i=2*Math.asin(i),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(u=Math.sin(i),c=Math.cos(i)),this.mode){case this.EQUIT:i=Math.abs(M)<=ot?0:Math.asin(l*u/M),o*=u,l=c*M;break;case this.OBLIQ:i=Math.abs(M)<=ot?this.phi0:Math.asin(c*this.sinph0+l*u*this.cosph0/M),o*=u*this.cosph0,l=(c-Math.sin(i)*this.sinph0)*M;break;case this.N_POLE:l=-l,i=ht-i;break;case this.S_POLE:i-=ht}s=0!==l||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(o,l):0}else{if(r=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(o/=this.dd,l*=this.dd,(n=Math.sqrt(o*o+l*l))<ot)return t.x=0,t.y=this.phi0,t;h=2*Math.asin(.5*n/this.rq),a=Math.cos(h),o*=h=Math.sin(h),this.mode===this.OBLIQ?(r=a*this.sinb1+l*h*this.cosb1/n,e=this.qp*r,l=n*this.cosb1*a-l*this.sinb1*h):(r=l*h/n,e=this.qp*r,l=n*a)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(l=-l),!(e=o*o+l*l))return t.x=0,t.y=this.phi0,t;r=1-e/this.qp,this.mode===this.S_POLE&&(r=-r)}s=Math.atan2(o,l),i=J(Math.asin(r),this.apa)}return t.x=qt(this.long0+s),t.y=i,t},names:["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],S_POLE:1,N_POLE:2,EQUIT:3,OBLIQ:4},Fs=function(t){return Math.abs(t)>1&&(t=t>1?1:-1),Math.asin(t)},Qs={init:function(){Math.abs(this.lat1+this.lat2)<ot||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=St(this.e3,this.sin_po,this.cos_po),this.qs1=Gs(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=St(this.e3,this.sin_po,this.cos_po),this.qs2=Gs(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=Gs(this.e3,this.sin_po,this.cos_po),Math.abs(this.lat1-this.lat2)>ot?this.ns0=(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.ns0=this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)},forward:function(t){var s=t.x,i=t.y;this.sin_phi=Math.sin(i),this.cos_phi=Math.cos(i);var a=Gs(this.e3,this.sin_phi,this.cos_phi),h=this.a*Math.sqrt(this.c-this.ns0*a)/this.ns0,e=this.ns0*qt(s-this.long0),n=h*Math.sin(e)+this.x0,r=this.rh-h*Math.cos(e)+this.y0;return t.x=n,t.y=r,t},inverse:function(t){var s,i,a,h,e,n;return t.x-=this.x0,t.y=this.rh-t.y+this.y0,this.ns0>=0?(s=Math.sqrt(t.x*t.x+t.y*t.y),a=1):(s=-Math.sqrt(t.x*t.x+t.y*t.y),a=-1),h=0,0!==s&&(h=Math.atan2(a*t.x,a*t.y)),a=s*this.ns0/this.a,this.sphere?n=Math.asin((this.c-a*a)/(2*this.ns0)):(i=(this.c-a*a)/this.ns0,n=this.phi1z(this.e3,i)),e=qt(h/this.ns0+this.long0),t.x=e,t.y=n,t},names:["Albers_Conic_Equal_Area","Albers","aea"],phi1z:function(t,s){var i,a,h,e,n,r=Fs(.5*s);if(t<ot)return r;for(var o=t*t,l=1;l<=25;l++)if(i=Math.sin(r),a=Math.cos(r),h=t*i,e=1-h*h,n=.5*e*e/a*(s/(1-o)-i/e+.5/t*Math.log((1-h)/(1+h))),r+=n,Math.abs(n)<=1e-7)return r;return null}},Ws={init:function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1},forward:function(t){var s,i,a,h,e,n,r,o=t.x,l=t.y;return a=qt(o-this.long0),s=Math.sin(l),i=Math.cos(l),h=Math.cos(a),(e=this.sin_p14*s+this.cos_p14*i*h)>0||Math.abs(e)<=ot?(n=this.x0+1*this.a*i*Math.sin(a)/e,r=this.y0+1*this.a*(this.cos_p14*s-this.sin_p14*i*h)/e):(n=this.x0+this.infinity_dist*i*Math.sin(a),r=this.y0+this.infinity_dist*(this.cos_p14*s-this.sin_p14*i*h)),t.x=n,t.y=r,t},inverse:function(t){var s,i,a,h,e,n;return t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,t.x/=this.k0,t.y/=this.k0,(s=Math.sqrt(t.x*t.x+t.y*t.y))?(h=Math.atan2(s,this.rc),i=Math.sin(h),a=Math.cos(h),n=Fs(a*this.sin_p14+t.y*i*this.cos_p14/s),e=Math.atan2(t.x*i,s*this.cos_p14*a-t.y*this.sin_p14*i),e=qt(this.long0+e)):(n=this.phic0,e=0),t.x=e,t.y=n,t},names:["gnom"]},Hs=function(t,s){var i=1-(1-t*t)/(2*t)*Math.log((1-t)/(1+t));if(Math.abs(Math.abs(s)-i)<1e-6)return s<0?-1*ht:ht;for(var a,h,e,n,r=Math.asin(.5*s),o=0;o<30;o++)if(h=Math.sin(r),e=Math.cos(r),n=t*h,a=Math.pow(1-n*n,2)/(2*e)*(s/(1-t*t)-h/(1-n*n)+.5/t*Math.log((1-n)/(1+n))),r+=a,Math.abs(a)<=1e-10)return r;return NaN},Ks={init:function(){this.sphere||(this.k0=St(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))},forward:function(t){var s,i,a=t.x,h=t.y,e=qt(a-this.long0);if(this.sphere)s=this.x0+this.a*e*Math.cos(this.lat_ts),i=this.y0+this.a*Math.sin(h)/Math.cos(this.lat_ts);else{var n=Gs(this.e,Math.sin(h));s=this.x0+this.a*this.k0*e,i=this.y0+this.a*n*.5/this.k0}return t.x=s,t.y=i,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s,i;return this.sphere?(s=qt(this.long0+t.x/this.a/Math.cos(this.lat_ts)),i=Math.asin(t.y/this.a*Math.cos(this.lat_ts))):(i=Hs(this.e,2*t.y*this.k0/this.a),s=qt(this.long0+t.x/(this.a*this.k0))),t.x=s,t.y=i,t},names:["cea"]},Xs={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)},forward:function(t){var s=t.x,i=t.y,a=qt(s-this.long0),h=Is(i-this.lat0);return t.x=this.x0+this.a*a*this.rc,t.y=this.y0+this.a*h,t},inverse:function(t){var s=t.x,i=t.y;return t.x=qt(this.long0+(s-this.x0)/(this.a*this.rc)),t.y=Is(this.lat0+(i-this.y0)/this.a),t},names:["Equirectangular","Equidistant_Cylindrical","eqc"]},Js=20,Vs={init:function(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Ps(this.es),this.e1=Ns(this.es),this.e2=Ss(this.es),this.e3=ks(this.es),this.ml0=this.a*Es(this.e0,this.e1,this.e2,this.e3,this.lat0)},forward:function(t){var s,i,a,h=t.x,e=t.y,n=qt(h-this.long0);if(a=n*Math.sin(e),this.sphere)Math.abs(e)<=ot?(s=this.a*n,i=-1*this.a*this.lat0):(s=this.a*Math.sin(a)/Math.tan(e),i=this.a*(Is(e-this.lat0)+(1-Math.cos(a))/Math.tan(e)));else if(Math.abs(e)<=ot)s=this.a*n,i=-1*this.ml0;else{var r=qs(this.a,this.e,Math.sin(e))/Math.tan(e);s=r*Math.sin(a),i=this.a*Es(this.e0,this.e1,this.e2,this.e3,e)-this.ml0+r*(1-Math.cos(a))}return t.x=s+this.x0,t.y=i+this.y0,t},inverse:function(t){var s,i,a,h,e,n,r,o,l;if(a=t.x-this.x0,h=t.y-this.y0,this.sphere)if(Math.abs(h+this.a*this.lat0)<=ot)s=qt(a/this.a+this.long0),i=0;else{n=this.lat0+h/this.a,r=a*a/this.a/this.a+n*n,o=n;var M;for(e=Js;e;--e)if(M=Math.tan(o),l=-1*(n*(o*M+1)-o-.5*(o*o+r)*M)/((o-n)/M-1),o+=l,Math.abs(l)<=ot){i=o;break}s=qt(this.long0+Math.asin(a*Math.tan(o)/this.a)/Math.sin(i))}else if(Math.abs(h+this.ml0)<=ot)i=0,s=qt(this.long0+a/this.a);else{n=(this.ml0+h)/this.a,r=a*a/this.a/this.a+n*n,o=n;var c,u,f,m,p;for(e=Js;e;--e)if(p=this.e*Math.sin(o),c=Math.sqrt(1-p*p)*Math.tan(o),u=this.a*Es(this.e0,this.e1,this.e2,this.e3,o),f=this.e0-2*this.e1*Math.cos(2*o)+4*this.e2*Math.cos(4*o)-6*this.e3*Math.cos(6*o),m=u/this.a,l=(n*(c*m+1)-m-.5*c*(m*m+r))/(this.es*Math.sin(2*o)*(m*m+r-2*n*m)/(4*c)+(n-m)*(c*f-2/Math.sin(2*o))-f),o-=l,Math.abs(l)<=ot){i=o;break}c=Math.sqrt(1-this.es*Math.pow(Math.sin(i),2))*Math.tan(i),s=qt(this.long0+Math.asin(a*c/this.a)/Math.sin(i))}return t.x=s,t.y=i,t},names:["Polyconic","poly"]},Zs={init:function(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013},forward:function(t){var s,i=t.x,a=t.y-this.lat0,h=i-this.long0,e=a/at*1e-5,n=h,r=1,o=0;for(s=1;s<=10;s++)r*=e,o+=this.A[s]*r;var l,M=o,c=n,u=1,f=0,m=0,p=0;for(s=1;s<=6;s++)l=f*M+u*c,u=u*M-f*c,f=l,m=m+this.B_re[s]*u-this.B_im[s]*f,p=p+this.B_im[s]*u+this.B_re[s]*f;return t.x=p*this.a+this.x0,t.y=m*this.a+this.y0,t},inverse:function(t){var s,i,a=t.x,h=t.y,e=a-this.x0,n=(h-this.y0)/this.a,r=e/this.a,o=1,l=0,M=0,c=0;for(s=1;s<=6;s++)i=l*n+o*r,o=o*n-l*r,l=i,M=M+this.C_re[s]*o-this.C_im[s]*l,c=c+this.C_im[s]*o+this.C_re[s]*l;for(var u=0;u<this.iterations;u++){var f,m=M,p=c,d=n,y=r;for(s=2;s<=6;s++)f=p*M+m*c,m=m*M-p*c,p=f,d+=(s-1)*(this.B_re[s]*m-this.B_im[s]*p),y+=(s-1)*(this.B_im[s]*m+this.B_re[s]*p);m=1,p=0;var _=this.B_re[1],x=this.B_im[1];for(s=2;s<=6;s++)f=p*M+m*c,m=m*M-p*c,p=f,_+=s*(this.B_re[s]*m-this.B_im[s]*p),x+=s*(this.B_im[s]*m+this.B_re[s]*p);var v=_*_+x*x;M=(d*_+y*x)/v,c=(y*_-d*x)/v}var g=M,b=c,w=1,A=0;for(s=1;s<=9;s++)w*=g,A+=this.D[s]*w;var C=this.lat0+A*at*1e5,E=this.long0+b;return t.x=E,t.y=C,t},names:["New_Zealand_Map_Grid","nzmg"]},Ys={init:function(){},forward:function(t){var s=t.x,i=t.y,a=qt(s-this.long0),h=this.x0+this.a*a,e=this.y0+this.a*Math.log(Math.tan(Math.PI/4+i/2.5))*1.25;return t.x=h,t.y=e,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s=qt(this.long0+t.x/this.a),i=2.5*(Math.atan(Math.exp(.8*t.y/this.a))-Math.PI/4);return t.x=s,t.y=i,t},names:["Miller_Cylindrical","mill"]},$s=20,ti={init:function(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=is(this.es)},forward:function(t){var s,i,a=t.x,h=t.y;if(a=qt(a-this.long0),this.sphere){if(this.m)for(var e=this.n*Math.sin(h),n=$s;n;--n){var r=(this.m*h+Math.sin(h)-e)/(this.m+Math.cos(h));if(h-=r,Math.abs(r)<ot)break}else h=1!==this.n?Math.asin(this.n*Math.sin(h)):h;s=this.a*this.C_x*a*(this.m+Math.cos(h)),i=this.a*this.C_y*h}else{var o=Math.sin(h),l=Math.cos(h);i=this.a*as(h,o,l,this.en),s=this.a*a*l/Math.sqrt(1-this.es*o*o)}return t.x=s,t.y=i,t},inverse:function(t){var s,i,a,h;return t.x-=this.x0,a=t.x/this.a,t.y-=this.y0,s=t.y/this.a,this.sphere?(s/=this.C_y,a/=this.C_x*(this.m+Math.cos(s)),this.m?s=Fs((this.m*s+Math.sin(s))/this.n):1!==this.n&&(s=Fs(Math.sin(s)/this.n)),a=qt(a+this.long0),s=Is(s)):(s=hs(t.y/this.a,this.es,this.en),(h=Math.abs(s))<ht?(h=Math.sin(s),i=this.long0+t.x*Math.sqrt(1-this.es*h*h)/(this.a*Math.cos(s)),a=qt(i)):h-ot<ht&&(a=this.long0)),t.x=a,t.y=s,t},names:["Sinusoidal","sinu"]},si={init:function(){},forward:function(t){for(var s=t.x,i=t.y,a=qt(s-this.long0),h=i,e=Math.PI*Math.sin(i);;){var n=-(h+Math.sin(h)-e)/(1+Math.cos(h));if(h+=n,Math.abs(n)<ot)break}h/=2,Math.PI/2-Math.abs(i)<ot&&(a=0);var r=.900316316158*this.a*a*Math.cos(h)+this.x0,o=1.4142135623731*this.a*Math.sin(h)+this.y0;return t.x=r,t.y=o,t},inverse:function(t){var s,i;t.x-=this.x0,t.y-=this.y0,i=t.y/(1.4142135623731*this.a),Math.abs(i)>.999999999999&&(i=.999999999999),s=Math.asin(i);var a=qt(this.long0+t.x/(.900316316158*this.a*Math.cos(s)));a<-Math.PI&&(a=-Math.PI),a>Math.PI&&(a=Math.PI),i=(2*s+Math.sin(2*s))/Math.PI,Math.abs(i)>1&&(i=1);var h=Math.asin(i);return t.x=a,t.y=h,t},names:["Mollweide","moll"]},ii={init:function(){Math.abs(this.lat1+this.lat2)<ot||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Ps(this.es),this.e1=Ns(this.es),this.e2=Ss(this.es),this.e3=ks(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=St(this.e,this.sinphi,this.cosphi),this.ml1=Es(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<ot?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=St(this.e,this.sinphi,this.cosphi),this.ml2=Es(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=Es(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))},forward:function(t){var s,i=t.x,a=t.y;if(this.sphere)s=this.a*(this.g-a);else{var h=Es(this.e0,this.e1,this.e2,this.e3,a);s=this.a*(this.g-h)}var e=this.ns*qt(i-this.long0),n=this.x0+s*Math.sin(e),r=this.y0+this.rh-s*Math.cos(e);return t.x=n,t.y=r,t},inverse:function(t){t.x-=this.x0,t.y=this.rh-t.y+this.y0;var s,i,a,h;this.ns>=0?(i=Math.sqrt(t.x*t.x+t.y*t.y),s=1):(i=-Math.sqrt(t.x*t.x+t.y*t.y),s=-1);var e=0;if(0!==i&&(e=Math.atan2(s*t.x,s*t.y)),this.sphere)return h=qt(this.long0+e/this.ns),a=Is(this.g-i/this.a),t.x=h,t.y=a,t;var n=this.g-i/this.a;return a=Os(n,this.e0,this.e1,this.e2,this.e3),h=qt(this.long0+e/this.ns),t.x=h,t.y=a,t},names:["Equidistant_Conic","eqdc"]},ai={init:function(){this.R=this.a},forward:function(t){var s,i,a=t.x,h=t.y,e=qt(a-this.long0);Math.abs(h)<=ot&&(s=this.x0+this.R*e,i=this.y0);var n=Fs(2*Math.abs(h/Math.PI));(Math.abs(e)<=ot||Math.abs(Math.abs(h)-ht)<=ot)&&(s=this.x0,i=h>=0?this.y0+Math.PI*this.R*Math.tan(.5*n):this.y0+Math.PI*this.R*-Math.tan(.5*n));var r=.5*Math.abs(Math.PI/e-e/Math.PI),o=r*r,l=Math.sin(n),M=Math.cos(n),c=M/(l+M-1),u=c*c,f=c*(2/l-1),m=f*f,p=Math.PI*this.R*(r*(c-m)+Math.sqrt(o*(c-m)*(c-m)-(m+o)*(u-m)))/(m+o);e<0&&(p=-p),s=this.x0+p;var d=o+c;return p=Math.PI*this.R*(f*d-r*Math.sqrt((m+o)*(o+1)-d*d))/(m+o),i=h>=0?this.y0+p:this.y0-p,t.x=s,t.y=i,t},inverse:function(t){var s,i,a,h,e,n,r,o,l,M,c,u,f;return t.x-=this.x0,t.y-=this.y0,c=Math.PI*this.R,a=t.x/c,h=t.y/c,e=a*a+h*h,n=-Math.abs(h)*(1+e),r=n-2*h*h+a*a,o=-2*n+1+2*h*h+e*e,f=h*h/o+(2*r*r*r/o/o/o-9*n*r/o/o)/27,l=(n-r*r/3/o)/o,M=2*Math.sqrt(-l/3),c=3*f/l/M,Math.abs(c)>1&&(c=c>=0?1:-1),u=Math.acos(c)/3,i=t.y>=0?(-M*Math.cos(u+Math.PI/3)-r/3/o)*Math.PI:-(-M*Math.cos(u+Math.PI/3)-r/3/o)*Math.PI,s=Math.abs(a)<ot?this.long0:qt(this.long0+Math.PI*(e-1+Math.sqrt(1+2*(a*a-h*h)+e*e))/2/a),t.x=s,t.y=i,t},names:["Van_der_Grinten_I","VanDerGrinten","vandg"]},hi={init:function(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0)},forward:function(t){var s,i,a,h,e,n,r,o,l,M,c,u,f,m,p,d,y,_,x,v,g,b,w,A=t.x,C=t.y,E=Math.sin(t.y),P=Math.cos(t.y),N=qt(A-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=ot?(t.x=this.x0+this.a*(ht-C)*Math.sin(N),t.y=this.y0-this.a*(ht-C)*Math.cos(N),t):Math.abs(this.sin_p12+1)<=ot?(t.x=this.x0+this.a*(ht+C)*Math.sin(N),t.y=this.y0+this.a*(ht+C)*Math.cos(N),t):(_=this.sin_p12*E+this.cos_p12*P*Math.cos(N),d=Math.acos(_),y=d/Math.sin(d),t.x=this.x0+this.a*y*P*Math.sin(N),t.y=this.y0+this.a*y*(this.cos_p12*E-this.sin_p12*P*Math.cos(N)),t):(s=Ps(this.es),i=Ns(this.es),a=Ss(this.es),h=ks(this.es),Math.abs(this.sin_p12-1)<=ot?(e=this.a*Es(s,i,a,h,ht),n=this.a*Es(s,i,a,h,C),t.x=this.x0+(e-n)*Math.sin(N),t.y=this.y0-(e-n)*Math.cos(N),t):Math.abs(this.sin_p12+1)<=ot?(e=this.a*Es(s,i,a,h,ht),n=this.a*Es(s,i,a,h,C),t.x=this.x0+(e+n)*Math.sin(N),t.y=this.y0+(e+n)*Math.cos(N),t):(r=E/P,o=qs(this.a,this.e,this.sin_p12),l=qs(this.a,this.e,E),M=Math.atan((1-this.es)*r+this.es*o*this.sin_p12/(l*P)),c=Math.atan2(Math.sin(N),this.cos_p12*Math.tan(M)-this.sin_p12*Math.cos(N)),x=0===c?Math.asin(this.cos_p12*Math.sin(M)-this.sin_p12*Math.cos(M)):Math.abs(Math.abs(c)-Math.PI)<=ot?-Math.asin(this.cos_p12*Math.sin(M)-this.sin_p12*Math.cos(M)):Math.asin(Math.sin(N)*Math.cos(M)/Math.sin(c)),u=this.e*this.sin_p12/Math.sqrt(1-this.es),f=this.e*this.cos_p12*Math.cos(c)/Math.sqrt(1-this.es),m=u*f,p=f*f,v=x*x,g=v*x,b=g*x,w=b*x,d=o*x*(1-v*p*(1-p)/6+g/8*m*(1-2*p)+b/120*(p*(4-7*p)-3*u*u*(1-7*p))-w/48*m),t.x=this.x0+d*Math.sin(c),t.y=this.y0+d*Math.cos(c),t))},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var s,i,a,h,e,n,r,o,l,M,c,u,f,m,p,d,y,_,x,v,g,b,w;if(this.sphere){if((s=Math.sqrt(t.x*t.x+t.y*t.y))>2*ht*this.a)return;return i=s/this.a,a=Math.sin(i),h=Math.cos(i),e=this.long0,Math.abs(s)<=ot?n=this.lat0:(n=Fs(h*this.sin_p12+t.y*a*this.cos_p12/s),r=Math.abs(this.lat0)-ht,e=qt(Math.abs(r)<=ot?this.lat0>=0?this.long0+Math.atan2(t.x,-t.y):this.long0-Math.atan2(-t.x,t.y):this.long0+Math.atan2(t.x*a,s*this.cos_p12*h-t.y*this.sin_p12*a))),t.x=e,t.y=n,t}return o=Ps(this.es),l=Ns(this.es),M=Ss(this.es),c=ks(this.es),Math.abs(this.sin_p12-1)<=ot?(u=this.a*Es(o,l,M,c,ht),s=Math.sqrt(t.x*t.x+t.y*t.y),f=u-s,n=Os(f/this.a,o,l,M,c),e=qt(this.long0+Math.atan2(t.x,-1*t.y)),t.x=e,t.y=n,t):Math.abs(this.sin_p12+1)<=ot?(u=this.a*Es(o,l,M,c,ht),s=Math.sqrt(t.x*t.x+t.y*t.y),f=s-u,n=Os(f/this.a,o,l,M,c),e=qt(this.long0+Math.atan2(t.x,t.y)),t.x=e,t.y=n,t):(s=Math.sqrt(t.x*t.x+t.y*t.y),d=Math.atan2(t.x,t.y),m=qs(this.a,this.e,this.sin_p12),y=Math.cos(d),_=this.e*this.cos_p12*y,x=-_*_/(1-this.es),v=3*this.es*(1-x)*this.sin_p12*this.cos_p12*y/(1-this.es),g=s/m,b=g-x*(1+x)*Math.pow(g,3)/6-v*(1+3*x)*Math.pow(g,4)/24,w=1-x*b*b/2-g*b*b*b/6,p=Math.asin(this.sin_p12*Math.cos(b)+this.cos_p12*Math.sin(b)*y),e=qt(this.long0+Math.asin(Math.sin(d)*Math.sin(b)/Math.cos(p))),n=Math.atan((1-this.es*w*this.sin_p12/Math.sin(p))*Math.tan(p)/(1-this.es)),t.x=e,t.y=n,t)},names:["Azimuthal_Equidistant","aeqd"]},ei={init:function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0)},forward:function(t){var s,i,a,h,e,n,r,o=t.x,l=t.y;return a=qt(o-this.long0),s=Math.sin(l),i=Math.cos(l),h=Math.cos(a),((e=this.sin_p14*s+this.cos_p14*i*h)>0||Math.abs(e)<=ot)&&(n=1*this.a*i*Math.sin(a),r=this.y0+1*this.a*(this.cos_p14*s-this.sin_p14*i*h)),t.x=n,t.y=r,t},inverse:function(t){var s,i,a,h,e,n,r;return t.x-=this.x0,t.y-=this.y0,s=Math.sqrt(t.x*t.x+t.y*t.y),i=Fs(s/this.a),a=Math.sin(i),h=Math.cos(i),n=this.long0,Math.abs(s)<=ot?(r=this.lat0,t.x=n,t.y=r,t):(r=Fs(h*this.sin_p14+t.y*a*this.cos_p14/s),e=Math.abs(this.lat0)-ht,Math.abs(e)<=ot?(n=qt(this.lat0>=0?this.long0+Math.atan2(t.x,-t.y):this.long0-Math.atan2(-t.x,t.y)),t.x=n,t.y=r,t):(n=qt(this.long0+Math.atan2(t.x*a,s*this.cos_p14*h-t.y*this.sin_p14*a)),t.x=n,t.y=r,t))},names:["ortho"]},ni={FRONT:1,RIGHT:2,BACK:3,LEFT:4,TOP:5,BOTTOM:6},ri={AREA_0:1,AREA_1:2,AREA_2:3,AREA_3:4},oi={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Quadrilateralized Spherical Cube",this.lat0>=ht-ct/2?this.face=ni.TOP:this.lat0<=-(ht-ct/2)?this.face=ni.BOTTOM:Math.abs(this.long0)<=ct?this.face=ni.FRONT:Math.abs(this.long0)<=ht+ct?this.face=this.long0>0?ni.RIGHT:ni.LEFT:this.face=ni.BACK,0!==this.es&&(this.one_minus_f=1-(this.a-this.b)/this.a,this.one_minus_f_squared=this.one_minus_f*this.one_minus_f)},forward:function(t){var s,i,a,h,e,n,r={x:0,y:0},o={value:0};if(t.x-=this.long0,s=0!==this.es?Math.atan(this.one_minus_f_squared*Math.tan(t.y)):t.y,i=t.x,this.face===ni.TOP)h=ht-s,i>=ct&&i<=ht+ct?(o.value=ri.AREA_0,a=i-ht):i>ht+ct||i<=-(ht+ct)?(o.value=ri.AREA_1,a=i>0?i-ft:i+ft):i>-(ht+ct)&&i<=-ct?(o.value=ri.AREA_2,a=i+ht):(o.value=ri.AREA_3,a=i);else if(this.face===ni.BOTTOM)h=ht+s,i>=ct&&i<=ht+ct?(o.value=ri.AREA_0,a=-i+ht):i<ct&&i>=-ct?(o.value=ri.AREA_1,a=-i):i<-ct&&i>=-(ht+ct)?(o.value=ri.AREA_2,a=-i-ht):(o.value=ri.AREA_3,a=i>0?-i+ft:-i-ft);else{var l,M,c,u,f,m;this.face===ni.RIGHT?i=Z(i,+ht):this.face===ni.BACK?i=Z(i,+ft):this.face===ni.LEFT&&(i=Z(i,-ht)),u=Math.sin(s),f=Math.cos(s),m=Math.sin(i),l=f*Math.cos(i),M=f*m,c=u,this.face===ni.FRONT?a=V(h=Math.acos(l),c,M,o):this.face===ni.RIGHT?a=V(h=Math.acos(M),c,-l,o):this.face===ni.BACK?a=V(h=Math.acos(-l),c,-M,o):this.face===ni.LEFT?a=V(h=Math.acos(-M),c,l,o):(h=a=0,o.value=ri.AREA_0)}return n=Math.atan(12/ft*(a+Math.acos(Math.sin(a)*Math.cos(ct))-ht)),e=Math.sqrt((1-Math.cos(h))/(Math.cos(n)*Math.cos(n))/(1-Math.cos(Math.atan(1/Math.cos(a))))),o.value===ri.AREA_1?n+=ht:o.value===ri.AREA_2?n+=ft:o.value===ri.AREA_3&&(n+=1.5*ft),r.x=e*Math.cos(n),r.y=e*Math.sin(n),r.x=r.x*this.a+this.x0,r.y=r.y*this.a+this.y0,t.x=r.x,t.y=r.y,t},inverse:function(t){var s,i,a,h,e,n,r,o,l,M={lam:0,phi:0},c={value:0};if(t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,i=Math.atan(Math.sqrt(t.x*t.x+t.y*t.y)),s=Math.atan2(t.y,t.x),t.x>=0&&t.x>=Math.abs(t.y)?c.value=ri.AREA_0:t.y>=0&&t.y>=Math.abs(t.x)?(c.value=ri.AREA_1,s-=ht):t.x<0&&-t.x>=Math.abs(t.y)?(c.value=ri.AREA_2,s=s<0?s+ft:s-ft):(c.value=ri.AREA_3,s+=ht),l=ft/12*Math.tan(s),e=Math.sin(l)/(Math.cos(l)-1/Math.sqrt(2)),n=Math.atan(e),a=Math.cos(s),h=Math.tan(i),(r=1-a*a*h*h*(1-Math.cos(Math.atan(1/Math.cos(n)))))<-1?r=-1:r>1&&(r=1),this.face===ni.TOP)o=Math.acos(r),M.phi=ht-o,c.value===ri.AREA_0?M.lam=n+ht:c.value===ri.AREA_1?M.lam=n<0?n+ft:n-ft:c.value===ri.AREA_2?M.lam=n-ht:M.lam=n;else if(this.face===ni.BOTTOM)o=Math.acos(r),M.phi=o-ht,c.value===ri.AREA_0?M.lam=-n+ht:c.value===ri.AREA_1?M.lam=-n:c.value===ri.AREA_2?M.lam=-n-ht:M.lam=n<0?-n-ft:-n+ft;else{var u,f,m;l=(u=r)*u,f=(l+=(m=l>=1?0:Math.sqrt(1-l)*Math.sin(n))*m)>=1?0:Math.sqrt(1-l),c.value===ri.AREA_1?(l=f,f=-m,m=l):c.value===ri.AREA_2?(f=-f,m=-m):c.value===ri.AREA_3&&(l=f,f=m,m=-l),this.face===ni.RIGHT?(l=u,u=-f,f=l):this.face===ni.BACK?(u=-u,f=-f):this.face===ni.LEFT&&(l=u,u=f,f=-l),M.phi=Math.acos(-m)-ht,M.lam=Math.atan2(f,u),this.face===ni.RIGHT?M.lam=Z(M.lam,-ht):this.face===ni.BACK?M.lam=Z(M.lam,-ft):this.face===ni.LEFT&&(M.lam=Z(M.lam,+ht))}if(0!==this.es){var p,d,y;p=M.phi<0?1:0,d=Math.tan(M.phi),y=this.b/Math.sqrt(d*d+this.one_minus_f_squared),M.phi=Math.atan(Math.sqrt(this.a*this.a-y*y)/(this.one_minus_f*y)),p&&(M.phi=-M.phi)}return M.lam+=this.long0,t.x=M.lam,t.y=M.phi,t},names:["Quadrilateralized Spherical Cube","Quadrilateralized_Spherical_Cube","qsc"]},li=[[1,2.2199e-17,-715515e-10,31103e-10],[.9986,-482243e-9,-24897e-9,-13309e-10],[.9954,-83103e-8,-448605e-10,-9.86701e-7],[.99,-.00135364,-59661e-9,36777e-10],[.9822,-.00167442,-449547e-11,-572411e-11],[.973,-.00214868,-903571e-10,1.8736e-8],[.96,-.00305085,-900761e-10,164917e-11],[.9427,-.00382792,-653386e-10,-26154e-10],[.9216,-.00467746,-10457e-8,481243e-11],[.8962,-.00536223,-323831e-10,-543432e-11],[.8679,-.00609363,-113898e-9,332484e-11],[.835,-.00698325,-640253e-10,9.34959e-7],[.7986,-.00755338,-500009e-10,9.35324e-7],[.7597,-.00798324,-35971e-9,-227626e-11],[.7186,-.00851367,-701149e-10,-86303e-10],[.6732,-.00986209,-199569e-9,191974e-10],[.6213,-.010418,883923e-10,624051e-11],[.5722,-.00906601,182e-6,624051e-11],[.5322,-.00677797,275608e-9,624051e-11]],Mi=[[-5.20417e-18,.0124,1.21431e-18,-8.45284e-11],[.062,.0124,-1.26793e-9,4.22642e-10],[.124,.0124,5.07171e-9,-1.60604e-9],[.186,.0123999,-1.90189e-8,6.00152e-9],[.248,.0124002,7.10039e-8,-2.24e-8],[.31,.0123992,-2.64997e-7,8.35986e-8],[.372,.0124029,9.88983e-7,-3.11994e-7],[.434,.0123893,-369093e-11,-4.35621e-7],[.4958,.0123198,-102252e-10,-3.45523e-7],[.5571,.0121916,-154081e-10,-5.82288e-7],[.6176,.0119938,-241424e-10,-5.25327e-7],[.6769,.011713,-320223e-10,-5.16405e-7],[.7346,.0113541,-397684e-10,-6.09052e-7],[.7903,.0109107,-489042e-10,-104739e-11],[.8435,.0103431,-64615e-9,-1.40374e-9],[.8936,.00969686,-64636e-9,-8547e-9],[.9394,.00840947,-192841e-9,-42106e-10],[.9761,.00616527,-256e-6,-42106e-10],[1,.00328947,-319159e-9,-42106e-10]],ci=.8487,ui=1.3523,fi=Mt/5,mi=1/fi,pi=18,di=function(t,s){return t[0]+s*(t[1]+s*(t[2]+s*t[3]))},yi=function(t,s){return t[1]+s*(2*t[2]+3*s*t[3])},_i={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.long0=this.long0||0,this.es=0,this.title=this.title||"Robinson"},forward:function(t){var s=qt(t.x-this.long0),i=Math.abs(t.y),a=Math.floor(i*fi);a<0?a=0:a>=pi&&(a=pi-1),i=Mt*(i-mi*a);var h={x:di(li[a],i)*s,y:di(Mi[a],i)};return t.y<0&&(h.y=-h.y),h.x=h.x*this.a*ci+this.x0,h.y=h.y*this.a*ui+this.y0,h},inverse:function(t){var s={x:(t.x-this.x0)/(this.a*ci),y:Math.abs(t.y-this.y0)/(this.a*ui)};if(s.y>=1)s.x/=li[pi][0],s.y=t.y<0?-ht:ht;else{var i=Math.floor(s.y*pi);for(i<0?i=0:i>=pi&&(i=pi-1);;)if(Mi[i][0]>s.y)--i;else{if(!(Mi[i+1][0]<=s.y))break;++i}var a=Mi[i],h=5*(s.y-a[0])/(Mi[i+1][0]-a[0]);h=Y(function(t){return(di(a,t)-s.y)/yi(a,t)},h,ot,100),s.x/=di(li[i],h),s.y=(5*i+h)*lt,t.y<0&&(s.y=-s.y)}return s.x=qt(s.x+this.long0),s},names:["Robinson","robin"]},xi={init:function(){this.name="geocent"},forward:function(t){return b(t,this.es,this.a)},inverse:function(t){return w(t,this.es,this.a,this.b)},names:["Geocentric","geocentric","geocent","Geocent"]};return I.defaultDatum="WGS84",I.Proj=Projection,I.WGS84=new I.Proj("WGS84"),I.Point=Point,I.toPoint=Ft,I.defs=o,I.transform=S,I.mgrs=ts,I.version="2.6.0",function(proj4){proj4.Proj.projections.add(es),proj4.Proj.projections.add(ms),proj4.Proj.projections.add(ds),proj4.Proj.projections.add(vs),proj4.Proj.projections.add(gs),proj4.Proj.projections.add(bs),proj4.Proj.projections.add(ws),proj4.Proj.projections.add(As),proj4.Proj.projections.add(Cs),proj4.Proj.projections.add(Rs),proj4.Proj.projections.add(Us),proj4.Proj.projections.add(Qs),proj4.Proj.projections.add(Ws),proj4.Proj.projections.add(Ks),proj4.Proj.projections.add(Xs),proj4.Proj.projections.add(Vs),proj4.Proj.projections.add(Zs),proj4.Proj.projections.add(Ys),proj4.Proj.projections.add(ti),proj4.Proj.projections.add(si),proj4.Proj.projections.add(ii),proj4.Proj.projections.add(ai),proj4.Proj.projections.add(hi),proj4.Proj.projections.add(ei),proj4.Proj.projections.add(oi),proj4.Proj.projections.add(_i),proj4.Proj.projections.add(xi)}(I),I});
var TC = TC || {};

TC.tool = TC.tool || {};

TC.tool.Proxification = function (proxy, options) {
    var self = this;

    self.Consts = {
        url: {
            SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/
        }
    };

    if (proxy === undefined) {
        throw new TypeError('"proxy" parameter is undefined', "TC.tool.Proxification.js");
    }

    if (typeof proxy == "function") {
        self.proxy = proxy;
    } else {
        self.proxy = function (url) {
            var result = proxy;
            if (url.substr(0, 4) != "http") {
                result += window.location.protocol;
            }
            result += encodeURIComponent(url);
            return result;
        };
    }

    options = options || {};

    self._location = options.location || window.location;

    self.preventMixedContent = options.allowedMixedContent !== undefined ? !options.allowedMixedContent : true;
};

(function () {
    if (!window.fetch) {
        (function (self) {
            // polyfill https://github.com/github/fetch/
            'use strict'; if (self.fetch) { return }
            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }
            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }
            function normalizeName(name) {
                if (typeof name !== 'string') { name = String(name) }
                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) { throw new TypeError('Invalid character in header field name') }
                return name.toLowerCase()
            }
            function normalizeValue(value) {
                if (typeof value !== 'string') { value = String(value) }
                return value
            }
            function iteratorFor(items) {
                var iterator = {
                    next: function () {
                        var value = items.shift()
                        return { done: value === undefined, value: value }
                    }
                }
                if (support.iterable) { iterator[Symbol.iterator] = function () { return iterator } }
                return iterator
            }
            function Headers(headers) {
                this.map = {}
                if (headers instanceof Headers) { headers.forEach(function (value, name) { this.append(name, value) }, this) } else if (Array.isArray(headers)) { headers.forEach(function (header) { this.append(header[0], header[1]) }, this) } else if (headers) { Object.getOwnPropertyNames(headers).forEach(function (name) { this.append(name, headers[name]) }, this) }
            }
            Headers.prototype.append = function (name, value) {
                name = normalizeName(name)
                value = normalizeValue(value)
                var oldValue = this.map[name]
                this.map[name] = oldValue ? oldValue + ',' + value : value
            }
            Headers.prototype['delete'] = function (name) { delete this.map[normalizeName(name)] }
            Headers.prototype.get = function (name) {
                name = normalizeName(name)
                return this.has(name) ? this.map[name] : null
            }
            Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)) }
            Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = normalizeValue(value) }
            Headers.prototype.forEach = function (callback, thisArg) { for (var name in this.map) { if (this.map.hasOwnProperty(name)) { callback.call(thisArg, this.map[name], name, this) } } }
            Headers.prototype.keys = function () {
                var items = []
                this.forEach(function (value, name) { items.push(name) })
                return iteratorFor(items)
            }
            Headers.prototype.values = function () {
                var items = []
                this.forEach(function (value) { items.push(value) })
                return iteratorFor(items)
            }
            Headers.prototype.entries = function () {
                var items = []
                this.forEach(function (value, name) { items.push([name, value]) })
                return iteratorFor(items)
            }
            if (support.iterable) { Headers.prototype[Symbol.iterator] = Headers.prototype.entries }
            function consumed(body) {
                if (body.bodyUsed) { return Promise.reject(new TypeError('Already read')) }
                body.bodyUsed = !0
            }
            function fileReaderReady(reader) {
                return new Promise(function (resolve, reject) {
                    reader.onload = function () { resolve(reader.result) }
                    reader.onerror = function () { reject(reader.error) }
                })
            }
            function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsArrayBuffer(blob)
                return promise
            }
            function readBlobAsText(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsText(blob)
                return promise
            }
            function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf)
                var chars = new Array(view.length)
                for (var i = 0; i < view.length; i++) { chars[i] = String.fromCharCode(view[i]) }
                return chars.join('')
            }
            function bufferClone(buf) {
                if (buf.slice) { return buf.slice(0) } else {
                    var view = new Uint8Array(buf.byteLength)
                    view.set(new Uint8Array(buf))
                    return view.buffer
                }
            }
            function Body() {
                this.bodyUsed = !1
                this._initBody = function (body) {
                    this._bodyInit = body
                    if (!body) { this._bodyText = '' } else if (typeof body === 'string') { this._bodyText = body } else if (support.blob && Blob.prototype.isPrototypeOf(body)) { this._bodyBlob = body } else if (support.formData && FormData.prototype.isPrototypeOf(body)) { this._bodyFormData = body } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this._bodyText = body.toString() } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                        this._bodyArrayBuffer = bufferClone(body.buffer)
                        this._bodyInit = new Blob([this._bodyArrayBuffer])
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) { this._bodyArrayBuffer = bufferClone(body) } else { throw new Error('unsupported BodyInit type') }
                    if (!this.headers.get('content-type')) { if (typeof body === 'string') { this.headers.set('content-type', 'text/plain;charset=UTF-8') } else if (this._bodyBlob && this._bodyBlob.type) { this.headers.set('content-type', this._bodyBlob.type) } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8') } }
                }
                if (support.blob) {
                    this.blob = function () {
                        var rejected = consumed(this)
                        if (rejected) { return rejected }
                        if (this._bodyBlob) { return Promise.resolve(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(new Blob([this._bodyArrayBuffer])) } else if (this._bodyFormData) { throw new Error('could not read FormData body as blob') } else { return Promise.resolve(new Blob([this._bodyText])) }
                    }
                    this.arrayBuffer = function () { if (this._bodyArrayBuffer) { return consumed(this) || Promise.resolve(this._bodyArrayBuffer) } else { return this.blob().then(readBlobAsArrayBuffer) } }
                }
                this.text = function () {
                    var rejected = consumed(this)
                    if (rejected) { return rejected }
                    if (this._bodyBlob) { return readBlobAsText(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer)) } else if (this._bodyFormData) { throw new Error('could not read FormData body as text') } else { return Promise.resolve(this._bodyText) }
                }
                if (support.formData) { this.formData = function () { return this.text().then(decode) } }
                this.json = function () { return this.text().then(JSON.parse) }
                return this
            }
            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
            function normalizeMethod(method) {
                var upcased = method.toUpperCase()
                return (methods.indexOf(upcased) > -1) ? upcased : method
            }
            function Request(input, options) {
                options = options || {}
                var body = options.body
                if (input instanceof Request) {
                    if (input.bodyUsed) { throw new TypeError('Already read') }
                    this.url = input.url
                    this.credentials = input.credentials
                    if (!options.headers) { this.headers = new Headers(input.headers) }
                    this.method = input.method
                    this.mode = input.mode
                    if (!body && input._bodyInit != null) {
                        body = input._bodyInit
                        input.bodyUsed = !0
                    }
                } else { this.url = String(input) }
                this.credentials = options.credentials || this.credentials || 'omit'
                if (options.headers || !this.headers) { this.headers = new Headers(options.headers) }
                this.method = normalizeMethod(options.method || this.method || 'GET')
                this.mode = options.mode || this.mode || null
                this.referrer = null
                if ((this.method === 'GET' || this.method === 'HEAD') && body) { throw new TypeError('Body not allowed for GET or HEAD requests') }
                this._initBody(body)
            }
            Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }) }
            function decode(body) {
                var form = new FormData()
                body.trim().split('&').forEach(function (bytes) {
                    if (bytes) {
                        var split = bytes.split('=')
                        var name = split.shift().replace(/\+/g, ' ')
                        var value = split.join('=').replace(/\+/g, ' ')
                        form.append(decodeURIComponent(name), decodeURIComponent(value))
                    }
                })
                return form
            }
            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }
            Body.call(Request.prototype)
            function Response(bodyInit, options) {
                if (!options) { options = {} }
                this.type = 'default'
                this.status = options.status === undefined ? 200 : options.status
                this.ok = this.status >= 200 && this.status < 300
                this.statusText = 'statusText' in options ? options.statusText : 'OK'
                this.headers = new Headers(options.headers)
                this.url = options.url || ''
                this._initBody(bodyInit)
            }
            Body.call(Response.prototype)
            Response.prototype.clone = function () { return new Response(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url }) }
            Response.error = function () {
                var response = new Response(null, { status: 0, statusText: '' })
                response.type = 'error'
                return response
            }
            var redirectStatuses = [301, 302, 303, 307, 308]
            Response.redirect = function (url, status) {
                if (redirectStatuses.indexOf(status) === -1) { throw new RangeError('Invalid status code') }
                return new Response(null, { status: status, headers: { location: url } })
            }
            self.Headers = Headers
            self.Request = Request
            self.Response = Response
            self.fetch = function (input, init) {
                return new Promise(function (resolve, reject) {
                    var request = new Request(input, init);
                    init = init || {};
                    var xhr = new XMLHttpRequest();
                    xhr.onload = function () {
                        if (xhr.status === 0) {
                            return new Response(null, { status: xhr.status });
                        } else {
                            var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') }
                            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
                            var body = 'response' in xhr ? xhr.response : xhr.responseText
                            resolve(new Response(body, options))
                        }
                    }
                    xhr.onerror = function () { reject(new TypeError('Network request failed')) }
                    xhr.ontimeout = function () { reject(new TypeError('Network request failed')) }
                    xhr.open(request.method, request.url, !init.sync)
                    if (request.credentials === 'include') { xhr.withCredentials = !0 } else if (request.credentials === 'omit') { xhr.withCredentials = !1 }
                    if (!init.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' }
                    request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) })
                    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
                })
            }
            self.fetch.polyfill = !0
        })(typeof self !== 'undefined' ? self : this);
    }

    var srcToURL = function (src) {
        // GLS: 30/01/2019 Se carga un polyfill que no implementa correctamente el origin
        //if (window.URL && !(src.indexOf('//') == 0)) {
        //    try {
        //        var url = new URL(src);
        //        if (url.origin && url.origin.length > 0) {
        //            return url;
        //        }
        //    }
        //    catch (error) {
        //        // no hacemos nada y seguimos adelante
        //    }
        //}

        var anchor = document.createElement('a');
        anchor.href = src;

        if (!anchor.origin) {

            if (!(anchor.protocol && anchor.hostname)) {
                var urlParts = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(anchor.href);

                anchor.protocol = urlParts[1];

                if (urlParts[4].indexOf(':') > -1) {
                    var hostname = urlParts[4].split(':');
                    anchor.hostname = hostname[0];
                    anchor.port = hostname[1];
                } else {
                    anchor.hostname = urlParts[4];
                }
            }

            anchor.origin = (anchor.protocol.length === 0 ? window.location.protocol : anchor.protocol) + "//" + anchor.hostname + (anchor.port && (src.indexOf(anchor.port) > -1) ? ':' + anchor.port : '');
        }

        return anchor;
    };

    function HostCacheService(objectStoreName) {
        this.database = null;
        this.objectStoreName = objectStoreName;
    }

    HostCacheService.prototype = {
        /* createDB : create the scheme of the database  */
        createDB: function () {

            // In the following line, you should include the prefixes of implementations you want to test.
            window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            // DON'T use "var indexedDB = ..." if you're not in a function.
            // Moreover, you may need references to some window.IDB* objects:
            window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
            window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
            if (!window.indexedDB) {
                window.alert("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
            }

            var request = window.indexedDB.open('HostCacheService', 1);
            var that = this;
            request.onsuccess = function (evt) {
                that.database = evt.target.result;
            };
            request.onerror = function (evt) {
                console.log("IndexedDB--> onerror ");
            };
            request.onupgradeneeded = function (evt) {
                var thisDB = evt.target.result;
                if (!thisDB.objectStoreNames.contains('HostAction')) {
                    var store = thisDB.createObjectStore('HostAction', { keyPath: 'id' });
                    store.createIndex("host", ["action"], { unique: true });
                }
            };
        },
        /* info on available storage */
        info: function () {
            // Request storage usage and capacity left
            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT
                function (used, remaining) {
                    console.log("Used quota: " + used + ", remaining quota: " + remaining);
                }, function (e) {
                    console.log('Error', e);
                });
        },
        /* isReady when objectStore has been created  */
        isReady: function () {
            if (!this.database)
                return false;

            return this.database.objectStoreNames.contains(this.objectStoreName);
        },
        getHost: function (host) {
            return new Promise(function (resolve, reject) {
                if (!this.database) {
                    console.log("getAction no database", this.database);
                    reject("no IndexedDB");
                }
                else {
                    var transaction = this.database.transaction(this.objectStoreName);
                    var hostIndex = transaction.objectStore(this.objectStoreName).index("host");

                    var requestGet = hostIndex.get([host]);
                    requestGet.onsuccess = function (evt) {
                        if (evt.target.result) {
                            resolve({ data: evt.target.result });
                        }
                        else { reject("no action"); }
                    };

                    requestGet.onerror = function (evt) {
                        reject("no action get failed");
                    };
                }
            });
        },
        addHost: function (host, action) {

            if (this.database) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                try {
                    // the transaction could abort because of a QuotaExceededError error
                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });
                    transaction.objectStore(this.objectStoreName).add({ id: guid, host: host, action: action });
                }
                catch (ex) {
                    console.log(ex);
                }

            }
            else {
                console.log("addHost no database");
            }
        },
        removeHost: function (host) {
            this.getHost(host).then(function (host) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                transaction.objectStore(this.objectStoreName).delete(host.data.id);
            });
        }
    };

    const HostCacheItem = function () {
        this.key = "";
        this.action = null;
        this.actionName = "";
    };

    const HostCache = function () {
        var toHost = function (src) {
            var url = srcToURL(src);
            if (url) {
                return url.origin;
            }

            return null;
        };

        //this.hostCacheService = new HostCacheService("HostAction");
        //this.hostCacheService.createDB();

        this._hosts = [];
        this._hostsImage = [];

        this.is = function (src, options) {
            var host = toHost(src);

            return this.get(host, options) !== null;
        };

        this.get = function (host, options) {
            if (this.getList(options).length === 0) {
                return null;
            } else {
                var filtered = this.getList(options).filter(function (h) {
                    return h.key === host && options.exportable == h.exportable;
                });
                if (filtered.length === 0) {
                    return null;
                } else {
                    return filtered[0];
                }
            }
        };

        this.getList = function (options) {
            return options.forImage ? this._hostsImage : this._hosts;
        };

        this.addKey = function (src, options) {
            var host = toHost(src);
            var newItem = { key: host, action: null };
            if (options.exportable) {
                newItem.exportable = options.exportable;
            }
            this.getList(options).push(newItem);
            return this.getList(options)[this.getList(options).length - 1];
        };

        this.removeKey = function (src, options) {
            var host = toHost(src);

            for (var i = 0; i < this.getList(options).length; i++) {
                if (this.getList(options)[i].key === host && options.exportable == this.getList(options)[i].exportable) {
                    this.getList(options).splice(i, 1);
                    break;
                }
            }
        };

        this.getAction = function (src, options) {
            options = options || {};

            var host = toHost(src);
            var cache = this.get(host, options);
            if (!cache) {
                return Promise.reject(new Error('Cache null'));
            }
            return cache._actionPromise;
        };
    };

    var toolProto = TC.tool.Proxification.prototype;

    toolProto.cacheHost = new HostCache();

    toolProto._isServiceWorker = function () {
        if (navigator.serviceWorker) {
            if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                return true;
            } else {
                navigator.serviceWorker.ready
                    .then(function (registration) {
                        if (registration.active) {
                            return true;
                        } else {
                            return false;
                        }
                    });

                return false;
            }
        } else {
            return false;
        }
    };

    toolProto._isSameOrigin = function (uri) {
        var self = this;

        var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
        var urlParts = !result && uri.match(self.Consts.url.SPLIT_REGEX);
        if (urlParts) {
            var uProtocol = urlParts[1];
            result = (uProtocol == self._location.protocol || uProtocol == undefined) && urlParts[3] == self._location.hostname;
            var uPort = urlParts[4], lPort = self._location.port;
            if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                result = result && uPort == lPort;
            }
        }
        return result;
    };

    toolProto._isSameProtocol = function (uri) {
        var protocolRegex = /^(https?:\/\/)/i;
        var uriProtocol = uri.match(protocolRegex);
        if (uriProtocol && uriProtocol.length > 1) {
            var locationProtocol = self._location.match(protocolRegex);
            if (locationProtocol && locationProtocol.length > 1) {
                return uriProtocol[0].trim() === locationProtocol[0].trim();
            }
        }

        return false;
    };

    toolProto._isSecureURL = function (url) {
        //sino empieza por http ni por https la consideramos segura
        if (!/^(f|ht)tps?:\/\//i.test(url))
            return true;
        return (/^(f|ht)tps:\/\//i.test(url));
    };

    const ResponseError = function (status, text, url) {
        this.status = status;
        this.text = text;
        this.url = url;
    };

    var changeProtocol = function (src, newProtocol) {
        var url = srcToURL(src);
        return src.replace(url.protocol, newProtocol);
    };

    var toHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    var toHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    var _currentHTTP = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTPS(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTPS);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTP(src), options, resolve, reject);
            }
        });
    };

    var _currentHTTPS = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTP(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTP);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTPS(src), options, resolve, reject);
            }
        });
    };

    var _byProxy = function (src, options, resolve, reject) {
        var self = this;

        options.sameOrigin = self._isSameOrigin(self._actionProxy.call(self, src));

        self._image.getImgTagByAction(src, options, self._actionProxy.bind(self)).then(function (img) {
            resolve(img, self._actionProxy);
        }, function (error) {
            reject(error);
        });
    };

    toolProto._actionDirect = function (src) {
        return src;
    };

    toolProto._actionHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    toolProto._actionHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    toolProto._actionProxy = function (src) {
        var self = this;

        return self.proxy(src);
    };

    toolProto._image = {
        ErrorType: {
            CORS: 'cors',
            PROTOCOL: 'protocol',
            NOTFOUNDED: 'notfounded',
            UNEXPECTED: 'unexpected'
        },
        checkHttpStatus: function (src) {
            const self = this;
            return fetch(src, { credentials: 'omit' })
                .then(function (response) {
                    return { status: response.status, statusText: response.statusText };
                })
                .catch(function (error) {
                    return self.ErrorType.UNEXPECTED;
                });
        },
        getImgTag: function (src, options) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (options.exportable && !options.sameOrigin) {
                    img.dataset.checkCORSHeaders = true;
                    img.crossOrigin = "anonymous";
                }

                img.onload = function () {

                    console.log('Load OK: ' + img.src);

                    img.onload = img.onerror = undefined;

                    if (options.exportable && !options.sameOrigin) {
                        var createCanvas = function (img) {
                            var canvas = document.createElement('CANVAS');
                            var ctx = canvas.getContext('2d');
                            canvas.height = img.height;
                            canvas.width = img.width;
                            ctx.drawImage(img, 0, 0);

                            return canvas;
                        };

                        try {
                            var canvas = createCanvas(img);
                            result = canvas.toDataURL("image/png");
                            resolve(img);
                        } catch (e) {
                            if (e.code === 18) { // GLS: 18 - SECURITY_ERR
                                reject(self.ErrorType.CORS);
                            } else {
                                resolve(img);
                            }
                        }
                    } else { resolve(img); }
                };

                img.onerror = function (error) {

                    console.log('Load crossOrigin ERROR: ' + img.src);

                    if (img.dataset.checkCORSHeaders) {
                        img.crossOrigin = null;

                        img.onerror = undefined;
                        img.onerror = function (error) {
                            console.log('Load ERROR: ' + img.src);

                            self.checkHttpStatus(img.src).then(function (error) {
                                if (options.ignoreProxification) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    if (error.status === 400) {
                                        reject(self.ErrorType.PROTOCOL);
                                    } else {
                                        reject(error);
                                    }
                                }
                            }).catch(reject);
                            img.onload = img.onerror = undefined;
                        };

                        img.src = src;

                    } else {
                        console.log('Load ERROR: ' + img.src);

                        img.onload = img.onerror = undefined;

                        self.checkHttpStatus(img.src).then(function (error) {
                            if (options.ignoreProxification) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                if (error.status === 400) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    reject(error);
                                }
                            }
                        }).catch(reject);
                    }
                };

                try {
                    img.src = src;
                } catch (ex) {
                    console.log('Load ERROR: ' + img.src);

                    reject(self.ErrorType.UNEXPECTED);
                }
            }.bind(toolProto._image));
        },
        getImgTagByAction: function (src, options, action) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (!options.sameOrigin) {
                    if (options.exportable) {
                        img.crossOrigin = "anonymous";
                    }
                }

                img.onload = function () {
                    img.onload = img.onerror = undefined;
                    resolve(img);
                };
                img.onerror = function (error) {
                    console.log('Load ERROR: ' + img.src);
                    img.onload = img.onerror = undefined;

                    self.checkHttpStatus(img.src).then(function (error) {
                        if (options.ignoreProxification) {
                            reject(self.ErrorType.PROTOCOL);
                        } else {
                            if (error.status === 400) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                reject(error);
                            }
                        }
                    }).catch(reject);
                };
                img.src = action(src);
            }.bind(toolProto._image));
        }
    };

    toolProto._fetch = {
        Headers: {
            CONTENTTYPE: "content-type"
        },
        ErrorType: {
            CORS: 'cors',
            NOTFOUNDED: 'Not_Founded',
            UNEXPECTED: 'Un_Expected',
            UNEXPECTEDCONTENTTYPE: 'Un_Expected_ContentType'
        },
        validateResponse: function (response) {
            if (!response.ok) { // status no está en el rango 200-299
                throw new ResponseError(response.status, response.statusText, response.url);
            }
            return response;
        },
        validateContentType: function (expectedContentType, response) {
            const self = this;

            if (!expectedContentType) {
                return response;
            }

            var contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);
            if (contentType && contentType.indexOf(expectedContentType) === -1) {
                throw Error(self._fetch.ErrorType.UNEXPECTEDCONTENTTYPE);
            }

            return response;
        }
    };

    /* Sólo GET */
    toolProto.fetchImage = function (src, options) {
        var self = this;

        options = options || {};
        options.forImage = true;

        return new Promise(function (resolve, reject) {

            if (self.cacheHost.is(src, options)) {
                self.cacheHost.getAction(src, options).then(function (cache) {
                    options.sameOrigin = self._isSameOrigin(cache.action(src));
                    self._image.getImgTagByAction(src, options, cache.action).then(function (img) {
                        resolve(img);
                    }, function (error) {
                        reject(error);
                    });
                });
            } else {
                var cache = self.cacheHost.addKey(src, options);
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    const _caching = function (img, action) {
                        cache.action = action.bind(self);
                        cache.exportable = options.exportable;

                        resolveActionPromise({ action: cache.action });

                        resolve(img);
                    };

                    const _reject = function (error) {
                        if (error.status == 200) {
                            //options.useCredentials = true;

                            // GLS: 04/01/2019 comento la siguiente línea porque no para de pedir al obtener una respuesta correcta y en el cuerpo viene una excepción
                            //makeRequest(options);

                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        } else {
                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        }
                    };

                    const makeRequest = function (options) {
                        if (self._isSameOrigin(src)) {
                            options.sameOrigin = true;
                            self._image.getImgTag(src, options).then(function (img) {
                                _caching(img, self._actionDirect);
                            }, _reject);
                        } else {
                            if (!self._isSecureURL(src)) {
                                if (self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                    // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                    _currentHTTP.call(self, src, options, _caching, _reject);
                                } else {
                                    // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                    self._image.getImgTag(src, options).then(function (img) {
                                        _caching(img, self._actionDirect);
                                    }, function (error) {
                                        if ((options.exportable && error === self._image.ErrorType.CORS) || !self._isSecureURL(self._location)) {
                                            // Si la imagen debe ser exportable y en la solicitud por HTTP tenemos error de CORS, deducimos que por HTTPS pasará lo mismo
                                            if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                                _reject(error);
                                            } else {
                                                _byProxy.call(self, src, options, _caching, _reject);
                                            }
                                        } else {
                                            _currentHTTP.call(self, src, options, _caching, _reject);
                                        }
                                    });

                                }
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                self._image.getImgTag(src, options).then(function (img) {
                                    _caching(img, self._actionDirect);
                                }, function (error) {
                                    if ((options.exportable && error === self._image.ErrorType.CORS) || self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                        // Si la imagen debe ser exportable y en la solicitud por HTTPS tenemos error de CORS, deducimos que por HTTP pasará lo mismo
                                        if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                            _reject(error);
                                        } else {
                                            _byProxy.call(self, src, options, _caching, _reject);
                                        }
                                    } else {
                                        _currentHTTPS.call(self, src, options, _caching, _reject);
                                    }
                                });
                            }
                        }
                    };

                    makeRequest(options);
                });
            }
        });
    };

    toolProto.fetchRetry = function (url, options, n) {
        const self = this;
        var _fetch = fetch;

        if (options.sync) {
            _fetch = self.fetchSync;
        }

        return _fetch(url, options).catch(function (error) {
            if (n === 1) throw error;
            return self.fetchRetry(url, options, n - 1);
        });
    };

    toolProto.fetchSync = function (url, options) {
        var self = this;

        return new Promise(function (resolve, reject) {

            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }

            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }

            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }


            var request = new Request(url, options);
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') };
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
            };
            xhr.onerror = function () { reject(new TypeError('Network request failed')) };
            xhr.ontimeout = function () { reject(new TypeError('Network request failed')) };
            xhr.open(request.method, request.url, false);
            if (request.credentials === 'include') { xhr.withCredentials = !options.sync } else if (request.credentials === 'omit') { xhr.withCredentials = !1 };
            if (!options.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' };
            request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) });
            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        })
    };

    toolProto.fetchXML = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "xml"; // No puedo usar la constante de la API porque está como application/xml y hay servicios que devuelven text/xml //TC.Consts.mimeType.XML;

        return self.fetch(url, options);
    };

    toolProto.fetchJSON = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = TC.Consts.mimeType.JSON;

        return self.fetch(url, options);
    };

    toolProto.fetchBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "blob";

        return self.fetch(url, options);
    };

    /* Para imágenes por POST */
    toolProto.fetchImageAsBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "image";

        return self.fetch(url, options);
    };

    /*
        type: GET|POST
        data: cuerpo del mensaje
        contentType: tipo del cuerpo del mensaje
        responseType: tipo de respuesta esperada
        retryAttempts: número de intentos por llamada
    */
    // indicar responseType en options
    toolProto.fetch = function (url, options) {
        const self = this;

        options = options || {};

        if (options.type) {
            options.method = options.type;

            delete options.type;
        }

        if (options.data) {
            options.body = options.data;

            delete options.data;
        }

        if (options.contentType) {
            options.headers = new Headers();
            options.headers.append('Content-Type', options.contentType);

            delete options.contentType;
        }

        if (!options.responseType) {
            options.responseType = '';
        }

        var _makeRequest = function (url, options, actions, cache) {
            var request;

            // fetch no incluye por defecto las cookies de autenticación, hay que indicarlo.
            //options.credentials = 'include';

            return (options.retryAttempts ? self.fetchRetry(actions[0].call(self, url), options, options.retryAttempts) : fetch(actions[0].call(self, url), options))
                .then(self._fetch.validateResponse)
                .then(self._fetch.validateContentType.bind(self, options.responseType))
                .then(function (response) {
                    if (cache) {
                        cache.action = actions[0].bind(self);
                    }

                    const contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);

                    //if (!options.responseType) {
                    //    if (contentType) {
                    //        options.responseType = contentType;
                    //    } else {
                    //        return response.text();
                    //    }
                    //}

                    const responseWithCharsetToDecodedString = function (charset) {
                        /*
                                2018 08 16
                                https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods
                                No existe método xml

                                https://developer.mozilla.org/en-US/docs/Web/API/Body/text
                                The text() method of the Body mixin takes a Response stream and reads it to completion.
                                It returns a promise that resolves with a USVString object (text).
                                The response is always decoded using UTF-8.
                            */

                        return response.blob().then(function (blob) {
                            const reader = new FileReader();

                            return new Promise(function (resolve, reject) {

                                reader.addEventListener("error", function () {
                                    reader.abort();
                                    reject(new DOMException("Problem decoding"));
                                });

                                reader.addEventListener("loadend", function () {
                                    resolve(reader.result);
                                });

                                reader.readAsText(blob, charset);
                            });
                        });
                    };

                    switch (true) {
                        case options.responseType.indexOf('xml') > -1:
                        case options.responseType.indexOf('text/xml') > -1:
                        case options.responseType.indexOf(TC.Consts.mimeType.XML) > -1:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    return (new window.DOMParser()).parseFromString(text, "text/xml");
                                });
                            } else {
                                return response.text().then(function (data) {
                                    return (new window.DOMParser()).parseFromString(data, "text/xml");
                                });
                            }
                        case options.responseType.indexOf('arraybuffer') > -1:
                            return response.arrayBuffer();
                        case options.responseType.indexOf('image') > -1:
                        case options.responseType.indexOf('blob') > -1:
                            return response.blob().then(function (blob) {
                                return new Blob([blob], { type: contentType });
                            });
                        case options.responseType.indexOf('document') > -1:
                            throw new DeveloperError('Unhandled responseType: ' + options.responseType);
                        case options.responseType.indexOf(TC.Consts.mimeType.JSON) > -1:
                            return response.json();
                        case options.responseType == '':
                        case options.responseType.indexOf('text') > -1:
                        default:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            } else {
                                return response.text().then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            }
                    }
                })
                .catch(function (error) {
                    if (actions.length === 1) {
                        console.log('request failed', error);
                        return Promise.reject(error);
                    }

                    actions.shift();
                    return _makeRequest(url, options, actions, cache);
                });
        };

        if (self.cacheHost.is(url, options)) {
            return new Promise(function (resolve, reject) {
                self.cacheHost.getAction(url, options).then(function (cache) {
                    resolve(_makeRequest(url, options, [cache.action]));
                }).catch(function (error) {
                    if (error.status > 400) {
                        reject(new Error(error.text));
                    } else {
                        resolve(self.fetch(url, options));
                    }
                });
            });            
        } else {
            var cache = self.cacheHost.addKey(url, options);
            return new Promise(function (resolve, reject) {
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    url = srcToURL(url).href;

                    const fnResolve = function (data) {
                        //self.cacheHost.hostCacheService.addHost(cache.key, cache.action);
                        resolveActionPromise({ action: cache.action });
                        resolve(data);
                    };

                    const fnReject = function (error) {
                        //self.cacheHost.hostCacheService.removeHost(cache.key);
                        self.cacheHost.removeKey(url, options);

                        rejectActionPromise(error);
                        reject(new Error(error.text));
                    };

                    if (self._isSameOrigin(url)) {
                        _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                    } else {
                        if (!self._isSecureURL(url)) {
                            if (self._isServiceWorker()) {
                                // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                _makeRequest(url, options, [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                _makeRequest(url, options, !self._isSecureURL(self._location) ? [self._actionDirect, self._actionHTTPS, self._actionProxy] : [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        } else {
                            if (self._isServiceWorker()) {
                                // HTTPS -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionHTTP, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        }
                    }
                });
                cache._actionPromise.catch(function (error) {
                    if (error.status > 400) {
                        reject(new Error(error.text));
                    } else {
                        resolve(self.fetch(url, options));
                    }
                });
            });
        }
    };
})();
var TC = TC || {};

TC.inherit = function (childCtor, parentCtor) {
    childCtor.prototype = Object.create(parentCtor.prototype);
    childCtor.prototype.constructor = childCtor;
    childCtor._super = parentCtor.prototype;
};

(function () {

    // Polyfill de CustomEvent
    /*! (c) Andrea Giammarchi - ISC */
    var self = this || /* istanbul ignore next */ {};
    self.CustomEvent = typeof CustomEvent === 'function' ?
        CustomEvent :
        (function (__p__) {
            CustomEvent[__p__] = new CustomEvent('').constructor[__p__];
            return CustomEvent;
            function CustomEvent(type, init) {
                if (!init) init = {};
                var e = document.createEvent('CustomEvent');
                e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);
                return e;
            }
        }('prototype'));

    if (!Element.prototype.matches) {
        Element.prototype.matches =
            Element.prototype.matchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.oMatchesSelector ||
            Element.prototype.webkitMatchesSelector;
    }

    const getNativeListener = function (evt, callback) {
        const result = function (evt) {
            const cbParameter = {
                type: evt.type,
                target: this,
                currentTarget: this
            };
            if (evt.detail) {
                Object.keys(evt.detail).forEach(function (key) {
                    if (!(key in cbParameter)) {
                        cbParameter[key] = evt.detail[key];
                    }
                });
            }
            return callback.call(this, cbParameter);
        }.bind(this);
        const stack = this._listeners[evt] = this._listeners[evt] || new Map();
        stack.set(callback, result);
        return result;
    };

    const onInternal = function (events, callback, options) {
        const self = this;
        events.split(' ').forEach(function (evt) {
            self.$events.addEventListener(evt, getNativeListener.call(self, evt, callback), options);
        });
        return self;
    };

    TC.EventTarget = function () {
        const self = this;
        self._listeners = {};
        self.$events = document.createDocumentFragment();

        const delegate = function (method) {
            this[method] = self.$events[method].bind(self.$events);
        };
        const methods = [
            'addEventListener',
            'dispatchEvent',
            'removeEventListener'
        ];
        methods.forEach(delegate, self);

        const fill$events = function (method) {
            self.$events[method] = self[method].bind(self);
        };
        methods.push('on');
        methods.push('one');
        methods.push('off');
        methods.push('trigger');
        methods.forEach(fill$events, self);
    };

    const etProto = TC.EventTarget.prototype;

    etProto.on = function (events, callback) {
        return onInternal.call(this, events, callback);
    };

    if (navigator.userAgent.indexOf("Trident") >= 0 || navigator.userAgent.indexOf("MSIE") >= 0) {
        // Parche para IE
        etProto.one = function (events, callback) {
            const self = this;
            const newCallback = function (e) {
                self.off(events, newCallback);
                callback.call(this, e);
            };
            self.on(events, newCallback);
            return self;
        };
    } else {
        etProto.one = function (events, callback) {
            return onInternal.call(this, events, callback, { once: true });
        };
    }

    etProto.off = function (events, callback) {
        const self = this;
        const eventList = events.split(' ');
        if (callback) {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack && stack.has(callback)) {
                    self.$events.removeEventListener(evt, stack.get(callback));
                }
            });
        }
        else {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack) {
                    stack.forEach(function (cb) {
                        self.$events.removeEventListener(evt, cb);
                    });
                    stack.clear();
                }
            });
        }
        return self;
    };

    etProto.trigger = function (type, options) {
        const self = this;
        //Compatibilidad hacia atrás
        if (window.$ && $.Event && type instanceof $.Event) {
            options = {};
            Object.keys(type).forEach(function (key) {
                if (key !== 'type') {
                    options[key] = type[key];
                }
            });
            type = type.type;
        }
        var ceOptions;
        if (options) {
            ceOptions = {
                detail: options
            };
        }
        const event = new CustomEvent(type, ceOptions);
        self.dispatchEvent(event);
    };

    TC.EventTarget._onBySelectorMap = new WeakMap();

    TC.EventTarget.listenerBySelector = function (selector, callback) {
        // Crea una estructura a partir de un mapa cuyas claves son los elementos.
        // Los valores son objetos cuyas claves son tipos de eventos
        // y cuyos valores son objetos que tienen como claves los selectores
        // y cuyos valores son las funciones de callback.
        // Se crea una función que va buscando la primera correspondencia con un selector.
        // En cuanto la encuentra, ejecuta el callback y deja de procesar.
        return function (e) {
            const element = this;
            const eventType = e.type;
            var eventTypes = TC.EventTarget._onBySelectorMap.get(element);
            if (!eventTypes) {
                eventTypes = {};
                TC.EventTarget._onBySelectorMap.set(element, eventTypes);
            }
            var selectors = eventTypes[eventType];
            if (!selectors) {
                eventTypes[eventType] = selectors = {};
            }
            if (!selectors[selector]) {
                selectors[selector] = callback;
            }
            // Para cada evento en cada elemento hay que llamar una sola vez al callback que toque.
            // Así que si se ejecuta un callback, prohibimos al resto de los listeners resolverse.
            if (!e._listenerBySelectorCalled) {
                var matches = false;
                var elm = e.target;
                var result;
                while (elm && elm !== element) {
                    for (selector in selectors) {
                        if (elm.matches && elm.matches(selector)) {
                            matches = true;
                            result = selectors[selector].call(element, e);
                            e._listenerBySelectorCalled = true;
                        }
                    }
                    if (matches) {
                        return result;
                    }
                    elm = elm.parentNode;
                }
            }
        };
    };

    /**
     * <p>Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que el constructor es asíncrono, por tanto cualquier código que haga uso de este objeto debería
     * estar dentro de una función de callback pasada como parámetro al método {{#crossLink "TC.Map/loaded:method"}}{{/crossLink}}.</p>
     * <p>Puede consultar también online el <a href="../../examples/Map.1.html">ejemplo 1</a>, el <a href="../../examples/Map.2.html">ejemplo 2</a> y el <a href="../../examples/Map.3.html">ejemplo 3</a>.</p>
     * @class TC.Map
     * @constructor
     * @async
     * @param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
     * @param {object} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global {{#crossLink "TC.Cfg"}}{{/crossLink}}.
     * @param {string} [options.crs="EPSG:25830"] Código EPSG del sistema de referencia espacial del mapa.
     * @param {array} [options.initialExtent] Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. 
     * Esta opción es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver TC.Cfg.{{#crossLink "TC.Cfg/crs:property"}}{{/crossLink}}).
     * Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/initialExtent:property"}}{{/crossLink}}.
     * @param {array} [options.maxExtent] Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima. Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/maxExtent:property"}}{{/crossLink}}.
     * @param {string} [options.layout] URL de una carpeta de maquetación. Consultar TC.Cfg.{{#crossLink "TC.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones.
     * @param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. 
     * @param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. 
     * @param {TC.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.
     * @param {TC.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geográficas.
     * @param {string} [options.locale="es-ES"] Código de idioma de la interfaz de usuario. Este código debe ser obedecer la sintaxis definida por la <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF</a>.
     * Los valores posibles son <code>es-ES</code>, <code>eu-ES</code> y <code>en-US</code>.
     * @param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver TC.Cfg.{{#crossLink "TC.Cfg/proxy:property"}}{{/crossLink}}).
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa con las opciones por defecto.
     *         var map = new TC.Map("mapa");
     *     </script>
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
     *         var map = new TC.Map("mapa", {
     *             crs: "EPSG:4326",
     *             initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             maxExtent: [
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             baseLayers: [
     * 				TC.Consts.layer.IDENA_DYNBASEMAP
     *             ]
     *         });
     *     </script>
     * @example
     *     <div id="mapa"></div>
     *     <script>
     *         // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
     *         var map = new TC.Map("mapa", {
     *             workLayers: [
     *                 {
     *                     id: "topo_mallas",
     *                     title: "Toponimia y mallas cartográficas",
     *                     type: TC.Consts.layerType.WMS,
     *                     url: "//idena.navarra.es/ogc/wms",
     *                     layerNames: "IDENA:toponimia,IDENA:mallas"
     *                 }
     *             ]
     *         });
     *     </script>
     */

    var currentState = null;
    var previousState = null;
    const _setupStateControl = function () {
        const self = this;

        var MIN_TIMEOUT_VALUE = 4;

        // eventos a los que estamos suscritos para obtener el estado            
        var events = [
            TC.Consts.event.LAYERADD,
            TC.Consts.event.LAYERORDER,
            TC.Consts.event.LAYERREMOVE,
            //TC.Consts.event.LAYEROPACITY, // Este evento lo vamos a tratar por separado, para evitar exceso de actualizaciones de estado.
            TC.Consts.event.LAYERVISIBILITY,
            TC.Consts.event.ZOOM,
            TC.Consts.event.BASELAYERCHANGE].join(' ');

        // gestión siguiente - anterior

        // registramos el estado inicial                
        self.replaceCurrent = true;
        _addToHistory.call(self);

        const fn_addToHistory = _addToHistory.bind(self);

        // nos suscribimos a los eventos para registrar el estado en cada uno de ellos
        self.on(events, fn_addToHistory);

        // a la gestión del evento de opacidad le metemos un retardo, para evitar que haya un exceso de actualizaciones de estado.
        var layerOpacityHandlerTimeout;
        self.on(TC.Consts.event.LAYEROPACITY, function (e) {
            clearTimeout(layerOpacityHandlerTimeout);
            layerOpacityHandlerTimeout = setTimeout(function () {
                _addToHistory.call(self, e);
            }, 500);
        });

        // gestión siguiente - anterior
        window.addEventListener('popstate', function (e) {
            var wait;
            wait = self.loadingCtrl && self.loadingCtrl.addWait();
            setTimeout(function () {
                if (e) {
                    // eliminamos la suscripción para no registrar el cambio de estado que vamos a provocar
                    self.off(events, fn_addToHistory);

                    var state = e.state;
                    if (Object.prototype.toString.call(state) === '[object Object]') {
                        state = self.checkLocation();
                    }

                    // gestionamos la actualización para volver a suscribirnos a los eventos del mapa                        
                    _loadIntoMap.call(self, state).then(function () {
                        setTimeout(function () {
                            self.on(events, fn_addToHistory);
                        }, 200);
                        self.loadingCtrl && self.loadingCtrl.removeWait(wait);
                    });
                }
            }, MIN_TIMEOUT_VALUE);
        });
    };
    const _addToHistory = function (e) {
        const self = this;

        var state = _getMapState.call(self);
        if (self.replaceCurrent) {
            window.history.replaceState(state, null, null);
            delete self.replaceCurrent;

            return;
        } else {

            /*if (self.registerState != undefined && !self.registerState) {
                self.registerState = true;
                return;
            }*/
            self.lastEventType = e.type;

            var saveState = function () {
                previousState = currentState;
                currentState = TC.Util.utf8ToBase64(state);
                if (currentState !== previousState) {
                    window.history.pushState(state, null, window.location.href.split('#').shift() + '#' + currentState);
                }
            };

            if (e) {
                switch (true) {
                    case (e.type == TC.Consts.event.BASELAYERCHANGE):
                    case (e.type == TC.Consts.event.LAYERORDER):
                    case (e.type == TC.Consts.event.ZOOM):
                        saveState();
                        break;
                    case (e.type.toLowerCase().indexOf("LAYER".toLowerCase()) > -1):
                        // unicamente modifico el hash si la capa es WMS
                        if (e.layer.type == TC.Consts.layerType.WMS)
                            saveState();
                        break;
                }
            }
        }
    };
    const _getMapState = function (extraStates) {
        const self = this;

        var state = {};

        if (self.crs !== self.options.crs) {
            state.crs = self.crs;
        }

        var ext = self.getExtent();
        for (var i = 0; i < ext.length; i++) {
            if (Math.abs(ext[i]) > 180)
                ext[i] = Math.floor(ext[i] * 1000) / 1000;
        }
        state.ext = ext;

        //determinar capa base
        var baseLayerData = [];

        // ¿es una capa de respaldo?
        if (self.baseLayers) {
            baseLayerData = self.baseLayers.filter(function (baseLayer) {
                return baseLayer.isRaster() && baseLayer.fallbackLayer;
            }).map(function (baseLayer) {
                return {
                    baseLayer: baseLayer, fallbackLayerID: baseLayer.fallbackLayer.id
                };
            }).filter(function (baseLayerData) {
                return baseLayerData.fallbackLayerID === (self.baseLayer ? self.baseLayer.id : self.baseLayers[0].id);
            });
        }

        if (baseLayerData.length > 0) {
            state.base = baseLayerData[0].baseLayer.id;
        } else {
            state.base = (self.baseLayer || self.baseLayers[0]).id;
        }

        //capas cargadas
        state.layers = [];

        var layer, entry;
        for (var i = 0; i < self.workLayers.length; i++) {
            layer = self.workLayers[i];
            if (layer.type == "WMS" && !layer.options.stateless) {
                if (layer.layerNames && layer.layerNames.length) {
                    entry = {
                        u: TC.Util.isOnCapabilities(layer.url),
                        n: Array.isArray(layer.names) ? layer.names.join(',') : layer.names,
                        o: layer.getOpacity(),
                        v: layer.getVisibility(),
                        h: layer.options.hideTitle,
                        ur: layer.unremovable,
                        t: layer.title,
                    };

                    state.layers.push(entry);
                }
            }
        }

        if (self.on3DView && self.view3D.cameraControls) {
            state.vw3 = self.view3D.cameraControls.getCameraState();
        }

        if (!window.jsonpack) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSONPACK);
        }

        if (extraStates) {
            TC.Util.extend(state, extraStates);
        }

        return jsonpack.pack(state);
    };
    const _clearMap = function () {
        const self = this;

        self.workLayers.filter(function (layer) {
            return !(layer instanceof (TC.layer.Vector));
        }).forEach(function (layer) {
            if (layer.unremovable) {
                layer.unremovable = false;
            }
            self.removeLayer(layer);
        });
    };
    const _loadIntoMap = function (stringOrJson) {
        const self = this;
        const promises = [];

        if (!stringOrJson) {
            return Promise.resolve();
        }

        if (!self.loadingctrl) {
            self.loadingCtrl = self.getControlsByClass("TC.control.LoadingIndicator")[0];
        }

        if (!self.hasWait) {
            self.hasWait = self.loadingCtrl && self.loadingCtrl.addWait();
        }

        // GLS lo añado para poder gestionar el final de la actualización de estado y volver a suscribirme a los eventos del mapa
        return new Promise(function (resolve, reject) {
            var resolved = function () {
                self.loadingCtrl && self.loadingCtrl.removeWait(self.hasWait);
                delete self.hasWait;
                resolve();
            };

            var obj;
            if (typeof (stringOrJson) == "string") {
                try {
                    obj = jsonpack.unpack(stringOrJson);
                }
                catch (error) {
                    try {
                        obj = JSON.parse(stringOrJson);
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'));
                    }
                }
            } else {
                obj = stringOrJson;
            }

            if (obj) {
                // CRS
                if ((obj.crs && obj.crs !== self.crs) || (typeof obj.crs === 'undefined' && self.crs !== self.options.crs)) {
                    promises.push(self.setProjection({
                        crs: obj.crs || self.options.crs,
                        oldCrs: self.crs,
                        extent: obj.ext,
                        baseLayer: self.getLayer(obj.base)
                    }));
                }
                else {
                    //capa base
                    if (obj.base != self.getBaseLayer().id) {
                        if (self.getLayer(obj.base)) {
                            self.setBaseLayer(obj.base);
                        }
                        const firstOption = self.baseLayers.filter(function (baseLayer) {
                            return baseLayer.options.fallbackLayer === obj.base;
                        })[0];
                        if (firstOption) {
                            const fbPromise = self.addLayer(firstOption.getFallbackLayer());
                            promises.push(fbPromise);
                            fbPromise.then(function (newLayer) {
                                self.setBaseLayer(newLayer);
                            });
                        }
                    }

                    //extent
                    if (obj.ext) {
                        promises.push(self.setExtent(obj.ext, { animate: false }));
                    }
                }

                //capas cargadas        
                //borrar primero
                _clearMap.call(self);

                obj.layers = obj.layers || obj.capas || [];

                if (obj.layers.length > 0) {

                    for (var i = 0; i < obj.layers.length; i++) {
                        var capa = obj.layers[i];

                        var layerInConfig = false;

                        for (j = 0; j < self.options.workLayers.length; j++) {
                            var lyrCfg = TC.Util.extend({}, self.options.workLayers[j], { map: self });

                            if (capa.u === lyrCfg.url && lyrCfg.layerNames.indexOf(capa.n) >= 0) {
                                layerInConfig = true;
                                lyrCfg.renderOptions = { "opacity": capa.o, "hide": !capa.v };
                                lyrCfg.unremovable = capa.ur;
                                lyrCfg.title = capa.t;
                                promises.push(self.addLayer(lyrCfg).then(function (layer) {
                                    layer.setVisibility(this.v);
                                    layer.setOpacity(this.o, true);
                                }.bind(capa)));
                            }
                        }

                        if (!layerInConfig) {
                            promises.push(self.addLayer({
                                id: TC.getUID(),
                                url: TC.Util.isOnCapabilities(capa.u, capa.u.indexOf(window.location.protocol) < 0) || capa.u,
                                hideTitle: capa.h,
                                layerNames: capa.n ? capa.n.split(',') : "",
                                unremovable: capa.ur,
                                title: capa.t,
                                renderOptions: {
                                    opacity: capa.o,
                                    hide: !capa.v
                                }
                            }).then(function (layer) {
                                var rootNode = layer.wrap.getRootLayerNode();
                                layer.title = rootNode.Title || rootNode.title;
                                /*URI:el setOpacity recibe un nuevo parametro. Que indica si se no se va a lanzar evento LAYEROPACITY
                                esto es porque en el loadstate al establecer la opacidad dedido a un timeout pasados X segundos se lanzaba 
                                este evento y producía un push en el state innecesario*/
                                layer.setOpacity(this.o, true);
                                layer.setVisibility(this.v);
                            }.bind(capa)));
                        }
                    }
                }

                Promise.all(promises)
                    .then(function () {
                        resolved();
                    })
                    .catch(function () {
                        resolved();
                    });
            }
            else {
                resolved();
            }
        });
    };

    const getReduceByValueFunction = function (prop, value) {
        return function (prev, cur, idx) {
            return cur[prop] === value ? idx : prev;
        };
    };

    const getReduceByZIndexFunction = function (zIndex) {
        return function (prev, cur, idx) {
            return cur.zIndex <= zIndex ? idx : prev;
        };
    };

    const getAvailableBaseLayer = function (id) {
        const ablCollection = this instanceof TC.Map ? this.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
        return ablCollection.filter(function (abl) {
            return abl.id === id;
        })[0];
    };

    TC.Map = TC.Map || function (div, options) {
        ///<summary>
        ///Constructor
        ///</summary>
        ///<param name="div" type="HTMLElement|string">Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.</param>
        ///<param name="options" type="object" optional="true">Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global TC.Cfg.</param>
        ///<returns type="TC.Map"></returns>
        ///<field name='isReady' type='boolean'>Indica si todos los controles del mapa están cargados.</field>
        ///<field name='isLoaded' type='boolean' default='false'>Indica si todos los controles y todas las capas del mapa están cargados.</field>
        ///<field name='activeControl' type='TC.Control'>Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.</field>
        ///<field name='layers' type='array' elementType='TC.Layer'>Lista de todas las capas base cargadas en el mapa.</field>
        ///<field name='controls' type='array' elementType='TC.Control'>Lista de todos los controles del mapa.</field>
        const self = this;
        TC.EventTarget.call(self);
        TC.Map._instances.push(self);

        //TC.Object.apply(self, arguments);

        /**
         * Indica si todos los controles del mapa están cargados.
         * @property isReady
         * @type boolean
         * @default false
         */
        self.isReady = false;

        /**
         * Indica si todos los controles y todas las capas del mapa están cargados.
         * @property isLoaded
         * @type boolean
         * @default false
         */
        self.isLoaded = false;

        /**
         * Lista de todos los controles del mapa.
         * @property controls
         * @type array
         * @default []
         */
        self.controls = [];

        /**
         * Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.
         * @property activeControl
         * @type TC.Control
         * @default null
         */
        self.activeControl = null;

        /**
         * Lista de todas las capas cargadas en el mapa.
         * @property layers
         * @type array
         * @default []
         */
        self.layers = [];

        /**
         * Lista de todas las capas base cargadas en el mapa.
         * @property baseLayers
         * @type array
         * @default []
         */
        self.baseLayers = [];

        /**
         * Lista de todas las capas de trabajo cargadas en el mapa.
         * @property workLayers
         * @type array
         * @default []
         */
        self.workLayers = [];

        /**
         * Capa base actual del mapa.
         * @property baseLayer
         * @type TC.Layer
         */
        self.baseLayer = null;

        /**
         * Capa donde se dibujan las entidades geográficas si no se especifica la capa explícitamente. Se instancia en el momento de añadir la primera entidad.
         * @property vectors
         * @type TC.layer.Vector
         * @default null
         */
        self.vectors = null;

        var loadingLayerCount = 0;
        /**
         * Elemento del DOM donde se ha creado el mapa.
         * @property div
         * @type HTMLElement
         */
        self.div = TC.Util.getDiv(div);
        if (TC._jQueryIsLoaded) {
            self._$div = $(self.div);
        }
        /**
         * El mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event MAPLOAD
         */
        /**
         * El mapa ha cargado todos sus controles, pero no hay garantía de que estén cargadas las capas
         * @event MAPREADY
         */
        /**
         * Se va a añadir una capa al mapa.
         * @event BEFORELAYERADD
         * @param {TC.Layer} layer Capa que se va a añadir.
         */
        /**
         * Se ha añadido una capa al mapa.
         * @event LAYERADD
         * @param {TC.Layer} layer Capa que se ha añadido.
         */
        /**
         * Se ha eliminado una capa del mapa.
         * @event LAYERREMOVE
         * @param {TC.Layer} layer Capa que se ha eliminado.
         */
        /**
         * Se ha cambiado de posición una capa en la lista de capas del mapa.
         * @event LAYERORDER
         * @param {TC.Layer} layer Capa que se ha eliminado.
         * @param {number} oldIndex Índice de la posición antes del cambio.
         * @param {number} newIndex Índice de la posición después del cambio.
         */
        /**
         * Se va a actualizar una capa del mapa: se van a modificar sus entidades o se va solicitar una nueva imagen.
         * @event BEFORELAYERUPDATE
         * @param {TC.Layer} layer Capa que va a actualizarse.
         */
        /**
         * Se ha actualizado una capa del mapa: se ha modificado sus entidades o se ha cargado una imagen nueva.
         * @event LAYERUPDATE
         * @param {TC.Layer} layer Capa que se ha actualizado.
         */
        /**
         * Ha habido un error al cargar la capa, bien porque no se ha podido obtener su capabilities o porque no soporta CRS compatibles.
         * @event LAYERERROR
         * @param {TC.Layer} layer Capa que sufre el error.
         */
        /**
         * Se ha establecido una nueva capa como mapa base.
         * @event BASELAYERCHANGE
         * @param {TC.Layer} layer Capa que es el nuevo mapa base.
         */
        /**
         * Se va a actualizar alguna capa del mapa.
         * @event BEFOREUPDATE
         */

        self.div.classList.add(TC.Consts.classes.LOADING, TC.Consts.classes.MAP);

        // Para gestionar zoomToMarkers
        self._markerPromises = [];

        self._layerBuffer = {
            layers: [],
            contains: function (id) {
                return this.layers.some(function (l) {
                    return l.id === id;
                });
            },
            getIndex: function (id) {
                return this.layers.reduce(getReduceByValueFunction('id', id), -1);
            },
            add: function (id, zIndex, isBase) {
                var idx;
                const obj = {
                    id: id,
                    pending: true,
                    zIndex: zIndex,
                    isBase: isBase
                };
                this.layers.splice(this.getIndexForZIndex(zIndex), 0, obj);
            },
            remove: function (id) {
                this.layers.splice(this.getIndex(id), 1);
            },
            getMapLayers: function () {
                return this.layers
                    .filter(l => l.pending === false)
                    .filter(l => !l.rejected)
                    .map(l => l.mapLayer);
            },
            resolve: function (map, layer, isBase) {
                const layerObj = this.layers[this.getIndex(layer.id)];
                layerObj.mapLayer = layer;
                layerObj.pending = false;
                map.layers = this.getMapLayers();
                if (isBase) {
                    if (map.baseLayers.length === 0) {
                        map.baseLayers = new Array(map.options.baseLayers.length);
                    }

                    var index = map.options.baseLayers.map(function (l) { return l.id }).indexOf(layer.id);
                    if (index < 0) {
                        var index = map.baseLayers.map(function (l) { return l.type }).indexOf(TC.Consts.layerType.VECTOR);
                        if (index < 0) {
                            map.baseLayers.push(layer);
                        } else {
                            map.baseLayers.splice(index, 0, layer);
                        }
                    } else {
                        map.baseLayers.splice(index, 1, layer);
                    }
                }
                else {
                    map.workLayers = map.layers.filter(function (l) {
                        return !l.isBase;
                    });
                }
            },
            reject: function (map, error) {
                const layerObj = this.layers[this.getIndex(error.layerId)];
                layerObj.mapLayer = null;
                layerObj.pending = false;
                layerObj.rejected = true;
                var index = map.options.baseLayers.map(l => l.id).indexOf(error.layerId);
                if (index >= 0) {
                    map.baseLayers.splice(index, 1);
                }
            },
            getResolvedWorkLayerIndex: function (map, id) {
                return this.layers.filter(function (l) {
                    return l.id === id || (!l.isBase && l.pending === false);
                }).reduce(getReduceByValueFunction('id', id), -1);
            },
            getResolvedVisibleLayerIndex: function (map, id) {
                var index = this.getResolvedWorkLayerIndex(map, id);
                if (map.baseLayer) {
                    index = index + 1;
                }
                return index;
            },
            getIndexForZIndex: function (zIndex) {
                return this.layers.reduce(getReduceByZIndexFunction(zIndex), -1) + 1;
            },
            checkMapLoad: function (map) {
                const self = this;
                if (map.options.baseLayers
                    .concat(map.options.workLayers)
                    .every(function (l) {
                        return self.contains(l.id || l);
                    }) && // Si ya se han empezado a procesar todas las capas de las opciones
                    !this.layers.some(function (layer) {
                        return layer.pending === true; // Si ya se han terminado de procesar
                    })) {
                    const throwMapLoad = function () {
                        if (!map.isLoaded) {
                            const setLoaded = function () {

                                // 07/03/2019 GLS: Bug 24832 la gestión del estado comienza después de TC.Consts.event.MAPLOAD, 
                                // como los callbacks a loaded se lanzan según el orden de suscripción, el de script.js de IDENA se lanza antes 
                                // que el de la gestión del estado, lo que provoca que las capas añadidas por queryString no se registren.
                                if (map.options.stateful) {
                                    _setupStateControl.call(map);
                                }

                                map.isLoaded = true;
                                map.div.classList.remove(TC.Consts.classes.LOADING);
                                map.trigger(TC.Consts.event.MAPLOAD);
                            };
                            // tenemos estado 3d
                            if (map.state && map.state.vw3) {
                                if (!map.div.classList.contains(TC.Consts.classes.THREED)) {
                                    map.div.classList.add(TC.Consts.classes.THREED);

                                    TC.loadJS(
                                        !TC.view || !TC.view.ThreeD,
                                        TC.apiLocation + 'TC/view/ThreeD',
                                        function () {
                                            TC.view.ThreeD.apply({
                                                map: map, state: map.state.vw3, callback: function () {
                                                    setLoaded();

                                                    map.getControlsByClass(TC.control.ThreeD)[0].button.removeAttribute("disabled");
                                                }
                                            });
                                        }
                                    );
                                }
                            } else {
                                setLoaded();
                            }
                        }
                    };
                    // Gestionamos el final de la carga del mapa
                    if (map.baseLayer) {
                        throwMapLoad();
                    }
                    else {
                        //GLS: Si no hay mapa de fondo cargado es posible que se haya añadido desde diálogo modal, lo comprobamos en todos los mapas de fondo disponibles del API
                        var onAvailables = [];
                        if (map.state && map.state.base) {
                            onAvailables = TC.Cfg.availableBaseLayers.filter(function (l) { return l.id === map.state.base });
                        }

                        if (onAvailables.length > 0) {
                            onAvailables[0].isBase = true;
                            map.addLayer(onAvailables[0]).then(function (layer) {
                                throwMapLoad();
                            });
                        }
                        else {
                            // Si no hay capa base cargada cargamos la primera compatible
                            const lastResortBaseLayer = map.baseLayers.filter(function (layer) {
                                return !layer.mustReproject;
                            }).filter(function (l) {
                                return l.wrap && l.wrap.layer;
                            });

                            if (lastResortBaseLayer.length > 0) {
                                map.wrap.setBaseLayer(lastResortBaseLayer[0].wrap.layer);
                                map.baseLayer = lastResortBaseLayer[0];
                            }

                            throwMapLoad();
                        }
                    }
                }
            }
        };

        self._layerBuffer.layers = [];

        if (!TC.ready) {
            TC.Cfg = TC.Util.extend({}, TC.Defaults, TC.Cfg);
            TC.ready = true;
        }

        // GLS: mergeOptions es inclusivo, para poder sobrescribir los tipos de búsqueda, añado con valor a false las que el usuario no haya configurado.
        if (options && options.controls && options.controls.search && options.controls.search.allowedSearchTypes) {
            for (var allowed in TC.Cfg.controls.search.allowedSearchTypes) {
                if (!options.controls.search.allowedSearchTypes.hasOwnProperty(allowed)) {
                    options.controls.search.allowedSearchTypes[allowed] = false;
                }
            }
        }

        // Añado las capas disponibles a la configuración general

        /**
         * Objeto de opciones del constructor.
         * @property options
         * @type object
         */
        options = options || {};
        mergeOptions.call(self, options);

        var init = function () {

            TC.loadJS(
                self.options.stateful && !window.jsonpack,
                [TC.apiLocation + TC.Consts.url.JSONPACK],
                function () {
                    if (self.options.stateful) {
                        self.state = self.checkLocation();
                    }

                    if (self.options.layout) {
                        self.trigger(TC.Consts.event.LAYOUTLOAD, { map: self });
                    }

                    if (options && options.workLayers !== undefined) {
                        self.options.workLayers = options.workLayers;
                    }
                    if (options && options.baseLayers !== undefined) {
                        self.options.baseLayers = options.baseLayers;
                    }

                    if (self.options.zoomToFeatures) {
                        // zoom a features solo cuando se cargue el mapa
                        var handleFeaturesAdd = function handleFeaturesAdd(e) {
                            clearTimeout(self._zoomToFeaturesTimeout);

                            self._zoomToFeaturesTimeout = setTimeout(function () {
                                self.zoomToFeatures(e.layer.features, { animate: false });
                                self.off(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                            }, 100);
                        };
                        self.on(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                    }
                    var _handleLayerAdd = function _handleLayerAdd(e) {
                        if (e.layer.isBase && (e.layer === self.baseLayer || (self.baseLayer && e.layer.fallbackLayer && e.layer.fallbackLayer.id === self.baseLayer.id))) {
                            if (typeof self.state !== "undefined") {
                                if (self.state.crs) {
                                    self.loaded(function () {
                                        self.setProjection({
                                            crs: self.state.crs,
                                            extent: self.state.ext
                                        });
                                    });
                                }
                                else {
                                    self.setExtent(self.state.ext, { animate: false });
                                }
                            }
                            self.off(TC.Consts.event.LAYERADD, _handleLayerAdd);
                        }
                    };
                    self.on(TC.Consts.event.LAYERADD, _handleLayerAdd);

                    if (self.options.elevation) {
                        TC.loadJS(
                            !TC.tool || !TC.tool.Elevation,
                            TC.apiLocation + 'TC/tool/Elevation',
                            function () {
                                const elevationOptions = typeof self.options.elevation === 'boolean' ? {} : self.options.elevation;
                                self.elevation = new TC.tool.Elevation(elevationOptions);
                            }
                        );
                    }


                    /**
                     * Well-known ID (WKID) del CRS del mapa.
                     * @property crs
                     * @type string
                     */
                    self.crs = self.options.crs;
                    self.initialExtent = self.options.initialExtent;
                    self.maxExtent = self.options.maxExtent;

                    self.wrap = new TC.wrap.Map(self);

                    TC.loadJS(
                        !window[TC.Consts.PROJ4JSOBJ],
                        [
                            TC.url.proj4js
                        ],
                        function () {
                            TC.loadJSInOrder(
                                !window[TC.Consts.OLNS],
                                [
                                    TC.url.ol,
                                    TC.url.olConnector
                                ],
                                function () {
                                    TC.loadProjDef({
                                        crs: self.options.crs,
                                        callback: function () {
                                            self.wrap.setMap();
                                            const ctlPromises = [];
                                            for (var name in self.options.controls) {
                                                var ctlOptions = self.options.controls[name];
                                                if (ctlOptions) {
                                                    ctlOptions = typeof ctlOptions === 'boolean' ? {} : TC.Util.extend(true, {}, ctlOptions);
                                                    if (typeof ctlOptions.div === 'string') {
                                                        ctlOptions.div = self.div.querySelector('#' + ctlOptions.div) || ctlOptions.div;
                                                    }
                                                    ctlPromises.push(self.addControl(name, ctlOptions));
                                                }
                                            }

                                            self.on(TC.Consts.event.BEFORELAYERUPDATE, _triggerLayersBeforeUpdateEvent);
                                            self.on(TC.Consts.event.LAYERUPDATE, _triggerLayersUpdateEvent);

                                            var i;
                                            var j;
                                            var lyrCfg;
                                            for (i = 0; i < self.options.baseLayers.length; i++) {
                                                lyrCfg = self.options.baseLayers[i];
                                                if (typeof lyrCfg === 'string') {
                                                    lyrCfg = getAvailableBaseLayer.call(self, lyrCfg);
                                                }
                                                self.addLayer(TC.Util.extend({}, lyrCfg, { isBase: true, map: self }));
                                            }

                                            var setVisibility = function (layer) {
                                                if (layer.isRaster() && !layer.names) {
                                                    layer.setVisibility(false);
                                                }
                                            };
                                            const workLayersNotInState = self.options.workLayers
                                                .map(function (workLayer) {
                                                    return TC.Util.extend({}, workLayer, { map: self });
                                                })
                                                .filter(function (workLayer) {
                                                    if (!self.state || !self.state.layers) {
                                                        return true;
                                                    }
                                                    return !self.state.layers.some(function (stateLayer) {
                                                        const result = stateLayer.u === workLayer.url && workLayer.layerNames.indexOf(stateLayer.n) >= 0;
                                                        if (result) {
                                                            stateLayer.id = workLayer.id; // Hemos identificado la capa, le damos el id que le corresponde
                                                        }
                                                        return result;
                                                    });
                                                });
                                            workLayersNotInState.forEach(function (workLayer) {
                                                self.addLayer(workLayer).then(setVisibility);
                                            });

                                            if (self.state && self.state.layers) {

                                                self.state.layers.forEach(function (stateLayer) {

                                                    // añado como promesa cada una de las capas que se añaden
                                                    self.addLayer({
                                                        id: stateLayer.id || TC.getUID(),
                                                        url: TC.Util.isOnCapabilities(stateLayer.u, stateLayer.u.indexOf(window.location.protocol) < 0) || stateLayer.u,
                                                        hideTitle: stateLayer.h,
                                                        layerNames: stateLayer.n ? stateLayer.n.split(',') : "",
                                                        unremovable: stateLayer.ur,
                                                        title: stateLayer.t,
                                                        renderOptions: {
                                                            opacity: stateLayer.o,
                                                            hide: !stateLayer.v
                                                        }
                                                    }).then(function (layer) {
                                                        var rootNode = layer.wrap.getRootLayerNode();
                                                        layer.title = stateLayer.t || rootNode.Title || rootNode.title;
                                                        if (this.o < 1) {
                                                            layer.setOpacity(this.o);
                                                        }
                                                        if (!this.v) {
                                                            layer.setVisibility(this.v);
                                                        }
                                                    }.bind(stateLayer));
                                                });
                                            }
                                            Promise.all(ctlPromises).finally(function () {
                                                self.isReady = true;
                                                self.trigger(TC.Consts.event.MAPREADY);
                                            })
                                            setHeightFix(self.div);
                                        }
                                    });
                                }
                            );
                        }
                    );

                    self.on(TC.Consts.event.FEATURECLICK, function (e) {
                        if (!self.activeControl || !self.activeControl.isExclusive()) {
                            if (self.on3DView) {
                                e.feature.showResultsPanel();
                            } else {
                                e.feature.showPopup();
                            }
                        }
                    });

                    self.on(TC.Consts.event.NOFEATURECLICK, function (e) {
                        e.layer._noFeatureClicked = true;
                        var allLayersClicked = true;
                        for (var i = 0, len = self.workLayers.length; i < len; i++) {
                            if (!self.workLayers[i]._noFeatureClicked) {
                                allLayersClicked = false;
                                break;
                            }
                        }
                        if (allLayersClicked) {
                            self.workLayers.forEach(function (wl) {
                                delete wl._noFeatureClicked;
                            });
                            self.getControlsByClass(TC.control.Popup).forEach(function (p) {
                                if (p.isVisible()) {
                                    p.hide();
                                }
                            });
                        }
                    });
                }
            );
        };

        mapProto.getMapState = function (extraStates) {
            const self = this;

            var state = _getMapState.call(self, extraStates);
            return TC.Util.utf8ToBase64(state);
        };

        mapProto.getPreviousMapState = function () {
            return previousState;
        };

        mapProto.checkLocation = function () {
            var hash = window.location.hash;

            if (hash && hash.length > 1) {
                hash = hash.substr(1);

                var obj;
                try {
                    obj = jsonpack.unpack(TC.Util.base64ToUtf8(hash));
                }
                catch (error) {
                    try {
                        obj = JSON.parse(TC.Util.base64ToUtf8(hash));
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                        return;
                    }
                }

                if (TC.Util.detectIE() && window.location.href.length === 2047) {
                    TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValidForEdge'), TC.Consts.msgErrorMode.TOAST);
                }

                if (obj) {
                    var inValidState = false;
                    //chequeo la integriadad del objeto restaurado del State
                    if (!obj.hasOwnProperty("ext")) {
                        inValidState = true;
                        obj.ext = self.options.initialExtent;
                    }
                    if (!obj.hasOwnProperty("base")) {
                        inValidState = true;
                        obj.base = self.options.defaultBaseLayer;
                    }
                    if (!obj.hasOwnProperty("layers")) {
                        inValidState = true;
                        obj.layers = [];
                    }
                    else {
                        for (var i = obj.layers.length - 1; i >= 0; i--) {
                            if (!obj.layers[i] || !obj.layers[i].hasOwnProperty("u") || !obj.layers[i].hasOwnProperty("n")) {
                                inValidState = true;
                                obj.layers.length = obj.layers.length - 1;
                                continue;
                            }
                            else if (!obj.layers[i].hasOwnProperty("o") || !obj.layers[i].hasOwnProperty("v") || !obj.layers[i].hasOwnProperty("h")) {
                                inValidState = true
                                TC.Util.extend(obj.layers[i], {
                                    o: (obj.layers[i].o || 1),
                                    v: (obj.layers[i].v || true),
                                    h: (obj.layers[i].h || false)
                                });
                            }
                        }
                    }

                    if (obj.hasOwnProperty("vw3")) {

                        if (!obj.vw3) {
                            inValidState = true;
                        } else if (!obj.vw3.cp || (obj.vw3.cp && obj.vw3.cp.length != 3) ||
                            !obj.vw3.chpr || (obj.vw3.chpr && obj.vw3.chpr.length != 3) ||
                            !obj.vw3.bcpd) {
                            inValidState = true;
                        }
                    }

                    if (inValidState)
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                    return obj;
                }
                TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            return;
        };

        var _checkIntegrity = function () {
        };

        /*
        *  _triggerLayersBeforeUpdateEvent: Triggers map beforeupdate event (jQuery.Event) when any layer starts loading
        *  Parameters: OpenLayers.Layer, event name ('loadstart', 'loadend')
        */
        var _triggerLayersBeforeUpdateEvent = function (e) {
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.BEFOREUPDATE);
            }
            loadingLayerCount = loadingLayerCount + 1;
        };

        var _triggerLayersUpdateEvent = function (e) {
            loadingLayerCount = loadingLayerCount - 1;
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.UPDATE);
            }
        };

        TC.i18n = TC.i18n || {};
        // i18n: carga de recursos si no está cargados previamente
        TC.i18n.loadResources = TC.i18n.loadResources || function (condition, path, locale) {
            var result;
            if (condition) {
                result = new Promise(function (resolve, reject) {
                    TC.ajax({
                        url: path + locale + '.json',
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    })
                        .then(function (response) {
                            const data = response.data;
                            TC.i18n[locale] = TC.i18n[locale] || {};
                            TC.Util.extend(TC.i18n[locale], data);
                            //TC.i18n.currentLocale = TC.i18n[locale];
                            if (typeof (dust) !== 'undefined') {
                                TC.loadJS(
                                    !window.dust.i18n,
                                    TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                                    function () {
                                        dust.i18n.add(locale, TC.i18n[locale]);
                                        resolve();
                                    });
                            }
                        })
                        .catch(function (err) {
                            reject(err);
                        });
                });
            } else {
                dust.i18n.add(locale, TC.i18n[locale]);
                //TC.i18n.currentLocale = TC.i18n[locale];
                result = Promise.resolve();
            }
            return result;
        };

        var i18nPromises = [];
        var locale = self.options.locale;
        i18nPromises.push(new Promise(function (resolve, reject) {
            TC.loadJSInOrder(
                !window.dust || !window.dust.i18n,
                TC.url.templating,
                function () {
                    if (locale) {
                        dust.i18n.setLanguages([locale]);

                        i18nPromises.push(TC.i18n.loadResources(!TC.i18n[locale], TC.apiLocation + 'TC/resources/', locale));
                    }
                    resolve();
                }
            );
        }));

        Promise.all(i18nPromises).finally(function () {
            // 22/03/2019 GLS: siempre vamos a tener layout porque en sitna.js (1757) se establece por defecto layout/responsive
            //                 si el usuario define otro se sobrescribe
            if (self.options.layout) {
                var layout = self.options.layout;

                self.trigger(TC.Consts.event.BEFORELAYOUTLOAD, { map: self });

                var layoutURLs = {};
                var ignoreError = false;
                if (typeof layout === 'string') {
                    var href = layout.trim();
                    href += href.match(/\/$/) ? '' : '/';

                    layoutURLs.config = href + 'config.json';
                    layoutURLs.markup = href + 'markup.html';
                    layoutURLs.style = href + 'style.css';
                    layoutURLs.script = href + 'script.js';
                    layoutURLs.i18n = href + 'resources';

                    // Si el layout se define como string, no podemos saber qué archivos a definido y cuales no, 
                    // por eso tampoco podemos saber si es un error de configuración o es que no lo ha definido así que no mostramos error entendiendo que si
                    // el archivo no está es porque no quiere.
                    ignoreError = true;
                }
                else if (
                    layout.hasOwnProperty('config') ||
                    layout.hasOwnProperty('markup') ||
                    layout.hasOwnProperty('style') ||
                    layout.hasOwnProperty('script') ||
                    layout.hasOwnProperty('href') ||
                    layout.hasOwnProperty('i18n')
                ) {
                    layoutURLs = TC.Util.extend({}, layout);
                }

                if (layoutURLs.i18n) {
                    layoutURLs.i18n += layoutURLs.i18n.match(/\/$/) ? '' : '/';
                }

                self.layout = layoutURLs;

                const layoutPromises = [];
                const ResponseError = function (status, url) {
                    this.status = status;
                    this.url = url;
                };
                const onError = function (error) {
                    if (!ignoreError || error.status != 404) {
                        const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));
                        TC.error(
                            TC.Util.getLocaleString(mapObj.options.locale, "urlFailedToLoad",
                                { url: error.url }),
                            [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],
                            "Error al cargar " + error.url);
                    }
                };

                const i18nLayoutPromise = new Promise(function (resolve, reject) {
                    if (layoutURLs.config) {

                        layoutPromises.push(fetch(layoutURLs.config)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.config);
                                }
                                return response.json();
                            }).then(function (data) {
                                resolve(data.i18n);
                                mergeOptions.call(self, data, options);
                            }).catch(function (error) {
                                onError(error);

                                resolve(false);
                            }));
                    }
                    else {
                        resolve(false);
                    }
                });
                layoutPromises.push(i18nLayoutPromise);

                if (layoutURLs.style) {
                    // Añadimos una clase para hacer más fáciles las reglas del layout
                    self.div.classList.add('tc-lo');

                    // GLS: 28/03/2019 Necesito hacer el HEAD para validar si existe porque si lo hago directamente y lo cargo como BLOB, 
                    // las referencias a las fuentes son relativas al blob por lo que no funcionan, así que HEAD y si existe lo cargo por href
                    fetch(layoutURLs.style, {
                        method: navigator.onLine ? 'HEAD': 'GET' // FLP: Las peticiones HEAD no se guardan en la cache, así que offline fallan, por eso la opción GET.
                    }).then(function (response) {
                        if (!response.ok) { // status no está en el rango 200-299
                            throw new ResponseError(response.status, layoutURLs.style);
                        }
                        return response;
                    }).then(function () {
                        var linkElement = document.createElement('link');
                        linkElement.rel = 'stylesheet';
                        linkElement.href = layoutURLs.style;

                        document.head.appendChild(linkElement);
                    }).catch(function (error) {
                        onError(error);
                    });
                }

                if (layoutURLs.markup) {
                    layoutPromises.push(new Promise(function (resolve, reject) {

                        fetch(layoutURLs.markup)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.markup);
                                }
                                return response.text();
                            }).then(function (data) {
                                // markup.html puede ser una plantilla dust para soportar i18n, compilarla si es el caso
                                i18nLayoutPromise.then(function (i18n) {
                                    if (i18n && locale && layoutURLs.i18n) {
                                        TC.i18n.loadResources(true, layoutURLs.i18n, locale).finally(function () {
                                            const replacerFn = function (match, grp1, grp2, grp3) {
                                                return TC.Util.getLocaleString(locale, grp1 || grp2 || grp3);
                                            };
                                            //data = data.replace(/\{\{([^\}\{]+)\}\}/g, replacerFn); // Estilo {{key}}
                                            //data = data.replace(/\{@i18n \$key="([^\}\{]+)"\/\}/g, replacerFn); // Estilo {@i18n $key="key"/}
                                            //data = data.replace(/\{\{i18n "([^\}\{]+)"\}\}/g, replacerFn); // Estilo {{i18n "key"}}
                                            data = data.replace(/\{\{i18n "([^\}\{]+)"\}\}|\{\{([^\}\{]+)\}\}|\{@i18n \$key="([^\}\{]+)"\/\}/g, replacerFn); // Los tres estilos anteriores
                                            self.div.insertAdjacentHTML('beforeend', data);
                                            resolve();
                                        });
                                    }
                                    else {
                                        self.div.insertAdjacentHTML('beforeend', data);
                                        resolve();
                                    }
                                });
                            }).catch(function (error) {
                                onError(error);

                                reject(Error(error));
                            });
                    }));
                }

                Promise.all(layoutPromises).finally(function () {

                    if (layoutURLs.script) {
                        fetch(layoutURLs.script)
                            .then(function (response) {
                                if (!response.ok) { // status no está en el rango 200-299
                                    throw new ResponseError(response.status, layoutURLs.script);
                                }
                                return response.blob();
                            }).then(function (fileBlob) {
                                var fileURL = URL.createObjectURL(fileBlob);

                                var scriptElement = document.createElement('script');
                                scriptElement.src = fileURL;

                                scriptElement.onload = function () {
                                    setHeightFix(self.div);
                                    init();
                                };

                                document.head.appendChild(scriptElement);

                            }).catch(function (error) {
                                onError(error);
                                init();
                            });
                    } else {
                        init();
                    }
                });

            }
            else {
                init();
            }
        });

        // Borramos árboles de capas cacheados
        self.on(TC.Consts.event.UPDATEPARAMS, function (e) {
            deleteTreeCache(e.layer);
        });
        self.on(TC.Consts.event.ZOOM, function () {
            for (var i = 0; i < self.workLayers.length; i++) {
                deleteTreeCache(self.workLayers[i]);
            }
        });

        // Redefinimos TC.error para añadir un aviso en el mapa
        /*var oldError = TC.error;
        TC.error = function (text) {
            oldError(text);
            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
        };*/
        var oldError = TC.error;
        TC.error = function (text, options, subject) {
            if (TC.isDebug && console.trace) {
                console.trace();
            }
            if (!options) {
                oldError(text);
                self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
            }
            else {
                var fnc = function (text, mode, subject) {
                    switch (mode) {
                        case TC.Consts.msgErrorMode.TOAST:
                            if (!self.toast) { console.warn("No existe el objeto Toast"); return; }
                            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
                            break;
                        case TC.Consts.msgErrorMode.EMAIL:
                            if (TC.Cfg.loggingErrorsEnabled) {
                                JL("onerrorLogger").fatalException(!subject ? text : {
                                    "msg": subject,
                                    "errorMsg": text,
                                }, null);
                            }
                            break;
                        case TC.Consts.msgErrorMode.CONSOLE:
                        default:
                            console.error(text)
                            break;
                    }
                }
                if (!Array.isArray(options)) {
                    fnc(text, options, subject)
                }
                else {
                    for (var i = 0; i < options.length; i++)
                        fnc(text, options[i], subject)
                }
            }

        };
    };

    TC.Map._instances = [];

    TC.Map.get = function (elm) {
        for (var i = 0, len = TC.Map._instances.length; i < len; i++) {
            const instance = TC.Map._instances[i];
            if (instance.div === elm) {
                return instance;
            }
        }
    };

    TC.inherit(TC.Map, TC.EventTarget);

    var deleteTreeCache = function (layer) {
        if (layer.type === TC.Consts.layerType.WMS) {
            layer.tree = null;
        }
    };

    /**
     * Función que mezcla opciones de mapa relativos a capa, teniendo cuidado de que puede haber objetos de opciones de capa o identificadores de capa.
     * En este último caso, si no son la opción prioritaria, hay que sustituirlos por los objetos de definiciones de capa.
     */
    var mergeLayerOptions = function (optionsArray, propertyName) {
        // lista de opciones de capa de los argumentos
        var layerOptions = Array.prototype.slice.call(optionsArray).map(function (elm) {
            var result = {};
            if (elm) {
                result[propertyName] = elm[propertyName];
            }
            return result;
        });
        if (propertyName === 'availableBaseLayers') console.log("layerOptions", layerOptions);
        // añadimos las opciones de capa de la configuración general
        var layerOption = {};
        layerOption[propertyName] = TC.Cfg[propertyName];
        layerOptions.unshift(layerOption);

        //Si se han definido baseLayers en el visor, hay que hacer un merge con las predefinidas en la API
        if (propertyName === 'baseLayers' && layerOptions[1]['baseLayers']) {
            layerOption = layerOptions[1];

            for (var i = 0; i < layerOption['baseLayers'].length; i++) {
                if (typeof layerOption['baseLayers'][i] === 'object') {
                    TC.Util.extend(layerOption['baseLayers'][i], getAvailableBaseLayer.call(this, layerOption['baseLayers'][i].id));
                }
            }
        } else {
            layerOptions.unshift(true); // Deep merge
            layerOption = TC.Util.extend.apply(this, layerOptions);
            if (propertyName === 'availableBaseLayers') console.log("layerOption", layerOption);
        }

        return layerOption[propertyName];
    };

    const mergeControlOptions = function (controlOptions) {        

        if (controlOptions.controlContainer) {

            if (Array.isArray(controlOptions.controlContainer.controls)) {

                controlOptions.controlContainer.controls.forEach((ctl) => {
                    Object.keys(ctl).filter((key) => key !== "position").forEach((name) => {
                        if (controlOptions[name] !== undefined) {
                            if (typeof ctl[name] === 'boolean') {
                                ctl[name] = {};
                            }
                            TC.Util.extend(ctl[name], controlOptions[name]);
                            delete controlOptions[name];
                        }                        
                    });
                });
                
            } else {
                // GLS compatibilidad hacia atrás

                Object.keys(controlOptions).filter(function (key) {
                    return Object.keys(controlOptions.controlContainer.controls).indexOf(key) > -1
                }).forEach(function (key) {
                    const containerControl = controlOptions.controlContainer.controls[key];
                    if (typeof containerControl.options === 'boolean') {
                        containerControl.options = {}
                    }
                    TC.Util.extend(containerControl.options, controlOptions[key]);
                    delete controlOptions[key];
                });
            }            
        }

        return controlOptions;
    }

    const mergeOptions = function () {
        const argArray = [true, {}, TC.Cfg].concat(Array.prototype.slice.call(arguments));
        const result = this.options = TC.Util.extend.apply(this, argArray);
        // Concatenamos las colecciones availableBaseLayers
        result.availableBaseLayers = TC.Cfg.availableBaseLayers.concat.apply(TC.Cfg.availableBaseLayers, Array.prototype.map.call(arguments, function (arg) {
            return arg.availableBaseLayers || [];
        }));
        result.baseLayers = mergeLayerOptions.call(this, arguments, 'baseLayers');
        result.workLayers = mergeLayerOptions.call(this, arguments, 'workLayers');

        const controls = Array.prototype.slice.call(arguments)
            .filter(elem => elem.controls)
            .map(elem => elem.controls);
        if (controls.length > 0) {
            result.controls = TC.Util.extend(result.controls, mergeControlOptions(TC.Util.extend(controls[0], controls[1])));
        }        
        return result;
    };

    var mapProto = TC.Map.prototype;

    var crsLayerError = function (map, layer) {
        var errorMessage = 'Layer "' + layer.title + '" ("' + layer.names + '"): ';
        var reason;
        if (layer.isValidFromNames()) {
            reason = 'layerSrsNotCompatible'
        } else {
            reason = 'layerNameNotValid';
        }
        errorMessage += TC.Util.getLocaleString(map.options.locale, reason);
        TC.error(errorMessage);
        map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: reason });
    };

    mapProto.getCRS = function () {
        const self = this;

        if (!self.on3DView) {
            return self.crs;
        } else {
            return self.view3D.crs;
        }
    };

    const appendRasterEvents = function (layer) {
        layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
            const wrap = this;
            if (!wrap._tileloaderror) {
                const path = layer.getPath();
                const title = path.length ? path[path.length - 1] : layer.title;
                layer.map.toast(TC.Util.getLocaleString(layer.map.options.locale, 'tileload.error',
                    { name: title, error: event.error.text }),
                    { type: TC.Consts.msgType.ERROR });
                wrap._tileloaderror = true;
                const onTileload = function (e) {
                    if (e.tile.src && e.tile.src !== TC.Consts.BLANK_IMAGE) {
                        delete wrap._tileloaderror;
                        wrap.$events.off(TC.Consts.event.TILELOAD, onTileload);
                    }
                };
                wrap.$events.on(TC.Consts.event.TILELOAD, onTileload);
            }
        });
    };

    /**
     * Añade una capa al mapa.
     * @method addLayer
     * @async
     * @param {TC.Layer|TC.cfg.LayerOptions|string} layer Objeto de capa, objeto de opciones del constructor de la capa, o identificador de capa.
     * @param {function} [callback] Función de callback.
     * @return {Promise} Promesa de objeto {{#crossLink "TC.Layer"}}{{/crossLink}}
     */
    mapProto.addLayer = function (layer, callback) {
        const self = this;

        const result = new Promise(function (resolve, reject) {

            const isLayerRaster = isRaster(layer);
            if (typeof layer === 'object' && !layer.id) {
                layer.id = TC.getUID();
            }

            let zIndex = layer.options ? layer.options.zIndex : layer.zIndex;
            if (typeof zIndex !== 'number') {
                zIndex = isLayerRaster ? 0 : 1;
            }

            self._layerBuffer.add(layer.id || layer, zIndex, layer.isBase);

            if (self.getLayer(layer.id)) {
                // Si ya existe capa con el mismo id, lanzamos error
                const error = Error(`Layer "${layer.id}" already exists`);
                error.layerId = layer.id;
                reject(error);
                return;
            }

            var lyr;
            var test;
            var objUrl;

            if (isLayerRaster) {
                test = !TC.layer || !TC.layer.Raster;
                objUrl = TC.apiLocation + 'TC/layer/Raster';
            }
            else {
                test = !TC.layer || !TC.layer.Vector;
                objUrl = TC.apiLocation + 'TC/layer/Vector';
            }
            TC.loadJS(
                test,
                [objUrl],
                function () {
                    if (typeof layer === 'string') {
                        lyr = new TC.layer.Raster(TC.Util.extend({}, getAvailableBaseLayer.call(self, layer), { map: self }));
                    }
                    else {
                        if (layer instanceof TC.Layer) {
                            lyr = layer;
                            lyr.map = self;
                        }
                        else {
                            layer.map = self;
                            if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                                lyr = new TC.layer.Vector(layer);
                            }
                            else {
                                lyr = new TC.layer.Raster(layer);
                            }
                        }
                    }

                    Promise.all([self.wrap.getMap(), lyr.wrap.getLayer()]).then(function () {

                        self.trigger(TC.Consts.event.BEFORELAYERADD, { layer: lyr });

                        // Nos aseguramos de que las capas raster se quedan por debajo de las vectoriales
                        var idx;
                        if (isRaster(lyr)) {
                            appendRasterEvents(lyr);
                            idx = self.wrap.indexOfFirstVector();
                        }
                        if (idx === -1) {
                            idx = self.wrap.getLayerCount();
                        }

                        const currentCrs = self.state && self.state.crs ? self.state.crs : self.getCRS();                        
                        TC.loadProjDef({
                            crs: currentCrs,
                            callback: function () {                                
                                const isCompatible = lyr.isCompatible(currentCrs);
                                if (lyr.isBase) {
                                    if (!isCompatible) {
                                        if (!lyr.type === TC.Consts.layerType.WMTS) {
                                            lyr.mustReproject = true;
                                        }
                                        else {
                                            const compatibleMatrixSet = lyr.wrap.getCompatibleMatrixSets(currentCrs)[0];
                                            if (compatibleMatrixSet) {
                                                lyr.wrap.setMatrixSet(compatibleMatrixSet);
                                            }
                                            else {
                                                lyr.mustReproject = true;
                                            }
                                        }
                                    }
                                    if (self.state) {
                                        lyr.isDefault = (self.state.base === lyr.id) || (self.state.base === lyr.options.fallbackLayer);
                                    }
                                    else if (typeof self.options.defaultBaseLayer === 'string') {
                                        lyr.isDefault = self.options.defaultBaseLayer === lyr.id;
                                    }
                                    else if (typeof self.options.defaultBaseLayer === 'number') {
                                        lyr.isDefault = self.options.defaultBaseLayer === self.baseLayers.length;
                                    }
                                    if (lyr.isDefault) {
                                        var fit;
                                        if (lyr.mustReproject && !lyr.type === TC.Consts.layerType.WMTS ||
                                            lyr.mustReproject && lyr.type === TC.Consts.layerType.WMTS && !lyr.wrap.getCompatibleMatrixSets(currentCrs)[0]) {
                                            if (lyr.options.fallbackLayer && lyr.getFallbackLayer) {

                                                self.addLayer(lyr.getFallbackLayer()).then(function (l) {
                                                    self.wrap.setBaseLayer(l.wrap.layer);
                                                    self.baseLayer = l.wrap.parent;
                                                    // GLS: Tema casita + initialExtent
                                                    fitToExtent(fit);

                                                    resolve(lyr);
                                                });
                                            } else {
                                                crsLayerError(self, lyr);
                                                const error = Error('Layer ' + lyr.id + ' incompatible with CRS');
                                                error.layerId = layer.id;
                                                reject(error);
                                            }
                                        }
                                        else {
                                            fit = self.baseLayer === null;

                                            lyr.wrap.getLayer().then(function (ollyr) {
                                                self.wrap.setBaseLayer(ollyr);
                                                self.baseLayer = lyr;

                                                // GLS: Tema casita + initialExtent
                                                fitToExtent(fit);

                                                resolve(lyr);
                                            });
                                        }
                                    }
                                    else {
                                        //self.baseLayers[self.baseLayers.length] = lyr;
                                        resolve(lyr);
                                    }
                                }
                                else {
                                    if (isCompatible) {
                                        lyr.wrap.getLayer().then(function (l) {
                                            resolve(lyr);
                                        });
                                    }
                                    else {
                                        crsLayerError(self, lyr);
                                        //URI: Si la capa no existe ne el capabilities se crea un falso negativo como capa no compatible con el CRS
                                        //y se enviaba un correo de log con ese error
                                        if (lyr.isValidFromNames()) {
                                            const error = Error('Layer ' + lyr.id + ' incompatible with CRS');
                                            error.layerId = layer.id;
                                            reject(error);
                                        }
                                        else {
                                            resolve(lyr);
                                        }
                                        
                                    }
                                }
                            }
                        });
                    }, function (error) {
                        error.layerId = layer.id;
                        reject(error);
                    });
                }
            );
        });

        result
            .then(function (l) {
                self._layerBuffer.resolve(self, l, l.isBase);
                if (!l.isBase) {
                    self.wrap.insertLayer(l.wrap.layer, self._layerBuffer.getResolvedVisibleLayerIndex(self, l.id));
                }
                self.trigger(TC.Consts.event.LAYERADD, { layer: l });
                self._layerBuffer.checkMapLoad(self);
                if (TC.Util.isFunction(callback)) {
                    callback(l);
                }
            })
            .catch(function (err) {
                self._layerBuffer.reject(self, err);
                self._layerBuffer.checkMapLoad(self);
            });

        const fitToExtent = function (fit) {
            if (fit) {
                var opt = {
                    projection: self.wrap.map.getView().getProjection(),
                    extent: self.initialExtent
                };
                var resolutions = self.baseLayer.getResolutions();
                if (resolutions && resolutions.length) {
                    opt.resolutions = resolutions;
                }
                else {
                    opt.minZoom = self.wrap.map.getView().getMinZoom();
                    opt.maxZoom = self.wrap.map.getView().getMaxZoom();
                    var minResolution = self.baseLayer.wrap.layer.getMinResolution();
                    if (minResolution !== 0) {
                        opt.minResolution = minResolution;
                    }
                    var maxResolution = self.baseLayer.wrap.layer.getMaxResolution();
                    if (maxResolution !== Number.POSITIVE_INFINITY) {
                        opt.maxResolution = maxResolution;
                    }
                }

                self.wrap.map.setView(new ol.View(opt));
                self.wrap.map.getView().fit(self.initialExtent);
            }
        };
        return result;
    };


    mapProto.removeLayer = function (layer) {
        const self = this;

        return new Promise(function (resolve, reject) {

            if (layer.unremovable) {
                return reject("Unremovable");
            }

            let found = false;
            for (var i = 0; i < self.layers.length; i++) {
                if (self.layers[i] === layer) {
                    self.layers.splice(i, 1);
                    found = true;
                    break;
                }
            }
            if (!found) {
                reject(new Error(`Layer ${layer.id} not found in map`));
                return;
            }
            if (layer.isBase) {
                for (var i = 0; i < self.baseLayers.length; i++) {
                    if (self.baseLayers[i] === layer) {
                        self.baseLayers.splice(i, 1);
                        if (self.baseLayer === layer) {
                            self.setBaseLayer(self.baseLayers[0]);
                        }
                        break;
                    }
                }
            }
            else {
                for (var i = 0; i < self.workLayers.length; i++) {
                    if (self.workLayers[i] === layer) {
                        self.workLayers.splice(i, 1);
                        break;
                    }
                }
                if (layer === self.vectors) {
                    self.vectors = null;
                }
            }

            layer.wrap.getLayer().then(function (olLayer) {
                self.wrap.removeLayer(olLayer);
                self._layerBuffer.remove(layer.id);
                self.trigger(TC.Consts.event.LAYERREMOVE, { layer: layer });
                self._layerBuffer.checkMapLoad(self);
                resolve(layer);
            });
        });
    };


    mapProto.insertLayer = function (layer, idx, callback) {
        var self = this;
        var beforeIdx = -1;
        for (var i = 0; i < self.layers.length; i++) {
            if (layer === self.layers[i]) {
                beforeIdx = i;
                break;
            }
        }

        var promises = [];
        promises.push(layer.wrap.getLayer());
        var targetLayer = self.layers[idx];
        if (targetLayer) {
            promises.push(targetLayer.wrap.getLayer());
        }
        Promise.all(promises).then(function (olLayers) {
            const olLayer = olLayers[0];
            const olTargetLayer = olLayers[1];
            var olIdx = -1;
            if (olTargetLayer) {
                olIdx = self.wrap.getLayerIndex(olTargetLayer);
            }
            else {
                olIdx = self.wrap.getLayerCount();
            }
            if (olIdx >= 0) {
                layer.map = self;
                self.wrap.insertLayer(olLayer, olIdx);
                if (beforeIdx > -1) {
                    self.layers.splice(beforeIdx, 1);
                }
                self.layers.splice(idx, 0, layer);
                self.workLayers = self.layers.filter(function (elm) {
                    return !elm.isBase;
                });
                self.trigger(TC.Consts.event.LAYERORDER, { layer: layer, oldIndex: beforeIdx, newIndex: idx });
            }
            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    mapProto.setLayerIndex = function (layer, idx) {
        this.wrap.setLayerIndex(layer.wrap.layer, idx);
    };

    mapProto.putLayerOnTop = function (layer) {
        var self = this;
        var n = self.wrap.getLayerCount();
        self.setLayerIndex(layer, n - 1);
    };

    /*
    *  setBaseLayer: Set a layer as base layer, it is added to layers collection it wasn't before
    *  Parameters: TC.Layer or string, callback which accepts layer as parameter
    *  Returns: TC.Layer promise
    */
    mapProto.setBaseLayer = function (layer, callback) {
        var self = this;
        var result = null;
        var found = false;

        if (typeof layer === 'string') {
            var i;
            for (i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    layer = self.layers[i];
                    found = true;
                    break;
                }
            }
            if (!found) {
                layer = getAvailableBaseLayer.call(self, layer);
                if (layer) {
                    layer = self.addLayer(TC.Util.extend(true, {}, layer, { isDefault: true, map: self }));
                    found = true;
                }
            }
        }
        else {
            if (self.layers.indexOf(layer) < 0) {
                layer.isDefault = true;
                layer.map = self;
                self.addLayer(layer);
                // GLS: comento lo siguiente porque ya se va a tratar en la línea 1838, si no, se lanza el evento 2 veces
                //.then(function () {                
                //self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                //if (TC.Util.isFunction(callback)) {
                //    callback();
                //}
                //});

                //result = layer;
                //return result;
            }
            found = true;
        }
        if (!found) {
            TC.error('Base layer is not available');
        }
        else {
            if (!layer.isCompatible(self.getCRS()) && (!layer.fallbackLayer || layer.fallbackLayer && !layer.fallbackLayer.isCompatible(self.getCRS()))) {
                TC.error('Base layer must be reprojected');
            }
            else {
                self.trigger(TC.Consts.event.BEFOREBASELAYERCHANGE, { oldLayer: self.getBaseLayer(), newLayer: layer });

                result = layer;
                self.wrap.getMap().then(function (olMap) {
                    layer.wrap.getLayer().then(function (olLayer) {
                        self.wrap.setBaseLayer(olLayer).then(function () {
                            self.baseLayer = layer;
                            self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                            if (TC.Util.isFunction(callback)) {
                                callback();
                            }
                        });
                    });
                });
            }
        }
        return result;
    };

    mapProto.setView = function (view) {
        const self = this;

        self.view = view;
        self.trigger(TC.Consts.event.VIEWCHANGE, { view: view });
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles del mapa se hayan cargado.
     * @method ready
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.ready = function (callback) {
        var self = this;
        if (TC.Util.isFunction(callback)) {
            if (self.isReady) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPREADY, callback);
            }
        }
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles y las capas iniciales del mapa se hayan cargado.
     * @method loaded
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.loaded = function (callback) {
        var self = this;
        if (TC.Util.isFunction(callback)) {
            if (self.isLoaded) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };



    /**
     * Devuelve un árbol de capas del mapa.
     * @method getLayerTree
     * @return {TC.LayerTree}
     */
    mapProto.getLayerTree = function () {


        var _traverse = function (o, func) {
            for (var i in o.children) {
                if (o.children && o.children.length > 0) {
                    //bajar un nivel en el árbol
                    _traverse(o.children[i], func);
                }

                func.apply(this, [o]);
            }
        };



        var self = this;
        var result = { baseLayers: [], workLayers: [] };
        if (self.baseLayer) {
            result.baseLayers[0] = self.baseLayer.getTree();
        }
        for (var i = 0; i < self.workLayers.length; i++) {
            var tree = self.workLayers[i].getTree();

            if (tree) {
                result.workLayers.unshift(tree);
            }
        }
        return result;
    };

    /**
     * Añade un control al mapa.
     * @method addControl
     * @async
     * @param {TC.Control|string} control Control a añadir o nombre del control
     * @param {object} [options] Objeto de opciones de configuración del control. Consultar el parámetro de opciones del constructor del control.
     * @return {Promise} Promesa de objeto {{#crossLink "TC.Control"}}{{/crossLink}}
     */
    mapProto.addControl = function (control, options) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const _addCtl = function (ctl) {
                self.controls.push(ctl);
                // Lo envolvemos en Promise.resolve para asegurarse compatibilidad hacia atrás con los controles que devuelven un $.Deferred.
                return Promise.resolve(ctl.register(self))
                    .then(function (c) {
                        if (!ctl.div.parentElement) {
                            self.div.appendChild(ctl.div);
                        }
                        self.trigger(TC.Consts.event.CONTROLADD, { control: ctl });
                        return c;
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            };
            if (typeof control === 'string') {
                control = control.substr(0, 1).toUpperCase() + control.substr(1);
                TC.loadJS(
                    !TC.Control || !TC.control[control],
                    [TC.apiLocation + 'TC/control/' + control],
                    function () {
                        _addCtl(new TC.control[control](null, options)).then(function (ctl) {
                            resolve(ctl)
                        });
                    }
                );
            }
            else {
                _addCtl(control).then(function (ctl) {
                    resolve(ctl);
                });
            }
        });
    };

    /**
     * Devuelve la lista de controles que son de la clase especificada.
     * @method getControlsByClass
     * @param {function|string} classObj Nombre de la clase o función constructora de la clase.
     * @return {array}
     */
    mapProto.getControlsByClass = function (classObj) {
        var self = this;
        var result = [];
        var obj = classObj;
        if (typeof classObj === 'string') {
            obj = window;
            var namespaces = classObj.split('.');
            for (var i = 0; i < namespaces.length; i++) {
                obj = obj[namespaces[i]];
                if (!obj) {
                    break;
                }
            }
        }
        if (TC.Util.isFunction(obj)) {
            for (var i = 0; i < self.controls.length; i++) {
                var ctl = self.controls[i];
                if (ctl instanceof obj) {
                    result.push(ctl);
                }
            }
        }

        return result;
    };

    mapProto.getControlById = function (id) {
        const self = this;
        for (var i = 0, len = self.controls.length; i < len; i++) {
            const ctl = self.controls[i];
            if (ctl.id === id) {
                return ctl;
            }
        }
        return null;
    };

    mapProto.getDefaultControl = function () {
        const self = this;
        var candidate;
        if (self.options.defaultActiveControl) {
            candidate = self.getControlsByClass('TC.control.' + self.options.defaultActiveControl.substr(0, 1).toUpperCase() + self.options.defaultActiveControl.substr(1))[0];
        }
        if (!candidate) {
            candidate = self.getControlsByClass('TC.control.MultiFeatureInfo')[0];
            if (candidate) {
                candidate = candidate.lastCtrlActive;
            }
            else {
                candidate = self.getControlsByClass('TC.control.FeatureInfo')[0];
            }
        }
        return candidate;
    };

    /**
     * Devuelve el primer control del mapa que sea de la clase {{#crossLink "TC.control.LoadingIndicator"}}{{/crossLink}}.
     * @method getLoadingIndicator
     * @return {TC.control.LoadingIndicator}
     */
    mapProto.getLoadingIndicator = function () {
        var result = null;
        var ctls = this.getControlsByClass('TC.control.LoadingIndicator');
        if (ctls.length) {
            result = ctls[0];
        }
        return result;
    };

    /**
     * Establece la extensión del mapa.
     * @method setExtent
     * @param {array} extent Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al cambiar la extensión.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.setExtent = function (extent, options) {
        return this.wrap.setExtent(extent, options);
    };

    /**
     * Obtiene la extensión actual del mapa.
     * @method getExtent
     * @return {array} Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.getExtent = function () {
        return this.wrap.getExtent();
    };

    /**
     * Establece el centro del mapa.
     * @method setCenter
     * @param {array} coord Array de dos números que representan la coordenada del punto en las unidades correspondientes al CRS del mapa.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al centrar.
     */
    mapProto.setCenter = function (coord, options) {
        return this.wrap.setCenter(coord, options);
    };

    mapProto.getCenter = function () {
        return this.wrap.getCenter();
    };

    mapProto.setRotation = function (rotation) {
        this.wrap.setRotation(rotation);
    };

    mapProto.getRotation = function () {
        return this.wrap.getRotation();
    };

    mapProto.getViewHTML = function () {
        return this.wrap.getViewport();
    };


    mapProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        const layers = options.layers || self.workLayers.concat(self.baseLayer);
        const crsLists = layers
            .filter(function (layer) {
                return layer.isRaster();
            }) // capas raster
            .map(function (layer) {
                return layer.getCompatibleCRS({ normalized: true, includeFallback: options.includeFallbacks });
            });
        const otherCrsLists = crsLists.slice(1);
        return crsLists[0].filter(function (elm) {
            return otherCrsLists.every(function (crsList) {
                return crsList.indexOf(elm) >= 0;
            });
        });
    };

    mapProto.loadProjections = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            const crsList = options.crsList || [];
            Promise.all(crsList
                .map(function (crs) {
                    return TC.getProjectionData({
                        crs: TC.Util.getCRSCode(crs)
                    });
                })).then(function (responses) {
                    var projList = responses
                        .filter(function (response) {
                            return response.status === 'ok' && response.number_result > 0;
                        })
                        .map(function (response) {
                            const projData = response.results[0];
                            const code = 'EPSG:' + projData.code;
                            TC.loadProjDef({
                                crs: code,
                                def: projData.def,
                                name: projData.name
                            });
                            return {
                                code: code,
                                name: projData.name,
                                proj4: projData.proj4,
                                unit: projData.unit
                            };
                        });
                    if (options.orderBy) {
                        projList = projList
                            .sort(TC.Util.getSorterByProperty(options.orderBy));
                    }
                    resolve(projList);
                },
                function (error) {
                    reject(error);
                });
        });
    };

    mapProto.setProjection = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            var baseLayer;
            if (options.crs) {
                if (options.baseLayer) {
                    baseLayer = options.baseLayer;
                }
                else if (options.allowFallbackLayer) {
                    // Cambiamos de capa de fondo si es mejor o no hay más remedio
                    if (!self.baseLayer.isCompatible(options.crs) &&
                        self.baseLayer.wrap.getCompatibleMatrixSets(options.crs).length === 0) {
                        if (self.baseLayer.options.fallbackLayer) {
                            baseLayer = self.baseLayer.getFallbackLayer();
                        }
                    }
                    else if (self.baseLayer.firstOption && (self.baseLayer.firstOption.isCompatible(options.crs) ||
                        self.baseLayer.firstOption.wrap.getCompatibleMatrixSets(options.crs).length > 0)) {
                        baseLayer = self.baseLayer.firstOption;
                    }
                }
                if (!baseLayer) {
                    baseLayer = self.baseLayer;
                }

                // 03/04/2019 GLS: esperamos a que termine de añadirse la capa porque si no se duplica en la gestión de la carga del CRS.
                const loadProj = function () {
                    TC.loadProjDef({
                        crs: options.crs,
                        callback: function () {
                            const oldCrs = self.crs;
                            const setProjection = function (baseLayer) {

                                const _setProjection = function () {
                                    const layerProjectionOptions = TC.Util.extend({}, options, { oldCrs: self.crs });
                                    const setLayerProjection = function (layer) {
                                        layer.setProjection(layerProjectionOptions);
                                    };
                                    if (baseLayer.isCompatible(options.crs) || baseLayer.wrap.getCompatibleMatrixSets(options.crs).length > 0) {
                                        baseLayer.setProjection(layerProjectionOptions);
                                        self.wrap.setProjection(TC.Util.extend({}, options, { baseLayer: baseLayer }));
                                        self.crs = options.crs;
                                        // En las capas base disponibles, evaluar su compatibilidad con el nuevo CRS
                                        self.baseLayers
                                            .filter(function (layer) {
                                                return layer !== baseLayer;
                                            })
                                            .forEach(setLayerProjection);
                                        // Reprojectamos capas cargadas
                                        self.workLayers.forEach(setLayerProjection);
                                        const resolveChange = function () {
                                            self.trigger(TC.Consts.event.PROJECTIONCHANGE, { oldCrs: oldCrs, newCrs: options.crs });
                                            resolve();
                                        };
                                        if (baseLayer && baseLayer !== self.baseLayer) {
                                            self.setBaseLayer(baseLayer, resolveChange);
                                        }
                                        else {
                                            resolveChange();
                                        }
                                    }
                                    else if (baseLayer.fallbackLayer) {
                                        setProjection(baseLayer.fallbackLayer);
                                    } else {
                                        reject(Error('Layer has no fallback'));
                                    }
                                };

                                if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                                    baseLayer.getCapabilitiesPromise().then(_setProjection);
                                } else {
                                    _setProjection();
                                }
                            };

                            setProjection(baseLayer);
                        }
                    });
                };

                if (self.baseLayers.indexOf(baseLayer) < 0) {
                    self.addLayer(baseLayer).then(loadProj);
                } else {
                    loadProj();
                }
            }
        });
    };

    mapProto.getMetersPerUnit = function () {
        return this.wrap.getMetersPerUnit();
    };

    /**
     * Obtiene una coordenada a partir de una posición del área de visualización del mapa en píxeles.
     * @method getCoordinateFromPixel
     * @param {array} xy Coordenada en píxeles de la posición en el área de visualización.
     * @return {array} Array de dos números que representa las coordenada del punto en las unidades correspondientes al CRS del mapa.
     */
    mapProto.getCoordinateFromPixel = function (xy) {
        return this.wrap.getCoordinateFromPixel(xy);
    };

    /**
     * Obtiene una posición en el área de visualización a partir de una coordenada.
     * @method getCoordinateFromPixel
     * @param {array} coord Coordenada en el mapa.
     * @return {array} Array de dos números que representa las posición del punto en píxeles.
     */
    mapProto.getPixelFromCoordinate = function (coord) {
        return this.wrap.getPixelFromCoordinate(coord);
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas las entidades geográficas pasadas por parámetro.
     * @method zoomToFeatures
     * @param {array} features Array de entidades geográficas. Si está vacío este método no hace nada.
     * @param {object} [options] Objeto de opciones de zoom.
     * @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del punto que se respetará al hacer zoom.
     * @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas las entidades. 
     * @param {boolean} [options.animate=false] Realizar animación al hacer el zoom. 
     * El valor es la relación resultante de la diferencia de dimensiones entre la extensión ampliada y la original relativa a la original.
     */
    mapProto.zoomToFeatures = function (features, options) {
        var self = this;
        if (features.length > 0) {
            var bounds = [Infinity, Infinity, -Infinity, -Infinity];
            var opts = options || {};
            var radius = opts.pointBoundsRadius || self.options.pointBoundsRadius;
            radius = radius / self.getMetersPerUnit();
            var extentMargin = opts.extentMargin;
            if (typeof extentMargin !== 'number') {
                extentMargin = self.options.extentMargin;
            }
            for (var i = 0; i < features.length; i++) {
                var b = features[i].getBounds();
                if (b) {
                    bounds[0] = Math.min(bounds[0], b[0]);
                    bounds[1] = Math.min(bounds[1], b[1]);
                    bounds[2] = Math.max(bounds[2], b[2]);
                    bounds[3] = Math.max(bounds[3], b[3]);
                }
            }
            if (bounds[2] - bounds[0] === 0) {
                bounds[0] = bounds[0] - radius;
                bounds[2] = bounds[2] + radius;
            }
            if (bounds[3] - bounds[1] === 0) {
                bounds[1] = bounds[1] - radius;
                bounds[3] = bounds[3] + radius;
            }
            if (self.options.extentMargin) {
                var dx = (bounds[2] - bounds[0]) * extentMargin / 2;
                var dy = (bounds[3] - bounds[1]) * extentMargin / 2;
                bounds[0] = bounds[0] - dx;
                bounds[1] = bounds[1] - dy;
                bounds[2] = bounds[2] + dx;
                bounds[3] = bounds[3] + dy;
            }
            if (self.options.maxExtent) {
                bounds[0] = Math.max(bounds[0], self.options.maxExtent[0]);
                bounds[1] = Math.max(bounds[1], self.options.maxExtent[1]);
                bounds[2] = Math.min(bounds[2], self.options.maxExtent[2]);
                bounds[3] = Math.min(bounds[3], self.options.maxExtent[3]);
            }
            self.wrap.setExtent(bounds, opts);

            // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
            self.trigger(TC.Consts.event.ZOOMTO, { extent: bounds });
        }
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas los marcadores que existen en él.
     * El método espera a todos los marcadores pendientes de incluir, dado que el método {{#crossLink "TC.Map/addMarker:method"}}{{/crossLink}} es asíncrono.
     * @method zoomToMarkers
     */
    mapProto.zoomToMarkers = function (options) {
        var self = this;
        Promise.all(self._markerPromises).then(function () {
            var markers = [];
            for (var i = 0; i < self.workLayers.length; i++) {
                var layer = self.workLayers[i];
                if (layer.type === TC.Consts.layerType.VECTOR) {
                    for (var j = 0; j < layer.features.length; j++) {
                        var feature = layer.features[j];
                        if (feature instanceof TC.feature.Marker) {
                            markers[markers.length] = feature;
                        }
                    }
                }
            }

            self.zoomToFeatures(markers, options);
            self._markerPromises = [];
        });
    };

    /**
     * Obtiene una capa por su identificador o devuelve la propia capa.
     * @method getLayer
     * @param {string|TC.Layer} layer Identificador de la capa u objeto de capa.
     * @return {TC.Layer}
     */
    mapProto.getLayer = function (layer) {
        const self = this;
        var result = null;
        if (typeof layer === 'string') {
            for (var i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    result = self.layers[i];
                    break;
                }
            }
        }
        else if (TC.Layer && layer instanceof TC.Layer && layer.map === self) {
            result = layer;
        }
        return result;
    };

    var _getVectors = function (map) {
        var result;
        if (!map.vectors) {
            result = map.addLayer({
                id: TC.getUID(), title: TC.i18n[map.options.locale]['vectors'], type: TC.Consts.layerType.VECTOR
            });
            map.vectors = result;
            result.then(function (vectors) {
                map.vectors = vectors;
            });
        }
        else {
            result = Promise.resolve(map.vectors);
        }
        return result;
    };

    /**
     * Añade un punto al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPoint
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.PointStyleOptions} [options] Opciones del punto.
     */
    mapProto.addPoint = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                layer.addPoint(coord, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPoint(coord, options);
            });
        }
    };

    /**
     * Añade un marcador puntual al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addMarker
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.MarkerStyleOptions} [options] Opciones del marcador.
     */
    mapProto.addMarker = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                self._markerPromises.push(layer.addMarker(coord, options));

            }
            else {
                self._markerPromises.push(Promise.reject(new Error('Layer "' + options.layer + '" not found')));
            }
        }
        else {
            // Se añade una promise más para evitar que zoomToMarkers salte antes de poblarse el array _markerPromises.
            self._markerPromises.push(new Promise(function (resolve, reject) {
                _getVectors(self).then(function (vectors) {
                    vectors.addMarker(coord, options).then(function (marker) {
                        resolve(marker);
                    });
                });
            }));
        }
    };

    /**
     * Añade una polilínea al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolyline
     * @async
     * @param {array} coords Array de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * @param {object} [options] Opciones de la polilínea.
     */
    mapProto.addPolyline = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolyline(coords, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolyline(coords, options);
            });
        }
    };

    /**
     * Añade un polígono al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolygon
     * @async
     * @param {array} coords Array que contiene anillos. Estos a su vez son arrays de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * El primer anillo es el exterior y el resto son islas. No es necesario cerrar los anillos (poner el mismo vértice al principio y al final).
     * @param {object} [options] Opciones del polígono.
     */
    mapProto.addPolygon = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolygon(coords, options);
            }
            else {
                throw new Error('Layer "' + options.layer + '" not found');
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolygon(coords, options);
            });
        }
    };




    mapProto.getBaseLayer = function () {
        return this.baseLayer || this.baseLayers[0];
    };

    mapProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    mapProto.getResolution = function () {
        return this.wrap.getResolution();
    };

    mapProto.setResolution = function (resolution) {
        this.wrap.setResolution(resolution);
    };

    mapProto.exportFeatures =async function (features, options) {
        var self = this;
        options = options || {};
        var loadingCtl = self.getLoadingIndicator();
        var waitId = loadingCtl && loadingCtl.addWait();
        // Eliminamos las elevaciones nulas
        // En GPX hay un bug con los valores cero, que hace que se tome el valor de elevación del punto previo, por eso ponemos NaN.
        const elevSubst = options.format === TC.Consts.format.GPX ? Number.NaN : 0;
        features.forEach(function (feature, idx) {
            // Decodificamos entidades HTML de la feature
            const data = feature.getData();
            for (let key in data) {
                if (/&(\w+|#\d{2,4});/g.test(key)) {
                    const value = data[key];
                    const newData = {};
                    const elm = document.createElement('div');
                    elm.innerHTML = key;
                    newData[elm.innerText] = value;
                    feature.unsetData(key);
                    feature.setData(newData);
                }
            }
            // Formateamos el valor de elevación
            var flatCoords = feature.getCoords({ pointArray: true });
            if (flatCoords.some(function (point) {
                return point[2] === null;
            })) {
                features[idx] = feature = feature.clone();
                flatCoords = feature.getCoords({ pointArray: true });
                flatCoords.forEach(function (point) {
                    if (point[2] === null) {
                        point[2] = elevSubst;
                    }
                });
            }
        });        
        const text = self.wrap.exportFeatures(features, options);
        const mimeType = TC.Consts.mimeType[options.format];
        const format = options.format || "";
        if (format === TC.Consts.format.KMZ) {
            var zip = new JSZip();
            var fileName = (options.fileName || TC.getUID())
            zip.file(fileName + ".kml", text);
            zip.generateAsync({ type: "blob", mimeType: mimeType}).then(function (blob) {
                filename = fileName + ".kmz";
                TC.Util.downloadBlob(filename, blob);
                loadingCtl && loadingCtl.removeWait(waitId);
            });
        }
        else {
            TC.Util.downloadFile((options.fileName || TC.getUID()) + '.' + format.toLowerCase(), mimeType, text);
            loadingCtl && loadingCtl.removeWait(waitId);
        }       
        
    };


    var toastContainerClass = 'tc-toast-container';
    var toastClass = 'tc-toast';
    var toasts = {};
    var toastHide = function () {
        const toast = this;
        var container = toast;
        do {
            container = container.parentElement;
        }
        while (container && !container.matches('.' + toastContainerClass));
        const text = toast.innerHTML;
        toast.classList.add(TC.Consts.classes.HIDDEN);
        if (toasts[text] !== undefined) {
            toasts[text] = undefined;
        }
        setTimeout(function () {
            if (toast.parentElement) {
                toast.parentElement.removeChild(toast);
            }
            if (container && !container.querySelector('.' + toastClass) && container.parentElement) {
                container.parentElement.removeChild(container);
            }
        }, 1000);
    };

    mapProto.toastHide = function (text) {
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
    };

    mapProto.toast = function (text, options) {
        const self = this;
        var opts = options || {
        };
        var duration = opts.duration || TC.Cfg.toastDuration;
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
        var container = self.div.querySelector('.' + toastContainerClass);
        if (!container) {
            container = document.createElement('div');
            container.classList.add(toastContainerClass);
            (opts.container ? opts.container : self.div).appendChild(container);
        }
        const toast = document.createElement('div');
        const span = document.createElement('span');
        toast.classList.add(toastClass);
        toast.appendChild(span);
        const p = document.createElement('p');
        p.innerHTML = text;
        toast.appendChild(p);
        toast.addEventListener(TC.Consts.event.CLICK, toastHide);
        container.appendChild(toast);
        toastInfo = toasts[text] = {
            toast: toast
        };

        var className = '';
        switch (opts.type) {
            case TC.Consts.msgType.INFO:
                className = TC.Consts.classes.INFO;
                break;
            case TC.Consts.msgType.WARNING:
                className = TC.Consts.classes.WARNING;
                break;
            case TC.Consts.msgType.ERROR:
                className = TC.Consts.classes.ERROR;
                break;
        }
        if (className.length) {
            toastInfo.toast.classList.add(className);
        }

        toastInfo.timeout = setTimeout(function () {
            toastHide.call(toastInfo.toast);
        }, duration);
    };

    // iPad iOS7 bug fix
    var mapHeightNeedsFix = false;
    var setHeightFix = function (div) {
        if (/iPad/i.test(navigator.userAgent)) {
            var ih = window.innerHeight;
            var mh = div.getBoundingClientRect.height;
            var dh = matchMedia('only screen and (orientation : landscape)').matches ? 20 : 0;
            if (mh === ih + dh) {
                mapHeightNeedsFix = true;
            }
        }
        var fix = function () {
            div.classList.toggle(TC.Consts.classes.IPAD_IOS7_FIX, matchMedia('only screen and (orientation : landscape)').matches);
        };
        if (mapHeightNeedsFix) {
            fix();
            window.addEventListener('resize', fix);
        }
        else {
            window.removeEventListener('resize', fix);
        }
    };

    var isRaster = function (layer) {
        return typeof layer === 'string' || (layer.type !== TC.Consts.layerType.VECTOR && layer.type !== TC.Consts.layerType.KML && layer.type !== TC.Consts.layerType.WFS);
    };

    mapProto.exportImage = function () {
        var self = this;
        var result = null;
        var errorMsg = 'El mapa actual no es compatible con la exportación de imágenes';
        var canvas = self.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
        if (canvas && self.options.crossOrigin) {
            try {
                result = canvas.toDataURL();
            }
            catch (e) {
                TC.error(errorMsg + ': ' + e.message);
            }
        }
        else {
            TC.error(errorMsg);
        }
        return result;
    };
})();

/**
 * Árbol de capas del mapa.
 * Esta clase no tiene constructor.
 * @class TC.LayerTree
 * @static
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas base del mapa.
 * @property baseLayers
 * @type array
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas de trabajo del mapa.
 * @property workLayers
 * @type array
 */

; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Util = factory();
    }
})(TC, function () {

    String.prototype.soundex = function () {
        var a = this.toLowerCase().split('')
        f = a.shift(),
            r = '',
            codes = {
                a: '', e: '', i: '', o: '', u: '',
                b: 1, f: 1, p: 1, v: 1,
                c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2,
                d: 3, t: 3,
                l: 4,
                m: 5, n: 5,
                r: 6
            };

        r = f +
            a
                .map(function (v, i, a) { return codes[v] })
                .filter(function (v, i, a) { return ((i === 0) ? v !== codes[f] : v !== a[i - 1]); })
                .join('');

        return (r + '000').slice(0, 4).toUpperCase();
    }

    // Polyfill para IE
    Number.isInteger = Number.isInteger || function (value) {
        return typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value;
    };

    // GLS: Parche: Chrome no formatea correctamente los números en euskera, establece como separador de decimales el (.)
    var toLocaleString = Number.prototype.toLocaleString;
    Number.prototype.toLocaleString = function (locale, options) {
        if (locale == "eu-ES" && !TC.Util.detectIE()) {
            var sNum = toLocaleString.apply(this, arguments);
            sNum = sNum.replace(/\,/g, '.')
            if (!(Math.floor(this) == this && Number.isInteger(Math.floor(this))))
                sNum = sNum.replace(/.([^.]*)$/, ",$1");

            return sNum;
        }
        else
            return toLocaleString.apply(this, arguments);
    }

    var iconUrlCache = {};
    var markerGroupClassCache = {};

    var path1 = ["Capability", "Request", "GetMap", "DCPType", "0", "HTTP", "Get", "OnlineResource"];
    var path2 = ["OperationsMetadata", "GetTile", "DCP", "HTTP", "Get", "0", "href"];
    var getOnPath = function (obj, p, i) {
        if (i < p.length - 1) {
            if (obj.hasOwnProperty(p[i]))
                return getOnPath(obj[p[i]], p, ++i);
            else return null;
        } else {
            return obj[p[i]];
        }
    };

    const swipeHandlers = new WeakMap();
    const modalCloseHandlers = new WeakMap();
    const hasOwn = ({}).hasOwnProperty;

    var Util = {

        isPlainObject: function (obj) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (typeof obj !== 'object' || obj.nodeType || obj.window === obj) {
                return false;
            }

            if (obj.constructor &&
                !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }

            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        isFunction: function (obj) {
            return typeof obj === 'function';
        },

        extend: function () {
            var clone,
                target = arguments[0] || {},
                i = 1,
                deep = false;

            // Comprobar si hay que hacer copia profunda (primer parámetro === true)
            if (typeof target === 'boolean') {
                deep = target;

                target = arguments[i] || {};
                i++;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== 'object' && !Util.isFunction(target)) {
                target = {};
            }

            for (var len = arguments.length; i < len; i++) {
                // Only deal with non-null/undefined values
                const options = arguments[i];
                if (options != null) {
                    // Extend the base object
                    for (var name in options) {
                        const src = target[name];
                        const copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        const copyIsArray = Array.isArray(copy);
                        if (deep && copy && (Util.isPlainObject(copy) || copyIsArray)) {
                            if (copyIsArray) {
                                clone = src && Array.isArray(src) ? src : [];

                            } else {
                                clone = src && Util.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = Util.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        },

        getMapLocale: function (map) {
            return map.options && map.options.locale && map.options.locale.replace('_', '-') || "es-ES";
        },

        regex: {
            PROTOCOL: /(^https?:)/i
        },

        isOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            if (withProtocol) {
                if (TC.capabilities[testUrl])
                    return url;
            } else {
                for (var c in TC.capabilities) {
                    if (c.replace(TC.Util.regex.PROTOCOL, "") == testUrl)
                        return c;
                }
            }

            for (c in TC.capabilities) {
                var u = getOnPath(TC.capabilities[c], path1, 0) || getOnPath(TC.capabilities[c], path2, 0);

                if (u && withProtocol && url == u) return u;
                else if (u && url.replace(TC.Util.regex.PROTOCOL, "") == u.replace(TC.Util.regex.PROTOCOL, "")) return u;
            }

            return url;
        },

        reqGetMapOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            var _get = function (caps) {
                var u = getOnPath(caps, path1, 0) || getOnPath(caps, path2, 0);
                if (u)
                    return !withProtocol ? u.split('?')[0].replace(TC.Util.regex.PROTOCOL, "") : u.split('?')[0];

                return null;
            };
            if (TC.capabilities[url]) {
                return _get(TC.capabilities[url]);
            }

            return null;
        },

        getFnFromString: function (fnName) {
            var scope = window;
            var scopeSplit = fnName.split('.');
            for (i = 0; i < scopeSplit.length - 1; i++) {
                scope = scope[scopeSplit[i]];

                if (scope == undefined) return;
            }

            return scope[scopeSplit[scopeSplit.length - 1]];
        },

        isURL: function (text) {
            return /^(http|https|ftp|mailto)\:\/\//i.test(text);
        },

        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        isSameOrigin: function (uri) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var location = window.location;
                var uProtocol = urlParts[1];
                result =
                    (uProtocol == location.protocol || uProtocol == undefined) &&
                    urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        formatNumber: function (value, locale) {
            var t = typeof value;
            if (t === 'number') {
                return value.toLocaleString(locale);
            }
            else if (t === 'string') {
                n = parseFloat(value);
                if (n === new Number(value).valueOf()) {
                    return n.toLocaleString(locale);
                }
            }
            return value;
        },

        addProtocol: function (uri) {
            var result = uri;
            if (uri && uri.indexOf('//') === 0) {
                result = location.protocol + uri;
            }
            return result;
        },

        /* 
        * getDiv: returns HTML element or null if the parameter is invalid
        * Parameter: string with element ID or HTML element
        */
        getDiv: function (div) {
            var result;
            if (typeof div === 'string') {
                result = document.getElementById(div);
            }
            else if (div instanceof HTMLElement) {
                result = div;
            }
            else if (div && '$' in window && div instanceof $ && div.length) {
                result = div[0];
            }
            else {
                result = document.createElement('div');
            }
            return result;
        },

        getScriptLocation: function () {
            var src;
            var script;
            if (document.currentScript) {
                script = document.currentScript;
            }
            else {
                var scripts = document.getElementsByTagName('script');
                script = scripts[scripts.length - 1];
            }
            src = script.getAttribute('src');
            if (src) {
                return src.substr(0, src.lastIndexOf('/') + 1);
            }
            return "";
        },

        /* 
        * getBackgroundUrlFromCss: devuelve la URL de background-image en CSS
        * Parameter: string con nombre de clase
        */
        getBackgroundUrlFromCss: function (cssClass) {
            var result = '';

            if (cssClass) {
                if (iconUrlCache[cssClass] !== undefined) {
                    result = iconUrlCache[cssClass];
                }
                else {
                    const iconDiv = document.createElement('div');
                    iconDiv.style.display = 'none';
                    iconDiv.classList.add(cssClass);
                    document.body.appendChild(iconDiv);
                    // The regular expression is nongreedy (.*?), otherwise in FF and IE it gets 'url_to_image"'
                    var match = /^url\(['"]?(.*?)['"]?\)$/gi.exec(window.getComputedStyle(iconDiv, null).backgroundImage);
                    if (match && match.length > 1) {
                        result = match[match.length - 1];
                    }
                    iconDiv.parentElement.removeChild(iconDiv);
                    iconUrlCache[cssClass] = result;
                }
            }
            return result;
        },

        getPointIconUrl: function getPointIconUrl(options) {
            var result = null;
            if (options.url) {
                result = options.url;
            }
            else {
                var className;
                if (typeof options.cssClass === 'string') {
                    className = options.cssClass;
                }
                else {
                    var classes = options.classes || TC.Cfg.styles.marker.classes;
                    className = classes[0];
                    if (options.group) {
                        if (markerGroupClassCache[options.group] === undefined) {
                            var i = 0;
                            for (var key in markerGroupClassCache) {
                                i++;
                            }
                            i = i % classes.length;
                            markerGroupClassCache[options.group] = classes[i];
                        }
                        className = markerGroupClassCache[options.group];
                    }
                }
                result = TC.Util.getBackgroundUrlFromCss(className);
            }
            if (!result && options !== TC.Cfg.styles.point && options.cssClass !== '') {
                result = getPointIconUrl(TC.Cfg.styles.point);
            }
            return result;
        },

        getLegendImageFromStyle: function (style, options) {
            let result = null;
            options = options || {};
            if (style.url) {
                result = style.url;
            }
            else {
                let width = options.width || 32;
                let height = options.height || 16;
                const strokeWidth = style.strokeWidth || 0;
                const strokeHalfWidth = strokeWidth / 2;
                const diameter = (style.radius || 0) * 2 + strokeWidth;
                const lineDashText = style.lineDash ? `stroke-dasharray="${style.lineDash.join(' ')}" ` : '';
                let body;
                width = Math.max(width, diameter);
                height = Math.max(height, diameter);
                switch (options.geometryType) {
                    case TC.Consts.geom.POINT:
                        body = `<circle cx="${width / 2}" cy="${height / 2}" r="${style.radius}" stroke="${style.strokeColor}" stroke-width="${strokeWidth}" fill="${style.fillColor}" fill-opacity="${style.fillOpacity}" ${lineDashText}/>`;
                        break;
                    case TC.Consts.geom.POLYLINE:
                        const xStart = strokeHalfWidth;
                        const yStart = height - strokeHalfWidth;
                        const xEnd = width - strokeHalfWidth;
                        const yEnd = strokeHalfWidth;
                        body = `<polyline points="${xStart},${yStart} ${xEnd},${yEnd}" style="stroke:${style.strokeColor};stroke-width:${strokeWidth}" ${lineDashText}/>`;
                        break;
                    case TC.Consts.geom.POLYGON:
                        const x1 = strokeHalfWidth;
                        const y1 = height - strokeHalfWidth;
                        const x2 = strokeHalfWidth;
                        const y2 = strokeHalfWidth;
                        const x3 = strokeHalfWidth + width * 0.8;
                        const y3 = strokeHalfWidth;
                        const x4 = width - strokeHalfWidth;
                        const y4 = height - strokeHalfWidth;
                        body = `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}" style="stroke:${style.strokeColor};stroke-width:${strokeWidth};fill:${style.fillColor};fill-opacity:${style.fillOpacity}" ${lineDashText}/>`;
                        break;
                    default:
                        body = `<rect x="${strokeHalfWidth}" x="${strokeHalfWidth}" width="${width - strokeWidth}" height="${height - strokeWidth}" style="stroke:${style.strokeColor};stroke-width:${strokeWidth};fill:${style.fillColor};fill-opacity:${style.fillOpacity}" ${lineDashText}/>`;
                        break;
                }
                result = 'data:image/svg+xml,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">${body}</svg>`);
            }
            return result;
        },

        /* 
        * addPathToTree: añade a un array a un árbol, cada elemento en un nivel anidado
        * Parameters: array, nodo de árbol, [índice]
        * Returns: último nodo insertado, null si ya existía la ruta
        */
        addArrayToTree: function addArrayToTree(path, treeNode, index) {
            var result = null;
            var found = false;
            index = index || 0;
            var name = path[index];
            if (name) {
                var n;
                for (var i = 0, len = treeNode.children.length; i < len; i++) {
                    n = treeNode.children[i];
                    if (n.name === name) {
                        found = true;
                        var r = addArrayToTree(path, n, index + 1);
                        if (r) {
                            result = r;
                        }
                        break;
                    }
                }
                if (!found) {
                    n = { name: name, title: name, uid: '/' + path.slice(0, index + 1).join('/'), children: [] };
                    treeNode.children.push(n);
                    result = n;
                }
            }
            return result;
        },

        parseCoords: function (text) {
            var result = null;

            var _parseGeoCoord = function (text) {
                var t = text;
                var result = {};
                result.type = TC.Consts.GEOGRAPHIC;
                var idx = t.indexOf('\u00B0');
                result.value = parseFloat(t.substr(0, idx));
                t = t.substr(idx + 1);
                idx = t.indexOf('\'');
                if (idx >= 0) {
                    var v = parseFloat(t.substr(0, idx)) / 60;
                    if (result.value >= 0) {
                        result.value += v;
                    }
                    else {
                        result.value -= v;
                    }
                    t = t.substr(idx + 1);
                    idx = t.indexOf('\'');
                    if (idx >= 0) {
                        v = parseFloat(t.substr(0, idx).replace(',', '.')) / 3600;
                        if (result.value >= 0) {
                            result.value += v;
                        }
                        else {
                            result.value -= v;
                        }
                    }
                }
                return result;
            };

            var _parseCoord = function (text) {
                var t = text.trim();
                // nnºnn'nn''N
                if (t.match(/^1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?\s*[NnSsWwOoEe]$/g)) {
                    switch (t[t.length - 1]) {
                        case 'S':
                        case 's':
                        case 'W':
                        case 'w':
                        case 'O':
                        case 'o':
                            t = '-' + t;
                            break;
                    }
                    t = t.substr(0, t.length - 1);
                    return _parseGeoCoord(t);
                }
                // +nnºnn'nn''
                if (t.match(/^[+-]?1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?$/g)) {
                    return _parseGeoCoord(t);
                }
                // nn.nn N
                if (t.match(/^1?\d{0,2}([.,]\d+)?\s*\u00B0?\s*[NnSsWwOoEe]$/g)) {
                    var result = { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.substr(0, t.length - 1).replace(',', '.')) };
                    if (t.match(/[SsWwOo]$/)) {
                        result.value = -result.value;
                    }
                    return result;
                }
                // +nn.nn
                if (t.match(/^[+-]?1?\d{0,2}([.,]\d+)?\s*\u00B0?$/g)) {
                    return { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.replace(',', '.')) };
                }
                // UTM
                if (t.match(/^\d{6,7}([.,]\d+)?$/g)) {
                    return { type: TC.Consts.UTM, value: parseFloat(t.replace(',', '.')) };
                }
                return null;
            };

            text = text.trim().toUpperCase();
            var xy = text.split(',');
            if (xy.length === 4) {
                xy = [xy.slice(0, 1).join('.'), xy.slice(2, 3).join('.')];
            }
            else if (xy.length === 1 || xy.length === 3) {
                xy = text.split(' ');
            }
            if (xy.length === 2) {
                var x = _parseCoord(xy[0]);
                var y = _parseCoord(xy[1]);
                if (x !== null && y !== null) {
                    result = [x, y];
                }
            }
            return result;
        },

        reproject: function (coords, sourceCrs, targetCrs) {
            var result;
            var multipoint = true;
            var multiring = true;
            var multipoly = true;
            if (Array.isArray(coords[0])) {
                if (Array.isArray(coords[0][0])) {
                    if (!Array.isArray(coords[0][0][0])) {
                        multipoly = false;
                        coords = [coords];
                    }
                }
                else {
                    multiring = false;
                    coords = [[coords]];
                }
            }
            else {
                multipoint = false;
                multiring = false;
                multipoly = false;
                coords = [[[coords]]];
            }
            TC.loadProjDef({ crs: sourceCrs, sync: true });
            TC.loadProjDef({ crs: targetCrs, sync: true });
            var sourcePrj = proj4(proj4.defs[sourceCrs]);
            var targetPrj = proj4(proj4.defs[targetCrs]);
            result = new Array(coords.length);
            coords.forEach(function (poly, pidx) {
                const rp = result[pidx] = [];
                poly.forEach(function (ring, ridx) {
                    const rr = rp[ridx] = [];
                    ring.forEach(function (coord, cidx) {
                        var point = proj4(sourcePrj, targetPrj, { x: coord[0], y: coord[1] });
                        if (targetPrj.oProj.units === TC.Consts.units.METERS) {
                            rr[cidx] = [Math.round(point.x), Math.round(point.y)];
                        } else {
                            rr[cidx] = [point.x, point.y];
                        }
                        if (coord.length > 2) {
                            rr[cidx][2] = coord[2];
                        }
                    });
                });
            });
            if (!multipoint) {
                result = result[0][0][0];
            }
            else if (!multiring) {
                result = result[0][0];
            }
            else if (!multipoly) {
                result = result[0];
            }
            return result;
        },

        getMetersPerDegree: function (extent) {
            var result = undefined;
            var R = 6370997; // m
            if (Array.isArray(extent) && extent.length >= 4) {
                var dLat = this.degToRad(extent[3] - extent[1]);
                var sindlat2 = Math.sin(dLat / 2);
                var a = sindlat2 * sindlat2;
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                result = R * c / (extent[3] - extent[1]);
            }
            return result;
        },

        radToDeg: function (rad) { // convert radians to degrees
            return rad * 180 / Math.PI;
        },
        degToRad: function (deg) { // convert degrees to radians
            return deg * Math.PI / 180;
        },
        mod: function (n) { // modulo for negative values
            return ((n % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        },

        getCRSCode: function (crs) {
            var result = null;
            crs = crs.trim();
            if (/^EPSG:\d{4,6}$/g.test(crs) || //formato EPSG
                /^urn:ogc:def:crs:EPSG:.*:\d{4,6}/g.test(crs) || // formato URN
                /http:\/\/www.opengis.net\/gml\/srs\/epsg.xml#\d{4,6}$/g.test(crs)) { // formato GML
                var match = crs.trim().match(/^.+[:#](\d{4,6})$/); // devuelve la parte numérica del código
                if (match) {
                    result = match[1];
                }
            }
            return result;
        },

        CRSCodesEqual: function (crs1, crs2) {
            if (crs1 === crs2) {
                return true;
            }
            var code1 = this.getCRSCode(crs1);
            var code2 = this.getCRSCode(crs2);
            return code1 !== null && code2 !== null && code1 === code2;
        },

        getLocaleString: function (locale, key, texts) {
            var result = key;
            if (TC.i18n && TC.i18n[locale]) {
                var text = TC.i18n[locale][key];
                if (text) {
                    result = text;
                    if (texts) {
                        for (var k in texts) {
                            result = result.replace('{' + k + '}', texts[k]);
                        }
                    }
                }
            }
            return result;
        },

        getSimpleMimeType: function (mimeType) {
            var result = '';
            if (mimeType) {
                var end = mimeType.indexOf(';');
                if (end > 0) {
                    mimeType = mimeType.substring(0, end);
                }
                result = mimeType;
            }
            return result;
        },

        getQueryStringParams: function (url) {
            var queryString;
            if (url) {
                var queryIdx = url.indexOf('?');
                if (queryIdx >= 0) {
                    queryString = url.substr(queryIdx);
                    var fragmentIdx = queryString.indexOf('#');
                    if (fragmentIdx >= 0) {
                        queryString = queryString.substr(0, fragmentIdx)
                    }
                }
                else {
                    queryString = '?';
                }
            }
            else {
                queryString = location.search;
            }
            var result = queryString.replace(/(^\?)/, '').split("&").map(function (elm) {
                return elm = elm.split("="), this[elm[0]] = elm[1], this
            }.bind({}))[0];
            delete result[''];
            return result;
        },

        getParamString: function (obj) {
            const arr = [];
            for (var key in obj) {
                arr[arr.length] = encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]);
            }
            return arr.join('&').replace(/%20/g, '+');
        },

        fastUnshift: function (a, elm) {
            var len = a.length;
            while (len) {
                a[len] = a[len - 1];
                len--;
            }
            a[0] = elm;
        },

        storage: {
            getCookie: function (key) {
                return TC.cookie(key);
            },
            setCookie: function (key, value, options) {
                return TC.cookie(key, value, options);
            },
            getLocalValue: function (key) {
                var result = null;
                if (localStorage && localStorage instanceof Storage) {
                    result = localStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setLocalValue: function (key, value) {
                if (localStorage && localStorage instanceof Storage) {
                    if (value === undefined) {
                        localStorage.removeItem(key);
                    }
                    else {
                        localStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            },
            getSessionLocalValue: function (key) {
                var result = null;
                if (sessionStorage && sessionStorage instanceof Storage) {
                    result = sessionStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setSessionLocalValue: function (key, value) {
                if (sessionStorage && sessionStorage instanceof Storage) {
                    if (value === undefined) {
                        sessionStorage.removeItem(key);
                    }
                    else {
                        sessionStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            }
        },
        detectFirefox: function () {
            if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent)) //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);
                return new Number(RegExp.$1); // capture x.x portion and store as a number
            else
                return false;
        },
        detectIE: function () {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            // GLS: 13/02/2019. Comento lo que respecta a Edge, no tiene sentido meterlo en el mismo saco que un navegador obsoleto.
            // No lo comento porque en la mesa no hay quorum.
            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // IE 12 => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },
        detectChrome: function () {
            return window.chrome;

        },
        detectSafari: function () {
            return !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);
        },
        detectMouse: function () {
            const matchesCoarse = matchMedia('(pointer:coarse)').matches;
            const matchesFine = matchMedia('(pointer:fine)').matches;
            if (matchesCoarse && matchesFine) {
                return true;
            }
            if (matchesCoarse && !matchesFine) {
                var testHover = function () {
                    //console.log('estamos en testHover');
                    var mq = '(hover: hover)',
                        hover = !TC.browserFeatures.touch(), // fallback if mq4 not supported: no hover for touch
                        mqResult;

                    mqResult = window.matchMedia(mq);
                    //console.log('resultado de window.matchMedia(mq): ' + mqResult.media);
                    //console.log('mq: ' + mq);
                    if (mqResult.media === mq) {
                        //console.log('es igual');
                        // matchMedia supports hover detection, so we rely on that
                        hover = mqResult.matches;
                        //console.log('va retornar: ' + hover);
                    }

                    return hover;
                };

                if (testHover())
                    return true;
                else return false;
            }
            if (!matchesCoarse && matchesFine) {
                return true;
            }
            if (matchMedia('(pointer:none)').matches) {
                return false;
            }
            if (!TC.browserFeatures.touch()) {
                return true;
            }
        },
        detectAndroid: function () {
            return navigator.userAgent.match(/Android/i);
        },
        detectBlackBerry: function () {
            return navigator.userAgent.match(/BlackBerry/i);
        },
        detectIOS: function () {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        detectMobileWindows: function () {
            return navigator.userAgent.match(/IEMobile/i);
        },
        detectMobile: function () {
            return (TC.Util.detectAndroid() || TC.Util.detectIOS() || TC.Util.detectMobileWindows() || TC.Util.detectBlackBerry());
        },
        getBrowser: function () {
            if (!window.UAParser) {
                TC.syncLoadJS(TC.apiLocation + TC.Consts.url.UA_PARSER);
            }

            var parser = new UAParser();
            var browser = parser.getBrowser();
            return { name: browser.name, version: browser.major };
        },
        getElementByNodeName: function (parentNode, nodeName) {
            var colonIndex = nodeName.indexOf(":");
            var tag = nodeName.substr(colonIndex + 1);
            var nodes = parentNode.getElementsByTagNameNS("*", tag);

            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeName == nodeName)
                    return nodes;
            }
            return undefined;
        },
        addURLParameters: function (url, parameters) {
            if (!parameters) {
                return url;
            }
            var toAdd = Object.keys(parameters).map(function (key) {
                return encodeURIComponent(key) + '=' + (parameters[key] ? encodeURIComponent(parameters[key]) : '');
            }).join('&');

            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var params = urlparts[1].split(/[&;]/g);
                params.push(toAdd);

                url = urlparts[0] + '?' + params.join('&');
                return url;
            } else {
                urlparts = url.split('#');
                if (urlparts.length >= 2) {
                    urlparts.shift();
                    url = urlparts[0] + '?' + toAdd + '#' + urlparts.join('#');
                    return url;
                }
                else {
                    url = url + '?' + toAdd;
                    return url;
                }
            }
        },
        removeURLParameter: function (url, parameter) {
            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var prefix = encodeURIComponent(parameter.toLowerCase()) + '=';
                var pars = urlparts[1].toLowerCase().split(/[&;]/g);

                //reverse iteration as may be destructive
                for (var i = pars.length; i-- > 0;) {
                    //idiom for string.startsWith
                    if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                        pars.splice(i, 1);
                    }
                }

                url = urlparts[0] + '?' + pars.join('&');
                return url;
            } else {
                return url;
            }
        },

        showModal: function (contentNode, options) {
            options = options || {};

            contentNode.hidden = false;
            if (window.$ && contentNode instanceof $) {
                contentNode = contentNode.get(0);
            }
            contentNode.classList.add(TC.Consts.classes.VISIBLE);
            const closeButton = contentNode.querySelectorAll('.tc-modal-close');
            if (closeButton && closeButton.length > 0) {
                for (var i = 0; i < closeButton.length; i++) {
                    var closeCallback = modalCloseHandlers.get(closeButton[i]);
                    if (closeCallback) {
                        modalCloseHandlers.delete(closeButton[i]);
                    }
                    else {
                        closeCallback = function (e) {
                            e.stopPropagation();
                            return TC.Util.closeModal(options.closeCallback, e.target);
                        };
                        modalCloseHandlers.set(closeButton[i], closeCallback);
                    }
                    modalCloseHandlers.set(closeButton[i], closeCallback);
                    closeButton[i].addEventListener('click', closeCallback);
                    if (Util.isFunction(options.openCallback)) {
                        options.openCallback();
                    }
                }
            }
        },

        closeModal: function (callback, target) {

            const hide = function (modal) {
                modal.classList.remove(TC.Consts.classes.VISIBLE);
            };

            var modal;
            if (target) {
                modal = target;
                while (modal && !modal.matches('.tc-modal')) {
                    modal = modal.parentElement;
                }

                hide(modal);
            } else {
                Array.prototype.forEach.call(document.querySelectorAll('.tc-modal'), function (modal) {
                    hide(modal);
                });
            }

            if (callback) {
                callback();
            }
        },

        closeAlert: function (btn) {
            var elm = btn;
            do {
                elm = elm.parentElement;
                if (elm.matches('.tc-alert')) {
                    elm.style.display = 'none';
                }
            }
            while (elm);
        },

        swipe: function (target, options) {
            const addListeners = function (handlers) {
                target.addEventListener('mousedown', handlers.start);
                target.addEventListener('touchstart', handlers.start);
                target.addEventListener('mouseup', handlers.end);
                target.addEventListener('touchend', handlers.end);
            };

            if (options === 'disable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    target.removeEventListener('mousedown', handlers.start);
                    target.removeEventListener('touchstart', handlers.start);
                    target.removeEventListener('mouseup', handlers.end);
                    target.removeEventListener('touchend', handlers.end);
                }
                return;
            }
            else if (options === 'enable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    addListeners(handlers);
                }
                return;
            }

            options = options || {};
            const minDistance = options.minDistance || 30;
            const maxCrossDistance = options.maxCrossDistance || 30;
            const maxAllowedTime = options.maxAllowedTime || 1000;
            var touchStartCoords = { 'x': -1, 'y': -1 }, // X and Y coordinates on mousedown or touchstart events.
                touchEndCoords = { 'x': -1, 'y': -1 },// X and Y coordinates on mouseup or touchend events.
                startTime = 0,// Time on swipeStart
                elapsedTime = 0;// Elapsed time between swipeStart and swipeEnd

            const getDirection = function (startCoords, endCoords) {
                const dx = endCoords.x - startCoords.x;
                const dy = endCoords.y - startCoords.y;
                const adx = Math.abs(dx);
                const ady = Math.abs(dy);
                if (adx > ady && adx > minDistance && ady <= maxCrossDistance) {
                    return dx < 0 ? 'left' : 'right';
                }
                if (ady > adx && ady > minDistance && adx <= maxCrossDistance) {
                    return dy < 0 ? 'up' : 'down';
                }
                return 'none';
            };

            const mustSwipe = function (e) {
                if (options.noSwipe) {
                    var elm = e.target;
                    while (elm && elm !== target) {
                        if (elm.matches && elm.matches(options.noSwipe)) {
                            return false;
                        }
                        elm = elm.parentNode;
                    }
                }
                return true;
            };

            const swipeStart = function (e) {
                if (mustSwipe(e)) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchStartCoords.x = e.pageX;
                    touchStartCoords.y = e.pageY;
                    startTime = new Date().getTime();
                }
            };

            const swipeEnd = function (e) {
                if (startTime) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchEndCoords.x = e.pageX;
                    touchEndCoords.y = e.pageY;
                    elapsedTime = new Date().getTime() - startTime;
                    if (elapsedTime <= maxAllowedTime) {
                        const callback = options[getDirection(touchStartCoords, touchEndCoords)];
                        if (callback) {
                            callback.call(target);
                        }
                    }
                    startTime = 0;
                }
            };

            const handlers = {
                start: swipeStart,
                end: swipeEnd
            };
            swipeHandlers.set(target, handlers);
            addListeners(handlers);
        },

        getParameterByName: function (name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)", "i"),
                results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        },

        getLocaleUserChoice: function (options) {
            var result = 'en-US';
            options = options || {};
            var cookieName = options.cookieName || 'SITNA.language';
            var paramName = options.paramName || 'lang';
            // Obtenemos preferencia de lenguaje
            var browserLanguage = (navigator.languages && navigator.languages.length) ? navigator.languages[0] : navigator.language || navigator.userLanguage;
            var lang = TC.Util.getParameterByName(paramName) || TC.Util.storage.getCookie(cookieName) || browserLanguage;
            var hyphenIdx = lang.indexOf('-');
            if (hyphenIdx >= 0) {
                lang = lang.substr(0, hyphenIdx);
            }
            var expirationDate = new Date(new Date().getTime() + 365 * 24 * 60 * 60 * 1000);
            TC.Util.storage.setCookie(cookieName, lang, { expires: expirationDate });

            switch (lang) {
                case 'eu':
                    result = 'eu-ES';
                    break;
                case 'es':
                    result = 'es-ES';
                    break;
                default:
                    result = 'en-US';
                    break;
            }
            return result;
        },

        getValidFilename: function (filename) {
            return (filename || '').replace(/[/\\?%*:|"<>]/g, '-');
        },

        downloadBlob: function (filename, blob) {
            var link = document.createElement("a");
            if (link.download !== undefined) {
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", TC.Util.getValidFilename(filename));
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        downloadFile: function (filename, type, data) {
            var blob = new Blob([data], { type: type });
            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        downloadDataURI: function (filename, type, dataURI) {
            var binary = atob(dataURI.split(',')[1]);

            var array = [];
            for (var i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            var blob = new Blob([new Uint8Array(array)], { type: type });

            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        /**
         * Acorta una URL utilizando el servicio de Bit.ly. No funciona para URLs locales.
         */
        shortenUrl: function (url) {
            return new Promise(function (resolve, reject) {
                TC.ajax({
                    url: "https://api-ssl.bitly.com/v3/shorten",
                    data: { access_token: "6c466047309f44bd8173d83e81491648b243ee3d", longUrl: url },
                })
                    .then(function (response) {
                        resolve(response.data);
                    })
                    .catch(function (e) {
                        reject(e);
                    });
            });
        },

        /**
         * Convierte a Base64.
         */
        utf8ToBase64: function (str) {
            return window.btoa(unescape(encodeURIComponent(str)));
        },

        /**
         * Decodifica un string en Base64.
         */
        base64ToUtf8: function (str) {
            var result;
            try {
                result = decodeURIComponent(escape(window.atob(str)));
            }
            catch (error) {
                result = null;
            }
            return result;
        },

        colorArrayToString: function (color) {
            if (Array.isArray(color)) {
                color = color
                    .slice(0, 3)
                    .reduce(function (prev, cur) {
                        const str = cur.toString(16);
                        return prev + '00'.substring(0, 2 - str.length) + str;
                    }, '#');
            }
            return color;
        },

        // Generic helper function that can be used for the three operations:        
        operation: function (list1, list2, comparerFn, operationIsUnion) {
            var result = [];

            for (var i = 0; i < list1.length; i++) {
                var item1 = list1[i],
                    found = false;
                for (var j = 0; j < list2.length; j++) {
                    if (comparerFn(item1, list2[j])) {
                        found = true;
                        break;
                    }
                }
                if (found === operationIsUnion) {
                    result.push(item1);
                }
            }
            return result;
        },
        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        // Following functions are to be used:
        inBoth: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, true);
        },

        inFirstOnly: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, false);
        },

        inSecondOnly: function (list1, list2, comparerFn) {
            return this.inFirstOnly(list2, list1, comparerFn);
        },

        toDataUrl: function (canvas, backgroundColour) {
            var defaultOptions = { type: 'image/png', encoderOptions: 0.92 };

            var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions,
                type = _ref.type,
                encoderOptions = _ref.encoderOptions;

            var context = canvas.getContext('2d');

            if (!context) {
                return '';
            }

            var width = canvas.width;
            var height = canvas.height;

            var data = context.getImageData(0, 0, width, height);
            var compositeOperation = context.globalCompositeOperation;

            if (backgroundColour) {

                context.globalCompositeOperation = 'destination-over';
                context.fillStyle = backgroundColour;
                context.fillRect(0, 0, width, height);
            }

            var imageData = canvas.toDataURL(type, encoderOptions);

            if (backgroundColour) {
                context.clearRect(0, 0, width, height);
                context.putImageData(data, 0, 0);
                context.globalCompositeOperation = compositeOperation;
            }

            return imageData;
        },

        imgToDataUrl: function (src, outputFormat) {

            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function () {
                    var canvas = createCanvas(img);
                    var dataURL;

                    try {
                        dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                            type: outputFormat || 'image/jpeg',
                            encoderOptions: 1.0
                        });
                        resolve({ dataUrl: dataURL, canvas: canvas });
                    } catch (error) {
                        img.src = TC.proxify(src);
                    }
                };

                img.onerror = function (error) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', TC.proxify(src), true);
                    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function (e) {
                        if (this.status === 200) {
                            var uInt8Array = new Uint8Array(this.response);
                            var i = uInt8Array.length;
                            var binaryString = new Array(i);
                            while (i--) {
                                binaryString[i] = String.fromCharCode(uInt8Array[i]);
                            }
                            var data = binaryString.join('');
                            var type = xhr.getResponseHeader('content-type');
                            if (type.indexOf('image') === 0) {
                                img.src = 'data:' + type + ';base64,' + window.btoa(data);
                                img.onload = function () {
                                    var canvas = createCanvas(img);
                                    dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                                        type: outputFormat || 'image/jpeg',
                                        encoderOptions: 1.0
                                    });
                                    resolve({ dataUrl: dataURL, canvas: canvas });
                                }
                            }
                        }
                    };
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4) {
                            if (xhr.status !== 200) {
                                reject(Error('HTTP error ' + xhr.status));
                            }
                        }
                    };

                    xhr.send();
                };

                img.src = src;
                if (img.complete || img.complete === undefined) {
                    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                    img.src = src;
                }
            });
        },

        imgTagToDataUrl: function (img, outputFormat) {
            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            var canvas = createCanvas(img);
            var dataURL;

            try {
                dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                    type: outputFormat || 'image/jpeg',
                    encoderOptions: 1.0
                });
                return { base64: dataURL, canvas: canvas };
            } catch (error) {
                return null;
            }
        },

        addToCanvas: function (canvas, img, position, size) {
            var newCanvas = TC.Util.cloneCanvas(canvas);
            var context = newCanvas.getContext('2d');

            return new Promise(function (resolve, reject) {
                var newImage = new Image();
                img.crossOrigin = 'anonymous';
                newImage.src = img;
                newImage.onload = function () {
                    if (size) {
                        context.drawImage(newImage, position.x || 0, position.y || 0, size.width, size.height);
                    } else {
                        context.drawImage(newImage, position.x || 0, position.y || 0);
                    }
                    resolve(newCanvas);
                }
            });
        },

        cloneCanvas: function (oldCanvas) {
            //create a new canvas
            var newCanvas = document.createElement('canvas');
            var context = newCanvas.getContext('2d');

            //set dimensions
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;

            //apply the old canvas to the new one
            context.drawImage(oldCanvas, 0, 0);

            //return the new canvas
            return newCanvas;
        },

        calculateAspectRatioFit: function (srcWidth, srcHeight, maxWidth, maxHeight) {
            var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);

            return { width: srcWidth * ratio, height: srcHeight * ratio };
        },

        getFormattedDate: function (date, hasTime) {
            function pad(s) { return (s < 10) ? '0' + s : s; }

            var d = new Date(date);
            return [d.getFullYear(), pad(d.getMonth() + 1), pad(d.getDate())].concat(hasTime ? ["_", pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())] : []).join('');

        },

        replaceAccent: function (t) {
            var translate = {
                "ä": "a", "ö": "o", "ü": "u",
                "Ä": "A", "Ö": "O", "Ü": "U",
                "á": "a", "é": "e", "i": "i", "ó": "o", "ú": "u",
                "Á": "A", "É": "E", "Í": "I", "Ó": "O", "Ú": "U",
                "ñ": "n", "Ñ": "N"
            };
            return t.replace(/[öäüÖÄÜáéíóúÁÉÍÓÚñÑ]/g, function (match) {
                return translate[match];
            });
        },

        downloadFileForm: async function (url, data) {
            var download = async function (url, data) {

                var response = await new Promise(function (resolve, reject) {
                    const request = new XMLHttpRequest();
                    request.responseType = "blob";
                    request.open("POST", url);
                    request.setRequestHeader('Content-Type', 'application/xml; charset=UTF-8');

                    request.onreadystatechange = function (e) {
                        if (request.readyState === 4) { // DONE
                            if (request.status !== 200) {
                                reject({
                                    status: request.status,
                                    msg: request.statusText,
                                    url: url
                                });
                            } else {

                                try {
                                    //URI: Miro si devuelve una cabecera content-disposition attachment. Si es asi uso el filenae como nombre de fichero. Esta descarga seguramente venga
                                    //de un proxy con postproceso de zippeado
                                    const contentDispositionHeader = request.getResponseHeader("Content-disposition");
                                    var filename = "";
                                    if (contentDispositionHeader) {
                                        filename = contentDispositionHeader.split("; ")[1].substring(9);
                                        if (contentDispositionHeader.split("; ")[0] !== "attachment") {
                                            filename = filename.substring(0, filename.lastIndexOf("."));
                                        }
                                    }
                                    resolve({ data: request.response, contentType: request.getResponseHeader("Content-type"), filename: filename });
                                }
                                catch (error) {
                                    reject(error);
                                }
                            }
                        }
                    };

                    try {
                        request.send(data);
                    } catch (error) {
                        reject(error);
                    }
                });
                var format = "";
                if (response.data.type.indexOf("kml") >= 0)
                    format = ".kml";
                else if (response.data.type.indexOf("json") >= 0)
                    format = ".geojson";
                else if (response.data.type.indexOf("xml") >= 0) {
                    format = ".gml";
                    if (/outputFormat="\S{1,}"/.exec(data)[0].includes(".kml") || /outputFormat="\S{1,}"/.exec(data)[0].includes("shape-zip")) {
                        throw { key: TC.Consts.DownloadError.MIMETYPE_NOT_SUPORTED, url: url, data: data, format: /outputFormat="\S{1,}"/.exec(data)[0] };
                    }
                }
                TC.Util.downloadFile((response.filename ? response.filename : TC.getUID()) + format, response.contentType, response.data);

            };
            var htmlObj = [];
            var _err;
            if (Array.isArray(url)) {
                var arrDownloads = url;
                for (var i = 0; i < arrDownloads.length; i++) {
                    try {
                        await download(arrDownloads[i].url, arrDownloads[i].data);
                    }
                    catch (err) {
                        _err = err;
                    }
                }
                if (_err) {
                    throw _err;
                }
            }
            else {
                download(url, data);
            }
        },

        WFSQueryBuilder: function (layers, filter, capabilities, outputFormat, onlyHits, srsName, maxFeatures) {
            const getSRSAttribute = function () {
                if (srsName) {
                    return ' srsName="' + srsName + '"'
                }
                else
                    return '';
            }
            if (!Array.isArray(layers) && !(layers instanceof Object))
                layers = [layers];

            var queryHeader = 'xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd" ' +
                ' service="WFS" {resultType} {format} ';
            switch (capabilities.version) {
                case "1.0.0":
                case "1.1.0":
                    queryHeader += 'xmlns:gml="http://www.opengis.net/gml" xmlns:wfs="http://www.opengis.net/wfs" ';
                    break;
                case "2.0.0":
                    queryHeader += 'xmlns:wfs=\"http://www.opengis.net/wfs/2.0\" xmlns:gml=\"http://www.opengis.net/gml/3.2\" ';
                    break;
            }
            for (var i in capabilities) {
                if (typeof (capabilities[i]) === "string" && i.indexOf("gml") < 0 && capabilities[i].indexOf("wfs") < 0)
                    queryHeader += (i + '="' + capabilities[i] + '" ');
            }

            var query = '<wfs:GetFeature ' + queryHeader.format({ resultType: (onlyHits ? 'resultType="hits"' : ''), format: 'outputFormat="' + outputFormat + '"' }) + (capabilities.version !== "2.0.0" && maxFeatures ? ' maxFeatures="' + maxFeatures + '"' : '') + '>';
            var queryBody = '';
            if (Array.isArray(layers)) {
                var queryItem = '<wfs:Query typeName' + (capabilities.version === "2.0.0" ? 's' : '') + '="{typeName}"' + getSRSAttribute() + '>{filter}</wfs:Query>';
                if (Array.isArray(layers))
                    layers.forEach(function (value) {
                        queryBody += queryItem.format({ typeName: value, filter: (filter && filter instanceof TC.filter.Filter ? filter.getText(capabilities.version) : "") });
                    });
            }
            else {
                var queryItem = '';
                for (var layer in layers) {
                    var queryItem = ('<wfs:Query typeName' + (capabilities.version === "2.0.0" ? 's' : '') + '="{typeName}"' + getSRSAttribute() + '>{filter}</wfs:Query>');
                    let filter = layers[layer]
                    queryBody += queryItem.format({ typeName: layer, filter: (filter && filter instanceof TC.filter.Filter ? filter.getText(capabilities.version) : "") });
                }
            }

            query += queryBody + '</wfs:GetFeature>'
            return query;
        },

        WFSFilterBuilder: function (feature, version, srsName) {
            var filter = '';
            if (Util.isPlainObject(feature)) {
                filter = '<{prefix}:Filter><{prefix}:Intersects><fes:ValueReference></fes:ValueReference><{prefix}:Function name="querySingle"><{prefix}:Literal>{clipLayer}</{prefix}:Literal><{prefix}:Literal>{geometryName}</{prefix}:Literal><{prefix}:Literal>{where}</{prefix}:Literal></{prefix}:Function></{prefix}:Intersects></{prefix}:Filter>'
                    .format({ prefix: (version === "2.0.0" ? "fes" : "ogc"), "clipLayer": feature.clipLayer, "geometryName": feature.geometryName, "where": feature.where })
            }
            else {
                switch (true) {
                    case !feature:
                        break;
                    case Array.isArray(feature)://bbox
                        var gmlEnvelope = ('<gml:Envelope>' +
                            '<gml:lowerCorner>{lowerCorner}</gml:lowerCorner>' +
                            '<gml:upperCorner>{upperCorner}</gml:upperCorner>' +
                            '</gml:Envelope>').format({ lowerCorner: (feature[0] + ' ' + feature[1]), upperCorner: (feature[2] + ' ' + feature[3]) });
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:BBOX>' + gmlEnvelope + '</ogc:BBOX></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:BBOX>' + gmlEnvelope + '</fes:BBOX></fes:Filter>';
                                break;
                        }
                        break;
                    case feature instanceof TC.Feature:
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:Intersects><ogc:PropertyName></ogc:PropertyName>' + TC.Util.writeGMLGeometry(feature, { version: "2.0", srsName: srsName }) + '</ogc:Intersects></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:Intersects><fes:ValueReference></fes:ValueReference>' + TC.Util.writeGMLGeometry(feature, { version: "3.2", srsName: srsName }) + '</fes:Intersects></fes:Filter>';
                                break;
                        }

                        break;
                    default:
                        TC.error("Geometr\u00eda no v\u00e1lida");
                        break;
                }
            }

            return filter;
        },

        writeGMLGeometry: function (feature, options) {
            options = options || {};
            const gmlVersion = options.version;
            const getSRSName = function () {
                if (options.srsName) {
                    return ' srsName="' + options.srsName + '"'
                }
                else
                    return '';
            };
            var getGmlCoordinates = function (coords) {
                var result;
                if (gmlVersion.indexOf('3') === 0) {
                    result = coords.toString();
                    while (result.indexOf(",") >= 0) {
                        result = result.replace(",", " ");
                    }
                }
                else {
                    result = coords.map(function (coord) {
                        return coord.join(',');
                    }).join(' ');
                }
                return result;
            };

            switch (gmlVersion) {
                case "3.1.1":
                    break;
                case "3.2":
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString srsDimension=\"2\"" + getSRSName() + "><gml:posList>" +
                                getGmlCoordinates(feature.geometry) +
                                "</gml:posList></gml:LineString>";
                            break;
                            break;
                        default:
                            return "<gml:Polygon srsDimension=\"2\"" + getSRSName() + "><gml:exterior><gml:LinearRing><gml:posList>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>";
                            break;
                    }
                    break;
                case "2.0":
                default:
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString" + getSRSName() + "><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LineString>";
                            break;
                        default:
                            return "<gml:Polygon" + getSRSName() + "><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>";
                            break;
                    }
                    break;
            }
        },

        isServiceWorker: function () {
            if (navigator.serviceWorker) {
                if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        },

        isSameOriginByLocation: function (uri, location) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var uProtocol = urlParts[1];
                result = (uProtocol == location.protocol || uProtocol == undefined) && urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        isSameProtocol: function (uri, location) {
            if (uri.match(/^(\/\/)/i)) {
                return true;
            }
            var protocolRegex = /^(https?:\/\/)/i;
            var uriProtocol = uri.match(protocolRegex);
            if (uriProtocol && uriProtocol.length > 1) {
                var locationProtocol = location.match(protocolRegex);
                if (locationProtocol && locationProtocol.length > 1) {
                    return uriProtocol[0].trim() === locationProtocol[0].trim();
                }
            }

            return false;
        },

        consoleRegister: function (msg) {
            if (TC.isDebug) {
                console.log(msg);
            }
        },

        getSorterByProperty: function (propName) {
            return function (a, b) {
                if (a[propName] > b[propName]) {
                    return 1;
                }
                if (a[propName] < b[propName]) {
                    return -1;
                }
                return 0;
            };
        },

        getSoundexDifference: function (a, b) {
            var res = 0

            for (var i = 0; i < a.length; i++) {
                if (a.charAt(i) == b.charAt(i)) {
                    res++;
                }
            }

            return res;
        },

        toAbsolutePath: function (href) {
            var link = document.createElement("a");
            link.href = href;
            return link.href;
        },

        //getRenderedHtml: function (templateId, template, data, callback) {
        //    return new Promise(function (resolve, reject) {
        //        var render = function () {
        //            if (dust.cache[templateId]) {
        //                dust.render(templateId, data, function (err, out) {
        //                    if (err) {
        //                        TC.error(err);
        //                        reject(Error(err));
        //                    }
        //                    else {
        //                        if (Util.isFunction(callback)) {
        //                            callback(out);
        //                        }
        //                        resolve(out);
        //                    }
        //                });
        //            }
        //        };
        //        TC.loadJSInOrder(
        //            !window.dust,
        //            TC.url.templating,
        //            function () {
        //                if (!dust.cache[templateId]) {
        //                    if (typeof template === 'string') {
        //                        TC.ajax({
        //                            url: template,
        //                            method: "GET",
        //                            responseType: 'text'
        //                        })
        //                            .then(function (response) {
        //                                const html = response.data;
        //                                var tpl = dust.compile(html, templateId);
        //                                dust.loadSource(tpl);
        //                                render();
        //                            })
        //                            .catch(function (err) {
        //                                console.log("Error fetching template: " + err)
        //                            });
        //                    }
        //                    else if (Util.isFunction(template)) {
        //                        template();
        //                        render();
        //                    }
        //                }
        //                else {
        //                    render();
        //                }
        //            }
        //        );
        //    });
        //},

        explodeGeometry: function (obj) {
            const origin = obj.origin;
            const iterationFunction = function (elm, idx, arr) {
                if (Array.isArray(elm)) {
                    elm.forEach(iterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = elm + origin[0];
                    }
                    if (idx === 1) {
                        arr[1] = elm + origin[1];
                    }
                }
            };
            obj.geom.forEach(iterationFunction);
            return obj.geom;
        },

        cloneMappingFunction: function (elm) {
            if (Array.isArray(elm)) {
                return elm.map(TC.Util.cloneMappingFunction);
            }
            return elm;
        },

        isGeometry: function (type) {
            switch (type) {
                case 'gml:LinearRingPropertyType':
                case 'gml:PolygonPropertyType':
                case 'gml:MultiPolygonPropertyType':
                case 'gml:MultiSurfacePropertyType':
                case 'gml:LineStringPropertyType':
                case 'gml:MultiLineStringPropertyType':
                case 'gml:PointPropertyType':
                case 'gml:MultiPointPropertyType':
                case 'gml:BoxPropertyType':
                case 'gml:GeometryCollectionPropertyType':
                case 'gml:GeometryAssociationType':
                case 'gml:GeometryPropertyType':
                case 'gml:MultiCurvePropertyType':
                case 'gml:CurvePropertyType':
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        },

        compactGeometry: function (geometry, precision) {
            const origin = [Number.MAX_VALUE, Number.MAX_VALUE];
            const newGeom = geometry.map(TC.Util.cloneMappingFunction);
            const firstIterationFunction = function (elm, idx) {
                if (Array.isArray(elm)) {
                    elm.forEach(firstIterationFunction);
                }
                else {
                    if (idx === 0 && elm < origin[0]) {
                        origin[0] = elm;
                    }
                    else if (idx === 1 && elm < origin[1]) {
                        origin[1] = elm;
                    }
                }
            };
            newGeom.forEach(firstIterationFunction);

            const round = function (val) {
                return Math.round(val * precision) / precision;
            }
            origin[0] = round(origin[0]);
            origin[1] = round(origin[1]);
            const secondIterationFunction = function (elm, idx, arr) {
                if (Array.isArray(elm)) {
                    elm.forEach(secondIterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = round(elm - origin[0]);
                    }
                    if (idx === 1) {
                        arr[1] = round(elm - origin[1]);
                    }
                }
            };
            newGeom.forEach(secondIterationFunction);
            return {
                origin: origin,
                geom: newGeom
            }
        },

        hasStyleOptions: function (options) {
            return options.hasOwnProperty('strokeColor') ||
                options.hasOwnProperty('strokeWidth') ||
                options.hasOwnProperty('fillColor') ||
                options.hasOwnProperty('strokeOpacity') ||
                options.hasOwnProperty('fillOpacity') ||
                options.hasOwnProperty('url') ||
                options.hasOwnProperty('radius') ||
                options.hasOwnProperty('anchor') ||
                options.hasOwnProperty('width') ||
                options.hasOwnProperty('height') ||
                options.hasOwnProperty('labelOutlineWidth') ||
                options.hasOwnProperty('labelOutlineColor') ||
                options.hasOwnProperty('labelOffset') ||
                options.hasOwnProperty('fontColor') ||
                options.hasOwnProperty('fontSize');
        },

        formatCoord: function (x, nDecimales) {
            return x.toLocaleString(TC.Util.getLocaleUserChoice(), { maximumFractionDigits: nDecimales });

            // No respeta el formato de los números según el idioma
            //var result;            
            //result = x.toFixed(nDecimales);
            //if (nDecimales <= 3) {
            //    result = result.replace(/\B(?=(\d{3})+(?!\d))/g, "|");
            //}

            //result = result.replace(".", ",").replace(/\|/g, ".");
            //return result;
        }
    };
    String.prototype.format = function () {
        var str = this.toString();
        if (!arguments.length)
            return str;
        var args = typeof arguments[0],
            args = (("string" == args || "number" == args) ? arguments : arguments[0]);
        for (arg in args)
            str = str.replace(RegExp("\\{" + arg + "\\}", "gi"), args[arg]);
        return str;
    };
    var fncOvelaps = function (elem1, elem2, comparisonFnc) {
        return comparisonFnc(elem1.getBoundingClientRect(), elem2.getBoundingClientRect());
    }
    if (this.HTMLElement) {
        HTMLElement.prototype.colliding = function (other) {
            return fncOvelaps(this, other, function (rect1, rect2) {
                return !(
                    rect1.top > rect2.bottom ||
                    rect1.right < rect2.left ||
                    rect1.bottom < rect2.top ||
                    rect1.left > rect2.right
                );
            });
        };
        HTMLElement.prototype.containing = function (other) {
            fncOvelaps(this, other, function (rect1, rect2) {
                return !(
                    rect1.left <= rect2.left &&
                    rect2.left < rect1.width &&
                    rect1.top <= rect2.top &&
                    rect2.top < rect1.height
                );
            });
        };
        HTMLElement.prototype.inside = function (other) {
            return fncOvelaps(this, other, function (rect1, rect2) {
                return (
                    ((rect2.top <= rect1.top) && (rect1.top <= rect2.bottom)) &&
                    ((rect2.top <= rect1.bottom) && (rect1.bottom <= rect2.bottom)) &&
                    ((rect2.left <= rect1.left) && (rect1.left <= rect2.right)) &&
                    ((rect2.left <= rect1.right) && (rect1.right <= rect2.right))
                );
            });
        };
    }
    return Util;
});

/**
 * LoadJS descargado de https://github.com/muicss/loadjs
 * @version 3.5.2
 * @ignore
 */
loadjs = function () { var l = function () { }, c = {}, f = {}, u = {}; function o(e, n) { if (e) { var t = u[e]; if (f[e] = n, t) for (; t.length;)t[0](e, n), t.splice(0, 1) } } function s(e, n) { e.call && (e = { success: e }), n.length ? (e.error || l)(n) : (e.success || l)(e) } function h(t, r, i, c) { var o, s, e = document, n = i.async, f = (i.numRetries || 0) + 1, u = i.before || l, a = t.replace(/^(css|img)!/, ""); c = c || 0, /(^css!|\.css$)/.test(t) ? (o = !0, (s = e.createElement("link")).rel = "stylesheet", s.href = a) : /(^img!|\.(png|gif|jpg|svg)$)/.test(t) ? (s = e.createElement("img")).src = a : ((s = e.createElement("script")).src = t, s.async = void 0 === n || n), !(s.onload = s.onerror = s.onbeforeload = function (e) { var n = e.type[0]; if (o && "hideFocus" in s) try { s.sheet.cssText.length || (n = "e") } catch (e) { 18 != e.code && (n = "e") } if ("e" == n && (c += 1) < f) return h(t, r, i, c); r(t, n, e.defaultPrevented) }) !== u(t, s) && e.head.appendChild(s) } function t(e, n, t) { var r, i; if (n && n.trim && (r = n), i = (r ? t : n) || {}, r) { if (r in c) throw "LoadJS"; c[r] = !0 } !function (e, r, n) { var t, i, c = (e = e.push ? e : [e]).length, o = c, s = []; for (t = function (e, n, t) { if ("e" == n && s.push(e), "b" == n) { if (!t) return; s.push(e) } --c || r(s) }, i = 0; i < o; i++)h(e[i], t, n) }(e, function (e) { s(i, e), o(r, e) }, i) } return t.ready = function (e, n) { return function (e, t) { e = e.push ? e : [e]; var n, r, i, c = [], o = e.length, s = o; for (n = function (e, n) { n.length && c.push(e), --s || t(c) }; o--;)r = e[o], (i = f[r]) ? n(r, i) : (u[r] = u[r] || []).push(n) }(e, function (e) { s(n, e) }), t }, t.done = function (e) { o(e, []) }, t.reset = function () { c = {}, f = {}, u = {} }, t.isDefined = function (e) { return e in c }, t }();

var TC = TC || {};
/*
 * Initialization
 */
TC.version = '2.1.0 [2020-3-16 15:28:36]';
(function () {
    if (!TC.apiLocation) {
        var src;
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
    }
})();

if (!TC.Consts) {

    TC.Consts = {};
    TC.Consts.OLNS = 'ol';
    TC.Consts.PROJ4JSOBJ = 'proj4';
    TC.Consts.GEOGRAPHIC = 'geographic';
    TC.Consts.UTM = 'UTM';
    TC.Consts.OLD_BROWSER_ALERT = 'TC.oldBrowserAlert';
    TC.Consts.CLUSTER_ANIMATION_DURATION = 200;
    TC.Consts.ZOOM_ANIMATION_DURATION = 300;
    TC.Consts.URL_MAX_LENGTH = 2048;
    TC.Consts.METER_PRECISION = 0;
    TC.Consts.DEGREE_PRECISION = 5;
    TC.Consts.EXTENT_TOLERANCE = 0.9998;/*URI: debido al redondeo del extente en el hash se obtiene un nivel de resolución mayor al debido. Con este valor definimos una tolerancia para que use una resolución si es muy muy muy próxima*/
    TC.Consts.SRSDOWNLOAD_GEOJSON_KML = "EPSG:4326";
	
    TC.Consts.url = {
        SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
        OL: 'lib/ol/build/ol-sitna',
        OL_CONNECTOR: 'TC/ol/ol',
        TEMPLATING: 'lib/dust/dust-full',
        TEMPLATING_HELPERS: 'lib/dust/dust-helpers',
        TEMPLATING_I18N: 'lib/dust/dustjs-i18n',
        TEMPLATING_OVERRIDES: 'lib/dust/dust.overrides.js',
        TEMPLATING_FULL: 'lib/handlebars/handlebars',
        TEMPLATING_RUNTIME: 'lib/handlebars/handlebars.runtime',
        TEMPLATING_HBS_HELPERS: 'lib/handlebars/helpers.js',
        PROJ4JS: 'lib/proj4js/proj4.js',
        EPSG: 'https://epsg.io/',
        LOCALFORAGE: TC.apiLocation + 'lib/localforage/localforage',
        D3C3: TC.apiLocation + 'lib/d3c3/d3c3.min.js',
        CESIUM: TC.apiLocation + 'lib/cesium/release/Cesium.js',
        JSNLOG: 'lib/jsnlog/jsnlog.min.js',
        ERROR_LOGGER: TC.apiLocation + 'errors/logger.ashx',
        PDFMAKE: TC.apiLocation + 'lib/pdfmake/pdfmake-fonts.min.js',
        JSONPACK: 'lib/jsonpack/jsonpack.min.js',
        UA_PARSER: 'lib/ua-parser/ua-parser.min.js',
        HASH: 'lib/jshash/md5-min.js',
        DRAGGABILLY: 'lib/draggabilly/draggabilly.pkgd',
        URL_POLYFILL: 'lib/polyfill/url.js',
        PROMISE_POLYFILL: 'lib/polyfill/promise/polyfill.min.js'
    };
    TC.Consts.classes = {
        MAP: 'tc-map',
        POINT: 'tc-point',
        MARKER: 'tc-marker',
        VISIBLE: 'tc-visible',
        HIDDEN: 'tc-hidden',
        COLLAPSED: 'tc-collapsed',
        CHECKED: 'tc-checked',
        DISABLED: 'tc-disabled',
        ACTIVE: 'tc-active',
        DEFAULT: 'tc-default',
        LASTCHILD: 'tc-lastchild',
        TRANSPARENT: 'tc-transparent',
        DROP: 'tc-drop',
        LOADING: 'tc-loading',
        IPAD_IOS7_FIX: 'tc-ipad-ios7-fix',
        INFO: 'tc-msg-info',
        WARNING: 'tc-msg-warning',
        ERROR: 'tc-msg-error',
        THREED: 'tc-threed'
    };
    TC.Consts.msgType = {
        INFO: 'info',
        WARNING: 'warning',
        ERROR: 'error'
    };
    TC.Consts.msgErrorMode = {
        TOAST: 'toast',
        CONSOLE: 'console',
        EMAIL: 'email'
    };
    TC.Consts.event = {
        /**
         * Se lanza cuando el mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event mapload
         */
        MAPLOAD: 'mapload.tc',
        MAPREADY: 'mapready.tc',
        BEFORELAYERADD: 'beforelayeradd.tc',
        LAYERADD: 'layeradd.tc',
        LAYERREMOVE: 'layerremove.tc',
        LAYERORDER: 'layerorder.tc',
        BEFORELAYERUPDATE: 'beforelayerupdate.tc',
        LAYERUPDATE: 'layerupdate.tc',
        LAYERERROR: 'layererror.tc',
        BEFOREBASELAYERCHANGE: 'beforebaselayerchange.tc',
        BASELAYERCHANGE: 'baselayerchange.tc',
        BEFOREUPDATE: 'beforeupdate.tc',
        UPDATE: 'update.tc',
        BEFOREZOOM: 'beforezoom.tc',
        ZOOM: 'zoom.tc',
        BEFOREUPDATEPARAMS: 'beforeupdateparams.tc',
        UPDATEPARAMS: 'updateparams.tc',
        VECTORUPDATE: 'vectorupdate.tc',
        FEATUREADD: 'featureadd.tc',
        BEFOREFEATURESADD: 'beforefeaturesadd.tc',
        FEATURESADD: 'featuresadd.tc',
        FEATUREREMOVE: 'featureremove.tc',
        FEATURESCLEAR: 'featuresclear.tc',
        FEATURESIMPORT: 'featuresimport.tc',
        FEATURESIMPORTERROR: 'featuresimporterror.tc',
        BEFORETILELOAD: 'beforetileload.tc',
        TILELOAD: 'tileload.tc',
        TILELOADERROR: 'tileloaderror.tc',
        CONTROLADD: 'controladd.tc',
        CONTROLACTIVATE: 'controlactivate.tc',
        CONTROLDEACTIVATE: 'controldeactivate.tc',
        BEFORECONTROLRENDER: 'beforecontrolrender.tc',
        CONTROLRENDER: 'controlrender.tc',
        BEFORELAYOUTLOAD: 'beforelayoutload.tc',
        LAYOUTLOAD: 'layoutload.tc',
        LAYERVISIBILITY: 'layervisibility.tc',
        LAYEROPACITY: 'layeropacity.tc',
        FEATURECLICK: 'featureclick.tc',
        NOFEATURECLICK: 'nofeatureclick.tc',
        FEATUREOVER: 'featureover.tc',
        FEATUREOUT: 'featureout.tc',
        BEFOREFEATUREINFO: 'beforefeatureinfo.tc',
        FEATUREINFO: 'featureinfo.tc',
        NOFEATUREINFO: 'nofeatureinfo.tc',
        FEATUREINFOERROR: 'featureinfoerror.tc',
        CLICK: 'click',
        MOUSEUP: 'mouseup',
        MOUSEMOVE: 'mousemove',
        MOUSELEAVE: 'mouseleave',
        STARTLOADING: 'startloading.tc',
        STOPLOADING: 'stoploading.tc',
        EXTERNALSERVICEADDED: 'externalserviceadded.tc',
        ZOOMTO: 'zoomto.tc',
        PROJECTIONCHANGE: 'projectionchange.tc',
        VIEWCHANGE: 'viewchange.tc',
        TERRAINPROVIDERADD: 'terrainprovideradd.tc',
        TERRAINPROVIDERREMOVE: 'terrainproviderremove.tc',
        OVERVIEWBASELAYERCHANGE: 'overviewbaselayerchange.tc',
        POPUP: 'popup.tc'
    };

/**
 * Colección de identificadores de capas útiles de IDENA y otros servicios de terceros.
 * @namespace SITNA.Consts.layer
 * @see MapOptions
 * @see SITNA.Map#addLayer
 * @see SITNA.Map#setBaseLayer
 */
    TC.Consts.layer = {
/**
 * Identificador de la capa de ortofoto de máxima actualidad del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO: 'ortofoto',
/**
 * Identificador de la capa de mapa base del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_BASEMAP: 'mapabase',
/**
 * Identificador de la capa de catastro del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_CADASTER: 'catastro',
/**
 * Identificador de la capa de cartografía topográfica 2017 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_CARTO: 'cartografia',
/**
 * Identificador de la capa de ortofoto 2019 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO2019: 'ortofoto2019',
/**
 * Identificador de la capa de ortofoto 2018 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO2018: 'ortofoto2018',
/**
 * Identificador de la capa de ortofoto 2017 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO2017: 'ortofoto2017',
/**
 * Identificador de la capa de ortofoto 2014 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO2014: 'ortofoto2014',
/**
 * Identificador de la capa de ortofoto 2012 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_ORTHOPHOTO2012: 'ortofoto2012',
/**
 * Identificador de la capa de mapa base del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNBASEMAP: 'mapabase_dinamico',
/**
 * Identificador de la capa de ortofoto de máxima actualidad del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO: 'ortofoto_dinamico',
/**
 * Identificador de la capa de ortofoto 2019 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO2019: 'ortofoto2019_dinamico',
/**
 * Identificador de la capa de ortofoto 2018 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO2018: 'ortofoto2018_dinamico',
/**
 * Identificador de la capa de ortofoto 2017 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO2017: 'ortofoto2017_dinamico',
/**
 * Identificador de la capa de ortofoto 2014 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO2014: 'ortofoto2014_dinamico',
/**
 * Identificador de la capa de ortofoto 2012 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNORTHOPHOTO2012: 'ortofoto2012_dinamico',
/**
 * Identificador de la capa de cartografía topográfica 2017 del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_DYNCARTO: 'cartografia_dinamico',
/**
 * Identificador de la capa de relieve en blanco y negro del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_BW_RELIEF: 'relieve_bn',
/**
 * Identificador de la capa de la combinación de ortofoto de máxima actualidad y mapa base del WMS de IDENA.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IDENA_BASEMAP_ORTHOPHOTO: 'base_orto',

/**
 * Identificador de la capa de cartografía raster del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_CARTO: "ign-raster",
/**
 * Identificador de la capa del callejero del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_BASEMAP: "ign-base",
/**
 * Identificador de la capa del callejero en gris del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_BASEMAP_GREY: "ign-base-gris",
/**
 * Identificador de la capa de relieve del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_RELIEF: "ign-mtn",
/**
 * Identificador de la capa del PNOA del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_ORTHOPHOTO: "ign-pnoa",
/**
 * Identificador de la capa del modelo digital de superficies LIDAR del WMTS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_LIDAR: "ign-lidar",

/**
 * Identificador de la capa de cartografía raster del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNCARTO: "ign-raster-dyn",
/**
 * Identificador de la capa del callejero del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNBASEMAP: "ign-base-dyn",
/**
 * Identificador de la capa del callejero en gris del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNBASEMAP_GREY: "ign-base-gris-dyn",
/**
 * Identificador de la capa de relieve del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNRELIEF: "ign-mtn-dyn",
/**
 * Identificador de la capa del PNOA del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNORTHOPHOTO: "ign-pnoa-dyn",
/**
 * Identificador de la capa del modelo digital de superficies LIDAR del WMS del Instituto Geográfico Nacional.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_ES_DYNLIDAR: "ign-lidar-dyn",

/**
 * Identificador de la capa de cartografía raster del WMTS del Instituto Geográfico Nacional Francés. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_CARTO: "ign-fr-cartes",
/**
 * Identificador de la capa de mapa base del WMTS del Instituto Geográfico Nacional Francés. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_BASEMAP: "ign-fr-base",
/**
 * Identificador de la capa de relieve del WMTS del Instituto Geográfico Nacional Francés. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_RELIEF: "ign-fr-estompage",
/**
 * Identificador de la capa de ortofoto del WMTS del Instituto Geográfico Nacional Francés. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_ORTHOPHOTO: "ign-fr-orto",

/**
 * Identificador de la capa de cartografía raster del WMS del Instituto Geográfico Nacional Francés.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_DYNCARTO: "ign-fr-cartes-dyn",
/**
 * Identificador de la capa de mapa base del WMS del Instituto Geográfico Nacional Francés.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_DYNBASEMAP: "ign-fr-base-dyn",
/**
 * Identificador de la capa de relieve del WMS del Instituto Geográfico Nacional Francés.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_DYNRELIEF: "ign-fr-estompage-dyn",
/**
 * Identificador de la capa de ortofoto del WMS del Instituto Geográfico Nacional Francés.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        IGN_FR_DYNORTHOPHOTO: "ign-fr-orto-dyn",

/**
 * Identificador de la capa de OpenStreetMap a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        OSM: 'osm',
/**
 * Identificador de la capa de Carto Voyager a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        CARTO_VOYAGER: 'carto_voyager',
/**
 * Identificador de la capa de Carto Light a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        CARTO_LIGHT: 'carto_light',
/**
 * Identificador de la capa de Carto Dark a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        CARTO_DARK: 'carto_dark',
/**
 * Identificador de la capa de Mapbox Streets a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        MAPBOX_STREETS: 'mapbox_streets',
/**
 * Identificador de la capa de Mapbox Satellite a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
 * @var {string}
 * @memberof SITNA.Consts.layer
 * @readonly
 */
        MAPBOX_SATELLITE: 'mapbox_satellite',
/** 
 * Identificador de una capa en blanco.
 * @var {string}
 * @readonly
 * @memberof SITNA.Consts.layer
 */
        BLANK: 'ninguno'
    };
    TC.Consts.text = {
        API_ERROR: 'Error API SITNA',
        APP_ERROR: 'Error de aplicación'
    };

/**
 * Colección de identificadores de tipo de capa.
 * @namespace SITNA.Consts.layerType
 * @see LayerOptions
 */
    TC.Consts.layerType = {
/**
 * Identificador de capa de tipo WMS.
 * @var {string}
 * @memberof SITNA.Consts.layerType
 * @readonly
 */
        WMS: 'WMS',
/**
 * Identificador de capa de tipo WMTS.
 * @var {string}
 * @memberof SITNA.Consts.layerType
 * @readonly
 */
        WMTS: 'WMTS',
/**
 * Identificador de capa de tipo WFS.
 * @var {string}
 * @memberof SITNA.Consts.layerType
 * @readonly
 */
        WFS: 'WFS',
/**
 * Identificador de capa de tipo vectorial. Este tipo de capa es la que se utiliza para dibujar marcadores.
 * @var {string}
 * @memberof SITNA.Consts.layerType
 * @readonly
 */
        VECTOR: 'vector',
/**
 * Identificador de capa de tipo KML.
 * @var {string}
 * @memberof SITNA.Consts.layerType
 * @deprecated En lugar de esta propiedad es recomendable usar {@link SITNA.Consts.layerType.VECTOR} para cargar archivos KML.
 * @readonly
 */
        KML: 'KML',
        GPX: 'GPX',
        GML: 'GML',
        GEOJSON: 'GeoJSON',
        GROUP: 'group'
    };

/**
 * Colección de identificadores de tipo de geometría.
 * @namespace SITNA.Consts.geom
 */
    TC.Consts.geom = {
/**
 * Identificador de geometría de tipo punto.
 * @var {string}
 * @memberof SITNA.Consts.geom
 * @readonly
 */
        POINT: 'point',
        MULTIPOINT: 'multipoint',
/**
 * Identificador de geometría de tipo línea.
 * @var {string}
 * @memberof SITNA.Consts.geom
 * @readonly
 */
        POLYLINE: 'polyline',
/**
 * Identificador de geometría de tipo polígono.
 * @var {string}
 * @memberof SITNA.Consts.geom
 * @readonly
 */
        POLYGON: 'polygon',
        MULTIPOLYLINE: 'multipolyline',
        MULTIPOLYGON: 'multipolygon',
        CIRCLE: 'circle',
        RECTANGLE: 'rectangle'
    };
    TC.Consts.searchType = {
        CADASTRAL: 'cadastral',
        COORDINATES: 'coordinates',
        MUNICIPALITY: 'municipality',
        COUNCIL: 'council',
        LOCALITY: 'locality',
        STREET: 'street',
        NUMBER: 'number',
        URBAN: 'urban',
        COMMONWEALTH: 'commonwealth',
        ROAD: 'road',
        ROADPK: 'roadpk',
        PLACENAME: 'placename',
        PLACENAMEMUNICIPALITY: 'placenamemunicipality'
    };
    TC.Consts.mapSearchType = {
        MUNICIPALITY: TC.Consts.searchType.MUNICIPALITY,
        COUNCIL: TC.Consts.searchType.COUNCIL,
        URBAN: TC.Consts.searchType.URBAN,
        COMMONWEALTH: TC.Consts.searchType.COMMONWEALTH,
        GENERIC: 'generic'
    };
    TC.Consts.comparison = {
        EQUAL_TO: '==',
        NOT_EQUAL_TO: '!=',
        LESS_THAN: '<',
        GREATER_THAN: '>',
        LESS_THAN_EQUAL_TO: '=<',
        GREATER_THAN_EQUAL_TO: '>=',
        LIKE: 'is'
    };
    TC.Consts.logicalOperator = {
        AND: 'and',
        OR: 'or'
    };
    TC.Consts.WMTSEncoding = {
        KVP: 'KVP',
        RESTFUL: 'RESTful'
    };

/**
 * Colección de tipos MIME de utilidad.
 * @namespace SITNA.Consts.mimeType
 * @see LayerOptions
 */
	TC.Consts.mimeType = {
/** 
 * Tipo MIME de imagen PNG.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default
 */		
        PNG: 'image/png',
/** 
 * Tipo MIME de imagen JPEG.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        JPEG: 'image/jpeg',
/** 
 * Tipo MIME de documento JSON.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        JSON: 'application/json',
/** 
 * Tipo MIME de documento GeoJSON.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        GEOJSON: 'application/vnd.geo+json',
/** 
 * Tipo MIME de documento KML.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        KML: 'application/vnd.google-earth.kml+xml',
        KMZ: 'application/vnd.google-earth.kmz',
/** 
 * Tipo MIME de documento GML.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        GML: 'application/gml+xml',
/** 
 * Tipo MIME de documento GPX.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        GPX: 'application/gpx+xml',
/** 
 * Tipo MIME de documento XML.
 * @var {string}
 * @memberof SITNA.Consts.mimeType
 * @readonly
 * @default 
 */		
        XML: 'application/xml'
    };
    TC.Consts.format = {
        JSON: 'JSON',
        KML: 'KML',
        KMZ: 'KMZ',
        GML: 'GML',
        GML2: 'GML2',
        GML3: 'GML3',
        GML32: 'GML32',
        GEOJSON: 'GeoJSON',
        TOPOJSON: 'TopoJSON',
        GPX: 'GPX',
        WKT: 'WKT'
    };
    //enumerado de errores y warninqs derivados de descargas, getfeatures
    TC.Consts.WFSErrors = {
        GETFEATURE_NOT_AVAILABLE: "GetFeatureNotAvailable",
        LAYERS_NOT_AVAILABLE: "LayersNotAvailable",
        NO_LAYERS: "NoLayers",
        NO_VALID_LAYERS: "noValidLayers",
        QUERY_NOT_AVAILABLE: "QueryNotAvailable",
        //CapabilitiesParseError: "CapabilitiesParseError",
        MAX_NUM_FEATURES: "NumMaxFeatures",
        GETCAPABILITIES: "GetCapabilities",
        INDETERMINATE: "Indeterminate",
        NO_FEATURES: "NoFeatures"
    }
    TC.Consts.visibility = {
        NOT_VISIBLE: 0,
        NOT_VISIBLE_AT_RESOLUTION: 1,
        HAS_VISIBLE: 2,
        VISIBLE: 4
    };

    TC.Consts.view = {
        DEFAULT: 0,
        THREED: 1,
        PRINTING: 2
    };

    TC.Consts.units = {
        DEGREES: "degrees",
        METERS: "m"
    };

    TC.Consts.MARKER = 'marker';

/**
 * Opciones de configuración del mapa. Para más información de como usar objetos de este tipo, consultar {@tutorial 2-configuration}.
 * @typedef MapOptions
 * @see 2-configuration
 * @property {LayerOptions[]|string[]} [baseLayers=[SITNA.Consts. layer. IDENA_BASEMAP]{@link SITNA.Consts.layer.IDENA_BASEMAP}, [SITNA.Consts. layer. IDENA_ORTHOPHOTO]{@link SITNA.Consts.layer.IDENA_ORTHOPHOTO}, [SITNA.Consts. layer. IDENA_CADASTER]{@link SITNA.Consts.layer.IDENA_CADASTER}, [SITNA.Consts. layer. IDENA_CARTO]{@link SITNA.Consts.layer.IDENA_CARTO}] - Lista con cualquier combinación de objetos de definición de capa o de identificadores de capas de la API SITNA
 * (miembros de {@link SITNA.Consts.layer}) para incluir dichas capas como mapas de fondo.
 * @property {MapControlOptions} [controls] - Opciones de controles de mapa, define qué controles se incluyen en un mapa y qué opciones se pasan a cada control.
 * @property {string} [crossOrigin] - Valor del atributo `crossorigin` de las imágenes del mapa para habilitar CORS Es necesario establecer esta opción para poder utilizar el método {@link SITNA.Map#exportImage}.
 *
 * Los valores soportados son `anonymous` y `use-credentials`.
 * @property {string} [crs="EPSG:25830"] - Código EPSG del sistema de referencia de coordenadas del mapa.
 * @property {string} [defaultBaseLayer=[SITNA.Consts. layer. IDENA_BASEMAP]{@link SITNA.Consts.layer.IDENA_BASEMAP}] - Identificador de la capa base por defecto o índice de la capa base por defecto en la lista de capas base del mapa (Definida con la propiedad `baseLayers`).
 * @property {number[]} [initialExtent=[541084.221, 4640788.225, 685574.4632, 4796618.764]] - Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima, en las unidades del sistema de referencia de coordenadas del mapa (Ver propiedad `crs`). Por defecto la extensión es la de Navarra.
 * @property {string} [layout="layout/responsive"] - URL de la carpeta de maquetación. Para prescindir de maquetación, establecer esta propiedad a `null`. Para más información al respecto de esta propiedad, 
 * consulte el tutorial {@tutorial layout_cfg}.
 * @property {string} [locale="es-ES"] - Código de idioma de la interfaz de usuario. Este código debe obedecer la sintaxis definida por la IETF. Los valores posibles son `es-ES`, `eu-ES` y `en-US`.
 * @property {number[]|boolean} [maxExtent=false] - Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima, de forma que el centro del mapa nunca saldrá fuera de estos límites. 
 * Estos valores deben estar en las unidades definidas por el sistema de referencia de coordenadas del mapa (Ver propiedad `crs`).
 *
 * Si en vez de un array el valor es `false`, el mapa no tiene limitada la extensión máxima.
 * @property {boolean} [mouseWheelZoom=true] - Si se establece a `true`, la rueda de scroll del ratón se puede utilizar para hacer zoom en el mapa.
 * @property {number} [pixelTolerance=10] - Tolerancia en pixels a las consultas de información de capa.
 *
 * En ciertas capas, por ejemplo las que representan geometrías de puntos, puede ser difícil pulsar precisamente en el punto donde está la entidad geográfica que interesa.
 * 
 * La propiedad `pixelTolerance` define un área de un número de pixels hacia cada lado del punto de pulsación, de forma que toda entidad geográfica que esté dentro de ese área, total o parcialmente, se incluye en el resultado de la consulta.
 * 
 * Por ejemplo, si el valor establecido es 10, toda entidad geográfica que esté dentro de un cuadrado de 21 pixels de lado (10 pixels por cuadrante más el pixel central) 
 * centrado en el punto de pulsación se mostrará en el resultado. A tener en cuenta: Esta propiedad establece el valor de los llamados *parámetros de vendedor* 
 * que los servidores de mapas admiten para modificar el comportamiento de las peticiones `getFeatureInfo` del standard WMS. Pero este comportamiento puede ser modificado también por otras circunstancias, 
 * como los estilos aplicados a las capas en el servidor.
 * 
 * Como estas circunstancias están fuera del ámbito de alcance de esta API, es posible que los resultados obtenidos desde algún servicio WMS sean inesperados en lo referente a `pixelTolerance`.
 * @property {string} [proxy] - URL del proxy utilizado para peticiones a dominios remotos.
 * 
 * Debido a restricciones de seguridad implementadas en Javascript, a través de `XMLHttpRequest` no es posible obtener información de dominios distintos al de la página web.
 * 
 * Hay dos maneras de solventar esta restricción. La primera es que el servidor remoto permita el acceso entre dominios estableciendo la cabecera `Access-Control-Allow-Origin` a la respuesta HTTP. 
 * Dado que esta solución la implementan terceras personas (los administradores del dominio remoto), no siempre es aplicable.
 * 
 * La segunda solución es desplegar en el dominio propio un proxy. Un proxy es un servicio que recibe peticiones HTTP y las redirige a otra URL.
 * 
 * Si la propiedad `proxy` está establecida, todas las peticiones a dominios remotos las mandará al proxy para que este las redirija. 
 * De esta manera no infringimos las reglas de seguridad de JavaScript, dado que el proxy está alojado en el dominio propio.
 * @property {StyleOptions} [styles] - Opciones de estilo de las entidades geográficas.
 * @property {LayerOptions[]} [workLayers] - Lista de objetos de definición de capa para incluir dichas capas como contenido activo del mapa.
 */
 
    TC.Defaults = (function () {

        var clusterRadii = {};
        var getClusterRadius = function (feature) {
            var count = feature.features.length;
            var result = clusterRadii[count];
            if (!result) {
                result = 2 + Math.round(Math.sqrt(count) * 5);
                clusterRadii[count] = result;
            }
            return result;
        };

        return {
            imageRatio: 1.05,
            proxy: '',

            crs: 'EPSG:25830',
            utmCrs: 'EPSG:25830',
            geoCrs: 'EPSG:4326',
            initialExtent: [541084.221, 4640788.225, 685574.4632, 4796618.764],
            maxExtent: false,
            baselayerExtent: [480408, 4599748, 742552, 4861892],
            resolutions: [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, .5, .25],
            pointBoundsRadius: 30,
            extentMargin: 0.2,
            mouseWheelZoom: true,
            attribution: '<a href="http://sitna.navarra.es/" target="_blank">SITNA</a>',
            oldBrowserAlert: true,
            notifyApplicationErrors: false,
            loggingErrorsEnabled: true,
            maxErrorCount: 10,

            locale: 'es-ES',

            view: TC.Consts.view.DEFAULT,

            screenSize: 20,
            pixelTolerance: 10, // Used in GFI requests
            maxResolutionError: 0.01, // Max error ratio to consider two resolutions equivalent

            toastDuration: 5000,

            avgTileSize: 31000,

            availableBaseLayers: [
                {
                    id: TC.Consts.layer.IDENA_BASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830extended',
                    layerNames: 'mapabase',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: true,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO,
                    title: 'Ortofoto máxima actualidad',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto_maxima_actualidad',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2019,
                    title: 'Ortofoto 2019',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2019',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2019.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2019,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2018,
                    title: 'Ortofoto 2018',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2018',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2017,
                    title: 'Ortofoto 2017',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2017',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830reduced',
                    layerNames: 'ortofoto2014',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2012',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CARTO,
                    title: 'Cartografía topográfica 2017',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'mapaTopografico',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CADASTER,
                    title: 'Catastro',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'catastro,regionesFronterizas',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-cadaster.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BW_RELIEF,
                    title: 'Relieve',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'IDENA:mapa_relieve_bn',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_bw.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BASEMAP_ORTHOPHOTO,
                    title: 'Mapa base/ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase_orto',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-base_ortho.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNBASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase,regionesFronterizas',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    title: 'Ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_maxima_actualidad',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2019,
                    title: 'Ortofoto 2019',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2019',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2019.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    title: 'Ortofoto 2018',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2018',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    title: 'Ortofoto 2017',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2017',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2014',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2012',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNCARTO,
                    title: 'Cartografía topográfica',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'MTNa5_BTA',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_CARTO,
                    type: TC.Consts.layerType.WMTS,
                    title: "Cartografía raster \r\n (IGN ES)",
                    url: "//www.ign.es/wmts/mapa-raster",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "MTN",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP,
                    title: "Callejero \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBaseTodo",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP_GREY,
                    title: "Callejero gris \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBase-gris",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_grey_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_RELIEF,
                    title: "Relieve \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/mdt",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "Relieve",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-relief_ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_ORTHOPHOTO,
                    title: "Ortofoto PNOA",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/pnoa-ma",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "OI.OrthoimageCoverage",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-orthophoto_pnoa.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_LIDAR,
                    title: "Modelo digital LIDAR (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "http://wmts-mapa-lidar.idee.es/lidar",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "EL.GridCoverageDSM",
                    matrixSet: "GoogleMapsCompatible",
                    format: "image/png",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-lidar_ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNLIDAR,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    title: 'Callejero gris \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo-gris',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_grey_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/pnoa-ma',
                    layerNames: 'OI.OrthoimageCoverage',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto_pnoa.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNCARTO,
                    title: 'Cartografía topográfica \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mapa-raster',
                    layerNames: 'mtn_rasterizado',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    title: 'Relieve \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mdt',
                    layerNames: 'relieve',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_ign.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNLIDAR,
                    title: 'Modelo digital LIDAR (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//wms-mapa-lidar.idee.es/lidar',
                    layerNames: 'EL.GridCoverage',
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-lidar_ign.jpg",
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_CARTO,
                    title: "Cartografía raster \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNCARTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_BASEMAP,
                    title: "Mapa base \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_RELIEF,
                    title: "Relieve \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE.SHADOW",
                    matrixSet: "PM",
                    format: "image/png",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_ORTHOPHOTO,
                    title: "Ortofoto \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ORTHOIMAGERY.ORTHOPHOTOS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNCARTO,
                    title: 'Cartografía raster \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP,
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    title: 'Relieve \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "HR.ORTHOIMAGERY.ORTHOPHOTOS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.OSM,
                    title: 'OSM',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/osm/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'osm',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-osm.png',
                    overviewMapLayer: TC.Consts.layer.OSM
                },
                {
                    id: TC.Consts.layer.CARTO_VOYAGER,
                    title: 'CARTO Voyager',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'voyager',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-voyager.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_LIGHT,
                    title: 'CARTO light',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'light_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-light.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_DARK,
                    title: 'CARTO dark',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'dark_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-dark.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.MAPBOX_STREETS,
                    title: 'Mapbox Streets',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'streets',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-streets.png',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.MAPBOX_SATELLITE,
                    title: 'Mapbox Satellite',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'satellite',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-satellite.jpg',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.BLANK,
                    title: 'Mapa en blanco',
                    type: TC.Consts.layerType.VECTOR
                }
            ],

            baseLayers: [
                TC.Consts.layer.IDENA_BASEMAP,
                TC.Consts.layer.IDENA_ORTHOPHOTO,
                TC.Consts.layer.IDENA_CADASTER,
                TC.Consts.layer.IDENA_CARTO
            ],

            defaultBaseLayer: TC.Consts.layer.IDENA_BASEMAP,

            workLayers: [],

/**
 * Opciones de clustering de puntos de una capa, define si los puntos se tienen que agrupar cuando están más cerca entre sí que un valor umbral.
 *
 * Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad 
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef ClusterOptions
 * @property {number} distance - Distancia en píxels que tienen que tener como máximo los puntos entre sí para que se agrupen en un cluster.
 * @property {boolean} [animate] - Si se establece a `true`, los puntos se agrupan y desagrupan con una transición animada.
 * @property {ClusterStyleOptions} [styles] - Opciones de estilo de los clusters.
 * @example <caption>[Ver en vivo](../examples/cfg.LayerOptions.cluster.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Creamos un mapa con una capa de puntos de un KML,
 *     // clustering activado a 50 pixels y transiciones animadas.
 *     var map = new SITNA.Map("mapa", {
 *         workLayers: [
 *             {
 *                 id: "cluster",
 *                 type: SITNA.Consts.layerType.KML,
 *                 url: "data/PromocionesViviendas.kml",
 *                 title: "Clusters",
 *                 cluster: {
 *                     distance: 50,
 *                     animate: true
 *                 }
 *             }
 *         ]
 *     });
 * </script>
 */

/**
 * Opciones de capa. Este objeto se utiliza en al [configurar un mapa]{@linkplain MapOptions}, el [control del catálogo de capas]{@linkplain LayerCatalogOptions} 
 * o como parámetro al [añadir una capa]{@linkplain SITNA.Map#addLayer}.
 * @typedef LayerOptions
 * @see MapOptions
 * @see LayerCatalogOptions
 * @see SITNA.Map#addLayer
 * @see SITNA.Map#setBaseLayer
 * @property {string} id - Identificador único de capa. No puede haber en un mapa dos capas con el mismo valor de `id`.
 * @property {ClusterOptions} [cluster] - La capa agrupa sus entidades puntuales cercanas entre sí en grupos (clusters). 
 * Aplicable a capas de tipo {@link SITNA.Consts.layerType.VECTOR}, {@link SITNA.Consts.layerType.WFS} y {@link SITNA.Consts.layerType.KML}.
 * @property {string} [format] - En las capas de tipo {@link SITNA.Consts.layerType.WMS} y {@link SITNA.Consts.layerType.WMTS},
 * es el tipo MIME del formato de archivo de imagen a obtener del servicio. En las capas de tipo {@link SITNA.Consts.layerType.VECTOR}, es el tipo MIME
 * del formato de archivo de datos geográficos que queremos cargar (GeoJSON, KML, etc.).
 * 
 * Si esta propiedad no está definida, si la capa es un mapa de fondo (consultar propiedad `isBase`), se asume que el formato es `image/jpeg`, en caso contrario se asume que el formato es `image/png`.
 *
 * Para asignar valor a esta propiedad se puede usar las constantes de definidas en {@link SITNA.Consts.mimeType}.
 * @property {boolean} [hideTree] - Aplicable a capas de tipo {@link SITNA.Consts.layerType.WMS} y {@link SITNA.Consts.layerType.KML}.
 * Si se establece a `true`, la capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
 * @property {boolean} [isBase] - Si se establece a `true`, la capa es un mapa de fondo.
 * @property {boolean} [isDefault] - *__Obsoleta__: En lugar de esta propiedad es recomendable usar la propiedad `defaultBaseLayer`de {@link MapOptions}.*
 * 
 * Si se establece a true, la capa se muestra por defecto si forma parte de los mapas de fondo.
 * @property {string} [layerNames] - Lista separada por comas de los nombres de capa del servicio OGC. Aplicable a capas de tipo {@link SITNA.Consts.layerType.WMS} y {@link SITNA.Consts.layerType.WMTS}.
 * @property {string} [matrixSet] - Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo {@link SITNA.Consts.layerType.WMTS}.
 * @property {boolean} [stealth] - Si se establece a `true`, la capa no aparece en la tabla de contenidos ni en la leyenda. 
 * De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
 * @property {string} [thumbnail] - URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
 * @property {string} [title] - Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
 * @property {string} [type] - Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {@link SITNA.Consts.layerType}.
 * @property {string} [url] - URL del servicio OGC o del archivo de datos geográficos que define la capa. Propiedad obligatoria en capas de tipo {@link SITNA.Consts.layerType.WMS},
 * {@link SITNA.Consts.layerType.WMTS}, {@link SITNA.Consts.layerType.WFS} y {@link SITNA.Consts.layerType.KML}.
 * 
 * En las capas de tipo {@link SITNA.Consts.layerType.VECTOR} los archivos de datos geográficos soportados son KML, GeoJSON, GPX, GML, WKT y TopoJSON.
 * El formato se deduce de la extensión del nombre de archivo, pero también se puede especificar utilizando la propiedad `format`.
 * @example <caption>Ejemplo de uso de la propiedad `url` - [Ver en vivo](../examples/cfg.LayerOptions.url.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Añadimos el control de tabla de contenidos en la primera posición.
 *     SITNA.Cfg.controls.TOC = {
 *         div: "slot1"
 *     };
 *     // Añadimos una capa raster desde un servicio WMS y cuatro capas vectoriales
 *     // a partir de archivos geográficos: GeoJSON, GPX, KML y GML.
 *     SITNA.Cfg.workLayers = [
 *         {
 *             id: "wms",
 *             title: "Camino de Santiago",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: "IDENA:PATRIM_Lin_CaminoSantR",
 *             format: SITNA.Consts.mimeType.PNG
 *         },
 *         {
 *             id: "geojson",
 *             type: SITNA.Consts.layerType.VECTOR,
 *             url: "data/PARQUESNATURALES.json",
 *             format: SITNA.Consts.mimeType.GEOJSON
 *         },
 *         {
 *             id: "gpx",
 *             type: SITNA.Consts.layerType.VECTOR,
 *             url: "data/CAMINOFRANCES.gpx"
 *         },
 *         {
 *             id: "kml",
 *             type: SITNA.Consts.layerType.VECTOR,
 *             url: "data/MUSEOSNAVARRA.kml"
 *         },
 *         {
 *             id: "gml",
 *             type: SITNA.Consts.layerType.VECTOR,
 *             url: "data/ESTACIONESTREN.gml"
 *         },
 *     ];
 *     var map = new SITNA.Map("mapa");
 * </script>
 */

/**
 * Opciones básicas de control.
 * @typedef ControlOptions
 * @see MapControlOptions
 * @see 2-configuration
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 */

/**
 * Opciones de sugerencia de servicio externo WMS.
 * @typedef WMSOptions
 * @see WMSGroupOptions
 * @property {string} name - Nombre del servicio WMS. Se mostrará como un elemento en la lista de opciones del control.
 * @property {string} url - URL de acceso al servicio WMS.
 */
 
/**
 * Opciones de grupo de sugerencias de servicios externos WMS.
 * @typedef WMSGroupOptions
 * @see DataLoaderOptions
 * @property {string} group - Nombre del grupo de sugerencias. Se mostrará como una sección en la lista de opciones del control.
 * @property {WMSOptions[]} items - Lista de sugerencias de servicios externos WMS.
 */

/**
 * Función de callback que gestiona los clic del usuario en la ventana de visualización del mapa.
 * @callback SITNA.Map~ClickCallback
 * @param {number[]} coords - Coordenadas del punto donde se ha realizado clic, en las unidades del sistema de referencia de coordenadas del mapa (Ver propiedad `crs`de {@link MapOptions}). Array de dos números correspondientes a las coordenadas x e y.
 * @example <caption>[Ver en vivo](../examples/cfg.ClickOptions.html)</caption> {@lang html} 
 * <div id="mapa"/>
 * <script>
 *     // Creamos un mapa con el control de gestión de clics, con una función de callback personalizada
 *     var map = new SITNA.Map("mapa", {
 *         controls: {
 *             click: {
 *                 active: true,
 *                 callback: function (coord) {
 *                     alert("Has pulsado en la posición " + coord[0] + ", " + coord[1]);
 *                 }
 *             }
 *         }
 *     });
 * </script>
 */
 
/**
 * Opciones de control de clics de usuario.
 * @typedef ClickOptions
 * @property {boolean} [active] - Si se establece a `true`, el control asociado está activo, es decir, responde a los clics hechos en el mapa desde el que se carga.
 * Como máximo puede haber solamente un control activo en el mapa en cada momento.
 * @property {SITNA.Map~ClickCallback} callback - Función de callback que gestiona la respuesta al clic.
 */
 
/**
 * Opciones de control de obtención de información de entidades de mapa por click.
 * @typedef FeatureInfoOptions
 * @extends ClickOptions
 * @see MapControlOptions
 * @property {boolean} [active] - Si se establece a `true`, el control asociado está activo, es decir, responde a los clics hechos en el mapa desde el que se carga.
 * Como máximo puede haber solamente un control activo en el mapa en cada momento.
 * @property {SITNA.Map~ClickCallback} callback - Función de callback que gestiona la respuesta al clic.
 * @property {boolean} [persistentHighlights] - Cuando el control `featureInfo` muestra los resultados de la consulta, si el servicio lo soporta, mostrará resaltadas sobre el mapa las geometrías
 * de las entidades geográficas de la respuesta. Si este valor es `true`, dichas geometrías se quedan resaltadas en el mapa indefinidamente. En caso contrario, las geometrías resaltadas se borran en el 
 * momento en que se cierra el bocadillo de resultados o se hace una nueva consulta.
 * @example <caption>[Ver en vivo](../examples/cfg.FeatureInfoOptions.persistentHighlights.html)</caption> {@lang html} 
 * <div id="mapa"></div>
 * <script>
 *     // Añadimos el control featureInfo.
 *     SITNA.Cfg.controls.featureInfo = {
 *         persistentHighlights: true
 *     };
 *     // Añadimos una capa WMS sobre la que hacer las consultas.
 *     SITNA.Cfg.workLayers = [
 *         {
 *             id: "masas",
 *             title: "Masas de agua",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "https://servicios.idee.es/wms-inspire/hidrografia",
 *             layerNames: ["HY.PhysicalWaters.Waterbodies"]
 *         }
 *     ];
 *     var map = new SITNA.Map("mapa");
 * </script> */
/**
 * Opciones de control de coordenadas.
 * @typedef CoordinatesOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {boolean} [showGeo] - Determina si se muestran coordenadas geográficas (en EPSG:4326) además de las del mapa, que por defecto son UTM (EPSG:25830).
 * @example <caption>[Ver en vivo](../examples/cfg.CoordinatesOptions.html)</caption> {@lang html} 
 * <div id="mapa"/>
 * <script>
 *     // Hacemos que el control que muestra las coordenadas en pantalla
 *     // muestre también las coordenadas geográficas
 *     SITNA.Cfg.controls.coordinates = {
 *         showGeo: true
 *     };
 *     var map = new SITNA.Map('map');
 * </script>
 */
 
/**
 * Opciones de control para añadir datos geográficos.
 * @typedef DataLoaderOptions
 * @extends ControlOptions
 * @see MapControlOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {boolean} [enableDragAndDrop] - Propiedad que establece si está permitido arrastrar y soltar archivos al área del mapa, además de abrirlos de la manera convencional abriendo el cuadro de diálogo de búsqueda de archivos.
 * @property {WMSGroupOptions[]} [wmsSuggestions] - Lista de grupos de sugerencias de servicios WMS ofrecidos por el control. Por ejemplo se puede establecer un grupo de servicios WMS estatales y otro de servicios WMS mundiales.
 * @example <caption>[Ver en vivo](../examples/cfg.DataLoaderOptions.html)</caption> {@lang html} 
 * <div id="mapa"></div>
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Activamos el proxy para poder acceder a servicios de otro dominio.
 *     SITNA.Cfg.proxy = "proxy.ashx?";
 *     // Añadimos el control de tabla de contenidos en el primer contenedor.
 *     SITNA.Cfg.controls.TOC = {
 *         div: "slot1"
 *     };
 *     // Añadimos el control de datos externos en el segundo contenedor.
 *     SITNA.Cfg.controls.dataLoader = {
 *         div: "slot2",
 *         enableDragAndDrop: true,
 *         wmsSuggestions: [
 *             {
 *                 group: "Estatales",
 *                 items: [
 *                     {
 *                         name: "Mapa Base (IGN)",
 *                         url: "https://www.ign.es/wms-inspire/ign-base"
 *                     },
 *                     {
 *                         name: "Unidades Administrativas (IGN)",
 *                         url: "https://www.ign.es/wms-inspire/unidades-administrativas"
 *                     },
 *                     {
 *                         name: "Cartografía Topográfica (IGN)",
 *                         url: "https://www.ign.es/wms-inspire/mapa-raster"
 *                     },
 *                     {
 *                         name: "Ortofotos PNOA Máxima Actualidad (IGN)",
 *                         url: "https://www.ign.es/wms-inspire/pnoa-ma"
 *                     }
 *                 ]
 *             },
 *             {
 *                 group: "Comunidades limítrofes",
 *                 items: [
 *                     {
 *                         name: "Aragón",
 *                         url: "http://idearagon.aragon.es/Visor2D"
 *                     },
 *                     {
 *                         name: "La Rioja",
 *                         url: "https://ogc.larioja.org/wms/request.php"
 *                     },
 *                     {
 *                         name: "País Vasco",
 *                         url: "http://www.geo.euskadi.eus/WMS_KARTOGRAFIA"
 *                     }
 *                 ]
 *             }
 *         ]
 *     };
 *     var map = new SITNA.Map("mapa");
 * </script>
 */

/**
 * Opciones de control de mapa de situación.
 * @typedef LayerCatalogOptions
 * @extends ControlOptions
 * @see MapControlOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {boolean} [enableSearch] - Propiedad que establece si se puede buscar capas por texto. La búsqueda del texto se realiza en los títulos 
 * y los resúmenes descriptivos de cada capa, que se publican en el [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities) del servicio.
 * @property {LayerOptions[]} layers - Lista de objetos de definición de las con capas de servicios WMS que queremos añadir al catálogo.
 * 
 * En estos objetos, si se asigna un valor a la propiedad `layerNames`, solo las capas especificadas y sus hijas estarán disponibles para ser añadidas al mapa. 
 * Sin embargo, si esta propiedad se deja sin asignar, todas las capas publicadas en el servicio WMS estarán disponibles para ser añadidas.
 * @example <caption>[Ver en vivo](../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Añadimos el control de capas cargadas en la primera posición.
 *     SITNA.Cfg.controls.workLayerManager = {
 *         div: "slot1"
 *     };
 *     // Añadimos en la segunda posición el catálogo de capas con dos servicios.
 *     SITNA.Cfg.controls.layerCatalog = {
 *         div: "slot2",
 *         enableSearch: true,
 *         layers: [
 *             {
 *                 id: "idena",
 *                 title: "IDENA",
 *                 hideTitle: true,
 *                 type: SITNA.Consts.layerType.WMS,
 *                 url: "//idena.navarra.es/ogc/wms",
 *                 hideTree: false
 *             },
 *             {
 *                 id: "sismica",
 *                 title: "Información sísmica y volcánica",
 *                 type: SITNA.Consts.layerType.WMS,
 *                 url: "//www.ign.es/wms-inspire/geofisica",
 *                 layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
 *                 hideTree: false
 *             }
 *         ]
 *     };
 *     var map = new SITNA.Map("mapa");
 * </script>
 */
 
/**
 * Opciones de control de mapa de situación.
 * @typedef OverviewMapOptions
 * @extends ControlOptions
 * @see MapControlOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {string|object} layer - Identificador de capa para usar como mapa de fondo u objeto de opciones de capa.
 */
 
 /**
 * Opciones de control de consultas alfanuméricas.
 * 
 * Algunos servidores tienen servicios WMS y WFS que actúan en paralelo, es decir, están alojados dentro del mismo nombre de host y publican las mismas capas.
 * Si el control `WFSQuery` está en el mapa, verifica si las capas de servicios WMS están asociadas a un WFS paralelo. Si es así, ofrece un interfaz de usuario
 * para poder hacer consultas a la capa en base a los valores de las propiedades de los elementos de la capa. Esta interfaz de usuario es accesible desde el control
 * `workLayerManager`.
 * @typedef WFSQueryOptions
 * @see MapControlOptions
 * @property {StyleOptions} [styles] - Opciones de estilo de las geometrías de las entidades resultado de la consulta.
 * @property {StyleOptions} [highlightStyles] - Opciones de estilo de las geometrías de las entidades resaltadas.
 * @example <caption>[Ver en vivo](../examples/cfg.WFSQueryOptions.html)</caption> {@lang html}
 * <div id="mapa" />
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Añadimos el control de capas cargadas en la primera posición.
 *     SITNA.Cfg.controls.workLayerManager = {
 *         div: "slot1"
 *     };
 *     //Si se añade el control WFSQuery, el control busca un servicio WFS pareado al WMS de cada capa añadida al mapa y si lo encuentra habilita la lupa que da acceso al constructor de consultas.
 *     SITNA.Cfg.controls.WFSQuery = {
 *         //Establecemos el estilo de las geometrías de las entidades resultado de la consulta
 *         styles: {
 *             //Estilo de polígonos y multipolígonos
 *             polygon: {
 *                 strokeColor: "#057f28",
 *                 strokeWidth: 4,
 *                 fillColor: "#057f28",
 *                 fillOpacity: 0.3
 *             },
 *             //Estilo de polilíneas y multipolilíneas
 *             line: {
 *                 strokeColor: "#057f28",
 *                 strokeWidth: 4
 *             },
 *             //Estilo de puntos y multipuntos
 *             point: {
 *                 strokeColor: "#057f28"
 *             }
 *         },
 *         //Establecemos el estilo de las geometrías de las entidades resaltadas
 *         highlightStyles: {
 *             //Estilo de polígonos y multipolígonos
 *             polygon: {
 *                 strokeColor: "#ff7f27",
 *                 strokeWidth: 4,
 *                 fillColor: "#ff7f27",
 *                 fillOpacity: 0.3
 *             },
 *             //Estilo de polilíneas y multipolilíneas
 *             line: {
 *                 strokeColor: "#ff7f27",
 *                 strokeWidth: 4
 *             },
 *             //Estilo de puntos y multipuntos
 *             point: {
 *                 strokeColor: "#ff7f27"
 *             }
 *         }
 *     };
 *     var map = new SITNA.Map("mapa", {
 *         workLayers: [{
 *             id: "paisajes",
 *             title: "Paisajes singulares",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: "IDENA:BIODIV_Pol_PaisajesSing"
 *         },
 *         {
 *             id: "meteorologia",
 *             title: "Meteorología",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: "IDENA:estacMeteor"
 *         },
 *         {
 *             id: "plazaola",
 *             title: "Vía Verde del Plazaola",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: "IDENA:DOTACI_Lin_VVPlazaola"
 *         }]
 *     });
 * </script>
 */

/**
 * Configuración del origen de datos auxiliar a la búsqueda de parcelas catastrales para la codificación de los nombres de municipio.
 * @typedef CadastralSearchOptionsExt
 * @see CadastralSearchOptions
 * @property {string[]} featureType - Colección de nombre de capa o capas a consultar.
 * @property {string} idProperty - Nombre de campo que identifica unívocamente el municipio cuyos valores deben coincidir con los posibles valores del campo indicado en firstQueryWord.
 * @property {string} labelProperty - Nombre de campo en el que buscar el texto indicado.
 * @example
 * {
 *     url: '//miServicioWFS/ogc/wfs',
 *     featurePrefix: 'IDENA',    
 *     featureType: ['Pol_ParcelaUrbana', 'Pol_ParcelaRustica', 'Pol_ParcelaMixta'],
 *     municipality: {
 *         featureType: 'Pol_Municipio',
 *         labelProperty: 'MUNICIPIO',
 *         idProperty: 'COD_MUNICIPIO'      
 *     },
 *     queryProperties: {
 *         firstQueryWord: 'COD_MUNICIPIO',
 *         secondQueryWord: 'POLIGONO',
 *         thirdQueryWord: 'PARCELA'
 *     }
 * }
 */

/**
 * Opciones de configuración del origen de datos de una búsqueda.
 * @typedef SearchQueryPropertyOptions
 * @see CadastralSearchOptions
 * @see MunicipalitySearchOptions
 * @see PostalAddressSearchOptions
 * @see StreetSearchOptions
 * @see TownSearchOptions
 * @property {string[]} firstQueryWord - Colección de nombre de campo o campos a consultar para el 1º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad `FeatureType`.
 * @property {string[]} secondQueryWord - Colección de nombre de campo o campos a consultar para el 2º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad `FeatureType`.
 * @property {string[]} thirdQueryWord - Colección de nombre de campo o campos a consultar para el 3º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad `FeatureType`.
 */

/**
 * Definición del color con el que se dibujará los resultados de la búsqueda en el mapa. Este color también se mostrará en la leyenda de la lista de sugerencias de resultados posibles de la búsqueda.
 * @typedef SearchResultColor
 * @see SearchSuggestionHeaderOptions
 * @property {string} css - Nombre de la propiedad de las sugerencias de la cual extraer el color. Ha de ser alguna de las distintas propiedades de colores presentes en {@link PointStyleOptions}, 
 * {@link LineStyleOptions} o {@link PolygonStyleOptions}.
 * @property {string} geomType - Nombre del tipo de geometría (el valor es un miembro de {@link SITNA.Consts.geom}).
 * @example
 * color: {
 *     geomType: "point",
 *     css: "fontColor"
 * } 
 */
 
/**
 * Algunas búsquedas hacen la consulta sobre varias capas. Este objeto define el color de los resultados de la búsqueda de cada capa. Estos colores también se mostrarán en la leyenda de la lista de sugerencias de resultados posibles de la búsqueda.
 * @typedef SearchResultColorDictionary
 * @see SearchSuggestionHeaderOptions
 * @property {SearchResultColor} color - Configuración para obtener el color.
 * @property {string} title - Title para identificar al color. Se define con la clave del diccionario de traducciones. Revisar la sección **Soporte multiidioma** en {@tutorial layout_cfg}.
 * @example
 * CATAST_Pol_ParcelaUrba: {
 *     title: "search.list.cadastral.urban",
 *     color: {
 *         geomType: "polygon",
 *         css: "strokeColor"
 *     } 
 * }
 */
 
/**
 * Opciones de configuración para la composición de la cabecera de una lista de sugerencias de búsqueda.
 * @typedef SearchSuggestionHeaderOptions
 * @see CadastralSearchOptions
 * @see MunicipalitySearchOptions
 * @see PostalAddressSearchOptions
 * @see StreetSearchOptions
 * @see TownSearchOptions
 * @property {string} label - Clave del diccionario de traducciones que indica qué tipo de búsqueda es: Parcela Catastral, Municipio, Calle… Revisar la sección **Soporte multiidioma** en {@tutorial layout_cfg}.
 * @property {SearchResultColorDictionary|SearchResultColor|string} color - Configuración para obtener el color que representa al tipo de búsqueda.
 * Se establece como color la primera coincidencia en `styles` que cumpla con la configuración.
 * 
 * La definición como string ha de ser para indicar el nombre de una propiedad presente en {@link PointStyleOptions}, {@link LineStyleOptions} o {@link PolygonStyleOptions}.
 * @example
 * {
 *     label: "search.list.town",
 *     color: "strokeColor"
 * }
 */
 
/**
 * Opciones de configuración del origen de datos de la búsqueda de parcelas catastrales.
 * @typedef CadastralSearchOptions
 * @see SearchOptions
 * @see {@link http://www.opengeospatial.org/standards/wfs|OGC Web Feature Service Standard}
 * @property {string} featurePrefix - Prefijo del nombre de la capa o capas a definir en la propiedad `featureType`. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
 * @property {string[]} featureType - Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `queryProperties`.
 * @property {string} geometryName - Nombre del campo de la geometría de la parcela catastral.
 * @property {CadastralSearchOptionsExt} municipality - Definición de la fuente de datos para la búsqueda de parcela por nombre de municipio en lugar de por código del mismo.
 * @property {SearchQueryPropertyOptions} queryProperties - Definición de los campos por los que filtrar la búsqueda de parcelas.
 *
 * En este tipo de búsqueda es obligatorio dar un valor a las siguientes propiedades:
 * - `firstQueryWord`: se indicará el campo o campos en los que buscar el código de municipio.
 * - `secondQueryWord`: se indicará el campo o campos en los que buscar el polígono.
 * - `thirdQueryWord`: se indicará el campo o campos en los que buscar la parcela.
 * @property {StyleOptions[]} styles - Colección de objetos de configuración de estilo. La relación entre capa y estilo se hace mediante el índice en la colección en `featureType` y en `styles`, por tanto, 
 * deberá haber tantas instancias como capas definidas en `featureType`.
 * 
 * No está disponible `cluster`.
 * @property {SearchSuggestionHeaderOptions} suggestionListHead - Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
 * @property {string} url - Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
 * @example <caption>[Ver en vivo](../examples/Cfg.SearchCadastralSource.html)</caption> {@lang javascript}
 * {   
 *     url:'//idena.navarra.es/ogc/wfs',                
 *     featurePrefix: 'IDENA',
 *     geometryName: 'the_geom',        
 *     featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
 *     municipality: {
 *         featureType: 'CATAST_Pol_Municipio',
 *         labelProperty: 'MUNICIPIO',
 *         idProperty: 'CMUNICIPIO'
 *     },
 *     queryProperties: {
 *         firstQueryWord: 'CMUNICIPIO',
 *         secondQueryWord: 'POLIGONO',
 *         thirdQueryWord: 'PARCELA'
 *     },
 *     suggestionListHead: {
 *         label: "search.list.cadastral",
 *         color: [
 *             {
 *                 CATAST_Pol_ParcelaUrba: {
 *                     title: "search.list.cadastral.urban",
 *                     color: {
 *                         geomType: "polygon",
 *                         css: "strokeColor"
 *                     }
 *                 }
 *             },
 *             {
 *                 CATAST_Pol_ParcelaRusti: {
 *                     title: "search.list.cadastral.rustic",
 *                     color: {
 *                         geomType: "polygon",
 *                         css: "strokeColor"
 *                     }
 *                 }
 *             },
 *             {
 *                 CATAST_Pol_ParcelaMixta: {
 *                     title: "search.list.cadastral.mixed",
 *                     color: {
 *                         geomType: "polygon",
 *                         css: "strokeColor"
 *                     }
 *                 }
 *             }
 *         ]
 *     },
 *     styles: [
 *         {
 *             polygon: {
 *                 fillColor: '#000000',
 *                 fillOpacity: 0.1,
 *                 strokeColor: '#136278',
 *                 strokeWidth: 2,
 *                 strokeOpacity: 1
 *             }
 *         },
 *         {
 *             polygon: {
 *                 fillColor: '#000000',
 *                 fillOpacity: 0.1,
 *                 strokeColor: '#0c8b3d',
 *                 strokeWidth: 2,
 *                 strokeOpacity: 1
 *             }
 *         },
 *         {
 *             polygon: {
 *                 fillColor: '#000000',
 *                 fillOpacity: 0.1,
 *                 strokeColor: '#e5475f',
 *                 strokeWidth: 2,
 *                 strokeOpacity: 1
 *             },
 *         }
 *     ]
 * }
 */

/**
 * Opciones de configuración del origen de datos de la búsqueda de municipios.
 * @typedef MunicipalitySearchOptions
 * @see SearchOptions
 * @see {@link http://www.opengeospatial.org/standards/wfs|OGC Web Feature Service Standard}
 * @property {string[]} dataIdProperty - Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un municipio. Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {string} featurePrefix - Prefijo del nombre de la capa o capas a definir en la propiedad `featureType`. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
 * @property {string[]} featureType - Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `queryProperties`.
 * @property {string} geometryName - Nombre del campo de la geometría del municipio.
 * @property {string} outputFormatLabel - Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección `outputProperties` con el valor del campo. Las llaves de cierre y apertura son necesarias.
 *
 * Por ejemplo: `outputProperties` como `[NombreMunicipio]` y `outputFormatLabel` como `“{0}”` mostrará en la lista resultados del tipo: *Pamplona*.
 * @property {string[]} outputProperties - Colección con los nombres de campos a mostrar (según el patrón indicando en `outputFormatLabel`) en la lista de sugerencias. 
 * Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. 
 * Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {SearchQueryPropertyOptions} queryProperties - Definición de los campos por los que filtrar la búsqueda de municipios.
 *
 * En este tipo de búsqueda es obligatorio dar un valor a la propiedad `firstQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre del municipio.
 * @property {StyleOptions[]} styles - Colección de objetos de configuración de estilo. La relación entre capa y estilo se hace mediante el índice en la colección en `featureType` y en `styles`, por tanto, 
 * deberá haber tantas instancias como capas definidas en `featureType`.
 * 
 * No está disponible `cluster`.
 * @property {SearchSuggestionHeaderOptions} suggestionListHead - Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
 * @property {string} url - Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
 * @example <caption>[Ver en vivo](../examples/Cfg.SearchMunicipalitySource.html)</caption> {@lang javascript}
 * {
 *     url:'//idena.navarra.es/ogc/wfs',        
 *     featurePrefix: 'IDENA',
 *     geometryName: 'the_geom',
 *     featureType: 'CATAST_Pol_Municipio',
 *     dataIdProperty: ['CMUNICIPIO'],
 *     queryProperties: {
 *         firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
 *     },
 *     suggestionListHead: {
 *         label: "search.list.municipality",
 *         color: "strokeColor"
 *     },
 *     outputProperties: ['MUNICIPIO'],
 *     outputFormatLabel: '{0}',        
 *     styles: [
 *         {
 *             polygon: {
 *                 fillColor: '#000000',
 *                 fillOpacity: 0.1,
 *                 strokeColor: '#fe06a5',
 *                 strokeWidth: 2,
 *                 strokeOpacity: 1
 *             }
 *         }
 *     ]
 * }
 */
 
/**
 * Opciones de configuración del origen de datos de la búsqueda de direcciones postales.
 * @typedef PostalAddressSearchOptions
 * @see SearchOptions
 * @see {@link http://www.opengeospatial.org/standards/wfs|OGC Web Feature Service Standard}
 * @property {string[]} dataIdProperty - Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a la dirección postal. Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {string} featurePrefix - Prefijo del nombre de la capa o capas a definir en la propiedad `featureType`. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
 * @property {string[]} featureType - Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `queryProperties`.
 * @property {string} geometryName - Nombre del campo de la geometría de la dirección postal.
 * @property {string} outputFormatLabel - Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección `outputProperties` con el valor del campo. Las llaves de cierre y apertura son necesarias.
 *
 * Por ejemplo: `outputProperties` como `[EntidadPoblacion, Via, Numero]` y `outputFormatLabel` como `“{1} {2}, {0}”` mostrará en la lista resultados del tipo: *Calle Estafeta 13, Pamplona*.
 * @property {string[]} outputProperties - Colección con los nombres de campos a mostrar (según el patrón indicando en `outputFormatLabel`) en la lista de sugerencias. 
 * Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. 
 * Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {SearchQueryPropertyOptions} queryProperties - Definición de los campos por los que filtrar la búsqueda de direcciones postales.
 *
 * En este tipo de búsqueda es obligatorio dar un valor a las siguientes propiedades:
 * - `firstQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre de la entidad de población.
 * - `secondQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre de la vía.
 * - `thirdQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el número de portal.
 * @property {StyleOptions[]} styles - Colección de objetos de configuración de estilo. La relación entre capa y estilo se hace mediante el índice en la colección en `featureType` y en `styles`, por tanto, 
 * deberá haber tantas instancias como capas definidas en `featureType`.
 * 
 * No está disponible cluster.
 * @property {SearchSuggestionHeaderOptions} suggestionListHead - Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
 * @property {string} url - Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
 * @example <caption>[Ver en vivo](../examples/Cfg.SearchPostalAddressSource.html)</caption> {@lang javascript}
 * {
 *     url: '//idena.navarra.es/ogc/wfs',        
 *     featurePrefix: 'IDENA',
 *     geometryName: 'the_geom',
 *     featureType: 'CATAST_Txt_Portal',
 *     dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
 *     queryProperties: {
 *         firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
 *         secondQueryWord: ['VIA', 'VIANOAC'],
 *         thirdQueryWord: ['PORTAL']
 *     },
 *     suggestionListHead: {
 *         label: "search.list.number",
 *         color: "fontColor"
 *     },
 *     outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
 *     outputFormatLabel: '{1} {2}, {0}',
 *     styles: [
 *         {
 *             point: {
 *                 radius: 0,
 *                 label: "PORTAL",
 *                 angle: "CADANGLE",
 *                 fontColor: "#CB0000",
 *                 fontSize: 14,
 *                 labelOutlineColor: "#FFFFFF",
 *                 labelOutlineWidth: 4
 *             }
 *         }
 *     ]
 * }
 */

/**
 * Opciones de configuración del origen de datos de la búsqueda de vías.
 * @typedef StreetSearchOptions
 * @see SearchOptions
 * @see {@link http://www.opengeospatial.org/standards/wfs|OGC Web Feature Service Standard}
 * @property {string[]} dataIdProperty - Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a una vía. Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {string} featurePrefix - Prefijo del nombre de la capa o capas a definir en la propiedad `featureType`. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
 * @property {string[]} featureType - Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `queryProperties`.
 * @property {string} geometryName - Nombre del campo de la geometría de la vía.
 * @property {string} outputFormatLabel - Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección `outputProperties` con el valor del campo. Las llaves de cierre y apertura son necesarias.
 *
 * Por ejemplo: `outputProperties` como `[EntidadPoblacion, Via]` y `outputFormatLabel` como `“{1}, {0}”` mostrará en la lista resultados del tipo: *Calle Estafeta, Pamplona*.
 * @property {string[]} outputProperties - Colección con los nombres de campos a mostrar (según el patrón indicando en `outputFormatLabel`) en la lista de sugerencias. 
 * Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. 
 * Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {SearchQueryPropertyOptions} queryProperties - Definición de los campos por los que filtrar la búsqueda de vías.
 *
 * En este tipo de búsqueda es obligatorio dar un valor a las siguientes propiedades:
 * - `firstQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre de la entidad de población.
 * - `secondQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre de la vía.
 * @property {string[]} renderFeatureType - Colección con los nombres de las capas auxiliares a añadir al resultado de la búsqueda en el mapa. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `dataIdProperty`.
 *
 * No se muestran sugerencias en base a las capas auxiliares, únicamente se añade información en el momento de pintar en el mapa, es por ello que debe existir relación en los datos entre las capas definidas en `featureType` y `renderFeatureType` y que ambas cuenten con los campos definidos en `dataIdProperty`.
 * @property {StyleOptions[]} styles - Colección de objetos de configuración de estilo. La relación entre capa y estilo se hace mediante el índice en las colecciones 1 y 2 siendo 1 la concatenación de `featureType` 
 * y `renderFeatureType` y 2 `styles`, por tanto, deberá haber tantas instancias como la suma de las capas definidas en `featureType` y en `renderFeatureType`.
 * 
 * No está disponible cluster.
 * @property {SearchSuggestionHeaderOptions} suggestionListHead - Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
 * @property {string} url - Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
 * @example <caption>[Ver en vivo](../examples/Cfg.SearchStreetSource.html)</caption> {@lang javascript}
 * {
 *     url: '//idena.navarra.es/ogc/wfs',        
 *     featurePrefix: 'IDENA',
 *     geometryName: 'the_geom',
 *     renderFeatureType: 'CATAST_Txt_Calle',
 *     featureType: 'CATAST_Lin_CalleEje',
 *     dataIdProperty: ['CVIA'],        
 *     queryProperties: {
 *         firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
 *         secondQueryWord: ['VIA', 'VIANOAC']
 *     },
 *     suggestionListHead: {
 *         label: "search.list.street",
 *         color: "strokeColor"
 *     },
 *     outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
 *     outputFormatLabel: '{1}, {0}',
 *     styles: [
 *         {
 *             line: {
 *                 strokeColor: "#CB0000",
 *                 strokeOpacity: 1,
 *                 strokeWidth: 2,
 *                 strokeLinecap: "round",
 *                 strokeDashstyle: "solid"
 *             }
 *         },
 *         {
 *             point: {
 *                 label: "VIA",
 *                 angle: "CADANGLE",
 *                 fontColor: "#000000",
 *                 fontSize: 7,
 *                 labelOutlineColor: "#ffffff",
 *                 labelOutlineWidth: 2
 *             }
 *         }
 *     ]
 * }
 */

/**
 * Opciones de configuración del origen de datos de la búsqueda de vías.
 * @typedef TownSearchOptions
 * @see SearchOptions
 * @see {@link http://www.opengeospatial.org/standards/wfs|OGC Web Feature Service Standard}
 * @property {string[]} dataIdProperty - Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un casco urbano. Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {string} featurePrefix - Prefijo del nombre de la capa o capas a definir en la propiedad `featureType`. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
 * @property {string[]} featureType - Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en `queryProperties`.
 * @property {string} geometryName - Nombre del campo de la geometría del casco urbano.
 * @property {string} outputFormatLabel - Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección `outputProperties` con el valor del campo. Las llaves de cierre y apertura son necesarias.
 *
 * Por ejemplo: `outputProperties` como `[NombreMunicipio, NombreCascoUrbano]` y `outputFormatLabel` como `“{1} ({0})”` mostrará en la lista resultados del tipo: *Salinas de Pamplona (Galar)*.
 * @property {string[]} outputProperties - Colección con los nombres de campos a mostrar (según el patrón indicando en `outputFormatLabel`) en la lista de sugerencias. 
 * Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. 
 * Los campos definidos deben existir en la capa o capas definidas en la propiedad `featureType`.
 * @property {SearchQueryPropertyOptions} queryProperties - Definición de los campos por los que filtrar la búsqueda de vías.
 *
 * En este tipo de búsqueda es obligatorio dar un valor a la propiedad `firstQueryWord`: se indicará el campo o campos (tipo `string`) en los que buscar el nombre del casco urbano.
 * @property {StyleOptions[]} styles - La relación entre capa y estilo se hace mediante el índice en la colección en `featureType` y en `styles`, por tanto, deberá haber tantas instancias como capas definidas en `featureType`.
 * 
 * No está disponible cluster.
 * @property {SearchSuggestionHeaderOptions} suggestionListHead - Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
 * @property {string} url - Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
 * @example <caption>[Ver en vivo](../examples/Cfg.SearchTownSource.html)</caption> {@lang javascript}
 * {
 *     url: '//idena.navarra.es/ogc/wfs',        
 *     featurePrefix: 'IDENA',
 *     geometryName: 'the_geom',
 *     featureType: 'ESTADI_Pol_EntidadPob',        
 *     dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],        
 *     queryProperties: {
 *         firstQueryWord: ['ENTINOAC', 'ENTIDAD']
 *     },
 *     suggestionListHead: {
 *         label: "search.list.urban",
 *         color: "strokeColor"
 *     },
 *     outputProperties: ['MUNICIPIO', 'ENTIDAD'],
 *     outputFormatLabel: '{1} ({0})',        
 *     styles: [
 *         {
 *             polygon: {
 *                 fillColor: '#000000',
 *                 fillOpacity: 0.1,
 *                 strokeColor: '#feba1e',
 *                 strokeWidth: 2,
 *                 strokeOpacity: 1
 *             }
 *         }
 *     ]
 * }
 */
 
/**
 * Opciones de control de búsquedas. La configuración por defecto tiene como origen de datos el WFS de IDENA. 
 * Es posible establecer un origen de datos distinto en el que consultar, para ello en lugar de asignar un booleano a la propiedad, que activa o desactiva la búsqueda, 
 * se asignará un objeto con las propiedades a sobrescribir. Las propiedades a sobrescribir no siempre serán las mismas, variarán en función de la configuración que tenga la búsqueda que se quiera modificar.
 * @typedef SearchOptions
 * @extends ControlOptions
 * @see MapControlOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {boolean|CadastralSearchOptions} [cadastralParcel=true] - Esta propiedad activa/desactiva la búsqueda de parcelas catastrales en el buscador del mapa. Formato: municipio, polígono, parcela.
 *
 * Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {@link CadastralSearchOptions}.
 *
 * @property {boolean} [coordinates=true] - Esta propiedad activa/desactiva la localización de coordenadas en Sistema de Referencia ETRS89, bien UTM Huso 30 Norte (EPSG:25830) o latitud-longitud (EPSG:4258, EPSG:4326 o CRS:84) en el buscador del mapa.
 * @property {string} [instructions="Buscar municipio, casco urbano, calle, dirección, referencia catastral, coordenadas UTM o latitud-longitud"] - Esta propiedad establece el atributo `title` del cajetín y del botón del buscador del mapa.
 * @property {boolean|MunicipalitySearchOptions} [municipality=true] - Esta propiedad activa/desactiva la búsqueda de municipios en el buscador del mapa.
 *
 * Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {@link MunicipalitySearchOptions}.
 * @property {boolean|PostalAddressSearchOptions} [postalAddress=true] - Esta propiedad activa/desactiva la búsqueda de direcciones postales en el buscador del mapa. Formato: entidad de población, vía, portal.
 * @property {boolean|StreetSearchOptions} [street=true] - Esta propiedad activa/desactiva la búsqueda de vías en el buscador del mapa. Formato: entidad de población, vía.
 * @property {boolean|TownSearchOptions} [town=true] - Esta propiedad activa/desactiva de cascos urbanos en el buscador del mapa.
 *
 * Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {@link TownSearchOptions}.
 * @example <caption>[Ver en vivo](../examples/cfg.SearchOptions.html)</caption> {@lang html}
 * <div id="mapa"></div>    
 * <script>
 *     // Creamos un mapa con el control de búsquedas. 
 *     // Configuramos el buscador desactivando la búsqueda de parcelas y la localización de coordenadas.
 *     // Indicamos un placeHolder y tooltip (propiedad "instructions") acorde con las búsquedas configuradas.
 *     var map = new SITNA.Map("mapa", {
 *         controls: {
 *             search: {
 *                 coordinates: false,
 *                 cadastralParcel: false,
 *                 municipality: true,
 *                 town: true,
 *                 street: true,
 *                 postalAddress: true,
 *                 placeHolder: "Municipio, casco urbano, calle o portal",
 *                 instructions: "Buscar municipio, casco urbano, calle o portal"
 *             }
 *         }
 *     });
 * </script>
 */
  
/**
 * Opciones de control de búsquedas.
 * @typedef StreetViewOptions
 * @extends ControlOptions
 * @see MapControlOptions
 * @property {HTMLElement|string} [div] - Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
 * @property {string} [googleMapsKey] - El control de StreetView hace uso de la API de Google Maps para funcionar. 
 * Esta propiedad establece la clave de uso asociada al sitio donde está alojada la aplicación que usa la API SITNA. 
 * No es necesaria para hacer funcionar el control pero es recomendable obtener una para garantizar el servicio por parte de Google.
 * 
 * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).
 * @property {HTMLElement|string} [viewDiv] - Elemento del DOM en el que mostrar la vista de StreetView o valor de atributo id de dicho elemento.
 * @example <caption>[Ver en vivo](../examples/cfg.StreetViewOptions.html)</caption> {@lang html}
 * <div id="mapa"/>
 * <div id="sv"/>
 * <script>
 *     // Creamos un mapa con el control de StreetView.
 *     // La vista de StreetView se debe dibujar en el elemento con identificador "sv".
 *     // Se utilizará la clave de Google Maps para el SITNA.
 *     // (Solamente es válida en el sitio web del SITNA, está aquí a título de ejemplo).
 *     var map = new SITNA.Map("mapa", {
 *         controls: {
 *             streetView: {
 *                 viewDiv: "sv",
 *                 googleMapsKey: "AIzaSyDyXgqllcajbMjx8yQxEX28VgA9nQOhtCM"
 *             }
 *         }
 *     });
 * </script>
 */
 
 /**
 * Opciones de controles de mapa, define qué controles se incluyen en un mapa y qué opciones se pasan a cada control.
 * @typedef MapControlOptions
 * @see MapOptions
 * @property {boolean|ControlOptions} [attribution=true] - Si se establece a un valor *truthy*, el mapa tiene atribución. 
 * @property {boolean|ControlOptions} [basemapSelector=false] - Si se establece a un valor *truthy*, el mapa tiene un selector de mapas de fondo.
 * @property {boolean|ClickOptions} [click=false] - Si se establece a un valor *truthy*, el mapa tiene un control que gestiona los clics del usuario sobre su ventana de visualización.
 * La atribución es un texto superpuesto al mapa que actúa como reconocimiento de la procedencia de los datos que se muestran.
 * @property {boolean|CoordinatesOptions} [coordinates=true] - Si se establece a un valor *truthy*, el mapa tiene un indicador de coordenadas y de sistema de referencia espacial.
 * @property {boolean|DataLoaderOptions} [dataLoader=false] - Si se establece a un valor *truthy*,  se muestra un control para añadir datos externos, en concreto servicios WMS y archivos locales de datos geográficos.
 *
 * Se pueden añadir WMS escribiendo la dirección del servicio o eligiendo un servicio de la lista de sugerencias de servicios de interés.
 * 
 * Se pueden añadir datos de archivos buscándolos en el cuadro de diálogo que se abre tras pulsar “Abrir archivo” o arrastrándolos y soltándolos dentro del área del mapa.
 * @property {boolean|FeatureInfoOptions} [featureInfo=true] - Si se establece a un valor *truthy*, el mapa responde a los clics con un información de las capas cargadas de tipo WMS. Se usa para ello la petición `getFeatureInfo` del standard WMS.
 * @property {boolean|LayerCatalogOptions} [layerCatalog=false] - Si se establece a un valor *truthy*, se muestra un control para añadir capas de trabajo desde uno o varios servicios WMS. 
 * Con este control se dispone de las siguientes funcionalidades:
 *
 *    - Consultar las capas disponibles en uno o varios WMS.
 *    - Buscar capas mediante texto libre. Se busca el texto en los títulos y los resúmenes descriptivos de cada capa, que se publican en el [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities) del servicio.
 *    - Añadir capas al mapa como capas de trabajo.
 *
 * Este control se usa habitualmente en combinación con `workLayerManager`, como se muestra en el ejemlo de {@link LayerCatalogOptions}.
 * @property {boolean|ControlOptions} [legend=false] - Si se establece a un valor *truthy*, el mapa tiene leyenda.
 * @property {boolean|ControlOptions} [loadingIndicator=true] - Si se establece a un valor *truthy*, el mapa tiene un indicador de espera de carga.
 * @property {boolean|ControlOptions} [measure=false] - Si se establece a un valor *truthy*, el mapa tiene un medidor de longitudes, áreas y perímetros.
 * @property {boolean|ControlOptions} [navBar=false] - Si se establece a un valor *truthy*, el mapa tiene una barra de navegación con control de zoom.
 * @property {boolean|OverviewMapOptions} [overviewMap=false] - Si se establece a un valor *truthy*, el mapa tiene un mapa de situación.
 * @property {boolean|ControlOptions} [popup=false] - Si se establece a un valor *truthy*, el mapa muestra los datos asociados a los marcadores cuando se pulsa sobre ellos.
 * @property {boolean|ControlOptions} [printMap=false] - Si se establece a un valor *truthy*, se muestra una herramienta para imprimir el mapa en PDF.
 *
 * El control permite al usuario elegir entre varios tamaños de hoja y orientación horizontal o vertical, además se le puede poner un título al documento de impresión.
 * 
 * Al pulsar el botón de imprimir se abre una previsualización como paso previo a la impresión. Ahí el usuario puede realizar unos últimos ajustes a la extensión del mapa.
 * 
 * El PDF se generará al pulsar en el botón dentro de la previsualización.
 * @property {boolean|ControlOptions} [scale=false] - Si se establece a un valor *truthy*, el mapa tiene un indicador numérico de escala.
 * @property {boolean|ControlOptions} [scaleBar=false] - Si se establece a un valor *truthy*, el mapa tiene un indicador gráfico de escala.
 * @property {boolean|ControlOptions} [scaleSelector=false] - Si se establece a un valor *truthy*, el mapa tiene un selector numérico de escala.
 * @property {boolean|SearchOptions} [search=false] - Si se establece a un valor *truthy*, el mapa tiene un buscador. 
 * El buscador localiza coordenadas y busca entidades geográficas tales como: municipios, cascos urbanos, vías, portales y parcelas catastrales de IDENA. 
 * Es posible establecer un origen de datos distinto a IDENA en el que buscar, consultar la sección: 2.3.1. Objeto de configuración de opciones del buscador.
 * @property {boolean|StreetViewOptions} [streetView=true] - Si se establece a un valor *truthy*, el usuario podrá abrir una ventana de Google StreetView en la ubicación seleccionada en el mapa.
 * @property {boolean|ControlOptions} [TOC=false] - Si se establece a un valor *truthy*, el mapa tiene una tabla de contenidos mostrando las capas de trabajo y los grupos de marcadores. 
 * Los controles `TOC` y `workLayerManager` realizan varias funciones comunes, así rara vez será necesario tener los dos a la vez en un visor.
 * @property {boolean|WFSQueryOptions} [WFSQuery=false] - Si se establece a un valor *truthy*, desde el control `workLayerManager` se pueden hacer consultas alfanuméricas a las capas del mapa. 
 * @property {boolean|ControlOptions} [workLayerManager=false] - Si se establece a un valor *truthy*, se muestra un control para consultar y gestionar las capas de trabajo que están cargadas en el mapa. 
 * Con este control se dispone de las siguientes funcionalidades: 
 * 
 *    - Consultar qué capas están cargadas en el mapa
 *    - Ver en qué orden están superpuestas y modificar ese orden
 *    - Comprobar si una capa es visible al nivel de zoom actual
 *    - Activar y desactivar la visibilidad de las capas
 *    - Establecer el grado de transparencia de cada capa
 *    - Borrar capas cargadas
 *    - Consultar metadatos asociados a la capa
 *    - Si está también el control `WFSQuery`, ejecutar consultas alfanuméricas sobre las capas cargadas en el mapa, si cuentan con un servicio WFS pareado al WMS.
 * 
 * Los controles `workLayerManager` y `TOC` realizan varias funciones comunes, así rara vez será necesario tener los dos a la vez en un visor.
 * @example <caption>Ejemplo de uso de propiedad `featureInfo` - [Ver en vivo](../examples/cfg.MapControlOptions.featureInfo.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Añadimos el control featureInfo.
 *     SITNA.Cfg.controls.featureInfo = true;
 *     // Añadimos una capa WMS sobre la que hacer las consultas.
 *     SITNA.Cfg.workLayers = [
 *         {
 *             id: "terremotos",
 *             title: "Terremotos últimos 365 días",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "https://www.ign.es/wms-inspire/geofisica",
 *             layerNames: ["Ultimos365dias"]
 *         }
 *     ];
 *     var map = new SITNA.Map("mapa");
 * </script>
 * @example <caption>Ejemplo de uso de propiedad `printMap` - [Ver en vivo](../examples/cfg.MapControlOptions.printMap.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Añadimos el control de impresión en el primer contenedor.
 *     SITNA.Cfg.controls.printMap = {
 *         div: "slot1"
 *     };
 *     var map = new SITNA.Map("mapa");
 * </script>
 * @example <caption>Ejemplo de uso de propiedad `workLayerManager` - [Ver en vivo](../examples/cfg.MapControlOptions.workLayerManager.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecemos un layout simplificado apto para hacer demostraciones de controles.
 *     SITNA.Cfg.layout = "layout/ctl-container";
 *     // Añadimos el control de capas cargadas en la primera posición.
 *     SITNA.Cfg.controls.workLayerManager = {
 *         div: "slot1"
 *     };
 *     // Añadimos tres capas WMS.
 *     SITNA.Cfg.workLayers = [
 *         {
 *             id: "relieve",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: ["IDENA:mapa_relieve_bn"]
 *         },
 *         {
 *             id: "pefc",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: ["IDENA:FOREST_Pol_MontesPEFC"]
 *         },
 *         {
 *             id: "pistas",
 *             type: SITNA.Consts.layerType.WMS,
 *             url: "//idena.navarra.es/ogc/wms",
 *             layerNames: ["IDENA:FOREST_Lin_PistasForP"]
 *         }
 *     ];
 *     var map = new SITNA.Map("mapa");
 * </script>
 */
            controls: {
                loadingIndicator: true,
                navBar: false,
                scaleBar: false,
                scale: false,
                scaleSelector: false,
                overviewMap: false,
                basemapSelector: false,
                attribution: true,
                TOC: false,
                workLayerManager: false,
                layerCatalog: false,
                coordinates: true,
                legend: false,
                popup: false,
                search: {
                    url: '//idena.navarra.es/ogc/wfs',
                    allowedSearchTypes: {
                        coordinates: {},
                        municipality: {},
                        urban: {},
                        street: {},
                        number: {},
                        cadastral: {}
                    }
                },
                measure: false,
                streetView: false,
                click: false,
                printMap: false,
                featureInfo: {
                    active: true,
                    persistentHighlights: true
                },
                featureTools: true
            },

            layout: null,

/**
 * Opciones de marcador (punto con un icono). Para determinar qué icono se va a asignar al marcador, se leen las propiedades `url`, `cssClass` `group`, en ese orden de preferencia.
 * Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef MarkerOptions
 * @extends MarkerStyleOptions
 * @see SITNA.Map#addMarker
 * @property {object} [data] - Diccionario de pares clave-valor que representa los atributos alfanuméricos del marcador. Al pulsar sobre este, los atributos se mostrarán en un bocadillo.
 * @property {string} [layer] - Esta propiedad se utiliza en {@link SITNA.Map#addMarker}. Es el identificador de una capa de tipo {@link SITNA.Consts.layerType.VECTOR} en la que se añadirá el marcador. 
 * Si no se especifica se creará una capa específica para los marcadores que se añadan por este método.
 * @property {boolean} [showPopup] - Si se establece a `true`, el marcador se añade al mapa con el bocadillo de información asociada visible por defecto.
 * @property {number[]} [anchor=[0.5, 1]] - Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono y [1, 1] la esquina inferior derecha del icono.
 * @property {string[]} [classes=["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]] - Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo `background-image` asociado a la clase.
 * @property {string} [cssClass] - Nombre de una clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
 * @property {number} [height=32] - Altura en píxeles del icono.
 * @property {number} [width=32] - Anchura en píxeles del icono.
 * @property {string} [url] - URL de archivo de imagen que se utilizará para el icono.
 * @property {string} [group] - Nombre de grupo en el que incluir el marcador. Todos los marcadores con el mismo valor en esta propiedad se consideran en un mismo grupo, y 
 * con ello comparten el mismo icono. El icono se selecciona por orden de la lista de clases CSS definida en `classes`. Los grupos se muestran en la tabla de contenidos y en la leyenda.
 * @property {string} [angle] - Nombre del campo del cual extraer la rotación a aplicar a la etiqueta.
 * @property {string} [fontColor="#000000"] - Color del texto de la etiqueta descriptiva del marcador, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [fontSize=10] - Tamaño de fuente del texto de la etiqueta descriptiva del marcador.
 * @property {string} [label] - Colección de nombre de campo o campos de los cuales extraer el valor de la etiqueta.
 * @property {string} [labelOutlineColor="#ffffff"] - Color del contorno del texto de la etiqueta descriptiva del marcador, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [labelOutlineWidth=2] - Anchura en píxeles del trazo del contorno del texto de la etiqueta.
 */

/**
 * Opciones de estilo de punto. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef PointStyleOptions
 * @see StyleOptions
 * @see layout_cfg
 * @property {string} [angle] - Nombre del campo del cual extraer la rotación a aplicar a la etiqueta.
 * @property {string} [fillColor="#000000" ("#333366" en clusters)] - Color de relleno, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [fillOpacity=0.3 (0.6 en clusters)] - Opacidad de relleno, valor de 0 a 1.
 * @property {string} [fontColor="#000000" ("#ffffff" en clusters)] - Color del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [fontSize=10 (9 en clusters)] - Tamaño de fuente del texto de la etiqueta descriptiva del punto.
 * @property {string} [label] - Colección de nombre de campo o campos de los cuales extraer el valor de la etiqueta.
 * @property {string} [labelOutlineColor="#ffffff" (undefined en clusters)] - Color del contorno del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [labelOutlineWidth=2 (undefined en clusters)] - Anchura en píxeles del trazo del contorno del texto de la etiqueta.
 * @property {number} [radius=6 (undefined en clusters)] - Radio en pixels del símbolo que representa el punto.
 * @property {string} [strokeColor="#ff0000" (undefined en clusters)] - Color de trazo de la línea que delimita el símbolo del punto, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [strokeOpacity=1 (undefined en clusters)] - Opacidad de trazo de la línea que delimita el símbolo del punto, valor de 0 a 1.
 * @property {number} [strokeWidth=2 (undefined en clusters)] - Anchura de trazo en píxeles de la línea que delimita el símbolo del punto.
 */

/**
 * Opciones de estilo de marcador (punto con un icono). Para determinar qué icono se va a asignar al marcador, se leen las propiedades `url` y `cssClass`, en ese orden de preferencia.
 * Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef MarkerStyleOptions
 * @see StyleOptions
 * @see layout_cfg
 * @property {number[]} [anchor=[0.5, 1]] - Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono y [1, 1] la esquina inferior derecha del icono.
 * @property {string[]} [classes=["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]] - Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo `background-image` asociado a la clase.
 * @property {string} [cssClass] - Nombre de una clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
 * @property {number} [height=32] - Altura en píxeles del icono.
 * @property {number} [width=32] - Anchura en píxeles del icono.
 * @property {string} [url] - URL de archivo de imagen que se utilizará para el icono.
 * @property {string} [angle] - Nombre del campo del cual extraer la rotación a aplicar a la etiqueta.
 * @property {string} [fontColor="#000000"] - Color del texto de la etiqueta descriptiva del marcador, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [fontSize=10] - Tamaño de fuente del texto de la etiqueta descriptiva del marcador.
 * @property {string} [label] - Colección de nombre de campo o campos de los cuales extraer el valor de la etiqueta.
 * @property {string} [labelOutlineColor="#ffffff"] - Color del contorno del texto de la etiqueta descriptiva del marcador, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [labelOutlineWidth=2] - Anchura en píxeles del trazo del contorno del texto de la etiqueta.
 */
 
 /**
 * Opciones de estilo de línea. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef LineStyleOptions
 * @see StyleOptions
 * @see layout_cfg
 * @property {string} [strokeColor="#ff0000"] - Color de trazo de la línea, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [strokeOpacity=1] - Opacidad de trazo de la línea, valor de 0 a 1.
 * @property {number} [strokeWidth=2] - Anchura de trazo en píxeles de la línea.
 */

/**
 * Opciones de estilo de polígono. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef PolygonStyleOptions
 * @see StyleOptions
 * @see layout_cfg
 * @property {string} [fillColor="#000000"] - Color de relleno, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [fillOpacity=0.3] - Opacidad de relleno, valor de 0 a 1.
 * @property {string} [strokeColor="#ff0000"] - Color de trazo de los lados del polígono, representado en formato hex triplet (`#RRGGBB`).
 * @property {number} [strokeOpacity=1] - Opacidad de trazo de los lados del polígono, valor de 0 a 1.
 * @property {number} [strokeWidth=2] - Anchura de trazo en de los lados del polígono.
 */

/**
 * Opciones de estilo de cluster de puntos. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de esta propiedad
 * (para ver instrucciones de uso de maquetaciones, consultar {@tutorial layout_cfg}).
 * @typedef ClusterStyleOptions
 * @see StyleOptions
 * @see layout_cfg
 * @property {PointStyleOptions} [point] - Opciones de estilo del punto que representa el cluster.
 * @see ClusterOptions
 * @example <caption>[Ver en vivo](../examples/cfg.ClusterStyleOptions.point.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Creamos un mapa con una capa vectorial,
 *     // clustering activado a 50 pixels y estilos personalizados.
 *     var map = new SITNA.Map("mapa", {
 *         workLayers: [
 *             {
 *                 id: "cluster",
 *                 type: SITNA.Consts.layerType.VECTOR,
 *                 title: "Clusters",
 *                 cluster: {
 *                     distance: 50,
 *                     styles: {
 *                         point: {
 *                             fillColor: "#f90",
 *                             fillOpacity: 1,
 *                             strokeColor: "#c60",
 *                             strokeWidth: 2,
 *                             fontColor: "#f90"
 *                         }
 *                     }
 *                 }
 *             }
 *         ]
 *     });
 *     
 *     map.loaded(function () {
 *         // Añadimos puntos aleatorios
 *         var extent = TC.Cfg.initialExtent;
 *         var dx = extent[2] - extent[0];
 *         var dy = extent[3] - extent[1];
 *         
 *         var randomPoint = function () {
 *             var x = extent[0] + Math.random() * dx;
 *             var y = extent[1] + Math.random() * dy;
 *             return [x, y];
 *         }
 *             
 *         for (var i = 0; i < 200; i++) {
 *             var point = randomPoint();
 *             map.addMarker(point, {
 *                 layer: "cluster",
 *                 data: {
 *                     x: point[0],
 *                     y: point[1]
 *                 }
 *             });
 *         }
 *     });
 * </script>
 */
 
 /**
 * Opciones de estilo de entidades geográficas.
 * @typedef StyleOptions
 * @see MapOptions
 * @see WFSQueryOptions
 * @see CadastralSearchOptions
 * @see MunicipalitySearchOptions
 * @see PostalAddressSearchOptions
 * @see StreetSearchOptions
 * @see TownSearchOptions
 * @property {PointStyleOptions} point - Opciones de estilo de punto.
 * @property {LineStyleOptions} line - Opciones de estilo de línea.
 * @property {PolygonStyleOptions} polygon - Opciones de estilo de polígono.
 * @property {MarkerStyleOptions} marker - Opciones de estilo de marcador (punto de mapa con icono).
 * @property {ClusterStyleOptions} cluster - Opciones de estilo de cluster de puntos. Consultar la propiedad `cluster` de {@link LayerOptions} para saber cómo mostrar clusters.
 */
            styles: {
                point: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    strokeOpacity: 1,
                    radius: 6,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -16],
                    fontColor: '#000000',
                    fontSize: 10
                },
                marker: {
                    classes: [
                        TC.Consts.classes.MARKER + 1,
                        TC.Consts.classes.MARKER + 2,
                        TC.Consts.classes.MARKER + 3,
                        TC.Consts.classes.MARKER + 4,
                        TC.Consts.classes.MARKER + 5
                    ],
                    anchor: [.5, 1],
                    width: 32,
                    height: 32,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -32],
                    fontColor: '#000000',
                    fontSize: 10
                },
                line: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    strokeOpacity: 1,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                polygon: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    strokeOpacity: 1,
                    fillColor: '#000000',
                    fillOpacity: 0.3,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                cluster: {
                    point: {
                        fillColor: '#333366',
                        fillOpacity: 0.6,
                        radius: getClusterRadius,
                        label: '${features.length}',
                        fontColor: "#ffffff",
                        fontSize: 9
                    }
                },
                selection: {
                    point: {
                        fillColor: '#008000',
                        fillOpacity: 0.5,
                        strokeColor: '#008000',
                        strokeWidth: 2,
                        radius: 6,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        labelOffset: [0, -16],
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    line: {
                        strokeColor: '#008000',
                        strokeWidth: 2,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    polygon: {
                        strokeColor: '#008000',
                        strokeWidth: 2,
                        fillColor: '#000000',
                        fillOpacity: .3,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    }
                }
            }
        };
    })();

    (function () {
        if (!Array.prototype.map) {
            Array.prototype.map = function (fun /*, thisArg */) {
                "use strict";

                if (this === void 0 || this === null)
                    throw new TypeError();

                var t = Object(this);
                var len = t.length >>> 0;
                if (typeof fun !== "function")
                    throw new TypeError();

                var res = new Array(len);
                var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                for (var i = 0; i < len; i++) {
                    // NOTE: Absolute correctness would demand Object.defineProperty
                    //       be used.  But this method is fairly new, and failure is
                    //       possible only if Object.prototype or Array.prototype
                    //       has a property |i| (very unlikely), so use a less-correct
                    //       but more portable alternative.
                    if (i in t)
                        res[i] = fun.call(thisArg, t[i], i, t);
                }

                return res;
            };
        }

        /* 
         * proxify: returns cross-origin safe URL
         */
        TC.proxify = function (url) {
            url = url.trim();
            var result = url;
            if (TC.Cfg.proxy) {
                var prevent = false;
                if (TC.Cfg.proxyExceptions) {
                    for (var i = 0; i < TC.Cfg.proxyExceptions.length; i++) {
                        if (url.indexOf(TC.Cfg.proxyExceptions[i]) > -1) {
                            prevent = true;
                            break;
                        }
                    }
                }

                if (!prevent && !TC.Util.isSameOrigin(url)) {
                    if (typeof TC.Cfg.proxy == "function") {
                        result = TC.Cfg.proxy(url);
                    } else {
                        result = TC.Cfg.proxy;
                        if (url.substr(0, 4) != "http") result += window.location.protocol;
                        result += encodeURIComponent(url);
                    }
                }
            }
            return result;
        };

        var getHead = function () {
            var result;
            var d = document;
            var ah = d.getElementsByTagName("head");
            if (ah.length === 0) {
                result = d.createElement("head");
                d.documentElement.insertBefore(result, document.body);
            }
            else {
                result = ah[0];
            }
            return result;
        };

        if (typeof TC.isDebug != "boolean") {
            TC.isDebug = true;
        };

        var _showLoadFailedError = function (url) {
            const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));
            TC.error(
                TC.Util.getLocaleString(mapObj.options.locale, "urlFailedToLoad",
                    { url: url }),
                [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],
                "Error al cargar " + url);
        };

        TC.syncLoadJS = function (url) {
            var _sendRequest = function (url, callbackErrorFn) {
                var req = new XMLHttpRequest();
                req.open("GET", url, false); // 'false': synchronous.
                var result;

                req.onreadystatechange = function (e) {
                    if (req.readyState === 4) {
                        if (req.status === 404) {
                            result = false;
                            callbackErrorFn(true);
                        } else if (req.status !== 200) {
                            callbackErrorFn();
                            result = false;
                        } else {
                            result = req.responseText;
                        }
                    }
                };


                try {
                    req.send(null);
                } catch (error) {
                    result = false;
                    callbackErrorFn();
                }

                return result;
            };

            if (!/(\.js|\/)$/i.test(url)) { // Si pedimos un archivo sin extensión se la ponemos según el entorno
                url = url + (TC.isDebug ? '.js' : '.min.js');
            }

            var reqResult = _sendRequest(url, function (is404) {
                if (is404) {
                    _showLoadFailedError(url);
                    return false;
                } else {
                    return _sendRequest(url, function () {
                        _showLoadFailedError(url);
                    });
                }
            });

            if (reqResult) {
                var script = document.createElement("script");
                script.type = "text/javascript";
                script.text = reqResult;
                getHead().appendChild(script);
            }
        };

        const prefixes = ['', '-webkit-', '-moz-', '-o-', '-ms-'];
        const randomText = ':-)';
        const urlString = 'http://sitna.tracasa.es/';
        var touch;
        var inputTypeColor;
        var urlParser;
        TC.browserFeatures = {
            touch: function () {
                if (touch === undefined) {
                    if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
                        touch = true;
                        return true;
                    }
                    const query = prefixes
                        .map(function (prefix) { return '(' + prefix + 'touch-enabled)'; })
                        .join();
                    touch = matchMedia(query).matches;
                }
                return touch;
            },
            inputTypeColor: function () {
                if (inputTypeColor === undefined) {
                    const elm = document.createElement('input');
                    elm.setAttribute('type', 'color');
                    inputTypeColor = elm.type !== 'text' && 'style' in elm;
                    if (inputTypeColor) {
                        elm.value = randomText;
                        inputTypeColor = elm.value !== randomText;
                    }
                }
                return inputTypeColor;
            },
            urlParser: function () {
                if (urlParser === undefined) {
                    try {
                        // have to actually try use it, because Safari defines a dud constructor
                        const url = new URL(urlString);
                        urlParser = url.href === urlString;
                    } catch (e) {
                        urlParser = false;
                    }
                }
                return urlParser;
            }
        };

        const patchJQuery = function () {
            // Parche para soportar $.when
            $._oldWhen = $.when;
            $.when = function () {
                const newArgs = new Array(arguments.length);
                for (var i = 0; i < arguments.length; i++) {
                    const arg = newArgs[i] = arguments[i];
                    if (arg instanceof Promise) {
                        const newArg = $.Deferred();
                        arg
                            .then(function (val) {
                                newArg.resolve(val)
                            })
                            .catch(function (err) {
                                newArg.reject(err);
                            });
                        newArgs[i] = newArg;
                    }
                }
                return $._oldWhen.apply(this, newArgs);
            };
        };

        if (window.jQuery) {
            TC._jQueryIsLoaded = true;
            patchJQuery();
        }
        //else {
        //    Object.defineProperty(window, 'jQuery', {
        //        configurable: true,
        //        get: fnction () {
        //            console.trace();
        //            Object.defineProperty(window, 'jQuery', { writable: true });
        //            TC.syncLoadJS(TC.Consts.url.JQUERY);
        //            patchJQuery();
        //            TC._jQueryIsLoaded = true;
        //            return jQuery;
        //        }
        //    });
        //    Object.defineProperty(window, '$', {
        //        configurable: true,
        //        get: function () {
        //            console.trace();
        //            Object.defineProperty(window, '$', { writable: true });
        //            TC.syncLoadJS(TC.Consts.url.JQUERY);
        //            patchJQuery();
        //            TC._jQueryIsLoaded = true;
        //            return $;
        //        }
        //    });
        //}

        if (!('Promise' in window)) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.PROMISE_POLYFILL);
        }
        // Polyfill para NodeList.forEach
        if (window.NodeList && !NodeList.prototype.forEach) {
            NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if (!('finally' in Promise.prototype)) {
            // Muchos polyfills de Promise no implementan finally, lo hacemos aquí en ese caso
            Promise.prototype.finally = function (callback) {
                const ctor = this.constructor;
                return this.then(
                    function (val) {
                        return ctor.resolve(callback()).then(function () {
                            return val;
                        });
                    },
                    function (err) {
                        return ctor.resolve(callback()).then(function () {
                            throw err;
                        });
                    }
                );
            };
        }

        if (!TC.tool || !TC.tool.Proxification) {
            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
        }

        // Transformación de petición AJAX de jQuery a promesa nativa
        TC.ajax = function (options) {
            return new Promise(function (resolve, reject) {
                options = options || {};
                const method = options.method || 'GET';
                var data;
                if (options.data) {
                    if (typeof options.data === 'string') {
                        data = options.data;
                    }
                    else if (typeof options.data === 'object') {
                        const paramArray = [];
                        for (var key in options.data) {
                            paramArray[paramArray.length] = key + '=' + options.data[key].toString();
                        }
                        data = paramArray.join('&');
                    }
                }
                var url = options.url;
                if (method === 'GET' && data) {
                    url = url + '?' + data;
                }
                if (options.cache === false) {
                    url += (url.indexOf('?') < 0 ? '?' : '&') + 'ts=' + Date.now();
                }
                const request = new XMLHttpRequest();
                request.open(method, url);

                if (options.contentType || typeof options.contentType === 'boolean') {
                    if (options.contentType) {
                        request.setRequestHeader('Content-Type', options.contentType + '; charset=UTF-8');
                    }

                }
                else {
                    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                }

                request.onreadystatechange = function (e) {
                    if (request.readyState === 4) { // DONE
                        if (request.status !== 200) {
                            reject({
                                status: request.status,
                                msg: request.statusText,
                                url: options.url
                            });
                        } else {
                            var responseData;
                            try {
                                switch (options.responseType) {
                                    case TC.Consts.mimeType.JSON:
                                        responseData = JSON.parse(request.responseText);
                                        break;
                                    case TC.Consts.mimeType.XML:
                                        responseData = new DOMParser().parseFromString(request.responseText, 'application/xml');
                                        break;
                                    default:
                                        responseData = request.responseText;
                                        break;
                                }
                                resolve({ data: responseData, contentType: request.getResponseHeader("Content-type") });
                            }
                            catch (error) {
                                reject(error);
                            }
                        }
                    }
                };

                try {
                    request.send(method === 'POST' ? data : null);
                } catch (error) {
                    reject(error);
                }
            });
        };

        TC.loadJSInOrder = function (condition, url, callback) {
            TC.loadJS(condition, url, callback, true);
        };

        const addCrossOriginAttr = function (path, scriptEl) {
            if (!TC.Util.isSameOrigin(path)) {
                scriptEl.crossOrigin = "anonymous";
            }
        };

        TC.loadJS = function (condition, url, callback, inOrder, notCrossOrigin) {
            if (arguments.length < 4) {
                inOrder = false;
            }

            var urls = Array.isArray(url) ? url : [url];
            urls = urls.map(function (elm) {
                if (!/\.js$/i.test(elm) && elm.indexOf(TC.apiLocation) === 0) { // Si pedimos un archivo sin extensión y es nuestro se la ponemos según el entorno
                    return elm + (TC.isDebug ? '.js' : '.min.js');
                }
                return elm;
            });

            if (condition) {
                urls = urls instanceof Array ? urls : [urls];

                var name = "";
                const getName = function (path) {
                    return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
                };
                if (urls.length > 1) {
                    var toReduce = urls.slice(0).filter(function (path, index) {
                        if (loadjs.isDefined(getName(path))) {
                            urls.splice(index, 1);
                            loadjs.ready(getName(path), callback);
                            return false;
                        } else {
                            return true;
                        }
                    });
                    if (toReduce.length === 1) {
                        name = getName(toReduce[0]);
                    } else if (toReduce.length > 0) {
                        name = toReduce.reduce(function (prev, curr) {
                            return getName(prev) + "_" + getName(curr);
                        });
                    }
                } else {
                    name = getName(urls[0]);
                }

                if (name.length > 0) {
                    if (!loadjs.isDefined(name)) {
                        var options = {
                            async: !inOrder,
                            numRetries: 1
                        };

                        if (!notCrossOrigin && !TC.Util.detectIE()) {
                            options.before = addCrossOriginAttr;
                        }

                        loadjs(urls, name, options);
                        loadjs.ready(name, {
                            success: function () {
                                callback();
                            },
                            error: function (pathsNotFound) {
                                _showLoadFailedError(pathsNotFound);
                            }
                        });
                    } else {
                        // Esto vuelve a añadir el script al head si se está pidiendo un script cargado previamente.
                        urls.forEach(function (url) {
                            const urlObj = new URL(url, location.href);
                            const script = Array.from(document.scripts).filter((scr) => scr.src === urlObj.href)[0];
                            if (script) {
                                document.head.appendChild(script.cloneNode());
                            }
                        });
                        loadjs.ready(name, callback);
                    }
                }
            }
            else {
                callback();
            }
        };

        TC.loadCSS = function (url) {
            const getName = function (path) {
                return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
            };

            const name = getName(url);
            if (!loadjs.isDefined(name)) {
                loadjs(url, name, {
                    error: function (pathsNotFound) {
                        _showLoadFailedError(pathsNotFound);
                    },
                    numRetries: 1
                });
            } else {
                loadjs.ready(name, {});
            }
        };

        var projectionDataCache = {};

        TC.getProjectionData = function (options) {
            options = options || {};
            const crs = options.crs || '';
            const match = crs.match(/\d{4,5}$/g);
            let code = match ? match[0] : '';
            const url = TC.Consts.url.EPSG + '?format=json&q=' + code;
            let projData = projectionDataCache[code];
            if (projData) {
                if (options.sync) {
                    return projData;
                }
                return Promise.resolve(projData);
            }
            if (options.sync) {
                let result;
                const xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function (e) {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 404) {
                            result = false;
                        } else if (xhr.status != 200) {
                            result = false;
                        } else {
                            result = xhr.responseText;
                        }
                    }
                };
                xhr.open('GET', url, false);

                try {
                    xhr.send(null);
                } catch (error) {
                    result = false;
                }
                if (result) {
                    result = JSON.parse(result);
                }
                return result;
            }
            return new Promise(function (resolve, reject) {
                const toolProxification = new TC.tool.Proxification(TC.proxify);
                toolProxification.fetchJSON(url, options).then(function (data) {
                    projectionDataCache[code] = data;
                    resolve(data);
                }).catch(function (error) {
                    reject(Error(error));
                });
            });
        };

        TC.loadProjDef = function (options) {
            options = options || {};
            const crs = options.crs;
            const epsgPrefix = 'EPSG:';
            const urnPrefix = 'urn:ogc:def:crs:EPSG::';
            const urnxPrefix = 'urn:x-ogc:def:crs:EPSG:';
            const ogcHttpUrlPrefix = 'http://www.opengis.net/gml/srs/epsg.xml#';
            const ogcHttpUriPrefix = 'http://www.opengis.net/def/crs/EPSG/0/';

            const fromHTTPURIToURN = function (name) {
                var match = /http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/\d\/(\d{4,5})/.exec(name);
                if (match && match.length === 2) {
                    return urnPrefix + match[1];
                }

                return name;
            };

            var getDef;
            if (!window[TC.Consts.PROJ4JSOBJ]) {
                TC.syncLoadJS(TC.url.proj4js);
            }
            getDef = function (name) {
                name = fromHTTPURIToURN(name);
                return proj4.defs(name);
            };
            const loadProj4Def = function (code, def) {
                proj4.defs(code, def);
                if (window.ol && window.ol.proj) {
                    // https://openlayers.org/en/latest/apidoc/module-ol_proj_proj4.html
                    window.ol.proj.proj4.register(proj4);
                }
            };
            const isFunction = function (obj) {
                return typeof obj === 'function';
            };
            const loadDef = function (code, def, name) {
                // Lista sacada de https://docs.geoserver.org/stable/en/user/services/wfs/webadmin.html#gml
                const epsgCode = epsgPrefix + code;
                const urnCode = urnPrefix + code;
                const urnxCode = urnxPrefix + code;
                const ogcHttpUrlCode = ogcHttpUrlPrefix + code;
                const ogcHttpUriCode = ogcHttpUriPrefix + code;
                var axisUnawareDef;
                if (typeof def === 'object') {
                    axisUnawareDef = TC.Util.extend({}, def);
                    def = TC.Util.extend({}, def);
                    if (axisUnawareDef.axis) {
                        delete axisUnawareDef.axis;
                    }
                }
                else if (typeof def === 'string') {
                    axisUnawareDef = def.replace('+axis=neu', '');
                }
                loadProj4Def(epsgCode, def);
                loadProj4Def(urnCode, def);
                loadProj4Def(urnxCode, def);
                // Por convención, los CRS definidos por URL siempre tienen orden de coordenadas X-Y.
                loadProj4Def(ogcHttpUrlCode, axisUnawareDef);
                loadProj4Def(ogcHttpUriCode, def);
                if (crs.indexOf(ogcHttpUrlPrefix) === 0) {
                    // El CRS es tipo URL, usado seguramente en un GML.
                    loadProj4Def(crs, axisUnawareDef);
                    getDef(crs).name = name;
                }
                getDef(epsgCode).name = name;
                getDef(ogcHttpUrlCode).name = name;
                getDef(ogcHttpUriCode).name = name;
            };
            const loadDefResponse = function (data) {
                const result = data && data.status === 'ok' && data.number_result === 1;
                if (result) {
                    var def = data.results[0];
                    loadDef(def.code, def.proj4, def.name);
                }
                return result;
            };

            var idx = crs.lastIndexOf('#');
            if (idx < 0) {
                idx = crs.lastIndexOf('/');
            }
            if (idx < 0) {
                idx = crs.lastIndexOf(':');
            }
            var code = crs.substr(idx + 1);
            var def = getDef(crs);
            if (def) {
                loadDef(code, def, options.name);
                if (isFunction(options.callback)) {
                    options.callback();
                }
            }
            else {
                if (options.def) {
                    loadDef(code, options.def, options.name);
                    if (isFunction(options.callback)) {
                        options.callback();
                    }
                }
                else {
                    const loadDataAndExecCallback = function (data) {
                        if (loadDefResponse(data) && isFunction(options.callback)) {
                            options.callback();
                        };
                    };
                    if (options.sync) {
                        const data = TC.getProjectionData(options);
                        loadDataAndExecCallback(data);
                    }
                    else {
                        TC.getProjectionData(options).then(loadDataAndExecCallback);
                    }
                }
            }
        };

        TC.url = {
            templating: [
                TC.apiLocation + TC.Consts.url.TEMPLATING,
                TC.apiLocation + TC.Consts.url.TEMPLATING_HELPERS,
                TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                TC.apiLocation + TC.Consts.url.TEMPLATING_OVERRIDES
            ],
            templatingRuntime: [
                TC.apiLocation + TC.Consts.url.TEMPLATING_RUNTIME,
                TC.apiLocation + TC.Consts.url.TEMPLATING_HBS_HELPERS
            ],
            templatingFull: [
                TC.apiLocation + TC.Consts.url.TEMPLATING_FULL,
                TC.apiLocation + TC.Consts.url.TEMPLATING_HBS_HELPERS
            ]
        };

        TC.url.ol = TC.apiLocation + TC.Consts.url.OL;
        TC.url.olConnector = TC.apiLocation + TC.Consts.url.OL_CONNECTOR;
        TC.url.proj4js = TC.apiLocation + TC.Consts.url.PROJ4JS;

        // Precargamos el CRS por defecto
        TC.loadProjDef({ crs: 'EPSG:25830', name: 'ETRS89 / UTM zone 30N', def: '+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs' });       
        // Precargamos los CRS de IDENA que tienen orden de ejes neu
        TC.loadProjDef({ crs: 'EPSG:4258', name: 'ETRS89', def: '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3040', name: 'ETRS89 / UTM zone 28N (N-E)', def: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3041', name: 'ETRS89 / UTM zone 29N (N-E)', def: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3042', name: 'ETRS89 / UTM zone 30N (N-E)', def: '+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3043', name: 'ETRS89 / UTM zone 31N (N-E)', def: '+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:4230', name: 'ED50', def: '+proj=longlat +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +no_defs +axis=neu' });        
        //resto de CRS nacionales
        TC.loadProjDef({ crs: 'EPSG:25828', name: 'ETRS89 / UTM zone 28N', def: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs' });        
        TC.loadProjDef({ crs: 'EPSG:25829', name: 'ETRS89 / UTM zone 29N', def: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs' });
        TC.loadProjDef({ crs: 'EPSG:25831', name: 'ETRS89 / UTM zone 31N', def: '+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs' });

        if (!TC.Util) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Util');
        }

        TC.Cfg = TC.Util.extend(true, {}, TC.Defaults, TC.Cfg);

        TC.capabilities = {};

        TC.describeFeatureType = {};

        TC.cache = {};

        TC.alert = function (text) {
            alert(text);
        };

        TC.prompt = function (text, value, callback) {
            var newValue = prompt(text, value);
            if (TC.Util.isFunction(callback)) {
                callback(newValue);
            }
        };

        TC.confirm = function (text, accept, cancel) {
            if (confirm(text)) {
                if (TC.Util.isFunction(accept)) {
                    accept();
                }
            }
            else {
                if (TC.Util.isFunction(cancel)) {
                    cancel();
                }
            }
        };

        TC.error = function (text) {
            if (window.console) {
                console.error(text);
            }

        };

        if (!TC.Map) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Map');
        }

        // OpenLayers connectors
        TC.wrap = {
            Map: function (map) {
                var self = this;
                self.parent = map;
                self.map = null;
                /*
                 *  wrap.getMap: Gets OpenLayers map or a promise for the OpenLayers map
                 */
                self.getMap = function () {
                    return self._promise;
                };                
            },
            Layer: function (layer) {
                var self = this;
                self.parent = layer;
                self.layer = null;
                TC.EventTarget.call(self);
                /*
                 *  getLayer: Gets OpenLayers layer or a promise for the OpenLayers layer
                 */
                self.getLayer = function () {
                    if (self.layer) {
                        return Promise.resolve(self.layer);
                    }
                    return self._promise;
                };
                /*
                 *  setLayer: Resolves the deferred layer object
                 * Parameter: the OpenLayers layer
                 */
                self.setLayer = function (olLayer) {
                    self.layer = olLayer;
                };
            },
            layer: {
                Raster: function () { TC.wrap.Layer.apply(this, arguments); },
                Vector: function () { TC.wrap.Layer.apply(this, arguments); }
            },
            Control: function (ctl) {
                var self = this;
                self.parent = ctl;
            },
            control: {
                Click: function () { TC.wrap.Control.apply(this, arguments); },
                ScaleBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBarHome: function () { TC.wrap.Control.apply(this, arguments); },
                Coordinates: function () { TC.wrap.Control.apply(this, arguments); },
                Search: function () { TC.wrap.Control.apply(this, arguments); },
                Measure: function () { TC.wrap.Control.apply(this, arguments); },
                OverviewMap: function () { TC.wrap.Control.apply(this, arguments); },
                FeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Popup: function () { TC.wrap.Control.apply(this, arguments); },
                GeometryFeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Geolocation: function () { TC.wrap.Control.apply(this, arguments); },
                Draw: function () { TC.wrap.Control.apply(this, arguments); },
                Modify: function () { TC.wrap.Control.apply(this, arguments); },
                CacheBuilder: function () { TC.wrap.Control.apply(this, arguments); },
                Edit: function () { TC.wrap.Control.apply(this, arguments); },
                ResultsPanel: function () { TC.wrap.Control.apply(this, arguments); }
            },
            Feature: function () { },
            Geometry: function () { }
        };
        TC.inherit(TC.wrap.Layer, TC.EventTarget);
        TC.inherit(TC.wrap.layer.Raster, TC.wrap.Layer);
        TC.inherit(TC.wrap.layer.Vector, TC.wrap.Layer);
        TC.inherit(TC.wrap.control.Click, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ScaleBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBarHome, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Coordinates, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Measure, TC.wrap.Control);
        TC.inherit(TC.wrap.control.OverviewMap, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Popup, TC.wrap.Control);
        TC.inherit(TC.wrap.control.FeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.GeometryFeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.Geolocation, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Draw, TC.wrap.Control);
        TC.inherit(TC.wrap.control.CacheBuilder, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Edit, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ResultsPanel, TC.wrap.Control);

        TC.loadCSS(TC.apiLocation + 'TC/css/tcmap.css');


        TC.loadJS(!TC.browserFeatures.urlParser(), TC.apiLocation + TC.Consts.url.URL_POLYFILL, function () { });

        var uids = {};
        TC.getUID = function (prefix) {
            prefix = prefix || '';
            var value = uids[prefix];
            if (!value) {
                value = uids[prefix] = 1;
            }
            var result = prefix + value;
            uids[prefix] = value + 1;
            return result;
        };

        const pluses = /\+/g;
        function raw(s) {
            return s;
        }
        function decoded(s) {
            return decodeURIComponent(s.replace(pluses, ' '));
        }

        TC.cookie = function (key, value, options) {

            // key and at least value given, set cookie...
            if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value === null)) {
                options = TC.Util.extend({}, options);

                if (value === null) {
                    options.expires = -1;
                }

                if (typeof options.expires === 'number') {
                    var days = options.expires, t = options.expires = new Date();
                    t.setDate(t.getDate() + days);
                }

                value = String(value);

                return (document.cookie = [
                    encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
                    options.expires ? ';expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    options.path ? ';path=' + options.path : '',
                    options.domain ? ';domain=' + options.domain : '',
                    options.secure ? ';secure' : ''
                ].join(''));
            }

            // key and possibly options given, get cookie...
            options = value || {};
            var decode = options.raw ? raw : decoded;
            var cookies = document.cookie.split('; ');
            for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
                if (decode(parts.shift()) === key) {
                    return decode(parts.join('='));
                }
            }
            return null;
        };

    })();
}

document.addEventListener('DOMContentLoaded', function () {

    // Completamos los datos de versión
    var build;
    var mapLibrary = 'Unknown library';
    var OL = 'OpenLayers';
    if (TC.Control) {
        build = 'Compiled';
        if (window.ol) {
            mapLibrary = OL + ' ' + ol.VERSION;
        }
    }
    else {
        build = 'On demand';
        mapLibrary = OL;
    }
    TC.version = TC.version + ' (' + build + '; ' + mapLibrary + '; @ ' + TC.apiLocation + ')';

    TC.browser = TC.Util.getBrowser();

    TC.loadJS(!TC.Cfg.acceptedBrowserVersions, TC.apiLocation + 'TC/config/browser-versions.js', function (result) {
        var isSupported = true;
        var versions = TC.Cfg.acceptedBrowserVersions;

        var match = versions.filter(function (item) {
            return item.name.toLowerCase() === TC.browser.name.toLowerCase();
        });

        // GLS: 14/02/2019 Añadimos gestión para que no muestre tostada ni envíe correos en caso de que el navegador sea uno expirado
        if (match.length > 0 && match[0].expired) {
            TC.Cfg.loggingErrorsEnabled = false;
        } else {
            if (match.length > 0 && !isNaN(match[0].version)) {
                if (TC.browser.version < match[0].version) {
                    isSupported = false;
                }
            }

            if (TC.Cfg.oldBrowserAlert && !isSupported) {
                TC.Cfg.loggingErrorsEnabled = false;
                const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));

                TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale).then(function () {
                    TC.error(TC.Util.getLocaleString(mapObj.options.locale, 'outdatedBrowser'), TC.Consts.msgErrorMode.TOAST);
                });
            }
        }
    });

    if (/ip(ad|hone|od)/i.test(navigator.userAgent)) {
        // En iOS, el primer click es un mouseover, por eso usamos touchstart como sustituto.
        TC.Consts.event.CLICK = "touchstart";
    }

    // Gestión de errores
    if (TC.Cfg.loggingErrorsEnabled) {

        if (!window.JL) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSNLOG);
        }

        JL.defaultAjaxUrl = TC.Consts.url.ERROR_LOGGER;

        const onError = (function () {
            var errorCount = 0;

            var mapObj;

            return function (e) {
                mapObj = mapObj || TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));

                var errorMsg, url = "", lineNumber = -1, column = -1, errorObj, apiError;

                if (e.type === "unhandledrejection") {
                    errorMsg = e.reason ? e.reason.message : "";
                    if (e.reason && e.reason.stack) {
                        apiError = e.reason.stack.indexOf(TC.apiLocation) >= 0;
                    } else {
                        apiError = true;
                    }
                    errorObj = e.reason;
                } else {
                    errorMsg = e.message;
                    url = e.filename;
                    lineNumber = e.lineno;
                    column = e.colno;
                    errorObj = e.error;
                    apiError = url.indexOf(TC.apiLocation) >= 0;
                }

                // Si notifyApplicationErrors === false solo capturamos los errores de la API
                if ((TC.Cfg.notifyApplicationErrors || apiError) && errorCount < TC.Cfg.maxErrorCount && TC.Cfg.loggingErrorsEnabled) {
                    // Send object with all data to server side log, using severity fatal, 
                    // from logger "onerrorLogger"
                    var msg = apiError ? TC.Consts.text.API_ERROR : TC.Consts.text.APP_ERROR;
                    JL("onerrorLogger").fatalException({
                        "msg": msg,
                        "errorMsg": errorMsg,
                        "url": url,
                        "lineNumber": lineNumber,
                        "column": column,
                        "appUrl": location.href,
                        "apiVersion": TC.version,
                        "prevState": mapObj.getPreviousMapState(),
                        "userAgent": navigator.userAgent
                    }, errorObj);
                    errorCount++;

                    if (!TC.isDebug) {
                        var DEFAULT_CONTACT_EMAIL = "webmaster@itracasa.es";
                        TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale)
                            .then(function () {
                                TC.error(TC.Util.getLocaleString(mapObj.options.locale, "genericError") + (mapObj.options.contactEmail || DEFAULT_CONTACT_EMAIL), { type: TC.Consts.msgType.ERROR });
                            });
                    }
                }
                // Tell browser to run its own error handler as well   
                return false;
            };
        })();

        window.addEventListener('error', onError, false);
        window.addEventListener('unhandledrejection', onError, false);
    }
});
if (!TC._hbs || (!TC._hbs.compile && Handlebars.compile)) {
    TC._hbs = Handlebars.create();
    Handlebars.noConflict();
}
TC._hbs.registerHelper("i18n", function (key, safe) {
    const value = TC.i18n.currentLocale[key];
    if (typeof value === 'string') {
        return safe ? new TC._hbs.SafeString(value) : value;
    }
    return key;
});

TC._hbs.registerHelper("gt", function (v1, v2) {
    return v1 > v2;
});

TC._hbs.registerHelper("lt", function (v1, v2) {
    return v1 < v2;
});

TC._hbs.registerHelper("eq", function (v1, v2) {
    return v1 == v2;
});

TC._hbs.registerHelper("round", function (value) {
    return Math.round(value);
});

TC._hbs.registerHelper("lowerCase", function (str) {
    return str.toLowerCase();
});

TC._hbs.registerHelper("startsWith", function (str, value) {
    return str.startsWith(value);
});

TC._hbs.registerHelper("isObject", function (obj, options) {
    if (typeof obj === 'object') {
        return options.fn(this);
    }
    else {
        return options.inverse(this);
    }
});

TC._hbs.registerHelper("isArray", function (obj, options) {
    if (Array.isArray(obj)) {
        return options.fn(this);
    }
    else {
        return options.inverse(this);
    }
});

TC._hbs.registerHelper("isKeyValue", function (obj, options) {
    if (obj.hasOwnProperty("value") && typeof obj["value"] !== 'object') {
        return options.fn(this);
    }
    else {
        return options.inverse(this);
    }
});
/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function n(a){return"boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function p(a){var b=ya[a.name],c=b.deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c=ya[a.name],d=c.deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||B(),a.db){if(!b)return c(a.db);o(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),p(a)}})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null)}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e)}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1)})}).catch(c);c(e)}}function B(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f=B(),ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){if(a<0)return void b(null);c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f=a.name===c.name&&e._dbInfo.db,g=f?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a)},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName)},e.onsuccess=function(){var a=e.result;a.close(),b(a)}}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo)}}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++){d[e]._dbInfo.db=null}return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a)},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a)}}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo)}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})})}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return"function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length)}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d)}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a()},function(a,b){d(b)})},d)});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f)},f)},f):f(a,g)},f)}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e})},function(a,b){c(b)})},function(a){c(a)})})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d))}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b()},function(a,b){c(b)})})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b()}).catch(function(a){c(a)})},function(a){c(a)})})}):va.reject("Invalid arguments"),h(d,b),d}function da(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return!1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function ga(){return!fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function na(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),a="function"!=typeof a&&a||{},!a.name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName}var d,e=this;return d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/")}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c)}}):va.reject("Invalid arguments"),h(d,b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return!0;d++}return!1},$a=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb=function(){function a(b){d(this,a);for(var c in bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e)}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}(function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e))}})();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!ab[a]},a.prototype._extend=function(a){sa(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),hb=new gb;b.exports=hb},{3:3}]},{},[4])(4)});


/**
 * Opciones de capa.
 * Esta clase no tiene constructor.
 * @class TC.cfg.LayerOptions
 * @static
 */
/**
 * Identificador único de capa.
 * @property id
 * @type string|undefined
 */
/**
 * Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
 * @property title
 * @type string|undefined
 */
/**
 * Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {{#crossLink "TC.consts.LayerType"}}{{/crossLink}}.
 * @property type
 * @type string|undefined
 */
/**
 * Tipo MIME del formato de archivo de imagen a obtener del servicio. Si esta propiedad no está definida, se comprobará si la capa es un mapa de fondo 
 * (consultar propiedad {{#crossLink "TC.cfg.LayerOptions/isBase:property"}}{{/crossLink}}). En caso afirmativo, el formato elegido será <code>"image/jpeg"</code>, 
 * de lo contrario el formato será <code>"image/png"</code>.
 * @property format
 * @type string|undefined
 */
/**
 * La capa se muestra por defecto si forma parte de los mapas de fondo.
 * @property isDefault
 * @type boolean|undefined
 */
/**
 * La capa es un mapa de fondo.
 * @property isBase
 * @type boolean|undefined
 */
/**
 * Aplicable a capas de tipo WMS y KML. La capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
 * @property hideTree
 * @type boolean|undefined
 */
/**
 * La capa no muestra su título cuando es añadida al control de capas de trabajo.
 * @property hideTitle
 * @type boolean|undefined
 * @default false
 */
/**
 * La capa no aparece en la tabla de contenidos ni en la leyenda. De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
 * @property stealth
 * @type boolean|undefined
 */
/**
 * URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
 * @property thumbnail
 * @type string|undefined
 */
/**
 * Opciones de clustering de puntos.
 * @property cluster
 * @type TC.cfg.ClusterOptions|undefined
 */

/**
 * Árbol de elementos de capa.
 * Esta clase no tiene constructor.
 * @class TC.layer.LayerTree
 * @static
 */
/**
 * Nombre de capa en servicios WMS o WMTS.
 * @property name
 * @type string|undefined
 */
/**
 * Título de capa. Es un texto descriptivo para el usuario.
 * @property title
 * @type string|undefined
 */
/**
 * Identificador único de la capa.
 * @property uid
 * @type string|undefined
 */
/**
 * URL de la imagen con la leyenda de la capa.
 * @property legend
 * @type string|undefined
 */
/**
 * Lista de nodos hijos del nodo actual.
 * @property children
 * @type array|undefined
 */

/**
 * Capa de mapa. Esta clase no debería instanciarse directamente, sino mediante alguna de las clases que heredan de ella.
 * @class TC.Layer
 * @constructor
 * @async
 * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
 */
TC.Layer = function (options) {
    ///<summary>
    ///Constructor
    ///</summary>
    ///<param name="options" type="object">Objeto de opciones de capa.</param>
    ///<returns type="TC.Layer"></returns>
    var _layer = this;

    /**
     * Objeto de opciones de capa.
     * @property options
     * @type TC.cfg.LayerOptions
     * @default {}
     */
    _layer.options = options || {};
    TC.Util.extend(_layer, _layer.options);

    _layer.PROTOCOL_REGEX = /^(f|ht)tp?:\/\//i;

    /**
     * Identificador de capa, debe ser único en el mapa. Si no se asigna en las opciones del constructor, se genera uno automáticamente.
     * @property id
     * @type string
     */
    _layer.id = _layer.options.id || TC.getUID();

    /**
     * Objeto del mapa al que pertenece la capa.
     * @property map
     * @type TC.Map|undefined
     */
    _layer.map = _layer.options.map;
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     */
    _layer.type = _layer.options.type || TC.Consts.layerType.WMS;

    /**
     * Fragmento HTML para utilizar como leyenda.
     * @property customLegend
     * @type string
     */
    _layer.customLegend = _layer.options.customLegend; 
    var defaultFormat = _layer.options.isBase ? TC.Consts.mimeType.JPEG : TC.Consts.mimeType.PNG;
    _layer.options.format = _layer.options.format || defaultFormat;

    if (_layer.options.owner) {
        _layer.owner = _layer.options.owner;
    }

    if (_layer.options.hideTree === undefined) {
        _layer.options.hideTree = true;
    }

    if (_layer.options.hideTitle === undefined) {
        _layer.options.hideTitle = false;
    }

    _layer._cache = {
        visibilityStates: {}
    };

    /**
     * Árbol de los componentes de la capa. Estos componentes son distintos según el tipo de capa: así, en una capa WMS son las distintas capas del servicio, 
     * en una capa KML son carpetas.
     * @property tree
     * @type TC.layer.LayerTree|null
     */
    _layer.tree = null;

    /**
     * Objeto envoltorio de la capa nativa de OpenLayers.
     * @property wrap
     * @type TC.wrap.Layer|null
     */
    _layer.wrap = null;
};

TC.Layer.state = {
    IDLE: 'idle',
    LOADING: 'loading'
};

/**
 * Establece la visibilidad de la capa en el mapa.
 * @method setVisibility
 * @param {boolean} visible <code>true</code> si se quiere mostrar la capa, <code>false</code> si se quiere ocultarla.
 */
TC.Layer.prototype.setVisibility = function (visible) {
    this.wrap.setVisibility(visible);
};

/**
 * Obtiene la visibilidad actual de la capa en el mapa.
 * @method getVisibility
 * @return {boolean} <code>true</code> si la capa está visible, <code>false</code> si está oculta.
 */
TC.Layer.prototype.getVisibility = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.getVisibility();
        }
    }
    return result;
};


/**
 * Obtiene la opacidad actual de la capa en el mapa.
 * @method getOpacity
 * @return {number}.
 */
TC.Layer.prototype.getOpacity = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.layer.getOpacity();
        }
    }
    return result;
};

/**
 * Establece la opacidad de la capa en el mapa. Hay que tener en cuenta que establecer opacidad 0 a una capa no es 
 * equivalente que llamar a TC.Layer.{{#crossLink "TC.Layer/setVisibility:method"}}{{/crossLink}} con el valor del parámetro <code>false</code>.
 * @method setOpacity
 * @param {number} opacity Valor entre <code>0</code> (capa transparente) y <code>1</code> (capa opaca).
 * @param {boolean} mute Indica si al establecer opacidad no se lanza evento LAYEROPACITY.
 */
TC.Layer.prototype.setOpacity = function (opacity, mute) {
    var layer = this;
    this.wrap.getLayer().then(function (olLayer) {
        olLayer.setOpacity(opacity);
        layer.opacity = opacity;
        if (layer.map && !mute) {
            layer.map.trigger(TC.Consts.event.LAYEROPACITY, { layer: layer, opacity: opacity });
        }
    });
};

/**
 * Determina si la capa se puede mostrar en el CRS especificado.
 * @method isCompatible
 * @param {string} crs Cadena con el well-known ID (WKID) del CRS.
 * @return {boolean}
 */
TC.Layer.prototype.isCompatible = function (crs) {
    return true;
};

/**
 * Determina si la capa tiene nombres válidos.
 * @method isValidFromNames
 * @return {boolean}
 */
TC.Layer.prototype.isValidFromNames = function () {
    return true;
};

/**
 * Determina si la capa es de tipo raster.
 * @method isRaster
 * @return {boolean}
 */
TC.Layer.prototype.isRaster = function () {
    var result = true;
    var _layer = this;
    switch (_layer.type) {
        case TC.Consts.layerType.VECTOR:
        case TC.Consts.layerType.KML:
        case TC.Consts.layerType.WFS:
        case TC.Consts.layerType.GROUP:
            result = false;
            break;
        default:
            break;
    }
    return result;
};

/**
 * Determina si la capa es visible a la resolución actual. Para ello consulta el documento de capabilities en los casos en que exista.
 * @method isVisibleByScale
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByScale = function (name) {
    return true;
};


/**
 * Determina si una capa del servicio está establecida en el mapa como visible.
 * @method isVisibleByName
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByName = function (name) {
    return true;
};

/**
 * <p>Devuelve un árbol de información de la capa. Como mínimo devuelve un nodo raíz con el título de la capa.</p>
 * <p>En capas de servicios WMS es la jerarquía de capas obtenida del documento capabilities. Dependiendo del valor de la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/hideTree:property"}}{{/crossLink}}, 
 * puede mostrar un árbol de todas las capas del servicio o solo un árbol de las capas visibles inicialmente.</p>
 * <p>En capas de documentos KML cada nodo es una carpeta del documento.</p>
 * <p>Si la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/stealth:property"}}{{/crossLink}} está establecida a <code>true</code>, este método devuelve <code>null</code>.</p>
 * @method getTree
 * @return {TC.layer.LayerTree}
 */
TC.Layer.prototype.getTree = function () {
    var _layer = this;
    var result = { name: _layer.name, title: _layer.title };
    return result;
};

/**
 * Devuelve un nodo del árbol de información de la capa.
 * @method findNode
 * @param {string} id Identificador del nodo.
 * @param {TC.layer.LayerTree} parent Nodo desde el que se comienza la búsqueda.
 * @return {TC.layer.LayerTree} Si no se encuentra el nodo el método devuelve <code>null</code>.
 */
TC.Layer.prototype.findNode = function findNode(id, parent) {
    var result = null;
    if (parent.uid == id) {
        result = parent;
    }
    else {
        for (var i = 0; i < parent.children.length; i++) {
            var r = findNode(id, parent.children[i]);
            if (r) {
                result = r;
                break;
            }
        }
    }
    return result;
};


/**
 * Establece la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method setNodeVisibility
 * @param {string} id Identificador del nodo.
 * @param {boolean} visible <code>true</code> si se quiere mostrar el elemento, <code>false</code> si se quiere ocultar.
 */
TC.Layer.prototype.setNodeVisibility = function (id, visible) {
    this.setVisibility(visible);
};

/**
 * Obtiene la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method getNodeVisibility
 * @param {string} id Identificador del nodo.
 * @return {TC.consts.Visibility}
 */
TC.Layer.prototype.getNodeVisibility = function (id) {
    return TC.Consts.visibility.VISIBLE;
};


TC.Layer.prototype.getResolutions = function () {
    if (this.wrap.getResolutions) {
        return this.wrap.getResolutions();
    }
    else {
        return [];
    }
};

TC.Layer.prototype.setProjection = function () {
};

TC.Layer.prototype.getBySSL_ = function (url) {
    var self = this;

    return url.replace(self.PROTOCOL_REGEX, "https://");
};

(function () {
    const isWebWorkerEnabled = window.hasOwnProperty('Worker');
    const wwPromise = new Promise(function (resolve, reject) {
        if (isWebWorkerEnabled) {
            // Para evitar problemas con IE10 y Opera evitamos el uso de blobs cuando es evitable
            var wwLocation = TC.apiLocation + 'TC/workers/tc-caps-web-worker.js';
            if (TC.Util.isSameOrigin(TC.apiLocation)) {
                resolve(wwLocation);
            }
            else {
                TC.ajax({
                    url: wwLocation,
                    method: 'GET',
                    responseType: 'text'
                }).then(
                    function (response) {
                        const data = response.data;
                        var blob = new Blob([data], { type: "text/javascript" });
                        var url = window.URL.createObjectURL(blob);
                        resolve(url);
                    },
                    function (e) {
                        reject(Error(e));
                    }
                    );
            }
        }
    });

    const parseCapabilities = function (layer, data) {
        var capabilities;

        if (data.documentElement) {

            const serviceException = data.getElementsByTagName('ServiceException')[0];
            if (serviceException) {
                capabilities = { error: serviceException.textContent };
            }
            else {
                var format = (layer.type === TC.Consts.layerType.WMTS) ? new layer.wrap.WmtsParser() : new layer.wrap.WmsParser();
                capabilities = format.read(data);

                //parsear a manija los tileMatrixSetLimits, que openLayers no lo hace (de momento)
                if (layer.type === TC.Consts.layerType.WMTS) {
                    if (capabilities.Contents && capabilities.Contents.Layer) {
                        const layerCollection = data.getElementsByTagName('Layer');
                        for (var i = 0, len = layerCollection.length; i < len; i++) {
                            const curXmlLy = layerCollection[i];
                            var nd = TC.Util.getElementByNodeName(curXmlLy, "ows:Identifier")[0];
                            var id = nd.firstChild.data;

                            var capLy = capabilities.Contents.Layer.filter(function (ly) {
                                return ly.Identifier == id;
                            });

                            if (capLy.length) {
                                capLy = capLy[0];
                                for (var j = 0; j < capLy.TileMatrixSetLink.length; j++) {
                                    var capLink = capLy.TileMatrixSetLink[j];
                                    matrixId = capLink.TileMatrixSet;

                                    var xmlLink;
                                    const xmlLinks = curXmlLy.getElementsByTagName('TileMatrixSetLink');
                                    for (var k = 0, kk = xmlLinks.length; k < kk; k++) {
                                        const curLink = xmlLinks[k];
                                        if (curLink.querySelector("TileMatrixSet:first").textContent == matrixId) {
                                            xmlLink = curLink;
                                            break;
                                        }
                                    }

                                    if (xmlLink) {
                                        capLink.TileMatrixSetLimits = [];
                                        const tmlCollection = xmlLink.getElementsByTagName('TileMatrixLimits');
                                        for (var k = 0, kk = tmlCollection.length; k < kk; k++) {
                                            const lim = tmlCollection[k];
                                            capLink.TileMatrixSetLimits.push({
                                                TileMatrix: lim.getElementsByTagName('TileMatrix')[0].textContent,
                                                MinTileRow: parseInt(lim.getElementsByTagName('MinTileRow')[0].textContent),
                                                MinTileCol: parseInt(lim.getElementsByTagName('MinTileCol')[0].textContent),
                                                MaxTileRow: parseInt(lim.getElementsByTagName('MaxTileRow')[0].textContent),
                                                MaxTileCol: parseInt(lim.getElementsByTagName('MaxTileCol')[0].textContent)
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            storeCapabilities(layer, capabilities);
            return Promise.resolve(capabilities);
        }
        else {
            return new Promise(function (resolve, reject) {
                if (isWebWorkerEnabled && typeof data === 'string') {
                    wwPromise.then(function (wwUrl) {
                        var worker = new Worker(wwUrl);
                        worker.onmessage = function (e) {
                            if (e.data.state === 'success') {
                                capabilities = e.data.capabilities;

                                // GLS: Sólo almacenamos si el capabilities es correcto
                                storeCapabilities(layer, capabilities);
                            }
                            else {
                                capabilities = {
                                    error: 'Web worker error'
                                }
                                reject(capabilities.error);
                            }

                            resolve(capabilities);
                            worker.terminate();
                        };
                        worker.postMessage({
                            type: layer.type,
                            text: data,
                            url: (TC.apiLocation.indexOf("http") >= 0 ? TC.apiLocation : document.location.protocol + TC.apiLocation)
                        });
                    })
                }
                else {
                    capabilities = data;
                    resolve(capabilities);
                }
            });
        }
    };

    const capabilitiesError = function (layer, reason) {
        return 'No se pudo obtener el documento de capacidades del servicio ' + layer.url + ': [' + reason + ']';
    };

    const getCapabilitiesOnline = function () {
        var layer = this;
        return new Promise(function (resolve, reject) {
            const url = layer.getGetCapabilitiesUrl();

            layer.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {
                parseCapabilities(layer, data.responseText)
                    .then(function (capabilities) {
                        if (capabilities.error) {
                            reject(Error(capabilitiesError(layer, capabilities.error)));
                            return;
                        }
                        resolve(capabilities);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            }).catch(function (dataError) {
                reject(Error(capabilitiesError(layer, dataError)));
            });

        });
    };

    const getCapabilitiesFromStorage = function () {
        var layer = this;
        return new Promise(function (resolve, reject) {
            // Obtenemos el capabilities almacenado en caché
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(layer.CAPABILITIES_STORE_KEY_PREFIX + layer.url)
                    .then(function (value) {
                        if (value) {
                            resolve(value);
                        }
                        else {
                            reject(Error('Capabilities not in storage: ' + layer.url));
                        }
                    })
                    .catch(function () {
                        reject(Error('Undefined storage error'));
                    });
            });
        });
    };

    const storeCapabilities = function (layer, capabilities) {
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {

            // Esperamos a que el mapa se cargue y entonces guardamos el capabilities.
            // Así evitamos que la operación, que es bastante pesada, ocupe tiempo de carga 
            // (con el efecto secundario de que LoadingIndicator esté un tiempo largo apagado durante la carga)
            var capKey = layer.CAPABILITIES_STORE_KEY_PREFIX + layer.options.url;
            var setItem = function () {
                // GLS: antes de guardar, validamos que es un capabilities sin error
                if (capabilities.hasOwnProperty("error")) {
                    return;
                } else {

                    layer.getCapabilitiesPromise().then(function () {
                        localforage.setItem(capKey, capabilities).catch(err => console.log(err));
                    });
                }
            };
            if (layer.map) {
                layer.map.loaded(setItem);
            }
            else {
                setItem();
            }
        });
    };

    const cleanOgcUrl = function (url) {
        var result = url;
        if (url) {
            var match = url.match(/\??SERVICE=\w+&/i);
            if (match) {
                result = result.replace(match[0], '');
            }
        }
        return result;
    };
    TC.Layer.prototype.getGetMapUrl = function () {
        return cleanOgcUrl(this.wrap.getGetMapUrl());
    };

    TC.Layer.prototype.getCapabilitiesOnline = getCapabilitiesOnline
    TC.Layer.prototype.getCapabilitiesFromStorage = getCapabilitiesFromStorage
})();




TC.control = TC.control || {};
TC.Control = function () {
    const self = this;
    TC.EventTarget.call(self);

    self.map = null;
    self.isActive = false;
    self.isDisabled = false;

    var len = arguments.length;

    self.options = TC.Util.extend({}, len > 1 ? arguments[1] : arguments[0]);
    self.id = self.options.id || TC.getUID(self.CLASS.substr(TC.Control.prototype.CLASS.length + 1) + '-');
    self.div = TC.Util.getDiv(self.options.div ? self.options.div : arguments[0]);
    if (TC._jQueryIsLoaded) {
        self._$div = $(self.div);
    }

    self.div.classList.add(TC.Control.prototype.CLASS, self.CLASS);
    
    self.template = self.options.template || self.template;
    self.exportsState = false;
};

TC.inherit(TC.Control, TC.EventTarget);

(function () {
    const ctlProto = TC.Control.prototype;

    ctlProto.CLASS = 'tc-ctl';

    ctlProto.template = '';

    ctlProto.show = function () {
        this.div.style.display = '';
    };

    ctlProto.hide = function () {
        this.div.style.display = 'none';
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(null, function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto._set1stRenderPromise = function (promise) {
        const self = this;
        if (!self._firstRender) {
            self._firstRender = promise;
        }
        return promise;
    };

    const processTemplates = function (ctl, data, templates) {
        return new Promise(function (resolve, reject) {
            const htmlPromises = [];
            const templateKeys = [];
            for (var key in templates) {
                var template = templates[key];
                if (typeof template === 'string') {
                    if (dust.cache[ctl.CLASS]) {
                        dust.render(ctl.CLASS, data, function (err, out) {
                            ctl.div.innerHTML = out;
                            if (err) {
                                TC.error(err);
                            }
                        });
                    } else {
                        var prom = TC.ajax({
                            url: template,
                            method: "GET",
                            responseType: 'text'
                        });
                        htmlPromises.push(prom);
                        templateKeys.push(key);
                    }
                }
                else if (TC.Util.isFunction(template)) {
                    template();
                }
            }

            if (htmlPromises.length === 0) {
                resolve();
            }
            else {
                Promise.all(htmlPromises)
                    .then(function (responseArray) {
                        responseArray
                            .map(response => response.data)
                            .forEach(function (template, idx) {
                            const tpl = dust.compile(template, templateKeys[idx]);
                            dust.loadSource(tpl);
                        });
                        resolve();
                    })
                    .catch(function (err) {
                        console.error("Error fetching templates: " + err);
                        reject(err instanceof Error ? err : Error(err));
                    });
            }

        });
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.map) {
                self.trigger(TC.Consts.event.BEFORECONTROLRENDER, { dataObject: data });
            }
            self.div.classList.toggle(TC.Consts.classes.DISABLED, self.isDisabled);

            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    var tplProm;

                    if (typeof self.template === 'object') {
                        tplProm = processTemplates(self, data, self.template);
                    }
                    else {
                        var templates = {};

                        if (self.template) templates[self.CLASS] = self.template;


                        tplProm = processTemplates(self, data, templates);
                    }

                    tplProm
                        .then(function () {
                            if (dust.cache[self.CLASS]) {
                                dust.render(self.CLASS, data, function (err, out) {
                                    self.div.innerHTML = out;
                                    if (err) {
                                        reject(Error(err));
                                        TC.error(err);
                                    }
                                });
                            }

                            self.trigger(TC.Consts.event.CONTROLRENDER);
                            if (TC.Util.isFunction(callback)) {
                                callback();
                            }
                            resolve();
                        })
                        .catch(function (err) {
                            reject(err instanceof Error ? err : Error(err));
                        });
                }
            );
        });
    };

    ctlProto.getRenderedHtml = function (templateId, data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var render = function () {
                if (dust.cache[templateId]) {
                    dust.render(templateId, data, function (err, out) {
                        if (err) {
                            TC.error(err);
                            reject(Error(err));
                        }
                        else {
                            if (TC.Util.isFunction(callback)) {
                                callback(out);
                            }
                            resolve(out);
                        }
                    });
                }
            };
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    if (!dust.cache[templateId]) {
                        var template = self.template[templateId];
                        if (typeof template === 'string') {
                            TC.ajax({
                                url: template,
                                method: "GET",
                                responseType: 'text'
                            })
                                .then(function (response) {
                                    const html = response.data;
                                    var tpl = dust.compile(html, templateId);
                                    dust.loadSource(tpl);
                                    render();
                                })
                                .catch(function (err) {
                                    console.log("Error fetching template: " + err)
                                });
                        }
                        else if (TC.Util.isFunction(template)) {
                            template();
                            render();
                        }
                    }
                    else {
                        render();
                    }
                }
            );
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.map = map;
            Promise.resolve(self.render()).then(function () {
                if (self.options.active) {
                    self.activate();
                }
                resolve(self);
            });
        });
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.map && self.map.activeControl && self.map.activeControl != self) {
            self.map.previousActiveControl = self.map.activeControl;
            self.map.activeControl.deactivate();
        }
        self.isActive = true;
        if (self.map) {
            self.map.activeControl = self;
            self.map.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
        }
    };

    ctlProto.deactivate = function (stopChain) {
        if (arguments.length == 0) stopChain = false;

        var self = this;
        self.isActive = false;
        if (self.map) {
            self.map.activeControl = null;

            if (!stopChain) {
                //determinar cuál es el control predeterminado para reactivarlo
                //salvo que sea yo mismo, claro
                var nextControl = self.map.getDefaultControl();
                if (nextControl == self) nextControl = null;
                else if (self.map.previousActiveControl == self) // GLS: Validamos antes de activar que el control activo anterior sea distinto al control actual
                    nextControl = null;
                else if (!nextControl) {
                    nextControl = self.map.previousActiveControl;
                }

                if (nextControl)
                    nextControl.activate();
            }
            self.map.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
        }
    };

    ctlProto.enable = function () {
        var self = this;
        self.isDisabled = false;
        if (self.div) {
            self.div.classList.remove(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.disable = function () {
        var self = this;
        self.isDisabled = true;
        if (self.div) {
            self.div.classList.add(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.renderPromise = function () {
        const self = this;
        return self._firstRender || new Promise(function (resolve, reject) {
            self.one(TC.Consts.event.CONTROLRENDER, function () {
                resolve(self);
            });
        });
    };

    ctlProto.addUIEventListener = function (selector, event, listener) {
        const self = this;
        const elements = selector ? self.div.querySelectorAll(selector) : [self.div];
        elements.forEach(function (elm) {
            elm.addEventListener(event, listener);
        });
    };

    ctlProto.addUIEventListeners = function () {
    };

    ctlProto.isExclusive = function () {
        return false;
    };

    ctlProto.getLocaleString = function (key, texts) {
        var self = this;
        var locale = self.map ? self.map.options.locale : TC.Cfg.locale;
        return TC.Util.getLocaleString(locale, key, texts);
    };

    ctlProto.getUID = function () {
        const self = this;
        return TC.getUID(self.id + '-');
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {};
        }
        return null;
    };

    ctlProto.importState = function (state) {
    };
})();
TC.feature = TC.feature || {};
TC.Feature = function (coords, options) {
    var self = this;

    self.wrap = new TC.wrap.Feature();
    self.wrap.parent = self;
    if (self.wrap.isNative(coords)) {
        self.wrap.feature = coords;
        coords._wrap = self.wrap;
        self.id = self.wrap.getId();
        self.geometry = self.wrap.getGeometry();
        if (coords._folders) {
            self.folders = coords._folders;
        }
        self.data = self.wrap.getData();
    }

    var opts = self.options = TC.Util.extend(true, {}, options);

    self.id = self.id || opts.id || TC.getUID();
    self.data = opts.data || self.data || null;
    self._visibilityState = TC.Consts.visibility.VISIBLE;
    if (opts.showsPopup === undefined) {
        self.showsPopup = true;
    }
    else {
        self.showsPopup = opts.showsPopup;
    }
    self.layer = opts.layer || null;
    self._selected = false;

    if (opts.selected) {
        self.select();
    }
};

TC.Feature.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.Feature.prototype.CLASSNAME = 'TC.Feature';

TC.Feature.prototype.getPath = function () {
    var result = [];
    var self = this;
    if (self.folders) {
        result = self.folders;
    }
    else if (self.options.group) {
        result = [self.options.group];
    }
    return result;
};

TC.Feature.prototype.setVisibility = function (visible) {
    var self = this;

    // Ocultamos el posible popup
    if (!visible && self.showsPopup && self.layer) {
        var popup = self.layer.map.getControlsByClass(TC.control.Popup).filter(function (popup) {
            return popup.currentFeature === self
        });

        if (popup.length > 0) {
            const p = popup[0];
            if (p.isVisible()) {
                p.hide();
            }
        }
    }

    if ((visible && self._visibilityState === TC.Consts.visibility.NOT_VISIBLE) || (!visible && self._visibilityState === TC.Consts.visibility.VISIBLE)) {
        self._visibilityState = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
        self.layer.wrap.setFeatureVisibility(self, visible);
    }
};

TC.Feature.prototype.setId = function (id) {
    var self = this;
    self.id = id;
    self.wrap.setId(id);
};

TC.Feature.prototype.getBounds = function () {
    return this.wrap.getBounds();
};

TC.Feature.prototype.setStyle = function (style) {
    this.wrap.setStyle(style);
};

TC.Feature.prototype.toggleSelectedStyle = function (condition) {
    const self = this;
    if (self._hasSelectedStyle != condition) {
        self._hasSelectedStyle = condition;
        self.wrap.toggleSelectedStyle(condition);
    }
};

TC.Feature.prototype.getLegend = function () {
    var self = this;
    if (!self._legend) {
        self._legend = self.wrap.getLegend();
    }
    return self._legend;
};

TC.Feature.prototype.getCoords = function () {
    const self = this;
    self.geometry = self.wrap.getGeometry();
    return self.geometry;
};

TC.Feature.prototype.getCoordsArray = function () {
    const self = this;
    const isPoint = function (elm) {
        return Array.isArray(elm) && elm.length >= 2 && typeof elm[0] === 'number' && typeof elm[1] === 'number';
    };
    const flattenFn = function (val) {
        return isPoint(val) ? [val] : val.reduce(reduceFn, []);
    }
    const reduceFn = function (acc, elm) {
        if (isPoint(elm)) {
            acc[acc.length] = elm;
        }
        else {
            acc = acc.concat(flattenFn(elm));
        }
        return acc;
    };
    return flattenFn(self.getCoords());
};

TC.Feature.prototype.getGeometryStride = function () {
    const self = this;
    const coordsArray = self.getCoordsArray();
    const firstCoord = coordsArray[0];
    if (firstCoord) {
        return firstCoord.length;
    }
    return 0;
}


TC.Feature.prototype.setCoords = function (coords) {
    const self = this;

    const toNumberCoords = function (arr) {
        arr.forEach(function (elm, idx) {
            if (Array.isArray(elm)) {
                toNumberCoords(elm);
            }
            else {
                if (elm === null) {
                    arr[idx] = 0;
                }
                else if (typeof elm !== 'number') {
                    console.log('Warning: coordinate does not have number type');
                    arr[idx] = parseFloat(elm);
                }
            }
        });
    };

    if (Array.isArray(coords)) {
        toNumberCoords(coords);
    }

    self.geometry = coords;
    return self.wrap.setGeometry(coords);
};

TC.Feature.prototype.getData = function () {
    var result = null;
    var self = this;
    if (self.data) {
        result = self.data;
    }
    else {
        result = self.wrap.getData();
    }
    return result;
};

TC.Feature.prototype.setData = function (data) {
    const self = this;
    self.data = TC.Util.extend(self.data, data);
    self.wrap.setData(data);
};

TC.Feature.prototype.unsetData = function (key) {
    const self = this;
    delete self.data[key];
    self.wrap.unsetData(key);
};

TC.Feature.prototype.clearData = function () {
    const self = this;
    self.data = {};
    self.wrap.clearData();
};

TC.Feature.prototype.getInfo = function (options) {
    var result = null;
    var self = this;
    options = options || {};
    var locale = options.locale || (self.layer && self.layer.map && TC.Util.getMapLocale(self.layer.map));
    var data = self.getData();
    if (typeof data === 'object') {
        var template = self.wrap.getTemplate();
        if (template) {
            // GLS: Contemplo en la expresión regular la opción de que el nombre del campo se componga de $[aaa/abc/loQueMeInteresa] 
            // (la expresión no está limitada a 2 niveles), hasta ahora se manejaba $[loQueMeInteresa]
            result = template.replace(/\$\[?(?:\w+\/)*(\w+)\]/g, function (match, p1) {
                return data[p1];
            });
        }
        else {
            var html = [];
            const hSlots = [];
            const openText = TC.Util.getLocaleString(locale, 'open');
            const titleText = TC.Util.getLocaleString(locale, 'linkInNewWindow');
            const formatValue = function (value) {
                var html = [];
                var isUrl = TC.Util.isURL(value);
                if (isUrl) {
                    html[html.length] = '<a href="';
                    html[html.length] = value;
                    html[html.length] = '" target="_blank" title="';
                    html[html.length] = titleText;
                    html[html.length] = '">';
                    html[html.length] = openText;
                    html[html.length] = '</a>';
                }
                else {
                    html[html.length] = value !== undefined ? (typeof (value) === "number"?TC.Util.formatNumber(value, locale):value) : '&mdash;';
                }
                return html;
            }
            const recursiva = function (data) {
                var html = [];
                if (data instanceof Array) {
                    html[html.length] = '<div class="complexAttr">';
                    var id = 'complexAttr_' + TC.getUID()
                    html[html.length] = '<input type="checkbox" id="' + id + '" />';
                    html[html.length] = '<div>';
                    html[html.length] = '<label for="' + id + '" title="" class="plus"></label>';
                    html[html.length] = '<label for="' + id + '" title="" class="title">' + data.length + ' ' + TC.Util.getLocaleString(locale, 'featureInfo.complexData.array') + '</label><br/>';
                    html[html.length] = '<table class="complexAttr"><tbody>';
                    for (var i = 0; i < data.length; i++) {
                        html[html.length] = '<tr><td>';
                        html = html.concat(recursiva(data[i]));
                        html[html.length] = '</td></tr>';
                    }
                    html[html.length] = '</tbody></table></div></div>';
                } else if (data instanceof Object) {
                    html[html.length] = '<table class="complexAttr"><tbody>';
                    for (var i in data) {
                        html[html.length] = '<tr>';
                        if (data[i] && data[i] instanceof Array) {
                            html[html.length] = '<th style="display:none">' + i + '</th><td>'
                            html[html.length] = '<label for="' + id + '" class="title">' + i + '</label><br/>';
                            html = html.concat(recursiva(data[i]));
                            html[html.length] = '</div></td>';
                        }
                        else if (data[i] && data[i] instanceof Object) {
                            //if(data[i] && Object.entries(data[i]).some((item)=>{return item[1] instanceof Object})){						
                            var id = 'complexAttr_' + TC.getUID()
                            html[html.length] = '<th style="display:none">' + i + '</th><td>';
                            html[html.length] = '<input type="checkbox" id="' + id + '" /><div>';
                            html[html.length] = '<label for="' + id + '" title="" class="plus"></label>';
                            html[html.length] = '<label for="' + id + '" title="" class="title">' + i + '</label><br/>';
                            html = html.concat(recursiva(data[i]));
                            html[html.length] = '</div></td>';
                        }
                        else {
                            html[html.length] = '<th class="key">' + i + '</th>';
                            html[html.length] = '<td class="value">';
                            html = html.concat(recursiva(data[i]));
                            html[html.length] = '</td>';
                        }
                        html[html.length] = '</tr>';
                    }
                    html[html.length] = '</tbody></table>';
                } else {
                    html = html.concat(formatValue(data));
                }
                return html;
            };
            for (var key in data) {
                const value = data[key];
                const match = key.match(/^h(\d)_/i);
                if (match) {
                    hSlots[match[1]] = value;
                }
                else {
                    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined') {
                        html[html.length] = '<tr><th>';
                        html[html.length] = key;
                        html[html.length] = '</th><td>';
                        html = html.concat(formatValue(value));
                        html[html.length] = '</td></tr>';
                    }
                    else {
                        html[html.length] = '<tr><th>';
                        html[html.length] = key;
                        html[html.length] = '</th><td>';
                        html = html.concat(recursiva(value))
                        html[html.length] = '</td></tr>';

                    }
                }
            }
            const headers = hSlots
                .map(function (val, idx) {
                    if (val) {
                        return '<h' + idx + '>' + val + '</h' + idx + '>';
                    }
                })
                .filter(function (val) {
                    return val;
                });
            if (headers.length) {
                html = headers.concat(html);
            }
            if (html.length > 0) {
                html.unshift('<table class="tc-attr">');
                html[html.length] = '</table>';
                result = html.join('');
            }
        }
    }
    else if (typeof data === 'string') {
        result = data;
    }
    if (!result) {
        result = self.title;
        if (self.group) {
            result += ' ' + self.group;
        }
    }
    if (!result) {
        result = TC.Util.getLocaleString(locale, 'noData');
    }
    return result;
};

TC.Feature.prototype.clone = function () {
    var self = this;
    var nativeClone = self.wrap.cloneFeature();
    nativeClone._wrap = self.wrap;
    return new self.constructor(nativeClone, self.options);
};

TC.Feature.prototype.getStyle = function () {
    return this.wrap.getStyle();
};

TC.Feature.prototype.showPopup = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;
        var popup = control || self.popup;
        if (!popup) {
            // Buscamos un popup existente que no esté asociado a un control.
            var popups = map.getControlsByClass('TC.control.Popup');
            for (var i = 0, len = popups.length; i < len; i++) {
                var p = popups[i];
                if (!p.caller) {
                    popup = p;
                    break;
                }
            }
        }
        if (popup) {
            popup.currentFeature = self;
            ctlPromise = Promise.resolve(popup);
        }
        else {
            ctlPromise = map.addControl('popup');
        }
        ctlPromise.then(function (ctl) {
            ctl.currentFeature = self;
            map.getControlsByClass(TC.control.Popup)
                .filter(p => p !== ctl && p.isVisible())
                .forEach(p => p.hide());
            self.wrap.showPopup(ctl);
            // Ajustamos el ancho del título al de la tabla de atributos
            const attrTable = ctl.contentDiv.querySelector("table.tc-attr");
            const headers = ctl.contentDiv.querySelectorAll("h1,h2,h3,h4,h5");
            if (attrTable && headers.length) {
                const maxWidth = attrTable.getBoundingClientRect().width + 'px';
                headers.forEach(function (h) {
                    h.style.maxWidth = maxWidth;
                });
            }
            map.trigger(TC.Consts.event.POPUP, { control: ctl });
            ctl.fitToView(true);
        });
    }
};

TC.Feature.prototype.showResultsPanel = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;

        var resultsPanelOptions = {
            content: "table",
            titles: {
                main: TC.Util.getLocaleString(map.options.locale, "rsp.title"),
                max: TC.Util.getLocaleString(map.options.locale, "rsp.title")
            }
        };
        var controlContainer = map.getControlsByClass('TC.control.ControlContainer')[0];
        if (controlContainer) {
            resultsPanelOptions.position = controlContainer.POSITION.RIGHT;
            ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
        } else {
            resultsPanelOptions.div = document.createElement('div');
            map.div.appendChild(resultsPanelOptions.div);
            ctlPromise = map.addControl('resultsPanel', resultsPanelOptions);
        }

        ctlPromise.then(function (ctl) {
            ctl.currentFeature = self;

            // GLS: si contamos con el contenedor de controles no es necesario cerra el resto de paneles ya que no habrá solape excepto los paneles
            if (map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctrl) { return ctrl.options.content === "table" }).forEach(function (p) {
                    p.close();
                });
            }

            // cerramos los paneles con feature asociada que no sean gráfico
            const panels = map.getControlsByClass('TC.control.ResultsPanel');
            panels.forEach(function (p) {
                if (p.currentFeature && !p.chart) {
                    p.close();
                }
            });

            ctl.menuDiv.innerHTML = '';
            ctl.open(self.getInfo({ locale: map.options.locale }), ctl.getInfoContainer());

            var onViewChange = function (e) {
                map.off(TC.Consts.event.VIEWCHANGE, onViewChange);

                ctl.close();
            };
            map.on(TC.Consts.event.VIEWCHANGE, onViewChange);
        });
    }
};


TC.Feature.prototype.select = function () {
    var self = this;
    self._selected = true;
    if (self.layer) {
        self.layer.selectedFeatures.push(self);
    }
    var selectionOptions = self.options.selection || {};
    self.setStyle(TC.Util.extend({}, TC.Cfg.styles.selection[self.STYLETYPE], selectionOptions[self.STYLETYPE]));
};

TC.Feature.prototype.unselect = function () {
    const self = this;
    self._selected = false;
    // Volvemos al estilo por defecto
    self.setStyle(self.options);

    if (self.layer) {
        const idx = self.layer.selectedFeatures.indexOf(self);
        if (idx >= 0) {
            self.layer.selectedFeatures.splice(idx, 1);
        }
    }
};

TC.Feature.prototype.isSelected = function () {
    return this._selected;
};

TC.Feature.prototype.toGML = function (version, srsName) {
    return this.wrap.toGML(version, srsName);
};



TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/**
 * <p>Opciones de estilo de punto. Esta clase no tiene constructor.</p>
 * @class TC.cfg.PointStyleOptions
 * @static
 */
/**
 * Radio en píxeles del símbolo del punto.
 * @property radius
 * @type number
 * @default 8
 */
/**
 * Color de relleno del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property fillColor
 * @type string
 */
/**
 * Opacidad de relleno del símbolo del punto. Número entre 0 (transparente) y 1 (opaco).
 * @property fillOpacity
 * @type number
 */
/**
 * Color de línea del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property strokeColor
 * @type string
 */
/**
 * Ancho de línea en píxeles del símbolo del punto.
 * @property strokeWidth
 * @type number
 * @default 2
 */
/**
 * Nombre del grupo en el que incluir el punto. Los grupos de puntos son entidades para facilitar la organización de estos, 
 * ya que un grupo se mostrará en la tabla de contenidos y en la leyenda.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Point = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.feature = coords;
        self.wrap.createPoint(coords, options);
    }
};

TC.inherit(TC.feature.Point, TC.Feature);

TC.feature.Point.prototype.STYLETYPE = TC.Consts.geom.POINT;

TC.feature.Point.prototype.CLASSNAME = 'TC.feature.Point';

TC.feature.Point.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [coords];
    }
    return coords;
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

TC.feature.Circle = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.createCircle(coords, options);
    }
};

TC.inherit(TC.feature.Circle, TC.Feature);

(function () {
    var featProto = TC.feature.Circle.prototype;

    featProto.STYLETYPE = TC.Consts.geom.POLYGON;

    featProto.CLASSNAME = 'TC.feature.Circle';

    featProto.getCoords = function () {
        return this.wrap.getGeometry();

    };

    featProto.setCoords = function (coords) {
        const self = this;
        if (Array.isArray(coords) &&
            Array.isArray(coords[0])
            && !Array.isArray(coords[0][0]) && !Array.isArray(coords[0][1])
            && !Array.isArray(coords[1])) {
            return TC.Feature.prototype.setCoords.call(self, coords);
        }
        else {
            throw new Error('Coordinates not valid for circle');
        }
    };

})();
TC.feature = TC.feature || {};

if (!TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}

/**
 * <p>Opciones de estilo de marcador (punto de mapa con icono). Esta clase no tiene constructor.</p>
 * @class TC.cfg.MarkerStyleOptions
 * @static
 */
/**
 * URL de la imagen del icono del marcador.
 * @property url
 * @type string
 */
/**
 * Clase CSS de la que obtener el icono del marcador, extrayendo la URL de la imagen del atributo <code>background-image</code> asociado a la clase.
 * @property cssClass
 * @type string
 * @default "tc-marker1"
 */
/**
 * Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo <code>background-image</code> asociado a la clase.
 * @property classes
 * @type array
 * @default ["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]
 */
/**
 * Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono.
 * @property anchor
 * @type array
 * @default [.5, 1]
 */
/**
 * Anchura en píxeles del icono.
 * @property width
 * @type number
 * @default 32
 */
/**
 * Altura en píxeles del icono.
 * @property height
 * @type number
 * @default 32
 */
/**
 * Nombre del grupo en el que incluir el marcador. Los grupos de marcadores son entidades para facilitar la organización de estos: 
 * por un lado, un grupo se mostrará en la tabla de contenidos y en la leyenda, por otro, si no se especifica explícitamente un icono para el marcador, 
 * todos los marcadores del mismo grupo tendrán el mismo icono. La asignación de icono a grupo se hará rotando entre los elementos de la propiedad 
 * {{#crossLink "TC.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Marker = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        var locale = self.layer && self.layer.map ? self.layer.map.options.locale: TC.Cfg.locale;
        self.title = options.title || TC.i18n[locale][TC.Consts.MARKER];
        self.wrap.createMarker(coords, options);
    }
};

TC.inherit(TC.feature.Marker, TC.feature.Point);

TC.feature.Marker.prototype.STYLETYPE = 'marker';

TC.feature.Marker.prototype.CLASSNAME = 'TC.feature.Marker';
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * MultiPolygon
 * Parameters: coords, array of array of array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolygon = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.createMultiPolygon(coords, options);
    }
};

TC.inherit(TC.feature.MultiPolygon, TC.Feature);

TC.feature.MultiPolygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.MultiPolygon.prototype.CLASSNAME = 'TC.feature.MultiPolygon';

TC.feature.MultiPolygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], [].concat.apply([], coords));
    }
    return coords;
};

TC.feature.MultiPolygon.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0])) {
        if (!Array.isArray(coords[0][0])) {
            coords = [[coords]];
        }
        else if (!Array.isArray(coords[0][0][0])) {
            coords = [coords];
        }
    }
    else {
        throw new Error('Coordinates not valid for multipolygon');
    }
    coords.forEach(function (polygon) {
        polygon.forEach(function (ring) {
            const startPoint = ring[0];
            const endPoint = ring[ring.length - 1];
            if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
                ring[ring.length] = startPoint;
            }
        });
    });
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.MultiPolygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolyline = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.createMultiPolyline(coords, options);
    }
};

TC.inherit(TC.feature.MultiPolyline, TC.Feature);

TC.feature.MultiPolyline.prototype.STYLETYPE = "line";

TC.feature.MultiPolyline.prototype.CLASSNAME = 'TC.feature.MultiPolyline';

TC.feature.MultiPolyline.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.MultiPolyline.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0]) && !Array.isArray(coords[0][0])) {
        coords = [coords];
    }
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.MultiPolyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polygon
 * Parameters: coords, array of array of 2 element arrays of numbers; options, object
 */
TC.feature.Polygon = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.createPolygon(coords, options);
    }
};

TC.inherit(TC.feature.Polygon, TC.Feature);

TC.feature.Polygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.Polygon.prototype.CLASSNAME = 'TC.feature.Polygon';

TC.feature.Polygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.Polygon.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && Array.isArray(coords[0])) {
        if (!Array.isArray(coords[0][0])) {
            coords = [coords];
        }
    }
    else {
        throw new Error('Coordinates not valid for polygon');
    }
    coords.forEach(function (ring) {
        const startPoint = ring[0];
        const endPoint = ring[ring.length - 1];
        if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
            ring[ring.length] = startPoint;
        }
    });
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.Polygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};

TC.feature.Polygon.prototype.getArea = function (options) {
    return this.wrap.getArea(options);
};
TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.Polyline = function (coords, options) {
    const self = this;

    TC.Feature.apply(self, arguments);

    if (!self.wrap.isNative(coords)) {
        self.wrap.createPolyline(coords, options);
    }
};

TC.inherit(TC.feature.Polyline, TC.Feature);

TC.feature.Polyline.prototype.STYLETYPE = "line";

TC.feature.Polyline.prototype.CLASSNAME = 'TC.feature.Polyline';

TC.feature.Polyline.prototype.setCoords = function (coords) {
    const self = this;
    if (Array.isArray(coords) && !Array.isArray(coords[0])) {
        coords = [coords];
    }
    return TC.Feature.prototype.setCoords.call(self, coords);
};

TC.feature.Polyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
TC.filter = {};

TC.filter.Filter = function (tagName) {
    this.tagName_ = tagName;
    
    this._defaultNSURL = "http://www.opengis.net/ogc";
    this._defaultPrefixNS = this._wfsPrefixNS = "ogc";
    this._fieldTitle = "PropertyName";

    this._defaultNSURL = this._wfsNSURL = "http://www.opengis.net/ogc";
    this._wfs2prefixNS = "fes";
    this._wfs2NSURL = "http://www.opengis.net/fes/2.0";
    this._wfs2FieldTitle = "ValueReference";
};

TC.filter.Filter.prototype.getTagName = function () {
    return this.tagName_;
};

TC.filter.Filter.prototype.writeFilterCondition_ = function () {

    //return '<{prefix}:{tag}>{childs}</{prefix}:{tag}>'.format({prefix:"ogc",tag:filter.getTagName(),childs:""});
    var filter = this;
    return '<{prefix}:Filter xmlns:{prefix}=\"{NSURL}">{inner}</{prefix}:Filter>'.format({
        prefix: this._defaultPrefixNS,
        NSURL: this._defaultNSURL,
        tag: filter.getTagName(),
        inner: this.writeInnerCondition_(filter)
    });

    /*ol.xml.pushSerializeAndPop(item,
        ol.format.WFS.GETFEATURE_SERIALIZERS_,
        ol.xml.makeSimpleNodeFactory(filter.getTagName()),
        [filter], objectStack);*/
}
TC.filter.Filter.prototype.writeInnerCondition_ = function (filter) {
    if (filter != this) {
        filter._defaultNSURL = this._defaultNSURL;
        filter._defaultPrefixNS = this._defaultPrefixNS;
        filter._fieldTitle = this._fieldTitle;
    }

    if (filter instanceof TC.filter.LogicalNary) {
        return filter.write()
    }
    else if (filter instanceof TC.filter.ComparisonBinary) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Comparison) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Spatial) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Function) {
        return filter.write();
    }
    else
        return filter.write();
};
TC.filter.Filter.prototype.writeInnerArrayCondition_ = function (filters) {
    const parent = this;
    return parent.conditions.reduce(function (vi, va, index) {
        return (vi instanceof TC.filter.Filter ? parent.writeInnerCondition_(vi) : vi) + parent.writeInnerCondition_(va);
    });
}

TC.filter.Filter.prototype.getText = function (wfsVersion) {
    if (wfsVersion && parseFloat(wfsVersion,10) >= 2) {
        this._defaultPrefixNS = this._wfs2prefixNS;
        this._defaultNSURL = this._wfs2NSURL;
        this._fieldTitle = this._wfs2FieldTitle;
    }
    return this.writeFilterCondition_();
};

TC.filter.and = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.And, params));
};

TC.filter.or = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.Or, params));
};

TC.filter.not = function (condition) {
    return new TC.filter.Not(condition);
};


TC.filter.intersects = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Intersects(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Intersects(arguments[0], arguments[1], arguments[2]);
};


TC.filter.within = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Within(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Within(arguments[0], arguments[1], arguments[2]);
};


TC.filter.equalTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.EqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.notEqualTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.NotEqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.lessThan = function (propertyName, expression) {
    return new TC.filter.LessThan(propertyName, expression);
};

TC.filter.lessThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.LessThanOrEqualTo(propertyName, expression);
};

TC.filter.greaterThan = function (propertyName, expression) {
    return new TC.filter.GreaterThan(propertyName, expression);
};

TC.filter.greaterThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.GreaterThanOrEqualTo(propertyName, expression);
};

TC.filter.isNull = function (propertyName) {
    return new TC.filter.IsNull(propertyName);
};

TC.filter.between = function (propertyName, lowerBoundary, upperBoundary) {
    return new TC.filter.IsBetween(propertyName, lowerBoundary, upperBoundary);
};

TC.filter["function"] = function (functionName, params) {
    return new TC.filter.Function(functionName, params);
};

TC.filter.like = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    return new TC.filter.IsLike(propertyName, pattern,
        opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
};

TC.filter.LogicalNary = function (tagName, conditions) {

    TC.filter.Filter.call(this, tagName);

    this.conditions = Array.prototype.slice.call(arguments, 1);
};
TC.inherit(TC.filter.LogicalNary, TC.filter.Filter);

TC.filter.And = function (conditions) {
    var params = ['And'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.And, TC.filter.LogicalNary);

TC.filter.Or = function (conditions) {
    var params = ['Or'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.Or, TC.filter.LogicalNary);

TC.filter.LogicalNary.prototype.write = function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerArrayCondition_()
    });
}

TC.filter.Not = function (condition) {
    this.condition = condition;
    TC.filter.Filter.call(this, 'Not');
    
};
TC.inherit(TC.filter.Not, TC.filter.Filter);

TC.filter.Filter.prototype.write=function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerCondition_(this.condition)
    });
}

TC.filter.Comparison = function (tagName, propertyName) {

    TC.filter.Filter.call(this, tagName);

    this.propertyName = propertyName;
};
TC.inherit(TC.filter.Comparison, TC.filter.Filter);

TC.filter.Comparison.prototype.write = function () {
    var values = '';
    //isbetween
    if (this.lowerBoundary && this.upperBoundary)
        values = '<{prefix}:LowerBoundary><{prefix}:Literal>{LowerBoundary}</{prefix}:Literal></{prefix}:LowerBoundary><{prefix}:UpperBoundary><{prefix}:Literal>{UpperBoundary}</{prefix}:Literal></{prefix}:UpperBoundary>'.format({
            prefix:this._defaultPrefixNS,
            LowerBoundary: this.lowerBoundary,
            UpperBoundary: this.upperBoundary
        });
    if (this.pattern)
        values = '<{prefix}:Literal>{Pattern}</{prefix}:Literal>'.format({
            prefix: this._defaultPrefixNS,
            Pattern: this.pattern
        });
    if (this.params)
        if (Array.isArray(this.params))
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (text) {
                    return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: text });
                }
                return (i > 0 ? a : fmt(a)) + fmt(b);
            });
        else
            values = '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: this.params });

    return '<{prefix}:{tag}{matchCase}{escape}{singleChar}{wildCard}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{values}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        escape: (typeof (this.escapeChar) !== "undefined" ? " escape=\"" + this.escapeChar + "\"" : ""),
        singleChar: (typeof (this.singleChar) !== "undefined" ? " singleChar=\"" + this.singleChar + "\"" : ""),
        wildCard: (typeof (this.wildCard) !== "undefined" ? " wildCard=\"" + this.wildCard + "\"" : ""),
        name: this.propertyName,
        values: values,
        fieldTitle: this._fieldTitle
    });
}

TC.filter.ComparisonBinary = function (
    tagName, propertyName, expression, opt_matchCase) {

    TC.filter.Comparison.call(this, tagName, propertyName);

    this.expression = expression;

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.ComparisonBinary, TC.filter.Comparison);

TC.filter.ComparisonBinary.prototype.write = function () {
    var _str = '<{prefix}:{tag}{matchCase}>' + (this.propertyName instanceof TC.filter.Filter ? '{name}' : '<{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>') + '<{prefix}:Literal>{value}</{prefix}:Literal></{prefix}:{tag}>';
    return _str.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        //escape:(typeof(this.escapeChar)!=="undefined"? " escape=\"" + this.escapeChar+ "\"":""),
        //singleChar:(typeof(this.singleChar)!=="undefined"? " singleChar=\"" + this.singleChar+ "\"":""),
        //wildCard:(typeof(this.wildCard)!=="undefined"? " wildCard=\"" + this.wildCard+ "\"":""),
        name: this.propertyName instanceof TC.filter.Filter ? this.propertyName.write() : this.propertyName,
        value: this.expression,
        fieldTitle: this._fieldTitle
    });
}
TC.filter.EqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.EqualTo, TC.filter.ComparisonBinary);

TC.filter.GreaterThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThan', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThan, TC.filter.ComparisonBinary);

TC.filter.GreaterThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.LessThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThan', propertyName, expression);
};
TC.inherit(TC.filter.LessThan, TC.filter.ComparisonBinary);

TC.filter.LessThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.LessThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.NotEqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.NotEqualTo, TC.filter.ComparisonBinary);

TC.filter.IsLike = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    TC.filter.Comparison.call(this, 'PropertyIsLike', propertyName);

    this.pattern = pattern;

    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';

    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';

    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.IsLike, TC.filter.Comparison);

TC.filter.IsNull = function (propertyName) {
    TC.filter.Comparison.call(this, 'PropertyIsNull', propertyName);
};
TC.inherit(TC.filter.IsNull, TC.filter.Comparison);

TC.filter.IsBetween = function (propertyName, lowerBoundary, upperBoundary) {
    TC.filter.Comparison.call(this, 'PropertyIsBetween', propertyName);
    this.lowerBoundary = lowerBoundary;
    this.upperBoundary = upperBoundary;
};
TC.inherit(TC.filter.IsBetween, TC.filter.Comparison);

TC.filter.Function = function (functionName, params) {
    TC.filter.Filter.call(this, functionName);
    this.params = params
};
TC.inherit(TC.filter.Function, TC.filter.Filter);

TC.filter.Function.prototype.write = function () {
    var values = '';
    if (this.params) {
        var _paramsToText = function (param, prefix) {
            if (typeof (param) === "string") {
                return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: prefix, value: param });
            }
            if (typeof (param) === "object") {
                var _text = '';
                for (var attr in param) {
                    _text = _text + '<{prefix}:{key}>{value}</{prefix}:{key}>'.format({ prefix: prefix, value: param[attr], key: attr })
                }
                return _text;
            }
        }
        if (Array.isArray(this.params)) {
            var prefix = this._defaultPrefixNS;
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (param) {
                    return _paramsToText(param, prefix);
                }
                return (i > 1 ? a : fmt(a)) + fmt(b);
            });
        }
        else
            values = _paramsToText(this.params, this._defaultPrefixNS);
    }
    return '<{prefix}:Function name="{tag}">{inner}</{prefix}:Function>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: values
    });
};

TC.filter.Spatial = function (tagName, geometryName, geometry, opt_srsName) {
    TC.filter.Filter.call(this, tagName);
    this.geometryName = geometryName;
    this.geometry = geometry;
    this.srsName = opt_srsName;
    this.wrap = new TC.wrap.Filter(this);
};

TC.wrap.Filter = function (filter) {
    this.parent = filter;
};

TC.wrap.Filter.prototype.getAxisOrientation = function () {
    // Establecemos el srsName a EPSG:xxxx o urn:x-ogc:def:crs:EPSG:xxxx dependiendo del orden de eje de coordenadas del CRS.
    // Esto se debe a que GeoServer hace asunciones en el orden de los ejes dependiendo del formato de srsName que se use.
    // Más información: https://docs.geoserver.org/latest/en/user/services/wfs/basics.html#wfs-basics-axis
    var srsName = this.parent.srsName;
    if (srsName) {
        const match = srsName.match(/\d{4,6}$/);
        if (match) {
            const code = match[0];
            const def = ol.proj.get(srsName);
            if (def) {
                return ((def.axisOrientation_ === 'neu' ? 'urn:x-ogc:def:crs:EPSG:' : 'EPSG:') + code);
            }
        }
    }
    return srsName;
};

TC.inherit(TC.filter.Spatial, TC.filter.Filter);

TC.filter.Spatial.prototype.write = function () {
    var pattern = null;
    if (this.geometryName) {
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{geometry}</{prefix}:{tag}>';
    }
    else {
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}/>{geometry}</{prefix}:{tag}>';
    }

    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        name: this.geometryName,
        geometry: (this.geometry instanceof TC.filter.Function ? this.writeInnerCondition_(this.geometry) : this.geometry.wrap.toGML(undefined, this.wrap.getAxisOrientation())),
        fieldTitle: this._fieldTitle
    });
};

TC.filter.bbox = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Bbox(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Bbox(arguments[0], arguments[1], arguments[2]);
};

TC.filter.Bbox = function (geometryName, extent, opt_srsName) {
    TC.filter.Filter.call(this, 'BBOX');
    this.geometryName = geometryName;
    this.extent = extent;
    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Bbox, TC.filter.Spatial);

TC.filter.Bbox.prototype.write = function () {
    var bbox = '<gml:Envelope{srsName}><gml:lowerCorner>{lowerCorner}</gml:lowerCorner><gml:upperCorner>{upperCorner}</gml:upperCorner></gml:Envelope>'
	.format({
	    srsName: (typeof (this.srsName) !== "undefined" ? " srsName=\"" + this.srsName + "\"" : ""),
	    lowerCorner: (this.extent[0] + ' ' + this.extent[1]),
	    upperCorner: (this.extent[2] + ' ' + this.extent[3])
	});
    var pattern = null;
    if (this.geometryName)
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{BBOX}</{prefix}:{tag}>';
    else
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}/>{BBOX}</{prefix}:{tag}>';
    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        fieldTitle:  this._fieldTitle,
        name: this.geometryName,
        BBOX: bbox
    });
};

TC.filter.Intersects = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Intersects', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Intersects, TC.filter.Spatial);

TC.filter.Within = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Within', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Within, TC.filter.Spatial);
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapContents = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.layerTrees = {};
};

TC.inherit(TC.control.MapContents, TC.Control);

(function () {
    var ctlProto = TC.control.MapContents.prototype;

    ctlProto.CLASS = 'tc-ctl-mc';

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }) : Promise.reject(Error('Cannot render: control has no map')));
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                for (var i = 0, len = map.layers.length; i < len; i++) {
                    self.updateLayerTree(map.layers[i]);
                }

                map
                    .on(TC.Consts.event.ZOOM + ' ' + TC.Consts.event.PROJECTIONCHANGE, function () {
                        self.updateScale();
                    })
                    .on(TC.Consts.event.UPDATEPARAMS, function (e) {
                        const layer = e.layer;
                        var names = layer.names;
                        var containsName = function containsName(node) {
                            var result = false;
                            if (node) {
                                if (names.indexOf(node.name) >= 0) {
                                    result = true;
                                }
                                else {
                                    for (var i = 0; i < node.children.length; i++) {
                                        if (containsName(node.children[i])) {
                                            result = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            return result;
                        };
                        if (containsName(self.layerTrees[layer.id]) || names.length === 0) {
                            self.update();
                        }
                        else {
                            self.updateLayerTree(layer);
                        }
                    })
                    .on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                        self.updateLayerVisibility(e.layer);
                    })
                    .on(TC.Consts.event.LAYERADD, function (e) {
                        self.updateLayerTree(e.layer);
                    })
                    .on(TC.Consts.event.VECTORUPDATE + ' ' + TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                        const layer = e.layer;
                        // Se introduce un timeout porque pueden venir muchos eventos de este tipo seguidos y no tiene sentido actualizar con cada uno
                        if (self._updateLayerTreeTimeout) {
                            clearTimeout(self._updateLayerTreeTimeout);
                        }
                        self._updateLayerTreeTimeout = setTimeout(function () {
                            if (self.map.workLayers.indexOf(layer) > -1) {
                                // GLS: Validamos si la capa que ha provocado el evento sigue en worklayers, si es borrada debido a la espera del timeout el TOC puede reflejar capas que ya no están
                                self.updateLayerTree(layer);
                                delete self._updateLayerTreeTimeout;
                            }
                        }, 100);
                    })
                    .on(TC.Consts.event.LAYERREMOVE, function (e) {
                        self.removeLayer(e.layer);
                    })
                    .on(TC.Consts.event.LAYERORDER, function (e) {
                        self.updateLayerOrder(e.layer, e.oldIndex, e.newIndex);
                    })
                    .on(TC.Consts.event.LAYERERROR, function (e) {
                        self.onErrorLayer(e.layer);                                                    
                    });

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        });
    };

    ctlProto.updateScale = function () {
    };

    ctlProto.updateLayerVisibility = function (layer) {
    };

    ctlProto.updateLayerTree = function (layer) {
        this.layerTrees[layer.id] = layer.getTree();
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx, collection) {
        const self = this;
        if (oldIdx >= 0 && oldIdx !== newIdx) {
            var currentElm, previousElm;
            const elms = self.getLayerUIElements();

            collection = collection || self.map.workLayers;

            for (var i = collection.length - 1; i >= 0; i--) {
                const l = collection[i];
                previousElm = currentElm;
                for (var j = 0, jj = elms.length; j < jj; j++) {
                    const elm = elms[j];
                    if (elm.dataset.layerId === l.id) {
                        currentElm = elm;
                        break;
                    }
                }
                if (l === layer) {
                    if (currentElm) {
                        if (previousElm) {
                            previousElm.insertAdjacentElement('afterend', currentElm);
                        }
                        else {
                            currentElm.parentElement.firstChild.insertAdjacentElement('beforebegin', currentElm);
                        }
                    }
                    break;
                }
            }
        }
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        const liCollection = self.getLayerUIElements();
        for (var i = 0, len = liCollection.length; i < len; i++) {
            const li = liCollection[i];
            if (li.dataset.layerId === layer.id) {
                li.parentElement.removeChild(li);
                break;
            }
        }
        if (self.getLayerUIElements().length === 0) {
            self.div.querySelector('.' + self.CLASS + '-empty').classList.remove(TC.Consts.classes.HIDDEN);
        }
    };

    ctlProto.onErrorLayer = function (layer) { };

    ctlProto.getLayerUIElements = function () {
        return this.div.querySelector('ul').children;
    };

    var isGetLegendGraphic = function (url) {
        return /[&?]REQUEST=getLegendGraphic/i.test(url);
    };

    /**
     * Carga y le da estilo a la imagen de la leyenda.
     * @param {string} requestMethod Si queremos pedir la imagen de la leyenda por POST, podemos especificarlo utilizando el parámetro requestMethod.
     */
    ctlProto.styleLegendImage = function (img, layer) {
        if (!img.getAttribute('src')) {
            var imgSrc = img.dataset.img;

            const toolProxification = new TC.tool.Proxification(TC.proxify);

            if (layer && layer.options.method && layer.options.method === "POST") {
                layer.getLegendGraphicImage()
                    .then(function (src) {
                        img.src = src; // ya se ha validado en getLegendGraphicImage
                    }).catch(function (err) {
                        TC.error(err);
                    });
            } else {
                if (isGetLegendGraphic(imgSrc)) {
                    const watch = img.parentElement;
                    // A\u00f1adimos el par\u00e1metro que define el estilo de los textos en la imagen
                    var colorStr = watch.style.color;
                    // Convertimos el color de formato rgb(r,g,b) a 0xRRGGBB
                    var openIdx = colorStr.indexOf('(');
                    var closeIdx = colorStr.indexOf(')');
                    if (openIdx >= 0 && closeIdx > openIdx) {
                        color = colorStr
                            .substr(0, closeIdx)
                            .substr(openIdx + 1)
                            .split(',');
                        colorStr = '0x';
                        for (var i = 0; i < 3; i++) {
                            var component = parseInt(color[i]).toString(16);
                            colorStr += component.length === 1 ? '0' + component : component;
                        }
                    }
                    else {
                        colorStr.replace('#', '0x');
                    }
                    imgSrc += '&LEGEND_OPTIONS=fontName:' + watch.style.fontFamily +
                        ';fontSize:' + parseInt(watch.style.fontSize) +
                        ';fontColor:' + colorStr +
                        ';fontAntiAliasing:true';
                    if (layer.params && layer.params.sld_body) {
                        imgSrc = TC.Util.addURLParameters(imgSrc, { sld_body: layer.params.sld_body });
                    }

                    toolProxification.fetchImage(imgSrc).then(function (img) {
                        img.dataset.img = img.src;
                    }).catch(function (err) {
                        TC.error(err);
                    });
                }

                toolProxification.fetchImage(imgSrc).then(function (i) {
                    img.src = i.src;
                }).catch(function (err) {
                    TC.error(err.statusText);
                });                
            }
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapInfo = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.MapInfo, TC.Control);

(function () {
    var ctlProto = TC.control.MapInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-mi';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.QR_MAX_URL_LENGTH = 150;
        self.SHORTEN_URL_LENGTH = 32715;

        self.exportsState = false;

        self.includeControls = self.options.includeControls === undefined || self.options.includeControls;

        map.ready(function () {
            const controlStates = map.state && map.state.ctl;
            if (controlStates) {
                if (!map._controlStatesLoaded) { // Para evitar que si hay varios controles Share cargados, cada uno importe por su cuenta.
                    self.importControlStates(controlStates);
                    map._controlStatesLoaded = true;
                }
            }
        });

        return result;
    }

    ctlProto.exportControlStates = function () {
        const self = this;
        if (self.map) {
            return self.map.controls
                .map(function (ctl) {
                    return ctl.exportState();
                })
                .filter(function (state) {
                    // Quitamos los estados nulos o vacíos
                    if (state) {
                        for (var key in state) {
                            if (state.hasOwnProperty(key)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
        }
        return [];
    };

    ctlProto.importControlStates = function (stateArray) {
        const self = this;
        if (self.map) {
            stateArray.forEach(function (state) {
                const ctl = self.map.getControlById(state.id);
                if (ctl) {
                    self.map.loaded(function () {
                        ctl.importState(state);
                    });
                }
            });
        }
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.featureToShare || self.sharedFeaturesLayer) {
                var layerState;
                state.id = self.id;
                if (self.featureToShare) {
                    const featureToShare = self.featureToShare.clone();
                    featureToShare.showsPopup = true;
                    layerState = self.featureToShare.layer.exportState({
                        features: [featureToShare]
                    });
                }
                else {
                    layerState = self.sharedFeaturesLayer.exportState();
                }
                state.features = layerState.features;
                if (layerState.crs) {
                    state.crs = layerState.crs;
                }
            }
            return state;
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map && state.features.length) {
            self.map.addLayer({
                id: self.getUID(),
                owner: self,
                type: TC.Consts.layerType.VECTOR,
                title: self.getLocaleString('foi'),
                stealth: true
            }).then(function (layer) {
                self.sharedFeaturesLayer = layer;
                layer.importState({ features: state.features, crs: state.crs }).then(function () {
                    self.map.zoomToFeatures(layer.features);
                });
            });
        }
    };

    ctlProto.manageMaxLengthExceed = function () {
        throw "Falta implementación del método manageMaxLengthExceed";
    };

    ctlProto.generateLink = function () {
        var self = this;

        var currentUrl = window.location.href;
        var hashPosition = currentUrl.indexOf('#');
        if (hashPosition > 0) {
            currentUrl = currentUrl.substring(0, hashPosition);
        }

        if (self.extraParams) {
            // Hacemos merge de parámetros de URL
            var params = TC.Util.getQueryStringParams(currentUrl);
            TC.Util.extend(params, self.extraParams);
            var qsPosition = currentUrl.indexOf('?');
            if (qsPosition >= 0) {
                currentUrl = currentUrl.substring(0, qsPosition);
            }
            currentUrl = currentUrl.concat('?', TC.Util.getParamString(params));
        }

        // eliminamos el parámetro del idioma, si no lo arrastramos al compartir
        if (TC.Util.getParameterByName('lang').length > 0) {
            if (currentUrl.indexOf('&') > -1) { // tenemos más parámetros en la url
                currentUrl = currentUrl.replace("lang" + "=" + TC.Util.getParameterByName('lang') + '&', '');
            } else {
                currentUrl = currentUrl.replace('?' + "lang" + "=" + TC.Util.getParameterByName('lang'), '');
            }
        }

        const controlStates = self.includeControls ? self.exportControlStates() : [];
        if (self.exportsState && (self.featureToShare || self.sharedFeaturesLayer)) {
            controlStates.push(self.exportState());
        }
        const extraStates = controlStates.length ? { ctl: controlStates } : undefined;

        var hashState = self.map.getMapState(extraStates);

        var url = currentUrl.concat("#", hashState);
        self.manageMaxLengthExceed({ browser: url.length > TC.Consts.URL_MAX_LENGTH, qr: url.length > self.SHORTEN_URL_LENGTH });
        return url;
    };

    ctlProto.shortenedLink = function () {
        const self = this;
        var wait;

        const generateLinkWithoutParams = function () {
            var url = self.generateLink();
            var start = url.indexOf('?');
            var end = url.indexOf('#');

            //Borramos los parámetros de la URL y dejamos sólo el hash
            if (start > 0) {
                if (start < end) {
                    url = url.replace(url.substring(start, end), '');
                } else {
                    url = url.replace(url.substring(start, url.length - 1), '');
                }
            }

            return url;
        };
        const shortenUrl = function (url) {
            var shortenServiceUrl = "https://tinyurl.com/api-create.php";

            if (!TC.tool || !TC.tool.Proxification) {
                TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
            }

            var data = new FormData();
            data.append("url", url);

            var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: false });
            return toolProxification.fetch(shortenServiceUrl, {
                type: 'POST',
                data: data
            }).then(function (data) {
                return data;
            }).catch(function (error) {
                return null;
            });
        };

        return new Promise(function (resolve, reject) {
            const onError = function () {
                self.map.toast(self.getLocaleString("urlTooLongForShortener"), { type: TC.Consts.msgType.ERROR });
                self.map.getLoadingIndicator().removeWait(wait);
                resolve("");
            };

            var url = generateLinkWithoutParams();

            if (url.length > self.QR_MAX_URL_LENGTH && url.length < self.SHORTEN_URL_LENGTH) {

                wait = self.map.getLoadingIndicator().addWait();

                shortenUrl(url).then(function (response) {
                    if (response && response.responseText) {
                        self.map.getLoadingIndicator().removeWait(wait);
                        resolve(response.responseText.replace('http://', 'https://'));
                    } else {
                        onError();
                    }
                }, onError);
            } else {
                if (url.length >= self.SHORTEN_URL_LENGTH) {
                    onError();
                }

                resolve("");
            }
        });
    };

    ctlProto.makeQRCode = function (codeContainer, width, height) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.loadJS(
                typeof QRCode === 'undefined',
                [TC.apiLocation + 'lib/qrcode/qrcode.min.js'],
                function () {
                    self.shortenedLink().then(function (url) {
                        url = url || "";
                        if (url.length > 0) {
                            var options = {
                                text: url
                            };

                            if (width && height) {
                                options.width = width;
                                options.height = height;
                            }

                            var config = { attributes: true, childList: true, subtree: true };
                            var observer = new MutationObserver(function (mutationsList, observer) {
                                var srcMutation = mutationsList.filter(function (mutation) {
                                    return mutation.type === "attributes"
                                }).filter(function (mutation) {
                                    return mutation.attributeName.indexOf('src') > -1;
                                });

                                if (srcMutation.length > 0) {
                                    observer.disconnect();
                                    resolve(srcMutation[0].target.src);
                                }
                            });
                            observer.observe(codeContainer, config);
                            new QRCode(codeContainer, options);
                        } else {
                            resolve();
                        }
                    });
                });
        });
    };

    ctlProto.drawScaleBarIntoCanvas = function (options) {
        const self = this;
        var canvas;
        var sb = self.map.getControlsByClass(TC.control.ScaleBar);
        if (sb.length == 0) {
            return null;
        }

        options = options || {};

        const drawFill = function (ctx, width, height) {
            var elem = document.getElementsByClassName(sb[0].CLASS);
            var fillnode = elem.item(0);
            var fillBoundingCR = TC.Util.extend({}, fillnode.getBoundingClientRect());

            fillBoundingCR.left = (options.left || 15) - 2;

            fillBoundingCR.top = options.top || 15;
            fillBoundingCR.top--;

            ctx.globalAlpha = 0.5;
            ctx.fillStyle = window.getComputedStyle(fillnode).backgroundColor;
            width += 4;
            height += 4;
            ctx.fillRect(fillBoundingCR.left, fillBoundingCR.top, width, height);
        };

        if (!options.canvas) {
            canvas = document.createElement('CANVAS');
        } else {
            canvas = options.canvas;
        }

        var ctx = canvas.getContext("2d");
        ctx.save();

        var elem = document.getElementsByClassName("ol-scale-line-inner");
        var node = elem.item(0);
        var boundingCR = TC.Util.extend({}, node.getBoundingClientRect());

        var text = node.textContent;

        ctx.beginPath();
        ctx.strokeStyle = window.getComputedStyle(node).borderColor;

        var width, height;

        if (boundingCR.width > boundingCR.height) {

            width = boundingCR.width;
            height = boundingCR.height;
        }
        else {

            width = boundingCR.height;
            height = boundingCR.width;
        }

        if (options.setSize) {
            canvas.width = width;
            canvas.height = height;
        }        

        boundingCR.left = options.left != undefined ? options.left : 15;
        boundingCR.top = options.top != undefined ? options.top : 15;

        ctx.moveTo(boundingCR.left, boundingCR.top);
        ctx.lineTo(boundingCR.left, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top);

        ctx.stroke();

        var textMetrics = ctx.measureText(text);
        var textPosition = {
            x: boundingCR.left + width / 2,
            y: boundingCR.top + height / 2
        };

        if (options.fill) {
            drawFill(ctx, width, height);
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = options.textColor != undefined ? options.textColor : window.getComputedStyle(node).color;

        ctx.font = options.font != undefined ? options.font : window.getComputedStyle(node).fontSize + " " + window.getComputedStyle(node).fontFamily;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, textPosition.x, textPosition.y);

        return canvas;
    };

    ctlProto.registerListeners = function () {
        const self = this;

        if (!self.registeredListeners) {
            self.map.on(TC.Consts.event.LAYERADD, self.generateLink.bind(self))
                .on(TC.Consts.event.LAYERREMOVE, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREADD, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, self.generateLink.bind(self));

            self.registeredListeners = true;
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.TOC = function () {
    var self = this;

    TC.control.MapContents.apply(self, arguments);
};

TC.inherit(TC.control.TOC, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.TOC.prototype;

    ctlProto.CLASS = 'tc-ctl-toc';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/TOC.html";
    ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/TOCBranch.html";
    ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/TOCNode.html";

    var _dataKeys = {
        layer: 'tcLayer',
        layerUid: 'tcLayerUid'
    };

    var CLICKEVENT = 'click';

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapContents.prototype.register.call(self, map);

        map.on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
            self.onExternalServiceAdded(e);
        });

        return result;
    };

    ctlProto.onExternalServiceAdded = function (e) {
        const self = this;
        if (e && e.layer) {
            e.layer.map = self.map;
            self.map.addLayer(e.layer).then(function (layer) {
                self.updateLayerTree(e.layer);
            });
        }
    };

    ctlProto.addUIEventListeners = function () {
        const self = this;
        self.div.addEventListener(CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) { // No usamos TC.Consts.event.CLICK porque en iPad los eventos touchstart no van bien en los checkbox
            const checkbox = e.target;
            var ul = checkbox;
            while (ul && !ul.matches('ul.' + self.CLASS + '-wl')) {
                ul = ul.parentElement;
            }
            const lis = [];
            for (var i = 0, len = ul.children.length; i < len; i++) {
                child = ul.children[i];
                if (child.tagName === 'LI') {
                    lis.push(child);
                }
            }
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.contains(checkbox)) {
                    const layer = self.map.getLayer(li.dataset.layerId);
                    var parent = checkbox;
                    do {
                        parent = parent.parentElement;
                    }
                    while (parent && parent.tagName !== 'LI');
                    const uid = parent.dataset.layerUid;
                    layer.setNodeVisibility(uid, checkbox.checked);
                    break;
                }
            }

            e.stopPropagation();
        }));
        self.div.addEventListener(TC.Consts.event.MOUSEUP, TC.EventTarget.listenerBySelector('button.' + self.CLASS + '-collapse-btn', function (e) {
            e.target.blur();
            const li = e.target.parentElement;
            if (!li.classList.contains(self.CLASS + '-leaf')) {
                li.classList.toggle(TC.Consts.classes.COLLAPSED);
                const ul = li.querySelector('ul');
                ul.classList.toggle(TC.Consts.classes.COLLAPSED);
                e.stopPropagation();
            }
        }));
    };

    ctlProto.update = function () {
        var self = this;

        var _getCheckbox = function (li) {
            for (var i = 0, len = li.children.length; i < len; i++) {
                const child = li.children[i];
                if (child.matches('input[type=checkbox]')) {
                    return child;
                }
            }
            return null;
        };

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                _getCheckbox(li).checked = layer.getVisibility();

                layer.tree = null;

                li.querySelectorAll('li').forEach(function (l) {
                    const checkbox = _getCheckbox(l);
                    const uid = l.dataset.layerUid;
                    switch (layer.getNodeVisibility(uid)) {
                        case TC.Consts.visibility.VISIBLE:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.NOT_VISIBLE_AT_RESOLUTION:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            checkbox.checked = false;
                            checkbox.indeterminate = true;
                            break;
                        default:
                            checkbox.checked = false;
                            checkbox.indeterminate = false;
                    }
                });
            }
        });

        self.updateScale();
    };

    ctlProto.updateScale = function () {
        const self = this;
        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            li.querySelectorAll('li').forEach(function (elm) {
                const uid = elm.dataset.layerUid;
                elm.classList.toggle(self.CLASS + '-node-notvisible', !layer.isVisibleByScale(uid));
            });
        });
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);

            self.getRenderedHtml(self.CLASS + '-branch', self.layerTrees[layer.id])
                .then(function (out) {
                    const parser = new DOMParser();
                    const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                    const uid = newLi.dataset.layerUid;
                    const li = self.div.querySelector('.' + self.CLASS + '-wl li[data-layer-uid="' + uid + '"]');
                    if (li) {
                        li.innerHTML = newLi.innerHTML;
                        li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                        if (!li.dataset.layerId) {
                            li.dataset.layerId = layer.id;
                        }
                    }
                    else {
                        newLi.dataset.layerId = layer.id;
                        const ul = self.div.querySelector('.' + self.CLASS + '-wl');
                        ul.insertBefore(newLi, ul.firstChild);
                    }
                })
                .catch(function (err) {
                    TC.error(err);
                });

            var wl = 'ul.' + self.CLASS + '-wl';
            var branch = 'ul.' + self.CLASS + '-branch';
            var node = 'li.' + self.CLASS + '-node';
            var leaf = 'li.' + self.CLASS + '-leaf';
            self.div.querySelectorAll(wl + ' ' + branch + ' ' + branch + ',' + wl + ' ' + branch + ' ' + node).forEach(function (node) {
                if (!node.matches(leaf)) {
                    node.classList.add(TC.Consts.classes.COLLAPSED);
                }
            });
            self.update();
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                var isHidden = !layer.getVisibility();
                li.querySelectorAll('input[type=checkbox]').forEach(function (checkbox) {
                    if (checkbox.matches('.' + self.CLASS + '-branch-cb')) {
                        checkbox.checked = !isHidden;
                    }
                    else {
                        checkbox.disabled = isHidden;
                    }
                });
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // Este control no tiene que hacer nada
    };

    ctlProto.render = function (callback) {
        const self = this;

        return TC.Control.prototype.render.call(self, function () {

            var controlOptions = self.options.controls || [];

            if (controlOptions.length > 0) {
                var ctl = controlOptions[0];
                var newDiv = document.createElement("div");
                self.div.appendChild(newDiv);
                self.map.addControl(ctl.name, TC.Util.extend({ 'div': newDiv }, ctl.options));
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        const result = [];
        const children = self.div.querySelector('ul.' + self.CLASS + '-wl').children;
        for (var i = 0, len = children.length; i < len; i++) {
            child = children[i];
            if (child.tagName === 'LI') {
                result[result.length] = child;
            }
        }
        return result;
    };
})();

TC.control = TC.control || {};

if (!TC.control.TOC) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TOC');
}

TC.control.WorkLayerManager = function (options) {
    var self = this;
    TC.control.TOC.apply(self, arguments);
    self.layers = [];
    self.layerTools = [];
};

TC.inherit(TC.control.WorkLayerManager, TC.control.TOC);

(function () {
    var ctlProto = TC.control.WorkLayerManager.prototype;

    ctlProto.CLASS = 'tc-ctl-wlm';
    ctlProto.CLICKEVENT = 'click';

    TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
    TC.Consts.classes.DRAGEND = TC.Consts.classes.DRAGEND || 'tc-dragend';

    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/WorkLayerManager.html";
    ctlProto.template[ctlProto.CLASS + '-elm'] = TC.apiLocation + "TC/templates/WorkLayerManagerElement.html";
    ctlProto.template[ctlProto.CLASS + '-type-sgl'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipSingle.html";
    ctlProto.template[ctlProto.CLASS + '-type-grp'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroup.html";
    ctlProto.template[ctlProto.CLASS + '-type-grp-node'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroupNode.html";

    const findLayerElement = function (ctl, layer) {
        return ctl.getLayerUIElements().filter(function (li) {
            return li.dataset.layerId === layer.id;
        })[0];
    };

    var getElligibleLayersNumber = function (ctl) {
        return ctl.layers.length;
    };

    const shouldBeDelAllVisible = function (ctl) {
        return !ctl.layers.some(function (layer) { return layer.unremovable });
    };

    const moveLayer = function (ctl, listItem, oldIndex, newIndex, callback) {
        const layerItems = ctl.getLayerUIElements();
        var targetItem;
        if (newIndex > oldIndex) {
            targetItem = layerItems[newIndex - 1];
        }
        else if (newIndex < oldIndex) {
            targetItem = layerItems[newIndex + 1];
        }
        else {
            return;
        }
        const sourceLayer = ctl.map.getLayer(listItem.dataset.layerId);
        const targetLayer = ctl.map.getLayer(targetItem.dataset.layerId);
        var newIdx = -1;
        for (var i = 0; i < ctl.map.layers.length; i++) {
            if (targetLayer === ctl.map.layers[i]) {
                newIdx = i;
                break;
            }
        }
        if (newIdx >= 1 && newIdx < ctl.map.layers.length) {
            ctl.map.insertLayer(sourceLayer, newIdx, callback);
        }
    };

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            TC.loadJS(
                !window.Sortable,
                [TC.apiLocation + 'lib/sortable/Sortable.min.js'],
                function () {
                    self.map.workLayers
                        .filter(function (layer) {
                            return !layer.stealth;
                        })
                        .forEach(function (layer) {
                            self.updateLayerTree(layer);
                        });


                    const ul = self.div.querySelector('ul');
                    self._sortable = Sortable.create(ul, {
                        handle: '.' + self.CLASS + '-dd',
                        animation: 150,
                        onSort: function (e) {
                            moveLayer(self, e.item, e.oldIndex, e.newIndex);
                        }
                    });

                    ul.addEventListener('keydown', TC.EventTarget.listenerBySelector('li', function (e) {
                        // Para mover capas con el teclado.
                        var elm = e.target;
                        while (elm.tagName !== 'LI') {
                            elm = elm.parentElement;
                            if (!elm) {
                                return;
                            }
                        }
                        const swap = function (oldIdx, newIdx) {
                            const sortableItems = self._sortable.toArray();
                            const buffer = sortableItems[oldIdx];
                            sortableItems[oldIdx] = sortableItems[newIdx];
                            sortableItems[newIdx] = buffer;
                            self._sortable.sort(sortableItems);
                            moveLayer(self, elm, oldIdx, newIdx);
                        };
                        const listItems = self.getLayerUIElements();
                        const elmIdx = listItems.indexOf(elm);
                        switch (true) {
                            case /Up$/.test(e.key):
                                if (elmIdx > 0) {
                                    swap(elmIdx, elmIdx - 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Down$/.test(e.key):
                                if (elmIdx < listItems.length - 1) {
                                    swap(elmIdx, elmIdx + 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Enter$/.test(e.key):
                                elm.blur();
                                e.stopPropagation();
                                break;
                            default:
                                break;
                        }
                    }));

                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            );
        }) : Promise.reject(Error('Cannot render: control has no map')));
    };

    ctlProto.register = function (map) {
        const self = this;

        return new Promise(function (resolve, reject) {
            TC.control.TOC.prototype.register.call(self, map).then(function () {

                map.loaded(function () {                   
                    self.updateScale();
                });

                map
                    .on(TC.Consts.event.LAYEROPACITY, function (e) {
                        const li = findLayerElement(self, e.layer);
                        if (li) {
                            li.querySelector('input[type=range]').value = Math.round(e.opacity * 100);
                        }
                    })
                    .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                        var fileName = e.fileName;
                        if (e.features && e.features.length > 0) { // GLS: Escuchamos al evento FEATURESIMPORT para poder desplegar el control de capas cargadas
                            // Ignoramos los GPX (se supone que los gestionará Geolocation)
                            var pattern = '.' + TC.Consts.format.GPX.toLowerCase();
                            if (e.fileName.toLowerCase().indexOf(pattern) === e.fileName.length - pattern.length) {
                                return;
                            }

                            map.one(TC.Consts.event.LAYERADD, function (e) {
                                if (e && e.layer && e.layer.title == fileName) {
                                    // Desplegamos el control capas cargadas
                                    if (self.map && self.map.layout && self.map.layout.accordion) {
                                        if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                            self.map.controls
                                                .filter(function (ctl) {
                                                    // Todos los otros controles que no cuelgan de otro control
                                                    return ctl !== self && !ctl.containerControl;
                                                })
                                                .forEach(function (ctl) {
                                                    ctl.div.classList.add(TC.Consts.classes.COLLAPSED);
                                                });
                                        }
                                    }

                                    // abrimos el panel de herramientas
                                    self.map.trigger(TC.Consts.event.TOOLSOPEN);

                                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                                }
                            });
                        }
                    });
                resolve(self);
            });
        });
    };

    ctlProto.onExternalServiceAdded = function (e) {
        // Este control no tiene que aceptar servicios externos directamente
    };

    ctlProto.addUIEventListeners = function () {
        const self = this;

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
            // al estar en ipad el evento pasa a ser touchstart en la constante: TC.Consts.event.CLICK, los checkbox no funcionan bien con este evento
            const checkbox = e.target;
            var li = checkbox;
            do {
                li = li.parentElement;
            }
            while (li && !li.matches('li.' + self.CLASS + '-elm'));

            const layer = self.map.getLayer(li.dataset.layerId);
            layer.setVisibility(checkbox.checked);
            e.stopPropagation();
        }));

        const inputRangeListener = function (e) {
            const range = e.target;
            var li = range;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');

            const layer = self.map.getLayer(li.dataset.layerId);
            layer.setOpacity(range.value / 100);
        };
        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));
        self.div.addEventListener('input', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector(`.${self.CLASS}-btn-del:not(.disabled)`, function (e) {
            var li = e.target;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const layer = self.map.getLayer(li.dataset.layerId);
            self.map.removeLayer(layer);
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-del-all', function (e) {
            TC.confirm(self.getLocaleString('layersRemove.confirm'), function () {
                self.getLayerUIElements()
                    .map(function (li) {
                        return self.map.getLayer(li.dataset.layerId);
                    })
                    .forEach(function (layer) {
                        self.map.removeLayer(layer);
                    });
            });
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn-info', function (e) {
            const a = e.target;
            var li = a;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const info = li.querySelector('.' + self.CLASS + '-info');
            const layer = self.map.getLayer(li.dataset.layerId);
            // Cargamos la imagen de la leyenda
            info.querySelectorAll('.' + self.CLASS + '-legend img').forEach(function (img) {
                self.styleLegendImage(img, layer);
            });
            info.classList.toggle(TC.Consts.classes.HIDDEN);

            if (li.querySelector('input[type="checkbox"]').checked) {
                const dragHandle = li.querySelector('.' + self.CLASS + '-dd');
                dragHandle.classList.toggle(TC.Consts.classes.HIDDEN, !info.classList.contains(TC.Consts.classes.HIDDEN));
            }

            a.classList.toggle(TC.Consts.classes.CHECKED);
        }));
    };

    ctlProto.updateLayerVisibility = function (layer) {
        const self = this;
        const li = findLayerElement(self, layer);
        if (li) {
            const visible = layer.getVisibility();
            li.querySelector('input[type="checkbox"]').checked = visible;
        }
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;        

        var getLegendImgByPost = function (layer) {
            return new Promise(function (resolve, reject) {
                if (layer && layer.options.method && layer.options.method === "POST") {
                    layer.getLegendGraphicImage()
                        .then(function (src) {
                            resolve(src);
                        })
                        .catch(function (err) { TC.error(err); });
                } else {
                    resolve();
                }
            });
        };

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            var alreadyExists = false;
            for (var i = 0, len = self.layers.length; i < len; i++) {
                if (layer === self.layers[i]) {
                    alreadyExists = true;
                    break;
                }
            }

            if (!alreadyExists) {
                self.layers.push(layer);

                var domReadyPromise;
                var layerTitle = layer.title || layer.wrap.getServiceTitle();
                var layerData = {
                    title: layer.options.hideTitle ? '' : layerTitle,
                    hide: layer.renderOptions && layer.renderOptions.hide ? true : false,
                    opacity: layer.renderOptions && layer.renderOptions.opacity ? (layer.renderOptions.opacity * 100) : 100,
                    customLegend: layer.customLegend,
                    unremovable: layer.unremovable,
                    id: layer.id
                };
                var isRaster = layer.isRaster();
                if (isRaster) {
                    layerData.layerNames = layer.layerNames;
                    var path = layer.getPath();
                    path.shift();
                    layerData.path = path;
                    var name = layer.names[0];
                    var info = layer.wrap.getInfo(name);
                    layerData.legend = info.legend;
                    layerData['abstract'] = info['abstract'];
                    var hasInfo = (info.hasOwnProperty('abstract') || info.hasOwnProperty('legend') || info.hasOwnProperty('metadata'));
                    var metadata;
                    if (layer.tree && layer.tree.children && layer.tree.children.length && layer.tree.children[0].children && layer.tree.children[0].children.length) {
                        metadata = null;
                    }
                    else {
                        metadata = info.metadata;
                        if (metadata) {
                            for (var j = 0, len = metadata.length; j < len; j++) {
                                var md = metadata[j];
                                md.formatDescription = self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) || self.getLocaleString('viewMetadata');
                            }
                        }
                    }
                    layerData.metadata = metadata;
                }


                getLegendImgByPost(layer).then(function (src) {
                    if (src) {
                        legend.src = src; // ya se ha validado en getLegendImgByPost
                    }
                             
                    self.getRenderedHtml(self.CLASS + '-elm', layerData).then(function (out) {
                        const parser = new DOMParser();
                        const li = parser.parseFromString(out, 'text/html').body.firstChild;
                        var layerNode;
                        var isGroup = false;
                        if (isRaster) {
                            isGroup = layer.names.length > 1;
                            if (!isGroup) {
                                var layerNodes = layer.wrap.getAllLayerNodes();
                                for (var i = 0; i < layerNodes.length; i++) {
                                    var node = layerNodes[i];
                                    if (layer.wrap.getName(node) === name) {
                                        layerNode = node;
                                        if (layer.wrap.getLayerNodes(node).length > 0) {
                                            isGroup = true;
                                        }
                                        break;
                                    }
                                }
                            }
                        }

                        const typeElm = li.querySelector('.' + self.CLASS + '-type');
                        const className = isGroup ? self.CLASS + '-type-grp' : self.CLASS + '-type-sgl';
                        typeElm.classList.add(className);

                        if (!hasInfo) {
                            li.querySelector('.' + self.CLASS + '-btn-info').classList.add(TC.Consts.classes.HIDDEN);
                        }

                        if (layerNode) {
                            layer.wrap.normalizeLayerNode(layerNode);

                            self.getRenderedHtml(className, layerNode).then(function (out) {
                                var tip;

                                typeElm.addEventListener('mouseover', function (e) {
                                    const mapDiv = self.map.div;
                                    const typeElmRect = typeElm.getBoundingClientRect();
                                    tip = document.createElement('div');
                                    tip.classList.add(self.CLASS + '-tip');
                                    tip.innerHTML = out;
                                    tip.style.top = (typeElmRect.top - mapDiv.offsetTop) + 'px';
                                    tip.style.right = mapDiv.offsetWidth - (typeElmRect.left - mapDiv.offsetLeft) + 'px';
                                    mapDiv.appendChild(tip);
                                });
                                typeElm.addEventListener('mouseout', function (e) {
                                    tip.parentElement.removeChild(tip);
                                });
                            });
                        }
                        const ul = self.div.querySelector('ul');
                        li.dataset.layerId = layer.id;

                        const lis = self.getLayerUIElements();
                        const layerList = self.map.workLayers
                            .filter(function (l) {
                                return !l.stealth;
                            });
                        const layerIdx = layerList.indexOf(layer);

                        self.layerTools.forEach(tool => self.addLayerToolUI(li, tool));

                        var inserted = false;
                        for (var i = 0, ii = lis.length; i < ii; i++) {
                            const referenceLi = lis[i];
                            const referenceLayerIdx = layerList.indexOf(self.map.getLayer(referenceLi.dataset.layerId));
                            if (referenceLayerIdx < layerIdx) {
                                referenceLi.insertAdjacentElement('beforebegin', li);
                                inserted = true;
                                break;
                            }
                        }
                        if (!inserted) {
                            ul.appendChild(li);
                        }

                        if (domReadyPromise) domReadyPromise(li);
                        self.updateScale();
                    });
                });

                var elligibleLayersNum = getElligibleLayersNumber(self);
                const numElm = self.div.querySelector('.' + self.CLASS + '-n');
                const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
                const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
                numElm.textContent = elligibleLayersNum;
                if (elligibleLayersNum > 0) {
                    numElm.classList.add(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.add(TC.Consts.classes.HIDDEN);
                    contentElm.classList.remove(TC.Consts.classes.HIDDEN);
                }
                else {
                    numElm.classList.remove(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
                    contentElm.classList.add(TC.Consts.classes.HIDDEN);
                }

                const deleteAllElm = self.div.querySelector('.' + self.CLASS + '-del-all');
                deleteAllElm.classList.toggle(TC.Consts.classes.HIDDEN, !shouldBeDelAllVisible(self));
            }
        }
    };

    ctlProto.updateScale = function () {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            var layer = self.map.getLayer(li.dataset.layerId);
            if (layer && layer.names) {
                var isVisible = false;
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        isVisible = true;
                        break;
                    }
                }
                li.classList.toggle(self.CLASS + '-elm-notvisible', !isVisible);
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        //TC.control.MapContents.prototype.updateLayerOrder.call(this, layer, oldIdx, newIdx);
        const self = this;
        self.map.workLayers
            .filter(function (layer) {
                return !layer.stealth;
            })
            .forEach(function (layer) {
                const li = findLayerElement(self, layer);
                if (li) {
                    li.parentElement.firstChild.insertAdjacentElement('beforebegin', li);
                }
            });
    };

    ctlProto.removeLayer = function (layer) {
        var self = this;
        var idx = self.layers.indexOf(layer);
        if (idx >= 0) {
            self.layers.splice(idx, 1);
        }
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                li.parentElement.removeChild(li);
            }
        });
        const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
        const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
        const numberElm = self.div.querySelector('.' + self.CLASS + '-n');
        var nChildren = getElligibleLayersNumber(self);
        numberElm.textContent = nChildren;
        if (nChildren > 0) {
            contentElm.classList.remove(TC.Consts.classes.HIDDEN);
            emptyElm.classList.add(TC.Consts.classes.HIDDEN);
            numberElm.classList.add(TC.Consts.classes.VISIBLE);
        }
        else {
            if (shouldBeDelAllVisible(self)) {
                self.div.querySelector('.' + self.CLASS + '-del-all').classList.add(TC.Consts.classes.HIDDEN);
            }
            contentElm.classList.add(TC.Consts.classes.HIDDEN);
            emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
            numberElm.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        return Array.from(self.div.querySelectorAll(`ul > li.${self.CLASS}-elm`));
    };

    ctlProto.addLayerToolUI = function (elm, tool) {
        const self = this;
        if (TC.Util.isFunction(tool.renderFn)) {
            const button = tool.renderFn(elm.querySelector(`.${self.CLASS}-tools`), elm.dataset.layerId);
            if (button) {
                if (TC.Util.isFunction(tool.actionFn)) {
                    button.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.preventDefault();
                        tool.actionFn.call(button);
                    });
                }
                if (TC.Util.isFunction(tool.updateFn) && tool.updateEvents) {
                    map.on(tool.updateEvents.join(' '), function (e) {
                        if (!e.layer || e.layer.id === button.dataset.layerId) {
                            tool.updateFn.call(button, e);
                        }
                    });
                }
            }
        }
    };

    ctlProto.addLayerTool = function (options) {
        const self = this;
        self.layerTools.push(options);
        self.getLayerUIElements().forEach(function (elm) {
            self.addLayerToolUI(elm, options);
        });
    };
})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Click = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if (self.options && self.options.callback) {
        self.callback = self.options.callback;
    }

    self.wrap = new TC.wrap.control.Click(self);
};

TC.inherit(TC.control.Click, TC.Control);

(function () {
    var ctlProto = TC.control.Click.prototype;

    ctlProto.CLASS = 'tc-ctl-click';

    ctlProto.register = function (map) {
        var self = this;
        self.wrap.register(map);
        return TC.Control.prototype.register.call(self, map);
    };

    ctlProto.activate = function () {
        var self = this;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate();
    };

    ctlProto.deactivate = function () {
        var self = this;
        self.wrap.deactivate();
        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.callback = function (coord, point) {
        console.log('[Click][' + coord[0] + ', ' + coord[1] + '][' + point[0] + ', ' + point[1] + ']');
    };
})();
TC.control = TC.control || {};

if (!TC.control.Click) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Click');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';
TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';

TC.control.FeatureInfoCommons = function () {
    const self = this;
    TC.control.Click.apply(self, arguments);

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        LIST_ITEM: 'ul' + cs + '-features li'
    };

    self.resultsLayer = null;
    self.filterLayer = null;
    self._layersPromise = null;
    self.filterFeature = null;
    self.info = null;
    self._infoHistory = {};
    self.popup = null;
    self.resultsPanel = null;
    self.lastFeatureCount = null;
    self.exportsState = true;
};

TC.control.FeatureInfoCommons.displayMode = {
    POPUP: 'popup',
    RESULTS_PANEL: 'resultsPanel'
};

(function () {

    var layerCount = function (ctl) {
        return ctl.info && ctl.info.services ?
            ctl.info.services.reduce(function (sCount, service) {
                return sCount + service.layers.reduce(function (lCount, layer) {
                    return lCount + 1;
                }, 0);
            }, 0) : 0;
    };

    TC.inherit(TC.control.FeatureInfoCommons, TC.control.Click);

    var ctlProto = TC.control.FeatureInfoCommons.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

    ctlProto.TITLE_SEPARATOR = ' • ';
    ctlProto.DEFAULT_STROKE_COLOR = '#0000ff';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/FeatureInfo.html";
    ctlProto.template[ctlProto.CLASS + "-object"] = TC.apiLocation + "TC/templates/FeatureInfoObject.html";

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.Click.prototype.register.call(self, map);

        self._createLayers();

        map.loaded(function () {
            const shareCtl = map.getControlsByClass('TC.control.Share')[0];
            if (shareCtl) {
                self.loadSharedFeature(shareCtl.loadParamFeature());
            }
        });

        self.displayMode = self.options.displayMode || TC.control.FeatureInfoCommons.displayMode.POPUP;
        self.setDisplayMode(self.displayMode);

        map
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                if (e.control === self.getDisplayControl() && self.resultsLayer) {
                    if (self.highlightedFeature && !self.options.persistentHighlights) {
                        self.downplayFeature(self.highlightedFeature);
                        self.highlightedFeature = null;
                    }
                    if (!self.querying && e.feature) {
                        self.filterLayer.removeFeature(e.feature);
                    }
                }
            })
            .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.highlightedFeature = null;
            })
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                const control = e.control;
                if (control.currentFeature !== self.filterFeature) {
                    self.highlightedFeature = control.currentFeature;
                }

                // GLS: si la feature es resultado de GFI decoramos
                if (e.control.caller == self) {
                    self._decorateDisplay(control);
                }

            })
            .on(TC.Consts.event.DRAWCHART, function (e) {
                setTimeout(function () {
                    self.highlightedFeature = e.control.currentFeature;
                }, 50);
            })
            .on(TC.Consts.event.LAYERREMOVE, function () {
                if (Object.keys(self._infoHistory).length) {
                    const services = {};
                    self.map.workLayers
                        .filter(function (layer) {
                            return layer.type === TC.Consts.layerType.WMS;
                        })
                        .forEach(function (layer) {
                            const names = services[layer.url] || [];
                            services[layer.url] = names.concat(layer.getDisgregatedLayerNames())
                        });
                    let featuresDeleted = false;
                    for (let url in self._infoHistory) {
                        const historyService = self._infoHistory[url];
                        if (services.hasOwnProperty(url)) {
                            const service = services[url];
                            for (let name in historyService) {
                                const historyLayer = historyService[name];
                                if (service.indexOf(name) < 0) {
                                    historyLayer.slice().forEach(f => self.downplayFeature(f));
                                    historyLayer.length = 0;
                                    featuresDeleted = true;
                                }
                            }
                        }
                        else {
                            for (let name in historyService) {
                                const historyLayer = historyService[name];
                                historyLayer.slice().forEach(f => self.downplayFeature(f));
                                featuresDeleted = true;
                            }
                            delete self._infoHistory[url];
                        }
                    }
                    if (featuresDeleted) {
                        self.closeResults();
                    }
                }
            })
            .on(TC.Consts.event.VIEWCHANGE, function (e) {
                self.closeResults();
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        // Este div se usa como buffer, así que no debe ser visible.
        self.div.classList.add(TC.Consts.classes.HIDDEN);
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.responseCallback = function (options) {
        const self = this;
        self.querying = false;

        if (self.filterFeature) {
            self.info = { services: options.services };
        }

        if (!options.featureCount) {
            self.lastFeatureCount = 0;
            self.map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self });
        }
        else {
            self._addSourceAttributes();
            self.lastFeatureCount = options.featureCount;
            self.map.trigger(TC.Consts.event.FEATUREINFO, TC.Util.extend({ control: self }, options));
        }
    };

    ctlProto.responseError = function (options) {
        const self = this;
        if (options.status === 404) {
            self.map.toast(self.getLocaleString("featureInfo.tooManyLayers"), { type: TC.Consts.msgType.ERROR });
        }
        self.responseCallback({});
    };

    ctlProto.markerStyle = {
        cssClass: TC.Consts.classes.POINT,
        anchor: [0.5, 0.5],
        width: 15,
        height: 15,
        noPrint: true
    };

    ctlProto.setDisplayMode = function (mode) {
        var self = this;
        self.displayMode = mode;
        var map = self.map;
        switch (mode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (!self.resultsPanel) {
                    map.addControl('resultsPanel')
                        .then(function (rp) {
                            self.resultsPanel = rp;
                            rp.caller = self;
                        });
                }
                break;
            default:
                self.displayMode = TC.control.FeatureInfoCommons.displayMode.POPUP;
                if (!self.popup) {
                    map.addControl('popup', {
                        closeButton: true,
                        draggable: self.options.draggable
                    }).then(function (popup) {
                        self.popup = popup;
                        popup.caller = self;
                        map.on(TC.Consts.event.POPUP, function (e) {
                            self.onShowPopup(e);
                        });

                        map.on(TC.Consts.event.POPUPHIDE, function (e) {
                            if (e.control === popup) {
                                //restaurar el ancho automático
                                self._resetSize();
                            }
                        });
                    });
                }
                break;
        }
    };

    ctlProto.getDisplayControl = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel;
            default:
                return self.popup;
        }
    };

    ctlProto.getDisplayTarget = function (options) {
        var self = this;
        options = options || {};
        if (options.control) {
            switch (true) {
                case TC.control.Popup && options.control instanceof TC.control.Popup:
                    return options.control.getContainerElement();
                case TC.control.ResultsPanel && options.control instanceof TC.control.ResultsPanel:
                    return options.control.getInfoContainer();
                default:
                    return null;
            }
        }
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getInfoContainer();
            default:
                return self.popup.getContainerElement();
        }
    };

    ctlProto.getMenuTarget = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getMenuElement();
            default:
                return self.popup.getMenuElement();
        }
    };

    ctlProto.displayResults = function () {
        var self = this;
        const clone = self.div.cloneNode(true);
        clone.classList.remove(TC.Consts.classes.HIDDEN);
        self.filterFeature.data = clone.outerHTML;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel) {
                    // GLS: si contamos con el control de controles no es necesario cerrar los paneles visibles ya que no habría solape
                    if (self.map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                        self.map.getControlsByClass(TC.control.ResultsPanel).forEach(function (p) {
                            if (p.isVisible()) {
                                p.close();
                            }
                        });
                    }

                    // cerramos los paneles con feature asociada
                    const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                    panels.forEach(function (p) {
                        if (p !== self.resultsPanel && p.currentFeature && !p.chart) {
                            p.close();
                        }
                    });

                    self.resultsPanel.currentFeature = self.filterFeature;
                    self.resultsPanel.open(self.filterFeature.data, self.resultsPanel.getInfoContainer());
                    
                    TC.loadJS(
                        !TC.control.Print,
                        [TC.apiLocation + 'TC/control/Print'],
                        function () {
                            // Eliminamos la impresora porque al pintar los resultados ya se añadirá
                            const printBtn = self.getMenuTarget().querySelectorAll('.' + TC.control.Print.prototype.CLASS + '-btn');
                            if (printBtn.length > 0) {
                                printBtn[0].remove();
                            }

                            self.displayResultsCallback();
                        });
                }

                break;
            default:
                if (self.popup) {
                    self.filterFeature.showPopup(self.popup);
                }
                break;
        }
    };

    const getElementIndex = function (elm) {
        return Array.from(elm.parentElement.children).indexOf(elm);
    };

    const getParentElement = function (elm, tagName) {
        var result = elm;
        do {
            result = result.parentElement;
        }
        while (result && result.tagName !== tagName);
        return result;
    };

    ctlProto.getFeatureElement = function (feature) {
        const self = this;
        var result;
        const getIndex = function (elm) {
            return Array.from(elm.parentElement.childNodes).getIndex(elm);
        };
        self.getDisplayTarget().querySelectorAll(self._selectors.LIST_ITEM).forEach(function (li) {
            const currentFeatureLi = li;
            const currentLayerLi = getParentElement(li, 'LI');
            const currentServiceLi = getParentElement(currentLayerLi, 'LI');
            var feat = self.getFeature(getElementIndex(currentServiceLi), getElementIndex(currentLayerLi), getElementIndex(currentFeatureLi));
            if (feat === feature) {
                result = currentFeatureLi;
            }
        });
        return result;
    };

    ctlProto.getNextFeatureElement = function (delta) {
        const self = this;
        const lis = self.getDisplayTarget().querySelectorAll('ul.' + self.CLASS + '-features > li');
        const length = lis.length;
        for (var i = 0; i < length; i++) {
            if (lis[i].matches('.' + TC.Consts.classes.CHECKED)) {
                return lis[(i + delta + length) % length]
            }
        }
        return null;
    };

    ctlProto.getFeaturePath = function (feature) {
        const self = this;
        if (self.info && self.info.services) {
            for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                const service = self.info.services[i];
                for (var j = 0, jj = service.layers.length; j < jj; j++) {
                    const layer = service.layers[j];
                    for (var k = 0, kk = layer.features.length; k < kk; k++) {
                        if (layer.features[k] === feature) {
                            return {
                                service: service.title || service.mapLayers.reduce(function (prev, cur) {
                                    return prev || cur.title;
                                }, ''),
                                layer: layer.path
                            };
                        }
                    }
                }
            }
        }
        return null;
    };

    ctlProto.closeResults = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel && self.resultsPanel.isVisible()) {
                    self.resultsPanel.close();
                }
                break;
            default:
                if (self.popup && self.popup.isVisible()) {
                    self.popup.hide();
                }
                break;
        }
    };

    ctlProto.displayResultsCallback = function () {
        var self = this;
        const content = self.getDisplayTarget().querySelector('.' + self.CLASS);

        var selector;
        // Evento para resaltar una feature
        var eventType = 'click'; // En iPad se usa click en vez de touchstart para evitar que se resalte una feature al hacer scroll
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(self._selectors.LIST_ITEM, function (e) {
            self.highlightFeature(e.target);
        }));

        // Evento para ir a la siguiente feature
        eventType = TC.Consts.event.CLICK;
        selector = '.' + self.CLASS + '-btn-next';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(1), 1);
            return false;
        }));

        // Evento para ir a la feature anterior
        selector = '.' + self.CLASS + '-btn-prev';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(-1), -1);
            return false;
        }));

        // Evento para desplegar/replegar features de capa
        selector = 'ul.' + self.CLASS + '-layers h4';

        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            const li = getParentElement(e.target, 'LI');
            if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                // Si no está en modo móvil ocultamos la capa (si hay más de una)
                const anotherLayer = content.querySelector('.tc-ctl-finfo-layers li:not(.tc-checked)');
                if (anotherLayer && getComputedStyle(anotherLayer).display !== 'none') {
                    self.downplayFeatures();
                }
            }
            else {
                self.highlightFeature(li.querySelector(self._selectors.LIST_ITEM));
                if (self.displayMode === TC.control.FeatureInfoCommons.displayMode.POPUP) {
                    self.popup.fitToView(true);
                }
            }
        }));

        // Evento para borrar la feature resaltada
        selector = '.' + self.CLASS + '-del-btn';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.downplayFeatures();
            self.closeResults();
        }));

        if (self.info) {
            if (self.info.defaultFeature && self.getFeatureElement(self.info.defaultFeature)) {
                self.getFeatureElement(self.info.defaultFeature).classList.add(TC.Consts.classes.DEFAULT);
                self.highlightFeature(self.info.defaultFeature);
            }
            else if (content.querySelector(self._selectors.LIST_ITEM)) {
                self.highlightFeature(content.querySelector(self._selectors.LIST_ITEM));
            }
        }

        content.querySelectorAll('table:not(.complexAttr)').forEach(function (table) {
            table.addEventListener(TC.Consts.event.CLICK, function (e) {
                const li = this.parentElement;
                if (li.classList.contains(TC.Consts.classes.DISABLED)) {
                    return;
                }
                if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                    // Si ya está seleccionada hacemos zoom
                    if (self.resultsLayer.features[0] && window.getSelection() && window.getSelection().toString().trim().length === 0) {
                        // Proceso para desactivar highlightFeature mientras hacemos zoom
                        var zoomHandler = function zoomHandler() {
                            self._zooming = false;
                            self.map.off(TC.Consts.event.ZOOM, zoomHandler);
                        };
                        self.map.on(TC.Consts.event.ZOOM, zoomHandler);
                        self._zooming = true;
                        ///////

                        self.map.zoomToFeatures([self.resultsLayer.features[0]], { animate: true });
                    }
                }
                else {
                    // Si no está seleccionada la seleccionamos
                    self.highlightFeature(li);
                }
                e.stopPropagation();
            });
        });
        content.querySelectorAll('table a, table label, table input').forEach(function (a) {
            a.addEventListener(TC.Consts.event.CLICK, function (e) {
                e.stopPropagation();
            });
        });

        if (TC.browserFeatures.touch() && self.displayMode === TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL) {
            const prevBtn = content.querySelector('.' + self.CLASS + '-btn-prev');
            if (!prevBtn || prevBtn.style.display !== 'none') { // Si los botones de anterior/siguiente están visibles, montamos el swipe
                if (self.resultsPanel) {
                    TC.Util.swipe(self.resultsPanel.div, 'disable');
                }

                if (layerCount(self) > 1) {
                    TC.Util.swipe(content, {
                        left: function () {
                            self.highlightFeature(self.getNextFeatureElement(1), 1);
                        },
                        right: function () {
                            self.highlightFeature(self.getNextFeatureElement(-1), -1);
                        }
                    });
                }
            }
        }
    };

    ctlProto.onShowPopup = function (e) {
        const self = this;
        if (e.control === self.popup) {

            self.displayResultsCallback();

            //ajustar el ancho para que no sobre a la derecha
            self._fitSize();
        }
    };

    ctlProto.loadSharedFeature = function (featureObj) {

    };

    ctlProto.insertLinks = function () {
        var self = this;
        const linkText = self.getLocaleString('open');
        const titleText = self.getLocaleString('linkInNewWindow');
        self.div.querySelectorAll('td.' + self.CLASS + '-val').forEach(function (td) {
            const text = td.textContent;
            if (TC.Util.isURL(text)) {
                td.innerHTML = '<a href="' + text + '" target="_blank" title="' + titleText + '">' + linkText + '</a>';
            }
        });
    };

    ctlProto.highlightFeature = function (featureOrElement, delta) {
        const self = this;
        var feature;
        if (!self._zooming) {
            var featureLi;
            // this puede ser o el elemento HTML de la lista correspondiente a la feature o la feature en sí
            if (featureOrElement instanceof TC.Feature) {
                feature = featureOrElement;
                featureLi = self.getFeatureElement(feature);
            }
            else {
                featureLi = featureOrElement;
                while (featureLi && featureLi.tagName !== 'LI') {
                    featureLi = featureLi.parentElement;
                }
            }
            const layerLi = getParentElement(featureLi, 'LI');
            const serviceLi = getParentElement(layerLi, 'LI');

            const serviceIdx = getElementIndex(serviceLi);
            const layerIdx = getElementIndex(layerLi);
            const featureIdx = getElementIndex(featureLi);
            feature = feature || self.getFeature(serviceIdx, layerIdx, featureIdx);

            self.downplayFeatures({ exception: feature });

            // Añadimos feature al historial de features resaltadas
            const service = self.info.services[serviceIdx];
            if (!self._infoHistory.hasOwnProperty(service.url)) {
                self._infoHistory[service.url] = {};
            }
            const historyService = self._infoHistory[service.url];
            const layer = service.layers[layerIdx];
            const historyLayer = historyService[layer.name] || [];
            historyService[layer.name] = historyLayer.concat(feature);

            featureLi.classList.add(TC.Consts.classes.CHECKED);
            layerLi.classList.add(TC.Consts.classes.CHECKED);
            serviceLi.classList.add(TC.Consts.classes.CHECKED);
            if (delta > 0) {
                featureLi.classList.add(TC.Consts.classes.FROMLEFT);
                layerLi.classList.add(TC.Consts.classes.FROMLEFT);
                serviceLi.classList.add(TC.Consts.classes.FROMLEFT);
            }
            else if (delta < 0) {
                featureLi.classList.add(TC.Consts.classes.FROMRIGHT);
                layerLi.classList.add(TC.Consts.classes.FROMRIGHT);
                serviceLi.classList.add(TC.Consts.classes.FROMRIGHT);
            }

            if (featureLi.querySelector('table')) {
                featureLi.querySelector('table').setAttribute('title', self.getLocaleString('clickToCenter'));
            }

            self.highlightedFeature = feature;

            if (self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current')) {
                self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current').innerHTML = self.getFeatureIndex(serviceIdx, layerIdx, featureIdx) + 1;
            }


            var features = self.resultsLayer.features.slice();
            var featureAlreadyHighlighted = features.filter(function (item) {
                return feature && feature.id === item.id;
            });

            //Si la feature a resaltar ya está resaltada, no hacemos nada. Así evitamos parpadeo
            if (featureAlreadyHighlighted.length > 0) {
                self.highlightedFeature = featureAlreadyHighlighted[0]; // Asignamos la original, la seleccionada inicialmente es un clon
                return;
            }

            if (!self.options.persistentHighlights) {
                features.forEach(f => {
                    if (f !== self.filterFeature) {
                        self.downplayFeature(f);
                    }
                });
            }
            if (feature && feature.geometry) {
                feature.showsPopup = self.options.persistentHighlights;
                self.resultsLayer.addFeature(feature);
            }
            else {
                featureLi.classList.add(TC.Consts.classes.DISABLED);
            }
        }
    };

    ctlProto.downplayFeature = function (feature) {
        const self = this;
        self.resultsLayer.removeFeature(feature);
        for (url in self._infoHistory) {
            const service = self._infoHistory[url];
            for (name in service) {
                const layer = service[name];
                const idx = layer.indexOf(feature);
                if (idx >= 0) {
                    layer.splice(idx, 1);
                    if (!layer.length) {
                        delete service[name];
                    }
                }
            }
        }
    };

    ctlProto.downplayFeatures = function (options) {
        const self = this;
        options = options || {};
        if (self.highlightedFeature && self.highlightedFeature !== options.exception) {
            self.downplayFeature(self.highlightedFeature);
            self.highlightedFeature = null;
        }
        const exceptionFLi = options.exception ? self.getFeatureElement(options.exception) : undefined;
        var exceptionLLi, exceptionSLi;
        if (exceptionFLi) {
            exceptionLLi = getParentElement(exceptionFLi, 'LI');
            exceptionSLi = getParentElement(exceptionLLi, 'LI');
        }

        const target = self.getDisplayTarget();
        Array.from(target.querySelectorAll('ul.' + self.CLASS + '-services li'))
            .filter(function (li) {
                return li !== exceptionFLi && li !== exceptionLLi && li !== exceptionSLi;
            })
            .forEach(function (li) {
                li.classList.remove(
                    TC.Consts.classes.CHECKED,
                    TC.Consts.classes.DISABLED,
                    TC.Consts.classes.FROMLEFT,
                    TC.Consts.classes.FROMRIGHT);
            });
        target.querySelectorAll('.' + self.CLASS + '-features table:not(.complexAttr)').forEach(function (table) {
            table.setAttribute('title', self.getLocaleString('clickToShowOnMap'));
        });
    };

    ctlProto._fitSize = function () {
        const self = this;
        const target = self.getDisplayTarget();
        var max = 0;
        //medir la máxima anchura de <ul>
        target.querySelectorAll("input").forEach(function (checkbox) { checkbox.checked = true })
        target.querySelectorAll(".tc-ctl-finfo-features li").forEach(function (elm) {
            max = Math.max(max, elm.offsetLeft + elm.offsetWidth);
        });

        //alert("max=" + max);
        if (max) {
            target.style.width = max + 50 + 'px';
        }
        target.querySelectorAll("input").forEach(function (checkbox) { checkbox.checked = false })
    };

    ctlProto._resetSize = function () {
        const self = this;
        self.getDisplayTarget().style.removeProperty('width');
    };

    ctlProto.getFeature = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result;
        const info = self.info;
        if (info && info.services) {
            result = info.services[serviceIdx];
            if (result) {
                result = result.layers[layerIdx];
                if (result) {
                    result = result.features[featureIdx];
                }
            }
        }
        return result;
    };

    ctlProto.getFeatureIndex = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result = -1;
        const info = self.info;
        if (info) {
            for (var i = 0; i <= serviceIdx; i++) {
                var service = info.services[i];
                var maxj = i === serviceIdx ? layerIdx : service.layers.length - 1;
                for (var j = 0; j <= maxj; j++) {
                    var layer = service.layers[j];
                    var maxk = j === layerIdx ? featureIdx : layer.features.length - 1;
                    for (var k = 0; k <= maxk; k++) {
                        result = result + 1;
                    }
                }
            }
        }
        return result;
    };

    ctlProto.beforeRequest = function (options) {
        var self = this;
        self.querying = true;
        self.map.trigger(TC.Consts.event.BEFOREFEATUREINFO, {
            xy: options.xy,
            control: self
        });
        self.closeResults();
        if (self.map && self.resultsLayer) {
            self.lastFeatureCount = null;

            if (!self.options.persistentHighlights) {
                self.resultsLayer.features.slice().forEach(f => self.downplayFeature(f));
            }
            self.info = null;
        }
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.wrap) {
            self.wrap.activate();
        }
        TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function (stopChain) {
        var self = this;
        if (self.popup && self.popup.isVisible()) {
            self.popup.hide();
        }
        if (!self.options.persistentHighlights) {
            self.resultsLayer.features.slice().forEach(f => self.downplayFeature(f));
            self.info = null;
            self._infoHistory = {};
        }
        self.filterLayer && self.filterLayer.clearFeatures();
        self.filterFeature = null;
        if (self.wrap) {
            self.wrap.deactivate();
        }
        TC.Control.prototype.deactivate.call(self, stopChain);
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.resultsLayer) {
            return {
                id: self.id,
                layer: self.resultsLayer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self._layersPromise.then(function () {
            self.resultsLayer.importState(state.layer);
        });
    };

    ctlProto._createLayers = function () {
        const self = this;

        var resultsLayer;
        if (self.options.resultsLayer) { // En caso de que se haya indicado una capa por configuración, la utilizamos
            resultsLayer = self.options.resultsLayer;
        } else {
            resultsLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Results layer',
                type: TC.Consts.layerType.VECTOR,
                owner: self,
                stealth: true
            };
        }
        var filterLayer;
        if (self.options.filterLayer) {
            filterLayer = self.options.filterLayer;
        }
        else {
            const styles = {};
            if (self.geometryType === TC.Consts.geom.POLYLINE) {
                styles.line = self.style;
            }
            if (self.geometryType === TC.Consts.geom.POLYGON) {
                styles.polygon = self.style;
            }

            filterLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Filter layer',
                owner: self,
                stealth: true,
                type: TC.Consts.layerType.VECTOR,
                styles: styles
            };
        }

        const map = self.map;
        self._layersPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                Promise.all([map.addLayer(resultsLayer), map.addLayer(filterLayer)]).then(function (layers) {
                    self.resultsLayer = layers[0];
                    self.filterLayer = layers[1];
                    resolve();
                });
            });
        });

        return self._layersPromise;
    };

    ctlProto._decorateDisplay = function (ctl) {
        const self = this;

        const resultsContainer = self.getMenuTarget({ control: ctl });

        // Añadimos botón de imprimir
        TC.loadJS(
            !TC.control.Print,
            [TC.apiLocation + 'TC/control/Print'],
            function () {

                if (!resultsContainer.querySelectorAll('.' + TC.control.Print.prototype.CLASS + '-btn').length) {
                    var printTitle = self.getLocaleString("feature");
                    if (ctl === self.getDisplayControl()) {
                        if (TC.feature.Point && self.filterFeature instanceof TC.feature.Point) {
                            const geom = self.filterFeature.geometry;
                            printTitle = self.getLocaleString('featuresAt', {
                                crs: self.map.crs,
                                x: TC.Util.formatCoord(geom[0], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION),
                                y: TC.Util.formatCoord(geom[1], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION)
                            });
                        }
                        else {
                            printTitle = self.getLocaleString('spatialQueryResults');
                        }
                    }
                    else if (ctl.currentFeature) {
                        printTitle = ctl.currentFeature.id;
                    }

                    // Si hay datos porque el popup es de un GFI con éxito o es de una feature resaltada damos la opción de imprimirlos
                    if (self.lastFeatureCount || (ctl.currentFeature && ctl.currentFeature.showsPopup === true)) {
                        new TC.control.Print({
                            target: resultsContainer,
                            printableElement: self.getDisplayTarget({ control: ctl }),
                            title: printTitle
                        });
                    }
                }
            }
        );
    };

    ctlProto._addSourceAttributes = function () {
        const self = this;
        const serviceAttrName = 'h3_' + self.getLocaleString('service');
        const layerAttrName = 'h4_' + self.getLocaleString('layer');
        // Añadimos como atributos los títulos de servicio y capa
        if (self.info && self.info.services) {
            self.info.services.forEach(function (service) {
                service.layers.forEach(function (layer) {
                    layer.features.forEach(function (feature) {
                        if (feature instanceof TC.Feature) {
                            const path = self.getFeaturePath(feature);
                            if (path) {
                                const newData = {};
                                newData[serviceAttrName] = path.service;
                                if (path.layer) {
                                    newData[layerAttrName] = path.layer.join(self.TITLE_SEPARATOR);
                                }
                                const allData = TC.Util.extend(newData, feature.getData());
                                feature.clearData();
                                feature.setData(allData);
                            }
                        }
                    });
                });
            });
        }
    };

})();

TC.control = TC.control || {};
TC.Consts = TC.Consts || {};
TC.Consts.SCREEN_SIZE_KEY = 'TC.Map.screenSize';

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Scale = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.Scale, TC.Control);

(function () {
    var ctlProto = TC.control.Scale.prototype;

    ctlProto.CLASS = 'tc-ctl-scl';

    ctlProto.template = TC.apiLocation + "TC/templates/Scale.html";

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize }, function () {

            const span = self.div.querySelector('span');
            span.textContent = '1:' + self.format(span.textContent.substr(2));

            self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        var screenSize = TC.Util.storage.getLocalValue(TC.Consts.SCREEN_SIZE_KEY);
        if (screenSize) {
            TC.Cfg.screenSize = screenSize;
        }
        self.render(function () {
            map.on(TC.Consts.event.ZOOM, function () {
                delete self.metersPerDegree;
                self.update();
            });
        });

        return result;
    };

    ctlProto.update = function () {
        this.render();
    };

    /*
     *  setScreenSize: Prompts for screen size in inches, updates and stores value
     */
    ctlProto.setScreenSize = function () {
        var self = this;
        TC.prompt(self.getLocaleString('selectScreenSize'), TC.Cfg.screenSize, function (value) {
            if (value) {
                TC.Cfg.screenSize = parseFloat(value);
                TC.Util.storage.setLocalValue(TC.Consts.SCREEN_SIZE_KEY, TC.Cfg.screenSize);
                self.update();
            }
        });
    };

    /*
     *  getScale: Gets scale denominator with a resolution or current map resolution and estimated screen DPI
     *  Parameters: number (optional), the resolution to get scale from. If no parameter is given, current map resolution is used
     *  Returns: number
     */
    ctlProto.getScale = function (resolution) {
        var self = this;
        var result = 0;
        var res = (!resolution && self.map) ? self.map.wrap.getResolution() : resolution;
        if (res) {
            result = res * self.getDpi(TC.Cfg.screenSize) / .0254;
            if (window.devicePixelRatio) {
                result = result * window.devicePixelRatio;
            }
        }
        if (self.map && self.map.wrap.isGeo()) {
            if (!self.metersPerDegree) {
                var extent = self.map.getExtent();
                if (extent) {
                    self.metersPerDegree = TC.Util.getMetersPerDegree(extent);
                }
            }
            if (self.metersPerDegree) {
                result = result * self.metersPerDegree;
            }
        }
        return result;
    };

    /*
     *  getDpi: Gets estimated DPI based on screen resolution and screenSize value
     *  Returns: number
     */
    ctlProto.getDpi = function (screenSize) {
        var self = this;
        self.dpi = Math.sqrt(screen.width * screen.width + screen.height * screen.height) / screenSize;
        return self.dpi;
    };


    ctlProto.format = function (number) {
        var n = (new Number(number)).toFixed(0);
        var a = [];
        while (n.length > 3) {
            var l = n.length - 3;
            a.unshift(n.substr(l));
            n = n.substr(0, l);
        }
        if (n) {
            a.unshift(n);
        }
        return a.join('.');
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.SWCacheClient = function () {
        const self = this;
        TC.Control.apply(this, arguments);
        self.serviceWorkerEnabled = false;
    };

    TC.inherit(TC.control.SWCacheClient, TC.Control);

    var ctlProto = TC.control.SWCacheClient.prototype;

    ctlProto.CLASS = 'tc-ctl-swcc';
    ctlProto.SW_URL = 'tc-cb-service-worker.js';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        // Si el navegador es compatible, añadimos el service worker.
        self._swPromise = new Promise(function (resolve, reject) {
            if (navigator.serviceWorker) {

                navigator.serviceWorker.register(self.SW_URL, {
                    scope: './'
                }).then(
                    function (reg) {
                        self.serviceWorkerEnabled = true;
                        if (reg.installing) {
                            resolve(reg.installing);
                        } else if (reg.waiting) {
                            resolve(reg.waiting);
                        } else if (reg.active) {
                            resolve(reg.active);
                        }
                        console.log(reg.scope, 'register');
                    },
                    function (reason) {
                        self.serviceWorkerEnabled = false;
                        reject(new Error(reason));
                        console.error('Could not register service worker: ' + reason);
                    });
            }
            else {                
                reject(new Error("Browser does not support service workers"));
            }
        });

        self._swPromise.catch(() => {
            if (location.protocol !== 'https:') {
                map.toast(self.getLocaleString('httpsRequired.warning', { url: location.href.replace(location.protocol, '') }), { type: TC.Consts.msgType.WARNING });
            }
            else {
                map.toast(self.getLocaleString('browserNotCompatible.warning'), { type: TC.Consts.msgType.WARNING });
            }
        });
        return result;
    };

    ctlProto.getServiceWorker = function () {
        if (!this._swPromise) {
            return Promise.reject(new Error('No service worker available'));
        }
        return this._swPromise;
    };

    var addMessageEventListener = function (resolve, reject, cacheName, action, eventName) {
        var MESSAGE = 'message';
        var messageHandler = function messageHandler(event) {
            if (event.data.name === cacheName) {
                if (event.data.action === action && event.data.event === eventName) {
                    resolve(cacheName);
                }
                else if (event.data.event === 'error') {
                    reject(Error(`Error message from service worker [${event.data.url} - ${event.data.action} - ${event.data.name}]`));
                }
                if (event.data.event !== 'progress') {
                    navigator.serviceWorker.removeEventListener(MESSAGE, messageHandler);
                }
            }
        };
        navigator.serviceWorker.addEventListener(MESSAGE, messageHandler);
    };

    ctlProto.createCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'create';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'cached');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    list: opts.urlList || [],
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

    ctlProto.deleteCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'delete';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'deleted');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Measure = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.drawControls = [];
    self.persistentDrawControls = false;
    self.NOMEASURE = '-';

    self.exportsState = true;

    this.renderPromise().then(function () {
        self.measureMode = self.options.mode;

        self.history = [];
        self.historyIndex = 0;
        self.reset = true;

        self.wrap = new TC.wrap.control.Measure(self);

        self._len = self.div.querySelector('.tc-ctl-meas-val-len');
        self._area = self.div.querySelector('.tc-ctl-meas-val-area');
        self._peri = self.div.querySelector('.tc-ctl-meas-val-peri');

        self.setMode(self.options.mode);
    });
};
TC.control.Measure.units = {
    "m": { peso: 0, abbr: "m&sup2;" },
    "dam": { peso: 1, abbr: "dam&sup2;" },
    "hm": { peso: 2, abbr: "hm&sup2;" },
    "ha": { peso: 2, abbr: "ha" },
    "km": { peso: 3, abbr: "km&sup2;" }
}

TC.inherit(TC.control.Measure, TC.Control);

(function () {
    var ctlProto = TC.control.Measure.prototype;

    ctlProto.CLASS = 'tc-ctl-meas';

    ctlProto.template = TC.apiLocation + "TC/templates/Measure.html";

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(TC.Control.prototype.render.call(self, function () {
            TC.loadJS(
                !TC.control.Draw,
                TC.apiLocation + 'TC/control/Draw',
                function () {
                    if (self.options.mode) {
                        self.div.querySelector('.tc-ctl-meas-select').classList.add(TC.Consts.classes.HIDDEN);
                    }

                    self.div.querySelectorAll(`.${TC.control.Measure.prototype.CLASS}-select span`).forEach(function (span) {
                        span.addEventListener(TC.Consts.event.CLICK, function (e) {
                            var label = this;
                            while (label && label.tagName !== 'LABEL') {
                                label = label.parentElement;
                            }
                            var checkbox = label.querySelector('input[type=radio][name=mode]');
                            var newMode = checkbox.value;

                            checkbox.checked = true;
                            self.setMode(newMode, true);
                        });
                    });

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map).then(function () {
                self.map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (self.map.view === TC.Consts.view.PRINTING) {
                        self.trigger(TC.Consts.event.DRAWEND);
                    }
                });

                const layerId = self.getUID();
                const drawLinesId = self.getUID();
                const drawPolygonsId = self.getUID();

                self.units = self.options.units ? self.options.units : "km";

                self.layerPromise = map.addLayer({
                    id: layerId,
                    title: self.getLocaleString('measure'),
                    owner: self,
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR,
                    styles: {
                        point: map.options.styles.point,
                        line: map.options.styles.line,
                        polygon: map.options.styles.polygon
                    }
                });

                self.units = self.options.units ? self.options.units : "km";

                Promise.all([self.layerPromise, self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);

                    self._lineDrawControlPromise = map.addControl('draw', {
                        id: drawLinesId,
                        div: self.div.querySelector('.tc-ctl-meas-line'),
                        mode: TC.Consts.geom.POLYLINE,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });
                    self._polygonDrawControlPromise = map.addControl('draw', {
                        id: drawPolygonsId,
                        div: self.div.querySelector('.tc-ctl-meas-polygon'),
                        mode: TC.Consts.geom.POLYGON,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });

                    Promise.all([self._lineDrawControlPromise, self._polygonDrawControlPromise]).then(function (controls) {
                        self.lineDrawControl = controls[0];
                        self.polygonDrawControl = controls[1];
                        controls.forEach(function (ctl) {
                            ctl.containerControl = self;
                            self.drawControls.push(ctl);
                            ctl
                                .on(TC.Consts.event.MEASURE + ' ' + TC.Consts.event.MEASUREPARTIAL, function (e) {
                                    self.showMeasures(e);
                                })
                                .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                    // Alerta de condición de carrera si no ponemos un timeout:
                                    // 1- Se llama a cancel de un control Draw.
                                    // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                    // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                    // 4- Se llama a cancel desde aquí.
                                    // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                    // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                    // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                    setTimeout(function () {
                                        self.cancel();
                                    }, 100);
                                });
                            // Desactivamos el método exportState que ya se encarga el control padre de ello
                            ctl.exportsState = false;
                        });

                        resolve(self);
                        self.setMode(self.options.mode);
                    }).catch(reject);
                }).catch(reject);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;

        const modes = [];
        self.div.querySelectorAll('.tc-ctl-meas-mode').forEach(function (elm) {
            modes.push(elm);
        });
        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-len');
                })[0];
                break;
            case TC.Consts.geom.POLYGON:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-area');
                })[0];
                break;
            case null:
            case undefined:
                self._activeMode = null;
                break;
            default:
                break;
        }

        const hiddenModes = modes.filter(function (elm) {
            return elm !== self._activeMode;
        });

        if (mode) {
            const radio = self.div.querySelector('input[type=radio][name=mode][value=' + mode + ']');
            radio.checked = true;
        }
        else {
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.checked = false;
            });
        }
        if (self._activeMode) {
            self._activeMode.classList.remove(TC.Consts.classes.HIDDEN);
            self._activeMode.querySelector('.tc-ctl').classList.remove(TC.Consts.classes.COLLAPSED);
        }
        hiddenModes.forEach(function (elm) {
            elm.classList.add(TC.Consts.classes.HIDDEN);
        });
        return self;
    };

    ctlProto.setMode = function (mode) {
        const self = this;

        self.mode = mode;
        self.displayMode(mode);

        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self.lineDrawControl.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case TC.Consts.geom.POLYGON:
                self.polygonDrawControl.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case null:
            case undefined:
                self.drawControls.forEach(function (ctl) {
                    if (ctl.isActive) {
                        ctl.cancel();
                    }
                });
                event = TC.Consts.event.CONTROLDEACTIVATE;
                break;
            default:
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
        }

        self.resetValues();

        if (event && self.map) {
            self.map.trigger(event, { control: self });
        }
        return self;
    };

    ctlProto.cancel = function () {
        this.setMode(null, false);
        return this;
    }

    ctlProto.showMeasures = function (options) {
        const self = this;
        options = options || {};
        var units = options.units;
        var precision;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.area) {
            var area = options.area;
            let html = [];
            (self.units instanceof Array ? self.units : self.units.split(",")).forEach(function (unit) {
                const difPeso = TC.control.Measure.units[unit.trim()].peso - TC.control.Measure.units["m"].peso;
                if (area > Math.pow(100, (difPeso - 1))) {
                    let precision = unit === 'm' ? 0 : 3;
                    html.push(TC.Util.formatNumber((area / Math.pow(100, (difPeso))).toFixed(precision), locale) + ' ' + TC.control.Measure.units[unit].abbr);
                }
            })
            self._area.innerHTML = html.join("/");
        }
        if (options.perimeter) {
            var perimeter = options.perimeter;
            if (perimeter > 1000) {
                perimeter = perimeter / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._peri.innerHTML = TC.Util.formatNumber(perimeter.toFixed(precision), locale) + ' ' + units;
        }
        if (options.length) {
            var length = options.length;
            if (length > 1000) {
                length = length / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._len.innerHTML = TC.Util.formatNumber(length.toFixed(precision), locale) + ' ' + units;
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        if (self._len) {
            self._len.textContent = self.NOMEASURE;
            self._area.textContent = self.NOMEASURE;
            self._peri.textContent = self.NOMEASURE;
        }
        return self;
    };

    ctlProto.getDrawLines = function () {

    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.layer) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.layerPromise.then(function (layer) {
            layer.importState(state.layer);
        });
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.ProjectionSelector = function () {
        const self = this;

        TC.Control.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code',
            CHANGE: self.CLASS + '-change',
            NO_CHANGE: self.CLASS + '-no-change'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.' + self._cssClasses.LOAD_CRS_BUTTON + ')', function (e) {
            const crs = e.target.dataset.crsCode;
            if (crs) {
                self.setProjection({
                    crs: crs,
                    allowFallbackLayer: true
                });
            }
        }));

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON, function (e) {
            self.loadFallbackProjections();
        }));
    };

    TC.inherit(TC.control.ProjectionSelector, TC.Control);

    const ctlProto = TC.control.ProjectionSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-projs';

    const _dataKeys = {
        LAYER: 'tcLayer',
        FALLBACK_LAYER: 'tcFallbackLayer'
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        });
        return result;
    };

    ctlProto.getAvailableCRS = function (options) {
        return this.map.getCompatibleCRS(TC.Util.extend(options || {}, { includeFallbacks: true }))
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self._cssClasses.CRS_DIALOG);
        const body = dialog.querySelector('.tc-modal-body');
        body.classList.add(TC.Consts.classes.LOADING);
        const ul = body.querySelector('ul.' + self._cssClasses.CRS_LIST);
        ul.innerHTML = '';
        const blFirstOption = self.map.baseLayer.firstOption || self.map.baseLayer;
        const blFallback = blFirstOption.isRaster() ? blFirstOption.getFallbackLayer() : null;

        const loadProjs = function () {
            var crsList = [];
            var blCRSList = [];

            options = options || {};
            
            if (blFirstOption.isRaster()) {
                blCRSList = blFirstOption.getCompatibleCRS();
                crsList = self.getAvailableCRS(TC.Util.extend(options, {}));
            } else {
                blCRSList = self.map.baseLayers
                    .filter((layer) => {
                        return layer.isRaster();
                    })
                    .map((layer) => {
                        return layer.getCompatibleCRS({ normalized: true, includeFallback: true });
                    })
                    .reduce((prev, current, index, array) => {
                        return prev.concat(current.filter((l) => { return prev.indexOf(l) < 0 }));
                    });

                const crsLists = (options.layer ? self.map.workLayers.concat(options.layer) : self.map.workLayers)
                    .filter(function (layer) {
                        return layer.isRaster();
                    })
                    .map(function (layer) {
                        return layer.getCompatibleCRS({ normalized: true, includeFallback: true });
                    });

                crsList = blCRSList.filter((crs) => {
                    return crsLists.every((elm) => {
                        return elm.indexOf(crs) > -1;
                    });
                });
            }

            self.map.loadProjections({
                crsList: crsList,
                orderBy: 'name'
            }).then(function (projList) {
                var hasFallbackCRS = false;
                var currentCRSName = dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_NAME);
                var currentCRSCode = dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_CODE);
                projList
                    .forEach(function (projObj) {
                        if (currentCRSName && currentCRSCode && TC.Util.CRSCodesEqual(self.map.crs, projObj.code)) {
                            currentCRSName.textContent = projObj.name;
                            currentCRSCode.textContent = projObj.code;
                        }
                        else {
                            const button = document.createElement('button');
                            button.textContent = projObj.name + ' (' + projObj.code + ')';
                            button.dataset.crsCode = projObj.code;
                            const li = document.createElement('li');
                            li.appendChild(button);
                            if (blCRSList.filter(function (crs) {
                                return TC.Util.CRSCodesEqual(crs, projObj.code)
                            }).length === 0) {
                                // Es un CRS del fallback
                                hasFallbackCRS = true;
                                li.classList.add(TC.Consts.classes.HIDDEN);
                                button.classList.add(TC.Consts.classes.WARNING);
                            }
                            ul.appendChild(li);
                        }
                    });
                if (hasFallbackCRS) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                    button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                    li.appendChild(button);
                    ul.appendChild(li);
                }

                // Mostramos un aviso si no hay CRS compatibles
                if (ul.querySelectorAll('li').length === 0) {
                    const li = document.createElement('li');
                    li.innerHTML = self.getLocaleString('thereAreNoCompatibleCRS');
                    ul.appendChild(li);
                }
                const visibleLi = ul.querySelectorAll('li:not(.' + TC.Consts.classes.HIDDEN + ')');
                dialog.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? '' : 'none';
                });
                dialog.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? 'none' : '';
                });
                dialog.querySelector('ul.' + self._cssClasses.CRS_LIST).style.display = visibleLi.length > 0 || hasFallbackCRS ? '' : 'none';
                body.classList.remove(TC.Consts.classes.LOADING);
            });
        };

        if (blFallback) {
            blFallback.getCapabilitiesPromise().then(loadProjs);
        }
        else {
            loadProjs();
        }
        TC.Util.showModal(dialog, options);
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options);
            }
        });
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
        self._dialogDiv.querySelectorAll('p.' + TC.Consts.classes.WARNING).forEach(function (p) {
            p.classList.remove(TC.Consts.classes.HIDDEN);
        })
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? '' : 'none';
        });
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? 'none' : '';
        });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Container = function () {
    var self = this;

    TC.Control.apply(self, arguments);    

    self.controlOptions = self.options.controls || [];

    self.ctlCount = self.controlOptions instanceof Array ? self.controlOptions.length : Object.keys(self.controlOptions).length;    
    self.defaultSelection = self.options.defaultSelection;
};

TC.inherit(TC.control.Container, TC.Control);

(function () {
    var ctlProto = TC.control.Container.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.uids = new Array(self.ctlCount);
        self.uids.forEach(function (elm, idx, arr) {
            arr[idx] = self.getUID();
        });

        return new Promise(function (resolve, rejetc) {
            Promise.all([result, self.renderPromise()]).then(function () {
                self.onRenderPromise();

                resolve(self);
            });
        });        
    };

    ctlProto.onRenderPromise = function () { };

    ctlProto.render = function (callback) { };

    ctlProto.getControl = function (idx) {
        var promise = this._ctlPromises[idx];
        if (!promise) {
            return Promise.reject(Error('No control found'));            
        }

        return promise;
    };

})();

TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.TabContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        TAB: cs + '-tab',
        RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
        ELEMENT: cs + '-elm'
    };    
};

TC.inherit(TC.control.TabContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.TabContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-tctr';

    ctlProto.template = TC.apiLocation + "TC/templates/TabContainer.html";

    ctlProto.onRenderPromise = function () {
        const self = this;

        self.title = self.title || self.getLocaleString(self.options.title || 'moreControls');
        self.div.querySelector('h2').innerHTML = self.title;

        var bufferPromises = new Array(self.ctlCount);
        for (var i = 0, len = self.controlOptions.length; i < len; i++) {
            var ctl = self.controlOptions[i];
            var ctlName = "";
            var ctlOptions = {};

            // GLS: 20/01/2020 código compatibilidad hacia atrás
            if (ctl["name"] !== undefined && ctl["options"] !== undefined) {
                console.log('Gestionamos config de tabContainer antiguo');

                ctlName = ctl["name"];
                ctlOptions = ctl["options"];
            } else {
                ctlName = Object.keys(ctl).filter((key) => {
                    return key !== "title";
                })[0];
                ctlOptions = ctl[ctlName];
            }
            
            bufferPromises[i] = self.map.addControl(ctlName, TC.Util.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i)
            }, ctlOptions));
        }
        var writeTitle = function (ctl, idx) {
            ctl.renderPromise().then(function () {
                const title = self.getLocaleString(self.controlOptions[idx].title) || ctl.div.querySelector('h2').innerHTML;
                var parent = ctl.div;
                do {
                    parent = parent.parentElement;
                }
                while (parent && !parent.matches(self._classSelector));
                parent.querySelector(self._selectors.TAB + '-' + idx + ' span').innerHTML = title;
            });
        };
        Promise.all(bufferPromises).then(function (controls) {
            for (var i = 0, len = controls.length; i < len; i++) {
                var ctl = controls[i];
                ctl.containerControl = self;
                writeTitle(ctl, i);                
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ title: self.title, controls: self.controlOptions }, function () {

            var clickHandler = function (e) {
                var closest = this;
                while (closest && !closest.matches(self._selectors.TAB)) {
                    closest = closest.parentElement;
                }
                var active, hidden = [];
                const checkbox = closest.querySelector(self._selectors.RADIOBUTTON);
                const newValue = checkbox.value;
                const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                if (self._oldValue === newValue && self.options.deselectable) {
                    setTimeout(function () {
                        checkbox.checked = false;
                    }, 0);
                    self._oldValue = null;
                    active = null;
                    hidden = elms;
                }
                else {
                    elms.forEach(function (elm) {
                        if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                            active = elm;
                        }
                        else {
                            hidden.push(elm);
                        }
                    });
                    self._oldValue = newValue;
                }

                if (active && active.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    active.classList.remove(TC.Consts.classes.COLLAPSED);

                    // GLS 24/01/2020 necesitamos un mutation observer para poder quitar el tc.collapsed cuando volvamos de  
                    // otro control ya que no hay click porque la pestaña ya está activa.
                    var observerTabElementAddCollapsedClass = new MutationObserver(function (mutations) {                        
                        mutations.forEach(function (mutation) {
                            if (mutation.target.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                mutation.target.classList.remove(TC.Consts.classes.COLLAPSED);
                            }
                        });
                    });
                    
                    observerTabElementAddCollapsedClass.observe(active, { attributes: true });                    
                }

                if (active) {
                    active.classList.remove(TC.Consts.classes.HIDDEN);
                }
                hidden.forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
                checkbox.checked = true;
            };

            self.div.querySelectorAll('span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, clickHandler);
            });

            // GLS: Si en el register de control se llama a render, ¿por qué volvemos a llamarlo aquí?
            //for (var i = 0, len = self._ctlPromises.length; i < len; i++) {
            //    self.getControl(i).then(function (ctl) {
            //        ctl.render();
            //    });
            //}

            if (typeof self.defaultSelection === 'number') {
                clickHandler.call(self.div.querySelectorAll(self._selectors.RADIOBUTTON)[self.defaultSelection]);
            }
        }));
    };

})();

(function () {
    /**
     * @const
     * @type {Array<null|string>}
     */
    let NAMESPACE_URIS = [
        null,
        'http://www.topografix.com/GPX/1/0',
        'http://www.topografix.com/GPX/1/1'
    ];


    // GLS: Obtenemos las combinaciones posibles
    const getAllCombinations = function (array) {
        var combi = [];
        var temp = [];

        var len = Math.pow(2, array.length);

        for (var i = 0; i < len; i++) {
            temp = [];
            for (var j = 0; j < array.length; j++) {
                if ((i & Math.pow(2, j))) {
                    if (temp.indexOf(array[j]) == -1)
                        temp.push(array[j]);
                }
            }
            if (temp.length > 0) {
                if (combi.indexOf(temp.join(' ')) == -1)
                    combi.push(temp.join(' '));
            }
        }

        return combi;
    }

    // GLS: Limpiamos de los nuevos los URIS ya disponibles en el formato
    const cleanCombinationsByFormat = function (customURIS, formatURIS) {
        if (customURIS && customURIS.length > 0) {
            for (var i = 0; i < formatURIS.length; i++) {
                var index = customURIS.indexOf(formatURIS[i]);
                if (index > -1)
                    customURIS.splice(index, 1);
            }
        }
    };

    // GLS: Obtenemos los nuevos URIS para KML
    const CUSTOM_NAMESPACE_URIS = getAllCombinations(NAMESPACE_URIS.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(CUSTOM_NAMESPACE_URIS, NAMESPACE_URIS);
    NAMESPACE_URIS = NAMESPACE_URIS.concat(CUSTOM_NAMESPACE_URIS);

    // FLP: No utilizamos directamente ol.format.xsd.readDateTime porque esta función devuelve un timestamp en segundos.
    const readDateTime = function (node) {
        return ol.format.xsd.readDateTime(node) * 1000;
    };

    /**
     * @const
     * @type {string}
     */
    const SCHEMA_LOCATION = 'http://www.topografix.com/GPX/1/1 ' +
        'http://www.topografix.com/GPX/1/1/gpx.xsd';

    /**
     * @const
     * @type {Object<string, function(Node, Array<*>): (ol.Feature|undefined)>}
     */
    const FEATURE_READER = {
        'rte': readRte,
        'trk': readTrk,
        'wpt': readWpt
    };


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GPX_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'rte': ol.xml.makeArrayPusher(readRte),
            'trk': ol.xml.makeArrayPusher(readTrk),
            'wpt': ol.xml.makeArrayPusher(readWpt)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString, 'linkText'),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString, 'linkType')
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const GPX_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'rte': ol.xml.makeChildAppender(writeRte),
            'trk': ol.xml.makeChildAppender(writeTrk),
            'wpt': ol.xml.makeChildAppender(writeWpt)
        });

    const writeDateTimeTextNode = function (node, dateTime) {
        var date = new Date(dateTime);
        var string = date.getUTCFullYear() + '-' +
            ol.string.padNumber(date.getUTCMonth() + 1, 2) + '-' +
            ol.string.padNumber(date.getUTCDate(), 2) + 'T' +
            ol.string.padNumber(date.getUTCHours(), 2) + ':' +
            ol.string.padNumber(date.getUTCMinutes(), 2) + ':' +
            ol.string.padNumber(date.getUTCSeconds(), 2) + 'Z';
        node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
    };

    /**
     * @typedef {Object} Options
     * @property {function(Feature, Node)} [readExtensions] Callback function
     * to process `extensions` nodes. To prevent memory leaks, this callback function must
     * not store any references to the node. Note that the `extensions`
     * node is not allowed in GPX 1.0. Moreover, only `extensions`
     * nodes from `wpt`, `rte` and `trk` can be processed, as those are
     * directly mapped to a feature.
     */

    /**
     * @typedef {Object} LayoutOptions
     * @property {boolean} [hasZ]
     * @property {boolean} [hasM]
     */

    /**
     * @classdesc
     * Feature format for reading and writing data in the GPX format.
     *
     * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first
     * feature of the source.
     *
     * When reading, routes (`<rte>`) are converted into LineString geometries, and
     * tracks (`<trk>`) into MultiLineString. Any properties on route and track
     * waypoints are ignored.
     *
     * When writing, LineString geometries are output as routes (`<rte>`), and
     * MultiLineString as tracks (`<trk>`).
     *
     * @api
     */
    class GPXCustom extends ol.format.GPX {

        /**
         * @param {Options=} opt_options Options.
         */
        constructor(opt_options) {
            super(opt_options);
        }

        /**
         * @inheritDoc
         */
        readFeatureFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return null;
            }
            const featureReader = FEATURE_READER[node.localName];
            if (!featureReader) {
                return null;
            }
            const feature = featureReader(node, [this.getReadOptions(node, opt_options)]);
            if (!feature) {
                return null;
            }
            this.handleReadExtensions_([feature]);
            return feature;
        }

        /**
         * @inheritDoc
         */
        readFeaturesFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return [];
            }
            if (node.localName == 'gpx') {
                /** @type {Array<ol.Feature>} */
                const features = ol.xml.pushParseAndPop([], GPX_PARSERS,
                    node, [this.getReadOptions(node, opt_options)]);
                if (features) {
                    this.handleReadExtensions_(features);
                    return features;
                } else {
                    return [];
                }
            }
            return [];
        }

        writeFeaturesNode(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            //FIXME Serialize metadata
            const gpx = ol.xml.createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');
            const xmlnsUri = 'http://www.w3.org/2000/xmlns/';
            gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', ol.xml.XML_SCHEMA_INSTANCE_URI);
            gpx.setAttributeNS(ol.xml.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);
            gpx.setAttribute('version', '1.1');
            gpx.setAttribute('creator', 'OpenLayers');

            ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */
                ({ node: gpx }), GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
            return gpx;
        }
    };


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const RTE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'number': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'extensions': parseExtensions,
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'rtept': parseRtePt
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const RTEPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'number': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'extensions': parseExtensions,
            'trkseg': parseTrkSeg
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRKSEG_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'trkpt': parseTrkPt
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const TRKPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const WPT_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'time': ol.xml.makeObjectPropertySetter(readDateTime),
            'magvar': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'geoidheight': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'cmt': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'desc': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'src': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'link': parseLink,
            'sym': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'type': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'fix': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'sat': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'hdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'vdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'pdop': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'ageofdgpsdata': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'dgpsid': ol.xml.makeObjectPropertySetter(ol.format.xsd.readNonNegativeInteger),
            'extensions': parseExtensions
        });


    /**
     * @const
     * @type {Array<string>}
     */
    const LINK_SEQUENCE = ['text', 'type'];


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LINK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const RTE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'rtept'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const RTE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'number': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'rtept': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(writeWptType))
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const RTEPT_TYPE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'ele', 'time'
        ]);


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const TRK_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'trkseg'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const TRK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'number': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'trkseg': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(writeTrkSeg))
        });


    /**
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const TRKSEG_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('trkpt');


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const TRKSEG_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'trkpt': ol.xml.makeChildAppender(writeWptType)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const WPT_TYPE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'ele', 'time', 'magvar', 'geoidheight', 'name', 'cmt', 'desc', 'src',
            'link', 'sym', 'type', 'fix', 'sat', 'hdop', 'vdop', 'pdop',
            'ageofdgpsdata', 'dgpsid'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const WPT_TYPE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ele': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'time': ol.xml.makeChildAppender(writeDateTimeTextNode),
            'magvar': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'geoidheight': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'link': ol.xml.makeChildAppender(writeLink),
            'sym': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'type': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'fix': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'sat': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode),
            'hdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'vdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'pdop': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'ageofdgpsdata': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'dgpsid': ol.xml.makeChildAppender(ol.format.xsd.writeNonNegativeIntegerTextNode)
        });


    /**
     * @const
     * @type {Object<string, string>}
     */
    const GEOMETRY_TYPE_TO_NODENAME = {
        'Point': 'wpt',
        'LineString': 'rte',
        'MultiLineString': 'trk'
    };


    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
        const geometry = /** @type {ol.Feature} */ (value).getGeometry();
        if (geometry) {
            const nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
            if (nodeName) {
                const parentNode = objectStack[objectStack.length - 1].node;
                return ol.xml.createElementNS(parentNode.namespaceURI, nodeName);
            }
        }
    }


    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {LayoutOptions} layoutOptions Layout options.
     * @param {Element} node Node.
     * @param {!Object} values Values.
     * @return {Array<number>} Flat coordinates.
     */
    function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
        flatCoordinates.push(
            parseFloat(node.getAttribute('lon')),
            parseFloat(node.getAttribute('lat')));
        if ('ele' in values) {
            flatCoordinates.push(/** @type {number} */(values['ele']));
            delete values['ele'];
            layoutOptions.hasZ = true;
        } else {
            flatCoordinates.push(0);
        }
        if ('time' in values) {
            flatCoordinates.push(/** @type {number} */(values['time']));
            delete values['time'];
            layoutOptions.hasM = true;
        } else {
            flatCoordinates.push(0);
        }
        return flatCoordinates;
    }


    /**
     * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates
     * and ends arrays by shrinking them accordingly (removing unused zero entries).
     *
     * @param {LayoutOptions} layoutOptions Layout options.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {Array<number>=} ends Ends.
     * @return {ol.geom.GeometryLayout} Layout.
     */
    function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
        let layout = ol.geom.GeometryLayout.XY;
        let stride = 2;
        if (layoutOptions.hasZ && layoutOptions.hasM) {
            layout = ol.geom.GeometryLayout.XYZM;
            stride = 4;
        } else if (layoutOptions.hasZ) {
            layout = ol.geom.GeometryLayout.XYZ;
            stride = 3;
        } else if (layoutOptions.hasM) {
            layout = ol.geom.GeometryLayout.XYM;
            stride = 3;
        }
        if (stride !== 4) {
            for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
                flatCoordinates[i * stride] = flatCoordinates[i * 4];
                flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
                if (layoutOptions.hasZ) {
                    flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
                }
                if (layoutOptions.hasM) {
                    flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
                }
            }
            flatCoordinates.length = flatCoordinates.length / 4 * stride;
            if (ends) {
                for (let i = 0, ii = ends.length; i < ii; i++) {
                    ends[i] = ends[i] / 4 * stride;
                }
            }
        }
        return layout;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseLink(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const href = node.getAttribute('href');
        if (href !== null) {
            values['link'] = href;
        }
        ol.xml.parseNode(LINK_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseExtensions(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        values['extensionsNode_'] = node;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseRtePt(node, objectStack) {
        const values = ol.xml.pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
        if (values) {
            const rteValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            const flatCoordinates = /** @type {Array<number>} */ (rteValues['flatCoordinates']);
            const layoutOptions = /** @type {LayoutOptions} */ (rteValues['layoutOptions']);
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseTrkPt(node, objectStack) {
        const values = ol.xml.pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
        if (values) {
            const trkValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            const flatCoordinates = /** @type {Array<number>} */ (trkValues['flatCoordinates']);
            const layoutOptions = /** @type {LayoutOptions} */ (trkValues['layoutOptions']);
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function parseTrkSeg(node, objectStack) {
        const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        ol.xml.parseNode(TRKSEG_PARSERS, node, objectStack);
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        const ends = /** @type {Array<number>} */ (values['ends']);
        ends.push(flatCoordinates.length);
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Track.
     */
    function readRte(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({
            'flatCoordinates': [],
            'layoutOptions': {}
        }, RTE_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        delete values['flatCoordinates'];
        const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
        delete values['layoutOptions'];
        const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
        const geometry = new ol.geom.LineString(flatCoordinates, layout);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Track.
     */
    function readTrk(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({
            'flatCoordinates': [],
            'ends': [],
            'layoutOptions': {}
        }, TRK_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const flatCoordinates = /** @type {Array<number>} */
            (values['flatCoordinates']);
        delete values['flatCoordinates'];
        const ends = /** @type {Array<number>} */ (values['ends']);
        delete values['ends'];
        const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
        delete values['layoutOptions'];
        const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
        const geometry = new ol.geom.MultiLineString(flatCoordinates, layout, ends);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.Feature|undefined} Waypoint.
     */
    function readWpt(node, objectStack) {
        const options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        const values = ol.xml.pushParseAndPop({}, WPT_PARSERS, node, objectStack);
        if (!values) {
            return undefined;
        }
        const layoutOptions = /** @type {LayoutOptions} */ ({});
        const coordinates = appendCoordinate([], layoutOptions, node, values);
        const layout = applyLayoutOptions(layoutOptions, coordinates);
        const geometry = new ol.geom.Point(coordinates, layout);
        ol.format.Feature.transformWithOptions(geometry, false, options);
        const feature = new ol.Feature(geometry);
        feature.setProperties(values, true);
        return feature;
    }


    /**
     * @param {Element} node Node.
     * @param {string} value Value for the link's `href` attribute.
     * @param {Array<*>} objectStack Node stack.
     */
    function writeLink(node, value, objectStack) {
        node.setAttribute('href', value);
        const context = objectStack[objectStack.length - 1];
        const properties = context['properties'];
        const link = [
            properties['linkText'],
            properties['linkType']
        ];
        ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */({ node: node }),
            LINK_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            link, objectStack, LINK_SEQUENCE);
    }


    /**
     * @param {Element} node Node.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeWptType(node, coordinate, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const namespaceURI = parentNode.namespaceURI;
        const properties = context['properties'];
        //FIXME Projection handling
        node.setAttributeNS(null, 'lat', String(coordinate[1]));
        node.setAttributeNS(null, 'lon', String(coordinate[0]));
        const geometryLayout = context['geometryLayout'];
        switch (geometryLayout) {
            case ol.geom.GeometryLayout.XYZM:
                if (coordinate[3] !== 0) {
                    properties['time'] = coordinate[3];
                }
            // fall through
            case ol.geom.GeometryLayout.XYZ:
                if (coordinate[2] !== 0) {
                    properties['ele'] = coordinate[2];
                }
                break;
            case ol.geom.GeometryLayout.XYM:
                if (coordinate[2] !== 0) {
                    properties['time'] = coordinate[2];
                }
                break;
            default:
            // pass
        }
        const orderedKeys = (node.nodeName == 'rtept') ?
            RTEPT_TYPE_SEQUENCE[namespaceURI] :
            WPT_TYPE_SEQUENCE[namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(/** @type {import("../xml.js").NodeStackItem} */
            ({ node: node, 'properties': properties }),
            WPT_TYPE_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeRte(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const properties = feature.getProperties();
        const context = { node: node };
        context['properties'] = properties;
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.LINE_STRING) {
            const lineString = /** @type {ol.geom.LineString} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            context['geometryLayout'] = lineString.getLayout();
            properties['rtept'] = lineString.getCoordinates();
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            RTE_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeTrk(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const properties = feature.getProperties();
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        context['properties'] = properties;
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.MULTI_LINE_STRING) {
            const multiLineString = /** @type {ol.geom.MultiLineString} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            properties['trkseg'] = multiLineString.getLineStrings();
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            TRK_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
    }


    /**
     * @param {Node} node Node.
     * @param {ol.geom.LineString} lineString LineString.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeTrkSeg(node, lineString, objectStack) {
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        context['geometryLayout'] = lineString.getLayout();
        context['properties'] = {};
        ol.xml.pushSerializeAndPop(context,
            TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY,
            lineString.getCoordinates(), objectStack);
    }


    /**
     * @param {Element} node Node.
     * @param {ol.Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeWpt(node, feature, objectStack) {
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        const context = objectStack[objectStack.length - 1];
        context['properties'] = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry.getType() == ol.geom.GeometryType.POINT) {
            const point = /** @type {ol.geom.Point} */ (ol.format.Feature.transformWithOptions(geometry, true, options));
            context['geometryLayout'] = point.getLayout();
            writeWptType(node, point.getCoordinates(), objectStack);
        }
    }

    ol.format.GPXCustom = GPXCustom;

})();

/**
 * @typedef {Object} Vec2
 * @property {number} x
 * @property {ol.style.IconAnchorUnits} xunits
 * @property {number} y
 * @property {ol.style.IconAnchorUnits} yunits
 * @property {ol.style.IconOrigin} origin
 */

/**
 * @typedef {Object} GxTrackObject
 * @property {Array<number>} flatCoordinates
 * @property {Array<number>} whens
 */

(function () {

    /**
     * @const
     * @type {Array<string>}
     */
    const GX_NAMESPACE_URIS = [
        'http://www.google.com/kml/ext/2.2'
    ];


    /**
     * @const
     * @type {Array<null|string>}
     */
    let NAMESPACE_URIS = [
        null,
        'http://earth.google.com/kml/2.0',
        'http://earth.google.com/kml/2.1',
        'http://earth.google.com/kml/2.2',
        'http://www.opengis.net/kml/2.2'
    ];

    // GLS: Obtenemos las combinaciones posibles
    const getAllCombinations = function (array) {
        var combi = [];
        var temp = [];

        var len = Math.pow(2, array.length);

        for (var i = 0; i < len; i++) {
            temp = [];
            for (var j = 0; j < array.length; j++) {
                if ((i & Math.pow(2, j))) {
                    if (temp.indexOf(array[j]) == -1)
                        temp.push(array[j]);
                }
            }
            if (temp.length > 0) {
                if (combi.indexOf(temp.join(' ')) == -1)
                    combi.push(temp.join(' '));
            }
        }

        return combi;
    }

    // GLS: Limpiamos de los nuevos los URIS ya disponibles en el formato
    const cleanCombinationsByFormat = function (customURIS, formatURIS) {
        if (customURIS && customURIS.length > 0) {
            for (var i = 0; i < formatURIS.length; i++) {
                var index = customURIS.indexOf(formatURIS[i]);
                if (index > -1)
                    customURIS.splice(index, 1);
            }
        }
    };

    // GLS: Obtenemos los nuevos URIS para KML
    const CUSTOM_NAMESPACE_URIS = getAllCombinations(NAMESPACE_URIS.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(CUSTOM_NAMESPACE_URIS, NAMESPACE_URIS);
    NAMESPACE_URIS = NAMESPACE_URIS.concat(CUSTOM_NAMESPACE_URIS);

    /**
     * @type {Object<string, ol.style.IconAnchorUnits>}
     */
    const ICON_ANCHOR_UNITS_MAP = {
        'fraction': ol.style.IconAnchorUnits.FRACTION,
        'pixels': ol.style.IconAnchorUnits.PIXELS,
        'insetPixels': ol.style.IconAnchorUnits.PIXELS
    };

    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const PLACEMARK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ExtendedData': extendedDataParser,
            'Region': regionParser,
            'MultiGeometry': ol.xml.makeObjectPropertySetter(
                readMultiGeometry, 'geometry'),
            'LineString': ol.xml.makeObjectPropertySetter(
                readLineString, 'geometry'),
            'LinearRing': ol.xml.makeObjectPropertySetter(
                readLinearRing, 'geometry'),
            'Point': ol.xml.makeObjectPropertySetter(
                readPoint, 'geometry'),
            'Polygon': ol.xml.makeObjectPropertySetter(
                readPolygon, 'geometry'),
            'Style': ol.xml.makeObjectPropertySetter(readStyle),
            'StyleMap': placemarkStyleMapParser,
            'address': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'description': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'name': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'open': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'phoneNumber': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'styleUrl': ol.xml.makeObjectPropertySetter(readURI),
            'visibility': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'MultiTrack': ol.xml.makeObjectPropertySetter(
                    readGxMultiTrack, 'geometry'),
                'Track': ol.xml.makeObjectPropertySetter(
                    readGxTrack, 'geometry')
            }
        ));


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeObjectPropertySetter(readURI)
        });


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const REGION_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LatLonAltBox': latLonAltBoxParser,
            'Lod': lodParser
        });


    /**
     * @type {import("../color.js").Color}
     */
    let DEFAULT_COLOR;

    /**
     * @type {ol.style.Fill}
     */
    let DEFAULT_FILL_STYLE = null;

    /**
     * Get the default fill style (or null if not yet set).
     * @return {ol.style.Fill} The default fill style.
     */
    function getDefaultFillStyle() {
        return DEFAULT_FILL_STYLE;
    }

    /**
     * @type {import("../size.js").Size}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR;

    /**
     * @type {ol.style.IconAnchorUnits}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;

    /**
     * @type {ol.style.IconAnchorUnits}
     */
    let DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;

    /**
     * @type {import("../size.js").Size}
     */
    let DEFAULT_IMAGE_STYLE_SIZE;

    /**
     * @type {string}
     */
    let DEFAULT_IMAGE_STYLE_SRC;

    /**
     * @type {number}
     */
    let DEFAULT_IMAGE_SCALE_MULTIPLIER;

    /**
     * @type {import("../style/Image.js").default}
     */
    let DEFAULT_IMAGE_STYLE = null;

    /**
     * Get the default image style (or null if not yet set).
     * @return {import("../style/Image.js").default} The default image style.
     */
    function getDefaultImageStyle() {
        return DEFAULT_IMAGE_STYLE;
    }

    /**
     * @type {string}
     */
    let DEFAULT_NO_IMAGE_STYLE;

    /**
     * @type {ol.style.Stroke}
     */
    let DEFAULT_STROKE_STYLE = null;

    /**
     * Get the default stroke style (or null if not yet set).
     * @return {ol.style.Stroke} The default stroke style.
     */
    function getDefaultStrokeStyle() {
        return DEFAULT_STROKE_STYLE;
    }

    /**
     * @type {ol.style.Stroke}
     */
    let DEFAULT_TEXT_STROKE_STYLE;

    /**
     * @type {ol.style.Text}
     */
    let DEFAULT_TEXT_STYLE = null;

    /**
     * Get the default text style (or null if not yet set).
     * @return {ol.style.Text} The default text style.
     */
    function getDefaultTextStyle() {
        return DEFAULT_TEXT_STYLE;
    }

    /**
     * @type {ol.style.Style}
     */
    let DEFAULT_STYLE = null;

    /**
     * @type {Array<ol.style.Style>}
     */
    let DEFAULT_STYLE_ARRAY = null;

    const getRGBA = function (color, opacity) {
        var result;
        if (color) {
            result = ol.color.asArray(color);
            result = result.slice();
            if (opacity !== undefined) {
                result[3] = opacity;
            }
        }
        else {
            result = [0, 0, 0, 1];
        }
        return result;
    };


    function createStyleDefaults() {
        // Rehacemos los estilos por defecto de KML para que se adecúen al de la API
        DEFAULT_COLOR = [255, 255, 255, 1];

        DEFAULT_FILL_STYLE = new ol.style.Fill({
            color: getRGBA(TC.Cfg.styles.polygon.fillColor, TC.Cfg.styles.polygon.fillOpacity)
        });

        DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2]; // FIXME maybe [8, 32] ?

        DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = ol.style.IconAnchorUnits.PIXELS;

        DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = ol.style.IconAnchorUnits.PIXELS;

        DEFAULT_IMAGE_STYLE_SIZE = [64, 64];

        DEFAULT_IMAGE_STYLE_SRC =
            'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';

        DEFAULT_IMAGE_SCALE_MULTIPLIER = 0.5;

        DEFAULT_IMAGE_STYLE = new ol.style.Icon({
            anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
            anchorOrigin: ol.style.IconOrigin.BOTTOM_LEFT,
            anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
            anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
            crossOrigin: 'anonymous',
            rotation: 0,
            scale: DEFAULT_IMAGE_SCALE_MULTIPLIER,
            size: DEFAULT_IMAGE_STYLE_SIZE,
            src: DEFAULT_IMAGE_STYLE_SRC
        });

        DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';

        DEFAULT_STROKE_STYLE = new ol.style.Stroke({
            color: getRGBA(TC.Cfg.styles.line.strokeColor, 1),
            width: TC.Cfg.styles.line.strokeWidth || 1
        });

        DEFAULT_TEXT_STROKE_STYLE = new ol.style.Stroke({
            color: [51, 51, 51, 1],
            width: 2
        });

        DEFAULT_TEXT_STYLE = new ol.style.Text({
            font: 'bold 16px Helvetica',
            fill: DEFAULT_FILL_STYLE,
            stroke: DEFAULT_TEXT_STROKE_STYLE,
            scale: 0.8
        });

        DEFAULT_STYLE = new ol.style.Style({
            fill: DEFAULT_FILL_STYLE,
            image: DEFAULT_IMAGE_STYLE,
            text: DEFAULT_TEXT_STYLE,
            stroke: DEFAULT_STROKE_STYLE,
            zIndex: 0
        });

        DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];

    }

    const namespaceURISmanage = function (source, format) {
        const xml = ol.xml.parse(source);
        const tags = xml.getElementsByTagName(format.toLowerCase());
        if (tags && tags.length > 0) {
            var value = tags[0].getAttribute('xmlns');
            if (value && value.indexOf(' ') > -1 && NAMESPACE_URIS.indexOf(value) > -1) {
                const values = value.split(' ');
                const namespaces = [];
                for (var i = 0; i < values.length; i++) {
                    namespaces.push(('xmlns:' + format.toLowerCase() + i) + "=\"" + values[i].trim() + "\"");
                }
            }
        }

        return source;
    };

    /**
     * @typedef {Object} Options
     * @property {boolean} [extractStyles=true] Extract styles from the KML.
     * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
     * @property {Array<ol.style.Style>} [defaultStyle] Default style. The
     * default default style is the same as Google Earth.
     * @property {boolean} [writeStyles=true] Write styles into KML.
     */


    class KMLCustom extends ol.format.KML {

        /**
         * @param {Options=} opt_options Options.
         */
        constructor(opt_options) {

            super(opt_options);

            const options = opt_options ? opt_options : {};


            if (!DEFAULT_STYLE_ARRAY) {
                createStyleDefaults();
            }

            this.defaultStyle_ = options.defaultStyle ?
                options.defaultStyle : DEFAULT_STYLE_ARRAY;
        }

        readFeatures(source, opt_options) {
            if (typeof source === 'string') {
                const kmlTag = '<kml';
                let startIdx = source.indexOf(kmlTag);
                if (startIdx >= 0) {
                    startIdx += kmlTag.length;
                    if (source.indexOf('xmlns:xsi=') < 0) {
                        source = source.substr(0, startIdx) + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' + source.substr(startIdx);
                    }

                    source = namespaceURISmanage(source, 'KML');
                }
            }
            return ol.format.KML.prototype.readFeatures.call(this, source, opt_options);
        }

        readDocumentOrFolder_(node, objectStack) {
            // FIXME use scope somehow
            const parsersNS = ol.xml.makeStructureNS(
                NAMESPACE_URIS, {
                    'Document': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),
                    'Folder': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),
                    'Placemark': ol.xml.makeArrayPusher(this.readPlacemark_, this),
                    'Style': this.readSharedStyle_.bind(this),
                    'StyleMap': this.readSharedStyleMap_.bind(this)
                });
            /** @type {Array<Feature>} */
            const features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack, this);
            if (features) {
                // Reescritura de código para leer las carpetas del KML
                if (node.localName == 'Folder') {
                    for (let i = 0, ii = features.length; i < ii; i++) {
                        const feature = features[i];
                        if (!Array.isArray(feature._folders)) {
                            feature._folders = [];
                        }
                        var nameElm = node.getElementsByTagName('name')[0];
                        if (nameElm) {
                            //feature._folders.unshift(nameElm.innerHTML || nameElm.textContent);
                            // Versión rápida de unshift
                            TC.Util.fastUnshift(feature._folders, nameElm.innerHTML || nameElm.textContent);
                        }
                    }
                }
                ///////////////////////////////////////////////////////
                return features;
            } else {
                return undefined;
            }
        }

        readPlacemark_(node, objectStack) {
            const object = ol.xml.pushParseAndPop({ 'geometry': null },
                PLACEMARK_PARSERS, node, objectStack);
            if (!object) {
                return undefined;
            }
            const feature = new ol.Feature();
            const id = node.getAttribute('id');
            if (id !== null) {
                feature.setId(id);
            }
            const options = objectStack[0];

            const geometry = object['geometry'];
            if (geometry) {
                ol.format.Feature.transformWithOptions(geometry, false, options);
            }
            feature.setGeometry(geometry);
            delete object['geometry'];

            if (this.extractStyles_) {
                let style = object['Style'];
                let styleUrl = object['styleUrl'];
                const styleFunction = createFeatureStyleFunction(
                    style, styleUrl, this.defaultStyle_, this.sharedStyles_,
                    this.showPointNames_);
                feature.setStyle(styleFunction);
            }
            delete object['Style'];
            // we do not remove the styleUrl property from the object, so it
            // gets stored on feature when setProperties is called

            feature.setProperties(object, true);

            return feature;
        }


        // TODO: completar con los cambios en ol-es.
        readSharedStyle_(node, objectStack) {
            const id = node.getAttribute('id');
            if (id !== null) {
                const style = readStyle(node, objectStack);
                if (style) {
                    let styleUri;
                    let baseURI = node.baseURI;
                    if (!baseURI || baseURI == 'about:blank') {
                        baseURI = window.location.href;
                    }
                    if (baseURI) {
                        const url = new URL('#' + id, baseURI);
                        styleUri = url.href;
                    } else {
                        styleUri = '#' + id;
                    }
                    this.sharedStyles_[styleUri] = style;
                }
            }
        }

        /**
         * @inheritDoc
         */
        readFeatureFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return null;
            }
            const feature = this.readPlacemark_(
                node, [this.getReadOptions(node, opt_options)]);
            if (feature) {
                return feature;
            } else {
                return null;
            }
        }

        /**
         * @inheritDoc
         */
        readFeaturesFromNode(node, opt_options) {
            if (!ol.array.includes(NAMESPACE_URIS, node.namespaceURI)) {
                return [];
            }
            let features;
            const localName = node.localName;
            if (localName == 'Document' || localName == 'Folder') {
                features = this.readDocumentOrFolder_(
                    node, [this.getReadOptions(node, opt_options)]);
                if (features) {
                    return features;
                } else {
                    return [];
                }
            } else if (localName == 'Placemark') {
                const feature = this.readPlacemark_(
                    node, [this.getReadOptions(node, opt_options)]);
                if (feature) {
                    return [feature];
                } else {
                    return [];
                }
            } else if (localName == 'kml') {
                features = [];
                for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
                    const fs = this.readFeaturesFromNode(n, opt_options);
                    if (fs) {
                        ol.array.extend(features, fs);
                    }
                }
                return features;
            } else {
                return [];
            }
        }
    };

    /**
     * @param {ol.style.Style|undefined} foundStyle Style.
     * @param {string} name Name.
     * @return {ol.style.Style} style Style.
     */
    function createNameStyleFunction(foundStyle, name) {
        let textStyle = null;
        const textOffset = [0, 0];
        let textAlign = 'start';
        if (foundStyle.getImage()) {
            let imageSize = foundStyle.getImage().getImageSize();
            if (imageSize === null) {
                imageSize = DEFAULT_IMAGE_STYLE_SIZE;
            }
            if (imageSize.length == 2) {
                const imageScale = foundStyle.getImage().getScale();
                // Offset the label to be centered to the right of the icon, if there is
                // one.
                textOffset[0] = imageScale * imageSize[0] / 2;
                textOffset[1] = -imageScale * imageSize[1] / 2;
                textAlign = 'left';
            }
        }
        if (foundStyle.getText() !== null) {
            // clone the text style, customizing it with name, alignments and offset.
            // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
            const foundText = foundStyle.getText();
            textStyle = foundText.clone();
            textStyle.setFont(foundText.getFont() || DEFAULT_TEXT_STYLE.getFont());
            textStyle.setScale(foundText.getScale() || DEFAULT_TEXT_STYLE.getScale());
            textStyle.setFill(foundText.getFill() || DEFAULT_TEXT_STYLE.getFill());
            textStyle.setStroke(foundText.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
        } else {
            textStyle = DEFAULT_TEXT_STYLE.clone();
        }
        textStyle.setText(name);
        textStyle.setOffsetX(textOffset[0]);
        textStyle.setOffsetY(textOffset[1]);
        textStyle.setTextAlign(textAlign);

        const nameStyle = new ol.style.Style({
            text: textStyle
        });
        return nameStyle;
    }


    /**
     * @param {Array<ol.style.Style>|undefined} style Style.
     * @param {string} styleUrl Style URL.
     * @param {Array<ol.style.Style>} defaultStyle Default style.
     * @param {!Object<string, (Array<ol.style.Style>|string)>} sharedStyles Shared styles.
     * @param {boolean|undefined} showPointNames true to show names for point placemarks.
     * @return {import("../style/Style.js").StyleFunction} Feature style function.
     */
    function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {

        return (
            /**
             * @param {Feature} feature feature.
             * @param {number} resolution Resolution.
             * @return {Array<ol.style.Style>} Style.
             */
            function (feature, resolution) {
                let drawName = showPointNames;
                /** @type {ol.style.Style|undefined} */
                let nameStyle;
                let name = '';
                if (drawName) {
                    const geometry = feature.getGeometry();
                    if (geometry) {
                        drawName = geometry.getType() === ol.geom.GeometryType.POINT;
                    }
                }

                if (drawName) {
                    name = /** @type {string} */ (feature.get('name'));
                    drawName = drawName && !!name;
                }

                if (style) {
                    if (drawName) {
                        nameStyle = createNameStyleFunction(style[0], name);
                        return style.concat(nameStyle);
                    }
                    return style;
                }
                if (styleUrl) {
                    const foundStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
                    if (drawName) {
                        nameStyle = createNameStyleFunction(foundStyle[0], name);
                        return foundStyle.concat(nameStyle);
                    }
                    return foundStyle;
                }
                if (drawName) {
                    nameStyle = createNameStyleFunction(defaultStyle[0], name);
                    return defaultStyle.concat(nameStyle);
                }
                return defaultStyle;
            }
        );
    }


    /**
     * @param {Array<ol.style.Style>|string|undefined} styleValue Style value.
     * @param {Array<ol.style.Style>} defaultStyle Default style.
     * @param {!Object<string, (Array<ol.style.Style>|string)>} sharedStyles
     * Shared styles.
     * @return {Array<ol.style.Style>} Style.
     */
    function findStyle(styleValue, defaultStyle, sharedStyles) {
        if (Array.isArray(styleValue)) {
            return styleValue;
        } else if (typeof styleValue === 'string') {
            // KML files in the wild occasionally forget the leading `#` on styleUrls
            // defined in the same document.  Add a leading `#` if it enables to find
            // a style.
            if (!(styleValue in sharedStyles) && ('#' + styleValue in sharedStyles)) {
                styleValue = '#' + styleValue;
            }
            return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
        } else {
            return defaultStyle;
        }
    }


    /**
     * @param {Node} node Node.
     * @return {import("../color.js").Color|undefined} Color.
     */
    function readColor(node) {
        const s = ol.xml.getAllTextContent(node, false);
        // The KML specification states that colors should not include a leading `#`
        // but we tolerate them.
        const m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
        if (m) {
            const hexColor = m[1];
            return [
                parseInt(hexColor.substr(6, 2), 16),
                parseInt(hexColor.substr(4, 2), 16),
                parseInt(hexColor.substr(2, 2), 16),
                parseInt(hexColor.substr(0, 2), 16) / 255
            ];

        } else {
            return undefined;
        }
    }


    /**
     * @param {Node} node Node.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    function readFlatCoordinates(node) {
        let s = ol.xml.getAllTextContent(node, false);
        const flatCoordinates = [];
        // The KML specification states that coordinate tuples should not include
        // spaces, but we tolerate them.
        const re =
            /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;
        let m;
        while ((m = re.exec(s))) {
            const x = parseFloat(m[1]);
            const y = parseFloat(m[2]);
            const z = m[3] ? parseFloat(m[3]) : 0;
            flatCoordinates.push(x, y, z);
            s = s.substr(m[0].length);
        }
        if (s !== '') {
            return undefined;
        }
        return flatCoordinates;
    }


    /**
     * @param {Node} node Node.
     * @return {string} URI.
     */
    function readURI(node) {
        const s = ol.xml.getAllTextContent(node, false).trim();
        let baseURI = node.baseURI;
        if (!baseURI || baseURI == 'about:blank') {
            baseURI = window.location.href;
        }

        if (baseURI) {
            // flacunza: Parche para evitar peticiones HTTP desde una página HTTPS
            if (location.protocol === 'https:' && baseURI.indexOf('http://') === 0) {
                baseURI = baseURI.substr(5);
            }
            const url = new URL(s, baseURI);
            return url.href;
        } else {
            return s;
        }
    }


    /**
     * @param {Element} node Node.
     * @return {Vec2} Vec2.
     */
    function readVec2(node) {
        const xunits = node.getAttribute('xunits');
        const yunits = node.getAttribute('yunits');
        let origin;
        if (xunits !== 'insetPixels') {
            if (yunits !== 'insetPixels') {
                origin = ol.style.IconOrigin.BOTTOM_LEFT;
            } else {
                origin = ol.style.IconOrigin.TOP_LEFT;
            }
        } else {
            if (yunits !== 'insetPixels') {
                origin = ol.style.IconOrigin.BOTTOM_RIGHT;
            } else {
                origin = ol.style.IconOrigin.TOP_RIGHT;
            }
        }
        return {
            x: parseFloat(node.getAttribute('x')),
            xunits: ICON_ANCHOR_UNITS_MAP[xunits],
            y: parseFloat(node.getAttribute('y')),
            yunits: ICON_ANCHOR_UNITS_MAP[yunits],
            origin: origin
        };
    }


    /**
     * @param {Node} node Node.
     * @return {number|undefined} Scale.
     */
    function readScale(node) {
        return ol.format.xsd.readDecimal(node);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const STYLE_MAP_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Pair': pairDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<ol.style.Style>|string|undefined} StyleMap.
     */
    function readStyleMapValue(node, objectStack) {
        return ol.xml.pushParseAndPop(undefined,
            STYLE_MAP_PARSERS, node, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const ICON_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Icon': ol.xml.makeObjectPropertySetter(readIcon),
            'heading': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'hotSpot': ol.xml.makeObjectPropertySetter(readVec2),
            'scale': ol.xml.makeObjectPropertySetter(readScale)
        });

    // Creamos un parser para interpretar la plantilla de los bocadillos
    const readText = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'text');
        var s = ol.format.xsd.readString(node);
        return s.trim();
    };

    const balloonStyleParser = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'BalloonStyle');
        // FIXME colorMode
        var object = ol.xml.pushParseAndPop(
            {}, BALLOON_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const type = typeof styleObject;
        ol.asserts.assert(type == 'object' && styleObject != null || type == 'function');
        var textStyle = new ol.style.Text({
            text: (object['text'])
        });
        styleObject['balloonStyle'] = textStyle;
    };

    const BALLOON_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'text': ol.xml.makeObjectPropertySetter(readText),
        });

    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function iconStyleParser(node, objectStack) {
        // FIXME refreshMode
        // FIXME refreshInterval
        // FIXME viewRefreshTime
        // FIXME viewBoundScale
        // FIXME viewFormat
        // FIXME httpQuery
        const object = ol.xml.pushParseAndPop(
            {}, ICON_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const IconObject = 'Icon' in object ? object['Icon'] : {};
        const drawIcon = (!('Icon' in object) || Object.keys(IconObject).length > 0);
        let src;
        const href = /** @type {string|undefined} */
            (IconObject['href']);
        if (href) {
            src = href;
        } else if (drawIcon) {
            src = DEFAULT_IMAGE_STYLE_SRC;
        }
        let anchor, anchorXUnits, anchorYUnits;
        let anchorOrigin = ol.style.IconOrigin.BOTTOM_LEFT;
        const hotSpot = /** @type {Vec2|undefined} */
            (object['hotSpot']);
        if (hotSpot) {
            anchor = [hotSpot.x, hotSpot.y];
            anchorXUnits = hotSpot.xunits;
            anchorYUnits = hotSpot.yunits;
            anchorOrigin = hotSpot.origin;
        } else if (src === DEFAULT_IMAGE_STYLE_SRC) {
            anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
            anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
            anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
            anchor = [0.5, 0];
            anchorXUnits = ol.style.IconAnchorUnits.FRACTION;
            anchorYUnits = ol.style.IconAnchorUnits.FRACTION;
        }

        let offset;
        const x = /** @type {number|undefined} */
            (IconObject['x']);
        const y = /** @type {number|undefined} */
            (IconObject['y']);
        if (x !== undefined && y !== undefined) {
            offset = [x, y];
        }

        let size;
        const w = /** @type {number|undefined} */
            (IconObject['w']);
        const h = /** @type {number|undefined} */
            (IconObject['h']);
        if (w !== undefined && h !== undefined) {
            size = [w, h];
        }

        let rotation;
        const heading = /** @type {number} */
            (object['heading']);
        if (heading !== undefined) {
            rotation = ol.math.toRadians(heading);
        }

        let scale = /** @type {number|undefined} */
            (object['scale']);

        if (drawIcon) {
            if (src == DEFAULT_IMAGE_STYLE_SRC) {
                size = DEFAULT_IMAGE_STYLE_SIZE;
                if (scale === undefined) {
                    scale = DEFAULT_IMAGE_SCALE_MULTIPLIER;
                }
            }

            const imageStyle = new ol.style.Icon({
                anchor: anchor,
                anchorOrigin: anchorOrigin,
                anchorXUnits: anchorXUnits,
                anchorYUnits: anchorYUnits,
                crossOrigin: 'anonymous', // FIXME should this be configurable?
                offset: offset,
                offsetOrigin: ol.style.IconOrigin.BOTTOM_LEFT,
                rotation: rotation,
                scale: scale,
                size: size,
                src: src
            });
            styleObject['imageStyle'] = imageStyle;
        } else {
            // handle the case when we explicitly want to draw no icon.
            styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LABEL_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'scale': ol.xml.makeObjectPropertySetter(readScale)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function labelStyleParser(node, objectStack) {
        // FIXME colorMode
        const object = ol.xml.pushParseAndPop(
            {}, LABEL_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const textStyle = new ol.style.Text({
            fill: new ol.style.Fill({
                color: /** @type {import("../color.js").Color} */
                    ('color' in object ? object['color'] : DEFAULT_COLOR)
            }),
            scale: /** @type {number|undefined} */
                (object['scale'])
        });
        styleObject['textStyle'] = textStyle;
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LINE_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'width': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function lineStyleParser(node, objectStack) {
        // FIXME colorMode
        // FIXME gx:outerColor
        // FIXME gx:outerWidth
        // FIXME gx:physicalWidth
        // FIXME gx:labelVisibility
        const object = ol.xml.pushParseAndPop(
            {}, LINE_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const strokeStyle = new ol.style.Stroke({
            color: /** @type {import("../color.js").Color} */
                ('color' in object ? object['color'] : DEFAULT_COLOR),
            width: /** @type {number} */ ('width' in object ? object['width'] : 1)
        });
        styleObject['strokeStyle'] = strokeStyle;
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const POLY_STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeObjectPropertySetter(readColor),
            'fill': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'outline': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function polyStyleParser(node, objectStack) {
        // FIXME colorMode
        const object = ol.xml.pushParseAndPop(
            {}, POLY_STYLE_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const styleObject = objectStack[objectStack.length - 1];
        const fillStyle = new ol.style.Fill({
            color: /** @type {import("../color.js").Color} */
                ('color' in object ? object['color'] : DEFAULT_COLOR)
        });
        styleObject['fillStyle'] = fillStyle;
        const fill = /** @type {boolean|undefined} */ (object['fill']);
        if (fill !== undefined) {
            styleObject['fill'] = fill;
        }
        const outline = /** @type {boolean|undefined} */ (object['outline']);
        if (outline !== undefined) {
            styleObject['outline'] = outline;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const FLAT_LINEAR_RING_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'coordinates': ol.xml.makeReplacer(readFlatCoordinates)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} LinearRing flat coordinates.
     */
    function readFlatLinearRing(node, objectStack) {
        return ol.xml.pushParseAndPop(null,
            FLAT_LINEAR_RING_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function gxCoordParser(node, objectStack) {
        const gxTrackObject = /** @type {GxTrackObject} */
            (objectStack[objectStack.length - 1]);
        const flatCoordinates = gxTrackObject.flatCoordinates;
        const s = ol.xml.getAllTextContent(node, false);
        const re =
            /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
        const m = re.exec(s);
        if (m) {
            const x = parseFloat(m[1]);
            const y = parseFloat(m[2]);
            const z = parseFloat(m[3]);
            flatCoordinates.push(x, y, z, 0);
        } else {
            flatCoordinates.push(0, 0, 0, 0);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GX_MULTITRACK_GEOMETRY_PARSERS = ol.xml.makeStructureNS(
        GX_NAMESPACE_URIS, {
            'Track': ol.xml.makeArrayPusher(readGxTrack)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.MultiLineString|undefined} MultiLineString.
     */
    function readGxMultiTrack(node, objectStack) {
        const lineStrings = ol.xml.pushParseAndPop([],
            GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
        if (!lineStrings) {
            return undefined;
        }
        return new ol.geom.MultiLineString(lineStrings);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GX_TRACK_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'when': whenParser
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'coord': gxCoordParser
            }));


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.LineString|undefined} LineString.
     */
    function readGxTrack(node, objectStack) {
        const gxTrackObject = ol.xml.pushParseAndPop(
    /** @type {GxTrackObject} */({
                flatCoordinates: [],
                whens: []
            }), GX_TRACK_PARSERS, node, objectStack);
        if (!gxTrackObject) {
            return undefined;
        }
        const flatCoordinates = gxTrackObject.flatCoordinates;
        const whens = gxTrackObject.whens;
        for (let i = 0, ii = Math.min(flatCoordinates.length, whens.length); i < ii; ++i) {
            flatCoordinates[4 * i + 3] = whens[i];
        }
        return new ol.geom.LineString(flatCoordinates, ol.geom.GeometryLayout.XYZM);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const ICON_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeObjectPropertySetter(readURI)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'x': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'y': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'w': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
                'h': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
            }));


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Object} Icon object.
     */
    function readIcon(node, objectStack) {
        const iconObject = ol.xml.pushParseAndPop(
            {}, ICON_PARSERS, node, objectStack);
        if (iconObject) {
            return iconObject;
        } else {
            return null;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const GEOMETRY_FLAT_COORDINATES_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'coordinates': ol.xml.makeReplacer(readFlatCoordinates)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    function readFlatCoordinatesFromNode(node, objectStack) {
        return ol.xml.pushParseAndPop(null,
            GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const EXTRUDE_AND_ALTITUDE_MODE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'extrude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'tessellate': ol.xml.makeObjectPropertySetter(ol.format.xsd.readBoolean),
            'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.LineString|undefined} LineString.
     */
    function readLineString(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const lineString = new ol.geom.LineString(flatCoordinates, ol.geom.GeometryLayout.XYZ);
            lineString.setProperties(properties, true);
            return lineString;
        } else {
            return undefined;
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Polygon|undefined} Polygon.
     */
    function readLinearRing(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const polygon = new ol.geom.Polygon(flatCoordinates, ol.geom.GeometryLayout.XYZ, [flatCoordinates.length]);
            polygon.setProperties(properties, true);
            return polygon;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const MULTI_GEOMETRY_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LineString': ol.xml.makeArrayPusher(readLineString),
            'LinearRing': ol.xml.makeArrayPusher(readLinearRing),
            'MultiGeometry': ol.xml.makeArrayPusher(readMultiGeometry),
            'Point': ol.xml.makeArrayPusher(readPoint),
            'Polygon': ol.xml.makeArrayPusher(readPolygon)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    function readMultiGeometry(node, objectStack) {
        const geometries = ol.xml.pushParseAndPop([],
            MULTI_GEOMETRY_PARSERS, node, objectStack);
        if (!geometries) {
            return null;
        }
        if (geometries.length === 0) {
            return new ol.geom.GeometryCollection(geometries);
        }
        let multiGeometry;
        let homogeneous = true;
        const type = geometries[0].getType();
        let geometry;
        for (let i = 1, ii = geometries.length; i < ii; ++i) {
            geometry = geometries[i];
            if (geometry.getType() != type) {
                homogeneous = false;
                break;
            }
        }
        if (homogeneous) {
            let layout;
            let flatCoordinates;
            if (type == ol.geom.GeometryType.POINT) {
                const point = geometries[0];
                layout = point.getLayout();
                flatCoordinates = point.getFlatCoordinates();
                for (let i = 1, ii = geometries.length; i < ii; ++i) {
                    geometry = geometries[i];
                    ol.array.extend(flatCoordinates, geometry.getFlatCoordinates());
                }
                multiGeometry = new ol.geom.MultiPoint(flatCoordinates, layout);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.LINE_STRING) {
                multiGeometry = new ol.geom.MultiLineString(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.POLYGON) {
                multiGeometry = new ol.geom.MultiPolygon(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
                multiGeometry = new ol.geom.GeometryCollection(geometries);
            } else {
                assert(false, 37); // Unknown geometry type found
            }
        } else {
            multiGeometry = new ol.geom.GeometryCollection(geometries);
        }
        return (
    /** @type {import("../geom/Geometry.js").default} */ (multiGeometry)
        );
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Point|undefined} Point.
     */
    function readPoint(node, objectStack) {
        const properties = ol.xml.pushParseAndPop({},
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatCoordinates =
            readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const point = new ol.geom.Point(flatCoordinates, ol.geom.GeometryLayout.XYZ);
            point.setProperties(properties, true);
            return point;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const FLAT_LINEAR_RINGS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'innerBoundaryIs': innerBoundaryIsParser,
            'outerBoundaryIs': outerBoundaryIsParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {ol.geom.Polygon|undefined} Polygon.
     */
    function readPolygon(node, objectStack) {
        const properties = ol.xml.pushParseAndPop(/** @type {Object<string,*>} */({}),
            EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node,
            objectStack);
        const flatLinearRings = ol.xml.pushParseAndPop([null],
            FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [flatCoordinates.length];
            for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                ol.array.extend(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            const polygon = new ol.geom.Polygon(flatCoordinates, ol.geom.GeometryLayout.XYZ, ends);
            polygon.setProperties(properties, true);
            return polygon;
        } else {
            return undefined;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const STYLE_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'IconStyle': iconStyleParser,
            'LabelStyle': labelStyleParser,
            'LineStyle': lineStyleParser,
            'PolyStyle': polyStyleParser,
            'BalloonStyle': balloonStyleParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<ol.style.Style>} Style.
     */
    function readStyle(node, objectStack) {
        const styleObject = ol.xml.pushParseAndPop(
            {}, STYLE_PARSERS, node, objectStack);
        if (!styleObject) {
            return null;
        }
        let fillStyle = /** @type {ol.style.Fill} */
            ('fillStyle' in styleObject ?
                styleObject['fillStyle'] : DEFAULT_FILL_STYLE);
        const fill = /** @type {boolean|undefined} */ (styleObject['fill']);
        if (fill !== undefined && !fill) {
            fillStyle = null;
        }
        let imageStyle;
        if ('imageStyle' in styleObject) {
            if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {
                imageStyle = styleObject['imageStyle'];
            }
        } else {
            imageStyle = DEFAULT_IMAGE_STYLE;
        }
        const textStyle = /** @type {ol.style.Text} */
            ('textStyle' in styleObject ?
                styleObject['textStyle'] : DEFAULT_TEXT_STYLE);
        let strokeStyle = /** @type {ol.style.Stroke} */
            ('strokeStyle' in styleObject ?
                styleObject['strokeStyle'] : DEFAULT_STROKE_STYLE);
        // GLS: Comento el machaque del estilo de línea por que no haya outline, según la documentación (https://developers.google.com/kml/documentation/kmlreference#style) 
        // es opcional indicar outline
        // Corregimos el bug 25306 No se carga el estilo de VV-del-Irati.kml
        //const outline = /** @type {boolean|undefined} */
        //    (styleObject['outline']);
        //if (outline !== undefined && !outline) {
        //    strokeStyle = null;
        //}
        const balloonStyle = styleObject['balloonStyle'];
        const returnStyle = new ol.style.Style({
            fill: fillStyle,
            image: imageStyle,
            stroke: strokeStyle,
            text: textStyle,
            zIndex: undefined // FIXME
        });
        if (balloonStyle) {
            returnStyle._balloon = balloonStyle;
        }
        return [returnStyle];
    }


    /**
     * Reads an array of geometries and creates arrays for common geometry
     * properties. Then sets them to the multi geometry.
     * @param {ol.geom.MultiPoint|ol.geom.MultiLineString|ol.geom.MultiPolygon} multiGeometry A multi-geometry.
     * @param {Array<import("../geom/Geometry.js").default>} geometries List of geometries.
     */
    function setCommonGeometryProperties(multiGeometry, geometries) {
        const ii = geometries.length;
        const extrudes = new Array(geometries.length);
        const tessellates = new Array(geometries.length);
        const altitudeModes = new Array(geometries.length);
        let hasExtrude, hasTessellate, hasAltitudeMode;
        hasExtrude = hasTessellate = hasAltitudeMode = false;
        for (let i = 0; i < ii; ++i) {
            const geometry = geometries[i];
            extrudes[i] = geometry.get('extrude');
            tessellates[i] = geometry.get('tessellate');
            altitudeModes[i] = geometry.get('altitudeMode');
            hasExtrude = hasExtrude || extrudes[i] !== undefined;
            hasTessellate = hasTessellate || tessellates[i] !== undefined;
            hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
        }
        if (hasExtrude) {
            multiGeometry.set('extrude', extrudes);
        }
        if (hasTessellate) {
            multiGeometry.set('tessellate', tessellates);
        }
        if (hasAltitudeMode) {
            multiGeometry.set('altitudeMode', altitudeModes);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'displayName': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'value': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function dataParser(node, objectStack) {
        const name = node.getAttribute('name');
        ol.xml.parseNode(DATA_PARSERS, node, objectStack);
        const featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        if (name !== null) {
            featureObject[name] = featureObject.value;
        } else if (featureObject.displayName !== null) {
            featureObject[featureObject.displayName] = featureObject.value;
        }
        delete featureObject['value'];
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const EXTENDED_DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Data': dataParser,
            'SchemaData': schemaDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function extendedDataParser(node, objectStack) {
        ol.xml.parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
    }

    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function regionParser(node, objectStack) {
        ol.xml.parseNode(REGION_PARSERS, node, objectStack);
    }

    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const PAIR_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Style': ol.xml.makeObjectPropertySetter(readStyle),
            'key': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'styleUrl': ol.xml.makeObjectPropertySetter(readURI)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function pairDataParser(node, objectStack) {
        const pairObject = ol.xml.pushParseAndPop(
            {}, PAIR_PARSERS, node, objectStack);
        if (!pairObject) {
            return;
        }
        const key = /** @type {string|undefined} */
            (pairObject['key']);
        if (key && key == 'normal') {
            const styleUrl = /** @type {string|undefined} */
                (pairObject['styleUrl']);
            if (styleUrl) {
                objectStack[objectStack.length - 1] = styleUrl;
            }
            const style = /** @type {ol.style.Style} */
                (pairObject['Style']);
            if (style) {
                objectStack[objectStack.length - 1] = style;
            }
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function placemarkStyleMapParser(node, objectStack) {
        const styleMapValue = readStyleMapValue(node, objectStack);
        if (!styleMapValue) {
            return;
        }
        const placemarkObject = objectStack[objectStack.length - 1];
        if (Array.isArray(styleMapValue)) {
            placemarkObject['Style'] = styleMapValue;
        } else if (typeof styleMapValue === 'string') {
            placemarkObject['styleUrl'] = styleMapValue;
        } else {
            assert(false, 38); // `styleMapValue` has an unknown type
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const SCHEMA_DATA_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'SimpleData': simpleDataParser
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function schemaDataParser(node, objectStack) {
        ol.xml.parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function simpleDataParser(node, objectStack) {
        const name = node.getAttribute('name');
        if (name !== null) {
            const data = ol.format.xsd.readString(node);
            const featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
            featureObject[name] = data;
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LAT_LON_ALT_BOX_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.xsd.readString),
            'minAltitude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxAltitude': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'north': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'south': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'east': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'west': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function latLonAltBoxParser(node, objectStack) {
        const object = ol.xml.pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const regionObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        const extent = [
            parseFloat(object['west']),
            parseFloat(object['south']),
            parseFloat(object['east']),
            parseFloat(object['north'])
        ];
        regionObject['extent'] = extent;
        regionObject['altitudeMode'] = object['altitudeMode'];
        regionObject['minAltitude'] = parseFloat(object['minAltitude']);
        regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const LOD_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'minLodPixels': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxLodPixels': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'minFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal),
            'maxFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.xsd.readDecimal)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function lodParser(node, objectStack) {
        const object = ol.xml.pushParseAndPop({}, LOD_PARSERS, node, objectStack);
        if (!object) {
            return;
        }
        const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
        lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
        lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
        lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const INNER_BOUNDARY_IS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeReplacer(readFlatLinearRing)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function innerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */
        const flatLinearRing = ol.xml.pushParseAndPop(undefined,
            INNER_BOUNDARY_IS_PARSERS, node, objectStack);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */
                (objectStack[objectStack.length - 1]);
            flatLinearRings.push(flatLinearRing);
        }
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    const OUTER_BOUNDARY_IS_PARSERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeReplacer(readFlatLinearRing)
        });


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function outerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */
        const flatLinearRing = ol.xml.pushParseAndPop(undefined,
            OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */
                (objectStack[objectStack.length - 1]);
            flatLinearRings[0] = flatLinearRing;
        }
    }


    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function linkParser(node, objectStack) {
        ol.xml.parseNode(LINK_PARSERS, node, objectStack);
    }


    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function whenParser(node, objectStack) {
        const gxTrackObject = /** @type {GxTrackObject} */
            (objectStack[objectStack.length - 1]);
        const whens = gxTrackObject.whens;
        const s = ol.xml.getAllTextContent(node, false);
        const when = Date.parse(s);
        whens.push(isNaN(when) ? 0 : when);
    }


    /**
     * @param {Node} node Node to append a TextNode with the color to.
     * @param {import("../color.js").Color|string} color Color.
     */
    function writeColorTextNode(node, color) {
        const rgba = asArray(color);
        const opacity = (rgba.length == 4) ? rgba[3] : 1;
        /** @type {Array<string|number>} */
        const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
        for (let i = 0; i < 4; ++i) {
            const hex = Math.floor(/** @type {number} */(abgr[i])).toString(16);
            abgr[i] = (hex.length == 1) ? '0' + hex : hex;
        }
        ol.format.xsd.writeStringTextNode(node, abgr.join(''));
    }


    /**
     * @param {Node} node Node to append a TextNode with the coordinates to.
     * @param {Array<number>} coordinates Coordinates.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeCoordinatesTextNode(node, coordinates, objectStack) {
        const context = objectStack[objectStack.length - 1];

        const layout = context['layout'];
        const stride = context['stride'];

        let dimension;
        if (layout == ol.geom.GeometryLayout.XY ||
            layout == ol.geom.GeometryLayout.XYM) {
            dimension = 2;
        } else if (layout == ol.geom.GeometryLayout.XYZ ||
            layout == ol.geom.GeometryLayout.XYZM) {
            dimension = 3;
        } else {
            assert(false, 34); // Invalid geometry layout
        }

        const ii = coordinates.length;
        let text = '';
        if (ii > 0) {
            text += coordinates[0];
            for (let d = 1; d < dimension; ++d) {
                text += ',' + coordinates[d];
            }
            for (let i = stride; i < ii; i += stride) {
                text += ' ' + coordinates[i];
                for (let d = 1; d < dimension; ++d) {
                    text += ',' + coordinates[i + d];
                }
            }
        }
        ol.format.xsd.writeStringTextNode(node, text);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const EXTENDEDDATA_NODE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Data': ol.xml.makeChildAppender(writeDataNode),
            'value': ol.xml.makeChildAppender(writeDataNodeValue),
            'displayName': ol.xml.makeChildAppender(writeDataNodeName)
        });


    /**
     * @param {Element} node Node.
     * @param {{name: *, value: *}} pair Name value pair.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeDataNode(node, pair, objectStack) {
        node.setAttribute('name', pair.name);
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const value = pair.value;

        if (typeof value == 'object') {
            if (value !== null && value.displayName) {
                ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                    ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);
            }

            if (value !== null && value.value) {
                ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                    ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);
            }
        } else {
            ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);
        }
    }


    /**
     * @param {Node} node Node to append a TextNode with the name to.
     * @param {string} name DisplayName.
     */
    function writeDataNodeName(node, name) {
        ol.format.xsd.writeCDATASection(node, name);
    }


    /**
     * @param {Node} node Node to append a CDATA Section with the value to.
     * @param {string} value Value.
     */
    function writeDataNodeValue(node, value) {
        ol.format.xsd.writeStringTextNode(node, value);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const DOCUMENT_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Placemark': ol.xml.makeChildAppender(writePlacemark)
        });


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const DOCUMENT_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return ol.xml.createElementNS(parentNode.namespaceURI, 'Placemark');
    };


    /**
     * @param {Node} node Node.
     * @param {Array<Feature>} features Features.
     * @param {Array<*>} objectStack Object stack.
     * @this {KML}
     */
    function writeDocument(node, features, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context, DOCUMENT_SERIALIZERS,
            DOCUMENT_NODE_FACTORY, features, objectStack, undefined,
            this);
    }


    /**
     * A factory for creating Data nodes.
     * @const
     * @type {function(*, Array<*>): (Node|undefined)}
     */
    const DATA_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Data');


    /**
     * @param {Node} node Node.
     * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeExtendedData(node, namesAndValues, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const names = namesAndValues.names;
        const values = namesAndValues.values;
        const length = names.length;

        for (let i = 0; i < length; i++) {
            ol.xml.pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS,
                DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
        }
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const ICON_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'href'
        ],
        ol.xml.makeStructureNS(GX_NAMESPACE_URIS, [
            'x', 'y', 'w', 'h'
        ]));


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const ICON_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'href': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode)
        }, ol.xml.makeStructureNS(
            GX_NAMESPACE_URIS, {
                'x': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'y': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'w': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
                'h': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode)
            }));


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const GX_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        return ol.xml.createElementNS(GX_NAMESPACE_URIS[0],
            'gx:' + opt_nodeName);
    };


    /**
     * @param {Node} node Node.
     * @param {Object} icon Icon object.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeIcon(node, icon, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const parentNode = objectStack[objectStack.length - 1].node;
        let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
        let values = ol.xml.makeSequence(icon, orderedKeys);
        ol.xml.pushSerializeAndPop(context,
            ICON_SERIALIZERS, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,
            values, objectStack, orderedKeys);
        orderedKeys =
            ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
        values = ol.xml.makeSequence(icon, orderedKeys);
        ol.xml.pushSerializeAndPop(context, ICON_SERIALIZERS,
            GX_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const ICON_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'scale', 'heading', 'Icon', 'hotSpot'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const ICON_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'Icon': ol.xml.makeChildAppender(writeIcon),
            'heading': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode),
            'hotSpot': ol.xml.makeChildAppender(writeVec2),
            'scale': ol.xml.makeChildAppender(writeScaleTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../style/Icon.js").default} style Icon style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeIconStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const src = style.getSrc();
        const size = style.getSize();
        const iconImageSize = style.getImageSize();
        const iconProperties = {
            'href': src
        };

        if (size) {
            iconProperties['w'] = size[0];
            iconProperties['h'] = size[1];
            const anchor = style.getAnchor(); // top-left
            const origin = style.getOrigin(); // top-left

            if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
                iconProperties['x'] = origin[0];
                iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);
            }

            if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
                const /** @type {Vec2} */ hotSpot = {
                    x: anchor[0],
                    xunits: ol.style.IconAnchorUnits.PIXELS,
                    y: size[1] - anchor[1],
                    yunits: ol.style.IconAnchorUnits.PIXELS
                };
                properties['hotSpot'] = hotSpot;
            }
        }

        properties['Icon'] = iconProperties;

        const scale = style.getScale();
        if (scale !== 1) {
            properties['scale'] = scale;
        }

        const rotation = style.getRotation();
        if (rotation !== 0) {
            properties['heading'] = rotation; // 0-360
        }

        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const LABEL_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'color', 'scale'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LABEL_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode),
            'scale': ol.xml.makeChildAppender(writeScaleTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Text} style style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeLabelStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const fill = style.getFill();
        if (fill) {
            properties['color'] = fill.getColor();
        }
        const scale = style.getScale();
        if (scale && scale !== 1) {
            properties['scale'] = scale;
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys =
            LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const LINE_STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'color', 'width'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const LINE_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode),
            'width': ol.xml.makeChildAppender(ol.format.xsd.writeDecimalTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Stroke} style style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeLineStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {
            'color': style.getColor(),
            'width': style.getWidth()
        };
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, string>}
     */
    const GEOMETRY_TYPE_TO_NODENAME = {
        'Point': 'Point',
        'LineString': 'LineString',
        'LinearRing': 'LinearRing',
        'Polygon': 'Polygon',
        'MultiPoint': 'MultiGeometry',
        'MultiLineString': 'MultiGeometry',
        'MultiPolygon': 'MultiGeometry',
        'GeometryCollection': 'MultiGeometry'
    };


    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node|undefined} Node.
     */
    const GEOMETRY_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
        if (value) {
            const parentNode = objectStack[objectStack.length - 1].node;
            return ol.xml.createElementNS(parentNode.namespaceURI,
                GEOMETRY_TYPE_TO_NODENAME[/** @type {import("../geom/Geometry.js").default} */ (value).getType()]);
        }
    };


    /**
     * A factory for creating Point nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const POINT_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Point');


    /**
     * A factory for creating LineString nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const LINE_STRING_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('LineString');


    /**
     * A factory for creating LinearRing nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const LINEAR_RING_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('LinearRing');


    /**
     * A factory for creating Polygon nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const POLYGON_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('Polygon');


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const MULTI_GEOMETRY_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LineString': ol.xml.makeChildAppender(
                writePrimitiveGeometry),
            'Point': ol.xml.makeChildAppender(
                writePrimitiveGeometry),
            'Polygon': ol.xml.makeChildAppender(writePolygon),
            'GeometryCollection': ol.xml.makeChildAppender(
                writeMultiGeometry)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeMultiGeometry(node, geometry, objectStack) {
        /** @type {import("../xml.js").NodeStackItem} */
        const context = { node: node };
        const type = geometry.getType();
        /** @type {Array<import("../geom/Geometry.js").default>} */
        let geometries;
        /** @type {function(*, Array<*>, string=): (Node|undefined)} */
        let factory;
        if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
            geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();
            factory = GEOMETRY_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_POINT) {
            geometries = /** @type {ol.geom.MultiPoint} */ (geometry).getPoints();
            factory = POINT_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_LINE_STRING) {
            geometries =
                (/** @type {ol.geom.MultiLineString} */ (geometry)).getLineStrings();
            factory = LINE_STRING_NODE_FACTORY;
        } else if (type == ol.geom.GeometryType.MULTI_POLYGON) {
            geometries =
                (/** @type {ol.geom.MultiPolygon} */ (geometry)).getPolygons();
            factory = POLYGON_NODE_FACTORY;
        } else {
            assert(false, 39); // Unknown geometry type
        }
        ol.xml.pushSerializeAndPop(context,
            MULTI_GEOMETRY_SERIALIZERS, factory,
            geometries, objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const BOUNDARY_IS_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'LinearRing': ol.xml.makeChildAppender(
                writePrimitiveGeometry)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/LinearRing.js").default} linearRing Linear ring.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeBoundaryIs(node, linearRing, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context,
            BOUNDARY_IS_SERIALIZERS,
            LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const PLACEMARK_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'ExtendedData': ol.xml.makeChildAppender(writeExtendedData),
            'MultiGeometry': ol.xml.makeChildAppender(writeMultiGeometry),
            'LineString': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'LinearRing': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'Point': ol.xml.makeChildAppender(writePrimitiveGeometry),
            'Polygon': ol.xml.makeChildAppender(writePolygon),
            'Style': ol.xml.makeChildAppender(writeStyle),
            'address': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'description': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'name': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'open': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'phoneNumber': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'styleUrl': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'visibility': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode)
        });


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const PLACEMARK_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'name', 'open', 'visibility', 'address', 'phoneNumber', 'description',
            'styleUrl', 'Style'
        ]);


    /**
     * A factory for creating ExtendedData nodes.
     * @const
     * @type {function(*, Array<*>): (Node|undefined)}
     */
    const EXTENDEDDATA_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('ExtendedData');


    /**
     * FIXME currently we do serialize arbitrary/custom feature properties
     * (ExtendedData).
     * @param {Element} node Node.
     * @param {Feature} feature Feature.
     * @param {Array<*>} objectStack Object stack.
     * @this {KML}
     */
    function writePlacemark(node, feature, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };

        // set id
        if (feature.getId()) {
            node.setAttribute('id', /** @type {string} */(feature.getId()));
        }

        // serialize properties (properties unknown to KML are not serialized)
        const properties = feature.getProperties();

        // don't export these to ExtendedData
        const filter = {
            'address': 1, 'description': 1, 'name': 1, 'open': 1,
            'phoneNumber': 1, 'styleUrl': 1, 'visibility': 1
        };
        filter[feature.getGeometryName()] = 1;
        const keys = Object.keys(properties || {}).sort().filter(function (v) {
            return !filter[v];
        });

        if (keys.length > 0) {
            const sequence = ol.xml.makeSequence(properties, keys);
            const namesAndValues = { names: keys, values: sequence };
            ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
                EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
        }

        const styleFunction = feature.getStyleFunction();
        if (styleFunction) {
            // FIXME the styles returned by the style function are supposed to be
            // resolution-independent here
            const styles = styleFunction(feature, 0);
            if (styles) {
                const style = Array.isArray(styles) ? styles[0] : styles;
                if (this.writeStyles_) {
                    properties['Style'] = style;
                }
                const textStyle = style.getText();
                if (textStyle) {
                    properties['name'] = textStyle.getText();
                }
            }
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);

        // serialize geometry
        const options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
        let geometry = feature.getGeometry();
        if (geometry) {
            geometry = ol.format.Feature.transformGeometryWithOptions(geometry, true, options);
        }
        ol.xml.pushSerializeAndPop(context, PLACEMARK_SERIALIZERS,
            GEOMETRY_NODE_FACTORY, [geometry], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const PRIMITIVE_GEOMETRY_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'extrude', 'tessellate', 'altitudeMode', 'coordinates'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const PRIMITIVE_GEOMETRY_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'extrude': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'tessellate': ol.xml.makeChildAppender(ol.format.xsd.writeBooleanTextNode),
            'altitudeMode': ol.xml.makeChildAppender(ol.format.xsd.writeStringTextNode),
            'coordinates': ol.xml.makeChildAppender(writeCoordinatesTextNode)
        });


    /**
     * @param {Node} node Node.
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePrimitiveGeometry(node, geometry, objectStack) {
        const flatCoordinates = geometry.getFlatCoordinates();
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        context['layout'] = geometry.getLayout();
        context['stride'] = geometry.getStride();

        // serialize properties (properties unknown to KML are not serialized)
        const properties = geometry.getProperties();
        properties.coordinates = flatCoordinates;

        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const POLYGON_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'outerBoundaryIs': ol.xml.makeChildAppender(
                writeBoundaryIs),
            'innerBoundaryIs': ol.xml.makeChildAppender(
                writeBoundaryIs)
        });


    /**
     * A factory for creating innerBoundaryIs nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const INNER_BOUNDARY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('innerBoundaryIs');


    /**
     * A factory for creating outerBoundaryIs nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const OUTER_BOUNDARY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('outerBoundaryIs');


    /**
     * @param {Node} node Node.
     * @param {ol.geom.Polygon} polygon Polygon.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePolygon(node, polygon, objectStack) {
        const linearRings = polygon.getLinearRings();
        const outerRing = linearRings.shift();
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        // inner rings
        ol.xml.pushSerializeAndPop(context,
            POLYGON_SERIALIZERS,
            INNER_BOUNDARY_NODE_FACTORY,
            linearRings, objectStack);
        // outer ring
        ol.xml.pushSerializeAndPop(context,
            POLYGON_SERIALIZERS,
            OUTER_BOUNDARY_NODE_FACTORY,
            [outerRing], objectStack);
    }


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const POLY_STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'color': ol.xml.makeChildAppender(writeColorTextNode)
        });


    /**
     * A factory for creating coordinates nodes.
     * @const
     * @type {function(*, Array<*>, string=): (Node|undefined)}
     */
    const COLOR_NODE_FACTORY = ol.xml.makeSimpleNodeFactory('color');


    /**
     * @param {Node} node Node.
     * @param {ol.style.Fill} style Style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writePolyStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        ol.xml.pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS,
            COLOR_NODE_FACTORY, [style.getColor()], objectStack);
    }


    /**
     * @param {Node} node Node to append a TextNode with the scale to.
     * @param {number|undefined} scale Scale.
     */
    function writeScaleTextNode(node, scale) {
        // the Math is to remove any excess decimals created by float arithmetic
        ol.format.xsd.writeDecimalTextNode(node,
            Math.round(scale * 1e6) / 1e6);
    }


    /**
     * @const
     * @type {Object<string, Array<string>>}
     */
    const STYLE_SEQUENCE = ol.xml.makeStructureNS(
        NAMESPACE_URIS, [
            'IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle'
        ]);


    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    const STYLE_SERIALIZERS = ol.xml.makeStructureNS(
        NAMESPACE_URIS, {
            'IconStyle': ol.xml.makeChildAppender(writeIconStyle),
            'LabelStyle': ol.xml.makeChildAppender(writeLabelStyle),
            'LineStyle': ol.xml.makeChildAppender(writeLineStyle),
            'PolyStyle': ol.xml.makeChildAppender(writePolyStyle)
        });


    /**
     * @param {Node} node Node.
     * @param {ol.style.Style} style Style.
     * @param {Array<*>} objectStack Object stack.
     */
    function writeStyle(node, style, objectStack) {
        const /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
        const properties = {};
        const fillStyle = style.getFill();
        const strokeStyle = style.getStroke();
        const imageStyle = style.getImage();
        const textStyle = style.getText();
        if (imageStyle && typeof /** @type {?} */ (imageStyle).getSrc === 'function') {
            properties['IconStyle'] = imageStyle;
        }
        if (textStyle) {
            properties['LabelStyle'] = textStyle;
        }
        if (strokeStyle) {
            properties['LineStyle'] = strokeStyle;
        }
        if (fillStyle) {
            properties['PolyStyle'] = fillStyle;
        }
        const parentNode = objectStack[objectStack.length - 1].node;
        const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
        const values = ol.xml.makeSequence(properties, orderedKeys);
        ol.xml.pushSerializeAndPop(context, STYLE_SERIALIZERS,
            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    }


    /**
     * @param {Element} node Node to append a TextNode with the Vec2 to.
     * @param {Vec2} vec2 Vec2.
     */
    function writeVec2(node, vec2) {
        node.setAttribute('x', String(vec2.x));
        node.setAttribute('y', String(vec2.y));
        node.setAttribute('xunits', vec2.xunits);
        node.setAttribute('yunits', vec2.yunits);
    }

    ol.format.KMLCustom = KMLCustom;
})();

; (function (root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(['../../lib/ol/build/ol-sitna'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../../lib/ol/build/ol-sitna'));
    } else {
        root.ol = factory(root.ol);
    }

})(this, function (ol) {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };

    // requestAnimationFrame polyfill
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };

    // Nombres de tipos de eventos
    const MOUSEMOVE = 'mousemove';
    const MOUSEOVER = 'mouseover';
    const RESIZE = ol.events.EventType.RESIZE;
    const DRAGENTER = ol.events.EventType.DRAGENTER;
    const DRAGOVER = ol.events.EventType.DRAGOVER;
    const DROP = ol.events.EventType.DROP;
    const CHANGE = ol.events.EventType.CHANGE;
    const SINGLECLICK = ol.MapBrowserEventType.SINGLECLICK;
    const POINTERMOVE = ol.MapBrowserEventType.POINTERMOVE;
    const MOVEEND = ol.MapEventType.MOVEEND;
    const POSTRENDER = ol.MapEventType.POSTRENDER;
    const POSTCOMPOSE = ol.render.EventType.POSTCOMPOSE;
    const ADDFEATURE = ol.source.VectorEventType.ADDFEATURE;
    const REMOVEFEATURE = ol.source.VectorEventType.REMOVEFEATURE;
    const CLEAR = ol.source.VectorEventType.CLEAR;
    const TILELOADSTART = ol.source.TileEventType.TILELOADSTART;
    const TILELOADEND = ol.source.TileEventType.TILELOADEND;
    const TILELOADERROR = ol.source.TileEventType.TILELOADERROR;

    const hitTolerance = TC.Util.detectMouse() ? 3 : 10;

    var cssUrl = TC.url.ol.substr(0, TC.url.ol.lastIndexOf('/'));
    cssUrl = cssUrl.substr(0, cssUrl.lastIndexOf('/') + 1) + 'css/ol.css';
    //TC.loadCSS(cssUrl);


    /////////////////////////// ol patches

    if (!ol.format.KMLCustom) {
        TC.syncLoadJS(TC.apiLocation + 'TC/ol/format/KMLCustom');
    }

    if (!ol.format.GPXCustom) {
        TC.syncLoadJS(TC.apiLocation + 'TC/ol/format/GPXCustom');
    }
    if (!window.JSZip) {
        window.JSZip = new Promise(function (resolve, reject) {
            TC.loadJS(!window.JSZip, TC.apiLocation + 'lib/jszip/jszip', function () {
                resolve();
            })
        })
        window.JSZip.then(null, function (err) {
            TC.error(err);
            window.JSZip = false;
        })
    }
    // Parche para evitar el error AssertionError: Assertion failed: calculated value (1.020636810790192) ouside allowed range (0-1)
    ol.View.prototype.getValueForResolutionFunction = function (opt_power) {
        const power = opt_power || 2;
        const maxResolution = this.maxResolution_;
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
            /**
                 * @param {number} resolution Resolution.
                 * @return {number} Value.
             */
            function (resolution) {
                var value =
                    (Math.log(maxResolution / resolution) / Math.log(power)) / max;
                value = Math.max(Math.min(1, value), 0);
                return value;
            });
    };

    if (!TC.Util.detectMobile()) {
        // Parche para situar el ancla del popup cuando tenemos zoom in/out de navegador o pantalla
        ol.Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
            const style = this.element.style;
            const offset = this.getOffset();

            const positioning = this.getPositioning();

            this.setVisible(true);

            var offsetX = offset[0];
            var offsetY = offset[1];
            if (positioning == ol.OverlayPositioning.BOTTOM_RIGHT ||
                positioning == ol.OverlayPositioning.CENTER_RIGHT ||
                positioning == ol.OverlayPositioning.TOP_RIGHT) {
                if (this.rendered.left_ !== '') {
                    this.rendered.left_ = style.left = '';
                }
                const right = Math.round(mapSize[0] - pixel[0] - offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.right_ != right) {
                    this.rendered.right_ = style.right = right;
                }
            } else {
                if (this.rendered.right_ !== '') {
                    this.rendered.right_ = style.right = '';
                }
                if (positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.TOP_CENTER) {
                    offsetX -= this.element.offsetWidth / 2;
                }
                const left = Math.round(pixel[0] + offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.left_ != left) {
                    this.rendered.left_ = style.left = left;
                }
            }
            if (positioning == ol.OverlayPositioning.BOTTOM_LEFT ||
                positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                positioning == ol.OverlayPositioning.BOTTOM_RIGHT) {
                if (this.rendered.top_ !== '') {
                    this.rendered.top_ = style.top = '';
                }
                const bottom = Math.round(mapSize[1] - pixel[1] - offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.bottom_ != bottom) {
                    this.rendered.bottom_ = style.bottom = bottom;
                }
            } else {
                if (this.rendered.bottom_ !== '') {
                    this.rendered.bottom_ = style.bottom = '';
                }
                if (positioning == ol.OverlayPositioning.CENTER_LEFT ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_RIGHT) {
                    offsetY -= this.element.offsetHeight / 2;
                }
                const top = Math.round(pixel[1] + offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.top_ != top) {
                    this.rendered.top_ = style.top = top;
                }
            }
        };
    }

    // Modificación para cambiar el comportamiento de ol.control.OverviewMap:
    // Mantener la caja del extent siempre centrada.
    ol.control.OverviewMap.prototype._validateExtent_ = ol.control.OverviewMap.prototype.validateExtent_;
    ol.control.OverviewMap.prototype.validateExtent_ = function () {
        var self = this;
        self._validateExtent_();
        if (self._wrap && self._wrap.parent.options.alwaysCentered) {
            self.recenter_();
        }
    };

    // En modo 3D, cambiar la lógica de la escala para que siempre muestre área de visión.
    ol.control.OverviewMap.prototype._resetExtent_ = ol.control.OverviewMap.prototype.resetExtent_;
    ol.control.OverviewMap.prototype.resetExtent_ = function () {
        var self = this;
        self._resetExtent_.call(self);
        var wrap = self._wrap;
        if (wrap.is3D) {
            var ovmap = self.ovmap_;
            var ovview = ovmap.getView();
            var extent = ovview.calculateExtent();
            var feature = wrap.get3DCameraLayer().getSource().getFeatures()[0];
            if (feature) {
                coordinates = feature.getGeometry().getCoordinates();
                var coord1 = coordinates[0][0];
                var coord2 = coordinates[0][1];
                if (!ol.extent.containsCoordinate(extent, coord1) || !ol.extent.containsCoordinate(extent, coord2)) {
                    var buffer = Math.max(
                        extent[0] - coord1[0],
                        extent[1] - coord1[1],
                        coord1[0] - extent[2],
                        coord1[1] - extent[3],
                        extent[0] - coord2[0],
                        extent[1] - coord2[1],
                        coord2[0] - extent[2],
                        coord2[1] - extent[3]
                    );
                    ovview.fit(ol.extent.buffer(extent, buffer));
                }
            }
        }
    };

    ol.format.GML3CRS84 = function () {
        ol.format.GML3.call(this, {
            srsName: 'CRS:84'
        });
    };
    TC.inherit(ol.format.GML3CRS84, ol.format.GML3);

    ol.format.GML2CRS84 = function () {
        ol.format.GML2.call(this, {
            srsName: 'CRS:84'
        });
    };
    TC.inherit(ol.format.GML2CRS84, ol.format.GML2);

    // Añadido el espacio de nombres de GML 3.2 al parser
    const gmlNamespace = 'http://www.opengis.net/gml';
    const gml32Namespace = 'http://www.opengis.net/gml/3.2';
    ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.RING_PARSERS[gml32Namespace] = ol.format.GMLBase.prototype.RING_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gml32Namespace] = ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.MULTICURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTICURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.ENVELOPE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.ENVELOPE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.PATCHES_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.PATCHES_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SEGMENTS_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SEGMENTS_PARSERS_[gmlNamespace];

    // Bug de OpenLayers hasta 5.3.0 como mínimo:
    // El parser de GML2 no lee las siguientes features del GML si tienen un featureType distinto del primero.
    // Esto pasa porque genera el objeto de featureTypes con la primera y en las siguientes iteraciones si el objeto existe no se regenera.
    // Entre comentarios /* */ se elimina lo que sobra.
    //
    // Más: se añade para FeatureCollection un parser por cada namespaceURI del nodo. 
    // Esto es porque QGIS genera GML cuyo nodo FeatureCollection tiene namespace = http://ogr.maptools.org/.
    ol.format.GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {
        const localName = node.localName;
        let features = null;
        if (localName == 'FeatureCollection') {
            // Ñapa para leer GML de https://catastro.navarra.es/ref_catastral/gml.ashx?C=217&PO=5&PA=626
            // y demás GMLs obtenidos de un WFS de GeoServer.
            var gmlnsCollectionParser = this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.prototype.namespace];
            if (!gmlnsCollectionParser['member']) {
                gmlnsCollectionParser['member'] = ol.xml.makeArrayPusher(
                    ol.format.GMLBase.prototype.readFeaturesInternal);
            };
            //////
            // Sustituimos la siguienta instrucción por la siguiente condición :
            //features = pushParseAndPop([],
            //    this.FEATURE_COLLECTION_PARSERS, node,
            //    objectStack, this);
            if (node.namespaceURI === 'http://www.opengis.net/wfs') {
                features = ol.xml.pushParseAndPop([],
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            } else {
                this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] =
                    this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] || this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.prototype.namespace];
                features = ol.xml.pushParseAndPop(/*null*/[], // Cambiado null por [] porque si no, no crea el array de features
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            }
            //////
        } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
            const context = objectStack[0];
            let featureType = context['featureType'];
            let featureNS = context['featureNS'];
            const prefix = 'p';
            const defaultPrefix = 'p0';
            if (/*!featureType && */node.childNodes) {
                featureType = [], featureNS = {};
                for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {
                    const child = node.childNodes[i];
                    if (child.nodeType === 1) {
                        const ft = child.nodeName.split(':').pop();
                        if (featureType.indexOf(ft) === -1) {
                            let key = '';
                            let count = 0;
                            const uri = child.namespaceURI;
                            for (let candidate in featureNS) {
                                if (featureNS[candidate] === uri) {
                                    key = candidate;
                                    break;
                                }
                                ++count;
                            }
                            if (!key) {
                                key = prefix + count;
                                featureNS[key] = uri;
                            }
                            featureType.push(key + ':' + ft);
                        }
                    }
                }
                if (localName != 'featureMember') {
                    // recheck featureType for each featureMember
                    context['featureType'] = featureType;
                    context['featureNS'] = featureNS;
                }
            }
            if (typeof featureNS === 'string') {
                const ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
            }
            /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */
            const parsersNS = {};
            const featureTypes = Array.isArray(featureType) ? featureType : [featureType];
            for (let p in featureNS) {
                /** @type {Object<string, import("../xml.js").Parser>} */
                const parsers = {};
                for (let i = 0, ii = featureTypes.length; i < ii; ++i) {
                    const featurePrefix = featureTypes[i].indexOf(':') === -1 ?
                        defaultPrefix : featureTypes[i].split(':')[0];
                    if (featurePrefix === p) {
                        parsers[featureTypes[i].split(':').pop()] =
                            (localName == 'featureMembers') ?
                                ol.xml.makeArrayPusher(this.readFeatureElement, this) :
                                ol.xml.makeReplacer(this.readFeatureElement, this);
                    }
                }
                parsersNS[featureNS[p]] = parsers;
            }
            if (localName == 'featureMember') {
                features = ol.xml.pushParseAndPop(undefined, parsersNS, node, objectStack);
            } else {
                features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack);
            }
        }
        if (features === null) {
            features = [];
        }
        return features;
    };

    ol.proj.proj4.register(proj4);
    // OpenLayers usa para las proyecciones geográficas un valor ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES], calculado con una esfera, salvo
    // EPSG:4326, en la que usa ol.proj.EPSG4326.METERS_PER_UNIT, calculado con el geoide. Esto hace que las proyecciones en EPSG:4258 salgan desplazadas,
    // pese a que para todos los efectos son iguales a las EPSG:4326. Para evitar eso, introducimos en las 4258 el valor ol.proj.EPSG4326.METERS_PER_UNIT.
    ol.proj.get('EPSG:4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('urn:ogc:def:crs:EPSG::4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('http://www.opengis.net/gml/srs/epsg.xml#4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;

    // Reescribimos la obtención de proyección para que soporte códigos tipo EPSG:X, urn:ogc:def:crs:EPSG::X y http://www.opengis.net/gml/srs/epsg.xml#X
    ol.proj.oldGet = ol.proj.get;
    ol.proj.get = function (projectionLike) {
        if (typeof projectionLike === 'string') {
            projectionLike = projectionLike.trim();
            TC.loadProjDef({ crs: projectionLike, sync: true });
        }
        return ol.proj.oldGet.call(this, projectionLike);
    };

    // Reescritura de código para transformar las geometrías de getFeatureInfo que están en un CRS distinto
    ol.format.GMLBase.prototype.readGeometryElement = function (node, objectStack) {
        var context = /** @type {Object} */ (objectStack[0]);
        context['srsName'] = node.firstElementChild.getAttribute('srsName');
        context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
        /** @type {ol.geom.Geometry} */

        // Parche para poder leer coordenadas en EPSG:4326 con orden incorrecto (las crea QGIS, por ejemplo)
        if (this instanceof ol.format.GML2CRS84 || this instanceof ol.format.GML3CRS84) {
            if (context.srsName !== 'EPSG:4326' || !context.srsName) {
                throw new Error("Conflicto de CRS");
            }
        }
        if (!context.srsName) {
            context.srsName = this.srsName;
        }
        context.dataProjection = ol.proj.get(context.srsName);
        const geometry = ol.xml.pushParseAndPop(null,
            this.GEOMETRY_PARSERS, node, objectStack, this);
        if (geometry) {
            return /** @type {ol.geom.Geometry} */ (
                ol.format.Feature.transformWithOptions(geometry, false, context));
        } else {
            return undefined;
        }
    };

    const ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;

    // Reescritura de código para hacerlo compatible con GML generado por inspire:
    // No se puede considerar geometría cualquier cosa que tenga elementos anidados.
    ol.format.GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {
        let geometryName;
        const values = {};
        for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
            let value;
            const localName = n.localName;
            // first, check if it is simple attribute
            if (n.childNodes.length === 0
                || (n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {
                value = ol.xml.getAllTextContent(n, false);
                if (ONLY_WHITESPACE_RE.test(value)) {
                    value = undefined;
                }
            } else {
                if (asFeature) {
                    //if feature, try it as a geometry
                    value = this.readGeometryElement(n, objectStack);
                }
                if (!value) { //if not a geometry or not a feature, treat it as a complex attribute
                    value = this.readFeatureElementInternal(n, objectStack, false);
                } else if (localName !== 'boundedBy' && localName !== 'referencePoint') {
                    // boundedBy is an extent and must not be considered as a geometry
                    // flacunza: Tampoco referencePoint
                    geometryName = localName;
                }
            }

            if (values[localName]) {
                if (!(values[localName] instanceof Array)) {
                    values[localName] = [values[localName]];
                }
                values[localName].push(value);
            } else {
                values[localName] = value;
            }

            const len = n.attributes.length;
            if (len > 0) {
                values[localName] = { _content_: values[localName] };
                for (let i = 0; i < len; i++) {
                    const attName = n.attributes[i].name;
                    values[localName][attName] = n.attributes[i].value;
                }
            }
        }
        if (!asFeature) {
            return values;
        } else {
            const feature = new ol.Feature(values);
            if (geometryName) {
                feature.setGeometryName(geometryName);
            }
            const fid = node.getAttribute('fid') ||
                node.getAttributeNS(this.namespace, 'id');
            if (fid) {
                feature.setId(fid);
            }
            return feature;
        }
    };

    //////////////////////// end ol patches

    const getRGBA = function (color, opacity) {
        var result;
        if (color) {
            result = ol.color.asArray(color);
            result = result.slice();
            if (opacity !== undefined) {
                result[3] = opacity;
            }
        }
        else {
            result = [0, 0, 0, 1];
        }
        return result;
    };

    /**
     * Obtiene el objeto de opciones de una vista que restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
     * el mapa base activo.
     */
    var getResolutionOptions = function (mapWrap, layer) {
        var view = mapWrap.map.getView();
        var prevRes = view.getResolution();

        var pms = {
            projection: view.getProjection(),
            center: view.getCenter(),
            resolution: prevRes,
            enableRotation: false
        };

        if (mapWrap.parent.maxExtent) {
            pms.extent = mapWrap.parent.maxExtent;
        }

        // GLS 06/03/2019 Corregimos bug 24832, si el mapa de fondo es el mapa en blanco, asignamos las resoluciones del mapa de fondo actual
        var layerForResolutions = layer;
        if (layer.type === TC.Consts.layerType.VECTOR && mapWrap.parent.getBaseLayer()) {
            layerForResolutions = mapWrap.parent.getBaseLayer();
        }

        var res = layerForResolutions.getResolutions ? layerForResolutions.getResolutions() : [];
        var maxRes;
        var minRes;

        if (res && res.length) {
            maxRes = layerForResolutions.maxResolution || res[0];
            minRes = layerForResolutions.minResolution || res[res.length - 1];

            var minResIx = res.indexOf(minRes);
            var maxResIx = res.indexOf(maxRes);

            pms.resolutions = res.slice(maxResIx, minResIx + 1);
        }
        else {
            maxRes = layerForResolutions.maxResolution;
            minRes = layerForResolutions.minResolution;
        }
        if (minRes) {
            pms.minResolution = minRes;
            if (prevRes < minRes) {
                pms.resolution = minRes;
            }
        }
        if (maxRes) {
            pms.maxResolution = maxRes;
            if (prevRes > maxRes) {
                pms.resolution = maxRes;
            }
        }

        return pms;
    };


    TC.wrap.Map.prototype.setMap = function () {
        var self = this;
        var center = [
            (self.parent.initialExtent[0] + self.parent.initialExtent[2]) / 2,
            (self.parent.initialExtent[1] + self.parent.initialExtent[3]) / 2
        ];

        var proj4Obj = proj4(self.parent.crs);
        var addEquivalentProjections = function () {
            // Añadimos proyecciones equivalentes y transformaciones necesarias.
            var crsCode = self.parent.crs.substr(self.parent.crs.lastIndexOf(':') + 1);

            var projOptions = {
                units: proj4Obj.oProj.units,
                global: true
            };

            var equivalentProjections = [];
            if (crsCode !== '4326') { // Este código ya está metido, no lo machacamos
                projOptions.code = 'EPSG:' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));
                projOptions.code = 'urn:ogc:def:crs:EPSG::' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));

                ol.proj.addEquivalentProjections(equivalentProjections);
            }
            //var doTransform = function (fn, input, opt_output, opt_dimension) {
            //    var result = [];
            //    var dimension = opt_dimension || 2;
            //    for (var i = 0; i < input.length; i += dimension) {
            //        var transformed = Array.prototype.slice.call(fn(input.slice(i, i + dimension)));
            //        if (dimension === 3 || dimension === 4) {
            //            transformed = transformed.slice(0, 2).concat(input.slice(i + 2, (i + 2) + (dimension - 2)));
            //        }

            //        result = result.concat(transformed);
            //    }
            //    if (Array.isArray(opt_output)) {
            //        opt_output.length = 0;
            //        for (var i = 0; i < result.length; i++) {
            //            opt_output[i] = result[i];
            //        }
            //        result = opt_output;
            //    }
            //    return result;
            //};
            //var fromEPSG4326 = function (input, opt_output, opt_dimension) {
            //    return doTransform(proj4Obj.forward, input, opt_output, opt_dimension);
            //};
            //var toEPSG4326 = function (input, opt_output, opt_dimension) {
            //    return doTransform(proj4Obj.inverse, input, opt_output, opt_dimension);
            //};

            ol.proj.proj4.register(proj4);

            //ol.proj.addEquivalentTransforms(
            //    ol.proj.EPSG4326.PROJECTIONS,
            //    equivalentProjections,
            //    fromEPSG4326,
            //    toEPSG4326);
        };

        addEquivalentProjections();

        var projOptions = {
            code: self.parent.crs,
            units: proj4Obj.oProj.units
        };
        if (self.parent.crs === 'EPSG:4326') {
            projOptions.axisOrientation = 'neu';
        }
        var projection = new ol.proj.Projection(projOptions);

        var interactions = ol.interaction.defaults({ constrainResolution: true });

        var viewOptions = {
            projection: projection,
            center: center,
            enableRotation: false
        };
        const extentForResolution = self.parent.maxExtent || self.parent.initialExtent;
        viewOptions.extent = extentForResolution;
        var rect = self.parent.div.getBoundingClientRect();
        var dx = extentForResolution[2] - extentForResolution[0];
        var dy = extentForResolution[3] - extentForResolution[1];
        if (rect.width / rect.height > dx / dy) {
            viewOptions.resolution = dx / rect.width;
        }
        else {
            viewOptions.resolution = dy / rect.height;
        }

        self.map = new ol.Map({
            target: self.parent.div,
            view: new ol.View(viewOptions),
            controls: [],
            interactions: interactions,
            pixelRatio: 1 /* 08/02/2019 GLS: 
            Establecemos el pixelRatio siempre a uno, porque OL sólo atiende al valor al principio, 
            si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso,
            click se sitúa mal, popup se sitúa entre otros efectos.
            Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                Bug 25976:Mapa situación en blanco
                Bug 25954:Canvas en blanco con zoom mayor al 100%
                Bug 23855:Mapa de situación se muestra en blanco
            */
        });

        if (!TC.Util.detectMobile()) {
            // Parche para corregir https://github.com/openlayers/openlayers/issues/2904
            // saben que tienen un bug cuando se trabaja sobre un mapa con zoom
            self.map.getEventPixel = function (event) {
                var viewportPosition = this.viewport_.getBoundingClientRect();
                var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
                eventPosition = eventPosition.clientX ? eventPosition : (eventPosition.pointerEvent ? eventPosition.pointerEvent : eventPosition);
                return [
                    (eventPosition.clientX - viewportPosition.left) * window.devicePixelRatio,
                    (eventPosition.clientY - viewportPosition.top) * window.devicePixelRatio
                ];
            };
        }

        self.map._wrap = self;
        self._promise = Promise.resolve(self.map);

        // mantenemos el ancho y alto del canvas en números enteros
        self.manageSize.call(self.map);

        // Para evitar estiramientos en canvas
        var updateSize = function () {
            self.map.updateSize();
        };
        self.parent.div.addEventListener(RESIZE, updateSize);
        self.parent.one(TC.Consts.event.MAPLOAD, updateSize);

        self.map.on(SINGLECLICK, function (e) {

            if (self.parent.view === TC.Consts.view.PRINTING) {
                return;
            }

            self.parent.workLayers.forEach(function (wl) {
                delete wl._noFeatureClicked;
            });
            var featuresInLayers = self.parent.workLayers.map(function () {
                return false;
            });
            self.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        for (var i = 0; i < self.parent.workLayers.length; i++) {
                            var wl = self.parent.workLayers[i];
                            if (wl.wrap.layer === layer) {
                                featuresInLayers[i] = true;
                                break;
                            }
                        }
                        self.parent.trigger(TC.Consts.event.FEATURECLICK, { feature: feature._wrap.parent });
                        return feature;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            for (var i = 0; i < featuresInLayers.length; i++) {
                if (!featuresInLayers[i]) {
                    self.parent.trigger(TC.Consts.event.NOFEATURECLICK, { layer: self.parent.workLayers[i] });
                }
            }
        });


        // GLS: 13/02/2019 cambiamos el orden de las suscripciones a eventos de cambio de resolución y moveend
        // para gestionar el borrado del estado inicial. Si no lo hacemos el cambio al extent inicial se registra como evento de usuario
        // porque la carga inicial del mapa con promesas nativas es más rápido que antes.
        // Bug:26001 Borrar estado inicial al entrar
        const addMoveEndListener = function () {
            self.map.on(MOVEEND, function () {
                self.parent.trigger(TC.Consts.event.ZOOM);
            });
        };
        var olView = self.map.getView();
        olView.on('change:resolution', function () {
            if (!self.map.hasListener(MOVEEND)) {
                self.map.once(MOVEEND, function () {
                    addMoveEndListener();
                });
            }

            self.parent.trigger(TC.Consts.event.BEFOREZOOM);
        }, self.parent);

        const onChangeView = function () {
            if (!self.map.hasListener(MOVEEND)) {
                self.map.un('change:view', onChangeView);
                addMoveEndListener();
            }
        };
        self.map.on('change:view', onChangeView);

        /**
         * Restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
         * el mapa base activo.
         */
        var limitZoomLevels = function (layer) {
            var prevRes = self.map.getView().getResolution();
            var prevZoom = self.map.getView().getZoom();

            var pms = getResolutionOptions(self, layer);

            var view = new ol.View(pms);
            self.map.setView(view);
            self.map.render();
        };

        self.parent.on(TC.Consts.event.BASELAYERCHANGE, function (e) {
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            if (self.parent.crs === self.parent.options.crs && !self.parent.on3DView && e.layer.type !== TC.Consts.layerType.VECTOR) {
                limitZoomLevels(e.layer);
            }
        });
        self.parent.on(TC.Consts.event.MAPLOAD, function (e) {
            limitZoomLevels(self.parent.getBaseLayer());
        });

        const olMapViewport = self.map.getViewport();

        olMapViewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
            var hit = false;

            if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {

                if (self.parent.view === TC.Consts.view.PRINTING) {
                    return;
                }

                var pixel = self.map.getEventPixel(e);
                hit = self.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
                    var result = true;
                    if (feature._wrap && !feature._wrap.parent.showsPopup && !feature._wrap.parent.options.selectable) {
                        result = false;
                    }

                    if (result && feature._wrap) {
                        self.parent.trigger(TC.Consts.event.FEATUREOVER, {
                            feature: feature._wrap.parent
                        });
                    }

                    return result;
                }, { hitTolerance: hitTolerance });
            }

            if (hit) {
                olMapViewport.style.cursor = 'pointer';
            } else {
                olMapViewport.style.cursor = '';
                //self.parent.trigger(TC.Consts.event.FEATUREOUT);
            }
        });
    };

    var getMetersPerUnit = function (proj, extentInDegrees) {
        var units = proj.getUnits();
        if (!units || units === ol.proj.Units.DEGREES) {
            return TC.Util.getMetersPerDegree(extentInDegrees);
        }
        return ol.proj.METERS_PER_UNIT[units];
    };

    TC.wrap.Map.prototype.getMetersPerUnit = function () {
        var self = this;
        return getMetersPerUnit(ol.proj.get(self.parent.crs), self.getExtent());
    };

    var getUnitRatio = function (options) {
        var self = this;
        options = options || {};
        var defaultCrs = self.parent.options.crs || TC.Cfg.crs;
        var defaultProj = ol.proj.get(defaultCrs);
        var newProj = ol.proj.get(options.crs);
        return getMetersPerUnit(newProj, options.extentInDegrees) / getMetersPerUnit(defaultProj, options.extentInDegrees);
    };

    var normalizeProjection = function (options) {
        var result;
        if (options.axisOrientation) {
            result = new ol.proj.Projection({
                code: options.crs,
                axisOrientation: options.axisOrientation
            });
        }
        else {
            result = ol.proj.get(options.crs);
        }
        if (!result.getUnits()) {
            result.units_ = ol.proj.Units.DEGREES;
        }
        return result;
    };

    TC.wrap.Map.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};
        const baseLayer = options.baseLayer || self.parent.baseLayer;
        var extent;
        if (options.extent) {
            extent = options.extent;
        }
        else {
            extent = ol.proj.transformExtent(self.getExtent(), self.parent.crs, options.crs);
        }
        const extentInDegrees = ol.proj.transformExtent(extent, options.crs, 'EPSG:4326');
        const unitRatio = getUnitRatio.call(self, {
            crs: options.crs,
            extentInDegrees: extentInDegrees
        });
        const projection = normalizeProjection(options);
        const oldView = self.map.getView();
        const viewOptions = {
            projection: projection,
            enableRotation: false
        };
        const resolutions = baseLayer.getResolutions();

        if (resolutions && resolutions.length) {
            viewOptions.resolutions = resolutions;
        }
        else {
            viewOptions.minZoom = oldView.getMinZoom();
            viewOptions.maxZoom = oldView.getMaxZoom();
            const minResolution = baseLayer.wrap.layer.getMinResolution();
            const maxResolution = baseLayer.wrap.layer.getMaxResolution();
            var transformFactor = 1;
            if (minResolution === 0 || maxResolution === Number.POSITIVE_INFINITY) {
                const oldUnitRatio = getUnitRatio.call(self, {
                    crs: self.parent.crs,
                    extentInDegrees: extentInDegrees
                });
                transformFactor = oldUnitRatio / unitRatio;
            }
            if (minResolution === 0) {
                viewOptions.minResolution = oldView.getMinResolution() * transformFactor;
            }
            else {
                viewOptions.minResolution = minResolution;
            }
            if (maxResolution === Number.POSITIVE_INFINITY) {
                viewOptions.maxResolution = oldView.getMaxResolution() * transformFactor;
            }
            else {
                viewOptions.maxResolution = maxResolution;
            }
        }

        // GLS: transformamos también el centro     
        viewOptions.center = ol.proj.transform(self.getCenter(), self.parent.crs, options.crs);

        var newView = new ol.View(viewOptions);
        self.map.setView(newView);
        self.parent.initialExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.initialExtent, self.parent.crs, options.crs) : self.parent.options.initialExtent;
        if (self.parent.options.maxExtent) {
            self.parent.options.maxExtent = self.parent.maxExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.maxExtent, self.parent.crs, options.crs) : self.parent.options.maxExtent;
        }
        newView.fit(extent, { nearest: true });
    };

    /*
     *  insertLayer: inserts OpenLayers layer at index
     *  Parameters: OpenLayers.Layer, number
     */
    TC.wrap.Map.prototype.insertLayer = function (olLayer, idx) {
        var self = this;
        var layers = self.map.getLayers();
        var alreadyExists = false;
        for (var i = 0; i < layers.getLength(); i++) {
            if (layers.item(i) === olLayer) {
                alreadyExists = true;
                break;
            }
        }
        if (alreadyExists) {
            layers.remove(olLayer);
            layers.insertAt(idx, olLayer);
        }
        else {
            if (idx < 0) {
                layers.push(olLayer);
            }
            else {
                layers.insertAt(idx, olLayer);
            }
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            var view = self.map.getView();
            if (self.parent.crs === self.parent.options.crs) {
                if (olLayer instanceof ol.layer.Tile) {
                    var resolutions = olLayer.getSource().getResolutions();
                    view.maxResolution_ = resolutions[0];
                    view.minResolution_ = resolutions[resolutions.length - 1];
                }
            }
            else {
                // Cambiamos los límites de resolución de la capa a los de la vista. Esto lo hacemos porque su resolución está en otro CRS.
                if (olLayer instanceof ol.layer.Tile) {
                    olLayer.setMaxResolution(view.getMaxResolution());
                    olLayer.setMinResolution(view.getMinResolution());
                }
            }

            var wrap = olLayer._wrap;
            var loadingTileCount = 0;

            var beforeTileLoadHandler = function (e) {
                wrap.parent.state = TC.Layer.state.LOADING;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    self.parent.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: wrap.parent });
                }
                olLayer._loadingTileCount = olLayer._loadingTileCount + 1;
            };
            if (wrap.parent.state === TC.Layer.state.LOADING && wrap.parent.isRaster()) {
                beforeTileLoadHandler();
            }
            wrap.$events.on(TC.Consts.event.BEFORETILELOAD, beforeTileLoadHandler);

            wrap.$events.on(TC.Consts.event.TILELOAD, function (e) {
                loadingTileCount = loadingTileCount - 1;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    wrap.parent.state = TC.Layer.state.IDLE;
                    self.parent.trigger(TC.Consts.event.LAYERUPDATE, { layer: wrap.parent });
                }
            });
        }
    };

    TC.wrap.Map.prototype.removeLayer = function (olLayer) {
        this.map.removeLayer(olLayer);
    };

    TC.wrap.Map.prototype.getLayerCount = function () {
        return this.map.getLayerGroup().getLayers().getLength();
    };

    TC.wrap.Map.prototype.indexOfFirstVector = function () {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (l, i) {
            if (l instanceof ol.layer.Vector && result === -1) {
                result = i;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.getLayerIndex = function (olLayer) {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (elm, idx) {
            if (elm === olLayer) {
                result = idx;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.setLayerIndex = function (olLayer, index) {
        var layers = this.map.getLayers();
        var list = layers.getArray();
        var ix = list.indexOf(olLayer);

        if (ix > -1 && ix != index) {
            this.map.removeLayer(olLayer);
            this.insertLayer(olLayer, index);
            //layers.setAt(index, olLayer);
        }
        else {
            //no está el layer, así que no hago nada
        }

    };

    TC.wrap.Map.prototype.setBaseLayer = function (olLayer) {
        var self = this;
        return new Promise(function (resolve, reject) {
            var setLayer = function (curBl) {
                // GLS: si se llega después de una animación el valor de self.parent.getBaseLayer() ya es el definitivo y no el actual lo que provoca efectos indeseados. 
                // ir a línea 1313: paso como parámetro el baseLayer actual en el caso de animación.
                var curBl = curBl || self.parent.getBaseLayer();
                if (curBl) {
                    self.map.removeLayer(curBl.wrap.layer);
                    if (olLayer instanceof ol.layer.Image) { // Si es imagen no teselada
                        olLayer._wrap.setProjection({
                            crs: self.parent.crs
                        });
                    }

                    if (olLayer._wrap.parent.type === TC.Consts.layerType.WMTS) {
                        var layerProjectionOptions = { crs: self.parent.crs, oldCrs: olLayer.getSource().getProjection().getCode() };

                        if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                            olLayer._wrap.parent.setProjection(layerProjectionOptions);
                        }
                    }

                    //if (olLayer instanceof ol.layer.Tile) { // Si es imagen teselada
                    //    const view = self.map.getView();
                    //    const resolutions = olLayer.getSource().getResolutions();
                    //    if (resolutions) {
                    //        view.options_.resolutions = resolutions;
                    //        view.applyOptions_(view.options_);
                    //    }
                    //}
                }
                self.insertLayer(olLayer, 0);
                self.map.getControls().forEach(function (ctl) {
                    if (ctl instanceof ol.control.ZoomSlider) {
                        ctl.initSlider_();
                    }
                });
                resolve();
            };

            // Toda esta lógica antes de llamar a setLayer() es para hacer un zoom a la nueva resolución
            // cuando la nueva capa no llega a la resolución actual
            var viewOptions = getResolutionOptions(self, olLayer._wrap.parent);
            var view = self.map.getView();
            var currentResolution = view.getResolution();
            if (viewOptions.resolutions) {
                //buscamos la nueva resolución: o una que sea similar a la actual dentro de los márgenes admitidos, o la inmediata superior
                var newRes = viewOptions.resolutions
                    .sort(function (a, b) { return a - b })
                    .reduce(function (prev, elm) {
                        if (prev === 0 &&
                            (elm > currentResolution || Math.abs(1 - (currentResolution / elm)) < self.parent.options.maxResolutionError)) {
                            return elm;
                        }
                        return prev;
                    }, 0);
                if (newRes !== currentResolution) {
                    if (self.parent.isLoaded) {
                        view.animate({ resolution: newRes, duration: TC.Consts.ZOOM_ANIMATION_DURATION }, setLayer.bind(self, self.parent.getBaseLayer()));
                    }
                    else { // Primera carga, no animamos
                        view.setResolution(newRes);
                        setLayer();
                    }
                }
                else {
                    setLayer();
                }
            }
            else {
                setLayer();
            }
        });
    };

    TC.wrap.Map.prototype.setExtent = function (extent, options) {
        const self = this;
        options = options || {};

        const applyExtent = function (view, mapSize, resolve, reject) {
            var res = view.getResolutionForExtent(extent, mapSize);
            // URI: Esta logica está fusilada de la función fit de un objeto view de OL3
            if (view.constrainResolution) {
                var constrainedResolution = view.constrainResolution(res, 0, 0);
                if (constrainedResolution < res) {
                    if (constrainedResolution / res < TC.Consts.EXTENT_TOLERANCE) {
                        constrainedResolution = view.constrainResolution(
                            constrainedResolution, -1, 0);
                    }
                }
                res = constrainedResolution;
            }

            // flacunza: No animamos si la duración va a ser 0, porque a veces el zoom no se completa
            // GLS: antes de resolver la promesa validamos si existe animación
            // URI: si la animacion no existe ponemos duracion 0
            // flacunza: en caso de que animate=undefined, se anima
            const center = [((extent[0] + extent[2]) / 2), ((extent[1] + extent[3]) / 2)];
            if (options.animate === void (0) || options.animate) {
                view.animate({
                    resolution: res,
                    center: center,
                    duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, resolve);
            }
            else {
                view.setCenter(center);
                view.setResolution(res);
                resolve();
            }
        };

        const setPromise = function (extent) {
            self._setExtentPromise = new Promise(function (resolve, reject) {
                // Timeout porque OL3 no tiene evento featuresadded, por tanto cuando se activa map.options.zoomToMarkers
                // se lanza un setExtent por marcador. El timeout evita ejecuciones a lo tonto.
                clearTimeout(self._timeout);
                self._timeout = setTimeout(function () {
                    var mapSize = self.map.getSize();
                    var view = self.map.getView();

                    if (self.parent.baseLayer) {
                        self.parent.baseLayer.wrap.getLayer().then(function (olLayer) {
                            // Todo esto para evitar que haga más zoom que el admisible por la capa base
                            const res = view.getResolutionForExtent(extent, mapSize);
                            const resolutions = self.getResolutions();
                            const maxZoom = view.getMaxZoom();
                            if (maxZoom < resolutions.length - 1) {
                                resolutions.length = maxZoom + 1;
                            }

                            if (resolutions.length > 0) {
                                var minRes = Math.min.apply(self, resolutions);
                                if (minRes > res) {
                                    var factor = 0.5 * (minRes / res - 1);
                                    var dx = ol.extent.getWidth(extent) * factor;
                                    var dy = ol.extent.getHeight(extent) * factor;
                                    extent = extent.slice(0);
                                    extent[0] = extent[0] - dx;
                                    extent[1] = extent[1] - dy;
                                    extent[2] = extent[2] + dx;
                                    extent[3] = extent[3] + dy;
                                }
                            }

                            applyExtent(view, mapSize, resolve, reject);

                        });
                    }
                    else {
                        applyExtent(view, mapSize, resolve, reject);
                    }
                }, 50);
            });
        };
        Promise.resolve(self._setExtentPromise).finally(function () {
            setPromise(extent);
        });

        return self._setExtentPromise;
    };

    TC.wrap.Map.prototype.getExtent = function () {
        return this.map.getView().calculateExtent(this.map.getSize());
    };

    TC.wrap.Map.prototype.setCenter = function (coords, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const callback = function () {
                resolve();
            };

            const opts = options || {};
            const view = self.map.getView();

            if (opts.animate) {
                view.animate({
                    center: coords, duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, callback);
            }
            else {
                view.setCenter(coords);
                resolve();
            }
        });
    };

    TC.wrap.Map.prototype.getCenter = function () {
        return this.map.getView().getCenter();
    };

    TC.wrap.Map.prototype.getResolution = function () {
        return this.map.getView().getResolution();
    };

    TC.wrap.Map.prototype.setResolution = function (resolution) {
        this.getMap().then(function (olMap) {
            olMap.getView().setResolution(resolution);
        });
    };

    TC.wrap.Map.prototype.setRotation = function (rotation) {
        this.getMap().then(function (olMap) {
            olMap.getView().setRotation(rotation);
        });
    };

    TC.wrap.Map.prototype.getRotation = function () {
        return this.map.getView().getRotation();
    };

    TC.wrap.Map.prototype.getResolutions = function () {
        return this.map.getView().getResolutions() || [];
    };

    TC.wrap.Map.prototype.getCoordinateFromPixel = function (xy) {
        return this.map.getCoordinateFromPixel(xy);
    };

    TC.wrap.Map.prototype.getPixelFromCoordinate = function (coord) {
        return this.map.getPixelFromCoordinate(coord);
    };

    TC.wrap.Map.prototype.getViewport = function (options) {
        const self = this;
        var result;
        var opts = options || {
        };
        if (opts.synchronous) {
            result = self.map.getViewport();
        }
        else {
            result = new Promise(function (resolve, reject) {
                self.getMap().then(function (olMap) {
                    resolve(olMap.getViewport());
                });
            });
        }
        return result;
    };

    TC.wrap.Map.prototype.isNative = function (map) {
        return map instanceof ol.Map;
    };

    TC.wrap.Map.prototype.isGeo = function () {
        var units = this.map.getView().getProjection().getUnits();
        return !units || units === ol.proj.Units.DEGREES;
    };

    TC.wrap.Map.prototype.addPopup = function (popupCtl) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var draggable = popupCtl.options.draggable === undefined || popupCtl.options.draggable;
            TC.loadJS(
                draggable && !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    self.getMap().then(function (olMap) {
                        if (!popupCtl.popupDiv) {
                            // No popups yet
                            const popupDiv = TC.Util.getDiv();
                            popupCtl.popupDiv = popupDiv;
                            if (window.$) {
                                popupCtl.$popupDiv = $(popupDiv);
                            }
                            popupDiv.classList.add(TC.control.Popup.prototype.CLASS);
                            popupCtl.contentDiv = TC.Util.getDiv();
                            popupCtl.contentDiv.classList.add(TC.control.Popup.prototype.CLASS + '-content');
                            popupCtl.popupDiv.appendChild(popupCtl.contentDiv);
                            popupCtl.menuDiv = TC.Util.getDiv();
                            popupCtl.menuDiv.classList.add(TC.control.Popup.prototype.CLASS + '-menu');
                            popupCtl.popupDiv.appendChild(popupCtl.menuDiv);
                            self.parent.div.appendChild(popupDiv);

                            var popup = new ol.Overlay({
                                element: popupDiv,
                                positioning: ol.OverlayPositioning.BOTTOM_LEFT
                            });
                            olMap.addOverlay(popup);
                            popupCtl.wrap.popup = popup;

                            //popupCtl._firstRender.resolve();
                            //popupCtl.trigger(TC.Consts.event.CONTROLRENDER);
                            const olMapViewport = olMap.getViewport();

                            if (draggable) {
                                const container = popupCtl.popupDiv.parentElement;
                                popupCtl.popupDiv.classList.add(TC.Consts.classes.DRAGGABLE);


                                container.addEventListener('touchmove', function (e) {
                                    var parent = e.target;
                                    do {
                                        if (parent.matches('.tc-ctl-finfo-layer-content')) {
                                            e.stopPropagation();
                                            break;
                                        }
                                        parent = parent.parentElement;
                                    }
                                    while (parent);
                                });

                                // Tuneamos Draggabilly para que acepte excepciones a los asideros del elemento.
                                const drag = new Draggabilly(container, {
                                    //not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                });
                                drag.handleEvent = function (event) {
                                    if (this.options.not && event.target.matches(this.options.not)) {
                                        return;
                                    }
                                    Draggabilly.prototype.handleEvent.call(this, event);
                                };
                                drag.on('pointerDown', function (e, pointer) {
                                    var bcr = e.target.getBoundingClientRect();
                                    // Si estamos pulsando sobre una barra de scroll abortamos drag
                                    if (bcr.left + e.target.clientWidth < pointer.pageX || bcr.top + e.target.clientHeight < pointer.pageY) {
                                        drag._pointerCancel(e, pointer);
                                        return false;
                                    }
                                });
                                drag.on('dragStart', function (e, pointer) {
                                    popupCtl.setDragging(true);
                                    popupCtl._currentOffset = popup.getOffset();
                                    if (popupCtl._previousContainerPosition) {
                                        var mapSize = olMap.getSize();
                                        popup.setPosition(olMap.getCoordinateFromPixel([popupCtl._previousContainerPosition[0], mapSize[1] - popupCtl._previousContainerPosition[1]]));
                                        popupCtl._currentOffset = [0, 0];
                                        popup.setOffset(popupCtl._currentOffset);
                                        delete popupCtl._previousContainerPosition;
                                    }
                                    else {
                                        popupCtl._currentOffset = popup.getOffset();
                                    }
                                });
                                drag.on('dragEnd', function (e) {
                                    popupCtl.setDragging(false);
                                    var coord1 = olMap.getCoordinateFromPixel([0, 0]);
                                    var coord2 = olMap.getCoordinateFromPixel(popup.getOffset());
                                    var coordDelta = [coord2[0] - coord1[0], coord2[1] - coord1[1]];
                                    var position = popup.getPosition();
                                    popup.setPosition([position[0] + coordDelta[0], position[1] + coordDelta[1]]);
                                    popup.setOffset([0, 0]);
                                    popupCtl._currentOffset = [0, 0];

                                    const containerRect = container.getBoundingClientRect();
                                    popupCtl._previousContainerPosition = [containerRect.left, containerRect.bottom];
                                });
                                //drag.on('dragMove', function (e, pointer, moveVector) {
                                //popup.setOffset([popupCtl._currentOffset[0] + moveVector.x, popupCtl._currentOffset[1] + moveVector.y]);
                                //});
                                //.drag(function (ev, dd) {
                                //    if (!ev.buttons && !Modernizr.touch) { // Evitamos que se mantenga el drag si no hay botón pulsado (p.e. en IE pulsando una scrollbar)
                                //        return false;
                                //    }
                                //    popup.setOffset([popupCtl._currentOffset[0] + dd.deltaX, popupCtl._currentOffset[1] + dd.deltaY]);
                                //}, {
                                //    not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                //    })                                
                            }

                            const mouseMoveHandler = function (e) {
                                const viewport = olMap.getViewport();
                                var hit = false;
                                if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {
                                    var pixel = olMap.getEventPixel(e);
                                    hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                                        var result = true;
                                        if (feature._wrap && !feature._wrap.parent.showsPopup) {
                                            result = false;
                                        }
                                        return result;
                                    },
                                        {
                                            hitTolerance: hitTolerance
                                        });
                                }
                                if (hit) {
                                    viewport.style.cursor = 'pointer';
                                } else {
                                    viewport.style.cursor = '';
                                }
                            };

                            // change mouse cursor when over marker
                            olMapViewport.removeEventListener(MOUSEMOVE, mouseMoveHandler);
                            olMapViewport.addEventListener(MOUSEMOVE, mouseMoveHandler);
                        }
                    });
                    resolve();
                }
            );
        });
    };

    TC.wrap.Map.prototype.hidePopup = function (popupCtl) {
        var self = this;
        self.parent.currentFeature = null;
        if (popupCtl.popupDiv) {
            popupCtl.popupDiv.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    TC.wrap.Map.prototype.manageSize = function () {
        const self = this;

        // Para controlar que el mapa no se vea borroso porque no encajan el width y height con los width y height de CSS
        const manageSize = function (event) {
            var pixelRatio = window.devicePixelRatio || 1;
            var canvas = event.context.canvas;
            var bounding = canvas.getBoundingClientRect();

            var idealWidth = pixelRatio * bounding.width;
            var idealHeight = pixelRatio * bounding.height;

            if (idealWidth !== bounding.width || !Number.isInteger(idealWidth)) {
                idealWidth = Math.round(idealWidth);
            }

            if (idealHeight !== bounding.height || !Number.isInteger(idealHeight)) {
                idealHeight = Math.round(idealHeight);
            }

            if (idealWidth !== bounding.width || idealHeight !== bounding.height) {
                var newSize = [idealWidth, idealHeight];
                event.target.setSize(newSize);
            }
        };

        if (!TC.Util.detectMobile()) {
            self.on(POSTCOMPOSE, manageSize);
        }
    };

    var getFormatFromName = function (name) {
        switch (name) {
            case TC.Consts.layerType.KML:
            case TC.Consts.mimeType.KML:
            case TC.Consts.format.KMZ:
                return new ol.format.KMLCustom({
                    showPointNames: false
                });
            case TC.Consts.layerType.GPX:
            case TC.Consts.mimeType.GPX:
                return new ol.format.GPXCustom();
            case TC.Consts.layerType.GEOJSON:
            case TC.Consts.mimeType.GEOJSON:
            case TC.Consts.mimeType.JSON:
            case TC.Consts.format.JSON:
                return new ol.format.GeoJSON();
            case TC.Consts.format.GML2:
                return new ol.format.GML2();
            case TC.Consts.format.GML3:
                return new ol.format.GML3();
            case TC.Consts.format.GML32:
                return new ol.format.GML32();
            case TC.Consts.mimeType.GML:
            case TC.Consts.format.GML:
                return new ol.format.GML();
            case TC.Consts.format.TOPOJSON:
                return new ol.format.TopoJSON();
            case TC.Consts.format.WKT:
                return new ol.format.WKT();
            default:
                return null;
        }
    };

    TC.wrap.Map.prototype.exportFeatures = function (features, options) {
        var self = this;
        options = options || {};
        var nativeStyle = createNativeStyle({
            styles: self.parent.options.styles
        });
        var olFeatures = features.map(function (elm) {
            var result = elm.wrap.feature.clone();
            // Si la feature no tiene estilo propio le ponemos el definido por la API
            if (!result.getStyle()) {
                result.setStyle(nativeStyle);
            }
            // Miramos si tiene texto, en cuyo caso la features se clona para no contaminar la feature orignal 
            // y al clon se le añade el texto como atributo (necesario para exportar etiquetas en KML y GPX)
            const text = getNativeFeatureStyle(result).getText();
            if (text) {
                result.setProperties({
                    name: text.getText()
                });
            }
            return result;
        });
        var format = getFormatFromName(options.format);

        if (format instanceof ol.format.KML) {
            // KML no tiene estilo para puntos aparte del de icono. Para puntos sin icono creamos uno en SVG.
            olFeatures = olFeatures
                .map(function (feature) {
                    const geom = feature.getGeometry();
                    if (geom instanceof ol.geom.Point) {
                        // Si el punto no tiene icono, creamos uno nuevo con un icono generado como data URI a partir del estilo
                        var style = getNativeFeatureStyle(feature);
                        const shape = style.getImage();
                        if (shape instanceof ol.style.RegularShape) {
                            const radius = shape.getRadius();
                            const stroke = shape.getStroke();
                            const strokeWidth = stroke.getWidth();
                            const diameter = (2 * radius) + strokeWidth + 1;
                            const position = diameter / 2;
                            const canvas = document.createElement('canvas');
                            canvas.width = diameter;
                            canvas.height = diameter;
                            const vectorContext = ol.render.toContext(canvas.getContext('2d'), {
                                size: [diameter, diameter]
                            });
                            const text = style.getText();
                            style = style.clone();
                            style.setText(); // Quitamos el texto para que no salga en el canvas
                            vectorContext.setStyle(style);
                            vectorContext.drawGeometry(new ol.geom.Point([position, position]));
                            const newFeature = new ol.Feature(geom);
                            newFeature.setProperties(feature.getProperties());
                            newFeature.setStyle(new ol.style.Style({
                                image: new ol.style.Icon({
                                    src: canvas.toDataURL('image/png')
                                }),
                                text: text
                            }));
                            return newFeature;
                        }
                    }
                    return feature;
                });
            // KML no pone etiquetas a líneas y polígonos. En esos casos ponemos un punto con la etiqueta.
            const pointsToAdd = [];
            olFeatures.forEach(function (feature) {
                var style = getNativeFeatureStyle(feature);
                const geometry = feature.getGeometry();
                const text = style.getText();
                var point;
                if (text) {
                    switch (true) {
                        case geometry instanceof ol.geom.LineString:
                            point = new ol.geom.Point(geometry.getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.Polygon:
                            point = geometry.getInteriorPoint();
                            break;
                        case geometry instanceof ol.geom.MultiLineString:
                            // Seleccionamos la línea más larga
                            const lineStrings = geometry.getLineStrings();
                            var maxLength = -1;
                            point = new ol.geom.Point(lineStrings[lineStrings
                                .map(function (line) {
                                    return line.getLength();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxLength) {
                                        maxLength = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.MultiPolygon:
                            // Seleccionamos el polígono más grande
                            const polygons = geometry.getPolygons();
                            var maxArea = -1;
                            point = polygons[polygons
                                .map(function (polygon) {
                                    return polygon.getArea();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxArea) {
                                        maxArea = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getInteriorPoint();
                            break;
                        default:
                            break;
                    }
                    if (point) {
                        const newFeature = new ol.Feature(point);
                        newFeature.setStyle(new ol.style.Style({
                            text: text.clone(),
                            image: new ol.style.Icon({
                                crossOrigin: 'anonymous',
                                src: TC.apiLocation + 'TC/css/img/transparent.gif'
                            })
                        }));
                        pointsToAdd.push(newFeature);
                    }
                }
            });
            if (pointsToAdd.length) {
                olFeatures = olFeatures.concat(pointsToAdd);
            }
        }

        if (format instanceof ol.format.GMLBase) {
            format.hasZ = features[0].getGeometryStride() >= 3;
            // Quitamos los espacios en blanco de los nombres de atributo en las features: no son válidos en GML.
            olFeatures = olFeatures.map(function (f) {
                return f.clone();
            });
            olFeatures.forEach(function (f) {
                const values = f.values_
                const keysToChange = [];
                for (var key in values) {
                    if (key.indexOf(' ') >= 0) {
                        keysToChange.push(key);
                    }
                }
                keysToChange.forEach(function (key) {
                    // Quitamos espacios en blanco y evitamos que empiece por un número
                    var newKey = key.replace(/ /g, '_');
                    if (/^\d/.test(newKey)) {
                        newKey = '_' + newKey;
                    }
                    if (key !== newKey) {
                        while (values[newKey] !== undefined) {
                            newKey += '_';
                        }
                    }
                    values[newKey] = values[key];
                    delete values[key];
                });
            });

            //Apañamos para que el GML sea válido. Si no lo hacemos, con IE, en ol-debug.js:36514 da un error porque node.localName no existe.
            format.featureNS = "sitna";
            format.featureType = "feature";
            var featuresNode = format.writeFeaturesNode(olFeatures, {
                featureProjection: self.parent.crs
            });

            var featureCollectionNode = ol.xml.createElementNS('http://www.opengis.net/gml',
                'FeatureCollection');
            featureCollectionNode.setAttributeNS('http://www.w3.org/2001/XMLSchema-instance',
                'xsi:schemaLocation', format.schemaLocation);
            featuresNode.removeAttribute('xmlns:xsi');
            featuresNode.removeAttribute('xsi:schemaLocation');
            featureCollectionNode.appendChild(featuresNode);
            //ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',
            //    'xsi:schemaLocation', this.schemaLocation);
            //return featureCollectionNode.outerHTML;
        }

        if (format instanceof ol.format.GPX) {
            // Queremos exportar tracks en vez de routes. OpenLayers exporta LineStrings como routes y MultiLineStrings como tracks.
            olFeatures = olFeatures.map(function (f) {
                const geom = f.getGeometry();
                if (geom instanceof ol.geom.LineString) {
                    f = f.clone();
                    f.setGeometry(new ol.geom.MultiLineString([geom.getCoordinates()]));
                }
                return f;
            });
        }

        var result = format.writeFeatures(olFeatures, {
            dataProjection: 'EPSG:4326',
            featureProjection: self.parent.crs
        });
        if (format instanceof ol.format.GPX) {
            // Este formato no procesa bien las elevaciones cuando son nulas. Hemos hecho un preproceso para transformarlas en NaN y ahora hay que eliminarlas.
            result = result.replace(/<ele>NaN<\/ele>/g, '');
        }
        return result;
    };

    var isFileDrag = function (e) {
        for (var i = 0, len = e.dataTransfer.types.length; i < len; i++) {
            if (e.dataTransfer.types[i] === 'Files') {
                return true;
            }
        }
        return false;
    };

    var handleDragEnter = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            self.getMap()._wrap.parent.div.classList.add(TC.Consts.classes.DROP);
            e.preventDefault();
            e.stopPropagation();
        }
    };

    var handleDragExit = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            var map = self.getMap()._wrap.parent;
            if (e.target === self.target) {
                map.div.classList.remove(TC.Consts.classes.DROP);
            }
        }
    };

    TC.wrap.Map.prototype.enableDragAndDrop = function (options) {
        var self = this;
        var opts = options || {};
        var ddOptions = {
            formatConstructors: [
                ol.format.KMLCustom,
                ol.format.GPXCustom,
                ol.format.GML3CRS84,
                ol.format.GML2CRS84,
                ol.format.GML3,
                ol.format.GML2,
                ol.format.GeoJSON,
                function () {
                    return new ol.format.WKT({
                        splitCollection: true
                    });
                },
                ol.format.TopoJSON
            ]
        };
        if (opts.dropTarget) {
            ddOptions.target = TC.getDiv(opts.dropTarget);
        }
        else {
            ddOptions.target = self.parent.div;
        }
        var ddInteraction = new ol.interaction.DragAndDrop(ddOptions);
        ddInteraction.on('addfeatures', function (e) {
            var featurePromises = e.features ? e.features.map(function (elm) {
                if (!elm.getId()) {
                    elm.setId(TC.getUID());
                }
                return TC.wrap.Feature.createFeature(elm);
            }) : [];
            Promise.all(featurePromises).then(function (features) {
                var li = self.parent.getLoadingIndicator();
                if (li) {
                    li.removeWait(self._featureImportWaitId);
                }
                if (features.length && !(features.some(function (feature) {
                    return !feature.geometry
                }))) {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORT, {
                        features: features, fileName: e.file.name, dropTarget: e.target.target
                    });
                }
                else {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {
                        file: e.file
                    });
                }
            });
        });
        if (opts.once) {
            ddInteraction.map_ = self.map;
        }
        else {
            self.map.addInteraction(ddInteraction);
            var dropArea = ddInteraction.target ? ddInteraction.target : self.map.getViewport();

            //URI: SI existe el objeto JSZIP modificio el metodo handleResult_ que es el maneja el drop de un fichero en el mapa
            if (window.JSZip) {
                var processZipFile = function () {
                    //URI: Me guardo la función original y defino la mía
                    const originalFnc = ddInteraction.handleResult_;

                    ddInteraction.handleResult_ = function (file, evt) {
                        var self = this;
                        //URI: si el fichero es ZIP o KMZ lo proceso sino llamo a la función original con los datos originales
                        if (file.type === "application/x-zip-compressed" || file.type === "application/vnd.google-earth.kmz") {
                            (async function (file) {
                                try {
                                    var zipContent = await JSZip.loadAsync(file);
                                }
                                catch (err) {
                                    throw err;
                                }
                                //URI:Leo el contenido del zip e itero por cada fichero
                                zipContent.forEach(async function (fileName, zip) {
                                    //TODO: Desestimar fichro no geográficos
                                    zip.async("blob").then(function (data) {
                                        //URI: Me creo un fichero vacío con el nombre solo. El contenido lo manejoa a contunuación
                                        var newFile = new File([], fileName);
                                        //URI: El contenid del fichero lo manejo con un filereader que es lo que usa internamente la función original para leer las features 
                                        var reader = new FileReader();
                                        reader.onload = function (evt) {
                                            //URI: una vez que he cargado los datos nuevos en el filereader llamo a la función original pasando el nuevo File y el nuevo FileReader
                                            originalFnc.apply(self, [newFile, evt]);
                                        };
                                        reader.readAsText(data);
                                    });
                                });
                            })(file);
                        }
                        else {
                            originalFnc.apply(self, [file, evt]);
                        }
                    }
                }
                if (window.JSZip instanceof Promise)
                    window.JSZip.then(processZipFile);
                else
                    processZipFile();
            }

            // Añadidos gestores de eventos para mostrar el indicador visual de drop.
            var handleDrop = function (e) {
                if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
                    var map = self.parent;
                    if (ddInteraction.target === e.target) {
                        var li = map.getLoadingIndicator();
                        if (li) {
                            self._featureImportWaitId = li.addWait();
                        }
                        e.stopPropagation();
                    }
                    else {
                        e.preventDefault();
                    }
                    map.div.classList.remove(TC.Consts.classes.DROP);
                }
            };
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragleave',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragend',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragexit',
                    handleDragExit, ddInteraction)
            );
            document.addEventListener('mouseenter', function (e) {
                if (!e.buttons) {
                    self.parent.div.classList.remove(TC.Consts.classes.DROP);
                }
            }, false);
            self.ddEnabled = true;
        }
        return ddInteraction;
    };

    TC.wrap.Map.prototype.loadFiles = function (files, options) {
        var self = this;
        var ddInteraction;
        if (self.ddEnabled) {
            self.map.getInteractions().forEach(function (elm) {
                if (elm instanceof ol.interaction.DragAndDrop) {
                    ddInteraction = elm;
                }
            });
        }
        else {
            ddInteraction = self.enableDragAndDrop({
                once: true
            });
        }

        if (ddInteraction && options) {
            var currentTarget = ddInteraction.target;
            ddInteraction.target = options.control;
            const undoTarget = function (e) {
                ddInteraction.target = currentTarget;

                self.parent.off(TC.Consts.event.FEATURESIMPORT, undoTarget);
            };
            self.parent.on(TC.Consts.event.FEATURESIMPORT, undoTarget);
        }

        var li = self.parent.getLoadingIndicator();
        if (li) {
            self._featureImportWaitId = li.addWait();
        }
        for (let i = 0, ii = files.length; i < ii; ++i) {
            const file = files.item(i);
            const reader = new FileReader();
            reader.addEventListener(ol.events.EventType.LOAD, ddInteraction.handleResult_.bind(ddInteraction, file));
            reader.readAsText(file);
        }
    };

    /*
     *  getVisibility: gets the OpenLayers layer visibility
     *  Result: boolean
     */
    TC.wrap.Layer.prototype.getVisibility = function () {
        const self = this;
        var result = false;
        if (self.layer) {
            result = self.layer.getVisible();
        }
        return result;
    };

    /*
     *  setVisibility: Sets the OpenLayers layer visibility
     *  Parameter: boolean
     */
    TC.wrap.Layer.prototype.setVisibility = function (visible) {
        const self = this;
        self.getLayer().then(function (layer) {
            layer.setVisible(visible);
        });
    };

    TC.wrap.Layer.prototype.isNative = function (layer) {
        return layer instanceof ol.layer.Layer;
    };

    TC.wrap.Layer.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};
        const layer = self.parent;
        if (layer.map) {
            const unitRatio = getUnitRatio.call(self, {
                crs: options.crs,
                extentInDegrees: ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326')
            });

            var resolutions = layer.getResolutions();
            if (resolutions && resolutions.length) {
                resolutions = resolutions.map(function (r) {
                    return r / unitRatio;
                });
                layer.wrap.layer.setMaxResolution(resolutions[0]);
                layer.wrap.layer.setMinResolution(resolutions[resolutions.length - 1]);
            }
            else {
                // de metros a grados
                if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.METERS && (!ol.proj.get(options.crs).getUnits() || ol.proj.get(options.crs).getUnits() === ol.proj.Units.DEGREES)) {

                    if (layer.minResolution) {
                        layer.minResolution = layer.minResolution / unitRatio;
                        self.layer.setMinResolution(layer.minResolution);
                    }

                    if (layer.maxResolution) {
                        layer.maxResolution = layer.maxResolution / unitRatio;
                        self.layer.setMaxResolution(layer.maxResolution);
                    }

                    // de grados a metros
                } else if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.DEGREES && ol.proj.get(options.crs).getUnits() === ol.proj.Units.METERS) {
                    var metersPerDegree = TC.Util.getMetersPerDegree(ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326'));

                    if (layer.minResolution) {
                        layer.minResolution = layer.minResolution * metersPerDegree;
                        self.layer.setMinResolution(layer.minResolution);
                    }

                    if (layer.maxResolution) {
                        layer.maxResolution = layer.maxResolution * metersPerDegree;
                        self.layer.setMaxResolution(layer.maxResolution);
                    }
                }
            }
        }
    };

    TC.wrap.layer.Raster.prototype.WmsParser = ol.format.WMSCapabilities;

    TC.wrap.layer.Raster.prototype.WmtsParser = ol.format.WMTSCapabilities;

    TC.wrap.Layer.prototype.addCommonEvents = function (layer) {
        var self = this;
        layer.on('change:visible', function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.LAYERVISIBILITY, {
                    layer: self.parent
                });
            }
        }, self.parent.map);
    };

    TC.wrap.layer.Raster.prototype.getGetMapUrl = function () {
        var result = null;
        var self = this;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                var dcpType = self.parent.capabilities.Capability.Request.GetMap.DCPType;
                for (var i = 0; i < dcpType.length; i++) {
                    if (dcpType[i].HTTP && dcpType[i].HTTP.Get) {
                        result = dcpType[i].HTTP.Get.OnlineResource;
                        break;
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = self.parent.capabilities.OperationsMetadata.GetTile.DCP.HTTP.Get[0].href;
                break;
            default:
                break;
        }
        const fragment = document.createDocumentFragment();
        const textarea = document.createElement('textarea');
        fragment.appendChild(textarea);
        textarea.innerHTML = result;
        result = textarea.textContent;
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfoFormats = function () {
        var result = null;
        var c = this.parent.capabilities;
        if (c.Capability && c.Capability.Request.GetFeatureInfo) {
            result = c.Capability.Request.GetFeatureInfo.Format;
        }
        return result;
    };

    TC.wrap.layer.Raster.infoFormatPreference = [
        'application/json',
        'application/vnd.ogc.gml/3.1.1',
        'application/vnd.ogc.gml',
        'application/vnd.esri.wms_featureinfo_xml',
        'text/html',
        'text/plain',
        'text/xml'
    ];

    TC.wrap.layer.Raster.prototype.getWMTSLayer = function () {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents) {
            for (var i = 0; i < capabilities.Contents.Layer.length; i++) {
                var layer = capabilities.Contents.Layer[i];
                for (var j = 0; j < layer.TileMatrixSetLink.length; j++) {
                    if (self.parent.options.matrixSet === layer.TileMatrixSetLink[j].TileMatrixSet) {
                        result = layer;
                        break;
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getTileMatrix = function (matrixSet) {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents && capabilities.Contents.TileMatrixSet) {
            for (var i = 0; i < capabilities.Contents.TileMatrixSet.length; i++) {
                var tms = capabilities.Contents.TileMatrixSet[i];
                if (tms.Identifier === matrixSet) {
                    result = tms.TileMatrix;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getScaleDenominators = function (node) {
        var result = [];
        var self = this;
        if (node.ScaleDenominator) {
            result = [node.ScaleDenominator, node.ScaleDenominator];
        }
        else {
            if (node.MinScaleDenominator || node.MaxScaleDenominator) {
                result = [node.MaxScaleDenominator, node.MinScaleDenominator];
            }
        }
        // Contemplamos el caso de una capa sin nombre: sus escalas válidas serán las de sus hijas.
        if (!result.length && !self.getName(node)) {
            var children = self.getLayerNodes(node);
            var max = -Infinity, min = Infinity;
            for (var i = 0, len = children.length; i < len; i++) {
                var childDenominators = self.getScaleDenominators(children[i]);
                if (childDenominators[0] > max) {
                    max = childDenominators[0];
                }
                if (childDenominators[1] < min) {
                    min = childDenominators[1];
                }
            }
            if (max > -Infinity && min < Infinity) {
                result = [max, min];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAttribution = function () {
        const self = this;
        const result = {};
        const capabilities = TC.capabilities[self.parent.url];

        if (capabilities) {
            if (capabilities.ServiceProvider) {
                result.name = capabilities.ServiceProvider.ProviderName.trim();
                result.site = capabilities.ServiceProvider.ProviderSite;
                if (result.site.href && result.site.href.trim().length > 0) {
                    result.site = result.site.href;
                }
            }
            else if (capabilities.ServiceIdentification) {
                result.name = capabilities.ServiceIdentification.Title.trim();
            }
            else {
                result.name = capabilities.Service.Title.trim();
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfo = function (name) {
        var self = this;
        var result = {};
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Capability) {
            var layerNodes = self.getAllLayerNodes();
            for (var i = 0; i < layerNodes.length; i++) {
                var l = layerNodes[i];
                if (self.parent.compareNames(self.getName(l), name)) {
                    if (l.Title) {
                        result.title = l.Title;
                    }
                    if (l.Abstract) {
                        result['abstract'] = l.Abstract;
                    }
                    result.legend = [];

                    var _process = function (value) {
                        var legend = this.getLegend(value);

                        if (legend.src)
                            result.legend.push({
                                src: legend.src, title: value.Title
                            });
                    };

                    var _traverse = function (o, func) {
                        if (o.Layer && o.Layer.length > 0) {
                            for (var i in o.Layer) {
                                //bajar un nivel en el árbol
                                _traverse(o.Layer[i], func);
                            }
                        } else {
                            func.apply(self, [o]);
                        }
                    };

                    //Obtenemos todas las leyendas de la capa o grupo de capas
                    _traverse(l, _process);

                    if (l.MetadataURL && l.MetadataURL.length) {
                        result.metadata = [];
                        for (var j = 0; j < l.MetadataURL.length; j++) {
                            var md = l.MetadataURL[j];
                            result.metadata.push({
                                format: md.Format, type: md.type, url: md.OnlineResource
                            });
                        }
                    }
                    result.queryable = l.queryable;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceType = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Capability.Request && capabilities.Capability.Request.GetMap) {
            result = TC.Consts.layerType.WMS;
        }
        else if (capabilities.OperationsMetadata && capabilities.OperationsMetadata.GetTile) {
            result = TC.Consts.layerType.WMTS;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceTitle = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Service) {
            result = capabilities.Service.Title;
        }
        else if (capabilities.ServiceIdentification) {
            result = capabilities.ServiceIdentification.Title;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getRootLayerNode = function () {
        var self = this;
        var result;
        if (self.getServiceType() === TC.Consts.layerType.WMS) {
            result = self.parent.capabilities.Capability.Layer;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getName = function (node, ignorePrefix) {
        var result = node.Name;
        if (result && ignorePrefix) {
            var idx = result.indexOf(':');
            if (idx >= 0) {
                result = result.substr(idx + 1);
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getIdentifier = function (node) {
        return node.Identifier;
    };

    TC.wrap.layer.Raster.prototype.getLayerNodes = function (node) {
        var result = node.Layer;
        if (!Array.isArray(result)) {
            if (result) {
                result = [result];
            }
            else {
                result = [];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAllLayerNodes = function () {
        var self = this;
        if (!self._layerList) {
            switch (self.getServiceType()) {
                case TC.Consts.layerType.WMS:
                    var getNodeArray = function getNodeArray(node) {
                        var r = [node];
                        var children = self.getLayerNodes(node);
                        for (var i = 0; i < children.length; i++) {
                            r = r.concat(getNodeArray(children[i]));
                        }
                        return r;
                    };
                    var root = self.getRootLayerNode();
                    self._layerList = root ? getNodeArray(root) : [];
                    break;
                case TC.Consts.layerType.WMTS:
                    self._layerList = self.parent.capabilities.Contents.Layer.slice();
                    break;
                default:
                    self._layerList = [];
                    break;
            }
        }
        return self._layerList;
    };

    TC.wrap.layer.Raster.prototype.normalizeLayerNode = function (node) {
        return node;
    };

    TC.wrap.layer.Raster.prototype.normalizeCapabilities = function (capabilities) {
        return capabilities;
    };


    TC.wrap.layer.Raster.prototype.getLegend = function (node) {
        var result = {};
        var styles = node.Style;
        if (styles && styles.length) {
            if (styles.length && styles[0].LegendURL && styles[0].LegendURL.length) {
                var legend = styles[0].LegendURL[0];

                const fragment = document.createDocumentFragment();
                const textarea = document.createElement('textarea');
                fragment.appendChild(textarea);
                textarea.innerHTML = legend.OnlineResource;
                result.src = textarea.textContent;
                // Eliminado porque GeoServer miente con el tamaño de sus imágenes de la leyenda
                //if (legend.size) {
                //    result.width = legend.size[0];
                //    result.height = legend.size[1];
                //}
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.isCompatible = function (crs) {
        var self = this;
        var result = true;
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        var names = layer.names.slice(0);
                        var _isCompatible = function _isCompatible(nodes, name, inCrs) {
                            var r = false;
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    var n = nodes[i];
                                    const itemCRS = n.CRS || n.SRS;
                                    const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                    var isIn = inCrs || crsList.indexOf(crs) >= 0;
                                    if (layer.compareNames(self.getName(n), name)) {
                                        if (isIn) {
                                            r = true;
                                        }
                                        break;
                                    }
                                    else if (_isCompatible(n.Layer, name, isIn)) {
                                        r = true;
                                        break;
                                    }
                                }
                            }
                            return r;
                        };
                        while (names.length > 0) {
                            if (!_isCompatible([layer.capabilities.Capability.Layer], names.pop())) {
                                result = false;
                                break;
                            }
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = false;
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tms = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0; i < tms.length; i++) {
                        if (tms[i].Identifier === layer.options.matrixSet) {
                            result = TC.Util.CRSCodesEqual(crs, tms[i].SupportedCRS);
                            break;
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleCRS = function () {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        const crsLists = layer.names
                            .map(function (name) {
                                return layer
                                    .getNodePath(name) // array de nodos
                                    .map(function (node) {
                                        const itemCRS = node.CRS || node.SRS || [];
                                        const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                        return Array.isArray(crsList) ? crsList : [crsList];
                                    }) // array de arrays de crs
                                    .reduce(function (prev, cur) {
                                        if (prev.length === 0) {
                                            return cur;
                                        }
                                        cur.forEach(function (elm) {
                                            if (prev.indexOf(elm) < 0) {
                                                prev[prev.length - 1] = elm;
                                            }
                                        });// array con todos los crs
                                        return prev;
                                    }, []);
                            });

                        if (crsLists.length === 1) {
                            result = crsLists[0];
                        } else {
                            const otherCrsLists = crsLists.slice(1);
                            result = crsLists[0].filter(function (elm) {
                                return otherCrsLists.every(function (crsList) {
                                    return crsList.indexOf(elm) >= 0;
                                });
                            });
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents) {
                    layer.capabilities.Contents.Layer
                        .filter(function (l) {
                            return l.Identifier === layer.layerNames;
                        })  // La capa de interés
                        .forEach(function (l) {
                            const tileMatrixSets = l.TileMatrixSetLink
                                .map(function (tmsl) {
                                    return tmsl.TileMatrixSet;
                                });
                            result = layer.capabilities.Contents.TileMatrixSet
                                .filter(function (tms) {
                                    return tileMatrixSets.indexOf(tms.Identifier) >= 0;
                                }) // TileMatrixSets asociados a la capa de interés
                                .map(function (tms) {
                                    return tms.SupportedCRS;
                                });
                        });
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleLayers = function (crs) {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    var _fnrecursive = function (item, crs, inCrs) {
                        var crsToCheck = item.CRS || item.SRS;
                        var itemCRS = Array.isArray(crsToCheck) ? crsToCheck : [crsToCheck];
                        var isIn = inCrs || itemCRS.indexOf(crs) >= 0;
                        if (isIn && item.Name) result[result.length] = item.Name;
                        if (item.Layer) {
                            for (var i = 0; i < item.Layer.length; i++) {
                                _fnrecursive(item.Layer[i], crs, isIn);
                            }
                        }
                    }
                    _fnrecursive(layer.capabilities.Capability.Layer, crs);
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tmsList = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0, ii = tmsList.length; i < ii; i++) {
                        var tms = tmsList[i];
                        if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                            var tmsIdentifier = tms.Identifier;
                            var layerList = layer.capabilities.Contents.Layer;
                            for (var j = 0, jj = layerList.length; j < jj; j++) {
                                var tmsLinkList = layerList[j].TileMatrixSetLink;
                                for (var k = 0, kk = tmsLinkList.length; k < kk; k++) {
                                    if (tmsLinkList[k].TileMatrixSet === tmsIdentifier) {
                                        result[result.length] = layerList[j].Identifier;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleMatrixSets = function (crs) {
        var self = this;
        var result = [];
        normalizeProjection({
            crs: crs
        });
        var layer = self.parent;
        if (self.getServiceType() === TC.Consts.layerType.WMTS) {
            var layerList = layer.capabilities.Contents.Layer;
            var tmsList = layer.capabilities.Contents.TileMatrixSet;
            for (var i = 0, ii = layerList.length; i < ii; i++) {
                if (layer.layerNames === layerList[i].Identifier) {
                    var tmsLinkList = layerList[i].TileMatrixSetLink;
                    for (var j = 0, jj = tmsLinkList.length; j < jj; j++) {
                        var tmsLink = tmsLinkList[j];
                        for (var k = 0, kk = tmsList.length; k < kk; k++) {
                            var tms = tmsList[k];
                            if (tms.Identifier === tmsLink.TileMatrixSet) {
                                if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                                    result[result.length] = tms.Identifier;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.setWMTSUrl = function () {
        var self = this;

        self.getLayer().then(function (l) {
            self.parent.options = self.parent.options || {};
            var urls = l.getSource().getUrls();
            self.parent.options.urlPattern = urls[urls.length - 1];
        });
    };

    TC.wrap.layer.Raster.prototype.createWMSLayer = function (url, params, options) {
        const self = this;
        var result = null;

        var source = new ol.source.ImageWMS({
            url: url,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            params: params,
            extent: TC.Cfg.initialExtent,
            ratio: TC.Cfg.imageRatio,
            imageLoadFunction: self.parent.getImageLoad.bind(self.parent)
        });

        source.on('imageloadstart', function (e) {
            self.trigger(TC.Consts.event.BEFORETILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on('imageloadend', function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on('imageloaderror', function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });


        var layerOptions = {
            visible: !!params.LAYERS.length || (options && options.method && options.method === 'POST'), //Las capas de temáticos cargadas por POST no tienen el atributo LAYERS
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }
        result = new ol.layer.Image(layerOptions);

        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    var createWmtsSource = function (options) {
        var self = this;
        var result = null;
        var sourceOptions = ol.source.WMTS.optionsFromCapabilities(self.parent.capabilities, {
            layer: options.layerNames,
            matrixSet: options.matrixSet,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            requestEncoding: options.encoding,
            format: options.format,
        });
        var https = 'https:';

        if (sourceOptions) {
            if (location.protocol === https) {
                sourceOptions.urls = sourceOptions.urls.map(function (elm) {
                    return elm.replace('http:', https);
                });
            }

            sourceOptions.crossOrigin = options.map ? options.map.options.crossOrigin : undefined;

            result = new ol.source.WMTS(sourceOptions);
            result.setTileLoadFunction(self.parent.getImageLoad.bind(self.parent));

            result.on(TILELOADSTART, function (e) {
                self.trigger(TC.Consts.event.BEFORETILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(TILELOADEND, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(TILELOADERROR, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });

            var prevFn = result.getResolutions.bind(result);
            result.getResolutions = function () {
                var resolutions = prevFn();
                var matrix = self.parent.getLimitedMatrixSet();
                //esto está mal, porque matrix podría empezar más abajo (tener recortado por ambos lados)
                if (matrix && matrix.length) {
                    var ix = matrix[0].matrixIndex;
                    resolutions = resolutions.slice(ix, matrix.length + ix);
                }

                return resolutions;
            };
        }

        return result;
    };

    TC.wrap.layer.Raster.prototype.createWMTSLayer = function (options) {
        const self = this;
        var result = null;

        var source = createWmtsSource.call(self, options);

        if (source) {
            var layerOptions = {
                source: source
            };
            if (options.minResolution) {
                layerOptions.minResolution = options.minResolution;
            }
            if (options.maxResolution) {
                layerOptions.maxResolution = options.maxResolution;
            }
            result = new ol.layer.Tile(layerOptions);
            result._wrap = self;

            self.addCommonEvents(result);

            var resolutions = source.getResolutions();
            //Este +1 tan chungo es porque, en el caso en que la resolución del mapa es igual a la máxima del layer, openLayers lo oculta
            result.setMaxResolution(resolutions[0] + 1);
            result.setMinResolution(resolutions[resolutions.length - 1]);
        }

        return result;
    };


    /*
     *  getParams: Gets the WMS layer getmap parameters
     *  Returns: object
     */
    TC.wrap.layer.Raster.prototype.getParams = function () {
        return this.layer.getSource().getParams();
    };

    /*
     *  setParams: Sets the WMS layer getmap parameters
     *  Parameter: object
     */
    TC.wrap.layer.Raster.prototype.setParams = function (params) {
        this.layer.getSource().updateParams(params);
    };

    TC.wrap.layer.Raster.prototype.setMatrixSet = function (matrixSet) {
        const self = this;
        const oldResolutions = self.layer.getSource().getResolutions();
        if (self.parent.type === TC.Consts.layerType.WMTS) {
            const newSource = createWmtsSource.call(self, TC.Util.extend({}, self.parent.options, { matrixSet: matrixSet }));
            const newResolutions = newSource.getResolutions();
            const newMaxResolution = newResolutions[0]
            const newMinResolution = newResolutions[newResolutions.length - 1];
            self.layer.setMaxResolution(newMaxResolution);
            self.layer.setMinResolution(newMinResolution);
            if (self.parent.minResolution) {
                self.parent.minResolution = newMinResolution;
            }
            if (self.parent.maxResolution) {
                self.parent.maxResolution = newMaxResolution;
            }
            self.layer.setSource(newSource);
        }
    };

    TC.wrap.layer.Raster.prototype.getResolutions = function () {
        if (this.layer.getSource) {
            var ts = this.layer.getSource();
            if (ts.getResolutions) return ts.getResolutions();
            else return [];
        }
        else {
            return [];
        }
    };

    TC.wrap.layer.Raster.prototype.setResolutions = function (resolutions) {
        if (this.layer.getSource) {
            var ts = this.layer.getSource();
            if (ts.resolutions_) {
                ts.resolutions_ = resolutions;
            }
            else if (ts.tileGrid) {
                ts.tileGrid.resolutions_ = resolutions;
            }
        }
    };

    TC.wrap.layer.Raster.prototype.reloadSource = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer.getSource) {
                self.layer.getSource().refresh();
                resolve();
            }
            else {
                reject();
            }
        });
    };

    TC.wrap.Geometry = {
        getNearest: function (point, candidates) {
            var pline = new ol.geom.LineString(candidates);
            return pline.getClosestPoint(point);
        }
    };

    // En OL3 la imagen tiene el tamaño original. Escalamos si hace falta.
    var setScaleFunction = function (imageStyle, iconWidth, olFeat) {
        if (imageStyle) {
            var setScaleForWidth = function (imgWidth) {
                var markerWidth = (olFeat && olFeat._wrap ? olFeat._wrap.parent.options.width : null) || iconWidth;
                if (markerWidth < imgWidth) {
                    var factor = markerWidth / imgWidth;
                    imageStyle.setScale(factor);
                }
            };
            var imageSize = imageStyle.getSize();
            if (imageSize) {
                setScaleForWidth(imageSize[0]);
            }
            else {
                var img = imageStyle.getImage();
                if (img.naturalWidth) {
                    setScaleForWidth(img.naturalWidth);
                }
                else {
                    const fragment = document.createDocumentFragment();
                    const img = document.createElement('img');
                    img.src = imageStyle.getSrc();
                    img.addEventListener('load', function () {
                        setScaleForWidth(this.naturalWidth);
                    });
                    fragment.appendChild(img);
                }
            }
        }
    };

    var getStyleValue = function (property, feature) {
        var result = property;
        var olFeat = feature && feature.wrap && feature.wrap.feature;
        if (typeof property === 'string') {
            var match = property.match(/^\$\{(.+)\}$/);
            if (match && olFeat) {
                // Permitimos el formato ${prop.subprop.subsubprop}
                var m = match[1].split('.');
                var r = olFeat.getProperties();
                for (var i = 0; i < m.length && r !== undefined; i++) {
                    r = r[m[i]];
                }
                if (r === undefined) {
                    r = feature.data;
                    for (var i = 0; i < m.length && r !== undefined; i++) {
                        r = r[m[i]];
                    }
                }
                result = r;
            }
        }
        else if (TC.Util.isFunction(property)) {
            result = property(feature);
        }
        return result;
    };

    // Transformación de opciones de estilo en un estilo nativo OL3.
    var createNativeStyle = function (options, olFeat) {
        var nativeStyleOptions = {
        };

        var feature;
        var isPoint, isLine, isPolygon;
        if (olFeat) {
            switch (olFeat.getGeometry().getType()) {
                case 'Point':
                case 'MultiPoint':
                    isPoint = true;
                    break;
                case 'LineString':
                case 'MultiLineString':
                    isLine = true;
                    break;
                case 'Polygon':
                case 'MultiPolygon':
                    isPolygon = true;
                    break;
            }
            if (olFeat._wrap) {
                feature = olFeat._wrap.parent;
            }
            else {
                // Si la API SITNA no ha completado su feature, creamos un mock-up para que no fallen las funciones de estilo
                feature = {
                    id: TC.wrap.Feature.prototype.getId.call({
                        feature: olFeat
                    }), // GLS añado el id de la feature para poder filtrar por la capa a la cual pertenece                    
                    features: olFeat.get('features'),
                    getData: function () {
                        return TC.wrap.Feature.prototype.getData.call({
                            feature: olFeat
                        });
                    }
                };


            }
        }
        var isCluster = feature && Array.isArray(feature.features) && feature.features.length > 1 && options.cluster;
        var styles;
        if (isCluster) {
            styles = TC.Util.extend(true, {}, TC.Cfg.styles.cluster, options.cluster.styles);
        }
        else {
            styles = options.styles || TC.Cfg.styles;
        }

        var styleOptions = {};
        if (styles.line && (isLine || !olFeat)) {
            styleOptions = styles.line;
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.line.strokeColor, feature),
                width: getStyleValue(styles.line.strokeWidth, feature),
                lineDash: styles.line.lineDash
            });
        }

        if (styles.polygon && (isPolygon || !olFeat)) {
            styleOptions = styles.polygon;
            nativeStyleOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styles.polygon.fillColor, feature), getStyleValue(styles.polygon.fillOpacity, feature))
            });
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.polygon.strokeColor, feature),
                width: getStyleValue(styles.polygon.strokeWidth, feature),
                lineDash: styles.polygon.lineDash
            });
        }

        if (styles.point && (isPoint || !olFeat)) {
            styleOptions = styles.point;
            var circleOptions = {
                radius: getStyleValue(styleOptions.radius, feature) ||
                (getStyleValue(styleOptions.height, feature) + getStyleValue(styleOptions.width, feature)) / 4
            };
            if (styleOptions.fillColor) {
                circleOptions.fill = new ol.style.Fill({
                    color: getRGBA(getStyleValue(styleOptions.fillColor, feature), getStyleValue(styleOptions.fillOpacity, feature))
                });
            }
            if (styleOptions.strokeColor) {
                circleOptions.stroke = new ol.style.Stroke({
                    color: getStyleValue(styleOptions.strokeColor, feature),
                    width: getStyleValue(styleOptions.strokeWidth, feature),
                    lineDash: styleOptions.lineDash
                });
            }

            if (!isNaN(circleOptions.radius))
                nativeStyleOptions.image = new ol.style.Circle(circleOptions);
        }

        if (styleOptions.label) {
            nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
        }

        if (styles.marker && (isPoint || !olFeat)) {
            styleOptions = styles.marker;
            var ANCHOR_DEFAULT_UNITS = 'fraction';
            if (styleOptions.url) {
                nativeStyleOptions.image = new ol.style.Icon({
                    crossOrigin: 'anonymous',
                    anchor: styleOptions.anchor,
                    anchorXUnits: styleOptions.anchorXUnits || ANCHOR_DEFAULT_UNITS,
                    anchorYUnits: styleOptions.anchorYUnits || ANCHOR_DEFAULT_UNITS,
                    src: styleOptions.url
                });
                nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
            }
        }

        return [new ol.style.Style(nativeStyleOptions)];
    };

    const createNativeTextStyle = function (styleObj, feature) {
        if (!styleObj || !styleObj.label) {
            return;
        }

        const textOptions = {
            text: '' + getStyleValue(styleObj.label, feature),
        };
        //const olGeom = feature.wrap.feature.getGeometry();
        //if (olGeom instanceof ol.geom.LineString || olGeom instanceof ol.geom.MultiLineString) {
        //    textOptions.placement = ol.style.TextPlacement.LINE;
        //}
        if (styleObj.fontSize) {
            textOptions.font = getStyleValue(styleObj.fontSize, feature) + 'pt sans-serif';
        }
        if (styleObj.angle) {
            textOptions.rotation = -Math.PI * getStyleValue(styleObj.angle, feature) / 180;
        }
        if (styleObj.fontColor) {
            textOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styleObj.fontColor, feature), 1)
            });
        }
        if (styleObj.labelOutlineColor) {
            textOptions.stroke = new ol.style.Stroke({
                color: getRGBA(getStyleValue(styleObj.labelOutlineColor, feature), 1),
                width: getStyleValue(styleObj.labelOutlineWidth, feature)
            });
        }
        if (styleObj.labelOffset) {
            textOptions.offsetX = styleObj.labelOffset[0];
            textOptions.offsetY = styleObj.labelOffset[1];
        }
        return new ol.style.Text(textOptions);
    };

    var toHexString = function (number) {
        var result = number.toString(16);
        if (result.length === 1) {
            result = '0' + result;
        }
        return result;
    };

    var getHexColorFromArray = function (colorArray) {
        return '#' + toHexString(colorArray[0]) + toHexString(colorArray[1]) + toHexString(colorArray[2])
    };

    var getStyleFromNative = function (olStyle, olFeat) {
        var result = {
        };
        if (TC.Util.isFunction(olStyle)) {
            if (olFeat) {
                olStyle = olStyle(olFeat);
            }
        }
        if (Array.isArray(olStyle)) {
            olStyle = olStyle[0];
        }
        if (!TC.Util.isFunction(olStyle)) {
            var color;
            var stroke;
            var fill;
            if (olFeat) {
                const olGeom = olFeat.getGeometry();
                const olGeomType = olGeom.getType();
                // Si la geometría no aplica, no poner ol.style.Image
                // Esto es porque el parser de KML genera estilos "totum revolutum" a partir de las URL de estilos (bug 27470)
                if (olGeomType !== ol.geom.GeometryType.POINT && olGeomType !== ol.geom.GeometryType.MULTI_POINT) {
                    olStyle.setImage(null);
                }
            }
            var image = olStyle.getImage();
            if (image) {
                if (image instanceof ol.style.RegularShape) {
                    stroke = image.getStroke();
                    color = stroke.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.strokeColor = getHexColorFromArray(color);
                    }
                    result.strokeWidth = stroke.getWidth();
                    fill = image.getFill();
                    if (fill) {
                        color = fill.getColor();
                        if (color) {
                            color = ol.color.asArray(color);
                            result.fillColor = getHexColorFromArray(color);
                        }
                        result.fillOpacity = color[3];
                    }
                }
                else {
                    result.url = image.getSrc();
                    var size = image.getSize();
                    if (size) {
                        result.width = size[0];
                        result.height = size[1];
                        result.anchor = image.getAnchor();
                        if (result.anchor) {
                            result.anchor[0] = result.anchor[0] / result.width;
                            result.anchor[1] = result.anchor[1] / result.height;
                        }
                    }
                }
            }
            else {
                stroke = olStyle.getStroke();
                if (stroke) {
                    color = stroke.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.strokeColor = getHexColorFromArray(color);
                    }
                    result.strokeWidth = stroke.getWidth();
                    result.lineDash = stroke.getLineDash();
                }
                fill = olStyle.getFill();
                if (fill) {
                    color = fill.getColor();
                    if (color) {
                        color = ol.color.asArray(color);
                        result.fillColor = getHexColorFromArray(color);
                    }
                    result.fillOpacity = color[3];
                }
            }
        }

        return result;
    };

    TC.wrap.layer.Vector.prototype.getStyle = function () {
        return getStyleFromNative(this.layer.getStyle());
    };

    TC.wrap.layer.Vector.prototype.reloadSource = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const layerOptions = self.createVectorSource(self.parent, self.createStyles(self.parent));

            if (self.parent.type === TC.Consts.layerType.WFS) {
                var listenerKey = layerOptions.source.on('change', function (e) {
                    if (layerOptions.source.getState() == 'ready') {
                        ol.Observable.unByKey(listenerKey);

                        resolve();
                    }
                });
            }

            var features = self.layer.getSource().getFeatures();
            self.layer.setSource(layerOptions.source);

            if (layerOptions.style)
                self.layer.setStyle(layerOptions.style);

            if (self.parent.type != TC.Consts.layerType.WFS) {
                layerOptions.source.addFeatures(features);
                resolve();
            }
        });
    };

    TC.wrap.layer.Vector.prototype.import = function (options) {
        var self = this;
        var opts = TC.Util.extend({
        }, options);
        opts.type = options.format;

        var oldFeatures = self.layer.getSource().getFeatures();
        var layerOptions = self.createVectorSource(opts, self.createStyles(self.parent));
        self.layer.setSource(layerOptions.source);
        if (layerOptions.style) {
            self.layer.setStyle(layerOptions.style);
        }

        layerOptions.source.addFeatures(oldFeatures);
    };

    TC.wrap.layer.Vector.prototype.createVectorSource = function (options, nativeStyle) {
        const self = this;

        var createGenericLoader = function (url, format) {
            var internalLoader = ol.featureloader.xhr(url, format);
            return function (extent, resolution, projection) {
                self.parent.state = TC.Layer.state.LOADING;
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                        layer: self.parent
                    });
                }
                internalLoader.call(this, extent, resolution, projection);
            };
        };
        var usesGenericLoader = false;

        var source;
        var vectorOptions;

        var getMimeTypeFromUrl = function (url) {
            var idx = url.indexOf('?');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
            else {
                idx = url.indexOf('#');
                if (idx >= 0) {
                    url = url.substr(0, idx);
                }
            }
            switch (url.substr(url.lastIndexOf('.') + 1).toLowerCase()) {
                case 'kml':
                    return TC.Consts.mimeType.KML;
                case 'json':
                case 'geojson':
                    return TC.Consts.mimeType.GEOJSON;
                case 'gml':
                    return TC.Consts.mimeType.GML;
                case 'gpx':
                    return TC.Consts.mimeType.GPX;
                default:
                    return null;
            }
        };

        if (Array.isArray(options.url) || options.urls) {
            var urls = options.urls || options.url;
            urls = urls.map(function (elm, idx) {
                return TC.proxify(elm);
            });
            vectorOptions = {
                url: urls,
                format: new ol.format.KMLCustom({
                    showPointNames: false
                }),
                projection: options.crs
            };
        }
        else if (options.url && options.type !== TC.Consts.layerType.WFS) {
            vectorOptions = {
                url: TC.proxify(options.url),
                projection: options.crs
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(getMimeTypeFromUrl(options.url)) || getFormatFromName(options.type);
            vectorOptions.loader = createGenericLoader(vectorOptions.url, vectorOptions.format);
            usesGenericLoader = true;
        }
        else if (options.data) {
            vectorOptions = {
                projection: options.crs,
                loader: function (extent, resolution, projection) {
                    self.parent.state = TC.Layer.state.LOADING;
                    if (self.parent.map) {
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });
                    }
                    var format = this.getFormat();
                    try {
                        var fs = format.readFeatures(options.data, {
                            featureProjection: projection
                        });
                        this.addFeatures(fs);
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                layer: self.parent, newData: data
                            });
                        }
                    }
                    catch (e) {
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, {
                                layer: self.parent, reason: e.message
                            });
                        }
                    }
                }
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(options.type);
        }
        else if (options.type == TC.Consts.layerType.WFS) {
            var outputFormat;
            var mimeType;
            switch (options.outputFormat) {
                case TC.Consts.format.JSON:
                    outputFormat = new ol.format.GeoJSON({
                        geometryName: options.geometryName
                    });
                    mimeType = 'json';
                    break;
                case TC.Consts.format.GML3:
                    outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML3() });
                    mimeType = TC.Consts.mimeType.GML;
                    break;
                case TC.Consts.format.GML32:
                    outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML32() });
                    mimeType = TC.Consts.mimeType.GML;
                    break;
                default:
                    outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML2() });
                    mimeType = TC.Consts.mimeType.GML;
                    break;
            }
            vectorOptions = {
                format: outputFormat,
                loader: function (extent, resolution, projection) {
                    var sOrigin = this;
                    var serviceUrl = options.url;
                    if (serviceUrl) {
                        self.parent.state = TC.Layer.state.LOADING;
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });

                        const manageResponse = (response) => {
                            const data = response.data;
                            let feats;
                            try {
                                feats = outputFormat.readFeatures(data);
                            }
                            catch (e) {
                                self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: e.message })
                            }
                            const triggerLayerUpdate = function () {
                                self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                    layer: self.parent, newData: data
                                });
                            };
                            const onFeaturesAdd = function (e) {
                                if (e.layer === self.parent) {
                                    self.parent.map.off(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                                    triggerLayerUpdate();
                                }
                            };
                            if (feats && feats.length) {
                                sOrigin.addFeatures(feats);
                                self.parent.map.on(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                            }
                            else {
                                triggerLayerUpdate();
                            }
                            self.parent.state = TC.Layer.state.IDLE;
                        }

                        const makeAjaxCall = (onlyHits, capabilities) => {
                            var ajaxOptions = {};
                            var crs = projection.getCode();
                            var version = options.version || capabilities.version || '1.1.0';
                            capabilities.version = version;
                            var url = serviceUrl;
                            var featureType = Array.isArray(options.featureType) ? options.featureType : [options.featureType];
                            if (options.properties && options.properties.getText(capabilities.version).length > TC.Consts.URL_MAX_LENGTH) {
                                ajaxOptions.method = 'POST';
                                ajaxOptions.url = url;
                                ajaxOptions.data = TC.Util.WFSQueryBuilder(featureType, options.properties, capabilities, onlyHits ? null : options.outputFormat, onlyHits, crs, options.maxFeatures)
                            }
                            else {
                                ajaxOptions.method = 'GET';
                                ajaxOptions.url = url;
                                ajaxOptions.data = {
                                    service: "WFS",
                                    request: "GetFeature",
                                    version: version,
                                    typename: (options.featurePrefix ? options.featurePrefix + ":" : "") + options.featureType,
                                    outputFormat: options.outputFormat,
                                    srsname: crs
                                }
                                if (onlyHits)
                                    ajaxOptions.data = Object.assign(ajaxOptions.data, {
                                        resultType: "hits"
                                    });
                                if (options.properties) {
                                    if (options.properties instanceof TC.filter.Bbox)
                                        ajaxOptions.data = Object.assign(ajaxOptions.data, {
                                            BBOX: '{0},{1},{2},{3},{4}'.format(options.properties.extent.concat([crs]))
                                        });
                                    else
                                        ajaxOptions.data = Object.assign(ajaxOptions.data, {
                                            filter: options.properties.getText()
                                        });
                                }
                                if (options.maxFeatures)
                                    ajaxOptions.data = Object.assign(ajaxOptions.data, {
                                        maxFeatures: options.maxFeatures
                                    });
                            }
                            switch (onlyHits ? "" : mimeType) {
                                case 'json':
                                    ajaxOptions.responseType = TC.Consts.mimeType.JSON;
                                    break;
                                default:
                                    ajaxOptions.responseType = TC.Consts.mimeType.XML;
                                    break;
                            }
                            ajaxOptions.contentType = TC.Consts.mimeType.XML;

                            return TC.ajax(ajaxOptions);
                        };

                        self.parent.getCapabilitiesPromise().then((_capabilities) => {
                            const capabilities = _capabilities;
                            //obtenos del capabilities nummax de features
                            let numMaxFeatures = null;
                            try {
                                numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
                            }
                            catch (e) {
                            }
                            if (numMaxFeatures) {
                                if (!options.maxFeatures) options.maxFeatures = numMaxFeatures;
                                makeAjaxCall(true, capabilities).then((response) => {
                                    var firstNode = response.data.children[0];
                                    if (firstNode.tagName.toLowerCase().indexOf("exception") >= 0) {
                                        self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: firstNode.querySelector("ExceptionText").innerHTML })
                                    }
                                    else if (firstNode.tagName.toLowerCase().indexOf("featurecollection") >= 0) {
                                        let numOfFeaturesFounded = parseInt((firstNode.attributes["numberMatched"] || firstNode.attributes["numberOfFeatures"]).value, 10);
                                        if (isNaN(numOfFeaturesFounded) || numOfFeaturesFounded >= parseInt(numMaxFeatures, 10)) {
                                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: TC.Consts.WFSErrors.MAX_NUM_FEATURES, data: { limit: parseInt(numMaxFeatures, 10), founded: numOfFeaturesFounded } });
                                            return;
                                        }
                                        else if (!isNaN(numOfFeaturesFounded) && numOfFeaturesFounded === 0) {
                                            //si no encuentra nada. LLamo a la función para 
                                            manageResponse({
                                                data: outputFormat.writeFeatures([])
                                            });
                                            return;
                                        }
                                        makeAjaxCall(false, capabilities).then(manageResponse);
                                    }
                                })
                            }
                            else {
                                makeAjaxCall(false, capabilities).then(manageResponse);
                            }
                        });
                        self._requestUrl = serviceUrl;
                    }
                },
                //strategy: ol.loadingstrategy.all(),
                projection: options.crs
            };
        }

        source = new ol.source.Vector(vectorOptions);

        if (usesGenericLoader) {
            source.on(CHANGE, function (e) {
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                        layer: self.parent
                    });
                }
            });
        }

        source._tcLayer = self.parent;

        var markerStyle = options.style && options.style.marker ? options.style.marker : TC.Cfg.styles.marker;
        if (!options.style || !options.style.marker) {
            markerStyle = TC.Util.extend({}, markerStyle, {
                anchor: TC.Cfg.styles.point.anchor
            });
        }

        // Si habilitamos el clustering la fuente es especial
        if (options.cluster) {
            source = new ol.source.Cluster({
                projection: options.crs,
                distance: options.cluster.distance,
                source: source
            });

            // Animación
            if (options.cluster.animate) {
                var getCurrentCoordinates = function (fromCoords, toCoords, duration, start) {
                    var fraction = Math.min((Date.now() - start) / duration, 1);
                    var dx = (toCoords[0] - fromCoords[0]) * fraction;
                    var dy = (toCoords[1] - fromCoords[1]) * fraction;
                    return [fromCoords[0] + dx, fromCoords[1] + dy];
                };
                var animate = function (parent, child) {
                    var start = Date.now();
                    var pCoords = parent.getGeometry().getCoordinates();
                    var cCoords = child.getGeometry().getCoordinates();
                    child.setGeometry(new ol.geom.Point(pCoords));
                    var step = function step() {
                        var coords = getCurrentCoordinates(pCoords, cCoords, TC.Consts.CLUSTER_ANIMATION_DURATION, start);
                        child.setGeometry(new ol.geom.Point(coords));
                        if (coords[0] !== cCoords[0] && coords[1] !== cCoords[1]) {
                            requestAnimationFrame(step);
                        }
                        else {
                            clusterCache.splice(clusterCache.indexOf(parent), 1);
                        }
                    };
                    requestAnimationFrame(step);
                };
                var clusterCache = [];
                source.addEventListener(REMOVEFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features && features.length > 1) {
                        clusterCache.push(e.feature);
                    }
                });
                source.addEventListener(ADDFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features) {
                        var coords = features[0].getGeometry().getCoordinates();
                        if (features.length > 1) {
                            var match = clusterCache.filter(function (elm) {
                                var elmCoords = elm.getGeometry().getCoordinates();
                                return elmCoords[0] === coords[0] && elmCoords[1] === coords[1];
                            });
                            if (match.length) {
                                clusterCache.splice(clusterCache.indexOf(match[0]), 1);
                            }
                        }
                        var parent = clusterCache.filter(function (elm) {
                            var children = elm.get('features');
                            if (children && children.length > 0) {
                                var child = children.filter(function (cElm) {
                                    var cCoords = cElm.getGeometry().getCoordinates();
                                    return cCoords[0] === coords[0] && cCoords[1] === coords[1];
                                });
                                return child.length > 0;
                            }
                        });
                        if (parent.length) {
                            animate(parent[parent.length - 1], e.feature);
                        }
                    }
                });
            }
        }

        var s = source;
        do {
            s.addEventListener(ADDFEATURE, function (e) {
                var olFeat = e.feature;
                // OL3 dibuja el tamaño original del icono del marcador, lo escalamos si es necesario:
                var style = getNativeFeatureStyle(olFeat, true);
                if (style) {
                    setScaleFunction(style.getImage(), markerStyle.width, olFeat);
                }
            });
            if (TC.Util.isFunction(s.getSource)) {
                s = s.getSource();
            }
            else {
                s = null;
            }
        }
        while (s);

        source.addEventListener(ADDFEATURE, function (e) {
            const olFeat = e.feature;

            const addFeatureToLayer = function (feat) {
                var addFn;
                switch (true) {
                    case TC.feature.Point && feat instanceof TC.feature.Point:
                        addFn = self.parent.addPoint;
                        break;
                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:
                        addFn = self.parent.addPolyline;
                        break;
                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:
                        addFn = self.parent.addPolygon;
                        break;
                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:
                        addFn = self.parent.addMultiPolygon;
                        break;
                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:
                        addFn = self.parent.addMultiPolyline;
                        break;
                    default:
                        addFn = self.parent.addFeature;
                        break;
                }
                if (addFn) {
                    var _timeout;
                    addFn.call(self.parent, olFeat).then(function (f) {
                        var features = olFeat.get('features');
                        if (Array.isArray(features)) {
                            // Es una feature de fuente ol.source.Cluster
                            f.features = features.map(function (elm) {
                                return new feat.constructor(elm);
                            });
                        }

                        // Timeout porque OL3 no tiene evento featuresadded. El timeout evita ejecuciones a lo tonto.
                        clearTimeout(_timeout);
                        _timeout = setTimeout(function () {
                            self.parent.map.trigger(TC.Consts.event.FEATURESADD, {
                                layer: self.parent, features: [f]
                            });
                        }, 50);
                    });
                }
            };

            if (!olFeat._wrap || !olFeat._wrap.parent.layer) { // Solo actuar si no es una feature añadida desde la API
                TC.wrap.Feature.createFeature(olFeat).then(addFeatureToLayer);
            }
        });

        source.addEventListener(REMOVEFEATURE, function (e) {
            var olFeat = e.feature;
            if (olFeat._wrap) {
                var idx = self.parent.features.indexOf(olFeat._wrap.parent);
                if (idx > -1) {
                    self.parent.features.splice(idx, 1);
                    self.parent.map.trigger(TC.Consts.event.FEATUREREMOVE, {
                        layer: self.parent, feature: olFeat._wrap.parent
                    });
                }
            }
        });

        source.addEventListener(ADDFEATURE, function (e) {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(REMOVEFEATURE, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(CLEAR, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.FEATURESCLEAR, {
                    layer: self.parent
                });
            }
        });

        var layerOptions = {
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }

        // En KML conservamos el estilo que viene con el archivo, así que no entramos aquí.
        // A no ser que tenga clusters, porque OL no soporta por defecto la combinación de estilo KML con clusters.
        if (!(vectorOptions && vectorOptions.format instanceof ol.format.KML) || options.cluster) {
            layerOptions.style = nativeStyle || options.styles;
        }

        return layerOptions;
    };

    TC.wrap.layer.Vector.prototype.createStyles = function (options) {
        var self = this;

        var dynamicStyle = false;

        if (TC.Util.isFunction(options)) {
            dynamicStyle = true;
            self.styleFunction = function (olFeat) {
                return createNativeStyle(options(olFeat));
            }
        }
        else {
            options = TC.Util.extend({}, options);
            options.crs = options.crs || TC.Cfg.crs;
            options.styles = options.styles || TC.Cfg.styles;
            var isDynamicStyle = function isDynamicStyle(obj) {
                for (var key in obj) {
                    var prop = obj[key];
                    switch (typeof prop) {
                        case 'string':
                            if (/^\$\{(.+)\}$/.test(prop)) {
                                return true;
                            }
                            break;
                        case 'object':
                            if (isDynamicStyle(prop)) {
                                return true;
                            }
                            break;
                        case 'function':
                            return true;
                            break;
                        default:
                            break;
                    }
                }
                return false;
            };

            dynamicStyle = !!(options.cluster && options.cluster.styles) || isDynamicStyle(options.styles);
            self.styleFunction = function (olFeat) {
                return createNativeStyle({ styles: self.parent.styles }, olFeat);
            };
        }

        var nativeStyle = dynamicStyle ? self.styleFunction : self.styleFunction();

        return nativeStyle;
    };

    TC.wrap.layer.Vector.prototype.setStyles = function (options) {
        const self = this;
        self.getLayer().then(function (olLayer) {
            olLayer.setStyle(self.createStyles({ styles: options }));
        });
    };

    TC.wrap.layer.Vector.prototype.createVectorLayer = function () {
        const self = this;
        var result = null;

        var options = self.parent.options;

        var layerOptions = self.createVectorSource(options, self.createStyles(options));
        layerOptions.declutter = self.parent.options.declutter || false;
        result = new ol.layer.Vector(layerOptions);
        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    TC.wrap.layer.Vector.prototype.addFeatures = function (features) {
        const self = this;
        const commit = function (l) {
            var source = l;
            while (TC.Util.isFunction(source.getSource)) {
                source = source.getSource();
            }
            source.addFeatures(features);
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatures = function () {
        var olLayer = this.getLayer();
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatures();
        }
        else {
            return [];
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatureById = function (id) {
        var olLayer = this.layer;
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatureById(id);
        }
        else {
            return null;
        }
    };

    TC.wrap.layer.Vector.prototype.removeFeature = function (feature) {
        const self = this;
        const commit = function (l) {
            if (feature.wrap.feature) {
                var source = l.getSource();
                source.removeFeature(feature.wrap.feature);
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.clearFeatures = function () {
        const self = this;
        const commit = function (l) {
            var source = l.getSource();
            if (source.clearFeatures) {
                source.clearFeatures();
            }
            else {
                source.clear();
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.setFeatureVisibility = function (feature, visible) {
        var self = this;

        var fillOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var strokeOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var displayNoneStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 0,
                fill: new ol.style.Fill(fillOptions),
                stroke: new ol.style.Stroke(strokeOptions)
            }),
            fill: new ol.style.Fill(fillOptions),
            stroke: new ol.style.Stroke(strokeOptions)
        });
        var idx = self.parent.features.indexOf(feature);
        if (idx >= 0) {
            var olFeat = feature.wrap.feature;
            self.getLayer().then(function (olLayer) {
                if (visible && olFeat._originalStyle) {
                    olFeat.setStyle(olFeat._originalStyle);
                }
                else {
                    olFeat._originalStyle = olFeat.getStyle() || olLayer.getStyle();
                    olFeat.setStyle(displayNoneStyle);
                }
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            });
        }
    };

    TC.wrap.layer.Vector.prototype.getRGBA = function (color, opacity) {
        return getRGBA(color, opacity);
    };

    TC.wrap.layer.Vector.prototype.findFeature = function (values) {
        // TODO: añadir ol.animation.zoom
    };

    TC.wrap.layer.Vector.prototype.getGetFeatureUrl = function () {
        return this._requestUrl;
    };

    TC.wrap.layer.Vector.prototype.sendTransaction = function (inserts, updates, deletes) {
        const self = this;
        const getNativeFeature = function (feat) {
            return feat.wrap.feature;
        };
        return new Promise(function (resolve, reject) {
            const olInserts = inserts.map(getNativeFeature);
            const olUpdates = updates.map(getNativeFeature);
            const olDeletes = deletes.map(getNativeFeature);
            if (inserts.length || updates.length || deletes.length) {
                self.getLayer().then(function (olLayer) {
                    var format = new ol.format.WFS();
                    var options = self.parent.options;
                    var transaction = format.writeTransaction(olInserts, olUpdates, olDeletes, {
                        featurePrefix: options.featurePrefix,
                        featureNS: options.featureNS,
                        featureType: options.featureType[0]
                    });
                    var ajaxOptions = {
                        url: self.parent.url,
                        method: 'POST',
                        contentType: TC.Consts.mimeType.XML,
                        responseType: TC.Consts.mimeType.XML,
                        data: transaction.outerHTML
                    };
                    TC.ajax(ajaxOptions)
                        .then(function (response) {
                            const data = response.data;
                            const ns = 'http://www.opengis.net/ows';
                            var er = data.getElementsByTagNameNS(ns, 'ExceptionReport')[0];
                            var errorObj = {
                                reason: ''
                            };
                            if (er) {
                                var e = er.getElementsByTagNameNS(ns, 'Exception')[0];
                                if (e) {
                                    errorObj.code = e.getAttribute('exceptionCode');
                                    var texts = e.getElementsByTagNameNS(ns, 'ExceptionText');
                                    for (var i = 0, len = texts.length; i < len; i++) {
                                        errorObj.reason += '\n' + texts[i].innerHTML;
                                    }
                                }
                                reject(errorObj);
                            }
                            else {
                                var transactionResponse = format.readTransactionResponse(data);
                                resolve(transactionResponse);
                            }
                        })
                        .catch(function () {
                            reject({
                                code: '', reason: 'unknown'
                            });
                        });
                });
            }
            else {
                resolve(self.parent);
            }
        });
    };

    TC.wrap.layer.Vector.prototype.setDraggable = function (draggable, onend, onstart) {
        var self = this;

        //tiene que estar a nivel de control para poder retirarla después
        //var interaction;
        Promise.all([self.parent.map.wrap.getMap(), self.getLayer()]).then(function (olObjects) {
            const olMap = olObjects[0];
            const olLayer = olObjects[1];
            if (draggable) {
                var interactionOptions = {
                    layers: [olLayer],
                    features: new ol.Collection(olLayer.getSource().getFeatures())
                };
                self.interaction = new ol.interaction.Translate(interactionOptions);
                if (TC.Util.isFunction(onend)) {
                    self.interaction.on('translateend', function (e) {
                        if (e.features.getLength()) {
                            onend(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                if (TC.Util.isFunction(onstart)) {
                    self.interaction.on('translatestart', function (e) {
                        if (e.features.getLength()) {
                            onstart(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                olMap.addInteraction(self.interaction);
            }
            else if (self.interaction) {
                olMap.removeInteraction(self.interaction);

                // GLS: En IE no muestra la manita en el over sobre marcadores trasladables.
                if (TC.Util.detectIE() && self._handlerDraggablePointerMove && TC.Util.isFunction(self._handlerDraggablePointerMove)) {
                    olMap.un('pointermove', self._handlerDraggablePointerMove);
                    delete self._handlerDraggablePointerMove;
                }
            }
        });
    };

    TC.wrap.layer.Vector.prototype.getFeaturesInExtent = function (extent, tolerance) {
        var self = this;
        var features = this.layer.getSource().getFeatures();
        var featuresInExtent = [];

        if (tolerance) {
            var leftCorner = self.parent.map.getPixelFromCoordinate([extent[0], extent[1]]);
            var rightCorner = self.parent.map.getPixelFromCoordinate([extent[2], extent[3]]);
            leftCorner[0] -= tolerance[0] / 2;
            leftCorner[1] += tolerance[1];
            rightCorner[0] += tolerance[0] / 2;
            extent = self.parent.map.getCoordinateFromPixel(leftCorner).concat(self.parent.map.getCoordinateFromPixel(rightCorner));
        }

        for (var i = 0; i < features.length; i++) {
            var feat = features[i];

            var geometry = feat.getGeometry();
            var coordinate = geometry.getCoordinates();

            if (ol.extent.containsCoordinate(extent, coordinate)) {
                featuresInExtent.push(feat._wrap.parent);
            }
        }

        return featuresInExtent;
    };

    TC.wrap.layer.Vector.prototype.getAttribution = function () {
        return null;
    };
    TC.wrap.layer.Vector.prototype.getGetMapUrl = function () {
        var result = null;
        var self = this;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WFS:
                try {
                    result = self.parent.capabilities.Operations.GetFeature.DCP.HTTP.Get.href;
                }
                catch (ex) {
                }
                break;
            default:
                break;
        }
        const fragment = document.createDocumentFragment();
        const textarea = document.createElement('textarea');
        fragment.appendChild(textarea);
        textarea.innerHTML = result;
        result = textarea.textContent;
        return result;
    };

    TC.wrap.layer.Vector.prototype.getServiceType = function () {
        var result = null;
        //URI: Si se tiene capabilities se supone que es un servicio WFS
        if (this.parent.capabilities) {
            result = TC.Consts.layerType.WFS;
        }
        return result;
    };

    TC.wrap.control.Click.prototype.register = function (map) {
        var self = this;

        self._trigger = function (e) {
            if (map.view === TC.Consts.view.PRINTING) {
                return;
            }
            var featureCount = 0;
            map.wrap.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        featureCount++;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            if (!featureCount) {
                // GLS: lanzo el evento click, para que los controles que no pueden heredar de click y definir un callback pueda suscribirse al evento
                self.parent.map.trigger(TC.Consts.event.CLICK, {
                    coordinate: e.coordinate, pixel: e.pixel
                });
                self.parent.callback(e.coordinate, e.pixel);
            }
            // Seguimos adelante si no se han pinchado featuers
            return featureCount === 0;
        };
    };

    TC.wrap.control.Click.prototype.activate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.on(SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.Click.prototype.deactivate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.un(SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.ScaleBar.prototype.render = function () {
        var self = this;
        if (!self.ctl) {
            self.ctl = new ol.control.ScaleLine({
                target: self.parent.div
            });
        }
        else {
            self.ctl.updateElement_();
        }
    };

    TC.wrap.control.ScaleBar.prototype.getText = function () {
        var self = this;
        if (self.ctl) {
            return self.ctl.renderedHTML_;
        }
    };

    TC.wrap.control.NavBar.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;
            self.zCtl = new ol.control.Zoom({
                target: div
            });
            // Ponemos para render una función modificada, para evitar que en los pinch zoom haya errores de este tipo:
            // AssertionError: Assertion failed: calculated value (1.002067782531452) ouside allowed range (0-1)

            self.zsCtl = new ol.control.ZoomSlider({
                render: function (e) {
                    if (!e.frameState || !e.frameState.viewState || olMap.getView().getMinResolution() <= e.frameState.viewState.resolution) {
                        // GLS: para evitar que el slider se configure en horizontal
                        var render = function () {
                            if (this.element.offsetWidth > this.element.offsetHeight) {
                                if (!self.requestSliderSize) {
                                    self.requestSliderSize = window.requestAnimationFrame(render.bind(this));
                                }

                                window.requestAnimationFrame(render.bind(this));
                            } else if (this.element.offsetWidth < this.element.offsetHeight) {
                                if (self.requestSliderSize) {
                                    window.cancelAnimationFrame(self.requestSliderSize);
                                    delete self.requestSliderSize;
                                }
                                ol.control.ZoomSlider.render.call(this, e);
                            }
                        };
                        render.call(this);
                    }
                }
            });
            self.zsCtl.setTarget(div);

            olMap.addControl(self.zsCtl);
            olMap.addControl(self.zCtl);

            div.querySelectorAll('button').forEach(function (button) {
                button.classList.add('tc-ctl-btn', self.parent.CLASS + '-btn');
                button.style.display = 'block';
                button.innerHTML = '';
                if (button.matches('.ol-zoom-in')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomin');
                    button.setAttribute('title', self.parent.getLocaleString('zoomIn'));
                }
                if (button.matches('.ol-zoom-out')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomout');
                    button.setAttribute('title', self.parent.getLocaleString('zoomOut'));
                }
            });

            const zoomSlider = div.querySelector('.ol-zoomslider');
            zoomSlider.classList.add(self.parent.CLASS + '-bar');
            zoomSlider.querySelector('.ol-zoomslider-thumb').classList.add(self.parent.CLASS + '-slider');

            map.on(TC.Consts.event.BASELAYERCHANGE, self.refresh.bind(self));
        });
    };

    TC.wrap.control.NavBar.prototype.refresh = function () {
        /*
        var map = this.parent.map;
        var olMap = map.wrap.map;

        olMap.removeControl(self.zsCtl);
        var res = map.getResolutions();
        self.zsCtl = new ol.control.ZoomSlider(
            {
                target: this.parent.div,
                "maxResolution": res[0],
                "minResolution": res[res.length - 1]
            });

        olMap.addControl(self.zsCtl);
        $(map.div).find('.ol-zoomslider').addClass(self.parent.CLASS + '-bar').find('.ol-zoomslider-thumb').addClass(self.parent.CLASS + '-slider');
        */
        var self = this;
        var map = self.parent.map.wrap.map;
        // Puede ser que se llame a refresh antes de que esté inicializado ol.control.ZoomSlider. En ese caso llamamos a render que lo inicializa.
        // Como render necesita un ol.MapEvent, esperamos al evento POSTRENDER.

        self.parent.renderPromise().then(function () {
            if (self.zsCtl.sliderInitialized_) {
                var res = map.getView().getResolution();
                self.zsCtl.setThumbPosition_(res);
            }
            else {
                map.once(POSTRENDER, function (e) {
                    self.zsCtl.render(e);
                });
            }
        });
    };

    TC.wrap.control.NavBarHome.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;

            self.z2eCtl = new ol.control.ZoomToExtent({
                target: div, extent: map.initialExtent, tipLabel: ''
            });

            olMap.addControl(self.z2eCtl);

            div.querySelectorAll('button').forEach(function (button) {
                button.style.display = 'block';
                button.innerHTML = '';
            });
            const homeBtn = div.querySelector('.ol-zoom-extent button');
            homeBtn.classList.add('tc-ctl-btn', self.parent.CLASS + '-btn');
            homeBtn.setAttribute('title', self.parent.getLocaleString('zoomToInitialExtent'));
        });
    };

    TC.wrap.control.NavBarHome.prototype.setInitialExtent = function (extent) {
        this.z2eCtl.extent = extent;
    };

    TC.wrap.control.Coordinates.prototype.register = function (map) {
        const self = this;
        self.map = map;

        return new Promise(function (resolve, reject) {

            self._coordsTrigger = function (e) {
                self.parent.coordsToClick(e);
            };

            map.wrap.getMap().then(function (olMap) {
                self.olMap = olMap;

                if (!self.parent.map.on3DView) {
                    var projection = olMap.getView().getProjection();
                    self.parent.crs = projection.getCode();
                    self.parent.units = projection.getUnits();
                } else {
                    self.parent.crs = self.parent.map.view3D.crs;
                    self.parent.units = TC.Consts.units.DEGREES;
                }

                self.parent.isGeo = self.parent.units === ol.proj.Units.DEGREES;

                //$(olMap.getViewport()).add(self.parent.div);
                resolve();
            });
        });
    };

    TC.wrap.control.Coordinates.prototype.onMouseMove = function (e) {
        var self = this;
        if (self.map.wrap.map) {
            var coords = self.map.wrap.map.getEventCoordinate(e);
            if (coords) {
                if (self.parent.isGeo) {
                    self.parent.latLon = coords.reverse();
                } else {
                    self.parent.xy = coords;
                }

                self.parent.update.apply(self.parent, arguments);
            }
        }
    };

    TC.wrap.control.Geolocation.prototype.register = function (map) {
        var self = this;
        self.map = map;

        self._snapTrigger = function (e) {
            if (e.dragging)
                return;

            self.initSnap(self.olMap.getEventCoordinate(e), e.pixel);
        };

        self._postcomposeTrigger = function (e) {
            self.duringTrackSnap(e);
        };

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    var getTrackingLine = function () {
        var self = this;

        return self.parent.layerTracking.features.filter(function (f) {
            return f instanceof TC.feature.Polyline;
        })[0];
    }

    TC.wrap.control.Geolocation.prototype.hasCoordinates = function () {
        var self = this;

        return self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length >= 1;
    };

    var getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {
            s: Math.floor((diff / 1000) % 60),
            m: Math.floor(((diff / (1000 * 60)) % 60)),
            h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
        };

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };
    TC.wrap.control.Geolocation.prototype.showElevationMarker = function (d) {
        var self = this;

        TC.wrap.control.ResultsPanel.prototype.showElevationMarker.call(self, {
            data: d,
            layer: self.parent.layerTrack,
            coords: self.parent.elevationChartData.coords
        })
    };

    TC.wrap.control.Geolocation.prototype.hideElevationMarker = function () {
        TC.wrap.control.ResultsPanel.prototype.hideElevationMarker.call(this);
    };

    TC.wrap.control.Geolocation.prototype.addWaypoint = function (position, properties) {
        var self = this;

        var waypoint = new ol.Feature({
            geometry: new ol.geom.Point([position[0], position[1], properties.ele, properties.time], ('XYZM'))
        });
        waypoint.setProperties(properties);

        self.parent.layerTracking.wrap.layer.getSource().addFeature(waypoint);
    };

    TC.wrap.control.Geolocation.prototype.addPosition = function (position, heading, m, speed, accuracy, altitudeAccuracy, altitude) {
        var self = this;

        var x = Math.round(position[0]);
        var y = Math.round(position[1]);

        var line = getTrackingLine.call(this);
        if (self.parent.layerTracking.features && line) {
            var last = line.geometry.length > 0 && line.geometry[line.geometry.length - 1];
            if (last && last.length == 0) {
                self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
            }
            else {
                var lx = Math.round(last[0]);
                var ly = Math.round(last[1]);

                if (x != lx || y != ly) {
                    self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                    line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
                }
            }

            TC.Util.storage.setSessionLocalValue(self.parent.Const.LocalStorageKey.TRACKINGTEMP, self.formattedToStorage(self.parent.layerTracking).features);
        }

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && speed != undefined && speed > 0 && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.positionChangehandler = function (geoposition) {
        const self = this;
        var accuracy, heading, speed, altitude, altitudeAccuracy;

        if (!getTrackingLine.call(this)) {
            self.parent.setTracking(false);
        }

        return new Promise(function (resolve, reject) {
            if (geoposition && geoposition.coords) {
                self.parent.layerGPS.clearFeatures();

                accuracy = (geoposition.coords.accuracy / self.parent.map.getMetersPerUnit()) || 0;
                heading = geoposition.coords.heading || geoposition[2] || 0;
                speed = geoposition.coords.speed ? geoposition.coords.speed * 3.6 : 0;
                altitude = geoposition.coords.altitude || 0;
                altitudeAccuracy = geoposition.coords.altitudeAccuracy || 0;

                if (self.parent.layerTracking) {
                    var position_ = [geoposition.coords && geoposition.coords.longitude || geoposition[0], geoposition.coords && geoposition.coords.latitude || geoposition[1]];
                    var projectedPosition = TC.Util.reproject(position_, 'EPSG:4326', self.parent.map.crs);

                    self.addPosition(projectedPosition, heading, new Date().getTime(), speed, accuracy, altitudeAccuracy, altitude);

                    var coords = getTrackingLine.call(self).geometry;
                    var len = coords.length;
                    if (len >= 2) {
                        self.parent.deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);
                    }

                    self.parent.trigger(self.parent.Const.Event.POSITIONCHANGE, {
                        pd: {
                            "position": projectedPosition,
                            "altitude": altitude,
                            "accuracy": accuracy,
                            "heading": TC.Util.radToDeg(heading),
                            "speed": speed
                        }
                    });

                    Promise.all([self.parent.layerGPS.addPoint(projectedPosition, {
                        radius: 4,
                        fillColor: '#00CED1',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWidth: 2,
                        showsPopup: false
                    }), self.parent.layerGPS.addCircle([projectedPosition, accuracy], {
                        strokeColor: '#00CED1',
                        strokeWidth: 0.4,
                        fillColor: '#ffffff',
                        fillOpacity: 0.2,
                        showsPopup: false
                    })]).then(function (features) {
                        const marker = features[0];
                        const accuracyCircle = features[1];
                        self.parent.geopositionTracking = true;

                        if (self.parent.firstPosition == false) {
                            self.parent.firstPosition = true;

                            if (!self.parent.trackCenterButton) {
                                self.parent.trackCenterButton = self.parent.div.querySelector('.' + self.parent.CLASS + '-track-center');
                                self.parent.trackCenterButton.querySelector('button').addEventListener('click', function () {
                                    self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);

                                    if (!self.parent.track.infoPanel.isVisible()) {
                                        self.parent.track.infoPanel.doVisible();
                                    }

                                    if (self.parent.track.infoPanel.isMinimized()) {
                                        self.parent.track.infoPanel.maximize();
                                    }
                                });

                                var controlContainer = self.parent.map.getControlsByClass('TC.control.ControlContainer')[0];
                                if (controlContainer) {
                                    self.parent.trackCenterButton = controlContainer.addElement({ position: controlContainer.POSITION.LEFT, htmlElement: self.parent.trackCenterButton });
                                } else {
                                    self.parent.map.div.appendChild(self.parent.trackCenterButton);
                                }

                            }
                            self.parent.trackCenterButton.classList.remove(TC.Consts.classes.HIDDEN);

                            self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);
                        }

                        resolve({
                            marker: marker, accuracy: accuracyCircle
                        });
                    });

                } else { resolve(null); }
            } else {
                resolve(null);
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.setTracking = function (tracking) {
        var self = this;

        if (tracking) {
            self.parent.firstPosition = false;
            var sessionwaypoint = [];

            var nativeTrackingFeature;

            if (self.parent.sessionTracking) {

                var JSONParser = new TC.wrap.parser.JSON();
                var features = JSONParser.parser.readFeatures(self.parent.sessionTracking);
                if (features && self.parent.storageCRS !== self.parent.map.crs) {
                    features = features.map(function (feature) {
                        var clone = feature.clone();
                        clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                        return clone;
                    });
                }

                var coordinates = features.filter(function (feature) {
                    var type = feature.getGeometry().getType().toLowerCase();
                    if (type === 'point') { sessionwaypoint.push(feature); }
                    return type === 'linestring' || type === 'multilinestring';
                })[0].getGeometry().getCoordinates();

                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(coordinates, ('XYZM')),
                    tracking: true
                });

            } else {
                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString([], ('XYZM')),
                    tracking: true
                });
            }

            if (nativeTrackingFeature) {

                TC.wrap.Feature.createFeature(nativeTrackingFeature).then(function (tcFeature) {
                    self.parent.layerTracking.addFeature(tcFeature);

                    if (tcFeature.geometry.length > 1) {
                        self.parent.map.zoomToFeatures(self.parent.layerTracking.features);
                    }

                    if (sessionwaypoint.length > 0) {
                        Promise.all(sessionwaypoint.map(function (waypoint) {
                            return TC.wrap.Feature.createFeature(waypoint);
                        })).then(function (features) {
                            if (features) {
                                features.forEach(function (feature) {
                                    self.parent.layerTracking.addFeature(feature);
                                });
                            }
                        });
                    }

                    self.parent.currentPositionWaiting = self.parent.getLoadingIndicator().addWait();

                    if (!self.currentPositionTrk) {
                        self.currentPositionTrk = [];
                    }

                    var getCurrentPositionInterval;
                    var getCurrentPositionRequest = 0;
                    var errorTimeout = 0;
                    var toast = false;
                    var options = {
                        enableHighAccuracy: true, timeout: 600000
                    };

                    function getCurrentPosition(errorCallback) {
                        var id = getCurrentPositionRequest++;
                        navigator.geolocation.getCurrentPosition(
                            function (data) {
                                clearInterval(getCurrentPositionInterval);
                                self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                                self.positionChangehandler(data).then(function (obj) {
                                    if (self.parent.geopositionTracking == true && obj && obj.marker && obj.accuracy) {
                                        self.currentPositionTrk.push(navigator.geolocation.watchPosition(self.positionChangehandler.bind(self), self.parent.onGeolocateError.bind(self.parent), options));
                                    }
                                });
                            },
                            errorCallback ? errorCallback :
                                function (error) {
                                    switch (error.code) {
                                        case error.TIMEOUT:
                                            if (errorTimeout > 10) {
                                                clearInterval(getCurrentPositionInterval);
                                                self.parent.onGeolocateError.call(self.parent, error);
                                            } else {
                                                errorTimeout++;
                                                getCurrentPosition(function () {
                                                    clearInterval(getCurrentPositionInterval);
                                                    if (!toast) {
                                                        toast = true;
                                                        self.parent.onGeolocateError.call(self.parent, error);
                                                    }
                                                });
                                            }
                                            break;
                                        default:
                                            clearInterval(getCurrentPositionInterval);
                                            self.parent.onGeolocateError.call(self.parent, error);
                                    }
                                }, {
                                timeout: 5000 + id,
                                maximumAge: 10,
                                enableHighAccuracy: true
                            }
                        );
                    }
                    getCurrentPositionInterval = setInterval(getCurrentPosition, 1000);

                    setTimeout(function () {
                        if (self.parent.layerTracking && self.parent.layerTracking.features && self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length == 0) {
                            clearInterval(getCurrentPositionInterval);

                            self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                            self.map.toast(self.parent.getLocaleString("geo.error.permission_denied"), {
                                type: TC.Consts.msgType.WARNING
                            });
                            self.parent.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
                            self.parent.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
                        }
                    }, options.timeout + 1000); // Wait extra second

                });
            }
        } else {
            self.parent.firstPosition = false;

            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }

            if (self.parent.trackCenterButton)
                self.parent.trackCenterButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    TC.wrap.control.Geolocation.prototype.activateSnapping = function () {
        var self = this;

        if (!TC.Util.detectMobile()) {
            self.olMap.on([POINTERMOVE, SINGLECLICK], self._snapTrigger);
            self.olMap.on(POSTCOMPOSE, self._postcomposeTrigger);
        }
    };
    TC.wrap.control.Geolocation.prototype.deactivateSnapping = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            if (!TC.Util.detectMobile()) {
                olMap.un([POINTERMOVE, SINGLECLICK], self._snapTrigger);
                olMap.un(POSTCOMPOSE, self._postcomposeTrigger);
            }

            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }

            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }

            if (self.snapLine) {
                delete self.snapLine;
                olMap.render();
            }
        });
    };
    TC.wrap.control.Geolocation.prototype.clear = function (layer) {
        var self = this;

        if (layer) {
            layer.clearFeatures();
        }

        attachedDTD = false;

        self.deactivateSnapping.call(self);
    };
    var vectorCtx;
    TC.wrap.control.Geolocation.prototype.duringTrackSnap = function (e) {
        var self = this;

        var vectorContext = vectorCtx = e.vectorContext;

        if (vectorContext && self.snapLine) {
            if (typeof (vectorContext.setFillStrokeStyle) === 'function')
                vectorContext.setFillStrokeStyle(null, new ol.style.Stroke({
                    color: 'rgba(197, 39, 55, 1)',
                    width: 1
                }));

            if (typeof (vectorContext.drawGeometry) === 'function')
                vectorContext.drawGeometry(self.snapLine.wrap.feature.getGeometry());
        }
    };

    TC.wrap.control.Geolocation.prototype.endSnap = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            /* cartel */
            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }
            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }
            /* línea */
            if (self.snapLine) {
                delete self.snapLine;
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.initSnap = function (coordinate, eventPixel) {
        var self = this;

        if (self.parent.layerTrack) {
            var vectorSource = self.parent.layerTrack.wrap.layer.getSource();
            var closestFeature = vectorSource.getClosestFeatureToCoordinate(coordinate);

            if (closestFeature !== null) {
                var geometry = closestFeature.getGeometry();
                var closestPoint = geometry.getClosestPoint(coordinate);

                const pixel = self.parent.map.getPixelFromCoordinate(closestPoint);
                const distance = Math.sqrt(
                    Math.pow(eventPixel[0] - pixel[0], 2) +
                    Math.pow(eventPixel[1] - pixel[1], 2));

                if (distance > self.parent.snappingTolerance) {
                    self.endSnap();
                } else {
                    var coordinates = [coordinate, [closestPoint[0], closestPoint[1]]];

                    if (!self.snapLine) self.snapLine = new TC.feature.Polyline(coordinates, {});
                    else self.snapLine.wrap.feature.getGeometry().setCoordinates(coordinates);

                    // información del punto
                    if (!self.snapInfoElement)
                        self.snapInfoElement = document.getElementsByClassName('tc-ctl-geolocation-track-snap-info')[0];

                    self.snapInfoElement.style.display = 'block';

                    if (!self.snapInfo) {
                        self.snapInfo = new ol.Overlay({
                            element: self.snapInfoElement,
                            offset: [5, 18]
                        });

                        self.olMap.addOverlay(self.snapInfo);
                    }

                    if (self.snapInfo.getMap() == undefined)
                        self.snapInfo.setMap(self.olMap);

                    self.snapInfo.setPosition(coordinate);

                    var data = {};
                    if (closestFeature.getGeometry().getType() != "LineString") {
                        if (closestFeature.getKeys().indexOf('name') > -1)
                            data.n = closestFeature.get('name');
                    }

                    var locale = self.parent.map.options.locale && self.parent.map.options.locale.replace('_', '-') || undefined;
                    data.x = self.map.wrap.isGeo() ? closestPoint[0].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[0]).toLocaleString(locale);
                    data.y = self.map.wrap.isGeo() ? closestPoint[1].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[1]).toLocaleString(locale);

                    if (self.map.wrap.isGeo()) {
                        data.isGeo = true;
                    }

                    var getZ = function (position) {
                        return closestPoint[position] ? (Math.round(closestPoint[position] * 100) / 100).toLocaleString(locale) : undefined;
                    };
                    var getM = function (position) {
                        return closestPoint[position] > 0 ? new Date(closestPoint[position]).toLocaleString(locale) : undefined;
                    };

                    if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZM) {
                        data.z = getZ(2);
                        data.m = getM(3);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZ) {
                        data.z = getZ(2);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYM) {
                        data.m = getM(2);
                    }

                    if (data) {
                        self.parent.getRenderedHtml(self.parent.CLASS + '-track-snapping-node', data, function (html) {
                            self.snapInfoElement.innerHTML = html;
                        });
                    }
                }
            }
        }

        self.olMap.render();
    };

    TC.wrap.control.Geolocation.prototype.drawTrackingData = function (track) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const featurePromises = [];

            const JSONParser = new TC.wrap.parser.JSON();
            const features = JSONParser.parser.readFeatures(track.data);

            features.filter(function (feature) {
                return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
            }).forEach(function (feature) {
                feature.getGeometry().setCoordinates(feature.getGeometry().getCoordinates(), track.layout);
            });

            self.activateSnapping.call(self);

            for (var i = 0, len = features.length; i < len; i++) {
                featurePromises.push(TC.wrap.Feature.createFeature(features[i]));
            }

            Promise.all(featurePromises).then(function (feats) {
                feats.forEach(function (feat) {
                    if (feat) {
                        self.parent.layerTrack.addFeature(feat);
                    }
                });
                self.parent.map.zoomToFeatures(self.parent.layerTrack.features);

                resolve();
            });
        });
    };

    TC.wrap.control.Geolocation.prototype.formattedFromStorage = function (storageData) {
        const self = this;

        if (self.parent.storageCRS !== self.parent.map.crs) {
            var features = new ol.format.GeoJSON().readFeatures(storageData);
            if (features) {
                features = features.map(function (feature) {
                    var clone = feature.clone();
                    clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                    return clone;
                });

                return new ol.format.GeoJSON().writeFeatures(features);
            }
        }

        return storageData;
    };
    TC.wrap.control.Geolocation.prototype.formattedToStorage = function (layer, removeTrackingProperty, notReproject) {
        var self = this;

        var parser = new TC.wrap.parser.JSON();
        parser = parser.parser;

        var features = layer.wrap.layer.getSource().getFeatures();
        var layout;

        features = features.map(function (feature) {
            if (feature.getGeometry() instanceof ol.geom.LineString) {
                layout = feature.getGeometry().getLayout();
            }

            if (removeTrackingProperty && feature.getProperties().tracking) {
                feature.unset("tracking");
            }

            if (!notReproject && self.parent.map.crs !== self.parent.storageCRS) {
                var clone = feature.clone();
                clone.getGeometry().transform(self.parent.map.crs, self.parent.storageCRS);

                return clone;
            }

            return feature;
        }).sort(function (a, b) {

            if (a.getGeometry() instanceof ol.geom.Point &&
                !(b.getGeometry() instanceof ol.geom.Point)) {
                return -1;
            }

            if (b.getGeometry() instanceof ol.geom.Point &&
                !(a.getGeometry() instanceof ol.geom.Point)) {
                return 2;
            }

            if (a.getProperties().name < b.getProperties().name) { return -1; }
            if (a.getProperties().name > b.getProperties().name) { return 1; }

            return 0;
        });

        return {
            features: parser.writeFeatures(features), layout: layout
        };
    };

    TC.wrap.control.Geolocation.prototype.export = function (li) {
        const self = this;
        return new Promise(function (resolve, reject) {

            self.parent.getTrackingData(li).then(function (data) {
                if (data) {

                    var olFeatures = new ol.format.GeoJSON().readFeatures(data.data);

                    if (olFeatures.length === 0) {
                        var geoJSON = self.parent.getTrackingData(li);
                        olFeatures = new ol.format.GeoJSON().readFeatures(geoJSON);
                    }

                    Promise.all(olFeatures.map(function (feature) {
                        return TC.wrap.Feature.createFeature(feature);
                    })).then((features) => {
                        resolve(features);
                    });
                } else {
                    reject();
                }
            });
        });
    };

    var segmentsUnion = function (lineStrings) {
        var mergedIndex = [];
        var coords = [];
        if (lineStrings.length > 1) {

            if (lineStrings[0].length == 4) {
                lineStrings = lineStrings.sort(function (a, b) {
                    if (a[0][3] == b[0][3])
                        return 0;
                    else if (a[0][3] < b[0][3])
                        return -1;
                    else return 1;
                });
            }

            for (var ls = 0; ls < lineStrings.length; ls++) {
                var lineString = lineStrings[ls];
                var nextLineIndex = -1;
                var distance = Infinity;

                var last = lineString.getLastCoordinate();
                for (var nls = ls + 1; nls < lineStrings.length; nls++) {
                    var first = lineStrings[nls].getFirstCoordinate();
                    var d = Math.hypot(last[0] - first[0], last[1] - first[1]);
                    if (d < distance) {
                        nextLineIndex = nls;
                        distance = d;
                    }
                }

                if (mergedIndex.length < lineStrings.length) {
                    if (mergedIndex.indexOf(ls) == -1) {
                        mergedIndex.push(ls);
                        coords = coords.concat(lineString.getCoordinates());
                    }
                    if (mergedIndex.indexOf(nextLineIndex) == -1) {
                        mergedIndex.push(nextLineIndex);
                        coords = coords.concat(lineStrings[nextLineIndex].getCoordinates());
                    }
                }
            }

            //self.map.toast(self.parent.getLocaleString("geo.trk.simulateWarning"), { type: TC.Consts.msgType.WARNING });

            return coords;
        }

        return lineStrings[0].getCoordinates();
    };

    TC.wrap.control.Geolocation.prototype.processImportedFeatures = function (options) {
        var self = this;

        var source = self.parent.layerTrack.wrap.layer.getSource();
        var fileName = self.parent.importedFileName;
        var names = [];
        var toAdd = [];
        var toRemove = [];
        var maybeRemove = [];
        var features = source.getFeatures();

        var segments = [];
        var coord = [];

        var getName = function (feature) {
            if (feature.getProperties().hasOwnProperty("name")) {
                if (feature.getProperties().name.trim().length > 0)
                    names.push(feature.getProperties().name);
                else names.push(fileName);
            }
            else names.push(fileName);
        };

        for (var f = 0; f < features.length; f++) {
            var feature = features[f];

            if (feature instanceof TC.Feature)
                feature = features[f].wrap.feature;

            if (feature.getGeometry() instanceof ol.geom.Point) {
                coord.push(feature.getGeometry().getCoordinates());
                maybeRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.LineString) {
                // GLS: 31/01/2018 Routes (<rte>) are converted into LineString geometries, and tracks (<trk>) into MultiLineString, por tanto, las líneas las cargamos como N Rutas, no las unimos como hasta ahora: // segments.push(feature.getGeometry());                
                getName(feature);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(feature.getGeometry().getCoordinates(), feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.MultiLineString) {
                var clone = feature.clone();
                getName(clone);

                var ls = clone.getGeometry().getLineStrings();

                var coords = segmentsUnion(ls);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(coords, feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
        }

        if (segments.length > 0) {
            var coords = segmentsUnion(segments);
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coords)
            }));
        }

        if (coord.length > 0 && maybeRemove.length == features.length) {
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coord)
            }));
        }

        if (toRemove.length > 0) {
            for (var i = 0; i < toRemove.length; i++) {
                source.removeFeature(toRemove[i]);
            }
        }

        if (toAdd.length > 0) {
            var sameName = function (array, element) {
                var indices = [];
                var idx = array.indexOf(element);
                while (idx != -1) {
                    indices.push(idx);
                    idx = array.indexOf(element, idx + 1);

                    if (indices.length > 1)
                        return true;
                }

                return indices.length > 1 ? true : false;
            };

            var featureToAdd;
            var index = 0;
            var processAdd = function () {
                const promises = toAdd.map(function (ta, idx) {
                    return new Promise(function (resolve, reject) {
                        if (featureToAdd) {
                            source.removeFeature(featureToAdd);
                        }

                        var name;
                        if (names.length > idx) {
                            var name = names[idx];
                            if (sameName(names, name))
                                name = '[' + (idx + 1) + ']' + ' ' + name;
                        }

                        self.parent.importedFileName = name ? name : fileName;

                        featureToAdd = toAdd[idx];
                        source.addFeature(featureToAdd);

                        self.parent.saveTrack({
                            message: self.parent.getLocaleString('geo.trk.upload.ok', { trackName: name ? name : fileName }),
                            importedFileName: name ? name : fileName,
                            notReproject: options.notReproject
                        }).then(function (importedIndex) {
                            if (idx == 0) {
                                index = importedIndex;
                            }
                            resolve();
                        });
                    });
                });
                return Promise.all(promises);
            };
            processAdd().then(function () {

                self.parent.layerTrack.setVisibility(false);
                self.parent.layerTrack.clearFeatures();

                self.parent.trigger(self.parent.Const.Event.IMPORTEDTRACK, { index: index });

                delete self.parent.importedFileName;
                self.parent.getLoadingIndicator().removeWait(options.wait);
            });
        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(options.wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    TC.wrap.control.Geolocation.prototype.import = function (wait, data, type) {
        var self = this;
        var vectorSource;
        var listenerKey;

        if (data && data.text) {

            var layerOptions = self.parent.layerTrack.wrap.createVectorSource({
                data: data.text,
                type: type
            });
            vectorSource = layerOptions.source;

            listenerKey = vectorSource.on('change', function (e) {
                if (vectorSource.getState() == 'ready') {
                    ol.Observable.unByKey(listenerKey);
                    self.processImportedFeatures(wait);
                }
            });

            var olLayer = self.parent.layerTrack.wrap.layer;
            olLayer.setSource(vectorSource);

        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    var idRequestAnimationFrame;
    TC.wrap.control.Geolocation.prototype.simulateTrackEnd = function () {
        var self = this;

        self.parent.chartProgressClear();

        if (self.simulateMarker) {
            window.cancelAnimationFrame(idRequestAnimationFrame);
            if (self.simulateMarker.layer.wrap.layer.getSource().getFeatures().length > 0)
                self.simulateMarker.layer.removeFeature(self.simulateMarker);

            delete self.simulateMarker;
        }
    };

    TC.wrap.control.Geolocation.prototype.simulateTrack = function () {
        var self = this;

        var coordinates;
        var features = self.parent.layerTrack.wrap.layer.getSource().getFeatures();
        for (var ls = 0; ls < features.length; ls++) {
            if (features[ls].getGeometry() instanceof ol.geom.LineString) {
                coordinates = features[ls].getGeometry().getCoordinates();
                break;
            }
        }

        if (coordinates && coordinates.length > 0) {
            var first = coordinates[0];

            var setSimulateMarker = function () {
                return new Promise(function (resolve, reject) {
                    if (!self.simulateMarker) {
                        self.parent.layerTrack.addPoint(first.slice(0, 2), {
                            radius: 7,
                            fillColor: '#ff0000',
                            fillOpacity: 0.5,
                            strokeColor: '#ffffff',
                            strokeWidth: 2
                        }).then(function (f) {
                            resolve(f);
                        });
                    } else {
                        self.simulateMarker.setCoords(first.slice(0, 2));
                        resolve(self.simulateMarker);
                    }
                });
            };
            setSimulateMarker().then(function (f) {
                self.simulateMarker = f;

                var animationFrameFraction = function () {
                    var trackLength = coordinates.length;
                    var start, finish;
                    var duration;
                    var fraction;
                    var hasTime = false;

                    const toLength = function (coords) {
                        if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                            return TC.Util.reproject(coords, self.parent.map.crs, self.parent.map.options.utmCrs);
                        }

                        return coords;
                    };

                    var arCoordinates = coordinates;
                    if (arCoordinates[0].length == 4 && arCoordinates[0][3] > 0) {
                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                        hasTime = true;
                    } else {
                        arCoordinates[0][3] = Date.now();

                        for (var i = 1; i < arCoordinates.length; i++) {
                            var done;
                            arCoordinates[i][3] = 0;

                            if (i + 1 < arCoordinates.length) {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1, i + 1))).getLength();
                            } else {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1))).getLength();
                            }

                            arCoordinates[i][3] = arCoordinates[i - 1][3] + (3600000 * done / self.parent.walkingSpeed);
                        }

                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                    }

                    var trackFilm = new ol.geom.LineString(arCoordinates);
                    var timestamp = start;
                    var distance = 0;

                    if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                        distance = new ol.geom.LineString(toLength(JSON.parse(JSON.stringify(arCoordinates)))).getLength();
                    } else {
                        distance = trackFilm.getLength();
                    }

                    var done = 0;
                    var getDoneAtM = function (m) {
                        for (var i = 0; i < arCoordinates.length; i++) {
                            if (arCoordinates[i][3] > m)
                                return {
                                    d: new ol.geom.LineString(toLength(arCoordinates.slice(0, i))).getLength(),
                                    p: arCoordinates[i - 1].slice(0, 2)
                                };
                        }
                    };

                    var loopAtFraction = function () {

                        if (!self.parent.simulate_paused) {
                            var position = trackFilm.getCoordinateAtM(timestamp);
                            var d = getDoneAtM(timestamp);

                            if (fraction >= 1 || !position || !d) {
                                var li = self.parent.getSelectedTrack();
                                if (li)
                                    self.parent.uiSimulate(false, li);

                                if (self.parent.hasElevation) {
                                    self.parent.chartProgressClear();
                                }

                                self.simulateTrackEnd();

                                return;
                            } else {

                                if (self.parent.hasElevation) {
                                    self.parent.chartSetProgress(d, position, distance, (hasTime ? self.parent._getTime(arCoordinates[0][3], position[3]) : false));
                                }

                                if (self.simulateMarker) {
                                    var from = self.simulateMarker.getCoords();
                                    var to = position;
                                    var rotation = Math.atan2(to[1] - from[1], to[0] - from[0]) * 180 / Math.PI;

                                    self.simulateMarker.setCoords(position);
                                    //self.simulateMarker.setStyle({ angle: rotation });
                                }

                                if (self.parent.simulate_speed !== 1)
                                    timestamp = timestamp + (self.parent.delta * self.parent.simulate_speed);
                                else
                                    timestamp = timestamp + self.parent.delta;
                            }
                        }

                        idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);
                    };
                    idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);

                };

                const hasD3 = new Promise(function (resolve, reject) {
                    if (window.d3) {
                        resolve();
                    }
                    else {
                        TC.loadJS(!window.d3, [TC.Consts.url.D3C3], function () {
                            resolve();
                        });
                    }
                });
                hasD3.then(function () {
                    idRequestAnimationFrame = requestAnimationFrame(animationFrameFraction);
                });
            });
        }
    };

    TC.wrap.control.Geolocation.prototype.headingChangehandler = function (evt) {
        var self = this;
        if (!self.parent.track.infoOnMap) {
            self.parent.track.infoOnMap = document.createElement('div');
            const iomStyle = self.parent.track.infoOnMap.style;
            iomStyle.overFlowY = 'scroll';
            iomStyle.height = '200px';
            iomStyle.width = '200px';
            iomStyle.top = '0';
            iomStyle.left = '100px';
            iomStyle.backgroundColor = 'fuchsia';
            iomStyle.position = 'absolute';
            self.parent.map.div.appendChild(self.parent.track.infoOnMap);
        }

        self.parent.track.infoOnMap.style.display = '';

        self.heading = evt.target.getHeading();

        self.parent.track.infoOnMap.innerHTML = self.parent.track.infoOnMap.innerHTML +
            '<br> <p> salta headingChangehandler </p> <br> <p> evt.target.getHeading(): ' + self.heading + ' </p>';



        self.map.wrap.getMap().then(function (map) {
            map.getView().setRotation(-self.heading);
        });

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.orientationChangehandler = function (event) {
        var self = this;

        var view = self.map.wrap.map.getView();
        var center = view.getCenter();
        var resolution = view.getResolution();
        var beta = event.target.getBeta() || 0;
        var gamma = event.target.getGamma() || 0;

        center[0] -= resolution * gamma * 25;
        center[1] += resolution * beta * 25;

        view.setCenter(view.constrainCenter(center));

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.pulsate = function (circle) {
        var self = this;

        self.pulsated = true;

        var radius = circle.wrap.feature.getGeometry().getRadius();
        var start = new Date().getTime();

        var duration = 500;
        var listenerKey;

        var getRadius = function (elapsed) {
            switch (true) {
                case elapsed <= 50:
                    return radius;
                case elapsed > 50 && elapsed <= 100:
                    return radius * 1.02;
                case elapsed > 100 && elapsed <= 150:
                    return radius * 1.05;
                case elapsed > 150 && elapsed <= 200:
                    return radius * 1.02;
                case elapsed > 200 && elapsed <= 300:
                    return radius;
                case elapsed > 300 && elapsed <= 350:
                    return radius * 1.02;
                case elapsed > 350 && elapsed <= 400:
                    return radius * 1.05;
                case elapsed > 400 && elapsed <= 450:
                    return radius * 1.02;
                case elapsed > 450 && elapsed <= 500:
                    return radius * 1;
                default:
                    return radius;
            }
        };
        listenerKey = self.olMap.on(POSTCOMPOSE, function (event) {
            var vectorContext = event.vectorContext;
            var frameState = event.frameState;

            var elapsed = frameState.time - start;

            var f = circle.wrap.feature.getGeometry().clone();
            var r = getRadius(elapsed);
            f.setRadius(r);

            vectorContext.setFillStrokeStyle(
                new ol.style.Fill({
                    color: 'rgba(0, 0, 0, 0.1)'
                }),
                new ol.style.Stroke({
                    color: 'rgba(255, 0, 0, .8)', width: 1
                })
            );
            vectorContext.drawCircleGeometry(f);

            if (elapsed > duration) {
                ol.Observable.unByKey(listenerKey);
                return;
            }

            frameState.animate = true;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.register = function (map) {
        const self = this;
        self.map = map;

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.showElevationMarker = function (options) {
        const self = this;
        options = options || {};
        const data = options.data;
        const layer = options.layer;
        const coords = options.coords;

        if (!self.elevationMarker) {
            const elm = document.createElement('div');
            elm.style.display = 'none';
            elm.classList.add('tc-ctl-geolocation-trackMarker', 'elevation');
            self.elevationMarker = new ol.Overlay({
                element: elm,
                offset: [0, -11],
                positioning: ol.OverlayPositioning.CENTER_CENTER,
                stopEvent: false
            });
        }

        // GLS: si la capa del track está visible mostramos marcamos punto del gráfico en el mapa
        if (layer.getVisibility() && layer.getOpacity() > 0) {
            self.elevationMarker.getElement().style.display = '';
            self.olMap.addOverlay(self.elevationMarker);
            self.elevationMarker.setPosition(coords[data[0].index]);
        }

        // No centrar en el marker
        //var extent = self.map.getExtent();
        //var p = coords[data[0].index];
        //if (p[0] >= extent[0] && p[0] <= extent[2] && p[1] >= extent[1] && p[1] <= extent[3]) { }
        //else {
        //    self.map.setCenter(p.slice(0, 2), { animate: true });
        //}
    };

    TC.wrap.control.ResultsPanel.prototype.hideElevationMarker = function () {
        if (this.elevationMarker) {
            this.elevationMarker.getElement().style.display = 'none';
        }
    };

    TC.wrap.control.Coordinates.prototype.coordsActivate = function () {
        var self = this;

        self.olMap.on(SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.control.Coordinates.prototype.coordsDeactivate = function () {
        var self = this;

        self.olMap.un(SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.Parser = function () {
    };

    TC.wrap.Parser.prototype.read = function (data) {
        var result = [];
        var self = this;
        if (self.parser) {
            if (!TC.Feature) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
            }
            result = self.parser.readFeatures(data).map(function (feat) {
                return new TC.Feature(null, {
                    id: feat.getId(), data: feat.getProperties()
                });
            });
        }
        return result;
    };

    TC.wrap.parser = {
        WFS: function (options) {
            this.parser = new ol.format.WFS(options);
        },
        JSON: function (options) {
            this.parser = new ol.format.GeoJSON(options);
        }
    };
    TC.inherit(TC.wrap.parser.WFS, TC.wrap.Parser);
    TC.inherit(TC.wrap.parser.JSON, TC.wrap.Parser);

    TC.wrap.control.OverviewMap.prototype.register = function (map) {
        var self = this;

        self.parent.layer.wrap.getLayer().then(function (olLayer) {
            self.ovMap = new ol.control.OverviewMap({
                target: self.parent.div,
                collapsed: false,
                collapsible: false,
                className: self.parent.CLASS + ' ol-overviewmap',
                layers: [olLayer]
            });
            self.ovMap._wrap = self;

            /* 08/02/2019 GLS: 
                Establecemos el pixelRatio siempre a uno (aunque el control instancie un olMap internamente no admite el paso de la opción pixelRatio,
                imposible de entender, por eso lo hago directamente), porque OL sólo atiende al valor al principio,
                si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso, click se sitúa mal,
                popup se sitúa entre otros efectos.
                Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                    Bug 25976:Mapa situación en blanco
                    Bug 25954:Canvas en blanco con zoom mayor al 100%
                    Bug 23855:Mapa de situación se muestra en blanco
            */
            self.ovMap.getOverviewMap().pixelRatio_ = 1;

            // Quitamos el drag&drop añadido en OL 4.1.0 machacando el overlay
            self.ovMap.ovmap_.removeOverlay(self.ovMap.boxOverlay_);
            var box = document.createElement('DIV');
            box.className = 'ol-overviewmap-box';
            box.style.boxSizing = 'border-box';
            self.ovMap.boxOverlay_ = new ol.Overlay({
                position: [0, 0],
                positioning: ol.OverlayPositioning.BOTTOM_LEFT,
                element: box
            });
            self.ovMap.ovmap_.addOverlay(self.ovMap.boxOverlay_);

            // mantenemos el ancho y alto del canvas en números enteros
            self.manageSize.call(self.ovMap.ovmap_);

            self._boxElm = self.ovMap.boxOverlay_.getElement();

            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    var ovmMap = self.ovMap.ovmap_;
                    const drag = new Draggabilly(self._boxElm);
                    // Parcheamos Draggabilly para que respete las otras transformaciones, por ejemplo rotación.
                    drag.positionDrag = function () {
                        const style = this.element.style;
                        const newTransform = 'translate3d( ' + this.dragPoint.x +
                            'px, ' + this.dragPoint.y + 'px, 0)';
                        if (style.transform.length) {
                            const idxStart = style.transform.indexOf('translate3d');
                            if (idxStart >= 0) {
                                const idxEnd = style.transform.indexOf(')', idxStart);
                                style.transform = style.transform.replace(style.transform.substring(idxStart, idxEnd + 1), newTransform);
                            }
                            else {
                                style.transform = newTransform + ' ' + style.transform;
                            }
                        }
                        else {
                            style.transform = newTransform;
                        }
                    };
                    drag.on('pointerDown', function (e) {
                        drag.dragged = self._boxElm.cloneNode();
                        drag.dragged.classList.add(TC.Consts.classes.ACTIVE);
                        drag.dragged.style.position = 'absolute';
                        self._boxElm.insertAdjacentElement('beforebegin', drag.dragged);
                        if (map.maxExtent) {
                            var bottomLeft = ovmMap.getPixelFromCoordinate([map.maxExtent[0], map.maxExtent[1]]);
                            var topRight = ovmMap.getPixelFromCoordinate([map.maxExtent[2], map.maxExtent[3]]);
                            var mapSize = ovmMap.getSize();
                            const container = document.createElement('div');
                            container.style.position = 'absolute';
                            container.style.bottom = Math.round(mapSize[1] - bottomLeft[1]) + 'px';
                            container.style.left = Math.round(bottomLeft[0]) + 'px';
                            container.style.top = Math.round(topRight[1]) + 'px';
                            container.style.right = Math.round(mapSize[0] - topRight[0]) + 'px';
                            const viewport = ovmMap.getViewport();
                            viewport.insertBefore(container, viewport.firstElementChild);
                            drag.options.containment = container;
                        }
                    });
                    drag.on('pointerUp', function (e) {
                        drag.dragged.parentElement.removeChild(drag.dragged);
                        if (map.maxExtent) {
                            ovmMap.getViewport().removeChild(drag.options.containment);
                            drag.options.containment = null;
                        }
                    });
                    drag.on('dragMove', function (e, pointer, moveVector) {
                        drag._delta = moveVector;
                    });
                    drag.on('dragEnd', function (e, pointer) {
                        var olMap = self.ovMap.getMap();
                        var view = olMap.getView();
                        var centerPixel = ovmMap.getPixelFromCoordinate(view.getCenter());
                        var newCenter = ovmMap.getCoordinateFromPixel([centerPixel[0] + drag._delta.x, centerPixel[1] + drag._delta.y]);
                        var extent = map.getExtent();
                        var halfWidth = (extent[2] - extent[0]) / 2;
                        var halfHeight = (extent[3] - extent[1]) / 2;

                        if (newCenter[0] + halfWidth > map.maxExtent[2]) {
                            newCenter[0] = map.maxExtent[2] - halfWidth;
                        }
                        else if (newCenter[0] - halfWidth < map.maxExtent[0]) {
                            newCenter[0] = map.maxExtent[0] + halfWidth;
                        }
                        if (newCenter[1] + halfHeight > map.maxExtent[3]) {
                            newCenter[1] = map.maxExtent[3] - halfHeight;
                        }
                        else if (newCenter[1] - halfHeight < map.maxExtent[1]) {
                            newCenter[1] = map.maxExtent[1] + halfHeight;
                        }

                        drag.setPosition(0, 0);
                        delete drag._delta;
                        map.setCenter(newCenter, { animate: true });
                    });
                });

            map.wrap.getMap().then(function (olMap) {

                // Modificamos mapa para que tenga la proyección correcta
                self.reset();

                const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.HIDDEN);
                    load.classList.add(TC.Consts.classes.VISIBLE);
                });
                olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.VISIBLE);
                    load.classList.add(TC.Consts.classes.HIDDEN);
                });

                olMap.addControl(self.ovMap);

                self.parent.isLoaded = true;
                self.parent.trigger(TC.Consts.event.MAPLOAD);
            });
        });
    };

    TC.wrap.control.OverviewMap.prototype.reset = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const setLayer = function (layer, crs) {
                if (layer.type === TC.Consts.layerType.WMTS) {
                    var layerProjectionOptions = { crs: crs || self.parent.map.crs, oldCrs: layer.wrap.layer.getSource().getProjection().getCode() }; // , allowFallbackLayer: true

                    if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                        layer.setProjection(layerProjectionOptions);
                    }
                }

                layer.wrap.getLayer().then(function (olLayer) {

                    var olView = new ol.View(getResolutionOptions(self.parent.map.wrap, olLayer._wrap.parent));

                    if (olView.getResolutions()) {
                        olView.setResolution(olView.getResolutions().filter(function (res) {
                            return res > olView.getResolutionForExtent(self.parent.map.getExtent(), olMap.getSize())
                        }).reverse()[0]);

                        olMap.setView(olView);
                    } else if (olView.getProjection().getCode() !== olMap.getView().getProjection().getCode()) {
                        olMap.setView(olView);
                    }

                    // para controlar el mapa en blanco en IE en la carga inicial
                    olLayer._wrap.$events.one(TC.Consts.event.TILELOAD, function () {
                        olMap.getLayers().getArray()[0].getSource().refresh();
                    });

                    if (layer !== self.parent.layer || olMap.getLayers().getArray().indexOf(layer) === -1) {

                        self.parent.map.trigger(TC.Consts.event.OVERVIEWBASELAYERCHANGE, { oldLayer: layer !== self.parent.layer ? self.parent.layer : null, newLayer: layer });
                        olMap.getLayers().forEach(function (l) {
                            if (l instanceof ol.layer.Image || l instanceof ol.layer.Tile) {
                                olMap.removeLayer(l);
                            }
                        });

                        const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                        olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.HIDDEN);
                            load.classList.add(TC.Consts.classes.VISIBLE);
                        });
                        olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.VISIBLE);
                            load.classList.add(TC.Consts.classes.HIDDEN);
                        });

                        olMap.getLayers().insertAt(0, olLayer); // GLS: no usamos .addLayer(olLayer) para asegurar que la capa a añadir quede como fondo.
                    }

                    resolve(layer);
                });
            };

            options = options || {};
            var layer = options.layer || self.parent.layer;
            if (self.parent.map && layer && self.ovMap) {
                var olMap = self.ovMap.ovmap_;

                layer.getCapabilitiesPromise().then(function () {

                    var originalLayer = layer;

                    if (!layer.isCompatible(self.parent.map.crs) && layer.wrap.getCompatibleMatrixSets(self.parent.map.crs).length === 0) {
                        layer = layer.getFallbackLayer() || self.parent.defaultLayer;

                        layer.getCapabilitiesPromise().then(function () {
                            if (self.parent.map.on3DView && !layer.isCompatible(self.parent.map.crs)) {
                                self.parent.map.loadProjections({
                                    crsList: originalLayer.getCompatibleCRS(),
                                    orderBy: 'name'
                                }).then(function (projList) {
                                    setLayer(originalLayer, projList[0].code);
                                });
                            } else if (layer.isCompatible(self.parent.map.crs)) {
                                setLayer(layer);
                            }
                        });
                    } else {
                        setLayer(layer);
                    }
                });
            }
        });
    };

    TC.wrap.control.OverviewMap.prototype.get3DCameraLayer = function () {
        var self = this;
        var result = null;
        var camLayerId = '3DCamera';
        var ovMap;

        if (self.ovMap) {
            ovMap = self.ovMap.getOverviewMap();
            ovMap.getLayers().forEach(function (elm) {
                if (elm.get('id') === camLayerId) {
                    result = elm;
                }
            });

            if (!result) {
                var ovMap = self.ovMap.getOverviewMap();
                var fovStyle = createNativeStyle({});
                // Ponemos los cuadriláteros de fov sin relleno (por legibilidad)
                fovStyle[0].getFill().setColor([0, 0, 0, 0]);
                result = new ol.layer.Vector({
                    id: camLayerId,
                    source: new ol.source.Vector(),
                    style: fovStyle
                });
                ovMap.addLayer(result);
            }
        }
        return result;
    };

    TC.wrap.control.OverviewMap.prototype.draw3DCamera = function (options) {
        var self = this;

        if (this.parent.map.isLoaded) {
            self.is3D = !!options;
            var camLayer = self.get3DCameraLayer();
            if (camLayer) {
                var feature;
                options = options || {
                };
                var fov = options.fov;
                var source = camLayer.getSource();
                if (!fov || !fov.length) { // no vemos terreno o no estamos en vista 3D
                    source.clear();
                }
                else {
                    var features = source.getFeatures();
                    if (!features.length) {
                        feature = new ol.Feature();
                        source.addFeature(feature);
                    }
                    else {
                        feature = features[0];
                    }
                    feature.setGeometry(new ol.geom.Polygon([fov]));
                }
                var heading = (typeof options.heading === 'number') ? options.heading : 0;
                self._boxElm.style.transform = 'rotate(' + heading + 'rad)';
            }
        }
    };

    TC.wrap.control.OverviewMap.prototype.enable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(true);

            /* GLS: bug 23855: mapa de situación se muestra en blanco
                En el resize se valida el alto y el ancho y como el div padre (id = "ovmap") tiene display: none, 
                el ancho y el alto devuelven cero y por ello se muestra en blanco. 
                No vale con lanzar .trigger('resize') porque no utiliza los valores actuales del div, 
                sino los almacenados, por eso llamamos a updateSize que actualiza dichos valores.
                https://tfsapp.tracasa.es:8088/tfs/web/wi.aspx?pcguid=4819cc6e-400e-4f70-ba7c-c18a830405aa&id=23855                
            */
            self.parent.wrap.ovMap.ovmap_.updateSize();

            // Lo siguiente es para actualizar mapa de situación
            const resizeEvent = document.createEvent('HTMLEvents');
            resizeEvent.initEvent('resize', false, false);
            self.parent.map.div.dispatchEvent(resizeEvent);
        }
    };

    TC.wrap.control.OverviewMap.prototype.disable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(false);
        }
    };

    TC.wrap.control.OverviewMap.prototype.manageSize = function () {
        const self = this;

        TC.wrap.Map.prototype.manageSize.call(self);
    };

    TC.wrap.control.FeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                var result = _clickTrigger.call(self, e);
                if (result) {
                    self.parent.beforeRequest({ xy: e.pixel });
                }
                else {
                    map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self.parent });
                }
                return result;
            }
        });
    };

    var bufferElm;
    var getElementText = function (elm) {
        var text = elm.innerHTML || elm.textContent;
        bufferElm = bufferElm || document.createElement("textarea");
        bufferElm.innerHTML = text;
        return bufferElm.value;
    };

    var esriXmlParser = {
        readFeatures: function (text) {
            var result = [];
            var dom = (new DOMParser()).parseFromString(text, 'text/xml');
            if (dom.documentElement.tagName === 'FeatureInfoResponse') {
                var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
                for (var i = 0, len = fiCollections.length; i < len; i++) {
                    var fic = fiCollections[i];
                    var layerName = fic.getAttribute('layername');
                    var fInfos = fic.getElementsByTagName('FeatureInfo');
                    for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                        var fields = fInfos[j].getElementsByTagName('Field');
                        var attributes = {
                        };
                        for (var k = 0, lenk = fields.length; k < lenk; k++) {
                            var field = fields[k];
                            attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                        }
                        var feature = new ol.Feature(attributes);
                        feature.setId(layerName + '.' + TC.getUID());
                        result[result.length] = feature;
                    }
                }
            }
            return result;
        }
    };

    var addLayerToService = function (service, layer, name) {
        var path = layer.getPath(name);
        service.layers.push({
            name: name,
            title: path[path.length - 1],
            path: path.slice(1),
            features: []
        });
    };

    TC.wrap.control.FeatureInfo.prototype.getFeatureInfo = function (coords, resolution, options) {
        var self = this;
        var opts = options || {};
        var map = self.parent.map;
        map.wrap.getMap().then(function (olMap) {
            var targetServices = {};
            var auxInfo = {};
            const requestPromises = [];
            const requestDataArray = [];
            var featurePromises = [];
            var services = [];

            //var infoFormats = [];
            var layers = olMap.getLayers().getArray();

            // GLS: filtro el array de capas para quedarnos con las capas que son raster y visibles.
            layers = layers.filter(function (elem) { return elem instanceof ol.layer.Image && elem.getVisible(); });

            for (var j = 0; j < layers.length; j++) {
                var olLayer = layers[j];
                var layer = olLayer._wrap.parent;
                var source = olLayer.getSource();

                //console.log("Source: " + layer.layerNames.join(","));
                //Por qué en workLayers están el vectorial de medición, y cosas así?
                if (source.getGetFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0 && layer.names.length > 0
                    && (!opts.serviceUrl || opts.serviceUrl === layer.url)) { // Mirar si en las opciones pone que solo busque en un servicio

                    //
                    var targetService;
                    if (!targetServices[layer.url]) {
                        targetService = {
                            url: layer.url,
                            layers: [],
                            mapLayers: [],
                            title: layer.title,
                            request: null
                        };
                        targetServices[layer.url] = targetService;
                        auxInfo[layer.url] = {
                            source: TC.Util.extend(true, {}, source),
                            layers: []
                        };
                    }
                    else {
                        targetService = targetServices[layer.url];
                        auxInfo[layer.url].source.updateParams(TC.Util.extend(auxInfo[layer.url].source.getParams(), source.getParams()));
                    }
                    targetService.mapLayers.push(layer);

                    //var targetService = {
                    //    layers: [], mapLayers: [layer]
                    //};
                    var disgregatedNames = layer.getDisgregatedLayerNames();
                    if (opts.layerName) { // Mirar si en las opciones pone que solo busque en una capa
                        if (disgregatedNames.indexOf(opts.layerName) >= 0 && olLayer._wrap.getInfo(opts.layerName).queryable) {
                            addLayerToService(targetService, layer, opts.layerName);
                            auxInfo[layer.url].layers.push(opts.layerName);
                        }
                    }
                    else {
                        for (var i = 0; i < disgregatedNames.length; i++) {
                            var name = disgregatedNames[i];
                            if (olLayer._wrap.getInfo(name).queryable) {
                                addLayerToService(targetService, layer, name);
                            }
                            else {
                                TC.Util.consoleRegister('Capa "' + disgregatedNames[i] + '" no queryable, la eliminamos de la petición GFI');
                                disgregatedNames.splice(i, 1);
                                i = i - 1;
                            }
                        }

                        // GLS: validamos si nos queda alguna capa a la cual consultar
                        if (disgregatedNames.length > 0) {
                            auxInfo[layer.url].layers = auxInfo[layer.url].layers.concat(disgregatedNames);
                        }
                    }
                }
            }

            for (var serviceUrl in targetServices) {
                services.push(targetServices[serviceUrl]);
                var targetService = targetServices[serviceUrl];
                var source = auxInfo[serviceUrl].source;
                var layers = auxInfo[serviceUrl].layers;

                // GLS: validamos si hay capas a las cuales consultar, si no hay continuamos con el siguiente servicio
                if (!layers || (layers && layers.length === 0)) {
                    continue;
                }

                var params = source.getParams();
                source.params_.LAYERS = layers.join(',');
                var gfiURL = source.getGetFeatureInfoUrl(coords, resolution, map.crs, {
                    'QUERY_LAYERS': layers.join(','),
                    'INFO_FORMAT': params.INFO_FORMAT,
                    'FEATURE_COUNT': 1000,
                    'radius': map.options.pixelTolerance,
                    'buffer': map.options.pixelTolerance
                });

                gfiURL = gfiURL.replace(/sld_body=[a-zA-Z%0-9._]*/); // Quitamos el parámetro sld_body


                var expUrl = gfiURL;
                const requestData = {
                    serviceUrl: serviceUrl,
                    requestedFormat: params.INFO_FORMAT,
                    expandUrl: expUrl
                };
                requestDataArray.push(requestData);
                requestPromises.push(new Promise(function (resolve, reject) {
                    const mapLayer = targetService.mapLayers[0];
                    mapLayer.toolProxification.fetch(gfiURL)
                        .then(function (data) {
                            mapLayer.toolProxification.cacheHost.getAction(requestData.expandUrl).then(function (cache) {
                                requestData.originalUrl = cache.action.call(mapLayer.toolProxification, requestData.expandUrl);
                                resolve(TC.Util.extend({}, data, requestData));
                            });
                        })
                        .catch(function (error) {
                            reject(Error(error));
                        });
                }));
                TC.Util.consoleRegister("Lanzamos GFI");
            }

            if (requestPromises.length > 0) {
                Promise.all(requestPromises).then(function (responses) {
                    var someSuccess = false;
                    var featureCount = 0;
                    var featureInsertionPoints = [];
                    for (var i = 0; i < responses.length; i++) {
                        var featureInfo = responses[i];
                        var service = targetServices[requestDataArray[i].serviceUrl];
                        someSuccess = true;
                        service.text = featureInfo.responseText;
                        var format;
                        var iFormat = featureInfo.contentType;
                        if (iFormat && iFormat.indexOf(";") > -1)
                            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

                        if (!iFormat) iFormat = featureInfo.requestedFormat;

                        if (iFormat === featureInfo.requestedFormat) {
                            switch (iFormat) {
                                case 'application/json':
                                    format = new ol.format.GeoJSON();
                                    break;
                                case 'application/vnd.ogc.gml':
                                    if (featureInfo.responseText.indexOf("FeatureCollection") > -1) {
                                        format = new ol.format.WFS({
                                            gmlFormat: new ol.format.GML2({
                                                srsName: map.crs
                                            })
                                        });
                                    }
                                    else {
                                        format = new ol.format.WMSGetFeatureInfo();
                                    }
                                    break;
                                case 'application/vnd.ogc.gml/3.1.1':
                                    format = new ol.format.GML3({
                                        srsName: map.crs
                                    });
                                    break;
                                case 'application/vnd.esri.wms_featureinfo_xml':
                                    format = esriXmlParser;
                                    break;
                                default:
                                    format = null;
                                    break;
                            }

                            if (format) {
                                var features;
                                try {
                                    features = format.readFeatures(featureInfo.responseText, {
                                        featureProjection: ol.proj.get(map.crs)
                                    });
                                }
                                catch (e) {
                                    TC.error(self.parent.getLocaleString('featureInfo.error.badResponse', { url: featureInfo.serviceUrl }) + ': ' + e.message);
                                    features = [];
                                    continue;
                                };
                                featureCount = featureCount + features.length;
                                var isParentOrSame = function (layer, na, nb) {
                                    var result = false;
                                    if (na === nb) {
                                        result = true;
                                    }
                                    else {
                                        var pa = layer.getNodePath(na);
                                        var pb = layer.getNodePath(nb);
                                        if (pa.length > 0 && pb.length >= pa.length) {
                                            result = true;
                                            for (var i = 0; i < pa.length; i++) {
                                                if (layer.wrap.getName(pa[i]) !== layer.wrap.getName(pb[i])) {
                                                    result = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    return result;
                                };

                                var fakeLayers = {
                                };

                                for (var j = 0; j < features.length; j++) {
                                    var feature = features[j];
                                    if (feature instanceof ol.Feature) {
                                        var fid = feature.getId() || TC.getUID();
                                        var found = false;
                                        var layerName = fid.substr(0, fid.lastIndexOf('.'));
                                        for (var k = 0; k < service.layers.length; k++) {
                                            var l = service.layers[k];
                                            var lName = l.name.substr(l.name.indexOf(':') + 1);
                                            if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                                                found = true;
                                                if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                    featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                    featureInsertionPoints.push(l.features);
                                                }
                                                break;
                                            }
                                        }

                                        //si llegamos aquí y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                                        //esto pasa, p.ej, en cartociudad
                                        if (!found) {
                                            //así que creo un layer de palo para la respuesta del featInfo
                                            var fakeLayer;
                                            if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                                            else {
                                                fakeLayer = {
                                                    name: layerName, title: layerName, path: [layerName], features: []
                                                };
                                                fakeLayers[layerName] = fakeLayer;
                                                service.layers.push(fakeLayer);
                                            }

                                            if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                featureInsertionPoints.push(fakeLayer.features);
                                            }
                                        }
                                    }
                                }//iteración sobre las features de esta respuesta


                            }
                            else {
                                //si no hay formato reconocido y parseable, metemos un iframe con la respuesta
                                //y prau
                                //para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent

                                var compoundLayer = {
                                    name: 'layer' + TC.getUID(), title: 'Datos en el punto', features: []
                                };

                                service.layers[service.layers.length] = compoundLayer;
                                compoundLayer.features[0] = {
                                    rawUrl: featureInfo.originalUrl, expandUrl: featureInfo.expandUrl, rawContent: featureInfo.responseText, rawFormat: iFormat
                                };
                                featureCount = featureCount + 1;
                            }
                        }
                        else { // iFormat !== featureInfo.requestedFormat

                            // GLS:
                            TC.Util.consoleRegister("Respuesta GFI: lo más probable es que el servidor esté devolviendo una excepción");
                            TC.Util.consoleRegister("Lanzamos los eventos que corresponde y mostramos tostada");

                            // En este caso lo más probable es que el servidor esté devolviendo una excepción
                            self.parent.responseError({
                                message: featureInfo.responseText,
                                status: featureInfo.status
                            });
                            // GLS: misma gestión de error que en ol.js - > function (a, b, c) { // error...
                            map.toast(self.parent.getLocaleString('featureInfo.error'), {
                                type: TC.Consts.msgType.ERROR
                            });
                        }

                    }
                    if (someSuccess) {
                        var finfoPromises = featurePromises;
                        if (featurePromises.length) {
                            finfoPromises = finfoPromises.concat(new Promise(function (resolve, reject) {
                                // Si hay features cargamos el módulo de geometria para encontrar una que se interseque con el punto
                                TC.loadJS(
                                    !TC.Geometry,
                                    TC.apiLocation + 'TC/Geometry',
                                    function () {
                                        resolve();
                                    }
                                );
                            }));
                        }
                        Promise.all(finfoPromises).then(function (features) {
                            var defaultFeature;
                            features.forEach(function (feat, idx) {
                                if (feat) {
                                    feat.attributes = [];
                                    for (var key in feat.data) {
                                        var value = feat.data[key];
                                        if (typeof value !== 'object') {
                                            feat.attributes.push({
                                                name: key,
                                                value: typeof (value) == "number" ? value.toLocaleString(TC.Util.getMapLocale(self.parent.map)) : value
                                            });
                                        }
                                        else {
                                            feat.attributes.push({
                                                name: key,
                                                value: value//"objeto complejo"
                                            });
                                        }
                                    }
                                    if (!defaultFeature && TC.Geometry.isInside(coords, feat.geometry)) {
                                        defaultFeature = feat;
                                    }
                                    featureInsertionPoints[idx].push(feat);
                                }
                            });

                            var services = [];
                            for (var serviceUrl in targetServices) {
                                if (targetServices.hasOwnProperty(serviceUrl)) {
                                    services.push(targetServices[serviceUrl]);
                                }
                            }

                            self.parent.responseCallback({
                                coords: coords,
                                resolution: resolution,
                                services: services,
                                featureCount: featureCount,
                                defaultFeature: defaultFeature
                            });
                        });
                    }
                },
                    function (a, b, c) { // error
                        if (services && services.length == 0) {
                            for (var serviceUrl in targetServices) {
                                services.push(targetServices[serviceUrl]);
                            }
                        }

                        self.parent.responseCallback({
                            coords: coords, resolution: resolution, services: services, featureCount: 0
                        });
                        map.toast(self.parent.getLocaleString('featureInfo.error'), {
                            type: TC.Consts.msgType.ERROR
                        });
                    });
            }
            else {

                if (map.workLayers.filter(function (layer) {
                    return layer instanceof TC.layer.Raster;
                }).length > 0) {
                    map.toast(self.parent.getLocaleString('featureInfo.notQueryableLayers'), {
                        type: TC.Consts.msgType.INFO
                    });
                }

                if (services && services.length == 0) {
                    for (var serviceUrl in targetServices) {
                        services.push(targetServices[serviceUrl]);
                    }
                }

                // GLS: nos suscribimos TC.Consts.event.BEFOREFEATUREINFO y lanzamos el mismo evento de zero resultados ya que puede darse que la resolución se lance antes del before.
                map.on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                    self.parent.responseCallback({
                        coords: coords, resolution: resolution, services: services, featureCount: 0
                    });
                });

                self.parent.responseCallback({
                    coords: coords, resolution: resolution, services: services, featureCount: 0
                });
            }
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                self.hasSuitableLayers().then(function (hasLayers) {
                    if (hasLayers) {
                        if (!self.parent._isSearching) {
                            if (e.type == SINGLECLICK && !self.parent._isDrawing && !self.parent._isSearching) {
                                _clickTrigger.call(self, e);
                            }
                        }
                    }
                });
            }

        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.hasSuitableLayers = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const map = self.parent.map;
            var ret = false;
            map.wrap.getMap().then(function (olMap) {
                olMap.getLayers().forEach(function (olLayer) {
                    var layer = olLayer._wrap.parent;
                    var source = olLayer.getSource();
                    //Por qué en workLayers están el vectorial de medición, y cosas así?
                    if (source.getGetFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0) {
                        ret = true;
                        return false;   //break del foreach
                    }
                });
                resolve(ret);
            });
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.beginDraw = function (options) {
        var self = this;
        options = options || {};
        var xy = options.xy;
        var layer = options.layer;
        var callback = options.callback;
        var geometryType = options.geometryType;
        var semaforo = false;
        if (!self.drawCtrl) {
            layer.wrap.getLayer().then(function (olLayer) {
                var olGeometryType;
                switch (geometryType) {
                    case TC.Consts.geom.POLYLINE:
                        olGeometryType = ol.geom.GeometryType.LINE_STRING;
                        break;
                    default:
                        olGeometryType = ol.geom.GeometryType.POLYGON;
                        break;
                }
                self.drawCtrl = new ol.interaction.Draw({
                    source: olLayer.getSource(),
                    type: olGeometryType
                    , style: olLayer.getStyle()
                });
                var setShowsPopup = function (wrap) {
                    wrap.parent.showsPopup = false;
                };
                olLayer.getSource().on(ADDFEATURE, function (event) {
                    if (event.feature._wrap) {
                        setShowsPopup(event.feature._wrap);
                    }
                    else {
                        event.feature._wrapPromise.then(setShowsPopup);
                    }
                });
                self.drawCtrl.handleEvent = function (event) {
                    //esta ñapa para solucionar cuando haces un primer punto y acontinuación otro muy rápido
                    if (event.type == SINGLECLICK) {
                        var points = olGeometryType === ol.geom.GeometryType.POLYGON ? this.sketchCoords_[0] : this.sketchCoords_;
                        if (semaforo && points.length == 2 && this.sketchFeature_ !== null) {// GLS: Añado la misma validación (this.sketchFeature_ !== null) que tiene el código de OL antes de invocar addToDrawing_ 
                            this.addToDrawing_(event);
                        }
                        else {
                            semaforo = true;
                        }
                    }
                    return ol.interaction.Draw.prototype.handleEvent.call(this, event);
                }
                const map = self.parent.map;
                const olMap = map.wrap.map;
                olMap.addInteraction(self.drawCtrl);
                self.drawCtrl.on('drawstart', function (event) {
                    self.parent._isDrawing = true;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                });
                self.drawCtrl.startDrawing_({
                    coordinate: xy
                });
                self.drawCtrl.on('drawend', function (event) {
                    self.parent._isDrawing = false;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                    olMap.removeInteraction(self.drawCtrl);
                    this.setActive(false);
                    self.drawCtrl = null;
                    olLayer.getSource().clear();
                    self.parent._drawToken = true;
                    setTimeout(function () {
                        self.parent._drawToken = false;
                    }, 500);
                    if (callback) {
                        TC.wrap.Feature.createFeature(event.feature, { showsPopup: false }).then(function (feat) {
                            callback(feat);
                        });
                    }
                });
            });

        }
        else {
            self.drawCtrl.setActive(true);
            self.drawCtrl.startDrawing_({
                coordinate: xy
            });
        }
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.cancelDraw = function (xy, layer, callback) {
        var self = this;
        if (self.drawCtrl && self.parent._isDrawing) {
            self.parent._isDrawing = false;
            self.drawCtrl.setActive(false);
            self.drawCtrl.source_.clear();

        }
    };

    const _checkMaxFeatures = function (numMaxfeatures, urlData, data) {
        return new Promise(function (resolve) {
            urlData.mapLayer.toolProxification.fetchXML(urlData.url, {
                data: data,
                contentType: 'application/xml',
                type: 'POST'
            }).then(function (response) {
                if (response instanceof XMLDocument) {
                    const exception = response.querySelector("ExceptionReport Exception")
                    if (exception) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.INDETERMINATE,
                                params: {
                                    err: exception.getAttribute("exceptionCode"), errorThrown: exception.querySelector("ExceptionText").textContent
                                }
                            }]
                        })
                        return;
                    }
                }
                var featFounds = parseInt(response.querySelector("FeatureCollection").getAttribute("numberMatched") || response.querySelector("FeatureCollection").getAttribute("numberOfFeatures"), 10);
                if (isNaN(featFounds) || featFounds > parseInt(numMaxfeatures, 10)) {
                    resolve({
                        errors: [{
                            key: TC.Consts.WFSErrors.MAX_NUM_FEATURES
                        }]
                    });
                    return;
                }
                else if (featFounds === 0) {
                    resolve({
                        errors: [{
                            key: TC.Consts.WFSErrors.NO_FEATURES
                        }]
                    });
                    return;
                }
                else
                    resolve(featFounds);

            }).catch(function (e) {
                //return Promise.reject(error);

                resolve({
                    errors: [{
                        key: TC.Consts.WFSErrors.INDETERMINATE,
                        params: { err: e.name, errorThrown: e.message }
                    }]
                });
                return;
            });

            //TC.ajax({
            //    url: url,
            //    data: data,
            //    contentType: 'application/xml',
            //    responseType: 'application/xml',
            //    method: 'POST'
            //}).then(function (response) {
            //    const responseData = response.data;
            //    if (responseData instanceof XMLDocument) {
            //        const exception = responseData.querySelector("ExceptionReport Exception")
            //        if (exception) {
            //            resolve({
            //                errors: [{
            //                    key: TC.Consts.WFSErrors.INDETERMINATE,
            //                    params: {
            //                        err: exception.getAttribute("exceptionCode"), errorThrown: exception.querySelector("ExceptionText").textContent
            //                    }
            //                }]
            //            })
            //            return;
            //        }
            //    }
            //    var featFounds = parseInt(responseData.querySelector("FeatureCollection").getAttribute("numberMatched") || responseData.querySelector("FeatureCollection").getAttribute("numberOfFeatures"), 10);                
            //    if (isNaN(featFounds) || featFounds > parseInt(numMaxfeatures, 10)) {
            //        resolve({
            //            errors: [{
            //                key: TC.Consts.WFSErrors.MAX_NUM_FEATURES
            //            }]
            //        });
            //        return;
            //    }
            //    else if (featFounds === 0) {
            //        resolve({
            //            errors: [{
            //                key: TC.Consts.WFSErrors.NO_FEATURES
            //            }]
            //        });
            //        return;
            //    }
            //    else
            //        resolve(featFounds);

            //}, function (e) {
            //    resolve({
            //        errors: [{
            //            key: TC.Consts.WFSErrors.INDETERMINATE,
            //            params: { err: e.name, errorThrown: e.message }
            //        }]
            //    });
            //    return;
            //});
        });
    }

    const _makePostCall = function (urlData, data) {
        return new Promise(function (resolve) {
            urlData.mapLayer.toolProxification.fetch(urlData.url, {
                data: data,
                contentType: 'application/xml',
                type: 'POST'
            }).then(function (response) {
                if (response instanceof XMLDocument) {
                    const exception = response.querySelector("ExceptionReport Exception")
                    if (exception) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.INDETERMINATE,
                                params: {
                                    err: exception.getAttribute("exceptionCode"), errorThrown: exception.querySelector("ExceptionText").textContent
                                }
                            }]
                        })
                        return;
                    }
                }
                resolve({ response: response });
            }).catch(function (e) {
                resolve({
                    errors: [{
                        key: TC.Consts.WFSErrors.INDETERMINATE,
                        params: { err: e.name, errorThrown: e.message }
                    }]
                });
                return;
            });
        });
    };

    const magicFunction = function (layer, availableLayers, filter) {
        //obtenemos el describe featuretype de cada capa
        return new Promise(async function (resolve, reject) {
            try {
                var response = await layer.describeFeatureType(availableLayers);
            }
            catch (error) {
                reject(error);
                return;
            }
            var returnObject = {};
            if (availableLayers.length === 1) {
                var obj = {};
                obj[availableLayers[0]] = response;
                response = obj;
            }
            //buscamos las geometrías por cada respuesta
            for (var layerName in response) {
                let _filter;
                var geometryFields = [];
                for (var k in response[layerName]) {
                    if (TC.Util.isGeometry(response[layerName][k].type) && !response[layerName][k].nillable && !response[layerName][k].minOccurs) {
                        //if (/^gml:\w+PropertyType$/.test(response[layerName][k].type) && !response[layerName][k].nillable && !response[layerName][k].minOccurs) {
                        geometryFields.push(k)
                    }
                }
                //Si solo hay un campo de tipo geometría bsucamos recursivamente entre en los filtros logicos And y or a la caza de filtros espaciales
                //para poner el nombre de la geometría
                if (geometryFields.length <= 1) {
                    var recursive = (filter, geomName) => {
                        if (filter instanceof TC.filter.LogicalNary)
                            filter.conditions.forEach((condition) => {
                                recursive(condition, geomName)
                            })
                        else if (filter instanceof TC.filter.Spatial) {
                            filter.geometryName = geomName;
                            return filter;
                        }
                    };
                    _filter = Object.assign(new filter.constructor, recursive(filter, geometryFields.length === 0 ? null : geometryFields[0]))
                }
                //Si has mas de un campo de tipo geometría bsucamos recursivamente entre en los filtros logicos And y or a la caza de filtros espaciales
                //para duplicar el filtro con los nombres de las geometrias y los emvolvemos en un filtro OR
                else if (geometryFields.length > 1) {
                    var recursive = (filter, geomNames) => {
                        if (filter instanceof TC.filter.LogicalNary)
                            filter.conditions.forEach((condition) => {
                                recursive(condition, geomNames);
                            })
                        else if (filter instanceof TC.filter.Spatial) {
                            return TC.filter.or.apply(null, geomNames.reduce((acc, curr) => { acc.push(new TC.filter[filter.getTagName()](curr, filter.geometry, filter.srsName)); return acc }, []))
                        }
                    };
                    _filter = Object.assign(new filter.constructor, recursive(filter, geometryFields));
                }
                //ahora construimos el objeto que de vuelta
                returnObject[layerName] = _filter;
            }
            resolve(returnObject);

        });
    };

    var WFSGetFeatureBuilder = function (map, filter, outputFormat, download) {
        const arrPromises = [];

        var services = {};

        const _getServiceTitle = function (service) {
            const mapLayer = service.mapLayers[0];
            return service.title || service.mapLayers.reduce(function (prev, cur) {
                return prev || cur.title;
            }, '') || (mapLayer.tree && mapLayer.tree.title) || mapLayer.capabilities.Service.Title;
        };


        const olMap = map.wrap.map;
        const getCRS = function () {
            if (download && (outputFormat === TC.Consts.mimeType.JSON || outputFormat === TC.Consts.mimeType.KML))
                return TC.Consts.SRSDOWNLOAD_GEOJSON_KML;
            return map.getCRS();
        };
        const _postOrDownload = function (url, data) {
            return new Promise(function (resolve) {
                if (!download) {
                    _makePostCall(url, data).then(function (response) {
                        if (response.errors && response.errors.length > 0) {
                            response.errors[0].params["serviceTitle"] = service.mapLayers.reduce(function (prev, cur) {
                                return prev || cur.title;
                            }, '') || _getServiceTitle(service);
                            resolve(response);
                        }
                        else {
                            resolve(response);
                        }
                    })
                }
                else
                    resolve({
                        url: url.url,
                        data: data
                    });
            });
        };
        olMap.getLayers().forEach(function (olLayer) {
            var layer = olLayer._wrap.parent;
            if (!olLayer.getVisible() || map.workLayers.indexOf(layer) < 0 || layer.type !== TC.Consts.layerType.WMS)
                return;
            var availableLayers = layer.getDisgregatedLayerNames() || layer.availableNames;
            const url = layer.url.toLowerCase();
            var serviceObj = services[url];
            if (!serviceObj) {
                serviceObj = services[url] = {
                    url: url,
                    layers: [],
                    mapLayers: [layer],
                    layerNames: []
                };
            }
            for (var i = 0; i < availableLayers.length; i++) {
                var name = availableLayers[i];
                //URI:se quita la exclusion de capas no visibles por escala
                /*if (!layer.isVisibleByScale(name) && !download)
                    continue;*/
                if (!layer.wrap.getInfo(name).queryable)
                    continue;
                serviceObj.layerNames.push(name);
                var path = layer.getPath(name);
                serviceObj.layers.push({
                    name: name,
                    title: path[path.length - 1],
                    path: path.slice(1),
                    features: []
                });
            }
            if (serviceObj.layerNames.length == 0)
                return;
            if (typeof (serviceObj.request) !== "undefined") {
                return;
            }
            serviceObj.request = serviceObj.request || layer.getWFSCapabilities(); //WFSCapabilities.Promises(url);
            arrPromises.push(new Promise(function (resolve, reject) {
                serviceObj.request.then(function (capabilities) {
                    var service = null;
                    var errors = [];
                    for (var url in services)
                        if (services[url].request && services[url].request == serviceObj.request) {
                            service = services[url];
                        }
                    var _numMaxFeatures = null;
                    var layerList = service.layerNames;
                    if (!(layerList instanceof Array) || !layerList.length) return;//condici\u00f3n de salida
                    //comprobamos que tiene el getfeature habilitado
                    if (typeof (capabilities.Operations.GetFeature) === "undefined") {
                        errors.push({ key: TC.Consts.WFSErrors.GETFEATURE_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service) } })
                        resolve({ "errors": errors });
                        return;
                    }
                    var availableLayers = [];
                    for (var i = 0; i < layerList.length; i++) {
                        //Comprbamos si la capa en el WMS tiene el mimso nombre que en el WFS
                        var layer = layerList[i];
                        //quitamos los ultimos caracteres que sean "_" , cosas de Idena
                        while (layer[layer.length - 1] === "_") {
                            layer = layer.substring(0, layer.lastIndexOf("_"));
                        }
                        if (!capabilities.FeatureTypes.hasOwnProperty(layer.substring(layerList[i].indexOf(":") + 1))) {
                            var titles = service.mapLayers[0].getPath(layer.substring(layerList[i].indexOf(":") + 1));
                            errors.push({ key: TC.Consts.WFSErrors.LAYERS_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service), "layerName": titles[titles.length - 1] } });
                            continue;
                        }
                        if (availableLayers.indexOf(layer) < 0)
                            availableLayers.push(layer);
                    }
                    if (availableLayers.length == 0) {
                        errors.push({ key: TC.Consts.WFSErrors.NO_VALID_LAYERS, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    if (capabilities.Operations.GetFeature.CountDefault)
                        _numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
                    //comprobamos si soporta querys    
                    if (
                        (capabilities.version === "1.0.0" && !capabilities.Operations.GetFeature.Operations.hasOwnProperty("Query"))
                        ||
                        ((capabilities.version === "2.0.0" || capabilities.version === "1.1.0") && capabilities.Operations.QueryExpressions.indexOf("wfs:Query") < 0)
                    ) {
                        errors.push({ key: TC.Consts.WFSErrors.QUERY_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    var url = (capabilities.Operations.GetFeature.DCPType ? capabilities.Operations.GetFeature.DCPType[1].HTTP.Post.onlineResource : capabilities.Operations.GetFeature.DCP.HTTP.Post["href"]);

                    Promise.all([
                        magicFunction(service.mapLayers[0], availableLayers, filter)//clonar filtro
                    ]).then(function (response) {
                        var filter = response[0]; //1
                        if (_numMaxFeatures) {
                            _checkMaxFeatures(_numMaxFeatures, { url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, outputFormat, true, getCRS())).then(function (response) {
                                if (response.errors && response.errors.length > 0) {
                                    switch (response.errors[0].key) {
                                        case TC.Consts.WFSErrors.INDETERMINATE:
                                            response.errors[0].params["serviceTitle"] = service.mapLayers.reduce(function (prev, cur) {
                                                return prev || cur.title;
                                            }, '') || _getServiceTitle(service);
                                            break;
                                        case TC.Consts.WFSErrors.MAX_NUM_FEATURES:
                                            response.errors[0]["params"] = { limit: _numMaxFeatures, serviceTitle: _getServiceTitle(service) };
                                            break;
                                        case TC.Consts.WFSErrors.NO_FEATURES:
                                            response.errors[0]["params"] = { serviceTitle: _getServiceTitle(service) };
                                            break;
                                    }
                                    resolve(response);
                                }
                                else
                                    _postOrDownload({ url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {
                                        resolve(Object.assign({ service: service, errors: errors }, response));
                                    });
                            });
                        }
                        else {
                            _postOrDownload({ url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {
                                resolve(Object.assign({ service: service, errors: errors }, response))

                            });
                        }
                    }).catch(function (e) {
                        resolve({
                            errors: [{
                                key: TC.Consts.WFSErrors.INDETERMINATE,
                                params: { err: e.name, errorThrown: e.message, serviceTitle: _getServiceTitle(service) }
                            }]
                        });
                    });
                }, function (e) {
                    var service = null;
                    for (var title in services)
                        if (services[title].request && services[title].request === serviceObj.request) {
                            service = services[title];
                        }
                    resolve({ errors: [{ key: TC.Consts.WFSErrors.GETCAPABILITIES, params: { err: e.name, serviceTitle: _getServiceTitle(service) } }] });
                });
            }));
        });
        return arrPromises;
    };
    TC.WFSGetFeatureBuilder = WFSGetFeatureBuilder;

    var readFeaturesFromResponse = function (map, data, contentType) {
        var format;
        var iFormat = contentType;
        if (iFormat && iFormat.indexOf(";") > -1)
            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

        if (!iFormat) iFormat = data.requestedFormat;
        switch (iFormat) {
            case 'application/json':
                format = new ol.format.GeoJSON();
                break;
            case 'application/vnd.ogc.gml':
                if (data.responseText.indexOf("FeatureCollection") > -1)
                    format = new ol.format.WFS({
                        gmlFormat: new ol.format.GML2({
                            srsName: map.crs
                        })
                    });
                else
                    format = new ol.format.WMSGetFeatureInfo();
                break;
            case 'application/vnd.ogc.gml/3.1.1':
                format = new ol.format.GML3({
                    srsName: map.crs
                });
                break;
            case "text/xml":
            case "application/xml":
                //posible error
                const exception = data.querySelector("ServiceException");
                if (exception)
                    TC.error(exception);
                format = null;
                break;
            default:
                format = null;
                break;
        }
        if (format) {
            return format.readFeatures(data, {
                featureProjection: ol.proj.get(map.crs)
            });
        }
        else {
            return null;
            ////si no hay formato reconocido y parseable, metemos un iframe con la respuesta
            ////y prau
            ////para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent
            //var l = service.layers[0];
            //l.features.push({
            //    error: response.responseText
            //});
        }
    };
    var featureToServiceDistributor = function (features, service) {
        var featurePromises = [];
        var featureInsertionPoints = [];
        var isParentOrSame = function (layer, na, nb) {
            var result = false;
            if (na === nb || (na.indexOf(nb) === 0)) {
                result = true;
            }
            else {
                var pa = layer.getPath(na);
                var pb = layer.getPath(nb);
                if (pa.length > 0 && pb.length >= pa.length) {
                    result = true;
                    for (var i = 0; i < pa.length; i++) {
                        if (pa[i] !== pb[i]) {
                            result = false;
                            break;
                        }
                    }
                }
            }
            return result;
        };

        var fakeLayers = {};
        for (var j = 0; j < features.length; j++) {
            var feature = features[j];
            if (feature instanceof ol.Feature) {
                var fid = feature.getId() || TC.getUID();
                var found = false;
                var layerName = fid.substr(0, fid.lastIndexOf('.'));
                for (var k = 0; k < service.layers.length; k++) {
                    var l = service.layers[k];
                    var lName = l.name.substr(l.name.indexOf(':') + 1);
                    if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                        found = true;
                        featurePromises.push(TC.wrap.Feature.createFeature(feature));

                        featureInsertionPoints[feature.id_] = (l.features);
                        break;
                    }
                }

                //si llegamos aqu\u00ed y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                //esto pasa, p.ej, en cartociudad
                if (!found) {
                    //as\u00ed que creo un layer de palo para la respuesta del featInfo
                    var fakeLayer;
                    if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                    else {
                        fakeLayer = {
                            name: layerName, title: layerName, features: []
                        };
                        fakeLayers[layerName] = fakeLayer;
                        service.layers.push(fakeLayer);
                    }

                    featurePromises.push(TC.wrap.Feature.createFeature(feature));
                    featureInsertionPoints.push(feature.id_);
                }
            }
        }//iteraci\u00f3n sobre las features de esta respuesta

        return new Promise(function (resolve, reject) {
            Promise.all(featurePromises).then(function (features) {
                features.forEach(function (feat) {
                    feat.attributes = [];
                    //feat.showsPopup = false;
                    for (var key in feat.data) {
                        var value = feat.data[key];
                        if (typeof value !== 'object') {
                            feat.attributes.push({
                                name: key, value: value
                            });
                        }
                        else {
                            feat.attributes.push({
                                name: key,
                                value: value//"objeto complejo"
                            });
                        }
                    }
                    featureInsertionPoints[feat.id].push(feat);
                });
                resolve({
                    service: service
                })
            });
        });
    }

    TC.wrap.control.GeometryFeatureInfo.prototype.getFeaturesByGeometry = function (feature, xy) {

        var self = this;
        var map = self.parent.map;
        self.parent.filterFeature = feature;
        feature.layer = self.parent.filterLayer;

        map.wrap.getMap().then(function (olMap) {

            var olGeometry = feature.wrap.feature.getGeometry();
            var stride = olGeometry.stride;
            var flatCoordinates = olGeometry.getFlatCoordinates();
            //calcular el punto mas alto
            if (!xy) {
                var bestPoint = null;
                for (var i = 1, len = flatCoordinates.length; i < len; i += stride) {
                    if (!bestPoint || bestPoint[1] < flatCoordinates[i]) {
                        bestPoint = [flatCoordinates[i - 1], flatCoordinates[i]];
                    }
                }
                xy = olMap.getPixelFromCoordinate(new ol.geom.Point(bestPoint).getCoordinates());
            }

            self.parent.beforeRequest({ xy: xy });

            var arrRequests = WFSGetFeatureBuilder(map, new TC.filter.intersects(feature, map.crs), TC.Consts.format.JSON);

            const arrPromises = [];
            Promise.all(arrRequests).then(function (responses) {
                var targetServices = [];
                var featureCount = 0;
                var hayError = false;

                for (var i = 0; i < responses.length; i++) {
                    const responseObj = responses[i];
                    if (!responseObj) continue;
                    arrPromises[arrPromises.length] = new Promise(function (resolve, reject) {
                        if (responseObj.errors && responseObj.errors.length) {
                            for (var j = 0; j < responseObj.errors.length; j++) {
                                var errorMsg, errorType = TC.Consts.msgType.WARNING;
                                hayError = true;
                                var error = responseObj.errors[j];
                                switch (error.key) {
                                    case TC.Consts.WFSErrors.MAX_NUM_FEATURES:
                                        errorMsg = self.parent.getLocaleString("wfs.tooManyFeatures", error.params);
                                        break;
                                        /*case TC.Consts.WFSErrors.NO_LAYERS:
                                            errorMsg = self.parent.getLocaleString('noLayersLoaded');*/
                                        break;
                                    case TC.Consts.WFSErrors.GETCAPABILITIES:
                                        errorMsg = self.parent.getLocaleString('wfsGFI.inValidService', error.params);
                                        break;
                                    case TC.Consts.WFSErrors.NO_FEATURES:
                                        //si no hay features nos callamos. Quizas en un futuro se muestre una alerta
                                        hayError = false;
                                        continue;
                                        break;
                                    case TC.Consts.WFSErrors.INDETERMINATE:
                                        errorMsg = self.parent.getLocaleString("wfs.IndeterminateError");
                                        TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                                        errorType = TC.Consts.msgType.ERROR;
                                        break;
                                    default:
                                        errorMsg = self.parent.getLocaleString("wfsGFI." + error.key, error.params);
                                        break;
                                }

                                map.toast(errorMsg, { type: errorType });
                            }
                            if (!responseObj.response) {
                                resolve();
                            }
                        }
                    });

                    // Puede no haber response porque la URL no es correcta, metemos un condicional
                    var featuresFound = responseObj.response ? readFeaturesFromResponse(map, responseObj.response.responseText, responseObj.response.contentType) : [];
                    //ahora se distribuye la features por servicio y capa
                    arrPromises[arrPromises.length - 1] = featureToServiceDistributor(featuresFound, responseObj.service);
                    if (responseObj.service) {
                        targetServices.push(responseObj.service);
                    }
                    featureCount = featureCount + featuresFound.length;
                }
                Promise.all(arrPromises).then(function () {
                    self.parent.responseCallback({
                        xy: xy || null, services: targetServices, featureCount: featureCount
                    });
                });
            }, function (e) {
                self.parent.responseCallback({});
            })
        });
    };

    TC.wrap.control.Popup.prototype = function () {
        this.popup = null;
    };

    TC.Consts.event.PANANIMATIONSTART = 'pananimationstart.tc';
    TC.Consts.event.PANANIMATIONEND = 'pananimationend.tc';
    TC.wrap.control.Popup.prototype.fitToView = function () {
        var self = this;
        var map = self.parent.map;
        var olMap = self.parent.map.wrap.map;

        var popupBoundingRect = self.parent.popupDiv.getBoundingClientRect();
        var mapBoundingRect = map.div.getBoundingClientRect();

        var topLeft = olMap.getCoordinateFromPixel([popupBoundingRect.left - mapBoundingRect.left, popupBoundingRect.top - mapBoundingRect.top]);
        var bottomRight = olMap.getCoordinateFromPixel([popupBoundingRect.right - mapBoundingRect.left, popupBoundingRect.bottom - mapBoundingRect.top]);
        var west = topLeft[0];
        var north = topLeft[1];
        var east = bottomRight[0];
        var south = bottomRight[1];

        var popupExt = [west, south, east, north];
        var mapExt = map.getExtent();

        if (!ol.extent.containsExtent(mapExt, popupExt)) {
            var overflows = {
                left: Math.max(mapExt[0] - popupExt[0], 0),
                bottom: Math.max(mapExt[1] - popupExt[1], 0),
                right: Math.max(popupExt[2] - mapExt[2], 0),
                top: Math.max(popupExt[3] - mapExt[3], 0)
            };

            if (self.parent.dragged) {
                // Movemos el popup
                var newPos = self.popup.getPosition();
                if (overflows.right) {
                    newPos[0] = newPos[0] - overflows.right;
                }
                else if (overflows.left) {
                    newPos[0] = newPos[0] + overflows.left;
                }
                if (overflows.top) {
                    newPos[1] = newPos[1] - overflows.top;
                }
                else if (overflows.bottom) {
                    newPos[1] = newPos[1] + overflows.bottom;
                }
                var newPixelPos = olMap.getPixelFromCoordinate(newPos);
                newPixelPos[1] = olMap.getSize()[1] - newPixelPos[1];
                self.parent._previousContainerPosition = newPixelPos;
                (self.popup._oldUpdatePixelPosition || self.popup.updatePixelPosition).call(self.popup, newPos);
            }
            else {
                if (self.parent.isVisible()) {
                    // Movemos el mapa
                    var view = olMap.getView();
                    var ct = view.getCenter().slice();

                    if (overflows.top) ct[1] += overflows.top;
                    else if (overflows.bottom) ct[1] -= overflows.bottom;
                    if (overflows.right) ct[0] += overflows.right;
                    else if (overflows.left) ct[0] -= overflows.left;

                    view.animate({
                        center: ct, easing: function (percent) {
                            if (percent === 0) self.parent.map.trigger(TC.Consts.event.PANANIMATIONSTART);
                            if (percent === 1) self.parent.map.trigger(TC.Consts.event.PANANIMATIONEND);
                            return percent;
                        }
                    });
                }
            }
        }
    };

    TC.wrap.control.Popup.prototype.setDragged = function (dragged) {
        var popup = this.popup;
        //var view = popup.getMap().getView();
        //var onViewChange = function () {
        //    console.log(this.getCenter());
        //};
        if (dragged) {
            // Parcheamos funciones para que el popup no se mueva cuando cambiamos el extent del mapa
            if (!popup._oldUpdatePixelPosition) {
                popup._oldUpdatePixelPosition = popup.updatePixelPosition;
                popup.updatePixelPosition = function () {
                };
            }
            if (!popup._newHandleOffsetChanged) {
                popup._newHandleOffsetChanged = function () {
                    this._oldUpdatePixelPosition();
                };
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup.handleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup._newHandleOffsetChanged, popup);
            }
            //view.on(['change:center','change:resolution'], onViewChange);
        }
        else {
            // Redefinimos las propiedades de posicionamiento porque al arrastrarlo, las hemos modificado.
            const containerStyle = popup.getElement().parentElement.style;
            containerStyle.setProperty('top', popup.rendered.top_);
            containerStyle.setProperty('bottom', popup.rendered.bottom_);
            containerStyle.setProperty('left', popup.rendered.left_);
            containerStyle.setProperty('right', popup.rendered.right_);

            delete this.parent._previousContainerPosition;
            // Deshacemos parcheo
            if (popup._oldUpdatePixelPosition) {
                popup.updatePixelPosition = popup._oldUpdatePixelPosition;
                delete popup._oldUpdatePixelPosition;
            }
            if (popup._newHandleOffsetChanged) {
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup._newHandleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType('offset'),
                    popup.handleOffsetChanged, popup);
                delete popup._newHandleOffsetChanged;
            }
            //view.un(['change:center', 'change:resolution'], onViewChange);
        }
    };

    TC.wrap.Feature.prototype.getLegend = function () {
        var self = this;
        var result = {
        };
        var style = getNativeFeatureStyle(self.feature, true);
        if (style) {
            var image = style.getImage();
            if (image) {
                if (image instanceof ol.style.Icon) {
                    result.src = image.getSrc();
                    var scale = image.getScale();
                    if (scale) {
                        result.scale = scale;
                        var img = image.getImage();
                        if (img.width) {
                            result.width = img.width * scale;
                            result.height = img.height * scale;
                        }
                    }
                }
                else if (image instanceof ol.style.Circle) {
                    result.src = image.canvas_.toDataURL();
                }
                if (self.parent.options.radius) {
                    result.height = result.width = self.parent.options.radius * 2;
                }
                else {
                    result.width = result.width || self.parent.options.width;
                    result.height = result.height || self.parent.options.height;
                }
            }
            else {
                // No image, find stroke and fill
                var stroke = style.getStroke();
                var fill = style.getFill();
                if (stroke) {
                    var strokeColor = stroke.getColor();
                    if (strokeColor) {
                        result.strokeColor = ol.color.asString(strokeColor);
                    }
                    var strokeWidth = stroke.getWidth();
                    if (strokeWidth) {
                        result.strokeWidth = strokeWidth;
                    }
                }
                if (fill) {
                    var fillColor = fill.getColor();
                    if (fillColor) {
                        result.fillColor = ol.color.asString(fillColor);
                    }
                }
            }
        }

        return result;
    };

    var createNativeFeature = function (geometryName) {
        const result = new ol.Feature();
        if (geometryName) {
            result.setGeometryName(geometryName);
        }
        return result;
    };

    TC.wrap.Feature.prototype.createPoint = function (coords, options) {
        const self = this;
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (TC.Util.hasStyleOptions(options)) {
            self.feature.setStyle(createNativeStyle({ styles: { point: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMarker = function (coords, options) {
        const self = this;

        var iconUrl = TC.Util.getPointIconUrl(options);
        if (iconUrl) {
            options.url = iconUrl;
            self.feature = createNativeFeature(options.geometryName);
            self.feature._wrap = self;
            self.parent.setCoords(coords);
            if (TC.Util.hasStyleOptions(options)) {
                self.feature.setStyle(createNativeStyle({ styles: { marker: options } }, self.feature));
            }
            self.setData(self.parent.data);
        }
        else {
            self.createPoint(coords, options);
        }
    };

    TC.wrap.Feature.prototype.createPolyline = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (TC.Util.hasStyleOptions(options)) {
            self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createPolygon = function (coords, options) {
        const self = this;
        options = options || {};
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (TC.Util.hasStyleOptions(options)) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };


    TC.wrap.Feature.prototype.createMultiPolyline = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (TC.Util.hasStyleOptions(options)) {
            self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMultiPolygon = function (coords, options) {
        const self = this;
        options = options || {};
        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (TC.Util.hasStyleOptions(options)) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createCircle = function (coords, options) {
        const self = this;

        self.feature = createNativeFeature(options.geometryName);
        self.feature._wrap = self;
        self.parent.setCoords(coords);
        if (options) {
            self.feature.setStyle(
                new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: options.strokeColor,
                        width: options.strokeWidth,
                        lineDash: options.lineDash
                    }),
                    fill: new ol.style.Fill({
                        color: getRGBA(options.fillColor, options.fillOpacity)
                    })
                })
            );
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.createFeature = function (olFeat, options) {
        if (!olFeat._featurePromise) {
            olFeat._featurePromise = new Promise(function (resolve, reject) {
                var olGeometry = olFeat.getGeometry();
                options = options || {};
                options.id = olFeat.getId();
                let olStyle = olFeat.getStyle();
                if (olStyle) {
                    TC.Util.extend(options, getStyleFromNative(olStyle, olFeat));
                }
                // geometría
                let geomStr;
                switch (true) {
                    case olGeometry instanceof ol.geom.Point:
                        if (TC.Util.isFunction(olStyle)) {
                            olStyle = olStyle(olFeat);
                        }
                        var olStyles = olStyle ? (Array.isArray(olStyle) ? olStyle : [olStyle]) : [];
                        for (var i = 0, len = olStyles.length; i < len; i++) {
                            olStyle = olStyles[i];
                            if (olStyle.getImage() instanceof ol.style.Icon) {
                                geomStr = 'Marker';
                                break;
                            }
                        }
                        geomStr = geomStr || 'Point';
                        break;
                    case olGeometry instanceof ol.geom.LineString:
                        geomStr = 'Polyline';
                        break;
                    case olGeometry instanceof ol.geom.Polygon:
                        geomStr = 'Polygon';
                        break;
                    case olGeometry instanceof ol.geom.MultiLineString:
                        geomStr = 'MultiPolyline';
                        break;
                    case olGeometry instanceof ol.geom.MultiPolygon:
                        geomStr = 'MultiPolygon';
                        break;
                    default:
                        break;
                }
                if (geomStr) {
                    TC.loadJS(
                        !TC.feature || !TC.feature[geomStr],
                        [TC.apiLocation + 'TC/feature/' + geomStr],
                        function () {
                            const feat = new TC.feature[geomStr](olFeat, options);
                            feat.data = feat.wrap.getData();
                            resolve(feat);
                        }
                    );
                }
                else {
                    TC.loadJS(
                        !TC.Feature,
                        [TC.apiLocation + 'TC/Feature'],
                        function () {
                            var feat = new TC.Feature(olFeat, options);
                            feat.data = feat.wrap.getData();
                            resolve(feat);
                        }
                    );
                }
            });
        }
        return olFeat._featurePromise;
    };

    TC.wrap.Feature.prototype.cloneFeature = function () {
        return this.feature.clone();
    };

    TC.wrap.Feature.prototype.getStyle = function () {
        var self = this;
        var result = {};
        var olStyle = self.feature.getStyle();
        if (TC.Util.isFunction(olStyle)) {
            olStyle = olStyle(self.feature);
        }
        var olStyles = olStyle ? (Array.isArray(olStyle) ? olStyle : [olStyle]) : [];

        const getFill = function (style, obj) {
            if (style) {
                const fill = style.getFill();
                if (fill) {
                    obj.fillColor = fill.getColor();
                    if (Array.isArray(obj.fillColor)) {
                        obj.fillOpacity = obj.fillColor[3];
                    }
                }
            }
        };
        const getStroke = function (style, obj) {
            if (style) {
                const stroke = style.getStroke();
                if (stroke) {
                    obj.strokeColor = stroke.getColor();
                    obj.strokeWidth = stroke.getWidth();
                }
            }
        };

        for (var i = 0, len = olStyles.length; i < len; i++) {
            olStyle = olStyles[i];
            getFill(olStyle, result);
            getStroke(olStyle, result);
            const image = olStyle.getImage();
            if (image instanceof ol.style.Icon) {
                result.url = image.getSrc();
                const size = image.getSize();
                const scale = image.getScale() || 1;
                if (size) {
                    result.width = size[0] * scale;
                    result.height = size[1] * scale;
                }
                var anchor = image.getAnchor();
                if (anchor) {
                    result.anchor = [anchor[0] * scale, anchor[1] * scale];
                    if (size) {
                        // getAnchor devuelve los valores en pixels, hay que transformar a fracción
                        result.anchor[0] = result.anchor[0] / result.width;
                        result.anchor[1] = result.anchor[1] / result.height;
                    }
                }
            }
            else {
                getFill(image, result);
                getStroke(image, result);
            }
            var text = olStyle.getText();
            if (text) {
                result.label = text.getText();
                var font = text.getFont();
                if (font) {
                    // A 96dpi 3pt = 4px
                    result.fontSize = parseInt(font.match(/\d+pt/)) || parseInt(font.match(/\d+px/)) * 0.75;
                }
                var rotation = text.getRotation();
                if (rotation) {
                    result.angle = -180 * rotation / Math.PI;
                }
                result.labelOffset = [text.getOffsetX(), text.getOffsetY()];
                fill = text.getFill();
                if (fill) {
                    result.fontColor = fill.getColor();
                }
                stroke = text.getStroke();
                if (stroke) {
                    result.labelOutlineColor = stroke.getColor();
                    result.labelOutlineWidth = stroke.getWidth();
                }
            }
        }
        TC.Util.extend(self.parent.options, result);
        return result;
    };

    TC.wrap.Feature.prototype.getGeometry = function () {
        var result;
        var self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            if (geom) {
                if (geom.getCoordinates) {
                    result = geom.getCoordinates();
                }
                else if (geom instanceof ol.geom.Circle) {
                    result = [geom.getCenter(), geom.getRadius()];
                }
            }
        }
        return result;
    };

    TC.wrap.Feature.prototype.setGeometry = function (geometry) {
        const self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            var ctor;
            var point,
                points,
                ringsOrPolylines,
                polygons,
                isMultiPolygon,
                isPolygonOrMultiLineString,
                isLineString;
            // punto: array de números
            // línea o anillo: array de puntos
            // multilínea o polígono: array de líneas o anillos
            // multipolígono: array de polígonos
            // Por tanto podemos recorrer los tipos en un switch sin breaks
            switch (true) {
                case (TC.feature.MultiPolygon && self.parent instanceof TC.feature.MultiPolygon):
                    isMultiPolygon = true;
                    ctor = ol.geom.MultiPolygon;
                    polygons = geometry;
                    if (Array.isArray(polygons)) {
                        ringsOrPolylines = geometry[0];
                    }
                case (TC.feature.Polygon && self.parent instanceof TC.feature.Polygon || TC.feature.MultiPolyline && self.parent instanceof TC.feature.MultiPolyline):
                    isPolygonOrMultiLineString = true;
                    ctor = ctor || ((TC.feature.Polygon && self.parent instanceof TC.feature.Polygon) ? ol.geom.Polygon : ol.geom.MultiLineString);
                    ringsOrPolylines = isMultiPolygon ? ringsOrPolylines : geometry;
                    if (Array.isArray(ringsOrPolylines)) {
                        points = ringsOrPolylines[0];
                    }
                case (TC.feature.Polyline && self.parent instanceof TC.feature.Polyline):
                    isLineString = true;
                    ctor = ctor || ol.geom.LineString;
                    points = isPolygonOrMultiLineString ? points : geometry;
                    if (Array.isArray(points)) {
                        point = points[0];
                    }
                case (TC.feature.Point && self.parent instanceof TC.feature.Point):
                    ctor = ctor || ol.geom.Point;
                    point = isLineString ? point : geometry;
                    if (Array.isArray(point) && typeof point[0] === 'number' && typeof point[1] === 'number') {
                        var layout;
                        switch (point.length) {
                            case 3:
                                layout = ol.geom.GeometryLayout.XYZ;
                                break;
                            case 4:
                                layout = ol.geom.GeometryLayout.XYZM;
                                break;
                            default:
                                layout = ol.geom.GeometryLayout.XY;
                                break;
                        }
                        if (geom) {
                            geom.setCoordinates(geometry, layout);
                        }
                        else {
                            geom = new ctor(geometry, layout);
                            self.feature.setGeometry(geom);
                        }
                    }
                    break;
                case (TC.feature.Circle && self.parent instanceof TC.feature.Circle):
                    if (Array.isArray(geometry) &&
                        Array.isArray(geometry[0])
                        && typeof geometry[0][0] === 'number' && typeof geometry[0][1] === 'number'
                        && typeof geometry[1] === 'number') {
                        var layout;
                        switch (geometry[0].length) {
                            case 3:
                                layout = ol.geom.GeometryLayout.XYZ;
                                break;
                            case 4:
                                layout = ol.geom.GeometryLayout.XYZM;
                                break;
                            default:
                                layout = ol.geom.GeometryLayout.XY;
                                break;
                        }
                        if (geom) {
                            geom.setCenterAndRadius(geometry[0], geometry[1], layout);
                        }
                        else {
                            geom = new ol.geom.Circle(geometry[0], geometry[1], layout);
                            self.feature.setGeometry(geom);
                        }
                    }
                    break;
            }
        }
    };

    TC.wrap.Feature.prototype.getId = function () {
        var result;
        var self = this;
        if (self.feature) {
            result = self.feature.getId();
        };
        return result;
    };

    TC.wrap.Feature.prototype.setId = function (id) {
        var self = this;
        if (self.feature) {
            self.feature.setId(id);
        };
    };

    const getPolygonLength = function (polygon, options) {
        const self = this;
        var result = 0;
        polygon.getLinearRings().forEach(function (ring) {
            coordinates = ring.getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            const newRing = polygon.getLinearRing(0);
            result = result + ol.geom.flat.linearRingLength(newRing.flatCoordinates, 0, newRing.flatCoordinates.length, newRing.stride);
        });
        return result;
    };

    const getLineStringLength = function (lineString, options) {
        const self = this;
        coordinates = lineString.getCoordinates();
        if (options.crs) {
            coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
        }
        const line = new ol.geom.LineString(coordinates);
        return line.getLength();
    };

    TC.wrap.Feature.prototype.getLength = function (options) {
        const self = this;
        options = options || {};
        var result = 0;

        const geom = self.feature.getGeometry();
        var coordinates;
        switch (true) {
            case geom instanceof ol.geom.Polygon:
                result = getPolygonLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.LineString:
                result = getLineStringLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getPolygons().forEach(function (polygon) {
                    result = result + getPolygonLength.call(self, polygon, options);
                });
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getLineStrings().forEach(function (lineString) {
                    result = result + getLineStringLength.call(self, lineString, options);
                });
                break;
        }

        return result;
    };

    TC.wrap.Feature.prototype.getArea = function (options) {
        const self = this;
        options = options || {};

        const geom = self.feature.getGeometry();
        var coordinates;
        if (geom instanceof ol.geom.Polygon) {
            coordinates = geom.getLinearRing(0).getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            return polygon.getArea();
        }
    };

    const getNativeFeatureStyle = function (feature, readonly) {
        var style = feature.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(feature);
        }
        if (Array.isArray(style)) {
            style = style.reduce(function (extendedStyle, currentStyle) {
                extendedStyle.fill_ = currentStyle.fill_ || extendedStyle.fill_;
                extendedStyle.image_ = currentStyle.image_ || extendedStyle.image_;
                extendedStyle.stroke_ = currentStyle.stroke_ || extendedStyle.stroke_;
                extendedStyle.text_ = currentStyle.text_ || extendedStyle.text_;
                return extendedStyle;
            }, new ol.style.Style());
        }
        if (!style && !readonly) {
            style = new ol.style.Style();
            feature.setStyle(style);
        }
        return style;
    };

    const getNativeLayerStyle = function (feature) {
        var style = this.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(feature);
        }
        if (Array.isArray(style)) {
            style = style[style.length - 1];
        }
        if (!style) {
            style = new ol.style.Style();
        }
        return style;
    };

    TC.wrap.Feature.prototype.setStyle = function (options) {
        const self = this;
        const olFeat = self.feature;
        if (options === null) {
            olFeat.setStyle(null);
            return;
        }
        const feature = self.parent;
        const geom = olFeat.getGeometry();
        let newStyle = olFeat.getStyle();
        let layerStyle;
        if (feature.layer) {
            layerStyle = getNativeLayerStyle.call(feature.layer.wrap.layer, feature.wrap.feature);
        }
        if (!newStyle) {
            if (layerStyle) {
                newStyle = layerStyle.clone();
            }
            else {
                newStyle = new ol.style.Style();
            }
        }
        if (TC.Util.isFunction(newStyle)) {
            newStyle = newStyle(olFeat);
        }
        if (!Array.isArray(newStyle)) {
            newStyle = [newStyle];
        }
        let style = newStyle[newStyle.length - 1];
        if (geom instanceof ol.geom.Point || geom instanceof ol.geom.MultiPoint) {

            var imageStyle;
            if (options.anchor || options.url || options.cssClass) { // Marcador
                imageStyle = style.getImage();
                const iconOptions = {};
                if (imageStyle instanceof ol.style.Icon) {
                    iconOptions.src = options.url || TC.Util.getBackgroundUrlFromCss(options.cssClass) || imageStyle.getSrc();

                    if (options.width && options.height) {
                        iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                    }
                    else {
                        iconOptions.size = imageStyle.getSize();
                    }
                    iconOptions.anchor = getStyleValue(options.anchor, feature);
                    if (!iconOptions.anchor) {
                        const imgAnchor = imageStyle.getAnchor();
                        if (Array.isArray(imgAnchor)) {
                            iconOptions.anchor = imgAnchor.map(function (elm, idx) {
                                return elm / iconOptions.size[idx];
                            });
                        }
                    }
                }
                else {
                    iconOptions.src = TC.Util.getPointIconUrl(options);
                    iconOptions.anchor = getStyleValue(options.anchor, feature);
                    iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                };
                if (options.angle) {
                    iconOptions.angle = options.angle;
                }

                imageStyle = new ol.style.Icon(iconOptions);
            }
            else if (!(style.getImage()) && style.getText()) { // Etiqueta

                if (options.label !== undefined) {
                    if (options.label.length) {
                        style.setText(createNativeTextStyle(options, feature));
                    }
                    else {
                        style.setText();
                    }
                } else {
                    style.setText();
                }
            }
            else { // Punto sin icono
                imageStyle = style.getImage();
                if (!imageStyle) {
                    imageStyle = new ol.style.Circle();
                }
                const circleOptions = {
                    radius: getStyleValue(options.radius, feature) ||
                    (getStyleValue(options.height, feature) + getStyleValue(options.width, feature)) / 4
                };
                if (isNaN(circleOptions.radius)) {
                    circleOptions.radius = imageStyle.getRadius();
                }
                if (options.fillColor) {
                    circleOptions.fill = new ol.style.Fill({
                        color: getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature))
                    });
                }
                else {
                    circleOptions.fill = imageStyle.getFill();
                }
                circleOptions.stroke = imageStyle.getStroke();
                const layerStroke = layerStyle && layerStyle.getStroke();
                if (options.strokeColor || options.strokeWidth) {
                    if (!circleOptions.stroke) {
                        circleOptions.stroke = new ol.style.Stroke();
                    }
                    if (options.strokeColor) {
                        circleOptions.stroke.setColor(getStyleValue(options.strokeColor, feature));
                    }
                    else {
                        const strokeColor = circleOptions.stroke.getColor() || (layerStroke && layerStroke.getColor() || TC.Cfg.styles.point.strokeColor);
                        circleOptions.stroke.setColor(getStyleValue(strokeColor, feature));
                    }
                    if (options.strokeWidth) {
                        circleOptions.stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                    }
                    else {
                        const strokeWidth = circleOptions.stroke.getWidth() || (layerStroke && layerStroke.getWidth() || TC.Cfg.styles.point.strokeWidth);
                        circleOptions.stroke.setWidth(getStyleValue(strokeWidth, feature));
                    }
                }
                imageStyle = new ol.style.Circle(circleOptions);
            }
            style.setImage(imageStyle);
        }
        else {
            var stroke = style.getStroke();
            var strokeChanged = false;
            if (!stroke) {
                stroke = new ol.style.Stroke();
            }
            if (options.strokeColor) {
                stroke.setColor(getStyleValue(options.strokeColor, feature));
                strokeChanged = true;
            }
            if (options.strokeWidth) {
                stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                strokeChanged = true;
            }
            if (options.lineDash) {
                stroke.setLineDash(options.lineDash)
                strokeChanged = true;
            }
            if (strokeChanged) {
                style.setStroke(stroke);
            }
            if (geom instanceof ol.geom.Polygon || geom instanceof ol.geom.MultiPolygon) {
                if (options.fillColor || options.fillOpacity) {
                    var fill = style.getFill() || new ol.style.Fill();
                    fill.setColor(getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature)));
                    style.setFill(fill);
                }
            }
        }

        if (options.label !== undefined) {
            if (options.label.length) {
                style.setText(createNativeTextStyle(options, feature));
            }
            else {
                style.setText();
            }
        }
        olFeat.setStyle(newStyle);
        olFeat.changed();
    };

    TC.wrap.Feature.prototype.toggleSelectedStyle = function (condition) {
        const self = this;
        const feature = self.feature;
        const setStyle = condition === undefined ? !feature._originalStyle : condition;
        if (setStyle) {
            setSelectedStyle(feature);
        }
        else {
            removeSelectedStyle(feature);
        }
    };

    TC.wrap.Feature.prototype.getInnerPoint = function (options) {
        var result;
        var opts = options || {};
        // Funciones para hacer clipping con el extent actual. Así nos aseguramos de que el popup sale en un punto visible actualmente.
        var feature = this.feature;
        var geometry = feature.getGeometry();

        const clipCoord = function (coord) {
            const clipBox = opts.clipBox;
            coord[0] = Math.min(Math.max(coord[0], clipBox[0]), clipBox[2]);
            coord[1] = Math.min(Math.max(coord[1], clipBox[1]), clipBox[3]);
        };
        const clipPolygon = function (geom) {
            if (opts.clipBox) {
                geom[0].forEach(clipCoord);
            }
        };
        const clipPolyline = function (geom) {
            const clipBox = opts.clipBox;
            if (clipBox) {
                for (var i = geom.length - 1; i >= 0; i--) {
                    const coord = geom[i];
                    const x = coord[0];
                    const y = coord[1];
                    if (x < clipBox[0] || x > clipBox[2] || y < clipBox[1] || y > clipBox[3]) {
                        geom.splice(i, 1);
                    }
                }
            }
        };

        result = geometry.getFirstCoordinate();
        switch (geometry.getType()) {
            case ol.geom.GeometryType.MULTI_POLYGON:
                var area = 0;
                geometry = geometry.getPolygons().reduce(function (prev, cur) {
                    const curArea = cur.getArea();
                    const result = curArea > area ? cur : prev;
                    area = curArea;
                    return result;
                });
            case ol.geom.GeometryType.POLYGON:
                var isInsideRing = function (point, ring) {
                    var result = false;
                    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                        var xi = ring[i][0], yi = ring[i][1];
                        var xj = ring[j][0], yj = ring[j][1];
                        var intersect = ((yi > point[1]) != (yj > point[1])) &&
                            (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                        if (intersect) result = !result;
                    }
                    return result;
                };
                var coords = geometry.getCoordinates();
                clipPolygon(coords);
                geometry = new ol.geom.Polygon(coords);
                result = geometry.getInteriorPoint().getCoordinates();
                var rings = geometry.getLinearRings();
                // Miramos si el punto está dentro de un agujero
                for (var i = 1; i < rings.length; i++) {
                    if (isInsideRing(result, rings[i].getCoordinates())) {
                        result = geometry.getClosestPoint(result);
                        break;
                    }
                }
                break;
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                var length = 0;
                geometry = geometry.getLineStrings().reduce(function (prev, cur) {
                    const curLength = cur.getLength();
                    const result = curLength > length ? cur : prev;
                    length = curLength;
                    return result;
                });
            case ol.geom.GeometryType.LINE_STRING:
                var centroid = [0, 0];
                var coords = geometry.getCoordinates();
                clipPolyline(coords);
                geometry = new ol.geom.LineString(coords);
                for (var i = 0; i < coords.length; i++) {
                    centroid[0] += coords[i][0];
                    centroid[1] += coords[i][1];
                }
                centroid[0] /= coords.length;
                centroid[1] /= coords.length;
                result = geometry.getClosestPoint(centroid);
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.Feature.prototype.showPopup = function (popupCtl) {
        var self = this;
        var map = popupCtl.map;
        if (map) {
            var feature = self.feature;
            if (feature) {
                map.currentFeature = self.parent;
                var currentExtent = map.getExtent();

                self._innerCentroid = self.getInnerPoint({ clipBox: currentExtent });

                popupCtl.contentDiv.innerHTML = self.parent.getInfo({ locale: map.options.locale });
                popupCtl.menuDiv.innerHTML = '';
                if (popupCtl.options.closeButton || popupCtl.options.closeButton === undefined) {
                    const btn = document.createElement('div');
                    btn.classList.add(popupCtl.CLASS + '-close');
                    btn.setAttribute('title', popupCtl.getLocaleString('close'));
                    popupCtl.menuDiv.appendChild(btn);
                    btn.addEventListener(TC.Consts.event.CLICK, function () {
                        popupCtl.hide();
                    });
                    popupCtl.contentDiv.classList.add(popupCtl.CLASS + '-has-btn');
                    // En OL2 los featureInfo en versión "baraja de cartas" salen sin tamaño.
                    // Para evitar esto, la clase tc-ctl-finfo tiene ancho y alto establecidos.
                    // Pero eso hace que en el popup salgan barras de scroll, porque contentDiv se crea demasiado pequeño.
                    // Rehacemos el tamaño de tc-ctl-finfo para eliminarlas.
                    const finfo = popupCtl.contentDiv.querySelector('.tc-ctl-finfo');
                    if (finfo) {
                        finfo.width = 'auto';
                        finfo.height = 'auto';
                    }
                }

                var options = self.parent.options;
                if (TC.Util.isEmptyObject(options) && self.parent.layer &&
                    self.parent.layer.options && self.parent.layer.options.styles) {

                    switch (self.parent.CLASSNAME) {
                        case "TC.feature.Point":
                            options = self.parent.layer.options.styles.point;

                            // 11/03/2019 Al crear las features del API desde las features nativas, 
                            // se valida si la feature tiene icono para definir si es punto o marcador
                            // el problema viene cuando la feature no tiene estilo propio sino que lo obtiene de la capa,
                            // en esos casos se define como punto lo que es un marcador y cuando llegamos aquí no se accede a las
                            // opciones de marcador sino de punto.
                            if (!options || TC.Util.isEmptyObject(options)) {
                                options = self.parent.layer.options.styles.marker;
                            }
                            break;
                        case "TC.feature.Marker":
                            options = self.parent.layer.options.styles.marker;
                            break;
                        case "TC.feature.Circle":
                            options = self.parent.layer.options.styles.circle;
                            break;
                        case "TC.feature.MultiPolygon":
                        case "TC.feature.Polygon":
                            options = self.parent.layer.options.styles.polygon;
                            break;
                        case "TC.feature.MultiPolyline":
                        case "TC.feature.Polyline":
                            options = self.parent.layer.options.styles.line;
                            break;
                    }
                }

                // Calcular anchor
                var anchor;
                if (options.anchor) {
                    anchor = getStyleValue(options.anchor, self.parent);
                }
                else {
                    var style;
                    var f = feature._wrap.parent;
                    for (var i = 0; i < map.workLayers.length; i++) {
                        var layer = map.workLayers[i];
                        if (!layer.isRaster()) {
                            if (layer.features.indexOf(f) >= 0) {
                                style = layer.wrap.styleFunction(feature);
                                break;
                            }
                        }
                    }
                    if (Array.isArray(style)) {
                        const image = style[0].getImage();
                        anchor = !image || image instanceof ol.style.Icon ? [0.5, 0] : [0.5, 0.5];
                    }
                }
                const offset = [0, 0];
                if (anchor) {
                    if (options.height) {
                        offset[1] = -(getStyleValue(options.height, self.parent) || 0) * anchor[1];
                    }
                    else {
                        var fStyle = getNativeFeatureStyle(feature, true);
                        if (fStyle) {
                            const image = fStyle.getImage();
                            if (image instanceof ol.style.Icon) {
                                const size = image.getImageSize();
                                if (size) {
                                    offset[1] = size[1] * -image.getScale();
                                }
                            }
                        }
                    }
                }
                popupCtl.wrap.setDragged(false);
                popupCtl.wrap.popup.setOffset(offset);
                popupCtl.wrap.popup.setPosition(self._innerCentroid);
                popupCtl.popupDiv.classList.add(TC.Consts.classes.VISIBLE);
            } else {
                map.wrap.hidePopup(popupCtl);
            }
        }
    };

    TC.wrap.Feature.prototype.isNative = function (feature) {
        return feature instanceof ol.Feature;
    };

    TC.wrap.Feature.prototype.getPath = function () {
        var result = [];
        var self = this;
        if (self.feature && self.feature._folders) {
            result = self.feature._folders;
        }
        return result;
    };

    TC.wrap.Feature.prototype.getBounds = function () {
        var result = null;
        var self = this;
        if (self.feature) {
            const geometry = self.feature.getGeometry();
            if (!geometry) return null;
            result = geometry.getExtent();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getTemplate = function () {
        var result = null;
        var self = this;
        var style = self.feature.getStyle();
        if (TC.Util.isFunction(style)) {
            style = style(self.feature);
        }
        if (Array.isArray(style)) {
            for (var i = 0; i < style.length; i++) {
                if (style[i]._balloon) {
                    var s = style[i]._balloon.getText();
                    if (s) {
                        style = style[i]._balloon;
                        break;
                    }
                }
            }
        }
        if (style && !Array.isArray(style) && style.getText) {
            result = style.getText();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getData = function () {
        var self = this;
        var result = self.feature.getProperties();
        // En caso de clusters
        if (Array.isArray(result.features)) {
            if (result.features.length === 1) {
                result = result.features[0].getProperties();
            }
            else {
                result = result.features.length + ' elementos';
            }
        }
        var geometryName = self.feature.getGeometryName();
        if (result[geometryName]) {
            delete result[geometryName];
        }
        return result;
    };

    TC.wrap.Feature.prototype.setData = function (data) {
        this.feature.setProperties(data);
    };

    TC.wrap.Feature.prototype.unsetData = function (key) {
        const feature = this.feature;
        feature.unset(key);
    };

    TC.wrap.Feature.prototype.clearData = function () {
        const feature = this.feature;
        const geometryName = feature.getGeometryName();
        feature.getKeys().forEach(function (key) {
            if (key !== geometryName) {
                feature.unset(key);
            }
        });
    };

    TC.wrap.control.Draw.prototype.mouseMoveHandler = function (evt) {
        const self = this;
        if (self.sketch) {
            self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());
        }
    };

    TC.wrap.control.Draw.prototype.mouseOverHandler = function (evt) {
        const self = this;
        if (self.sketch && self.hoverCoordinate) {
            self.pushCoordinate(self.hoverCoordinate);
            self.hoverCoordinate = null;
        }
    };

    TC.wrap.control.Draw.prototype.clickHandler = function (evt) {
        const self = this;
        if (self.parent.map.view === TC.Consts.view.PRINTING) {
            return;
        }
        if (self._mdPx) { // No operamos si el clic es consecuencia es en realidad un drag
            const dx = self._mdPx[0] - evt.clientX;
            const dy = self._mdPx[1] - evt.clientY;
            if (dx * dx + dy * dy > self.interaction.squaredClickTolerance_) {
                return;
            }
        }
        if (self.sketch) {
            var coords = self.sketch.getGeometry().getCoordinates();
            self.parent.trigger(TC.Consts.event.POINT, {
                point: coords[coords.length - 1]
            });
        }
    };

    TC.wrap.control.Draw.prototype.mousedownHandler = function (evt) {
        const self = this;
        self._mdPx = [evt.clientX, evt.clientY];
    };

    TC.wrap.control.Draw.prototype.getMeasureData = function () {
        var self = this;

        var formatLength = function (line, data) {
            line = new ol.geom.LineString(TC.Util.reproject(line.getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs));
            data.length = line.getLength();
        };

        var formatArea = function (polygon, data) {
            polygon = new ol.geom.Polygon([TC.Util.reproject(polygon.getLinearRing(0).getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs)]);
            data.area = polygon.getArea();
            var ring = polygon.getLinearRing(0);
            data.perimeter = ol.geom.flat.linearRingLength(ring.flatCoordinates, 0, ring.flatCoordinates.length, ring.stride);
        };

        var result = {
            units: ol.proj.Units.METERS
        };
        if (this.sketch) {
            var geom = (this.sketch.getGeometry());
            if (geom instanceof ol.geom.Polygon) {
                formatArea(geom, result);
            }
            else if (geom instanceof ol.geom.LineString) {
                formatLength(geom, result);
            }
        }

        return result;
    };

    // Función para reproyectar el dibujo actual
    const drawProjectionChangeHandler = function (ctl, e) {
        if (ctl.sketch) {
            const oldProj = e.oldValue.getProjection();
            const newProj = e.target.get(e.key).getProjection();
            if (oldProj.getCode() !== newProj.getCode()) {
                const geom = ctl.sketch.getGeometry();
                geom.transform(oldProj, newProj);
                ctl.interaction.sketchPoint_.getGeometry().transform(oldProj, newProj);
                const flatCoordinates = [];
                var sketchCoords;
                if (ctl.interaction.getMode() === 'Polygon') {
                    sketchCoords = ctl.interaction.sketchCoords_[0];
                }
                else {
                    sketchCoords = ctl.interaction.sketchCoords_;
                }
                ol.geom.flat.deflateCoordinates(flatCoordinates, 0, sketchCoords, geom.stride);
                const transformFn = ol.proj.getTransform(oldProj, newProj);
                transformFn(flatCoordinates, flatCoordinates, geom.stride);
                sketchCoords = ol.geom.flat.inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, geom.stride);
                if (ctl.interaction.getMode() === 'Polygon') {
                    ctl.interaction.sketchCoords_ = [sketchCoords];
                }
                else {
                    ctl.interaction.sketchCoords_ = sketchCoords;
                }
            }
        }
    };

    TC.wrap.control.Draw.prototype.activate = function (mode) {
        var self = this;

        var type;
        switch (mode) {
            case TC.Consts.geom.POLYGON:
                type = ol.geom.GeometryType.POLYGON;
                break;
            case TC.Consts.geom.MULTIPOLYGON:
                type = ol.geom.GeometryType.MULTI_POLYGON;
                break;
            case TC.Consts.geom.POINT:
                type = ol.geom.GeometryType.POINT;
                break;
            case TC.Consts.geom.MULTIPOINT:
                type = ol.geom.GeometryType.MULTI_POINT;
                break;
            case TC.Consts.geom.MULTIPOLYLINE:
                type = ol.geom.GeometryType.MULTI_LINE_STRING;
                break;
            default:
                type = ol.geom.GeometryType.LINE_STRING;
                break;
        }
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (layer) {
                    layer.wrap.getLayer().then(function (olLayer) {

                        if (!self.viewport) self.viewport = olMap.getViewport();

                        if (self.interaction) {
                            olMap.removeInteraction(self.interaction);
                            if (self._mousedownHandler) {
                                self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                                self._mousedownHandler = null;
                            }
                            if (self._clickHandler) {
                                self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                                self._clickHandler = null;
                            }
                            if (self._mouseMoveHandler && self._mouseOverHandler) {
                                self.viewport.removeEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.removeEventListener(MOUSEOVER, self._mouseOverHandler);
                            }
                        }

                        if (self.snapInteraction) {
                            olMap.removeInteraction(self.snapInteraction);
                        }

                        if (mode) {
                            self._mousedownHandler = self.mousedownHandler.bind(self);
                            self._clickHandler = self.clickHandler.bind(self);
                            self.viewport.addEventListener('mousedown', self._mousedownHandler);
                            self.viewport.addEventListener(TC.Consts.event.CLICK, self._clickHandler);
                            if (self.parent.measure) {
                                self._mouseMoveHandler = self.mouseMoveHandler.bind(self);
                                self._mouseOverHandler = self.mouseOverHandler.bind(self);
                                self.viewport.addEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.addEventListener(MOUSEOVER, self._mouseOverHandler);
                            }

                            var drawOptions = {
                                type: type,
                                snapTolerance: 0,
                                condition: function () {
                                    if (ol.events.condition.shiftKeyOnly(arguments[0])) {
                                        hole = olMap.forEachFeatureAtPixel(olMap.getPixelFromCoordinate(arguments[0].coordinate), function (feature) {
                                            if (ol.geom.GeometryType.POLYGON == feature.getGeometry().getType() ||
                                                ol.geom.GeometryType.MULTI_POLYGON == feature.getGeometry().getType()) {
                                                return feature;
                                            }
                                            return null;
                                        },
                                            {
                                                hitTolerance: hitTolerance
                                            });
                                    }

                                    if (self.parent.map.view === TC.Consts.view.PRINTING) {
                                        return null;
                                    }

                                    return true;
                                }
                            };
                            if (olLayer) {
                                drawOptions.source = olLayer.getSource();
                            }
                            const parentStyles = self.parent.styles || {};
                            switch (mode) {
                                case TC.Consts.geom.RECTANGLE:
                                    drawOptions.style = createNativeStyle({
                                        styles: { line: self.parent.styles.line }
                                    });
                                    drawOptions.type = ol.geom.GeometryType.LINE_STRING;
                                    drawOptions.maxPoints = 2;
                                    drawOptions.geometryFunction = function (coordinates, geometry) {
                                        const start = coordinates[0];
                                        const end = coordinates[1];
                                        const newCoords = [[start, [start[0], end[1]], end, [end[0], start[1]], start]];
                                        if (geometry) {
                                            geometry.setCoordinates(newCoords);
                                        }
                                        else {
                                            geometry = new ol.geom.Polygon(newCoords);
                                        }
                                        return geometry;
                                    };
                                    break;
                                case TC.Consts.geom.POLYGON:
                                case TC.Consts.geom.MULTIPOLYGON:
                                    if (parentStyles.polygon) {
                                        drawOptions.style = createNativeStyle({
                                            styles: { polygon: parentStyles.polygon }
                                        });
                                    }
                                    break;
                                case TC.Consts.geom.POINT:
                                case TC.Consts.geom.MULTIPOINT:
                                    if (parentStyles.point) {
                                        drawOptions.style = createNativeStyle({
                                            styles: { point: parentStyles.point }
                                        });
                                    }
                                    break;
                                case TC.Consts.geom.MULTIPOLYLINE:
                                default:
                                    if (parentStyles.line) {
                                        drawOptions.style = createNativeStyle({
                                            styles: { line: parentStyles.line }
                                        });
                                    }
                                    break;
                            }

                            self.interaction = new ol.interaction.Draw(drawOptions);

                            self.interaction.on('drawstart', function (evt) {
                                self.sketch = evt.feature;
                                self.parent.trigger(TC.Consts.event.DRAWSTART);
                            }, this);

                            self.interaction.on('drawend', function (evt) {
                                const overlayStyle = evt.target.overlay_.getStyle();
                                evt.feature.setStyle(Array.isArray(overlayStyle) ? overlayStyle.map(function (style) {
                                    return style.clone();
                                }) : overlayStyle);
                                if (self.parent.measure) {
                                    self.parent.trigger(TC.Consts.event.MEASURE, self.getMeasureData());
                                }
                                TC.wrap.Feature.createFeature(self.sketch).then(function (feat) {
                                    self.parent.trigger(TC.Consts.event.DRAWEND, { feature: feat });
                                    self.sketch = null;
                                });
                            }, this);

                            self._projectionChangeHandler = function (e) {
                                drawProjectionChangeHandler(self, e);
                            };
                            olMap.on('change:view', self._projectionChangeHandler);

                            olMap.addInteraction(self.interaction);

                            if (self.parent.snapping) {
                                var snapOptions = {};
                                if (olLayer) {
                                    snapOptions.source = olLayer.getSource();
                                }
                                else if (self.parent.snapping instanceof TC.Layer) {
                                    snapOptions.source = self.parent.snapping.wrap.layer.getSource();
                                }
                                self.snapInteraction = new ol.interaction.Snap(snapOptions);
                                olMap.addInteraction(self.snapInteraction);
                            }
                        }

                        self.redoStack = [];
                    });
                }
            });
        }
    };

    TC.wrap.control.Draw.prototype.deactivate = function () {
        var self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (self.viewport) {
                    if (self._mousedownHandler) {
                        self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                        self._mousedownHandler = null;
                    }
                    if (self._clickHandler) {
                        self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                        self._clickHandler = null;
                    }
                }
                if (layer && !self.parent.persistent) {
                    layer.clearFeatures();
                }
                if (self.interaction) {
                    olMap.removeInteraction(self.interaction);
                    self.interaction = null;
                }
                olMap.un('change:view', self._projectionChangeHandler);
            });
        }
    };

    //El valor devuelto es lo que va al stack de redo
    TC.wrap.control.Draw.prototype.popCoordinate = function () {
        var self = this;
        var result = null;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                }
                else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                if (coords.length > 1) {

                    var puntos;
                    if (geom instanceof ol.geom.Polygon)
                        puntos = self.interaction.sketchCoords_[0];
                    else if (geom instanceof ol.geom.LineString)
                        puntos = self.interaction.sketchCoords_;

                    /*
                    Al menos con linestring, no necesariamente hay que quitar el último
                    Porque OL mete en coordinates del sketchFeature_ tanto el último marcado como el que flota detrás del cursor
                    Para comprobar que realmente es ése, podemos contrastarlo con self.interaction.sketchPoint_.getGeometry().getCoordinates()
                    */
                    var flyingPointContained = false;
                    if (self.interaction.sketchPoint_) {
                        var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                        for (var i = 0; i < coords.length; i++) {
                            if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                                flyingPointContained = true;
                                break;
                            }
                        }
                    }

                    var index;
                    if (flyingPointContained) index = puntos.length - 2;
                    else index = puntos.length - 1;

                    result = puntos[index];
                    puntos.splice(index, 1);

                    if (geom instanceof ol.geom.Polygon) {
                        geom.setCoordinates([puntos]);
                        self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    }
                    else {
                        geom.setCoordinates(puntos);
                    }


                    feature.setGeometry(geom);
                }
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.pushCoordinate = function (coord) {
        var self = this;
        var result = false;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                } else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                //coords.push(coord);

                var puntos;
                if (geom instanceof ol.geom.Polygon) {
                    puntos = self.interaction.sketchCoords_[0];
                    //self.interaction.sketchCoords_[0].push(coord);
                    //geom.setCoordinates([fullCoords], ol.geom.GeometryLayout.XY);
                } else if (geom instanceof ol.geom.LineString) {

                    puntos = self.interaction.sketchCoords_;
                }

                //Si hay punto volador, hay que meter la coordenada justo antes
                var flyingPointContained = false;
                if (self.interaction.sketchPoint_) {
                    var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                    for (var i = 0; i < coords.length; i++) {
                        if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                            flyingPointContained = true;
                            break;
                        }
                    }
                }


                if (flyingPointContained) index = puntos.length - 1;
                else index = puntos.length;
                puntos.splice(index, 0, coord);

                if (geom instanceof ol.geom.LineString)
                    geom.setCoordinates(puntos, ol.geom.GeometryLayout.XY);
                else {
                    geom.setCoordinates([puntos], ol.geom.GeometryLayout.XY);
                    self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    //feature.setGeometry(geom);
                }


                result = true;
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.undo = function () {
        var self = this;
        var result = false;

        var coord = self.popCoordinate();
        if (coord) {
            self.redoStack.push(coord);
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.redo = function () {
        var self = this;
        var result = false;

        if (self.redoStack.length > 0) {
            self.pushCoordinate(self.redoStack.pop());
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.end = function () {
        var self = this;
        if (self.interaction && self.interaction.sketchFeature_)
            self.interaction.finishDrawing();
    };

    TC.wrap.control.Draw.prototype.setStyle = function (style) {
        const self = this;
        if (self.interaction) {
            self.interaction.overlay_.setStyle(createNativeStyle({
                styles: style
            }));
        }
    };

    TC.wrap.control.CacheBuilder.prototype.getRequestSchemas = function (options) {
        var extent = options.extent;
        var layers = options.layers;
        var result = new Array(layers.length);
        for (var i = 0, len = result.length; i < len; i++) {
            var layer = layers[i];
            var schema = {
                layerId: layer.id
            };
            var olSource = layer.wrap.layer.getSource();
            if (olSource.getUrls) {
                schema.url = olSource.getUrls()[0];
            }
            if (olSource.getTileGrid) {
                var tileGrid = olSource.getTileGrid();
                var resolutions = tileGrid.getResolutions();
                var matrixIds = tileGrid.getMatrixIds();
                var node = layer.getLayerNodeByName(layer.layerNames);
                var tmsLimits = null;
                for (var j = 0, llen = node.TileMatrixSetLink.length; j < llen; j++) {
                    var tmsl = node.TileMatrixSetLink[j];
                    if (tmsl.TileMatrixSet === layer.matrixSet) {
                        tmsLimits = tmsl.TileMatrixSetLimits;
                        break;
                    }
                }
                schema.tileMatrixLimits = [];
                for (var j = 0, rlen = resolutions.length; j < rlen; j++) {
                    var origin = tileGrid.getOrigin(j);
                    var tileSize = tileGrid.getTileSize(j);
                    var resolution = resolutions[j];
                    var unitsPerTile = tileSize * resolution;
                    var tml = {
                        mId: matrixIds[j],
                        res: resolution,
                        origin: origin,
                        tSize: tileSize,
                        cl: Math.floor((extent[0] - origin[0]) / unitsPerTile),
                        cr: Math.floor((extent[2] - origin[0]) / unitsPerTile),
                        rt: Math.floor((origin[1] - extent[3]) / unitsPerTile),
                        rb: Math.floor((origin[1] - extent[1]) / unitsPerTile)
                    }
                    if (tmsLimits) {
                        var tmsLimit = tmsLimits[j];
                        if (tmsLimit) {
                            tml.cl = Math.max(tml.cl, tmsLimit.MinTileCol);
                            tml.cr = Math.min(tml.cr, tmsLimit.MaxTileCol);
                            tml.rt = Math.max(tml.rt, tmsLimit.MinTileRow);
                            tml.rb = Math.min(tml.rb, tmsLimit.MaxTileRow);
                        }
                    }
                    if (tml.cl <= tml.cr && tml.rt <= tml.rb) {
                        schema.tileMatrixLimits.push(tml);
                    }
                }
            }
            result[i] = schema;
        }
        return result;
    };

    TC.wrap.control.CacheBuilder.prototype.getGetTilePattern = function (layer) {
        var result = "";
        var olSource = layer.wrap.layer.getSource();
        if (olSource.getUrls) {
            result = olSource.getUrls()[0];
        }
        if (layer.options.encoding !== TC.Consts.WMTSEncoding.RESTFUL) {
            if (result.indexOf('?') < 0) {
                result = result + '?';
            }
            if (result.indexOf('?') === result.length - 1) {
                result = result + 'layer=' + layer.layerNames + '&style=default&tilematrixset=' + encodeURIComponent(layer.matrixSet) +
                    '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + encodeURIComponent(layer.format) +
                    '&TileMatrix={TileMatrix}&TileCol={TileCol}&TileRow={TileRow}';
            }
        }
        return result;
    };

    const createHaloStroke1 = function (width) {
        return new ol.style.Stroke({
            color: '#ffffff',
            width: width + 4,
        });
    };

    const createHaloStroke2 = function (width) {
        return new ol.style.Stroke({
            color: '#000000',
            width: width + 6,
        });
    };

    const addHaloToStyle = function (style) {
        if (!style) {
            style = [];
        }
        if (style instanceof ol.style.Style) {
            style = [style];
        }
        style = style.slice();
        const mainStyle = style[0];
        if (mainStyle) {
            const image = mainStyle.getImage();
            var strokeWidth;
            if (image instanceof ol.style.RegularShape) {
                strokeWidth = image.getStroke().getWidth();
                const radius = image.getRadius();
                const haloPart1 = mainStyle.clone();
                haloPart1.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(haloPart1);
                const haloPart2 = mainStyle.clone();
                haloPart2.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke2(strokeWidth)
                }));
                style.unshift(haloPart2);
            }
            const stroke = mainStyle.getStroke();
            if (stroke) {
                strokeWidth = stroke.getWidth();
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke2(strokeWidth)
                }));
            }
            return style;
        }
        return null;
    };

    const createSelectedStyle = function (feat) {
        let originalStyle = feat._originalStyle = feat._originalStyle || feat.getStyle();
        if (!feat._originalStyle && feat._wrap.parent.layer) {
            originalStyle = feat._wrap.parent.layer.wrap.layer.getStyle();
        }
        if (!originalStyle) {
            originalStyle = createNativeStyle({}, feat);
        }
        if (TC.Util.isFunction(originalStyle)) {
            return function (f, r) {
                return addHaloToStyle(originalStyle(f, r));
            };
        }
        return addHaloToStyle(originalStyle);
    };

    const setSelectedStyle = function (feat) {
        updateSelectedStyle.call(feat);
        feat.changed();
        //ol.events.listen(feat, CHANGE, updateSelectedStyle, feat);
    };

    const removeSelectedStyle = function (feat) {
        //ol.events.unlisten(feat, CHANGE, updateSelectedStyle, feat);
        if (feat.hasOwnProperty('_originalStyle')) {
            feat.setStyle(feat._originalStyle);
        }
        delete feat._originalStyle;
    };

    const updateSelectedStyle = function () {
        this.style_ = createSelectedStyle(this);
        this.styleFunction_ = !this.style_ ? undefined : ol.Feature.createStyleFunction(this.style_);
    };

    TC.wrap.control.Modify.prototype.activate = function () {
        const self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.layer.wrap.getLayer()]).then(function (olObjects) {
                const olMap = olObjects[0];
                const olLayer = olObjects[1];
                if (self.selectInteraction) {
                    olMap.removeInteraction(self.selectInteraction);
                }
                var select = new ol.interaction.Select({
                    layers: [olLayer],
                    hitTolerance: hitTolerance
                });
                self.selectInteraction = select;
                olMap.addInteraction(select);
                var getWrapperFeature = function (elm) {
                    return elm._wrap.parent;
                };
                select.on('select', function (event) {
                    if (event.selected.length > 0) {
                        self.parent.trigger(TC.Consts.event.FEATURESSELECT, { ctrl: self, features: event.selected.map(getWrapperFeature) });
                    }
                    if (event.deselected.length > 0) {
                        if (event.selected.length == 0) {
                            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, features: event.deselected.map(getWrapperFeature) });
                        }
                    }
                });
                if (self.modifyInteraction) {
                    olMap.removeInteraction(self.modifyInteraction);
                }
                var modify = new ol.interaction.Modify({
                    features: select.getFeatures()
                });
                modify.on('modifyend', function (e) {
                    e.features.forEach(function (feature) {
                        feature._wrap.parent.geometry = feature._wrap.getGeometry();
                        self.parent.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature._wrap.parent, layer: self.parent.layer });
                    });
                });
                self.modifyInteraction = modify;
                olMap.addInteraction(modify);

                if (self.snapInteraction) {
                    olMap.removeInteraction(self.snapInteraction);
                }
                if (self.parent.snapping) {
                    self.snapInteraction = new ol.interaction.Snap({
                        source: olLayer.getSource()
                    });
                    olMap.addInteraction(self.snapInteraction);
                }

                if (!self._onMouseMove) {
                    self._onMouseMove = function (e) {
                        const viewport = olMap.getViewport();
                        var hit = false;
                        var feature;

                        var pixel = olMap.getEventPixel(e);
                        hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                            if (self.parent.layer && layer === self.parent.layer.wrap.layer) {
                                return true;
                            }
                            return false;
                        },
                            {
                                hitTolerance: hitTolerance
                            });

                        if (hit) {
                            viewport.style.cursor = 'pointer';
                        } else {
                            viewport.style.cursor = '';
                            //self.parent.trigger(TC.Consts.event.FEATUREOUT);
                        }
                    };
                }

                olMap.getViewport().addEventListener(MOUSEMOVE, self._onMouseMove);
            });
        }
    };

    TC.wrap.control.Modify.prototype.deactivate = function () {
        const self = this;
        if (self.modifyInteraction) {
            self.modifyInteraction.setActive(false);
            self.selectInteraction.setActive(false);
            self.parent.map.wrap.getMap().then(function (olMap) {
                olMap.getViewport().removeEventListener(MOUSEMOVE, self._onMouseMove);
                olMap.removeInteraction(self.modifyInteraction);
                olMap.removeInteraction(self.selectInteraction);
                self.modifyInteraction = null;
                self.selectInteraction = null;
            });
        }
    };

    TC.wrap.control.Modify.prototype.getSelectedFeatures = function () {
        var self = this;
        var result = [];
        if (self.selectInteraction) {
            self.selectInteraction.getFeatures().forEach(function (elm) {
                result[result.length] = elm._wrap.parent;
            });
        }
        return result;
    };

    TC.wrap.control.Modify.prototype.setSelectedFeatures = function (features) {
        var self = this;
        if (self.selectInteraction) {
            var source = self.selectInteraction.featureOverlay_.getSource();
            source.clear();
            source.addFeatures(features.map(function (elm) {
                return elm.wrap.feature;
            }));
        }
    };

    TC.wrap.control.Modify.prototype.unselectFeatures = function (features) {
        features = features || [];
        const self = this;
        const selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
        if (selectedFeatures) {
            const unselectedFeatures = [];
            selectedFeatures.getArray().slice().forEach(function (olFeature) {
                if (!features.length || features.indexOf(olFeature) >= 0) {
                    selectedFeatures.remove(olFeature);
                    unselectedFeatures[unselectedFeatures.length] = olFeature._wrap.parent;
                }
            });
            if (unselectedFeatures.length) {
                self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { features: unselectedFeatures });
            }
        }
    };

    TC.wrap.control.Edit.prototype.cancel = function (deactivate, cancelTxt) {
        var self = this;
        self.points = [];
        self.histPoints = [];
        var layer = (self.control && self.control.layer) || (self.modifyInteraction && self.modifyInteraction.layer);
        //if (!self.session || ((self.modifyInteraction && self.modifyInteraction.modified) || (self.session.featuresAdded && self.session.featuresAdded.length)) && cancelTxt && !confirm(cancelTxt))
        //    return;
        if (self.selectInteraction) {
            var features = self.selectInteraction.getFeatures();
            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, feature: features.get(0) });
            features.clear();
            self.selectInteraction.setActive(false);
        }
        //if (self.drawInteraction) {
        //    self.drawInteraction.abortDrawing_();
        //    if (deactivate) {
        //        self.drawInteraction.setActive(false);
        //    }
        //}
        //if(self.modifyInteraction)
        //{
        //    if (self.modifyInteraction.feature)
        //        self.modifyInteraction.unselectFeature(self.modifyInteraction.feature);
        //    if (deactivate)
        //    {
        //        self.modifyInteraction.deactivate();
        //    }   
        //}
        ////if (self.session.featuresAdded && self.session.featuresAdded.length > 0) {
        ////    layer.removeFeatures(self.session.featuresAdded);
        ////    self.session.featuresAdded = [];
        ////}
        //self.parent.trigger(TC.Consts.event.EDITIONCANCEL, { ctrl: self });
        ////no se por que hostias se cambia el renderIntent a las features
        //layer.features.forEach(function (feat) {
        //    feat.renderIntent = "";
        //});    
        //layer.removeAllFeatures();
        //layer.addFeatures(self.session.features);        
        //self.clearSession();
    };

    TC.wrap.control.Edit.prototype.deleteFeatures = function (features) {
        var self = this;
        if (Array.isArray(features)) {
            var olFeatures = features.map(function (elm) {
                return elm.wrap.feature;
            });
            self.parent.layer.wrap.getLayer().then(function (olLayer) {
                var selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
                for (var i = 0, len = olFeatures.length; i < len; i++) {
                    var olFeature = olFeatures[i];
                    if (selectedFeatures) {
                        selectedFeatures.remove(olFeature);
                        self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { feature: olFeature._wrap.parent });
                    }
                    olLayer.getSource().removeFeature(olFeature);
                    self.parent.trigger(TC.Consts.event.FEATUREREMOVE, { feature: olFeature._wrap.parent });
                }
            });
        }
    };

    //TC.wrap.control.Edit.prototype.clearSession = function () {
    //    var self = this;
    //    delete self.session;
    //};

    TC.wrap.Feature.prototype.toGML = function (version, srsName) {
        var parser = new ol.format.GML({
            srsName: srsName
        });
        var xml = parser.writeGeometryNode(this.feature.getGeometry());
        //elimino los aributos srsName de los hijos en geometrias compuestas Polygon->LinearRing etc;
        var poligons = xml.querySelector("MultiSurface,MultiPolygon,Polygon")
        if (poligons) poligons.querySelectorAll("Polygon,LinearRing").forEach((item) => { item.removeAttribute("srsName") });
        //id para INSPIRE
        xml.firstChild.setAttribute("gml:id", xml.firstChild.tagName + "." + TC.getUID());
        //reemplazo todos los <loquesea por <gml:loquesea y </loquesea por </gml:loquesea
        return new XMLSerializer().serializeToString(xml.firstChild).replace(/\<\/?\w/gm, function (str) { var pos = str.indexOf("/") > 0 ? str.indexOf("/") + 1 : 1; return str.substring(0, pos) + "gml:" + str.substring(pos) })
        //return new XMLSerializer().serializeToString(xml.firstChild).replace(/\</gm, "<gml:");
    };


    TC.wrap.Feature.prototype.toGeoJSON = function () {
        var parser = new ol.format.GeoJSON();
        return parser.writeGeometry(this.feature.getGeometry());
    };

    TC.wrap.Geometry.write = function (options) {
        options = options || {};
        var geometry;
        switch (options.format) {
            default:
                options.parser = new ol.format.GeoJSON();
        };
        switch (options.type) {
            case TC.Consts.geom.POLYLINE:
                geometry = new ol.geom.LineString(options.coordinates);
                break;
            case TC.Consts.geom.POLYGON:
                geometry = new ol.geom.Polygon(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOINT:
                geometry = new ol.geom.MultiPoint(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYLINE:
                geometry = new ol.geom.MultiLineString(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYGON:
                geometry = new ol.geom.MultiPolygon(options.coordinates);
                break;
            case TC.Consts.geom.POINT:
            default:
                geometry = new ol.geom.Point(options.coordinates);
                break;
        };
        return options.parser.writeGeometry(geometry);
    };

    TC.wrap.Geometry.toGeoJSON = function (options) {
        return TC.wrap.Geometry.write(options);
    };

    return ol;
});

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Attribution = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self.apiAttribution = '';
    self.mainDataAttribution = null;
    self.dataAttributions = [];
    if (self.options.dataAttributions) {
        self.dataAttributions = self.options.dataAttributions instanceof Array ? self.options.dataAttributions : [self.options.dataAttributions];
    }
};

TC.inherit(TC.control.Attribution, TC.Control);

(function () {
    var ctlProto = TC.control.Attribution.prototype;

    ctlProto.CLASS = 'tc-ctl-attrib';

    ctlProto.template = TC.apiLocation + "TC/templates/Attribution.html";

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.apiAttribution = self.map.options.attribution || self.apiAttribution;

        var addData = function (obj) {
            if (obj) {
                // TODO: sanitizer
                var attr = obj.getAttribution();
                if (attr) {
                    if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                        self.mainDataAttribution = {
                            name: 'IDENA',
                            site: 'http://idena.navarra.es/'
                        };
                    }
                    else {
                        var textExists = false;
                        for (var i = 0; i < self.dataAttributions.length; i++) {
                            if (attr.name === self.dataAttributions[i].name) {
                                textExists = true;
                                break;
                            }
                        }
                        if (!textExists) {
                            self.dataAttributions.push(attr);
                        }
                    }
                }
            }
        };

        var removeData = function (obj) {
            if (obj) {

                var checkRemoveData = function () {
                    if (obj.map.workLayers.length > 0) {
                        var _wl = obj.map.workLayers.slice().reverse();
                        for (var i = 0; i < _wl.length; i++) {
                            if (_wl[i].url == obj.url && _wl[i].getVisibility())
                                return false;
                        }

                        return true;
                    }

                    return true;
                };

                if (obj instanceof TC.Layer ? checkRemoveData() : true) {
                    // TODO: sanitizer
                    var attr = obj.getAttribution();

                    if (attr) {
                        var index = self.dataAttributions.reduce(function (prev, cur, idx) {
                            if (cur.name === attr.name) {
                                return idx;
                            }
                            return prev;
                        }, -1);

                        const checkIsSameAttribution = function (toCheckName) {
                            return (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) &&
                                (/IDENA/.test(toCheckName) || /Tracasa Instrumental/.test(toCheckName)) ||
                                    (attr.name === toCheckName);
                        };

                        // Validamos si las atribuciones a borrar son también del mapa base
                        if (self.map.baseLayer && self.map.baseLayer.wrap.getAttribution() && checkIsSameAttribution(self.map.baseLayer.wrap.getAttribution().name)) {
                            return;
                        } else {
                            // Validamos si las atribuciones a borrar son también de alguna de las capas raster cargadas
                            if (self.map.workLayers.filter(function (layer) {
                                return layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS;
                            }).some(function (layer) {
                                var workLayerAttribution = layer.wrap.getAttribution();
                                return workLayerAttribution && checkIsSameAttribution(workLayerAttribution.name);
                            })) {
                                return;
                            }
                        }

                        if (index > -1) {
                            self.dataAttributions.splice(index, 1);
                        } else if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                            self.mainDataAttribution = null;
                        }
                    }
                }
            }
        };
        //URI: Si las atribuciones están vacias evito hace una llamada al renderizado del control ya que lo obtendría sin datos.
        //self.render();

        map.loaded(function () {
            if (map.baseLayer.wrap.getAttribution) {
                addData(map.baseLayer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (!layer.isBase && layer.wrap.getAttribution && layer.wrap.getAttribution()) {
                addData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.BEFOREBASELAYERCHANGE + " " + TC.Consts.event.OVERVIEWBASELAYERCHANGE, function (e) {
            const type = e.type;
            const newLayer = e.newLayer;
            const oldLayer = e.oldLayer;
            if (TC.Consts.event.OVERVIEWBASELAYERCHANGE.indexOf(type) > -1) {
                self.ignoreLayer = newLayer;
            }

            if (oldLayer && oldLayer.wrap.getAttribution) {
                removeData(oldLayer.wrap);
            }

            if (newLayer && newLayer.wrap.getAttribution) {
                addData(newLayer.wrap);
            }

            self.render();
        });

        map.on(TC.Consts.event.LAYERREMOVE, function (e) {
            const layer = e.layer;
            if (layer.wrap.getAttribution) {
                removeData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERADD, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                addData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERREMOVE, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                removeData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
            const layer = e.layer;
            if (self.ignoreLayer === layer) {
                return;
            }

            if (layer.wrap.getAttribution) {
                if (layer.getVisibility()) {
                    addData(layer.wrap);
                } else {
                    removeData(layer.wrap);
                }
                self.render();
            }
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;        

        return self._set1stRenderPromise(self.renderData({
            api: (typeof (self.apiAttribution) === 'function' ? self.apiAttribution.apply(self) : self.getLocaleString(self.apiAttribution)),
            mainData: self.mainDataAttribution,
            otherData: self.dataAttributions,
            isCollapsed: self.div.querySelector('.' + self.CLASS + '-other') ? self.div.querySelector('.' + self.CLASS + '-other').classList.contains(TC.Consts.classes.COLLAPSED) : true
        }, function () {
            const cmd = self.div.querySelector('.' + self.CLASS + '-cmd');
            cmd && cmd.addEventListener(TC.Consts.event.CLICK, function () {
                self.toggleOtherAttributions();
            });

            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto.toggleOtherAttributions = function () {
        const self = this;
        const other = self.div.querySelector('.' + self.CLASS + '-other');
        other.classList.toggle(TC.Consts.classes.COLLAPSED);
    };
})();

TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

(function () {

    TC.control.BasemapSelector = function () {
        var self = this;
        //options = options || {};

        TC.control.MapContents.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.tc-modal-close)', function (e) {

            if (e.target.classList.contains(self._cssClasses.LOAD_CRS_BUTTON)) {
                self.loadFallbackProjections();
                return;
            }

            TC.Util.closeModal();
            const btn = e.target;
            const crs = btn.dataset.crsCode;

            // dependerá del que esté activo
            const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
            dialog.classList.add(TC.Consts.classes.HIDDEN);

            const layer = self.getLayer(dialog.dataset.layerId);
            if (layer) {
                if (crs) {
                    TC.loadProjDef({
                        crs: crs,
                        callback: function () {
                            self.map.setProjection({
                                crs: crs,
                                baseLayer: layer
                            });
                        }
                    });
                }
                else {
                    const fallbackLayer = self.getFallbackLayer(btn.dataset.fallbackLayerId);
                    if (fallbackLayer) {
                        self.map.setBaseLayer(fallbackLayer);
                    }
                }
            }
        }));
    };

    TC.inherit(TC.control.BasemapSelector, TC.control.MapContents);

    var ctlProto = TC.control.BasemapSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-bms';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/BasemapSelector.html";
    ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/BasemapSelectorNode.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/BasemapSelectorDialog.html";

    const getClosestParent = function (elm, selector) {
        while (elm && !elm.matches(selector)) {
            elm = elm.parentElement;
        }
        return elm;
    };

    const changeInputRadioBaseMap = function (e, callback) {
        const self = this;
        var flagToCallback = true;

        var radio = e.target;

        var layer = self.getLayer(getClosestParent(radio, 'li').dataset.layerId);

        if (self.options.dialogMore && getClosestParent(radio, '.' + self.CLASS + '-more-dialog')) {
            const radios = self.div.querySelectorAll('input[type=radio]');
            for (var i = 0, len = radios.length; i < len; i++) {
                const bmsLayer = self.getLayer(getClosestParent(radios[i], 'li').dataset.layerId);
                if (bmsLayer) {
                    switch (true) {
                        case bmsLayer.id === layer.id:
                            layer = bmsLayer;
                            break;
                    }
                }
            };
        }

        if (layer != self.map.getBaseLayer()) {
            if (layer.mustReproject) {

                if (self.map.on3DView) {
                    if (!layer.getFallbackLayer()) {
                        self._currentSelection.checked = true;
                        e.stopPropagation();
                        return;
                    } else if (layer.getFallbackLayer()) {
                        const fallbackLayer = layer.getFallbackLayer();
                        if (fallbackLayer) {
                            fallbackLayer._capabilitiesPromise.then(function () {
                                if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                    self.map.setBaseLayer(layer);
                                }
                            });
                        }

                        flagToCallback = true;
                    }
                } else {
                    // provisonal
                    if (self._currentSelection) {
                        self._currentSelection.checked = true;
                    }

                    // Buscamos alternativa
                    const dialogOptions = {
                        layer: layer
                    };
                    const fallbackLayer = layer.getFallbackLayer();
                    if (fallbackLayer) {
                        fallbackLayer._capabilitiesPromise.then(function () {
                            if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                dialogOptions.fallbackLayer = fallbackLayer;
                            }
                            self.showProjectionChangeDialog(dialogOptions);
                        });
                    }
                    else {
                        self.showProjectionChangeDialog(dialogOptions);
                    }
                    //layer.getCompatibleCRS({ normalized: true });
                    flagToCallback = false;
                }

            }
            else {

                if (layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS && layer.getProjection() !== self.map.crs) {
                    layer.setProjection({ crs: self.map.crs });
                }

                self.map.setBaseLayer(layer);
            }
        }

        if (this._currentSelection) {
            this._currentSelection.checked = true;
        }


        if (callback) {
            callback(flagToCallback);
        }
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapContents.prototype.register.call(self, map);

        if (self.options.dialogMore) {
            map.on(TC.Consts.event.VIEWCHANGE, function () {
                self._getMoreBaseLayers();
            });
        }

        map.on(TC.Consts.event.BASELAYERCHANGE + ' ' + TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.VIEWCHANGE, function (e) {
            self.update(self.div, e.layer);
        });


        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {

            if (e.target.value === "moreLayers") {
                self.showMoreLayersDialog();
            } else {
                changeInputRadioBaseMap.call(self, e);
            }

            e.stopPropagation();
        }));

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.control.MapContents.prototype.render.call(self, callback, self.options);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;

            if (self.options.dialogMore) {
                const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

                dialog.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {
                    changeInputRadioBaseMap.call(self, e, function (close) {
                        if (close) {
                            TC.Util.closeModal();
                        }
                    });

                    e.stopPropagation();
                }));
            }
        });

        return result;
    };

    ctlProto.update = function (div, baseLayer) {
        const self = this;

        div = div || self.div;

        div.querySelectorAll(`ul.${self.CLASS}-branch li`).forEach(function (li) {
            const layer = self.getLayer(li.dataset.layerId);
            if (layer) {
                const curBaseLayer = baseLayer || self.map.baseLayer;
                const radio = li.querySelector('input[type=radio]');
                const checked = curBaseLayer && (curBaseLayer === layer || curBaseLayer.id === layer.id ||
                    (layer.getFallbackLayer && (curBaseLayer === layer.getFallbackLayer() || (layer.getFallbackLayer() && curBaseLayer.id === layer.getFallbackLayer().id))));

                if (self.map.on3DView && layer.mustReproject && layer.fallbackLayer && layer.getFallbackLayer) {
                    layer.getFallbackLayer().getCapabilitiesPromise().then(function () {
                        var mustReproject = !layer.getFallbackLayer().isCompatible(self.map.getCRS());

                        radio.checked = checked;
                        if (mustReproject) {
                            radio.classList.add(TC.Consts.classes.DISABLED);
                            li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                        }
                        else {
                            radio.classList.remove(TC.Consts.classes.DISABLED);
                            li.removeAttribute('title');
                        }
                    });
                } else {
                    radio.checked = checked;
                    if (layer.mustReproject) {
                        radio.classList.add(TC.Consts.classes.DISABLED);
                        li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                    }
                    else {
                        radio.classList.remove(TC.Consts.classes.DISABLED);
                        li.removeAttribute('title');
                    }
                }

                if (checked) {
                    self._currentSelection = radio;
                }
            }
        });

        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        const self = this;        
        if (layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.getRenderedHtml(self.CLASS + '-node', self.layerTrees[layer.id]).then(function (out) {
                const parser = new DOMParser();
                const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                var uid = newLi.dataset.layerUid;
                const ul = self.div.querySelector('.' + self.CLASS + '-branch');
                const currentLi = ul.querySelector('li[data-layer-uid="' + uid + '"]');
                if (currentLi) {
                    currentLi.innerHTML = newLi.innerHTML;
                }
                else {
                    newLi.dataset.layerId = layer.id;

                    // Insertamos elemento en el lugar correcto, según indica la colección baseLayers
                    const setLayerIds = self.map.baseLayers
                        .filter(baseLayer => baseLayer && !baseLayer.stealth) // Buscamos capas que deban mostrarse
                        .map(baseLayer => baseLayer.id);
                    const idx = setLayerIds.indexOf(layer.id);
                    let inserted = false;
                    for (let i = idx - 1; i >= 0; i--) {
                        const curLi = ul.querySelector(`li[data-layer-id="${setLayerIds[i]}"]`);
                        if (curLi) {
                            curLi.insertAdjacentElement('afterend', newLi);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        for (let i = idx + 1, ii = setLayerIds.length; i < ii; i++) {
                            const curLi = ul.querySelector(`li[data-layer-id="${setLayerIds[i]}"]`);
                            if (curLi) {
                                curLi.insertAdjacentElement('beforebegin', newLi);
                                inserted = true;
                                break;
                            }
                        }
                        if (!inserted) {
                            const moreLabel = ul.querySelector(`.${self.CLASS}-more-node`);
                            if (moreLabel) {
                                moreLabel.parentElement.insertAdjacentElement('beforebegin', newLi);
                            }
                            else {
                                ul.appendChild(newLi);
                            }
                        }
                    }
                    self.update();
                }
            }).catch(function (err) {
                TC.error(err);
            });
        }
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // no hace nada
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        if (layer.isBase) {
            const lis = self.div.querySelector('.' + self.CLASS + '-branch').querySelectorAll('li');
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.dataset.layerId === layer.id) {
                    li.parentElement.removeChild(li);
                    break;
                }
            }
        }
    };

    ctlProto.onErrorLayer = function (layer) {
        const self = this;

        if (layer.isBase && !layer.options.stealth) {
            self.map.toast(self.getLocaleString('baseLayerNotAvailable', { mapName: layer.title }), { type: TC.Consts.msgType.ERROR });
        }
    };

    ctlProto.getFallbackLayer = function (id) {
        const self = this;
        const filterFn = function (layer) {
            return layer.fallbackLayer && layer.fallbackLayer.id === id;
        };
        var result = self.map.baseLayers.filter(filterFn)[0].fallbackLayer;
        if (!result && self._moreBaseLayers) {
            result = self._moreBaseLayers.filter(filterFn)[0].fallbackLayer;
        }
        return result;
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        options = options || {};
        const layer = options.layer;
        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.classList.add(TC.Consts.classes.LOADING);
        const blCRSList = layer.getCompatibleCRS();

        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        dialog.dataset.layerId = layer.id;
        const ul = dialog.querySelector('ul.' + self.CLASS + '-crs-list');
        ul.innerHTML = '';
        self.map.loadProjections({
            crsList: self.map.getCompatibleCRS({
                layers: self.map.workLayers.concat(layer),
                includeFallbacks: true
            }),
            orderBy: 'name'
        }).then(function (projList) {
            var hasFallbackCRS = false;
            const fragment = document.createDocumentFragment();
            projList
                .forEach(function (projObj) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');

                    if (blCRSList.filter(function (crs) {
                        return TC.Util.CRSCodesEqual(crs, projObj.code)
                    }).length === 0) {
                        // Es un CRS del fallback
                        hasFallbackCRS = true;

                        button.innerHTML = projObj.name + ' (' + projObj.code + ')';
                        if (options.layer.fallbackLayer) {
                            button.dataset.fallbackLayerId = options.layer.fallbackLayer.id;
                        }
                        button.dataset.crsCode = projObj.code;
                        button.classList.add(TC.Consts.classes.WARNING);
                        li.classList.add(TC.Consts.classes.HIDDEN);
                    } else {
                        button.innerHTML = self.getLocaleString('changeMapToCrs', { crs: projObj.name + ' (' + projObj.code + ')' });
                        button.dataset.crsCode = projObj.code;
                    }

                    li.appendChild(button);
                    fragment.appendChild(li);
                });

            if (options.fallbackLayer) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.innerHTML = self.getLocaleString('reprojectOnTheFly');
                button.dataset.fallbackLayerId = options.fallbackLayer.id;
                li.appendChild(button);
                fragment.appendChild(li);
            }

            if (hasFallbackCRS) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                li.appendChild(button);
                fragment.appendChild(li);
            }
            ul.appendChild(fragment);

            modalBody.classList.remove(TC.Consts.classes.LOADING);
        });
        dialog.querySelector('.' + self.CLASS + '-name').innerHTML = layer.title || layer.name;
        TC.Util.showModal(dialog);
    };

    ctlProto.showMoreLayersDialog = function () {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

        dialog.classList.toggle(TC.Consts.classes.THREED, !!self.map.on3DView);

        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.innerHTML = '';
        modalBody.classList.add(TC.Consts.classes.LOADING);
        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        TC.Util.showModal(dialog, {
            closeCallback: function () {
                // no hay selección, vuelvo a seleccionar el mapa de fondo actual del mapa.
                this._currentSelection.checked = true;
                this.update();
            }.bind(self)
        });

        dialog.querySelector('.tc-modal-window').classList.add(self.CLASS + '-more-dialog');

        self._getMoreBaseLayers().then(function () {

            self.getRenderedHtml(self.CLASS, { baseLayers: self._moreBaseLayers }, function (html) {
                modalBody.innerHTML = html;
                modalBody.classList.remove(TC.Consts.classes.LOADING);
                modalBody.querySelectorAll('li').forEach(function (li, idx) {
                    li.dataset.layerId = self._moreBaseLayers[idx].id;
                });

                self.update(modalBody);
            });
        });
    };

    ctlProto.getLayer = function (id) {
        const self = this;
        return self.map && (self.map.getLayer(id) || (self._moreBaseLayers && self._moreBaseLayers.filter(function (layer) {
            return layer.id === id;
        })[0]));
    };

    const getTo3DVIew = function (baseLayer) {
        const self = this;

        return new Promise(function (resolve, reject) {
            Promise.all([
                baseLayer.getCapabilitiesPromise(),
                baseLayer.getFallbackLayer() ? baseLayer.getFallbackLayer().getCapabilitiesPromise() : Promise.resolve()
            ]).then(function () {
                resolve();
            });
        });
    };

    ctlProto._getMoreBaseLayers = function () {
        const self = this;

        if (!self._moreBaseLayers && !self._moreBaseLayersPromise) {

            self._moreBaseLayersPromise = new Promise(function (resolve, reject) {

                // GLS: Carlos no quiere que se muestren los respectivos dinámicos así que los filtro.
                var noDyn = TC.Cfg.availableBaseLayers.filter(function (l) {
                    return TC.Cfg.availableBaseLayers.filter(function (l) {
                        return l.fallbackLayer
                    }).map(function (l) {
                        return l.fallbackLayer
                    }).indexOf(l.id) == -1
                }).map(function (baseLayer) {
                    if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                        return new TC.layer.Raster(baseLayer);
                    } else if (baseLayer.type == TC.Consts.layerType.VECTOR) {
                        return new TC.layer.Vector(baseLayer);
                    }
                });

                self._moreBaseLayers = new Array(noDyn.length);

                const resolvePromise = function () {
                    self._moreBaseLayers = self._moreBaseLayers.filter(function (baseLayer) {
                        return baseLayer !== null;
                    });

                    resolve(self._moreBaseLayers);
                };
                const addLayer = function (i) {
                    const baseLayer = this;

                    baseLayer.map = self.map;
                    baseLayer.isBase = baseLayer.options.isBase = true;

                    if (baseLayer.type === TC.Consts.layerType.WMTS) {
                        var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                        baseLayer.mustReproject = !matrixSet;
                    } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                        baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                    }

                    if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                        baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());
                    }

                    self._moreBaseLayers.splice(i, 1, baseLayer);
                };

                Promise.all(noDyn.map(function (baseLayer, i) {
                    return new Promise(function (res, rej) {
                        if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                            var promise = self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                            promise.then(
                                function () {
                                    addLayer.call(baseLayer, i);
                                    res();
                                },
                                function (fail) {
                                    self._moreBaseLayers.splice(i, 1, null);
                                    res();
                                });
                        } else {
                            addLayer.call(baseLayer, i);
                            res();
                        }
                    });
                })).finally(resolvePromise);
            });

        } else if (self._moreBaseLayers) {

            return new Promise(function (resolve, reject) {
                Promise.all(self._moreBaseLayers.filter(function (baseLayer) {
                    return baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS;
                }).map(function (baseLayer) {
                    return self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                })).then(function () {

                    self._moreBaseLayers = self._moreBaseLayers.map(function (baseLayer) {

                        if (baseLayer.type === TC.Consts.layerType.WMTS) {
                            var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                            baseLayer.mustReproject = !matrixSet;
                        } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                            baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                        }
                        if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                            baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());

                            return baseLayer;
                        }

                        return baseLayer;
                    });

                    resolve(self._moreBaseLayers);
                });
            });
        }

        return self._moreBaseLayersPromise;
    };
})();

TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

(function () {

    TC.Consts.classes.CONNECTION_OFFLINE = TC.Consts.classes.CONNECTION_OFFLINE || 'tc-conn-offline';
    TC.Consts.classes.CONNECTION_WIFI = TC.Consts.classes.CONNECTION_WIFI || 'tc-conn-wifi';
    TC.Consts.classes.CONNECTION_MOBILE = TC.Consts.classes.CONNECTION_MOBILE || 'tc-conn-mobile';
    TC.Consts.classes.OFFLINE = TC.Consts.classes.OFFLINE || 'tc-offline';

    var ALREADY_EXISTS = 'already_exists';

    var manifestUrlList;
    var requestManifest = function () {
        return new Promise(function (resolve, reject) {
            if (manifestUrlList && manifestUrlList.length) {
                resolve(manifestUrlList);
            }
            else {
                var manifestFile = document.documentElement.getAttribute('manifest') || 'manifest.appcache';
                if (manifestFile) {
                    TC.ajax({
                        url: manifestFile,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (response) {
                        var data = response.data;
                        TC.loadJS(
                            !window.hex_md5,
                            [TC.apiLocation + TC.Consts.url.HASH],
                            function () {
                                var hash = hex_md5(data);
                                var idxEnd = data.indexOf('NETWORK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('FALLBACK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('SETTINGS:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                var lines = data.split(/[\n\r]/).filter(function (elm) {
                                    return elm.length > 0 && elm.indexOf('#') !== 0 && elm !== 'CACHE:';
                                });
                                // Eliminamos la primera línea porque siempre es CACHE MANIFEST
                                lines.shift();
                                resolve({
                                    hash: hash,
                                    urls: lines
                                });
                            }
                        );
                    }).catch(function (error) {
                        reject(error);
                    });
                }
                else {
                    reject(Error('There is no manifest in document'));
                }
            }
        });
    };

    TC.control.CacheBuilder = function () {
        var self = this;

        TC.control.SWCacheClient.apply(this, arguments);

        var cs = self._classSelector = '.' + self.CLASS;
        self._selectors = {
            DRAW: cs + '-draw',
            DRAWING: cs + '-drawing',
            PROGRESS: cs + '-progress',
            NEW: cs + '-new',
            LIST: cs + '-list',
            LISTITEM: cs + '-list > li',
            OKBTN: cs + '-btn-ok',
            NEWBTN: cs + '-btn-new',
            SAVEBTN: '.tc-btn-save',
            CANCELBTN: '.tc-btn-cancel',
            EDITBTN: '.tc-btn-edit',
            VIEWBTN: '.tc-btn-view',
            DELETEBTN: '.tc-btn-delete',
            TILECOUNT: cs + '-tile-count',
            NAMETB: cs + '-txt-name',
            TEXTBOX: 'input.tc-textbox',
            EXIT: cs + '-link-exit',
            OFFPANEL: cs + '-off-panel',
            BLLIST: cs + '-bl-list',
            BLLISTITEM: cs + '-bl-list > li',
            BLLISTTEXT: cs + '-bl-panel-txt',
            RNGMAXRES: cs + '-rng-maxres',
            SEARCH: cs + '-map-available-srch',
            EMPTYLIST: cs + '-map-available-empty',
            OFFLINEHIDDEN: '[data-no-cb]'
        };

        self.storedMaps = [];

        const mapDefString = TC.Util.getParameterByName(self.MAP_DEFINITION_PARAM_NAME);
        const extentString = TC.Util.getParameterByName(self.MAP_EXTENT_PARAM_NAME);
        self.mapIsOffline = !!mapDefString;
        if (mapDefString) {
            self.currentMapDefinition = JSON.parse(window.atob(decodeURIComponent(mapDefString)));
        }
        if (extentString) {
            self.currentMapExtent = getExtentFromString(extentString);
        }

        // Comprobación de disponibilidad de localStorage
        try {
            self.localStorage = window.localStorage;
            const key = "__delete_me__";
            self.localStorage.setItem(key, key);
            self.localStorage.removeItem(key);
        }
        catch (e) {
            self.localStorage = null;
            TC.error(self.getLocaleString('couldNotAccessLocalStorage'));
        }

        // Carga de mapas guardados
        if (self.localStorage) {
            for (var i = 0, len = self.localStorage.length; i < len; i++) {
                var key = self.localStorage.key(i);
                if (key.indexOf(self.LOCAL_STORAGE_KEY_PREFIX) === 0 && key !== self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash') {
                    // Es un nombre de mapa y no es el hash de integridad de la cache root
                    var values = self.localStorage.getItem(key).split(" ");
                    var extent = getExtentFromString(values.shift());
                    var name = values.join(" ");
                    var map = {
                        name: name,
                        extent: extent,
                        url: decodeURIComponent(key.substr(self.LOCAL_STORAGE_KEY_PREFIX.length))
                    }
                    self.storedMaps.push(map);
                }
            }
            self.storedMaps.sort(function (a, b) {
                if (a.name > b.name) {
                    return 1;
                }
                if (a.name < b.name) {
                    return -1;
                }
                return 0;
            });
        }

        var options = TC.Util.extend({}, len > 1 ? arguments[1] : arguments[0]);
        self._dialogDiv = TC.Util.getDiv(options.dialogDiv);
        if (window.$) {
            self._$dialogDiv = $(self._dialogDiv);
        }
        if (!options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        if (self.mapIsOffline) {
            document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                elm.classList.add(TC.Consts.classes.HIDDEN);
            })
        }

        TC.Control.apply(self, arguments);
        self.wrap = new TC.wrap.control.CacheBuilder(self);

        self.isDownloading = false;
        self.baseLayers = [];

        self.options.avgTileSize = self.options.avgTileSize || TC.Cfg.avgTileSize;
        self.requestSchemas = [];
        self.minResolution = 0;
        self.currentMap = null;

        self._loadedCount = 0;

        // Actualización del enlace al modo online
        // Parche para detectar cambios en el hash. Lo usamos para actualizar los enlaces a los idiomas
        var pushState = history.pushState;
        history.pushState = function (state) {
            var result;
            //if (typeof history.onpushstate == "function") {
            //    history.onpushstate({ state: state });
            //}
            result = pushState.apply(history, arguments);
            if (self._offlinePanelDiv) {
                const params = TC.Util.getQueryStringParams();
                delete params[self.MAP_DEFINITION_PARAM_NAME];
                delete params[self.MAP_EXTENT_PARAM_NAME];
                delete params[self.SERVICE_WORKER_FLAG];
                var newParams = TC.Util.getParamString(params);
                if (newParams.length) {
                    newParams = '?' + newParams;
                }
                const href = location.pathname + newParams + location.hash;
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).setAttribute('href', href);
            }
            return result;
        }

        // Detección de estado de conexión
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {};
        var onlineHandler = function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.remove(
                    TC.Consts.classes.CONNECTION_OFFLINE,
                    TC.Consts.classes.CONNECTION_MOBILE,
                    TC.Consts.classes.CONNECTION_WIFI);

                var type = connection.type;
                switch (type) {
                    case 1:
                    case 2:
                    case undefined:
                        panel.classList.add(TC.Consts.classes.CONNECTION_WIFI);
                        break;
                    default:
                        panel.classList.add(TC.Consts.classes.CONNECTION_MOBILE);
                        break;
                }
            }
        };
        if (connection.addEventListener) {
            connection.addEventListener('typechange', onlineHandler);
        }
        window.addEventListener('online', onlineHandler);
        window.addEventListener('offline', function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE, TC.Consts.classes.CONNECTION_WIFI);
            }
        });
    };

    TC.inherit(TC.control.CacheBuilder, TC.control.SWCacheClient);

    var ctlProto = TC.control.CacheBuilder.prototype;

    ctlProto.CLASS = 'tc-ctl-cbuild';
    ctlProto.MAP_DEFINITION_PARAM_NAME = "map-def";
    ctlProto.MAP_EXTENT_PARAM_NAME = "map-extent";
    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.map.";
    ctlProto.ROOT_CACHE_NAME = "root";
    ctlProto.SERVICE_WORKER_FLAG = 'sw';
    ctlProto._states = {
        READY: 'ready',
        EDIT: 'editing',
        DOWNLOADING: 'downloading',
        DELETING: 'deleting'
    };
    ctlProto._actions = {
        CREATE: 'create',
        DELETE: 'delete'
    };
    ctlProto.offlineControls = [
        'attribution',
        'basemapSelector',
        'cacheBuilder',
        'click',
        'coordinates',
        'draw',
        'edit',
        'geolocation',
        'loadingIndicator',
        'measure',
        'navBar',
        'popup',
        'print',
        'scale',
        'scaleBar',
        'scaleSelector',
        'state',
        'fullScreen'
    ];

    TC.Consts.event.MAPCACHEDOWNLOAD = TC.Consts.event.MAPCACHEDOWNLOAD || 'mapcachedownload.tc';
    TC.Consts.event.MAPCACHEDELETE = TC.Consts.event.MAPCACHEDELETE || 'mapcachedelete.tc';
    TC.Consts.event.MAPCACHEPROGRESS = TC.Consts.event.MAPCACHEPROGRESS || 'mapcacheprogress.tc';
    TC.Consts.event.MAPCACHEERROR = TC.Consts.event.MAPCACHEERROR || 'mapcacheerror.tc';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/CacheBuilder.html";
    ctlProto.template[ctlProto.CLASS + '-map-node'] = TC.apiLocation + "TC/templates/CacheBuilderMapNode.html";
    ctlProto.template[ctlProto.CLASS + '-bl-node'] = TC.apiLocation + "TC/templates/CacheBuilderBaseLayerNode.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CacheBuilderDialog.html";
    ctlProto.template[ctlProto.CLASS + '-off-panel'] = TC.apiLocation + "TC/templates/CacheBuilderOfflinePanel.html";

    const getExtentFromString = function (str) {
        return decodeURIComponent(str).split(',').map(function (elm) {
            return parseFloat(elm);
        });
    };

    const setDownloadingState = function (ctl) {
        ctl._state = ctl._states.DOWNLOADING;
        TC.Util.closeModal();
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.remove(TC.Consts.classes.HIDDEN);
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = true;
        ctl.layer.clearFeatures();
        ctl.boxDraw.cancel();
    };

    const setDeletingState = function (ctl) {
        ctl._state = ctl._states.DELETING;
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        ctl.div.querySelectorAll(ctl._selectors.LISTITEM).forEach(function (li) {
            li.classList.add(TC.Consts.classes.DISABLED);
        });
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = false;
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = '';
        ctl.boxDraw.cancel();
    };

    const setNameEditingState = function (ctl, li) {
        li.querySelector('span').classList.add(TC.Consts.classes.HIDDEN);
        const textbox = li.querySelector(ctl._selectors.TEXTBOX);
        textbox.classList.remove(TC.Consts.classes.HIDDEN);
        textbox.value = li.querySelector('span a').innerHTML;
        textbox.focus();
        li.querySelector(ctl._selectors.SAVEBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.add(TC.Consts.classes.HIDDEN);
    };

    const setNameReadyState = function (ctl, li) {
        li.querySelector('span').classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.TEXTBOX).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.SAVEBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.remove(TC.Consts.classes.HIDDEN);
    };

    var formatNumber = function (number) {
        return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
    };

    var updateResolutions = function (ctl, options) {
        var opts = options || {};
        const resDiv = ctl._dialogDiv.querySelector(ctl._classSelector + '-res');
        const range = ctl._dialogDiv.querySelector(ctl._selectors.RNGMAXRES);
        var resolutions = ctl.getResolutions();
        var resText, resLevel, resLeft;
        if (resolutions.length) {
            range.setAttribute('max', resolutions.length - 1);
            if (ctl.minResolution) {
                // Si ya había resolución previa y no se ha tocado el slider, se actualiza su valor
                if (opts.rangeValue === undefined) {
                    for (var i = 0, len = resolutions.length; i < len; i++) {
                        if (ctl.minResolution >= resolutions[i]) {
                            range.value = i;
                            break;
                        }
                    }
                }
            }
            else {
                if (opts.rangeValue === undefined) {
                    // Si no había resolución previa se selecciona un valor inicial igual a la resolución actual
                    const currentResolution = ctl.map.getResolution();
                    range.value = resolutions.filter(r => r > currentResolution).length;
                }
            }
            resLevel = parseInt(range.value);
            var resValue = Math.floor(new Number(resolutions[resLevel]) * 1000) / 1000;
            resText = ctl.getLocaleString('metersPerPixel', {
                value: resValue.toLocaleString((ctl.map ? ctl.map.options.locale : TC.Cfg.locale).replace('_', '-'))
            });
            resLeft = (resLevel + 1) * 100 / (resolutions.length + 1) + '%';
            range.disabled = false;
            ctl.minResolution = resolutions[range.value];
        }
        else {
            resLevel = 0;
            resText = '';
            range.value = 0;
            resLeft = '0';
            ctl.minResolution = 0;
            range.disabled = true;
        }
        resDiv.style.left = resLeft;
        resDiv.innerHTML = resText;
    };

    const findTileMatrixLimits = function (schema, resolution) {
        var result = null;
        for (var i = 0, len = schema.tileMatrixLimits.length; i < len; i++) {
            result = schema.tileMatrixLimits[i];
            if (result.res <= resolution) {
                break;
            }
        }
        return result;
    };

    const updateThumbnails = function (ctl) {
        ctl._dialogDiv.querySelectorAll(ctl._classSelector + '-bl-node input[type=checkbox]').forEach(function (cb, idx) {
            if (cb.checked) {
                var schema = ctl.requestSchemas.filter(function (elm) {
                    return elm.layerId === cb.value;
                })[0];
                if (schema) {
                    var tml = findTileMatrixLimits(schema, ctl.minResolution);
                    if (tml) {
                        var tmKey = '{TileMatrix}';
                        var trKey = '{TileRow}';
                        var tcKey = '{TileCol}';
                        var url = schema.url;
                        if (url.indexOf(tmKey) < 0) {
                            // Caso KVP
                            var qsIdx = url.indexOf('?');
                            if (qsIdx >= 0) {
                                url = url.substr(0, qsIdx);
                            }
                            for (var j = 0, lenj = ctl.baseLayers.length; j < lenj; j++) {
                                var l = ctl.baseLayers[j];
                                if (l.id === schema.layerId) {
                                    url = url + '?layer=' + l.layerNames + '&style=default&tilematrixset=' + l.matrixSet +
                                        '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + l.format +
                                        '&TileMatrix=' + tmKey + '&TileRow=' + trKey + '&TileCol=' + tcKey;
                                    break;
                                }
                            }
                        }
                        while (cb && cb.tagName !== 'LABEL') {
                            cb = cb.parentElement;
                        }
                        if (cb) {
                            cb.style.backgroundSize = 'auto';
                            cb.style.backgroundPosition = 'left bottom';
                            cb.style.backgroundImage = 'url(' + url.replace('{TileMatrix}', tml.mId).replace(trKey, tml.rt).replace(tcKey, tml.cl) + ')';
                        }
                    }
                }
            }
        });
    };

    const formatSize = function (ctl, size) {
        var result;
        if (size < 1) {
            result = ctl.getLocaleString('lessThan1Mb');
        }
        else {
            result = ctl.getLocaleString('approxXMb', { quantity: formatNumber(size) });
        }
        return result;
    };

    const showEstimatedMapSize = function (ctl) {
        var text = '';
        ctl.tileCount = 0;
        for (var i = 0, ii = ctl.requestSchemas.length; i < ii; i++) {
            var schema = ctl.requestSchemas[i];
            for (var j = 0, jj = schema.tileMatrixLimits.length; j < jj; j++) {
                var tml = schema.tileMatrixLimits[j];
                ctl.tileCount += (tml.cr - tml.cl + 1) * (tml.rb - tml.rt + 1);
                if (tml.res < ctl.minResolution) {
                    break;
                }
            }
        }
        if (ctl.tileCount) {
            ctl.estimatedMapSize = Math.round(ctl.tileCount * ctl.options.avgTileSize / 1048576);
            text = ctl.getLocaleString('xTiles', { quantity: formatNumber(ctl.tileCount) }) + ' (' + formatSize(ctl, ctl.estimatedMapSize) + ')';
        }
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = text;
    };

    const getListElementByMapName = function (ctl, name) {
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.innerHTML === name) {
                return li;
            }
        }
        return null;
    };

    const getListElementByMapUrl = function (ctl, url) {
        var hashIdx = url.indexOf('#');
        if (hashIdx >= 0) {
            url = url.substr(0, hashIdx);
        }
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.getAttribute('href') === url) {
                return li;
            }
        }
        return null;
    };

    var saveMapToStorage = function (ctl, map) {
        var result = false;
        if (ctl.localStorage) {
            ctl.localStorage.setItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(map.url), map.extent + " " + map.name);
            result = true;
        }
        return result;
    };

    var removeMapFromStorage = function (ctl, url) {
        var result = false;
        if (ctl.localStorage) {
            ctl.localStorage.removeItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(url));
            result = true;
        }
        return result;
    };

    const addMap = function (ctl) {
        const map = ctl.currentMap;
        if (saveMapToStorage(ctl, map)) {
            ctl.getRenderedHtml(ctl.CLASS + '-map-node', { name: map.name, url: map.url }, function (html) {
                const parser = new DOMParser();
                ctl.div.querySelector(ctl._selectors.LIST).appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).setAttribute('hidden', 'hidden');
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = false;
            });
            ctl.storedMaps.push(map);
        }
    };

    const removeMap = function (ctl, url) {
        const map = ctl.findStoredMap({ url: url });
        if (map) {
            if (removeMapFromStorage(ctl, url)) {
                const li = getListElementByMapName(ctl, map.name);
                if (li) {
                    li.parentElement.removeChild(li);
                }
            }
            var idx = ctl.storedMaps.indexOf(map);
            ctl.storedMaps.splice(idx, 1);
            if (!ctl.storedMaps.length) {
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = true;
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).removeAttribute('hidden');
            }

            return map.name;
        }

        return null;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            var renderObject = { storedMaps: self.storedMaps, listId: self.CLASS + '-list-' + TC.getUID() };
            self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
                self._dialogDiv.innerHTML = html;
                self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener(TC.Consts.event.CLICK, function (e) {
                    e.preventDefault();
                    this.selectionStart = 0;
                    this.selectionEnd = this.value.length;
                    this.focus();

                });
            }).then(function () {
                self.renderData(renderObject, function () {
                    self._dialogDiv.querySelector(self._selectors.OKBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.generateCache();
                    });
                    self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener('input', function () {
                        self._updateReadyState();
                    });
                    self.div.querySelector(self._selectors.NEWBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.setEditState();
                    });
                    self.div.querySelector(self._classSelector + '-btn-cancel-draw').addEventListener(TC.Consts.event.CLICK, function () {
                        self.setReadyState();
                    });

                    self.div.querySelector(self._classSelector + '-btn-cancel-dl').addEventListener(TC.Consts.event.CLICK, function () {
                        self.cancelCacheRequest();
                    });

                    const list = self.div.querySelector(self._selectors.LIST);
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.DELETEBTN, function (e) {
                        self.startDeleteMap(e.target.parentElement.querySelector('a').innerHTML);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.EDITBTN, function (e) {
                        setNameEditingState(self, e.target.parentElement);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.CANCELBTN, function (e) {
                        const li = e.target.parentElement;
                        li.querySelector(self._selectors.TEXTBOX).value = li.querySelector('a').innerHTML;
                        setNameReadyState(self, li);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.SAVEBTN, function (e) {
                        const li = e.target.parentElement;
                        setNameReadyState(self, li);
                        const anchor = li.querySelector('a');
                        const oldName = anchor.innerHTML;
                        const newName = li.querySelector(self._selectors.TEXTBOX).value;
                        const map = self.findStoredMap({ url: anchor.getAttribute('href') });
                        if (map) {
                            map.name = newName;
                            anchor.innerHTML = newName;
                            anchor.setAttribute('title', newName);
                            saveMapToStorage(self, map);
                        }
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.VIEWBTN, function (e) {
                        const btn = e.target;
                        var showExtent = !btn.classList.contains(TC.Consts.classes.ACTIVE);
                        const viewBtn = self.div.querySelector(self._selectors.VIEWBTN);
                        viewBtn.classList.remove(TC.Consts.classes.ACTIVE);
                        viewBtn.parentElement.classList.remove(TC.Consts.classes.ACTIVE);
                        const mapName = btn.parentElement.querySelector('a').innerHTML;
                        if (mapName) {
                            var map = self.findStoredMap({ name: mapName });
                            if (map) {
                                var extent = getExtentFromString(map.extent);
                                self.layer.clearFeatures();
                                if (showExtent) {
                                    self.layer.addPolygon(
                                        [
                                            [
                                                [extent[0], extent[1]],
                                                [extent[0], extent[3]],
                                                [extent[2], extent[3]],
                                                [extent[2], extent[1]]
                                            ]
                                        ]
                                        , {
                                            showsPopup: false
                                        }).then(function () {
                                            self.layer.map.zoomToFeatures(self.layer.features);
                                        });
                                    btn.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.parentElement.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.setAttribute('title', self.getLocaleString('removeMapExtent'));
                                }
                            }
                        }
                    }));

                    var _filter = function (searchTerm) {
                        searchTerm = searchTerm.toLowerCase();
                        //tc-ctl-cbuild-map-available-empty
                        const lis = self.div.querySelectorAll(self._selectors.LISTITEM);
                        lis.forEach(function (li) {
                            li.style.display = 'none';
                        });
                        const mapLis = [];
                        lis.forEach(function (li) {
                            if (li.matches('li:not([class]),li.' + TC.Consts.classes.ACTIVE)) {
                                mapLis.push(li);
                            }
                        });

                        if (searchTerm.length === 0) {
                            mapLis.forEach(function (li) {
                                li.style.removeProperty('display');
                            });
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'visible';
                        } else {
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'hidden';
                            var r = new RegExp(searchTerm, 'i');
                            mapLis.forEach(function (li) {
                                li.style.display = r.test(li.querySelector('a').textContent) ? '' : 'none';
                            });

                            if (!mapLis.some(function (li) {
                                return !li.hidden;
                            })) {
                                lis.forEach(function (li) {
                                    if (li.matches('[class^="tc-ctl-cbuild-map-not"]')) {
                                        li.style.removeProperty('display');
                                    }
                                });
                            }
                        }
                    };

                    const trackSearch = self.div.querySelector(self._selectors.SEARCH);
                    const searchListener = function () {
                        _filter(this.value.toLowerCase().trim());
                    };
                    trackSearch.addEventListener('keyup', searchListener);
                    trackSearch.addEventListener('search', searchListener);

                    self._dialogDiv.querySelector(self._selectors.BLLIST).addEventListener('change', TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
                        const checkbox = e.target;
                        if (checkbox.checked) {
                            self.baseLayers.push(self.map.getLayer(checkbox.value));
                        }
                        else {
                            for (var i = 0, ii = self.baseLayers.length; i < ii; i++) {
                                const bl = self.baseLayers[i];
                                if (bl.id === checkbox.value) {
                                    self.baseLayers.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        self.updateRequestSchemas();
                        updateResolutions(self);
                        updateThumbnails(self);
                        self._updateReadyState();
                        showEstimatedMapSize(self);
                    }));

                    const range = self._dialogDiv.querySelector(self._selectors.RNGMAXRES);
                    const rangeListener = function (e) {
                        updateResolutions(self, {
                            rangeValue: e.target.value
                        });
                        updateThumbnails(self);
                        showEstimatedMapSize(self);
                    };
                    range.addEventListener('input', rangeListener);
                    range.addEventListener('change', rangeListener);

                    const li = getListElementByMapUrl(self, location.href);
                    if (li) {
                        li.classList.add(TC.Consts.classes.ACTIVE);
                    }

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }
                })
                    .then(function () {
                        resolve();
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            });

            // Control para evitar que se cancele una descarga de cache al salir de la página
            window.addEventListener('beforeunload', function (e) {
                if (self.isDownloading) {
                    var msg = self.getLocaleString('cb.mapDownloading.warning');
                    e.returnValue = msg;
                    return msg;
                }
            }, true);
        }));
    };

    ctlProto.register = function (map) {
        var self = this;

        const result = TC.control.SWCacheClient.prototype.register.call(self, map);

        self.getServiceWorker().then(
            function () {
                navigator.serviceWorker.ready.then(function () {
                    navigator.serviceWorker.addEventListener('message', function (event) {
                        switch (event.data.event) {
                            case 'progress':
                                self.trigger(TC.Consts.event.MAPCACHEPROGRESS, { url: event.data.name, loaded: event.data.count, total: event.data.total });
                                break;
                            case 'cached':
                                self.trigger(TC.Consts.event.MAPCACHEDOWNLOAD, { url: event.data.name });
                                break;
                            case 'deleted':
                                self.trigger(TC.Consts.event.MAPCACHEDELETE, { url: event.data.name });
                                break;
                            case 'error':
                                if (event.data.action === self._actions.CREATE) {
                                    TC.error(self.getLocaleString('cb.resourceDownload.error', { url: event.data.url }));
                                }
                                break;
                            default:
                                break;
                        }
                    });
                });

                if (navigator.onLine) {
                    // Cacheamos mediante service worker las URLs del manifiesto
                    requestManifest().then(function (obj) {
                        const hashStorageKey = self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash';
                        var hash;
                        if (self.localStorage) {
                            hash = self.localStorage.getItem(hashStorageKey);
                        }
                        if (hash !== obj.hash) {
                            self.cacheUrlList(obj.urls);
                            self.one(TC.Consts.event.MAPCACHEDOWNLOAD, function () {
                                const firstLoad = !hash;
                                if (self.localStorage) {
                                    self.localStorage.setItem(hashStorageKey, obj.hash);
                                }
                                if (!firstLoad) {
                                    TC.confirm(self.getLocaleString('newAppVersionAvailable'), function () {
                                        location.reload();
                                    });
                                }
                            });
                        }
                    });
                }
            },
            function (error) {
                self.renderPromise().then(function () {
                    const container = self.div.querySelector(`.${self.CLASS}-new`);
                    const warning = document.createElement('div');
                    warning.classList.add('tc-alert', 'alert-warning');
                    const header = document.createElement('p');
                    const text = document.createElement('strong');
                    text.innerHTML = self.getLocaleString('offlineMap.error');
                    header.appendChild(text);
                    const reason = document.createElement('p');
                    reason.innerHTML = error.message;
                    warning.appendChild(header);
                    warning.appendChild(reason);
                    container.querySelector(self._selectors.NEWBTN).classList.add(TC.Consts.classes.HIDDEN);
                    container.appendChild(warning);
                });
            }
        ).catch(() => console.log("No SW available: no events handled"));

        if (self.mapIsOffline) {
            map.div.classList.add(TC.Consts.classes.OFFLINE);

            // Si no está especificado, el panel de aviso offline se cuelga del div del mapa
            self._offlinePanelDiv = TC.Util.getDiv(self.options.offlinePanelDiv);
            if (!self.options.offlinePanelDiv) {
                map.div.appendChild(self._offlinePanelDiv);
            }
            self.getRenderedHtml(self.CLASS + '-off-panel', null, function (html) {
                self._offlinePanelDiv.innerHTML = html;
                if (!navigator.onLine) {
                    const offPanel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                    offPanel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                    offPanel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE, TC.Consts.classes.CONNECTION_WIFI);
                }
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).addEventListener(TC.Consts.event.CLICK, function (e) {
                    TC.confirm(self.getLocaleString('offlineMapExit.confirm'),
                        null,
                        function () {
                            e.preventDefault();
                        });
                });
            });
        }

        const drawId = self.getUID();
        const layerId = self.getUID();
        self.layerPromise = map.addLayer({
            id: layerId,
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            owner: self,
            styles: {
                line: map.options.styles.line
            }
        });
        self.layer = null;
        Promise.all([
            self.layerPromise,
            self.renderPromise(),
            map.addControl('draw', {
                id: drawId,
                div: self.div.querySelector(self._selectors.DRAW),
                mode: TC.Consts.geom.RECTANGLE,
                persistent: false
            })
        ]).then(function (objects) {
            const layer = self.layer = objects[0];
            const boxDraw = self.boxDraw = objects[2];
            boxDraw.setLayer(layer);
            boxDraw
                .on(TC.Consts.event.DRAWSTART, function (e) {
                    self.map.toast(self.getLocaleString('clickOnDownloadAreaOppositeCorner'), { type: TC.Consts.msgType.INFO });
                })
                .on(TC.Consts.event.DRAWEND, function (e) {
                    var points = e.feature.geometry[0];
                    var pStart = points[0];
                    var pEnd = points[2];
                    var minx = Math.min(pStart[0], pEnd[0]);
                    var maxx = Math.max(pStart[0], pEnd[0]);
                    var miny = Math.min(pStart[1], pEnd[1]);
                    var maxy = Math.max(pStart[1], pEnd[1]);
                    self.setExtent([minx, miny, maxx, maxy]);
                    const checkboxes = self._dialogDiv.querySelectorAll('input[type=checkbox]');
                    checkboxes.forEach(function (checkbox) {
                        // Comprobamos que la extensión del mapa está disponible a alguna resolución
                        const layer = self.map.getLayer(checkbox.value);
                        var li = checkbox;
                        while (li && li.tagName !== 'LI') {
                            li = li.parentElement;
                        }
                        const tml = self.wrap.getRequestSchemas({
                            extent: self.extent,
                            layers: [layer]
                        })[0].tileMatrixLimits;

                        li.classList.toggle(TC.Consts.classes.HIDDEN, !tml.length);
                    });
                    const visibleLi = self._dialogDiv.querySelector(self._selectors.BLLISTITEM + ':not(.' + TC.Consts.classes.HIDDEN + ')');
                    self._dialogDiv.querySelector(self._selectors.BLLISTTEXT).innerHTML = self.getLocaleString(visibleLi ? 'selectAtLeastOne' : 'cb.noMapsAtSelectedExtent');

                    updateThumbnails(self);
                    showEstimatedMapSize(self);
                    TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-dialog'), {
                        openCallback: function () {
                            setTimeout(function () { // Este timeout evita el pulsado accidental cuando sale el diálogo
                                checkboxes.forEach(function (cb) {
                                    cb.disabled = false;
                                });
                            }, 100);
                            var time;
                            if (Date.prototype.toLocaleString) {
                                var opt = {};
                                opt.year = opt.month = opt.day = opt.hour = opt.minute = opt.second = 'numeric';
                                time = new Date().toLocaleString(self.map.options.locale.replace('_', '-'), opt);
                            }
                            else {
                                time = new Date().toString();
                            }
                            self._dialogDiv.querySelector(self._selectors.NAMETB).value = time;
                            self._updateReadyState();
                        },
                        closeCallback: function () {
                            checkboxes.forEach(function (cb) {
                                cb.disabled = true;
                            });
                            self.boxDraw.layer.clearFeatures();
                        }
                    });
                });

            map.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                if (boxDraw === e.control) {
                    if (self._state === self._states.EDITING) {
                        self.setReadyState();
                    }
                }
            });

        });

        var addRenderedListNode = function (layer) {
            var result = false;
            const blList = self._dialogDiv.querySelector(self._selectors.BLLIST);
            const isLayerAdded = function () {
                return !!blList.querySelector('li[data-layer-uid="' + layer.id + '"]');
            };
            var isValidLayer = layer.type === TC.Consts.layerType.WMTS && !layer.mustReproject;
            if (TC.Util.detectSafari() && TC.Util.detectIOS()) {
                isValidLayer = isValidLayer && TC.Util.isSameOrigin(layer.url);
            }
            if (isValidLayer && !isLayerAdded()) {
                result = true;
                self.getRenderedHtml(self.CLASS + '-bl-node', layer, function (html) {
                    if (!isLayerAdded()) {
                        const parser = new DOMParser();
                        blList.appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                    }
                });
            }
            return result;
        };

        map
            .on(TC.Consts.event.LAYERADD, function (e) {
                if (e.layer.isBase && self.mapIsOffline) {
                    // Capamos las resoluciones de la capa
                    const resolutions = e.layer.getResolutions();
                    if (resolutions) {
                        const cachedResolutions = resolutions.filter(r => r >= self.currentMapDefinition.res);
                        if (cachedResolutions.length) {
                            e.layer.setResolutions(cachedResolutions);
                        }
                    }
                }
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    addRenderedListNode(e.layer);
                });
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    const layer = e.layer;
                    if (layer.type === TC.Consts.layerType.WMTS) {
                        const li = self._dialogDiv
                            .querySelector(self._selectors.BLLIST)
                            .querySelector('li[data-layer-uid="' + layer.id + '"]');
                        li.parentElement.removeChild(li);
                    }
                });
            });

        map.ready(function () {
            if (self.mapIsOffline) {
                // Deshabilitamos los controles que no son usables en modo offline
                var offCtls = [];
                var i, len;
                for (i = 0, len = self.offlineControls.length; i < len; i++) {
                    var offCtl = self.offlineControls[i];
                    offCtl = offCtl.substr(0, 1).toUpperCase() + offCtl.substr(1);
                    offCtls = offCtls.concat(map.getControlsByClass('TC.control.' + offCtl));
                }

                for (i = 0, len = map.controls.length; i < len; i++) {
                    var ctl = map.controls[i];
                    if (offCtls.indexOf(ctl) < 0) {
                        ctl.disable();
                    }
                }

                document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
            }
        });

        map.loaded(function () {

            self.layerPromise.then(function (layer) {
                map.putLayerOnTop(layer);
            });

            self.renderPromise().then(function () {
                self.div.querySelector(self._selectors.NEWBTN).disabled = false;
                map.baseLayers.forEach(addRenderedListNode);
            });

            if (self.mapIsOffline) {
                const mapDef = self.currentMapDefinition;
                const isSameLayer = function (layer, mapDefLayer) {
                    const layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                    return (layerUrl === mapDef.url[mapDefLayer.urlIdx] && layer.layerNames === mapDefLayer.id && layer.matrixSet === mapDef.tms[mapDefLayer.tmsIdx]);
                };
                // Añadimos al mapa las capas guardadas que no están por defecto
                const missingLayers = map.options.availableBaseLayers
                    .filter((abl) => abl.type === TC.Consts.layerType.WMTS) // Capas cacheables
                    .filter((abl) => { // Que estén en el mapa sin conexión
                        return mapDef.layers.some((l) => isSameLayer(abl, l));
                    })
                    .filter((abl) => { // Que no estén en las capas por defecto
                        return !map.baseLayers.some((l) => l.id === abl.id);
                    });
                Promise.all(missingLayers.map((layer) => {
                    return map.addLayer(TC.Util.extend({}, layer, { isBase: true }));
                })).finally(function () {
                    // Obtenemos las capas cacheadas
                    const cachedLayers = [];
                    for (var i = 0, ii = mapDef.layers.length; i < ii; i++) {
                        for (var j = 0, jj = map.baseLayers.length; j < jj; j++) {
                            const baseLayer = map.baseLayers[j];
                            if (baseLayer.type === TC.Consts.layerType.WMTS && isSameLayer(baseLayer, mapDef.layers[i])) {
                                cachedLayers.push(baseLayer);
                                break;
                            }
                        }
                    }
                    if (cachedLayers.length) {
                        map.setBaseLayer(cachedLayers[0], function () {
                            // Quitamos las capas no disponibles (la capa en blanco la mantenemos)
                            for (var i = map.baseLayers.length - 1; i >= 0; i--) {
                                const baseLayer = map.baseLayers[i];
                                if (baseLayer.type !== TC.Consts.layerType.VECTOR && !cachedLayers.includes(baseLayer)) {
                                    map.removeLayer(baseLayer);
                                }
                            }

                            map.setExtent(self.currentMapExtent, { animate: false });
                        });
                    }
                });
            }
        });

        self
            .on(TC.Consts.event.MAPCACHEDOWNLOAD, function (e) {
                self.isDownloading = false;
                const removeHash = function (url) {
                    const hashIdx = url.indexOf('#');
                    return (hashIdx >= 0) ? url.substr(0, hashIdx) : url;
                }
                const url = removeHash(e.url);
                const li = getListElementByMapUrl(self, url);
                if (li && !self.serviceWorkerEnabled) {
                    // Se ha descargado un mapa cuando se quería borrar. Pasa cuando la cache ya estaba borrada pero la entrada en localStorage no.
                    li.classList.remove(TC.Consts.classes.DISABLED);
                    TC.alert(self.getLocaleString('cb.delete.error'));
                }
                else {
                    if (self.currentMap && url === self.currentMap.url) {
                        addMap(self);
                        map.toast(self.getLocaleString('mapDownloaded', { mapName: self.currentMap.name }));
                    }
                }
                self.currentMap = null;
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEDELETE, function (e) {
                self.isDownloading = false;
                var mapName = removeMap(self, e.url) || (self.currentMap && self.currentMap.name);
                self.currentMap = null;
                if (mapName) {
                    map.toast(self.getLocaleString('mapDeleted', { mapName: mapName }));
                }
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEPROGRESS, function (e) {
                var total = e.total;
                if (!total && self.requestSchemas) {
                    total = self.requestSchemas[0].tileCount;
                }
                var loaded = e.loaded;
                if (loaded) {
                    self._loadedCount = loaded;
                }
                else {
                    self._loadedCount += 1;
                    loaded = self._loadedCount;
                }
                self.showDownloadProgress(loaded, total);
            })
            .on(TC.Consts.event.MAPCACHEERROR, function (e) {
                self.isDownloading = false;
                self.setReadyState();
                var msg = self.getLocaleString('cb.mapCreation.error');
                var handleError = true;
                switch (e.reason) {
                    case 'quota':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonQuota');
                        break;
                    case 'resource':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonResource');
                        break;
                    case 'manifest':
                        if (e.status == '410') {
                            removeMap(self, e.url);
                        }
                        handleError = false;
                        break;
                    case ALREADY_EXISTS:
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonAlreadyExists');
                        break;
                    default:
                        break;
                }
                if (handleError) {
                    if (TC.Util.detectIE()) {
                        TC.error(msg);
                        TC.alert(self.getLocaleString('cb.mapCreation.error.reasonEdge'));
                    }
                    else {
                        TC.alert(msg);
                    }
                }
                self.currentMap = null;
            });

        return result;
    };

    ctlProto.setExtent = function (extent) {
        var self = this;
        if (Array.isArray(extent) && extent.length >= 4) {
            self.extent = extent;
            self.updateRequestSchemas();
        }
    };

    ctlProto._updateReadyState = function () {
        const self = this;
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled =
            !self.extent ||
            self._dialogDiv.querySelector(self._selectors.NAMETB).value.length === 0 ||
            self._dialogDiv.querySelector(self._selectors.RNGMAXRES).disabled;
    };

    ctlProto.setReadyState = function () {
        const self = this;
        self._state = self._states.READY;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        self.div.querySelectorAll(self._selectors.LISTITEM).forEach(function (li) {
            li.classList.remove(TC.Consts.classes.DISABLED);
        });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = false;
        self._dialogDiv.querySelector(self._selectors.TILECOUNT).innerHTML = '';
        self.extent = null;
        self._loadedCount = 0;
        if (self.boxDraw) {
            self.boxDraw.cancel();
        }
    };

    ctlProto.setEditState = function () {
        const self = this;
        self._state = self._states.EDITING;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.DRAWING).classList.remove(TC.Consts.classes.HIDDEN);
        self.map.toast(self.getLocaleString('clickOnDownloadAreaFirstCorner'), { type: TC.Consts.msgType.INFO });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = true;
        self._dialogDiv.querySelector(self._selectors.NAMETB).value = '';
        self.boxDraw.activate();
    };

    ctlProto.generateCache = function () {
        const self = this;
        const options = {
            mapName: self._dialogDiv.querySelector(self._selectors.NAMETB).value
        };
        if (self.findStoredMap({ name: options.mapName })) {
            TC.alert(self.getLocaleString('cb.mapNameAlreadyExists.error', options));
        }
        else {
            var startRequest = function () {
                self.div.querySelector(self._classSelector + '-name').innerHTML = options.mapName;
                self.map.toast(self.getLocaleString('downloadingMap', { mapName: options.mapName }));
                setDownloadingState(self);
                self.requestCache(options);
            };

            // Usamos Storage API si existe
            if (navigator.storage && navigator.storage.estimate) {
                navigator.storage.estimate().then(function (estimate) {
                    const availableMB = (estimate.quota - estimate.usage) / 1048576;
                    if (self.estimatedMapSize < availableMB) {
                        startRequest();
                    }
                    else {
                        TC.confirm(self.getLocaleString('cb.mapCreation.warning.reasonSize', {
                            mapName: options.mapName,
                            mapSize: formatSize(self, self.estimatedMapSize),
                            availableStorage: formatSize(self, Math.round(availableMB))
                        }), startRequest);
                    }
                });
            }
            else {
                startRequest();
            }
        }
    };

    ctlProto.cacheUrlList = function (urlList, options) {
        var self = this;
        var opts = options || {};
        self.createCache(opts.name || (self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME), {
            urlList: urlList,
            silent: opts.silent
        });
    };

    ctlProto.requestCache = function (options) {
        var self = this;
        var opts = options || {};
        if (self.map) {
            var extent = opts.extent || self.extent || self.map.getExtent();
            self.updateRequestSchemas({ extent: extent });

            if (self.requestSchemas) {
                var filterTml = function (elm, i, arr) {
                    var result = elm.res >= self.minResolution;
                    if (!result && i > 0) {
                        result = arr[i - 1].res > self.minResolution;
                    }
                    return result;
                };
                var trimTml = function (tml) {
                    return {
                        mId: tml.mId,
                        cl: tml.cl,
                        cr: tml.cr,
                        rt: tml.rt,
                        rb: tml.rb
                    };
                };
                // Solo mantenemos los esquemas hasta el nivel de resolución mínima o el inmediatamente inferior a ella si no lo tiene
                var requestSchemas = self.requestSchemas.map(function (schema) {
                    return {
                        layerId: schema.layerId,
                        tileMatrixLimits: schema.tileMatrixLimits.filter(filterTml)
                    };
                });
                // Actualizamos el extent para que coincida con las teselas del último nivel de los esquemas
                // También eliminamos del esquema todo lo irrelevante para la petición
                var intersectionExtent = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (var i = 0, len = requestSchemas.length; i < len; i++) {
                    var rs = requestSchemas[i];
                    var tml = rs.tileMatrixLimits[rs.tileMatrixLimits.length - 1];
                    var unitsPerTile = tml.res * tml.tSize;
                    intersectionExtent[0] = Math.min(intersectionExtent[0], tml.origin[0] + unitsPerTile * tml.cl);
                    intersectionExtent[1] = Math.min(intersectionExtent[1], tml.origin[1] - unitsPerTile * (tml.rb + 1));
                    intersectionExtent[2] = Math.max(intersectionExtent[2], tml.origin[0] + unitsPerTile * (tml.cr + 1));
                    intersectionExtent[3] = Math.max(intersectionExtent[3], tml.origin[1] - unitsPerTile * tml.rt);
                    rs.tileMatrixLimits = rs.tileMatrixLimits.map(trimTml);
                }


                // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                var precision = Math.pow(10, self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION);
                intersectionExtent = intersectionExtent.map(function (elm, idx) {
                    var round = (idx < 3) ? Math.ceil : Math.floor;
                    return round(elm * precision) / precision;
                });

                var mapDefinition = {
                    bBox: intersectionExtent,
                    res: Math.floor(self.minResolution * 1000) / 1000, // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                    url: [],
                    tms: [],
                    format: [],
                    layers: new Array(self.baseLayers.length)
                };
                for (var i = 0, len = self.baseLayers.length; i < len; i++) {
                    var layer = self.baseLayers[i];
                    var layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                    var urlIdx = mapDefinition.url.indexOf(layerUrl);
                    if (urlIdx < 0) {
                        urlIdx = mapDefinition.url.push(layerUrl) - 1;
                    }
                    var tmsIdx = mapDefinition.tms.indexOf(layer.matrixSet);
                    if (tmsIdx < 0) {
                        tmsIdx = mapDefinition.tms.push(layer.matrixSet) - 1;
                    }
                    var shortFormat = layer.format.substr(layer.format.indexOf('/') + 1);
                    var formatIdx = mapDefinition.format.indexOf(shortFormat);
                    if (formatIdx < 0) {
                        formatIdx = mapDefinition.format.push(shortFormat) - 1;
                    }
                    mapDefinition.layers[i] = {
                        urlIdx: urlIdx,
                        id: layer.layerNames,
                        tmsIdx: tmsIdx,
                        formatIdx: formatIdx
                    };
                }

                var params = TC.Util.getQueryStringParams();
                var e = params[self.MAP_EXTENT_PARAM_NAME] = intersectionExtent.toString();
                params[self.MAP_DEFINITION_PARAM_NAME] = btoa(JSON.stringify(mapDefinition));
                if (self.serviceWorkerEnabled) {
                    params[self.SERVICE_WORKER_FLAG] = 1;
                }
                var u = location.origin + location.pathname.substr(0, location.pathname.lastIndexOf('/') + 1) + '?' + TC.Util.getParamString(params);
                self.currentMap = { name: opts.mapName, extent: e, url: u };
                self.isDownloading = true;

                // Guardado mediante service workers
                if (self.serviceWorkerEnabled) {
                    const urlList = [];
                    for (var i = 0, len = requestSchemas.length; i < len; i++) {
                        var schema = requestSchemas[i];
                        var urlPattern = null;
                        for (var j = 0, lenj = self.baseLayers.length; j < lenj; j++) {
                            var l = self.baseLayers[j];
                            if (l.id === schema.layerId) {
                                urlPattern = self.wrap.getGetTilePattern(l);
                                if (l.getFallbackLayer) {
                                    // Esto se usa para meter en almacenamiento local el capabilities de la capa de fallback y evitar errores cuando no haya red
                                    l.getFallbackLayer();
                                }
                                if (l.thumbnail) {
                                    urlList.push(l.thumbnail);
                                }
                                break;
                            }
                        }
                        if (urlPattern) {
                            for (var k = 0, lenk = schema.tileMatrixLimits.length; k < lenk; k++) {
                                var tml = schema.tileMatrixLimits[k];
                                for (var r = tml.rt; r <= tml.rb; r++) {
                                    for (var c = tml.cl; c <= tml.cr; c++) {
                                        urlList.push(urlPattern.replace('{TileMatrix}', tml.mId).replace('{TileCol}', c).replace('{TileRow}', r));
                                    }
                                }
                            }
                        }
                    }
                    urlList.push(u);
                    self.cacheUrlList(urlList, { name: u });
                }
            }
        }
    }

    ctlProto.cancelCacheRequest = function () {
        var self = this;
        if (self.currentMap) {
            self.deleteCache(self.currentMap.url).then(function (obj) {
                if (!obj) {
                    self.currentMap = null;
                }
            });
        }
        self.isDownloading = false;
        self.setReadyState();
    };

    ctlProto.deleteMap = function (name) {
        var self = this;

        var map = self.findStoredMap({ name: name });
        if (map) {
            self.deleteCache(map.url);
        }
    };

    ctlProto.startDeleteMap = function (name) {
        const self = this;
        if (navigator.onLine) {
            if (name) {
                var confirmText = self.getLocaleString('cb.delete.confirm', { mapName: name });
                if (!self.serviceWorkerEnabled) {
                    confirmText = confirmText + " " + self.getLocaleString('cb.delete.confirm.connect.warning');
                }
                if (confirm(confirmText)) {
                    if (navigator.onLine) {
                        setDeletingState(self);
                        self.deleteMap(name);
                    } else {
                        TC.alert(self.getLocaleString('cb.delete.conn.alert'));
                    }
                }
            }
        } else {
            TC.alert(self.getLocaleString('cb.delete.conn.alert'));
        }
    };

    ctlProto.findStoredMap = function (options) {
        var self = this;
        return self.storedMaps.filter(function (elm) {
            var result = true;
            if (options.name && options.name !== elm.name) {
                result = false;
            }
            if (result && options.url && options.url !== elm.url) {
                result = false;
            }
            return result;
        })[0];
    };

    ctlProto.showDownloadProgress = function (current, total) {
        const self = this;
        const cs = self._classSelector;
        const count = self.div.querySelector(cs + '-progress-count');
        if (total) {
            var percent = Math.min(Math.round(current * 100 / total), 100);
            var percentString = percent + '%';
            self.div.querySelector(cs + '-progress-ratio').style.width = percentString;
            count.innerHTML = percentString;
        }
        else {
            self.div.querySelector(cs + '-progress-bar').classList.add(TC.Consts.classes.HIDDEN);
            count.innerHTML = self.getLocaleString('xFiles', { quantity: current });
        }
    };

    ctlProto.updateRequestSchemas = function (options) {
        var self = this;
        var opts = options || {};
        opts.extent = opts.extent || self.extent;
        opts.layers = opts.layers || self.baseLayers;
        self.requestSchemas = self.wrap.getRequestSchemas(opts);
        return self.requestSchemas;
    };

    ctlProto.getResolutions = function () {
        const self = this;
        var result = [];

        const resolutionMapper = function (tml) {
            return tml.res;
        };
        // Obtenemos un array de resoluciones por cada esquema de cada capa
        const allResolutions = self.requestSchemas.map(function (schema) {
            return schema.tileMatrixLimits.map(resolutionMapper);
        });

        // "Hacemos la cremallera" con los arrays de resoluciones de todas las capas y añadimos resoluciones al array de resultados
        result = result.concat.apply(result, allResolutions);
        result.sort(function (a, b) {
            return b - a;
        });
        return result;
    };

})();

TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.ControlContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;

    // GLS: 20/01/2020 código compatibilidad hacia atrás
    if (!Array.isArray(self.controlOptions)) {
        console.log('Gestionamos config de controlContainer antiguo');

        var controlOptions = [];

        Object.keys(self.controlOptions).forEach((key) => {
            const ctl = self.controlOptions[key];
            var newCtl = {
                position: ctl.side
            };

            newCtl[key] = ctl.options;

            controlOptions.push(newCtl);
        });

        self.controlOptions = controlOptions;
    }
};

TC.inherit(TC.control.ControlContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.ControlContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-cctr';
    ctlProto.POSITION = {
        LEFT: "left",
        RIGHT: "right"
    };

    // GLS: 20/01/2020 código compatibilidad hacia atrás
    ctlProto.SIDE = ctlProto.POSITION;

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ControlContainer.html";
    ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/ControlContainerNode.html";

    ctlProto.onRenderPromise = function () {
        const self = this;

        var bufferPromises = new Array(self.ctlCount);

        for (var i = 0, len = self.controlOptions.length; i < len; i++) {
            var ctl = self.controlOptions[i];

            var ctlName = Object.keys(ctl).filter((key) => {
                return ["position", "index"].indexOf(key) < 0;
            })[0];
            bufferPromises[i] = self.map.addControl(ctlName, TC.Util.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i).querySelector('div')
            }, ctl[ctlName]));
        }

        Promise.all(bufferPromises).then(function () {
            for (var i = 0, len = arguments.length; i < len; i++) {
                var ctl = arguments[i];
                ctl.containerControl = self;
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({
            controls: Object.keys(self.controlOptions).map(function (key, i) {
                return TC.Util.extend(self.controlOptions[key], { index: i });
            })
        }));
    };

    ctlProto.addControl = function (control, options) {
        const self = this;
        options.position = options.position || options.side || self.POSITION.LEFT;

        return new Promise(function (resolve, reject) {
            self.getRenderedHtml(self.CLASS + '-node', { index: ++self.ctlCount }, function (html) {
                var template = document.createElement('template');
                template.innerHTML = html.trim();

                self.div.querySelector('ul.' + self.CLASS + '-' + options.position).appendChild(template.content ? template.content.firstChild : template.firstChild);
                self.map.addControl(control, TC.Util.extend({
                    id: self.getUID(),
                    div: self.div.querySelector('.' + self.CLASS + '-elm-' + self.ctlCount).querySelector('div')
                }, options)).then(function (ctrl) {
                    resolve(ctrl);
                });
            });
        });
    };

    ctlProto.addElement = function (options) {
        const self = this;

        options.position = options.position || options.side || self.POSITION.LEFT;

        var li = document.createElement('li');
        li.setAttribute('class', (self.CLASS + '-elm ') + (self.CLASS + '-elm-' + self.ctlCount++ + ' '));

        self.div.querySelector('ul.' + self.CLASS + '-' + options.position).appendChild(li);

        var addedElement = li.appendChild(options.htmlElement);
        addedElement.setAttribute('class', addedElement.getAttribute('class') + ' tc-ctl');
        return addedElement;
    };
})();

TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

TC.control.Coordinates = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.crs = '';
    self.xy = [0, 0, 0];
    self.latLon = [0, 0, 0];
    self.x = 0;
    self.y = 0;
    self.lat = 0;
    self.lon = 0;
    self.units = TC.Consts.units.METERS;
    self.isGeo = false;

    TC.control.ProjectionSelector.apply(self, arguments);

    TC.Util.extend(self._cssClasses, {
        CRS: self.CLASS + '-crs',
        GEOCRS: self.CLASS + '-geocrs',
        X: self.CLASS + '-x',
        Y: self.CLASS + '-y',
        LAT: self.CLASS + '-lat',
        LON: self.CLASS + '-lon',
        ELEVATION: self.CLASS + '-elevation',
        THREEDMARKER: self.CLASS + '-threed'
    });

    self.geoCrs = self.options.geoCrs || TC.Cfg.geoCrs;
    self.wrap = new TC.wrap.control.Coordinates(self);
};

TC.inherit(TC.control.Coordinates, TC.control.ProjectionSelector);

(function () {
    var ctlProto = TC.control.Coordinates.prototype;

    ctlProto.CLASS = 'tc-ctl-coords';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Coordinates.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CoordinatesDialog.html";

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        self.crs = self.map.crs;

        self.clear();

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            if (view === TC.Consts.view.PRINTING) {
                return;
            }

            const _3dContainerListener = function (e) {
                if (!self.isPointerOver(e)) {
                    self.clear();
                }
            };

            if (view === TC.Consts.view.THREED) {
                self.isGeo = true;
                self.units = TC.Consts.units.DEGREES;
                self.crs = self.map.view3D.crs;

                self.map.view3D.container.addEventListener('mouseout', _3dContainerListener);

                /* provisional: faltaría el off cuando pasemos a default*/
                self.map.view3D.on(TC.Consts.event.MOUSEMOVE, function (coords) {
                    if (coords) {
                        if (TC.Util.detectMobile()) { // si estamos en móvil añadimos marcador al mapa 3D                            

                            self.clear();

                            self.coordsToClick({ coordinate: [coords.lon, coords.lat, coords.ele], cssClass: self._cssClasses.THREEDMARKER });
                        }

                        self.latLon = [coords.lat, coords.lon];
                        if (coords.ele > 0) {
                            var locale = TC.Util.getMapLocale(self.map);
                            self.latLon.push(coords.ele.toLocaleString(locale) + "m");
                        }

                        self.update();
                    } else {
                        self.clear();
                    }
                });

            } else if (view === TC.Consts.view.DEFAULT) {
                self.isGeo = self.map.wrap.isGeo();
                self.units = TC.Consts.units.METERS;
                self.crs = self.map.crs;

                if (self.map.view3D) {
                    self.map.view3D.container.removeEventListener('mouseout', _3dContainerListener);
                }                
            }

            if (self.map.view3D) {
                self.geoCrs = self.map.view3D.crs;
                self.render();
            }            
        });

        map.loaded(function () {
            // Se espera antes de registrar el control a que se cargue el mapa para evitar que muestre valores extraños
            self.wrap.register(map).then(function () {
                self.render(function () {
                    //self.update();
                    self.clear();
                });
            });

            if (TC.Util.detectMobile()) {
                self.renderPromise().then(function () {
                    self.getLayer();
                    self.activateCoords();
                });                
            }

            map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                if (!map.on3DView) {
                    self.isGeo = map.wrap.isGeo();
                    self.crs = e.newCrs;
                    self.render();
                }                
            });

            self.map.wrap.getViewport().then(function (viewport) {
                self.renderPromise().then(function () {
                    viewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
                        if (self.map.on3DView) {
                            return;
                        }

                        self.onMouseMove(e);
                    });
                    viewport.addEventListener(TC.Consts.event.MOUSELEAVE, function (e) {
                        self.onMouseLeave(e);
                    });
                });                
            });
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.renderData.call(self, {
                x: self.x,
                y: self.y,
                lat: self.lat,
                lon: self.lon,
                ele: self.isGeo && self.latLon.length > 2 ? self.latLon[2] : (!self.isGeo && self.xy.length > 2 ? self.xy[2] : null),
                crs: self.crs,
                geoCrs: self.geoCrs,
                isGeo: self.isGeo,
                showGeo: !self.isGeo && self.options.showGeo
            }, function () {
                self.div.querySelector('button.' + self._cssClasses.CRS).addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.showProjectionChangeDialog();
                });

                //self.div.addEventListener('mousemove', function (e) {
                //    self.setVisibility([e.clientX, e.clientY]);
                //});

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            });
        }));
    };

    ctlProto.onMouseMove = function (e) {        
        this.wrap.onMouseMove(e);
    };

    ctlProto.onMouseLeave = function (e) {
        const self = this;
        setTimeout(function () {
            if (!self.isPointerOver(e)) {
                self.div.style.visibility = 'hidden';
                self.clear();
            }
        }, 200);
    };

    ctlProto.isPointerOver = function (e) {
        var self = this;

        var clientRect = self.div.getBoundingClientRect();
        return (clientRect.left <= e.clientX &&
            clientRect.left + clientRect.width >= e.clientX &&
            clientRect.top <= e.clientY &&
            clientRect.top + clientRect.height >= e.clientY);
    };    

    ctlProto.update = function () {
        const self = this;

        if (!self.isGeo && self.options.showGeo) {
            self.latLon = TC.Util.reproject(self.xy, self.crs, self.geoCrs).reverse();
        }

        if (!self.isGeo) {
            self.x = TC.Util.formatCoord(self.xy[0], TC.Consts.METER_PRECISION);
            self.y = TC.Util.formatCoord(self.xy[1], TC.Consts.METER_PRECISION);
        }

        if (self.isGeo || self.options.showGeo) {
            self.lat = TC.Util.formatCoord(self.latLon[0], TC.Consts.DEGREE_PRECISION);
            self.lon = TC.Util.formatCoord(self.latLon[1], TC.Consts.DEGREE_PRECISION);
        }

        self.render(function () {
            const closeSpan = self.div.querySelector('span.close');
            if (TC.Util.detectMobile()) {
                closeSpan.addEventListener('click', function () {
                    self.div.classList.add(TC.Consts.classes.HIDDEN);
                    self.clear();
                });

                closeSpan.style.display = '';
            }
            else {
                self.div.classList.remove(TC.Consts.classes.HIDDEN);
                self.div.style.visibility = 'visible';
                closeSpan.style.display = 'none';
            }
        });
    };

    ctlProto.clear = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.div.style.visibility = 'hidden';

        delete self.currentCoordsMarker;
        self.getLayer().then(function (layer) {
            layer.clearFeatures();
        });
    };

    ctlProto.deactivateCoords = function () {
        var self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.clear();

        self.wrap.coordsDeactivate();
    };

    ctlProto.activateCoords = function () {
        var self = this;

        self.wrap.coordsActivate();
    };

    ctlProto.getCoords = function () {
        var self = this;
        // si hay visible un popup, establecemos la posición de la cruz en el punto en el cual se ha abierto el popup
        var popup = self.map.getControlsByClass(TC.control.Popup);
        if (popup && popup.length > 0 && popup[0].isVisible()) {
            self.coordsToPopup(popup[0]);
        }
        else { // si no hay popup, calculamos el centro del mapa                
            self.updateCoordsCtrl([(self.map.getExtent()[0] + self.map.getExtent()[2]) / 2, (self.map.getExtent()[1] + self.map.getExtent()[3]) / 2]);

            self.coordsToClick.call(self, { coordinate: self.xy });
        }
    };

    ctlProto.coordsToPopup = function (popup) {
        var self = this;

        if (popup) {
            self.updateCoordsCtrl(popup.wrap.popup.getPosition());
        }
    };

    ctlProto.updateCoordsCtrl = function (position) {
        var self = this;

        if (position) {
            if (!self.isGeo) {
                self.x = position[0];
                self.y = position[1];
                self.xy = [self.x, self.y];

                if (position.length > 2) {
                    self.xy.push(position[2]);
                }
            }
            if (self.isGeo || self.options.showGeo) {
                self.lat = position[0];
                self.lon = position[1];
                self.latLon = [self.lat, self.lon];

                if (position.length > 2) {
                    self.latLon.push(position[2]);
                }
            }

            self.update();
        }
    };

    // Establece la posición de la cruz en la posición recibida
    //var animationTimeout;
    ctlProto.coordsToClick = function (e) {
        var self = this;

        // Si streetView está activo, no responde al click
        if (!self.map.div.classList.contains('tc-ctl-sv-active') || !self.map.div.classList.contains(TC.Consts.classes.COLLAPSED)) {

            var coordsBounding = self.div.getBoundingClientRect();
            if ((coordsBounding.left <= e.clientX && e.clientX <= coordsBounding.right && coordsBounding.top <= e.clientY && e.clientY <= coordsBounding.bottom)) {
                self.div.classList.add(TC.Consts.classes.HIDDEN);
                self.clear();

                return;
            }

            self.div.classList.remove('tc-fading');
            setTimeout(function () {
                self.div.classList.add('tc-fading');
            }, 10);

            self.updateCoordsCtrl(e.coordinate);

            if (!self.map.on3DView) {
                self.coordsMarkerAdd(e.coordinate, e.cssClass);
            }

            self.div.classList.remove(TC.Consts.classes.HIDDEN);
            //self.div.style.visibility = 'visible';

            //self.div.style.opacity = '0.7';

            //animationTimeout = setTimeout(function () {
            //    $(self.div).animate({ opacity: 0 }, 3000, "linear",
            //        function () {
            //            self.clear();
            //        });
            //}, 5000);
        }
    };

    ctlProto.coordsMarkerAdd = function (position, cssClass) {
        var self = this;

        if (!self.currentCoordsMarker) {
            self.getLayer().then(function (layer) {
                layer.addMarker(position, { title: 'Coord', showsPopup: false, cssClass: cssClass || TC.Consts.classes.POINT, anchor: [0.5, 0.5] })
                    .then(function (marker) {
                        self.currentCoordsMarker = marker;
                    });
            });
        } else {
            self.currentCoordsMarker.setCoords(position);
        }
    };

    ctlProto.getLayer = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer == undefined) {
                self.map.addLayer({
                    id: self.getUID(),
                    type: TC.Consts.layerType.VECTOR,
                    stealth: true,
                    owner: self,
                    title: 'Coordenadas',
                }).then(function (layer) {
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);
                    resolve(self.layer);
                });
            } else {
                resolve(self.layer);
            }
        });
    };

})();
TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.DataLoader = function () {
    const self = this;

    TC.control.TabContainer.apply(self, arguments);

    self.controlOptions = [
        {
            name: 'externalWMS',
            title: 'addWMS',
            options: {
                suggestions: self.options.wmsSuggestions
            }
        },
        {
            name: 'fileImport',
            options: {
                enableDragAndDrop: self.options.enableDragAndDrop
            }
        }
    ];
    self.defaultSelection = 0;
};

TC.inherit(TC.control.DataLoader, TC.control.TabContainer);

(function () {
    const ctlProto = TC.control.DataLoader.prototype;

    ctlProto.register = function (map) {
        const self = this;
        self.title = self.getLocaleString('addMaps');
        return new Promise(function (resolve, reject) {
            TC.control.TabContainer.prototype.register.call(self, map).then(ctl => {
                ctl.div.classList.add(self.CLASS + '-datldr');
                resolve(ctl);
            });
        })
    };

})();

TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

TC.Consts.DownloadError = {
    MIMETYPE_NOT_SUPORTED: "MimeTypeNotSupported"
}

TC.control.Download = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self._hiddenElms = [];

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }    
};

TC.inherit(TC.control.Download, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Download.prototype;

    ctlProto.CLASS = 'tc-ctl-download';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Download.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/DownloadDialog.html";

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.renderData.call(self, { controlId: self.id }, function () {

                const cs = '.tc-ctl-tctr';
                self._selectors = {
                    TAB: cs + '-tab',
                    RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
                    ELEMENT: cs + '-elm'
                };

                const clickHandler = function (e) {
                    var tab = this;
                    while (tab && !tab.matches(self._selectors.TAB)) {
                        tab = tab.parentElement;
                    }
                    if (tab) {
                        const checkbox = tab.querySelector(self._selectors.RADIOBUTTON);
                        const newValue = checkbox.value;
                        const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                        if (self._oldValue === newValue && self.options.deselectable) {
                            setTimeout(function () {
                                checkbox.checked = false;
                            }, 0);
                            self._oldValue = null;
                            self._activeElm = null;
                            elms.forEach(function (elm) {
                                self._hiddenElms.push(elm);
                            });
                        }
                        else {
                            elms.forEach(function (elm) {
                                if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                                    self._activeElm = elm;
                                }
                                else {
                                    self._hiddenElms.push(elm);
                                }
                            });
                            self._oldValue = newValue;
                        }

                        self._hiddenElms.forEach(function (elm) {
                            elm.classList.add(TC.Consts.classes.COLLAPSED);
                        });
                        if (self._activeElm) {
                            self._activeElm.classList.remove(TC.Consts.classes.COLLAPSED);
                        }
                        checkbox.checked = true;
                    }
                };

                self.div.querySelectorAll('span').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, clickHandler);
                });
                if (callback) {
                    callback();
                }
            });
        });
    };

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        /**
         * Descarga las features de las capas de trabajo actualmente seleccionadas. Comprueba que el número de features a descargar
         * no excede el límite impuesto por el servidor.
         */       

        var _download = function () {
            var wait = self.map.getLoadingIndicator().addWait();

            var format = '';
            if (self._activeElm) {
                format = self._activeElm.querySelector('select').value;
            }
            if (format.indexOf('image') > -1) {
                const doneQR = new Promise(function (resolve, reject) {
                    var canvas = self.map.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
                    var newCanvas = TC.Util.cloneCanvas(canvas);

                    var sb = self.map.getControlsByClass(TC.control.ScaleBar);
                    if (sb) {
                        self.drawScaleBarIntoCanvas({ canvas: newCanvas, fill: true });
                    }

                    if (self._activeElm.querySelector(`#${self.CLASS}-image-qr-${self.id}:checked`)) {
                        const codeContainerId = 'qrcode';
                        var codeContainer = document.getElementById(codeContainerId);
                        if (codeContainer) {
                            codeContainer.innerHTML = '';
                        }
                        else {
                            codeContainer = document.createElement('div');
                            codeContainer.setAttribute('id', codeContainerId);
                            document.body.appendChild(codeContainer);
                        }

                        codeContainer.style.top = '-200px';
                        codeContainer.style.left = '-200px';
                        codeContainer.style.position = 'absolute';

                        self.makeQRCode(codeContainer, 87, 87).then(function (qrCodeBase64) {
                            if (qrCodeBase64) {
                                var ctx = newCanvas.getContext("2d");
                                ctx.fillStyle = "#ffffff";
                                ctx.fillRect(newCanvas.width - 91, newCanvas.height - 91, 91, 91);

                                TC.Util.addToCanvas(newCanvas, qrCodeBase64, { x: newCanvas.width - 88, y: newCanvas.height - 88 }).then(function (mapCanvas) {
                                    resolve(mapCanvas);
                                });
                            } else {
                                TC.error(self.getLocaleString('dl.export.map.error') + ': ' + 'QR');
                                self.map.getLoadingIndicator().removeWait(wait);
                            }
                        });
                    } else {
                        resolve(newCanvas);
                    }
                });

                doneQR.then(function (_canvas) {
                    try {
                        const res = _canvas.toDataURL(format);
                        TC.Util.downloadDataURI(window.location.hostname + '_' + TC.Util.getFormattedDate(new Date().toString(), true) + '.' + format.split('/')[1], format, res);
                    } catch (e) {
                        TC.error(self.getLocaleString('dl.export.map.error') + ': ' + e.message);
                    }

                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
            else {
                var extent = self.map.getExtent();
                
                var arrPromises = TC.WFSGetFeatureBuilder(self.map, TC.filter.bbox(extent, self.map.getCRS()), format, true);
                Promise.all(arrPromises).then(async function (responseArray) {

                    var responses = responseArray.filter(function (item) { return item != null });
                    if (responses.length === 0) {
                        _showAlertMsg({ key: TC.Consts.WFSErrors.NO_LAYERS }, wait);
                        return;
                    }
                    var arrDownloads = [];
                    for (var i = 0; i < responses.length; i++) {
                        //errores del WFS
                        if (responses[i].errors && responses[i].errors.length) {
                            for (var j = 0; j < responses[i].errors.length; j++) {
                                var error = responses[i].errors[j];
                                _showAlertMsg(error, wait);
                            }
                            continue;
                        }
                        var data = responses[i].data;
                        var url = responses[i].url;
                        if (data && url)
                            arrDownloads.push({ url: url + "?download=zip", data: data });
                    }
                    try {
                        await TC.Util.downloadFileForm(arrDownloads);
                    }
                    catch (err) {
                        if (err.key === TC.Consts.DownloadError.MIMETYPE_NOT_SUPORTED) {
                            const service = responseArray.find(function (response) { return response.data === err.data }).service;
                            const params = {
                                plural: service.layers.length > 1 ? self.getLocaleString("dl.format.notSupported.plural") : "",
                                layerNames: service.layers.reduce(function (vi, va, i, array) {
                                    return (vi instanceof Array ? vi : [vi]).concat([va.title]).join(i < array.length - 1 ? ", " : " " + self.getLocaleString("dl.format.notSupported.conjunction") +" ")
                                }, []),                                
                                serviceTitle: service.mapLayers[0].title,
                                format:format
                            }
                            self.map.toast(self.getLocaleString("dl.format.notSupported").format(params), { type: TC.Consts.msgType.ERROR });
                        }
                    }

                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
        };

        /**
         * Comprueba si hay capas visibles en el panel de capas cargadas.
         */
        var _getVisibleLayers = function () {
            var visibleLayers = [];
            for (var i = 0; i < self.map.workLayers.length; i++) {
                var layer = self.map.workLayers[i];
                if (layer.type === TC.Consts.layerType.WMS) {
                    if (layer.getVisibility() && layer.names.length > 0) {
                        visibleLayers.push(layer);
                    }
                }
            }
            return visibleLayers;
        };

        var _showAlertMsg = function (error, wait) {
            const alert = self.div.querySelector('.alert-warning:not(.' + self.CLASS + '-alert)');
            var errorMsg;
            switch (error.key) {
                case TC.Consts.WFSErrors.MAX_NUM_FEATURES:
                    errorMsg = alert.querySelector("#zoom-msg-" + self.id).innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NO_LAYERS:
                    errorMsg = self.getLocaleString('noLayersLoaded');
                    break;
                case TC.Consts.WFSErrors.GETCAPABILITIES:
                    errorMsg = alert.querySelector("#novalid-msg-" + self.id).innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NO_FEATURES:
                    errorMsg = alert.querySelector("#noFeatures-msg-" + self.id).innerHTML;
                    break;
                case TC.Consts.WFSErrors.INDETERMINATE:
                    errorMsg = self.getLocaleString("wfs.IndeterminateError");
                    self.map.toast(errorMsg, { type: TC.Consts.msgType.ERROR });
                    TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                    self.map.getLoadingIndicator().removeWait(wait);
                    return
                    break;
                default:
                    errorMsg = self.getLocaleString("wfs." + error.key, error.params);
                    break;
            }
            self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

            self.map.getLoadingIndicator().removeWait(wait);
        };

        var _showHelp = function (evt) {
            evt.stopPropagation();
            TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-help-dialog'));
        };

        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-btn', _download));
        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-help', _showHelp));

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector(`#${self.CLASS}-image-qr-${self.id}`, function (e) {
            if (e.target.checked) {
                self.generateLink();
            } else {
                self.div.querySelector('.' + self.CLASS + '-alert').classList.add(TC.Consts.classes.HIDDEN);
            }
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {            
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;
        const alert = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.getElementById(`${self.CLASS}-image-qr-${self.id}`).checked) {
            alert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
        } else {
            alert.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}
if (!TC.Feature || !TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}
if (!TC.Feature || !TC.feature.Polyline) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polyline');
}
if (!TC.Feature || !TC.feature.Polygon) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polygon');
}

TC.Consts.event.DRAWSTART = 'drawstart.tc';
TC.Consts.event.DRAWEND = 'drawend.tc';
TC.Consts.event.DRAWCANCEL = 'drawcancel.tc';
TC.Consts.event.DRAWUNDO = 'drawundo.tc';
TC.Consts.event.DRAWREDO = 'drawredo.tc';
TC.Consts.event.POINT = 'point.tc';
TC.Consts.event.MEASURE = 'measure.tc';
TC.Consts.event.MEASUREPARTIAL = 'measurepartial.tc';
TC.Consts.event.STYLECHANGE = 'stylechange.tc';
TC.Consts.event.CHANGE = 'change';

(function () {

    const formatColor = function (color) {
        const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
        if (match && match.length) {
            return '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
        }
        return color;
    };

    TC.control.Draw = function () {
        var self = this;

        TC.Control.apply(self, arguments);

        if (!TC.browserFeatures.inputTypeColor() && !window.CP) {
            TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
            TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
        }

        self._classSelector = '.' + self.CLASS;

        self._pointClass = self.CLASS + '-point';
        self._lineClass = self.CLASS + '-line';
        self._polygonClass = self.CLASS + '-polygon';

        self.history = [];
        self.historyIndex = 0;
        self.exportsState = true;

        self
            .on(TC.Consts.event.DRAWSTART, function (e) {
                self.resetValues();
            })
            .on(TC.Consts.event.POINT, function (e) {
                if (self.layer && !self.persistent && self.layer.features && self.layer.features.length > 0) {
                    self.layer.clearFeatures();
                }

                self.history.length = self.historyIndex;
                self.history[self.historyIndex++] = e.point;

                setDrawState(self);
            })
            .on(TC.Consts.event.DRAWEND, function (e) {
                setFeatureAddReadyState(self);

                e.feature.setId(TC.getUID(self.getLocaleString('sketch') + '.'));

                if (self.callBack) {
                    self.callBack(e.feature);
                }
            });

        self._layerPromise = null;
    };

    TC.inherit(TC.control.Draw, TC.Control);

    var ctlProto = TC.control.Draw.prototype;

    ctlProto.CLASS = 'tc-ctl-draw';

    var setDrawState = function (ctl) {
        ctl._endBtn.disabled =
            ctl.historyIndex === 0 ||
            (ctl.mode === TC.Consts.geom.POLYGON && ctl.historyIndex < 3) ||
            (ctl.mode === TC.Consts.geom.POLYLINE && ctl.historyIndex < 2);
        ctl._redoBtn.disabled = ctl.history.length === ctl.historyIndex;
        ctl._undoBtn.disabled = ctl.historyIndex === 0;
    };

    var setFeatureAddReadyState = function (ctl) {
        ctl.resetValues();
        ctl._endBtn.disabled = true;
        ctl._cancelBtn.disabled = false;
    };

    ctlProto.template = TC.apiLocation + "TC/templates/Draw.html";

    ctlProto.render = function (callback) {
        var self = this;
        var strToolTip;
        var strokeColor;
        var strokeWidth;
        switch (self.options.mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                strToolTip = self.getLocaleString('drawLine');
                self.div.classList.add(self._lineClass);
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                strToolTip = self.getLocaleString('drawPolygon');
                self.div.classList.add(self._polygonClass);
                strokeColor = TC.Cfg.styles.polygon.strokeColor;
                strokeWidth = TC.Cfg.styles.polygon.strokeWidth;
                break;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                strToolTip = self.getLocaleString('drawPoint');
                self.div.classList.add(self._pointClass);
                strokeColor = TC.Cfg.styles.point.strokeColor;
                strokeWidth = TC.Cfg.styles.point.strokeWidth;
                break;
            default:
                strToolTip = self.getLocaleString('draw');
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
        }
        const renderObject = {
            tooltip: strToolTip,
            strokeColor: formatColor(strokeColor),
            strokeWidth: strokeWidth,
            styleTools: self.options.styleTools
        };
        return self._set1stRenderPromise(self.renderData(renderObject, function () {
            if (!TC.browserFeatures.inputTypeColor()) {
                // El navegador no soporta input[type=color], usamos polyfill
                const input = self.div.querySelector('input[type=color]');
                if (input) {
                    input.style.backgroundColor = input.value;
                    input.style.color = 'transparent';
                    const picker = new CP(input, 'click', document.body);

                    input.onclick = function (e) {
                        e.preventDefault();
                    };

                    // Evitamos que salga el teclado virtual en iOS
                    input.onfocus = function (e) {
                        this.blur();
                    };

                    input.onchange = function (e) {
                        this.style.backgroundColor = this.value;
                    };

                    self.map.loaded(function () {
                        picker.on("change", function (color) {
                            self.setStrokeColor('#' + color);
                        });
                    });
                }
            }
            self.reset = true;
            self.callBack = null;
            self.measure = false;
            self._cancelClick = false;

            self.mode = self.options.mode || TC.Consts.geom.POLYLINE;

            if (self.options.measure)
                self.measure = self.options.measure
            if (TC.Util.isFunction(self.options.callback))
                self.callBack = self.options.callback;
            if (self.options.persistent === undefined) {
                self.persistent = true;
            }
            else {
                self.persistent = self.options.persistent;
            }

            self.wrap = new TC.wrap.control.Draw(self);

            self._newBtn = self.div.querySelector(self._classSelector + '-btn-new');
            self._newBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.new();
            });

            self._cancelBtn = self.div.querySelector(self._classSelector + '-btn-cancel');
            self._cancelBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.cancel();
            });

            self._endBtn = self.div.querySelector(self._classSelector + '-btn-end');
            self._endBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.end();
            });

            self._undoBtn = self.div.querySelector(self._classSelector + '-btn-undo');
            self._undoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.undo();
            });

            self._redoBtn = self.div.querySelector(self._classSelector + '-btn-redo');
            self._redoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.redo();
            });

            if (self.options.styleTools) {
                self._strokeColorPicker = self.div.querySelector(self._classSelector + '-str-c');
                self._strokeColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeColor(e.target.value);
                });

                self._strokeWidthSelector = self.div.querySelector(self._classSelector + '-str-w');
                self._strokeWidthSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeWidth(e.target.value);
                });
                self._strokeWidthWatch = self.div.querySelector(self._classSelector + '-str-w-watch');
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.map.on(TC.Consts.event.VIEWCHANGE, function () {
            if (self.map.view === TC.Consts.view.PRINTING) {
                self.end();

                // No lanzo el evento porque da error al no llegar una feature
                // self.trigger(TC.Consts.event.DRAWEND);
            }
        });

        self._layerPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                if (self.options.layer) {
                    self.setLayer(self.options.layer);
                    resolve(self.layer);
                }
                else {
                    // Si self.options.layer === false se instancia el control sin capa asociada
                    if (self.options.layer === false) {
                        self.setLayer(null);
                        resolve(null);
                    }
                    else {
                        map.addLayer({
                            id: self.getUID(),
                            title: 'DrawControl',
                            stealth: true,
                            owner: self,
                            type: TC.Consts.layerType.VECTOR,
                            styles: {
                                point: map.options.styles.point,
                                line: map.options.styles.line,
                                polygon: map.options.styles.polygon
                            }
                        }).then(function (layer) {
                            map.putLayerOnTop(layer);
                            self.setLayer(layer);
                            resolve(self.layer);
                        });
                    }
                }
            });
        });

        return result;
    };

    ctlProto.new = function () {
        var self = this;
        if (self.layer && !self.persistent) {
            self.layer.clearFeatures();
        }
        self._cancelBtn.disabled = false;
        self.setMode(self.mode, true);
        return self;
    };

    ctlProto.undo = function () {
        var self = this;
        var result = self.wrap.undo();
        if (result) {
            self.historyIndex--;
            setDrawState(self);

            if (self.historyIndex <= 0) {
                self.resetValues();
            }
            self.trigger(TC.Consts.event.DRAWUNDO);
        }

        return result;
    };

    ctlProto.redo = function () {
        var self = this;
        var result = this.wrap.redo();
        if (result) {
            self.historyIndex++;
            setDrawState(self);
            self.trigger(TC.Consts.event.DRAWREDO);
        }
        return result;
    };

    ctlProto.cancel = function () {
        var self = this;
        self._cancelClick = true;
        this.setMode(null, false);
        self.resetValues();
        setFeatureAddReadyState(self);
        self._cancelBtn.disabled = true;
        self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        return self;
    };

    ctlProto.activate = function () {
        var self = this;
        self._newBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._cancelBtn.disabled = false;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
        self.div.classList.remove(self._pointClass, self._lineClass, self._polygonClass);
        switch (self.mode) {
            case TC.Consts.geom.POINT:
                self.div.classList.add(self._pointClass);
                break;
            case TC.Consts.geom.POLYLINE:
                self.div.classList.add(self._lineClass);
                break;
            case TC.Consts.geom.POLYGON:
                self.div.classList.add(self._polygonClass);
                break;
            default:
                break;
        }

    };

    ctlProto.deactivate = function () {
        var self = this;
        if (self._newBtn) {
            self._newBtn.classList.remove(TC.Consts.classes.ACTIVE);
        }
        if (self._cancelBtn) {
            self._cancelBtn.disabled = true;
        }
        TC.Control.prototype.deactivate.call(self, !self._cancelClick);
        if (self.wrap) {
            self.wrap.deactivate();
        }
        self.resetValues();
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        self._cancelClick = false;
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        self.resetValues();
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        self.resetValues();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            //if (self.layer) {
                //self.layer.map.putLayerOnTop(self.layer);
            //}
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.setStyle = function (style) {
        const self = this;
        if (style) {
            self.style = TC.Util.extend(self.style, style);
        }
        else {
            switch (self.options.mode) {
                case TC.Consts.geom.POLYLINE:
                case TC.Consts.geom.MULTIPOLYLINE:
                    style = { line: self.styles.line };
                    break;
                case TC.Consts.geom.POLYGON:
                case TC.Consts.geom.MULTIPOLYGON:
                    style = { polygon: self.styles.polygon };
                    break;
                case TC.Consts.geom.POINT:
                case TC.Consts.geom.MULTIPOINT:
                    style = { point: self.styles.point };
                    break;
                default:
                    style = {};
                    break;
            }
        }
        if (self.isActive) {
            self.wrap.setStyle(style);
        }
    };

    ctlProto.getModeStyle = function(mode) {
        const self = this;
        mode = mode || self.options.mode;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                return self.styles.line;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                return self.styles.polygon;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                return self.styles.point;
            default:
                return null;
                break;
        }
    };

    ctlProto.setStrokeColorWatch = function (color) {
        const self = this;
        if (self.options.styleTools) {
            if (color === undefined) {
                color = self.getModeStyle().strokeColor;
            }
            const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (match && match.length) {
                color = '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
            }
            self._strokeColorPicker.value = color;
            if (!TC.browserFeatures.inputTypeColor()) {
                const input = self._strokeColorPicker;
                input.style.backgroundColor = color;
                input.blur();
            }
        }
        return self;
    };

    ctlProto.setStrokeColor = function (color) {
        const self = this;
        const style = self.getModeStyle();
        if (style) {
            style.strokeColor = color;
        }

        // Resetea el estilo
        if (self.isActive) {
            self.setStyle();
        }

        self.setStrokeColorWatch(color);
        self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeColor', value: color });
        return self;
    };

    ctlProto.setStrokeWidthWatch = function (width) {
        const self = this;
        if (self.options.styleTools) {
            if (width === undefined) {
                width = self.getModeStyle().strokeWidth;
            }
            width = parseInt(width, 10);
            if (width !== Number.NaN) {
                self._strokeWidthSelector.value = width;
                self._strokeWidthWatch.style.borderBottomWidth = width + 'px';
            }
        }
        return self;
    };

    ctlProto.setStrokeWidth = function(width) {
        const self = this;
        width = parseInt(width, 10);
        if (width !== Number.NaN) {
            const style = self.getModeStyle();
            if (style) {
                style.strokeWidth = width;
            }

            // Resetea el estilo
            if (self.isActive) {
                self.setStyle();
            }

            self.setStrokeWidthWatch(width);
            self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeWidth', value: width });
        }
        return self;
    };

    ctlProto.getLayer = function () {
        const self = this;
        if (self.layer) {
            return Promise.resolve(self.layer);
        }
        return this._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        const self = this;
        if (self.map) {
            if (typeof (layer) === "string") {
                self.layer = self.map.getLayer(layer);
            }
            else {
                self.layer = layer;
            }

            self.styles = {};
            const layerStyles = (self.layer && self.layer.styles) || TC.Cfg.styles;
            TC.Util.extend(true, self.styles, self.options.styles || layerStyles);

        }
    };

    ctlProto.resetValues = function () {
        const self = this;
        self.history.length = 0;
        self.historyIndex = 0;
        setDrawState(self);
        return self;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.getLayer().then(function (layer) {
            layer.importState(state.layer);
        });
    };
})();
TC.control = TC.control || {};

if (!TC.control.Measure) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Measure');
}

TC.control.DrawMeasureModify = function () {
    var self = this;

    TC.control.Measure.apply(self, arguments);

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]'
    };

    self.persistentDrawControls = true;

    self.renderPromise().then(function () {
        self._1stCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-1-t');
        self._2ndCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-2-t');
        self._1stCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-1-v');
        self._2ndCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-2-v');
        self._elevationText = self.div.querySelector('.tc-ctl-meas-val-coord-ele-t');
        self._elevationValue = self.div.querySelector('.tc-ctl-meas-val-coord-ele-v');
    });

};

TC.inherit(TC.control.DrawMeasureModify, TC.control.Measure);

(function () {
    var ctlProto = TC.control.DrawMeasureModify.prototype;

    ctlProto.CLASS = 'tc-ctl-dmm';

    var _dataKeys = {
        VALUE: 'tcValue'
    };

    var downloadDialog = null;


    TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';
    TC.Consts.event.FEATURESSELECT = TC.Consts.event.FEATURESSELECT || "featuresselect.tc";

    const elevationProfileCache = [];

    const getElevationProfileFromCache = function (feature) {
        return elevationProfileCache.filter(function (elm) {
            return elm.feature === feature;
        })[0];
    };

    const cacheElevationProfile = function (feature, data) {
        var result = getElevationProfileFromCache(feature);
        if (!result) {
            result = {
                feature: feature
            };
            elevationProfileCache.push(result);
        }
        result.data = data;
        return result;
    };

    const removeElevationProfileFromCache = function (feature) {
        const featIdx = elevationProfileCache.reduce(function (prev, cur, idx) {
            if (cur.feature === feature) {
                return idx;
            }
            return prev;
        }, -1);
        if (featIdx >= 0) {
            elevationProfileCache.splice(featIdx, 1);
        }
    };

    const clearElevationProfileCache = function () {
        elevationProfileCache.length = 0;
    };

    ctlProto.template = TC.apiLocation + "TC/templates/DrawMeasureModify.html";        

    ctlProto.render = function (callback) {
        const self = this;
        const promise = self._set1stRenderPromise(TC.control.Measure.prototype.render.call(self, function () {
            self._clearBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-clr');
            self._clearBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                TC.confirm(self.getLocaleString('deleteAll.confirm'), function () {
                    self.clear();
                });
            });
            self._downloadBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-dl');
            self._downloadBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showSketchDownloadDialog();
            });

            self._elevProfileBtn = self.div.querySelector('.tc-ctl-meas-prof-btn');
            self._elevProfileBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.elevationProfileActive ? self.deactivateElevationProfile() : self.activateElevationProfile();
            });

            if (!self.options.displayElevation) {
                self._elevProfileBtn.style.display = 'none';
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));

        const renderOptions = {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        };
        
        return promise;
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.control.Measure.prototype.register.call(self, map).then(function () {
                const pointDrawControlId = self.getUID();
                const modifyId = self.getUID();

                const elevationPromise = new Promise(function (resolve, reject) {
                    if (self.options.displayElevation) {
                        self.elevationProfileActive = true;
                        TC.loadJS(
                            !TC.tool || !TC.tool.Elevation,
                            TC.apiLocation + 'TC/tool/Elevation',
                            function () {
                                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                                self.elevation = new TC.tool.Elevation(elevationOptions);
                                resolve(self.elevation);
                            }
                        );
                    }
                    else if (self.map.elevation) {
                        self.elevation = self.map.elevation;
                        resolve(self.elevation);
                    }
                    else
                        resolve();
                });
                
                Promise.all([self.layerPromise, self.renderPromise(), elevationPromise]).then(function (objects) {
                    const layer = objects[0];
                    layer.title = self.getLocaleString('sketch');

                    self._modifyPromise = map.addControl('modify', {
                        id: modifyId,
                        div: self.div.querySelector('.' + self.CLASS + '-mod'),
                        layer: layer
                    });

                    self._modifyPromise.then(function (modify) {

                        self.modify = modify;
                        modify
                            .on(TC.Consts.event.FEATURESSELECT, function (e) {
                                if (self.resultsPanelChart && !e.features.some(function (feature) {
                                    return self.resultsPanelChart.currentFeature === feature;
                                })) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                const feature = e.features[e.features.length - 1];
                                if (feature) {
                                    self.showMeasures(self.getFeatureMeasureData(feature));
                                    const style = feature._originalStyle || feature.getStyle();
                                    switch (true) {
                                        case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                            self.displayMode(TC.Consts.geom.POLYGON);
                                            self.polygonDrawControl
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                            self.displayMode(TC.Consts.geom.POLYLINE);
                                            self.lineDrawControl
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            const profile = getElevationProfileFromCache(feature);
                                            if (profile) {
                                                self.resultsPanelChart.setCurrentFeature(feature);
                                                self.renderElevationChart(profile.data);
                                            }
                                            break;
                                        case TC.feature.Point && feature instanceof TC.feature.Point:
                                            self.displayMode(TC.Consts.geom.POINT);
                                            self.pointDrawControl
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        default:
                                            break;
                                    }
                                    self.modify
                                        .setFontColorWatch(style.fontColor)
                                        .setFontSizeWatch(style.fontSize);
                                }
                            })
                            .on(TC.Consts.event.FEATURESUNSELECT, function (e) {
                                const features = self.modify.getSelectedFeatures();
                                if (!features.length) {
                                    self.resetDrawWatches();
                                }
                                self.resetElevationProfile();
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.close();
                                }
                            })
                            .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                                if (e.layer === self.layer) {
                                    removeElevationProfileFromCache(e.feature);
                                    const setMeasures = function (feature) {
                                        const measureData = self.getFeatureMeasureData(feature);
                                        self.showMeasures(measureData);
                                        self.setFeatureMeasureData(feature);
                                    };
                                    setMeasures(e.feature);

                                    // Si es un punto metemos la elevación en la geometría (porque la mostramos en las medidas)
                                    if (self.options.displayElevation && TC.feature.Point && e.feature instanceof TC.feature.Point) {
                                        self.elevation.setGeometry({
                                            features: [e.feature],
                                            crs: self.map.crs
                                        }).then(function (features) {
                                            setMeasures(features[0]);
                                        });
                                    }

                                    const popups = self.map.getControlsByClass('TC.control.Popup');
                                    popups.forEach(function (pu) {
                                        if (pu.currentFeature === e.feature && pu.isVisible()) {
                                            pu.hide();
                                        }
                                    });
                                }
                            });

                        map
                            .on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                                const control = e.control;
                                if (control === self.modify) {
                                    self.resetDrawWatches();
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.setCurrentFeature(null);
                                        self.resultsPanelChart.close();
                                    }
                                }
                                else if (control === self.lineDrawControl) {
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.close();
                                    }
                                }
                            })
                            .on(TC.Consts.event.POPUP, function (e) {
                                // En líneas queremos mostrar el perfil en vez del popup
                                const feature = e.control.currentFeature;
                                if (TC.feature.Polyline && feature instanceof TC.feature.Polyline && self.layer.features.indexOf(feature) >= 0) {
                                    if (self.elevationProfileActive) {
                                        e.control.hide();
                                        if (self.resultsPanelChart) {
                                            self.resultsPanelChart.setCurrentFeature(feature);
                                        }
                                        const profile = getElevationProfileFromCache(feature);
                                        if (self.resultsPanelChart) {
                                            self.resultsPanelChart.currentFeature = feature;
                                            if (self.resultsPanelChart.isMinimized()) {
                                                self.resultsPanelChart.maximize();
                                            }
                                        }
                                        if (profile) {
                                            self.renderElevationChart(profile.data);
                                        }
                                        else {
                                            self.displayElevationProfile(feature.geometry);
                                        }
                                    }
                                }
                            })
                            .on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                                if (self.elevationChartData) {
                                    self.elevationChartData.coords = TC.Util.reproject(self.elevationChartData.coords, e.oldCrs, e.newCrs);
                                }
                            });

                    });

                    self._lineDrawControlPromise.then(function (lineDrawControl) {
                        lineDrawControl
                            .on(TC.Consts.event.DRAWSTART, function () {
                                //self.resetElevationProfile();
                                if (self.resultsPanelChart && self.resultsPanelChart.currentFeature) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                self.resetValues();
                            })
                            .on(TC.Consts.event.DRAWUNDO + ' ' + TC.Consts.event.DRAWREDO, function () {
                                const lineDrawControl = this;
                                self.displayElevationProfile(lineDrawControl.history.slice(0, lineDrawControl.historyIndex));
                            })
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.currentFeature = e.feature;
                                }
                            })
                            .on(TC.Consts.event.POINT, function (e) {
                                const lineDrawControl = this;
                                const coords = lineDrawControl.history.slice(0, lineDrawControl.historyIndex);
                                const lastCoord = coords[coords.length - 1];
                                if (lastCoord[0] !== e.point[0] || lastCoord[1] !== e.point[1]) {
                                    coords.push(e.point);
                                }
                                self.displayElevationProfile(coords);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._polygonDrawControlPromise.then(function (polygonDrawControl) {
                        polygonDrawControl
                            .on(TC.Consts.event.DRAWSTART, function () {
                                self.resetValues();
                            })
                            //.on(TC.Consts.event.DRAWEND, function (e) {
                            //    if (self.options.displayElevation) {
                            //        self.elevation.setGeometry({
                            //            features: [e.feature],
                            //            crs: self.map.crs
                            //        });
                            //    }
                            //})
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._pointDrawControlPromise = map.addControl('draw', {
                        id: pointDrawControlId,
                        div: self.div.querySelector('.' + TC.control.Measure.prototype.CLASS + '-point'),
                        mode: TC.Consts.geom.POINT,
                        persistent: self.persistentDrawControls,
                        styleTools: true,
                        layer: self.layer
                    });

                    self._pointDrawControlPromise.then(function (pointDrawControl) {

                        pointDrawControl.containerControl = self;
                        self.drawControls.push(pointDrawControl);
                        self.pointDrawControl = pointDrawControl;

                        self.resetValues();

                        pointDrawControl
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                const updateChanges = function (feat) {
                                    self.showMeasures({ coords: feat.geometry, units: map.wrap.isGeo() ? 'degrees' : 'm' });
                                    self.setFeatureMeasureData(feat);
                                };
                                updateChanges(e.feature);
                                if (self.options.displayElevation) {
                                    self.elevation.setGeometry({
                                        features: [e.feature],
                                        crs: self.map.crs
                                    }).then(function (features) {
                                        updateChanges(features[0]);
                                    })
                                }
                            })
                            .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                // Alerta de condición de carrera si no ponemos un timeout:
                                // 1- Se llama a cancel de un control Draw.
                                // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                // 4- Se llama a cancel desde aquí.
                                // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                setTimeout(function () {
                                    self.cancel();
                                }, 100);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                        // Desactivamos el método exportState que ya se encarga el control padre de ello
                        pointDrawControl.exportsState = false;
                    });

                    self.setMode(self.options.mode);

                    map
                        .on(TC.Consts.event.FEATUREADD, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                self.setFeatureMeasureData(feature);
                                
                                self._modifyPromise.then(function (modify) {
                                    modify.displayLabelText(feature.getStyle().label);
                                });
                                self._clearBtn.disabled = false;
                                self._downloadBtn.disabled = false;
                            }
                        })
                        .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                if (self.layer.features.length === 0) {
                                    self._clearBtn.disabled = true;
                                    self._downloadBtn.disabled = true;
                                    self.resetValues();
                                    clearElevationProfileCache();
                                }
                                else if (feature) {
                                    removeElevationProfileFromCache(feature);
                                }
                            }
                        })
                        .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                            const control = e.control;
                            if (control.setCurrentFeature) {
                                control.setCurrentFeature(null);
                            }
                        });

                    resolve(self);
                });

            }).catch(function (error) {
                reject(error);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self._activeMode = self.div.querySelector('.tc-ctl-meas-pt');
        }
        if (self.modify) {
            self.modify.div.classList.remove(TC.Consts.classes.COLLAPSED);
        }
        return TC.control.Measure.prototype.displayMode.call(self, mode);
    };

    ctlProto.setMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self.pointDrawControl.activate();
        }
        return TC.control.Measure.prototype.setMode.call(self, mode);
    };

    ctlProto.setFeatureMeasureData = function (feature) {
        const self = this;
        const data = {};
        switch (true) {
            case TC.feature.Point && feature instanceof TC.feature.Point:
                const firstCoordText = self._1stCoordText.innerHTML;
                const secondCoordText = self._2ndCoordText.innerHTML;
                const elevationText = self._elevationText.innerHTML;
                if (self._1stCoordValue.textContent.trim().length > 0 && self._2ndCoordValue.textContent.trim().length > 0) {
                    data.CRS = self.map.crs;
                    data[firstCoordText.substr(0, firstCoordText.indexOf(':'))] = parseFloat(self._1stCoordValue.dataset.value);
                    data[secondCoordText.substr(0, secondCoordText.indexOf(':'))] = parseFloat(self._2ndCoordValue.dataset.value);
                    if (elevationText) {
                        data[self.getLocaleString('ele')] = parseFloat(self._elevationValue.dataset.value);
                    }
                    feature.setData(data);
                }
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                if (self._len.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('2dLength')] = self._len.innerHTML;
                    feature.setData(data);
                }
                break;
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                if (self._area.innerHTML.trim() !== self.NOMEASURE && self._peri.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('area')] = self._area.innerHTML;
                    data[self.getLocaleString('2dPerimeter')] = self._peri.innerHTML;
                    feature.setData(data);
                }
                break;
            default:
                break;
        }
        return self;
    };

    ctlProto.getFeatureMeasureData = function (feature) {
        const self = this;
        const result = {
            units: 'm'
        };
        const measureOptions = {};
        if (self.map.wrap.isGeo()) {
            measureOptions.crs = TC.Cfg.utmCrs;
        }
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                result.area = feature.getArea(measureOptions);
                result.perimeter = feature.getLength(measureOptions);
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                result.length = feature.getLength(measureOptions);
                const profile = getElevationProfileFromCache(feature);
                if (profile) {
                    self.renderElevationChart(profile.data);
                }
                else {
                    self.displayElevationProfile(feature.geometry);
                }
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
                result.coords = feature.geometry;
                break;
            default:
                break;
        }
        return result;
    };

    ctlProto.showMeasures = function (options) {
        const self = this;
        TC.control.Measure.prototype.showMeasures.call(self, options);
        options = options || {};
        var units = options.units;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.coords) {
            var precision;
            var coord1, coord2;
            if (options.units === 'm') {
                precision = TC.Consts.METER_PRECISION;
                coord1 = options.coords[0];
                coord2 = options.coords[1];
                self._1stCoordText.innerHTML = 'x: ';
                self._2ndCoordText.innerHTML = 'y: ';
            }
            else {
                precision = TC.Consts.DEGREE_PRECISION;
                coord1 = options.coords[1];
                coord2 = options.coords[0];
                self._1stCoordText.innerHTML = 'lat: ';
                self._2ndCoordText.innerHTML = 'lon: ';
            }
            const factor = Math.pow(10, precision);
            const round = function (val) {
                return Math.round(val * factor) / factor;
            }
            self._1stCoordValue.innerHTML = TC.Util.formatNumber(coord1.toFixed(precision), locale);
            self._1stCoordValue.dataset.value = round(coord1);
            self._2ndCoordValue.innerHTML = TC.Util.formatNumber(coord2.toFixed(precision), locale);
            self._2ndCoordValue.dataset.value = round(coord2);
            if (options.coords.length > 2) {
                const elevation = Math.round(options.coords[2]);
                self._elevationText.innerHTML = self.getLocaleString('ele').toLowerCase() + ': ';
                self._elevationValue.innerHTML = TC.Util.formatNumber(elevation.toFixed(TC.Consts.METER_PRECISION), locale) + ' m';
                self._elevationValue.dataset.value = elevation;
            }
            else {
                self._elevationText.innerHTML = '';
                self._elevationValue.innerHTML = '';
                self._elevationValue.dataset.value = '';
            }
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        TC.control.Measure.prototype.resetValues.call(self);

        if (self._1stCoordText) {
            self._1stCoordText.innerHTML = self.NOMEASURE;
            self._2ndCoordText.innerHTML = '';
            self._1stCoordValue.innerHTML = '';
            self._1stCoordValue.dataset.value = '';
            self._2ndCoordValue.innerHTML = '';
            self._2ndCoordValue.dataset.value = '';
            self._elevationText.innerHTML = '';
            self._elevationValue.innerHTML = '';
            self._elevationValue.dataset.value = '';
        }
        return self;
    };

    ctlProto.resetDrawWatches = function () {
        const self = this;
        self.drawControls.forEach(function (ctl) {
            ctl
                .setStrokeColorWatch()
                .setStrokeWidthWatch();
        });
    };

    ctlProto.clear = function () {
        const self = this;
        self.resetValues();
        self.layer.clearFeatures();
        if (self.modify.isActive) {
            self.modify.deactivate();
        }
        if (self.options.displayElevation) {
            self.resetElevationProfile();
            if (self.resultsPanelChart) {
                self.resultsPanelChart.close();
            }
        }
        self._clearBtn.disabled = true;
        self._downloadBtn.disabled = true;
        return self;
    };

    ctlProto.showSketchDownloadDialog = function (options) {
        const self = this;

        new Promise(function (resolve, reject) {
            if (!downloadDialog) {
                self.map.addControl('FeatureDownloadDialog').then(ctl => {
                    downloadDialog = ctl;
                    resolve(downloadDialog);
                });
            }
            else {
                resolve(downloadDialog);
            }
        }).then(function (control) {
            var options = {
                title: self.getLocaleString("downloadSketch"),
                fileName: self.getLocaleString('sketch').toLowerCase().replace(' ', '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true)
            };

            //const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog');
            const hasPoints = self.layer.features.some(function (feature) {
                return (TC.feature.Point && feature instanceof TC.feature.Point) ||
                    (TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint);
            });
            const hasLines = self.layer.features.some(function (feature) {
                return (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
                    (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
            });
            const hasPolygons = self.layer.features.some(function (feature) {
                return (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
                    (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);
            });
            //si solo hay poligonos ocultamos el botón de formato GPX
            if (!hasPoints && !hasLines && hasPolygons)
                options = Object.assign({}, options, { excludedFormats: ["GPX"] })

            //si el control tiene su propia configurtación de elevacion la pasamos para que sobrescriba  a la del mapa
            if (self.options.displayElevation !== true)
                options = Object.assign({}, options, { elevation: Object.assign({}, self.map.elevation && self.map.elevation.options, self.options.displayElevation) });
            else
                options = Object.assign({}, options, { elevation: self.map.elevation && self.map.elevation.options });

            control.open(self.layer.features, options);
            
        });
        return self;
        
    };

    ctlProto.onStyleChange = function (e) {
        const self = this;
        var featureCtor;
        switch (e.target.mode) {
            case TC.Consts.geom.POLYGON:
                featureCtor = TC.feature.Polygon;
                break;
            case TC.Consts.geom.POLYLINE:
                featureCtor = TC.feature.Polyline;
                break;
            case TC.Consts.geom.POINT:
                featureCtor = TC.feature.Point;
                break;
            default:
                break;
        }
        if (featureCtor) {
            self.modify.getSelectedFeatures().forEach(function (feature) {
                if (feature instanceof featureCtor) {
                    const styleOptions = {};
                    styleOptions[e.property] = e.value;
                    //feature._originalStyle[e.property] = e.value;
                    feature.setStyle(styleOptions);
                    //clearTimeout(feature._selectionStyleTimeout);
                    //feature._selectionStyleTimeout = setTimeout(function () {
                    //    feature.setStyle(self.modify.styleFunction(feature));
                    //}, self.options.styleChangeDisplayTimeout || 1000);
                }
            });
        }
    }

    ctlProto.displayElevationProfile = function (coords) {
        const self = this;
        if (coords.length === 1) {
            // Espera una línea, metemos un segundo punto
            coords = coords.slice();
            coords.push(coords[0]);
        }
        const li = self.map.getLoadingIndicator();
        const waitId = li && li.addWait();
        self.elevation.getElevation({
            crs: self.map.crs,
            coordinates: coords,
            partialCallback: function (elevCoords) {
                li && li.removeWait(waitId);
                var distance = 0.0;
                var maxElevation = Number.NEGATIVE_INFINITY;
                var minElevation = Number.POSITIVE_INFINITY;
                const profile = elevCoords
                    .map(function (point, idx, arr) {
                        const prev = idx === 0 ? point : arr[idx - 1];
                        const dx = point[0] - prev[0];
                        const dy = point[1] - prev[1];
                        distance += Math.sqrt(dx * dx + dy * dy);
                        var ele = point[2];
                        if (typeof ele === 'number') {
                            maxElevation = Math.max(ele, maxElevation);
                            minElevation = Math.min(ele, minElevation);
                        }
                        return [distance, ele];
                    });

                self.elevationChartData = {
                    x: profile.map(function (elm) {
                        return elm[0];
                    }),
                    ele: profile.map(function (elm) {
                        return elm[1];
                    }),
                    coords: elevCoords
                };
                const elevationGainOptions = {
                    coords: elevCoords
                };
                if (typeof self.options.displayElevation === 'object') {
                    elevationGainOptions.hillDeltaThreshold = self.options.displayElevation.hillDeltaThreshold;
                }
                TC.Util.extend(self.elevationChartData, TC.tool.Elevation.getElevationGain(elevationGainOptions));

                // Cacheamos el perfil
                const matchingFeature = self.layer.features
                    .filter(function (feat) {
                        return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
                    })
                    .filter(function (line) {
                        for (var i = 0, len = line.geometry.length; i < len; i++) {
                            const coord = coords[i];
                            const lineCoord = line.geometry[i];
                            if (!coord || coord[0] !== lineCoord[0] || coord[1] !== lineCoord[1]) {
                                return false;
                            }
                        }
                        return true;
                    })[0];
                if (matchingFeature) {
                    cacheElevationProfile(matchingFeature, self.elevationChartData);
                }

                if (self.resultsPanelChart) {
                    self.renderElevationChart();
                }
                else {
                    self.createChartPanel().then(function (resultsPanelChart) {
                        self.resultsPanelChart.renderPromise().then(function () {
                            self.renderElevationChart();
                        });
                    });
                }
            }
        }).catch(function (error) {
            self.resetElevationProfile();
            li && li.removeWait(waitId);
        });
    };

    ctlProto.createChartPanel = function () {
        const self = this;

        const resultsPanelOptions = {
            id: self.getUID(),
            content: "chart",
            titles: {
                main: self.getLocaleString("geo.trk.chart.chpe"),
                max: self.getLocaleString("geo.trk.chart.chpe")
            },
            chart: {
                ctx: self,
                onmouseout: ctlProto.removeElevationTooltip,
                tooltip: ctlProto.getElevationTooltip
            }
        };

        return new Promise(function (resolve, reject) {
            var addControlPromise;
            const addResultsPanelChart = function (controlContainer) {
                resultsPanelOptions.position = controlContainer.POSITION.RIGHT;
                addControlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
            };

            if (self.options.displayElevation.displayOn) {
                var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayElevation.displayOn[0].toUpperCase() + self.options.displayElevation.displayOn.substring(1))[0];
                if (!controlContainer) {
                    self.map.addControl(self.options.displayElevation.displayOn).then(addResultsPanelChart);
                } else {
                    addResultsPanelChart(controlContainer);
                }
            } else {
                resultsPanelOptions.div = document.createElement('div');
                self.map.div.appendChild(resultsPanelOptions.div);
                addControlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
            }

            addControlPromise.then(function (resultsPanelChart) {
                resultsPanelChart.caller = self;
                self.resultsPanelChart = resultsPanelChart;
                self._decorateChartPanel();
                resolve(resultsPanelChart);
            });
        });
    };

    ctlProto._decorateChartPanel = function () {
        const self = this;
        self.resultsPanelChart.setCurrentFeature = function (feature) {
            const that = this;
            if (that.currentFeature) {
                that.currentFeature.toggleSelectedStyle(false);
            }
            that.currentFeature = feature;
            if (feature) {
                feature.toggleSelectedStyle(true);
            }
        };
    };

    ctlProto.renderElevationChart = function (profileData) {
        const self = this;
        self.elevationChartData = profileData || self.elevationChartData;
        if (self.resultsPanelChart && self.elevationProfileActive) {
            self.resultsPanelChart.caller = self;
            self.resultsPanelChart.openChart(self.elevationChartData);
            if (!self.resultsPanelChart.isMinimized()) {
                self.resultsPanelChart.show();
            }
        }
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.resultsPanelChart.wrap.showElevationMarker({
            data: d,
            layer: self.layer,
            coords: self.elevationChartData.coords
        });

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.resultsPanelChart.wrap.hideElevationMarker();
    }

    ctlProto.activateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = true;
        self._elevProfileBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('deactivateElevationProfile'));
        var profileDrawn = false;
        if (self.lineDrawControl.historyIndex > 1) {
            self.displayElevationProfile(self.lineDrawControl.history.slice(0, self.lineDrawControl.historyIndex));
            profileDrawn = true;
        }
        else {
            const features = self.modify.getActiveFeatures().filter(function (feat) {
                return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
            });
            if (features.length) {
                const feature = features[features.length - 1];
                self.displayElevationProfile(feature.geometry);
                profileDrawn = true;
            }
        }
        if (!profileDrawn) {
            self.resetElevationProfile();
        }
        if (self.resultsPanelChart) {
            self.resultsPanelChart.show();
        }
    };

    ctlProto.deactivateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = false;
        self._elevProfileBtn.classList.remove(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('activateElevationProfile'));
        self.resetElevationProfile();
        if (self.resultsPanelChart) {
            self.resultsPanelChart.close();
        }
    };

    ctlProto.resetElevationProfile = function () {
        const self = this;
        if (self.options.displayElevation && self.resultsPanelChart) {
            self.elevationChartData = {
                x: [0],
                ele: [0],
                coords: [0, 0, 0],
                upHill: 0,
                downHill: 0
            };
            self.resultsPanelChart.openChart(self.elevationChartData);
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    const setEditState = function (ctl, state) {
        ctl.div.querySelectorAll(ctl._selectors.MODE_RADIO_BUTTON).forEach(r => r.disabled = !state);
    }

    /* Creamos el constructor, llamando al constructor del padre */
    TC.control.Edit = function () {
        const self = this;

        TC.Control.apply(this, arguments);

        self._classSelector = '.' + self.CLASS;

        self._selectors = {
            MODE_RADIO_BUTTON: 'input[type=radio][name=mode]'
        };


        self.wrap = new TC.wrap.control.Edit(self);
        self.layer = null;
        //self.feature = self.options.feature ? self.options.feature : null;
        self.callback = TC.Util.isFunction(arguments[2]) ? arguments[2] : (self.options.callback ? self.options.callback : null);
        self.cancelActionConfirmTxt = self.options.cancelText ? self.options.eraseText : "Si continua todos los cambios se perderán. ¿Desea continuar?";
        self.styles = self.options.styles;
        self.layersEditData = {};
        self.pointDrawControl = null;
        self.lineDrawControl = null;
        self.polygonDrawControl = null;
        //self.cutDrawControl = null;
        self.modifyControl = null;
        self.snapping = (typeof self.options.snapping === 'boolean') ? self.options.snapping : true;


            //.on(TC.Consts.event.EDITIONSAVE, function (e) {
            //    if (self.callback)
            //        self.callback(e.added, e.removed, e.modified);
            //});
    };

    TC.inherit(TC.control.Edit, TC.Control);

    TC.control.Edit.mode = {
        MODIFY: 'modify',
        ADDPOINT: 'addpoint',
        ADDLINE: 'addline',
        ADDPOLYGON: 'addpolygon',
        CUT: 'cut',
        OTHER: 'other'
    }

    const ctlProto = TC.control.Edit.prototype;

    ctlProto.CLASS = 'tc-ctl-edit';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Edit.html";
    ctlProto.template[ctlProto.CLASS + '-attr'] = TC.apiLocation + "TC/templates/EditAttributes.html";
    ctlProto.template[ctlProto.CLASS + '-import'] = TC.apiLocation + "TC/templates/EditImport.html";
    ctlProto.template[ctlProto.CLASS + '-import-layer'] = TC.apiLocation + "TC/templates/EditImportLayer.html";
    ctlProto.template[ctlProto.CLASS + '-import-feature'] = TC.apiLocation + "TC/templates/EditImportFeature.html";

    /* Extendemos el método register. 
       La lógica del control suele definirse aquí. */
    ctlProto.register = function (map) {
        const self = this;

        return new Promise(function (resolve, reject) {

            TC.Control.prototype.register.call(self, map).then(function () {

                const DRAW = 'draw';
                self._pointDrawCtlPromise = map.addControl(DRAW, {
                    id: self.getUID(),
                    div: self.div.querySelector(`.${self.CLASS}-point`),
                    mode: TC.Consts.geom.POINT,
                    layer: false
                });
                self._lineDrawCtlPromise = map.addControl(DRAW, {
                    id: self.getUID(),
                    div: self.div.querySelector(`.${self.CLASS}-line`),
                    mode: TC.Consts.geom.POLYLINE,
                    layer: false
                });
                self._polygonDrawCtlPromise = map.addControl(DRAW, {
                    id: self.getUID(),
                    div: self.div.querySelector(`.${self.CLASS}-polygon`),
                    mode: TC.Consts.geom.POLYGON,
                    layer: false
                });
                //self._cutDrawCtlPromise = map.addControl(DRAW, {
                //    id: self.getUID(),
                //    div: self.div.querySelector(`.${self.CLASS}-cut`),
                //    mode: TC.Consts.geom.POLYLINE,
                //    snapping: true,
                //    styles: {
                //        line: {
                //            lineDash: [5, 5]
                //        }
                //    },
                //    layer: false
                //});
                self._modifyCtlPromise = map.addControl('modify', {
                    id: self.getUID(),
                    div: self.div.querySelector(`.${self.CLASS}-modify`),
                    snapping: self.snapping
                });
                Promise.all([
                    self._pointDrawCtlPromise,
                    self._lineDrawCtlPromise,
                    self._polygonDrawCtlPromise,
                    //self._cutDrawCtlPromise,
                    self._modifyCtlPromise
                ]).then(function (controls) {
                    self.pointDrawControl = controls[0];
                    self.lineDrawControl = controls[1];
                    self.polygonDrawControl = controls[2];
                    //self.cutDrawControl = controls[3];
                    self.modifyControl = controls[3];

                    const drawendHandler = function (e) {
                        e.feature.setStyle(null); // Por defecto, Draw añade estilo a todo lo que dibuja. No nos conviene cuando está dentro de Edit.
                        self.trigger(TC.Consts.event.DRAWEND, { feature: e.feature });
                    };
                    const drawcancelHandler = function () {
                        self.cancel();
                    };
                    self.pointDrawControl
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.lineDrawControl
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.polygonDrawControl
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    //self.cutDrawControl
                    //    .on(TC.Consts.event.DRAWEND, function (e) {
                    //        //TC.loadJS(
                    //        //    !window.turf && !turf.lineSplit,
                    //        //    [TC.apiLocation + 'lib/turf/line-split'],
                    //        //    function () {

                    //        //    }
                    //        //);

                    //        //self.layer.features.filter(f => f)
                    //    })
                    //    .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.modifyControl
                        .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                            self.trigger(TC.Consts.event.FEATUREMODIFY, { feature: e.feature, layer: e.layer });
                        })
                        .on(TC.Consts.event.FEATUREADD, function (e) {
                            self.trigger(TC.Consts.event.FEATUREADD, { feature: e.feature, layer: e.layer });
                        })
                        .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                            self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: e.feature, layer: e.layer });
                        });

                    self.modifyControl.displayAttributes = function () {
                        const selectedFeatures = self.getSelectedFeatures();
                        const feature = selectedFeatures[selectedFeatures.length - 1];
                        if (feature) {
                            self.modifyControl._editAttrBtn.classList.add(TC.Consts.classes.ACTIVE);
                            const attributes = self.getLayerEditData(feature.layer).attributes;
                            const attrArray = Object.keys(attributes).map(k => attributes[k]);
                            const jfa = self._joinedFeatureAttributes || [];
                            const data = feature.getData() || {};

                            attrArray.forEach(function (attributeObj) {
                                attributeObj.value = data[attributeObj.name];
                                if (attributeObj.name === 'id') {
                                    attributeObj.readOnly = true;
                                }
                                attributeObj.availableValues = [];
                                jfa.forEach(function (jfaObj) {
                                    const val = jfaObj[attributeObj.name];
                                    if (val !== undefined && val !== '') {
                                        attributeObj.availableValues[attributeObj.availableValues.length] = val;
                                    }
                                });
                            });

                            attrArray.sort(function (a, b) {
                                if (a.readOnly ? !b.readOnly : b.readOnly) { //XOR
                                    return !a.readOnly - !b.readOnly; // Primero readOnly
                                }
                                if (a.name > b.name) {
                                    return 1;
                                }
                                if (a.name < b.name) {
                                    return -1;
                                }
                                return 0;
                            });
                            self.getRenderedHtml(self.CLASS + '-attr', { data: attrArray }, function (html) {
                                self.modifyControl._attributesSection;
                                const contentDiv = self.getAttributeDisplayTarget();
                                contentDiv.classList.remove(TC.Consts.classes.HIDDEN);
                                contentDiv.innerHTML = html;
                                const inputs = contentDiv.querySelectorAll('input');
                                const selects = contentDiv.querySelectorAll('select');
                                inputs.forEach(function (elm) {
                                    elm.addEventListener('input', function (e) {
                                        const input = e.target;
                                        for (var i = 0, len = selects.length; i < len; i++) {
                                            const select = selects[i];
                                            if (select.matches(`[name=${e.target.getAttribute('name')}]`) && select.value !== input.value) {
                                                select.value = '';
                                                break;
                                            }
                                        }
                                    });
                                });
                                selects.forEach(function (elm) {
                                    elm.addEventListener('change', function (e) {
                                        const select = e.target;
                                        for (var i = 0, len = inputs.length; i < len; i++) {
                                            const input = inputs[i];
                                            if (input.matches(`[name=${e.target.getAttribute('name')}]`)) {
                                                input.value = select.value;
                                                break;
                                            }
                                        }
                                    });
                                });

                                contentDiv.querySelector(`.${self.modifyControl.CLASS}-btn-attr-ok`).addEventListener(TC.Consts.event.CLICK, function (e) {
                                    self.modifyControl._onAttrOK();
                                });

                                contentDiv.querySelector(`.${self.modifyControl.CLASS}-btn-attr-cancel`).addEventListener(TC.Consts.event.CLICK, function () {
                                    self.modifyControl.closeAttributes();
                                });
                            });
                        }
                    };

                    self.modifyControl._onAttrOK = function () {
                        const that = this;
                        const feature = that.getSelectedFeatures()[0];
                        if (feature) {
                            const data = {};
                            const attributes = self.getLayerEditData(feature.layer).attributes;
                            const inputs = that.getAttributeDisplayTarget().querySelectorAll('input');
                            inputs.forEach(function (input) {
                                var name = input.getAttribute('name');
                                var value = input.value;
                                switch (attributes[name].type) {
                                    case 'int':
                                    case 'integer':
                                    case 'byte':
                                    case 'long':
                                    case 'negativeInteger':
                                    case 'nonNegativeInteger':
                                    case 'nonPositiveInteger':
                                    case 'positiveInteger':
                                    case 'short':
                                    case 'unsignedLong':
                                    case 'unsignedInt':
                                    case 'unsignedShort':
                                    case 'unsignedByte':
                                        value = parseInt(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'double':
                                    case 'float':
                                    case 'decimal':
                                        value = parseFloat(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'date':
                                    case 'time':
                                    case 'dateTime':
                                        data[name] = new Date(value);
                                        break;
                                    case 'boolean':
                                        data[name] = !!value;
                                        break;
                                    case undefined:
                                        break;
                                    default:
                                        data[name] = value;
                                        break;
                                }
                            });
                            feature.setData(data);
                            that.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature, layer: that.layer });
                            that.closeAttributes();
                        }
                    };

                    if (Array.isArray(self.options.modes) && self.options.modes.length == 1) {
                        self.setMode(self.options.modes[0], null);
                    }

                    resolve(self);

                    map.loaded(function () {
                        self.setLayer(self.options.layer);
                    });

                    map
                        .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                            if (e.control === self.featureImportPanel) {
                                self.featuresToImport = [];
                                self.getHighlightsLayer().then(l => l.clearFeatures());
                            }
                        })
                        .on(TC.Consts.event.LAYERREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                            if (self.featureImportPanel && !self.featureImportPanel.div.classList.contains(TC.Consts.classes.HIDDEN)) {
                                self.getHighlightsLayer().then(function (hlLayer) {
                                    for (let i = self.featuresToImport.length - 1; i >= 0; i--) {
                                        const fti = self.featuresToImport[i];
                                        if (fti.layer === e.layer || (fti.original && fti.original.layer === e.layer)) {
                                            self.featuresToImport.splice(i, 1);
                                            hlLayer.removeFeature(fti);
                                        }
                                    }
                                    const li = self.featureImportPanel.getInfoContainer().querySelector(`li[data-layer-id="${e.layer.id}"]`);
                                    if (li) {
                                        li.remove();
                                    }
                                });
                            }
                        })
                        .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                            if (self.featureImportPanel && !self.featureImportPanel.div.classList.contains(TC.Consts.classes.HIDDEN)) {
                                self.getHighlightsLayer().then(function (hlLayer) {
                                    for (let i = 0, ii = self.featuresToImport.length; i < ii; i++) {
                                        const fti = self.featuresToImport[i];
                                        if (fti === e.feature || fti.original === e.feature) {
                                            self.featuresToImport.splice(i, 1);
                                            hlLayer.removeFeature(fti);
                                            const lli = self.featureImportPanel.getInfoContainer().querySelector(`li[data-layer-id="${e.layer.id}"]`);
                                            if (lli) {
                                                const fli = lli.querySelector(`#tc-ctl-edit-import-list-cb-${e.layer.id}-${e.feature.id}`);
                                                if (fli) {
                                                    fli.remove();
                                                }
                                                if (!lli.children.length) {
                                                    lli.remove();
                                                }
                                            }
                                            break;
                                        }
                                    }
                                });
                            }
                        })
                        .on(TC.Consts.event.LAYERUPDATE, function (e) { // TODO: Actualizar cuando la capa ya existe en la lista
                            if (self.featureImportPanel && !self.featureImportPanel.div.classList.contains(TC.Consts.classes.HIDDEN)) {
                                const layerObj = self.getAvailableFeaturesToImport().filter(l => l.id === e.layer.id)[0];
                                if (layerObj) {
                                    self.getRenderedHtml(self.CLASS + '-import-layer', layerObj, function (html) {
                                        const list = self
                                            .featureImportPanel
                                            .getInfoContainer()
                                            .querySelector(`.${self.CLASS}-import-list .tc-layers`);
                                        if (!list.querySelector(`li[data-layer-id="${e.layer.id}"]`)) {
                                            list.insertAdjacentHTML('beforeend', html);
                                        }
                                    });
                                }
                            }
                        })
                        .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                            if (self.featureImportPanel && !self.featureImportPanel.div.classList.contains(TC.Consts.classes.HIDDEN)) {
                                const layer = e.layer;
                                const features = (e.feature ? [e.feature] : e.features).filter(f => self.isFeatureAllowed(f));
                                if (features.length) {
                                    self.displayLayerToImport({
                                        id: layer.id,
                                        title: layer.title,
                                        features: features
                                    });
                                }
                            }
                        });
                });
            });
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(TC.Control.prototype.render.call(self, function () {

            //control de renderizado enfunción del modo de edicion
            if (Array.isArray(self.options.modes) && self.options.modes.length > 0) {
                for (var m in TC.control.Edit.mode)
                    if (typeof m === 'string' && self.options.modes.indexOf(TC.control.Edit.mode[m]) < 0) {
                        const label = self.div.querySelector(`label${self._classSelector}-btn-${TC.control.Edit.mode[m]}`);
                        label.parentElement.removeChild(label);
                        const div = self.div.querySelector(`div${self._classSelector}-${TC.control.Edit.mode[m]}`);
                        div.parentElement.removeChild(div);
                    }
                if (self.options.modes.length === 1) {
                    var mode = self.options.modes[0];
                    const label = self.div.querySelector(`label${self._classSelector}-btn-${mode}`);
                    label.parentElement.removeChild(label);
                }
            }

            self.div.querySelectorAll(self._selectors.MODE_RADIO_BUTTON).forEach(function (radio) {
                radio.addEventListener('change', function () {
                    var newMode = this.value;
                    var mode = self.mode === newMode ? undefined : newMode;
                    self.setMode(mode);
                });
            });

            self.div.querySelector(self._classSelector + '-btn-import').addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showFeatureImportPanel();
            });

            self.div.querySelector(self._classSelector + '-btn-dl').addEventListener(TC.Consts.event.CLICK, function (e) {
                self.getDownloadDialog().then(function (dialog) {
                    const options = {
                        title: self.getLocaleString('download'),
                        fileName: self.layer.id.toLowerCase().replace(' ', '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true),
                        elevation: self.options.downloadElevation
                    };
                    dialog.open(self.layer.features, options);
                });
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.getGeometryType = function (geometryType) {
        switch (geometryType) {
            case 'gml:LinearRingPropertyType':
            case 'gml:PolygonPropertyType':
            case 'LinearRingPropertyType':
            case 'PolygonPropertyType':
                return TC.Consts.geom.POLYGON;
            case 'gml:MultiPolygonPropertyType':
            case 'gml:MultiSurfacePropertyType':
            case 'MultiPolygonPropertyType':
            case 'MultiSurfacePropertyType':
                return TC.Consts.geom.MULTIPOLYGON;
            case 'gml:LineStringPropertyType':
            case 'gml:CurvePropertyType':
            case 'LineStringPropertyType':
            case 'CurvePropertyType':
                return TC.Consts.geom.POLYLINE;
            case 'gml:MultiLineStringPropertyType':
            case 'gml:MultiCurvePropertyType':
            case 'MultiLineStringPropertyType':
            case 'MultiCurvePropertyType':
                return TC.Consts.geom.MULTIPOLYLINE;
            case 'gml:PointPropertyType':
            case 'gml:MultiPointPropertyType':
            case 'PointPropertyType':
            case 'MultiPointPropertyType':
                return TC.Consts.geom.POINT;
            case 'gml:BoxPropertyType':
            case 'BoxPropertyType':
                return TC.Consts.geom.RECTANGLE;
            case 'gml:GeometryCollectionPropertyType':
            case 'gml:GeometryAssociationType':
            case 'gml:GeometryPropertyType':
            case 'GeometryCollectionPropertyType':
            case 'GeometryAssociationType':
            case 'GeometryPropertyType':
                return true;
            default:
                return false;
        }

    };

    ctlProto.setLayer = function (layer) {
        const self = this;
        self.layer = self.map.getLayer(layer);
        if (self.layer) {
            layer.describeFeatureType()
                .then(function (attributes) {
                    const layerEditData = {
                        attributes: {}
                    };
                    // recogemos los atributos no geométricos y definimos la geometría
                    for (var key in attributes) {
                        const attr = attributes[key];
                        const geometryType = self.getGeometryType(attr.type);
                        if (geometryType) {
                            layerEditData.geometryName = attr.name;
                            layerEditData.geometryType = typeof geometryType === 'boolean' ? null : geometryType;
                        }
                        else {
                            layerEditData.attributes[key] = attr;
                        }
                    }
                    for (var key in layerEditData.attributes) {
                        const attr = layerEditData.attributes[key];
                        attr.type = attr.type.substr(attr.type.indexOf(':') + 1);
                    }
                    self.layersEditData[layer.id] = layerEditData;
                })
                .catch(function (err) {
                    self.layersEditData[layer.id] = {
                        geometryType: null,
                        attributes: {}
                    };
                });
        }
        const setLayer = c => c.setLayer(self.layer);
        self.getModifyControl().then(setLayer);
        self.getPointDrawControl().then(setLayer);
        self.getLineDrawControl().then(setLayer);
        self.getPolygonDrawControl().then(setLayer);
        //self.getCutDrawControl().then(setLayer);
        self.setMode(self.layer ? TC.control.Edit.mode.MODIFY : null);
        setEditState(self, self.layer);
    };

    ctlProto.setMode = function (mode) {
        var self = this;
        self.mode = mode;
        //setFeatureSelectReadyState(self);

        var activateDraw = function (draw) {
            if (draw) {
                if (self.snapping) {
                    draw.snapping = self.layer;
                }
                draw.activate();
            }
        };

        var active;
        var hiddenList;
        Promise.all([
            self._pointDrawCtlPromise,
            self._lineDrawCtlPromise,
            self._polygonDrawCtlPromise,
            //self._cutDrawCtlPromise,
            self._modifyCtlPromise
        ]).then(function (controls) {
            const pointDrawControl = controls[0];
            const lineDrawControl = controls[1];
            const polygonDrawControl = controls[2];
            //const cutDrawControl = controls[3];
            const modifyControl = controls[3];
            switch (mode) {
                case TC.control.Edit.mode.MODIFY:
                    active = self.div.querySelector(self._classSelector + '-modify');
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon,' + self._classSelector + '-other');
                    modifyControl.activate();
                    break;
                case TC.control.Edit.mode.ADDPOINT:
                    active = self.div.querySelector(self._classSelector + '-point');
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-modify,' + self._classSelector + '-line,' + self._classSelector + '-polygon,' + self._classSelector + '-other');
                    activateDraw(pointDrawControl);
                    break;
                case TC.control.Edit.mode.ADDLINE:
                    active = self.div.querySelector(self._classSelector + '-line');
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-modify,' + self._classSelector + '-point,' + self._classSelector + '-polygon,' + self._classSelector + '-other');
                    activateDraw(lineDrawControl);
                    break;
                case TC.control.Edit.mode.ADDPOLYGON:
                    active = self.div.querySelector(self._classSelector + '-polygon');
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-modify,' + self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-other');
                    activateDraw(polygonDrawControl);
                    break;
                case TC.control.Edit.mode.OTHER:
                    active = self.div.querySelector(self._classSelector + '-other');
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-modify,' + self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                    if (controls.indexOf(self.map.activeControl) >= 0) {
                        self.map.activeControl.deactivate();
                    }
                    break;
                default:
                    active = null;
                    hiddenList = self.div.querySelectorAll(self._classSelector + '-modify,' + self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon,' + self._classSelector + '-other');
                    if (controls.indexOf(self.map.activeControl) >= 0) {
                        self.map.activeControl.deactivate();
                    }
                    //if (cutDrawControl.isActive) {
                    //    cutDrawControl.deactivate();
                    //}
                    break;
            }

            if (mode) {
                const radio = self.div.querySelector(`${self._selectors.MODE_RADIO_BUTTON}[value=${mode}]`);
                radio.checked = true;
            }
            else {
                self.div.querySelectorAll(self._selectors.MODE_RADIO_BUTTON).forEach(function (radio) {
                    radio.checked = false;
                });
            }
            if (active) {
                active.classList.remove(TC.Consts.classes.HIDDEN);
            }
            hiddenList.forEach(function (hidden) {
                hidden.classList.add(TC.Consts.classes.HIDDEN);
            });
        });
    };

    ctlProto.constrainModes = function (modes) {
        const self = this;
        if (!Array.isArray(modes)) {
            modes = [];
        }
        self.modes = modes
            .filter(function (m) {
                // Quitamos los valores que no sean modos de edición
                for (var key in TC.control.Edit.mode) {
                    if (TC.control.Edit.mode[key] === m) {
                        return true;
                    }
                }
                return false;
            })
            .filter(function (m) {
                // Quitamos los modos de edición que no se definieron en la configuración
                if (!Array.isArray(self.options.modes)) {
                    return true;
                }
                return self.options.modes.indexOf(m) >= 0;
            });
        if (self.modes.indexOf(self.mode) < 0) {
            self.setMode(null);
        }
        const selector = self.modes.map(m => `[value=${m}]`).join() || '[value]';
        self.div.querySelectorAll(self._selectors.MODE_RADIO_BUTTON).forEach(function (rb) {
            rb.disabled = !rb.matches(selector);
        });
    };

    ctlProto.isFeatureAllowed = function (feature) {
        const self = this;
        switch (true) {
            case TC.feature.Point && feature instanceof TC.feature.Point:
                return self.modes.indexOf(TC.control.Edit.mode.ADDPOINT) >= 0;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                return self.modes.indexOf(TC.control.Edit.mode.ADDLINE) >= 0;
            case TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:
                return self.modes.indexOf(TC.control.Edit.mode.ADDLINE) >= 0 && self.isMultiple;
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                return self.modes.indexOf(TC.control.Edit.mode.ADDPOLYGON) >= 0;
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                return self.modes.indexOf(TC.control.Edit.mode.ADDPOLYGON) >= 0 && self.isMultiple;
            default:
                return true;
        }
    };

    ctlProto.setComplexGeometry = function (isMultiple) {
        const self = this;
        self.isMultiple = isMultiple;
        //self.getPointDrawControl().then(c => c.setMode(isMultiple ? TC.Consts.geom.MULTIPOINT : TC.Consts.geom.POINT));
        self.getLineDrawControl().then(c => c.setMode(isMultiple ? TC.Consts.geom.MULTIPOLYLINE : TC.Consts.geom.POLYLINE));
        self.getPolygonDrawControl().then(c => c.setMode(isMultiple ? TC.Consts.geom.MULTIPOLYGON : TC.Consts.geom.POLYGON));
    };

    ctlProto.getLayerEditData = function (optionalLayer) {
        const self = this;
        const layer = optionalLayer || self.layer;
        if (!layer) {
            return null;
        }
        return self.layersEditData[layer.id] = self.layersEditData[layer.id] || {
            checkedOut: false
        };
    };

    ctlProto.cancel = function () {
        var self = this;
        if (Array.isArray(self.options.modes) && self.options.modes.length == 1) {
            self.setMode(self.options.modes[0], null);
        }
        else {
            self.setMode(null, false);
        }
        self.wrap.cancel(true, self.cancelActionConfirmTxt);
    };

    ctlProto.onFeatureClick = function (e) {
        if (!self.activeControl || !self.activeControl.isExclusive()) {
            e.feature.show();
        }
    };
    
    ctlProto.activate = function (options) {
        const self = this;
        options = options || {};
        const activateCtl = function (ctl) {
            if (ctl !== self.map.activeControl) {
                self._previousActiveControl = self.map.activeControl;
            }
        };
        switch (options.mode) {
            case TC.control.Edit.mode.ADDPOINT:
                self.getPointDrawControl().then(activateCtl);
                break;
            case TC.control.Edit.mode.ADDLINE:
                self.getLineDrawControl().then(activateCtl);
                break;
            case TC.control.Edit.mode.ADDPOLYGON:
                self.getPolygonDrawControl().then(activateCtl);
                break;
            default:
                self.getModifyControl().then(activateCtl);
                break;
        }
    };

    ctlProto.deactivate = function () {
        const self = this;
        if (self._previousActiveControl) {
            self.map.previousActiveControl = self._previousActiveControl;
            switch (self.map.activeControl) {
                case self.pointDrawControl:
                    self.pointDrawControl.deactivate();
                    break;
                case self.lineDrawControl:
                    self.lineDrawControl.deactivate();
                    break;
                case self.polygonDrawControl:
                    self.polygonDrawControl.deactivate();
                    break;
                case self.modifyControl:
                    self.modifyControl.deactivate();
                    break;
                default:
                    break;
            }
        }
        self.modifyControl && self.modifyControl.closeAttributes();
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.getAttributeDisplayTarget = function () {
        return this.modifyControl._attributesSection;
    };

    //ctlProto.joinFeatures = function (features) {
    //    var self = this;
    //    if (self.geometryType === TC.Consts.geom.MULTIPOLYLINE ||
    //        self.geometryType === TC.Consts.geom.MULTIPOLYGON ||
    //        self.geometryType === TC.Consts.geom.MULTIPOINT) {
    //        self._joinedFeatureAttributes = [];
    //        if (features.length > 1) {
    //            var geometries = features.map(function (elm) {
    //                self._joinedFeatureAttributes[self._joinedFeatureAttributes.length] = elm.getData();
    //                return elm.geometry;
    //            });
    //            var newGeometry = geometries.reduce(function (a, b) {
    //                return a.concat(b);
    //            });
    //            var newFeature = new features[0].constructor(newGeometry);
    //            for (var i = 0, len = features.length; i < len; i++) {
    //                var feature = features[i];
    //                self.layer.removeFeature(feature);
    //                self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
    //            }
    //            self.layer.addFeature(newFeature).then(function (feat) {
    //                self.setSelectedFeatures([newFeature]);
    //                self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
    //                feat.showPopup(self.attributeEditor);
    //            });
    //        }
    //        setFeatureSelectedState(self, [newFeature]);
    //    }
    //};

    //ctlProto.splitFeatures = function (features) {
    //    var self = this;
    //    var complexFeatures = features.filter(complexGeometryFilter);
    //    var geometries = complexFeatures.map(function (elm) {
    //        return elm.geometry;
    //    });
    //    var newFeatures = [];
    //    for (var i = 0, ii = complexFeatures.length; i < ii; i++) {
    //        var feature = complexFeatures[i];
    //        var data = feature.getData();
    //        var geometry = geometries[i];
    //        for (var j = 0, jj = geometry.length; j < jj; j++) {
    //            newFeatures[newFeatures.length] = new feature.constructor([geometry[j]], { data: data });
    //        }
    //    }
    //    for (var i = 0, len = complexFeatures.length; i < len; i++) {
    //        var feature = complexFeatures[i];
    //        self.layer.removeFeature(feature);
    //        self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
    //    }
    //    var newFeatPromises = new Array(newFeatures.length);
    //    for (var i = 0, len = newFeatures.length; i < len; i++) {
    //        const promise = newFeatPromises[i] = self.layer.addFeature(newFeatures[i]);
    //        promise.then(function (feat) {
    //            self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
    //        });
    //    }
    //    Promise.all(newFeatPromises).then(function() {
    //        self.setSelectedFeatures(newFeatures);
    //    });
    //    setFeatureSelectedState(self, newFeatures);
    //};

    //ctlProto.deleteFeatures = function (features) {
    //    var self = this;
    //    self.wrap.deleteFeatures(features);
    //    if (self.layer.features.length === 0) {
    //        self._deleteBtn.disabled = true;
    //    }
    //};

    ctlProto.getSelectedFeatures = function () {
        return this.modifyControl.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        return this.modifyControl.setSelectedFeatures(features);
    };

    ctlProto.getLayer = function () {
        var self = this;
        return self.layer;
    };

    ctlProto.getModifyControl = function () {
        const self = this;
        return self._modifyCtlPromise || new Promise(function (resolve, reject) {
            self.renderPromise().then(() => resolve(self.modifyControl));
        });
    };

    ctlProto.getPointDrawControl = function () {
        const self = this;
        return self._pointDrawCtlPromise || new Promise(function (resolve, reject) {
            self.renderPromise().then(() => resolve(self.pointDrawControl));
        });
    };

    ctlProto.getLineDrawControl = function () {
        const self = this;
        return self._lineDrawCtlPromise || new Promise(function (resolve, reject) {
            self.renderPromise().then(() => resolve(self.lineDrawControl));
        });
    };

    ctlProto.getPolygonDrawControl = function () {
        const self = this;
        return self._polygonDrawCtlPromise || new Promise(function (resolve, reject) {
            self.renderPromise().then(() => resolve(self.polygonDrawControl));
        });
    };

    //ctlProto.getCutDrawControl = function () {
    //    const self = this;
    //    return self._cutDrawCtlPromise || new Promise(function (resolve, reject) {
    //        self.renderPromise().then(() => resolve(self.cutDrawControl));
    //    });
    //};

    ctlProto.getFeatureImportPanel = function () {
        const self = this;
        if (!self._featureImportPanelPromise) {
            self._featureImportPanelPromise = self.map.addControl('resultsPanel', {
                titles: {
                    main: self.getLocaleString('importFromOtherLayer')
                }
            });
            self._featureImportPanelPromise.then(panel => self.featureImportPanel = panel);
        }
        return self._featureImportPanelPromise;
    };

    ctlProto.getHighlightsLayer = function () {
        const self = this;
        if (!self._highlightsLayerPromise) {
            self._highlightsLayerPromise = self.map.addLayer({
                id: self.getUID(),
                type: TC.Consts.layerType.VECTOR,
                title: 'Highlights Layer',
                stealth: true,
                styles: self.map.options.styles.selection || TC.Cfg.styles.selection
            });
            self._highlightsLayerPromise.then(layer => self.highlightsLayer = layer);
        }
        return self._highlightsLayerPromise;
    };

    ctlProto.highlightFeatures = function (features) {
        const self = this;
        self.getHighlightsLayer().then(function (layer) {
            const featuresToHighlight = self.featuresToImport.concat(features);
            layer.features.slice().forEach(function (feature) {
                if (!feature.original || featuresToHighlight.indexOf(feature.original) < 0) {
                    layer.removeFeature(feature);
                }
            });
            layer.addFeatures(featuresToHighlight
                .filter(function (feature) {
                    return !layer.features.some(function (f) {
                        return f.original && f.original === feature;
                    });
                })
                .map(function (feature) {
                const newFeature = feature.clone();
                newFeature.toggleSelectedStyle(true);
                newFeature.original = feature;
                return newFeature;
            }));
        });
    };

    ctlProto.getAvailableFeaturesToImport = function () {
        const self = this;
        return self.map.workLayers
            .filter(l => !l.isRaster())
            .filter(l => l !== self.layer)
            .filter(l => l !== self.highlightsLayer)
            .map(function (l) {
                return {
                    id: l.id,
                    title: l.title,
                    features: l.features.filter(function (f) {
                        return self.isFeatureAllowed(f);
                    })
                };
            })
            .filter(l => l.features.length);
    };

    ctlProto.getFeatureFromImportList = function (elm) {
        const self = this;
        const cb = elm.querySelector('input');
        const layer = self.map.getLayer(elm.parentElement.parentElement.dataset.layerId);
        if (layer) {
            return layer.getFeatureById(cb.value);
        }
        return null;
    };

    ctlProto.importFeatures = function (features) {
        const self = this;
        let failure = false;
        const layerEditData = self.getLayerEditData();
        const featuresToImport = (features || self.featuresToImport || [])
            .filter(f => {
                const result = self.isFeatureAllowed(f);
                if (!result) {
                    failure = true;
                }
                return result;
            });
        featuresToImport.map(function (feature) {
            let newFeature;
            const featureOptions = {
                data: feature.data,
                geometryName: layerEditData.geometryName
            };
            if (self.isMultiple) {
                switch (true) {
                    case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                        newFeature = new TC.feature.MultiPolygon([feature.geometry], featureOptions);
                        break;
                    case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                        newFeature = new TC.feature.MultiPolyline([feature.geometry], featureOptions);
                        break;
                    default:
                        newFeature = feature.clone();
                        break;
                }
            }
            else {
                switch (true) {
                    case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                        newFeature = new TC.feature.Polygon(feature.geometry[0], featureOptions);
                        break;
                    case TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:
                        newFeature = new TC.feature.Polyline(feature.geometry[0], featureOptions);
                        break;
                    default:
                        newFeature = feature.clone();
                        break;
                }
            }
            newFeature.setStyle(null);
            return newFeature;
        }).forEach(function (feature) {
            self.layer.addFeature(feature);
            self.trigger(TC.Consts.event.FEATUREADD, { feature: feature, layer: self.layer });
        });
        
        if (failure) {
            self.map.toast(self.getLocaleString('importFromOtherLayer.warning'), { type: TC.Consts.msgType.WARNING });
        }
    };

    const handleCheck = function (ctl, checkbox) {
        const feature = ctl.getFeatureFromImportList(checkbox.parentElement);
        if (checkbox.checked) {
            ctl.featuresToImport.push(feature);
        }
        else {
            const idx = ctl.featuresToImport.indexOf(feature);
            if (idx >= 0) {
                ctl.featuresToImport.splice(idx, 1);
            }
        }
    };

    ctlProto._addImportLayerEvents = function (li) {
        const self = this;
        
        li.querySelector('input').addEventListener('change', function (e) {
            const cb = this;
            cb.parentElement.querySelectorAll('li.tc-feature input').forEach(function (ccb) {
                if (ccb.checked !== cb.checked) {
                    ccb.checked = cb.checked;
                    handleCheck(self, ccb);
                }
            });
            self.highlightFeatures([]);
        });

        li.querySelectorAll('li.tc-feature').forEach(function (elm) {
            self._addImportFeatureEvents(elm);
        });
    };

    ctlProto._addImportFeatureEvents = function (li) {
        const self = this;
        const highlightListener = function (e) {
            const feature = self.getFeatureFromImportList(this);
            if (feature) {
                self.highlightFeatures([feature]);
            }
        };
        li.addEventListener(TC.Consts.event.CLICK, highlightListener);
        li.addEventListener('mouseover', highlightListener);
        li.querySelector('input').addEventListener('change', function (e) {
            handleCheck(self, this);
        });
    };

    ctlProto.showFeatureImportPanel = function () {
        const self = this;

        self.featuresToImport = [];

        self.getFeatureImportPanel().then(function (panel) {
            const container = panel.getInfoContainer();
            self.getRenderedHtml(self.CLASS + '-import', { layers: self.getAvailableFeaturesToImport() }, function (html) {
                panel.open(html, container);
                container.querySelector('ul').addEventListener('mouseout', function (e) {
                    self.highlightFeatures([]);
                });
                container.querySelectorAll('li.tc-layer').forEach(function (elm) {
                    self._addImportLayerEvents(elm);
                });
                container.querySelector(`.${self.CLASS}-import-btn-ok`).addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.importFeatures();
                    self.featureImportPanel.close();
                });
            });
        });
    };

    ctlProto.displayLayerToImport = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.featureImportPanel && !self.featureImportPanel.div.classList.contains(TC.Consts.classes.HIDDEN)) {
                const container = self.featureImportPanel.getInfoContainer();
                const list = container.querySelector(`.${self.CLASS}-import-list .tc-layers`);
                const layerElementSelector = `li[data-layer-id="${layer.id}"]`;
                const li = list.querySelector(layerElementSelector);
                if (li) {
                    features.forEach(function (feature) {
                        if (self.isFeatureAllowed(feature)) {
                            self.getRenderedHtml(self.CLASS + '-import-feature', layerObj, function (html) {
                                li.insertAdjacentHTML('beforeend', html);
                                self._addImportFeatureEvents(li.querySelector('li:last-child'));
                            });
                        }
                    });
                    resolve(li);
                }
                else {
                    self.getRenderedHtml(self.CLASS + '-import-layer', { id: layer.id, title: layer.title, features: layer.features }, function (html) {
                        list.insertAdjacentHTML('beforeend', html);
                        const newLi = list.querySelector(layerElementSelector);
                        self._addImportLayerEvents(newLi);
                        resolve(newLi);
                    });
                }
            }
            else {
                resolve(null);
            }
        });
    };

    ctlProto.getDownloadDialog = function () {
        const self = this;
        if (self._downloadDialog) {
            return Promise.resolve(self._downloadDialog);
        }
        return new Promise(function (resolve, reject) {
            self.map.addControl('FeatureDownloadDialog').then(ctl => {
                self._downloadDialog = ctl;
                resolve(ctl);
            })
        });
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ExternalWMS = function (options) {
    const self = this;
    self.count = 0;
    self._addedUrls = [];

    TC.Control.apply(self, arguments);

    self.allowReprojection = typeof self.options.allowReprojection === 'boolean' ? self.options.allowReprojection : true;
};

TC.inherit(TC.control.ExternalWMS, TC.Control);

(function () {
    var ctlProto = TC.control.ExternalWMS.prototype;

    ctlProto.CLASS = 'tc-ctl-xwms';

    /**
     * Marca como seleccionadas aquellas opciones del desplegable correspondientes a servicios WMS ya añadidos al TOC.
     */
    ctlProto.markServicesAsSelected = function (options) {
        if (options.length > 0) {
            const selectedOption = options[0];
            selectedOption.disabled = true;
            selectedOption.classList.add('tc-ctl-xwms-option-selected');
        }
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('select', function (evt) {
            if (evt.target.value !== '') {
                var url = evt.target.value;
                if (url.indexOf('//') === 0) {
                    url = location.protocol + url;
                }
                self.div.querySelector('input').value = url;
                evt.target.value = '';
            }
        }));

        /**
         * Borra parámetros no necesarios de la URL del servicio WMS.
         */
        var _removeParamsFromUrl = function (url, unwantedParams) {
            for (var i = 0; i < unwantedParams.length; i++) {
                url = TC.Util.removeURLParameter(url, unwantedParams[i]);
            }
            if (url.match(/\?$/)) {
                url = url.substr(0, url.length - 1);
            }
            return url;
        }

        const addWMS = function () {
            var url = self.div.querySelector('input').value.trim();

            if (!url) {
                TC.alert(self.getLocaleString('typeAnAddress'));
            }
            else if (!/^((https?|ftp):)?(\/\/)?(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(url)) {
                TC.alert(self.getLocaleString('typeAValidAddress'));
            }
            else {
                if (self._addedUrls.some(function (addedUrl) {
                    return addedUrl.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')
                })) {
                    TC.alert(self.getLocaleString('serviceAlreadyAdded'));
                }
                else {
                    var loadingCtrl = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];
                    loadingCtrl.show();
                    var params = TC.Util.getQueryStringParams(url);

                    if (!/https?:\/\/|\/\//i.test(url)) {
                        url = "//" + url;
                    }

                    //Extraemos sólo los parámetros adicionales
                    var unwantedParams = ["version", "service", "request"];
                    var urlWithoutParams = _removeParamsFromUrl(url, Object.keys(params));

                    for (var item in params) {
                        if (unwantedParams.indexOf(item.toLowerCase()) >= 0) {
                            delete params[item];
                        }
                    }

                    const addButton = self.div.querySelector('button');
                    addButton.disabled = true;

                    var obj = {
                        id: 'xwms' + (++self.count),
                        //"title": "Servicio externo",
                        type: 'WMS',
                        url: urlWithoutParams,
                        hideTree: false,
                        queryParams: params
                    };
                    //URI: recorremos las opciones buscando el servicio que se va a agregar a ver si tiene parametro layerNames
                    for (var i = 0; i < self.options.suggestions.length; i++) {
                        var _current = self.options.suggestions[i].items.filter(function (item, i) {
                            return item.url === url;
                        });
                        if (_current.length > 0 && _current[0].layerNames) {
                            obj["layerNames"] = _current[0].layerNames;
                            break;
                        }
                    }

                    var layer = new TC.layer.Raster(obj);
                    layer.getCapabilitiesPromise().then(function (cap) {
                        if (typeof (cap.Capability) === 'undefined') {
                            TC.alert(self.getLocaleString('noLayersFoundInService'));
                            loadingCtrl.hide();
                            addButton.disabled = false;
                            return;
                        } else {
                            var root = cap.Capability.Layer;
                            if (root.CRS && root.CRS.indexOf(self.map.crs) == -1 && !self.allowReprojection) {
                                //no soportado. avisar y fallar
                                TC.alert(self.getLocaleString('serviceSrsNotCompatible'));
                                loadingCtrl.hide();
                                addButton.disabled = false;
                                return;
                            }

                            self.map.trigger(TC.Consts.event.EXTERNALSERVICEADDED, { layer: layer });
                            self.div.querySelector('input').value = '';

                            const selectedOptions = [];
                            self.div.querySelectorAll('select option').forEach(function (option) {
                                if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                                    selectedOptions.push(option);
                                }
                            });
                            self.markServicesAsSelected(selectedOptions);
                            self._addedUrls.push(url);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        }
                    },
                        function (error) {
                            TC.alert(self.getLocaleString('serviceCouldNotBeLoaded') + ":\n" + error);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        });
                }
            }
        };

        self.renderPromise().then(() => {
            self.div.querySelector('input').addEventListener('keyup', (e) => {
                if (e.key && e.key.toLowerCase() === "enter" && self.div.querySelector('input').value.trim().length > 0) {
                    addWMS();
                }
            });
        });       

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('button[name="agregar"]', addWMS));

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (layer && !layer.isBase) {
                var url = layer.url;

                if (url) {
                    self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];
                    if (self.div.querySelectorAll('select option').length === 0 && url && self.pending_markServicesAsSelected.indexOf(url) === -1) {
                        self.pending_markServicesAsSelected.push(url);
                    }

                    const selectedOptions = [];
                    self.div.querySelectorAll('select option').forEach(function (option) {
                        if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                            selectedOptions.push(option);
                        }
                    });
                    self.markServicesAsSelected(selectedOptions);
                    self._addedUrls.push(url);
                }
            }
        });

        return result;
    };

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ExternalWMS.html";

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(self.options, function () {
            self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];

            self.pending_markServicesAsSelected.forEach(function (elemUrl) {
                const selectedOptions = [];
                self.div.querySelectorAll('select option').forEach(function (option) {
                    if (TC.Util.addProtocol(option.value) === TC.Util.addProtocol(elemUrl)) {
                        selectedOptions.push(option);
                    }
                });

                self.markServicesAsSelected(selectedOptions);
                self._addedUrls.push(elemUrl);
            });

            self.pending_markServicesAsSelected = [];
        }));
    };


})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}


TC.control.FeatureDownloadDialog = function () {
    var self = this;
    TC.Control.apply(self, arguments);
    self.title = self.options.title;
    self.cssClass = self.options.cssClass || "";

    self._selectors = {
        ELEVATION_CHECKBOX: "." + self.CLASS + '-elev input[type=checkbox]',
        INTERPOLATION_PANEL: "." + self.CLASS + '-ip',
        INTERPOLATION_RADIO: 'input[type=radio][name=finfo-ip-coords]',
        INTERPOLATION_DISTANCE: "." + self.CLASS + '-ip-m'
    };
};

TC.inherit(TC.control.FeatureDownloadDialog, TC.Control);

(function () {

    const ctlProto = TC.control.FeatureDownloadDialog.prototype;

    ctlProto.CLASS = 'tc-ctl-dwn-dialog';

    var _formats= ["KML", "GML", "GeoJSON", "WKT", "GPX"];

    //if (window.JSZip) {
    //    if (window.JSZip instanceof Promise)
    //        window.JSZip.then(function () {
    //            _formats.splice(1, 0, "KMZ");
    //        });
    //    else
    //        _formats.splice(1, 0, "KMZ");
    //}

    var displayElevation, interpolation = false;
    var interpolationDistance = null;

    ctlProto.template = {};   

    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/FeatureDownloadDialog.html";

    const addElevationAndInterpolation = function (featureOrFeatures, options) {
        const self = this;
        options = options || {};
        const features = Array.isArray(featureOrFeatures) ? featureOrFeatures : [featureOrFeatures];
        return new Promise(function (resolve, reject) {

            //si no se incluyen las elevaciones quito las Z de las geometrias que las tuvieran
            if (!options.displayElevation) {
                resolve(features.map(function (feat) {
                    if (feat.getGeometryStride() > 2) {
                        const f = feat.clone();
                        f.getCoordsArray().forEach(coord => coord.length = 2);
                        f.setCoords(f.geometry);
                        return f;
                    }
                    return feat;
                }));
                return;
            }

            let mustInterpolate = options.elevation && options.elevation.resolution;
            // Array con features sin altura y nulo donde habia feature con alturas
            let featuresToAddElevation = mustInterpolate ? features.map(f => f.clone()) : features.map(f => f.getGeometryStride() > 2 ? null : f.clone());
            
            if (mustInterpolate || featuresToAddElevation.some(f => f !== null)) {
                const elevOptions = {
                    crs: self.map.crs,
                    features: featuresToAddElevation,
                    maxCoordQuantity: options.elevation && options.elevation.maxCoordQuantity,
                    resolution: options.elevation.resolution,
                    sampleNumber: options.elevation.sampleNumber || 0
                };                    
                (self.map.elevation || new TC.tool.Elevation(typeof self.options.elevation === 'boolean' ? {} : self.options.elevation)).setGeometry(elevOptions).then(
                    function (processedFeatures) {
                        // Recombinamos features procesadas y sin procesar
                        processedFeatures.forEach((f, index) => {
                            if (!f) {
                                processedFeatures[index] = features[index];
                            }
                        });
                        resolve(processedFeatures);
                    },
                    function (error) {
                        reject(error instanceof Error ? error : Error(error));
                    }
                );
            }
            else {
                resolve(features);
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);
        return result;
        
    };

    ctlProto.open = function (features, options) {
        const self = this;

        ctlProto.getRenderedHtml(ctlProto.CLASS, Object.assign({}, {
            cssClass: self.cssClass,
            checkboxId: self.getUID(),
            elevation: options.elevation,//options.elevation ? (options.elevation instanceof Object ? options.elevation : self.map.elevation.options) : options.elevation,
            formats: _formats.filter(function (item) {
                return (options && options.excludedFormats && options.excludedFormats.indexOf(item) < 0) | (!options | !options.excludedFormats)
            })
        }, options), function (html) {
            var template = document.createElement('template');
            template.innerHTML = html;
            var modal = template.content ? template.content.firstChild : template.firstChild;            
            document.body.appendChild(modal);

            var modalBody = modal.getElementsByClassName("tc-modal-body")[0];
            modalBody.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button[data-format]', function (e) {

                var resolution = displayElevation && interpolation ? parseFloat(modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE + ' input[type=number]').value) || (self.options.elevation || self.map.elevation.options).resolution : 0

                const endExport = async (features) => {

                    //checkear si son features con datos complejos
                    var cancel = false;
                    if (format !== TC.Consts.format.GEOJSON && options.format !== TC.Consts.format.WKT && (features instanceof Array ? features : [features]).some(function (feat) {
                        for (var attr in feat.getData()) {
                            if (feat.data[attr] instanceof Object)
                                return true
                        }
                        return false;
                    }))
                        await TC.confirm(self.getLocaleString("dl.export.complexAttr").format(format), null,
                            function () {
                                cancel = true
                            });
                    if (cancel) { return };

                    const li = self.map.getLoadingIndicator();
                    const waitId = li && li.addWait();


                    TC.Util.closeModal();
                    addElevationAndInterpolation.apply(self, [features,
                        {
                            displayElevation: displayElevation,
                            elevation: displayElevation ? Object.assign({}, options.elevation || self.map.elevation.options, { resolution: resolution }) : null
                        }]).then(
                        function (features) {
                            let fileName = (options ? (options.fileName || options.title.toLowerCase().replace(/ /g, '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true) || "download_" + TC.Util.getFormattedDate(new Date().toString(), true)) : (options.title.toLowerCase().replace(/ /g, '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true) || "download_" + TC.Util.getFormattedDate(new Date().toString(), true)));                            
                            self.map.exportFeatures(features, {
                                fileName: fileName,
                                format: format
                            });
                        },
                        function (error) {
                            self.open(features, options)
                            if (TC.tool.Elevation && error.message === TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED) {
                                TC.alert(self.getLocaleString('tooManyCoordinatesForElevation.warning'));
                                return;
                            }
                            TC.error(self.getLocaleString('elevation.error'));
                        }
                        ).finally(function () {
                            li && li.removeWait(waitId);
                        });
                }

                const format = e.target.dataset.format;
                if (format === TC.Consts.format.GPX) {

                    if ((features instanceof Array ? features : [features]).some(function (feature) {
                        return TC.feature.Polygon && feature instanceof TC.feature.Polygon;
                    })) {
                        TC.confirm(self.getLocaleString('gpxNotCompatible.confirm'), function () {
                            endExport((features instanceof Array ? features : [features]).filter((f) => { return TC.feature.Polygon && !(f instanceof TC.feature.Polygon); }));
                        });
                    }
                    else {
                        endExport(features);
                    }
                }
                else {
                    endExport(features);
                }


            }));

            const hasLines = (features instanceof Array ? features : [features]).some(function (feature) {
                return (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
                    (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
            });
            const hasPolygons = (features instanceof Array ? features : [features]).some(function (feature) {
                return (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
                    (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);
            });
            if (options.elevation) {
                modalBody.querySelector(self._selectors.ELEVATION_CHECKBOX).checked = (displayElevation == true);
                if (displayElevation && (hasLines || hasPolygons) && options.elevation.resolution) {
                    modalBody.querySelector(self._selectors.INTERPOLATION_PANEL).classList.remove(TC.Consts.classes.HIDDEN);                    
                }
                if (modalBody.querySelector(self._selectors.INTERPOLATION_PANEL)) {
                    modalBody.querySelectorAll(self._selectors.INTERPOLATION_RADIO)[interpolation ? 1 : 0].checked = true;
                    if (interpolation) {
                        modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE).classList.remove(TC.Consts.classes.HIDDEN);
                        modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE + " input").value = interpolationDistance || modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE + " input").value;
                    }
                }
            }

            modalBody.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.ELEVATION_CHECKBOX, function (e) {
                //self.showDownloadDialog(); // Recalculamos todo el aspecto del diálogo de descarga
                var ipPanel = modalBody.querySelector(self._selectors.INTERPOLATION_PANEL);
                if (ipPanel) { ipPanel.classList.toggle(TC.Consts.classes.HIDDEN, displayElevation || !(hasLines || hasPolygons)); }
                displayElevation = !displayElevation;
            }));
            modalBody.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.INTERPOLATION_RADIO, function (e) {
                const idDiv = modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE);
                idDiv.classList.toggle(TC.Consts.classes.HIDDEN);
                interpolation = !interpolation;
                if (interpolation) modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE + " input").value = interpolationDistance || modalBody.querySelector(self._selectors.INTERPOLATION_DISTANCE + " input").value;
            }));
            modalBody.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.INTERPOLATION_DISTANCE, function (e) {
                interpolationDistance = e.target.value;
            }));

            TC.Util.showModal(modal, {
                closeCallback: function () {
                    modal.parentElement.removeChild(modal);
                }
            });
        });
    };
    
})();
TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}

(function () {
    TC.control.FeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.FeatureInfo(self);

        TC.Consts.classes.FROMLEFT = 'tc-fromleft';
        TC.Consts.classes.FROMRIGHT = 'tc-fromright';
    };

    TC.inherit(TC.control.FeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.FeatureInfo.prototype;

    var roundCoordinates = function roundCoordinates(obj, precision) {
        var result;
        var n = 20;
        if (Array.isArray(obj)) {
            result = obj.slice();
            for (var i = 0, len = result.length; i < len; i++) {
                result[i] = roundCoordinates(result[i]);
            }
        }
        else if (typeof obj === "number") {
            result = Math.round(obj.toFixed(precision));
        }
        else {
            result = obj;
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        // Le ponemos un padre al div. Evitamos con esto que se añada el div al mapa (no es necesario, ya que es un mero buffer)
        document.createElement('div').appendChild(self.div);

        if (self.options.displayElevation || self.map.options.elevation) {
            TC.loadJS(
                !TC.tool || !TC.tool.Elevation,
                TC.apiLocation + 'TC/tool/Elevation',
                function () {
                    const elevationOptions = self.options.displayElevation ? (typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation) : (typeof self.map.options.elevation === 'boolean' ? {} : self.map.options.elevation);
                    self.elevation = new TC.tool.Elevation(elevationOptions);
                }
            );
        }        
        return result;
    };

    ctlProto.callback = function (coords, xy) {
        const self = this;

        self.querying = true;

        if (self.elevation) {
            self.elevationRequest = self.elevation.getElevation({
                crs: self.map.crs,
                coordinates: coords
            });
        }

        if (self.map && self.filterLayer) {
            //aquí se pone el puntito temporal
            var title = self.getLocaleString('featureInfo');
            var markerOptions = TC.Util.extend({}, self.map.options.styles.marker, self.markerStyle, { title: title, set: title, showsPopup: false });
            self.filterLayer.clearFeatures();
            self.highlightedFeature = null;
            self.filterFeature = null;
            self.filterLayer.addMarker(coords, markerOptions).then(function (marker) {
                ////cuando se queda el puntito es porque esto sucede tras el cierre de la popup
                ////o sea
                ////lo normal es que primero se ejecute esto, y luego se procesen los eventos FEATUREINFO o NOFEATUREINFO
                ////pero en el caso raro (la primera vez), ocurre al revés. Entonces, ya se habrá establecido lastFeatureCount (no será null)
                //if (self.lastFeatureCount === null) {
                //    self.map.putLayerOnTop(self.filterLayer);
                //    self.filterFeature = marker;
                //}
                //else {
                //    self.filterLayer.clearFeatures();
                //}
                self.map.putLayerOnTop(self.filterLayer);
                self.filterFeature = marker;

                self.renderResults({ coords: marker.geometry, displayElevation: self.elevation, loading: true }, function () {
                    self.displayResults();
                });

                var visibleLayers = false;
                for (var i = 0; i < self.map.workLayers.length; i++) {
                    var layer = self.map.workLayers[i];
                    if (layer.type === TC.Consts.layerType.WMS) {
                        if (layer.getVisibility() && layer.names.length > 0) {
                            visibleLayers = true;
                            break;
                        }
                    }
                }
                var resolution = self.map.getResolution();
                if (visibleLayers) {
                    self.wrap.getFeatureInfo(coords, resolution);
                }
                else {
                    // Metemos setTimeout para salirnos del hilo. Sin él se corre el riesgo de que se ejecute esto antes del evento BEFOREFEATUREINFO
                    setTimeout(function () {
                        self.responseCallback({ coords: coords });
                    });
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        const self = this;

        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);
        if (self.filterFeature) {
            var services = options.services;

            // Eliminamos capas sin resultados
            if (services) {
                for (var i = 0; i < services.length; i++) {
                    var service = services[i];
                    for (var j = 0; j < service.layers.length; j++) {
                        if (!service.layers[j].features.length) {
                            service.layers.splice(j, 1);
                            j = j - 1;
                        }
                    }
                    if (!service.layers.length) {
                        services.splice(i, 1);
                        i = i - 1;
                    }
                }
            }

            self.info.defaultFeature = options.defaultFeature;

            if (self.elevationRequest) {
                options.displayElevation = true;
            }
            self.renderResults(options, function () {
                self.insertLinks();

                if (self.sharedFeatureInfo) {
                    self.div.querySelectorAll('ul.' + self.CLASS + '-services li').forEach(function (li) {
                        li.classList.add(TC.Consts.classes.CHECKED);
                    })
                    var sharedFeature;
                    var featureObj = self.sharedFeatureInfo;
                    for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                        var service = self.info.services[i];
                        if (service.mapLayers.some(function (ml) { return ml.url === featureObj.s })) {
                            for (var j = 0, jj = service.layers.length; j < jj; j++) {
                                var layer = service.layers[j];
                                if (layer.name === featureObj.l) {
                                    for (var k = 0, kk = layer.features.length; k < kk; k++) {
                                        var feature = layer.features[k];
                                        if (feature.id === featureObj.f) {
                                            sharedFeature = feature;
                                            var hash = hex_md5(JSON.stringify({
                                                data: feature.getData(),
                                                geometry: roundCoordinates(feature.geometry, TC.Consts.DEGREE_PRECISION) // Redondeamos a la precisión más fina (grado)
                                            }));
                                            if (featureObj.h !== hash) {
                                                TC.alert(self.getLocaleString('finfo.featureChanged.warning'));
                                            }
                                            break;
                                        }
                                    }
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    if (sharedFeature) {
                        self.highlightedFeature = sharedFeature;
                        self.map.addLayer({
                            id: self.getUID(),
                            type: TC.Consts.layerType.VECTOR,
                            title: self.getLocaleString('foi'),
                            owner: self,
                            stealth: true
                        }).then(function (layer) {
                            self.sharedFeatureLayer = layer;
                            self.filterLayer.clearFeatures();
                            self.filterFeature = null;
                            layer.addFeature(sharedFeature);
                            self.map.zoomToFeatures([sharedFeature]);
                        });
                    }
                    delete self.sharedFeatureInfo;
                }
                else {
                    self.displayResults();
                }
                //capturamos el click de label y enlaces para no propagarlos a las tablas y que haga zoom cuando no se quiere
                self.div.querySelectorAll('ul.' + self.CLASS + '-services label, ul.' + self.CLASS + '-services a').forEach(function (label) {
                    label.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.stopPropagation();
                    })
                })
            });
        }
    };

    ctlProto.displayResultsCallback = function () {
        const self = this;
        TC.control.FeatureInfoCommons.prototype.displayResultsCallback.call(self);

        if (self.elevationRequest) {
            const ctl = self.getDisplayControl();
            self.getDisplayTarget().querySelector(`.${self.CLASS}-elev`).classList.add(TC.Consts.classes.HIDDEN);
            self.elevationRequest.then(function (elevationCoords) {
                if (ctl.currentFeature) {
                    const currentCoords = ctl.currentFeature.geometry;                    
                    if (TC.Util.formatCoord(currentCoords[0], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) === TC.Util.formatCoord(elevationCoords[0][0], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) &&
                        TC.Util.formatCoord(currentCoords[1], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) === TC.Util.formatCoord(elevationCoords[0][1], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION)) {
                        const elevationValue = elevationCoords.length ? elevationCoords[0][2] : null;
                        self.displayElevation(elevationValue);
                    }
                }
                //self.elevationRequest = null;
            });
        }
        else if (!self.querying && (!self.info || !self.info.services)) {
            self.closeResults();
        }
    };

    ctlProto.renderResults = function (options, callback) {
        const self = this;
        if (self.filterFeature) {
            const currentCoords = self.filterFeature.geometry;
            if (options.coords && currentCoords[0] === options.coords[0] && currentCoords[1] === options.coords[1]) {
                const locale = self.map.options.locale || TC.Cfg.locale;
                options.isGeo = self.map.wrap.isGeo();
                if (options.coords) {
                    options.crs = self.map.crs;
                    options.coords = options.coords.map(function (value) {
                        return TC.Util.formatNumber(value.toFixed(options.isGeo ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION), locale);
                    });
                }
                self.renderData(options, callback);
            }
        }
    };

    ctlProto.displayElevation = function (value) {
        const self = this;
        const locale = self.map.options.locale || TC.Cfg.locale;
        const elevationString = value === null ? '-' : TC.Util.formatNumber(Math.round(value), locale) + ' m';
        const elevationDisplay = self.getDisplayTarget().querySelector(`.${self.CLASS}-elev`);
        elevationDisplay.classList.toggle(TC.Consts.classes.HIDDEN, value === null);
        elevationDisplay.querySelector(`.${self.CLASS}-coords-val`).innerHTML = elevationString;
    };

    ctlProto.loadSharedFeature = function (featureObj) {
        // Función para dar compatibilidad hacia atrás, ahora las features se comparten por URL
        const self = this;
        if (featureObj) {
            //buscamos si la feature compartida pertenece a alguna de las capas añadidas
            if (self.map.workLayers.filter(function (item, i) {
                return item.type === TC.Consts.layerType.WMS && item.url === featureObj.s && item.getDisgregatedLayerNames().indexOf(featureObj.l) >= 0
            }).length === 0) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
                return;
            }
            self.sharedFeatureInfo = featureObj;
            TC.loadJS(
                !window.hex_md5,
                [TC.apiLocation + TC.Consts.url.HASH],
                function () {
                    // Creamos una consulta getFeatureInfo ad-hoc, con la resolución a la que estaba la consulta original.
                    const coords = [-100, -100];
                    self.beforeRequest({ xy: coords }); // xy negativo para que no se vea el marcador, ya que no sabemos dónde ponerlo.
                    //aquí se pone el puntito temporal
                    self.filterLayer.clearFeatures();
                    self.filterFeature = null;
                    self.filterLayer.addMarker(coords).then(function (marker) {
                        self.filterFeature = marker;
                        self.wrap.getFeatureInfo(featureObj.xy, featureObj.r, {
                            serviceUrl: featureObj.s,
                            layerName: featureObj.l,
                            featureId: featureObj.f
                        });
                    });
                }
            );
        }
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';

TC.control.FeatureTools = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]',
        INTERPOLATION_RADIO: 'input[type=radio][name=finfo-ip-coords]',
        INTERPOLATION_DISTANCE: cs + '-dialog-ip-m'
    };

    if (self.options.displayElevation) {
        TC.loadJS(
            !TC.tool || !TC.tool.Elevation,
            TC.apiLocation + 'TC/tool/Elevation',
            function () {
                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                self.elevation = new TC.tool.Elevation(elevationOptions);
            }
        );
    }

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
};

TC.inherit(TC.control.FeatureTools, TC.Control);

(function () {
    var ctlProto = TC.control.FeatureTools.prototype;

    ctlProto.CLASS = 'tc-ctl-ftools';

    ctlProto.TITLE_SEPARATOR = ' • ';
    ctlProto.FILE_TITLE_SEPARATOR = '__';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/FeatureTools.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/FeatureToolsDialog.html";

    var downloadDialog = null;

    ctlProto.register = function (map) {
        const self = this;
        map
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                self.currentDisplay = e.control;              // caso feature compartida
                if (self.currentDisplay.caller || (!self.currentDisplay.caller && self.currentDisplay.currentFeature)) {
                    self.highlightedFeature = !(!self.currentDisplay.caller && self.currentDisplay.currentFeature) ? self.currentDisplay.caller.highlightedFeature : self.currentDisplay.currentFeature;
                    self.addUI(self.currentDisplay);
                }
            })
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.currentDisplay = null;
            })
            .on(TC.Consts.event.FEATUREADD, function (e) {
                const feature = e.feature;
                if (self.currentDisplay && self.currentDisplay.caller && feature === self.currentDisplay.caller.highlightedFeature) {
                    self.highlightedFeature = feature;
                }
            });
        //.on(TC.Consts.event.FEATUREREMOVE, function (e) {
        //    const feature = e.feature;
        //    if (feature === self.highlightedFeature) {
        //        const highlightedFeature = feature.clone();
        //        highlightedFeature.showsPopup = true;
        //        // Si la feature se eliminó por un cierre de popup provocado por la apertura de otro, 
        //        // reasignamos la feature nueva al popup, ya que este está apuntando a una feature que ya no está en el mapa.
        //        map.getControlsByClass('TC.control.Popup').concat(map.getControlsByClass('TC.control.ResultsPanel')).forEach(function (ctl) {
        //            if (ctl.currentFeature === self.highlightedFeature) {
        //                ctl.currentFeature = highlightedFeature;
        //            }
        //        });
        //        self.getHighlightLayer().then(function (layer) {
        //            layer.addFeature(highlightedFeature);
        //        });
        //    }
        //});

        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                self.map.addControl('share', {
                    id: self.getUID(),
                    div: self._dialogDiv.querySelector('.tc-modal-body .' + self.CLASS + '-share-dialog-ctl'),
                    includeControls: false // Establecemos el control para que no exporte estados de controles, así no se comparte la feature dos veces
                }).then(function (ctl) {
                    self._shareCtl = ctl;
                    resolve(self);
                }).catch(function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
            });
        });
    };

    ctlProto.render = function () {
        const self = this;

        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        }, function (html) {
            self._dialogDiv.innerHTML = html;
            if (!downloadDialog) {
                self.map.addControl('FeatureDownloadDialog').then(ctl => {
                    downloadDialog = ctl;
                });
            }
        }));
    };

    ctlProto.addUI = function (ctl) {
        const self = this;
        const menuContainer = ctl.getMenuElement();
        // Nos aseguramos de que el se decora el control una sola vez
        const menuIsMissing = function () {
            return menuContainer && !menuContainer.querySelector('.' + self.CLASS);
        };
        if (menuIsMissing()) {
            // Añadimos los botones de herramientas
            self.getRenderedHtml(self.CLASS, null, function (html) {
                if (menuIsMissing()) {                    

                    const parser = new DOMParser();
                    const tools = parser.parseFromString(html, 'text/html').body.firstChild;
                    menuContainer.appendChild(tools);

                    self.updateUI(ctl);

                    if (!self.map.options.stateful) {
                        // Compartir no funciona sin estado
                        const shareBtn = tools.querySelector('.' + self.CLASS + '-share-btn');
                        shareBtn.parentElement.removeChild(shareBtn);
                    }
                    self._setToolButtonHandlers(tools);

                    const container = ctl.getContainerElement();
                    self._decorateDisplay(container);

                    // Añadimos botón de imprimir
                    TC.loadJS(
                        !TC.control.Print,
                        [TC.apiLocation + 'TC/control/Print'],
                        function () {
                            var printTitle = "";

                            if (!container.querySelectorAll('.' + TC.control.Print.prototype.CLASS + '-btn').length) {
                                if (self.highlightedFeature) {
                                    printTitle = self.highlightedFeature.id;

                                    if (self.highlightedFeature.showsPopup === true) {
                                        new TC.control.Print({
                                            target: menuContainer,
                                            printableElement: container,
                                            title: printTitle
                                        });
                                    }
                                }
                            }
                        });
                }
            });
        }
        else {
            self.updateUI(ctl);
        }
    };

    ctlProto._decorateDisplay = function (container) {
        const self = this;

        if (self.highlightedFeature) {

            // Añadimos un zoom a la feature al pulsar en la tabla
            const attributeTable = container.querySelector('table.tc-attr');
            if (attributeTable) {
                attributeTable.addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.zoomToCurrentFeature();
                });

                attributeTable.querySelectorAll('a, table label, table input').forEach(function (a) {
                    a.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.stopPropagation(); // No queremos zoom si pulsamos en un enlace
                    });
                });

                attributeTable.classList.add(self.CLASS + '-zoom');
                attributeTable.setAttribute('title', self.getLocaleString('clickToCenter'));
            }
        }
    };

    ctlProto.updateUI = function (ctl) {
        const self = this;
        const uiDiv = ctl.getMenuElement().querySelector('.' + self.CLASS);
        uiDiv.classList.remove(TC.Consts.classes.ACTIVE);
        clearTimeout(self._uiUpdateTimeout);
        self._uiUpdateTimeout = setTimeout(function () {
            const currentFeature = self.getCurrentFeature();
            uiDiv.classList.toggle(TC.Consts.classes.ACTIVE, currentFeature && currentFeature.layer.owner ? currentFeature.layer.owner.filterLayer !== currentFeature.layer : true);
        }, 100);
    };

    ctlProto._setToolButtonHandlers = function (container) {
        const self = this;

        // Evento para mostrar diálogo modal de descarga
        container.querySelector('.' + self.CLASS + '-dl-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.showDownloadDialog();
        });

        if (self.map.options.stateful) {
            // Evento para mostrar diálogo modal de compartir
            container.querySelector('.' + self.CLASS + '-share-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showShareDialog();
            });
        }

        // Evento para hacer zoom
        container.querySelector('.' + self.CLASS + '-zoom-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.zoomToCurrentFeature();
        });

        // Evento para borrar la feature
        container.querySelector('.' + self.CLASS + '-del-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.removeCurrentFeature();
        });
    };

    ctlProto.showDownloadDialog = function () {
        const self = this;

        const feature = self.getCurrentFeature();

        var options = {
            title: self.getLocaleString("feature") + " - " + self.getLocaleString("download"),
            fileName: self._getFeatureFilename(feature)
        };

        if (self.options.displayElevation !== true)
            options = Object.assign({}, options, { elevation: Object.assign({}, self.map.elevation && self.map.elevation.options, self.options.displayElevation) });
        else
            options = Object.assign({}, options, { elevation: self.map.elevation && self.map.elevation.options });

        if (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon || TC.feature.Polygon && feature instanceof TC.feature.Polygon)
            options = Object.assign({}, options, { excludedFormats: ["GPX"] });

        downloadDialog.open(feature, options);
    };

    ctlProto.showShareDialog = function () {
        const self = this;
        TC.Util.showModal(self._dialogDiv.querySelector('.' + self.CLASS + '-share-dialog'), {
            openCallback: function () {
                self.onShowShareDialog();
            },
            closeCallback: function () {
                self._shareCtl.featureToShare = null;
            }
        });
    };

    ctlProto.getCurrentFeature = function () {
        const self = this;
        return self.currentDisplay && ((self.currentDisplay.caller && self.currentDisplay.caller.highlightedFeature) ||
            self.currentDisplay.currentFeature);
    };

    ctlProto.zoomToCurrentFeature = function () {
        const self = this;
        if (self.map) {
            self.map.zoomToFeatures([self.getCurrentFeature()], { animate: true });
        }
    };

    ctlProto.removeCurrentFeature = function () {
        const self = this;
        const currentFeature = self.getCurrentFeature();
        const removeFeature = function () {
            self.highlightedFeature = null;
            if (currentFeature && currentFeature.layer) {
                currentFeature.layer.removeFeature(currentFeature);
            }
        };
        const closeDisplay = function () {
            if (self.currentDisplay) {
                self.currentDisplay.close ? self.currentDisplay.close() : self.currentDisplay.hide();
            }
        };
        // No pedimos confirmación para borrar si es un resalte de GFI.
        if (currentFeature && currentFeature.layer.owner && currentFeature.layer === currentFeature.layer.owner.resultsLayer) {
            removeFeature();
            closeDisplay();
        }
        else {
            TC.confirm(self.getLocaleString('deleteFeature.confirm'), function () {
                removeFeature();
                closeDisplay();
            });
        }
    };

    const prepareFeatureToShare = function (ctl, options) {
        options = options || {};
        return new Promise(function (resolve, reject) {
            const currentFeature = ctl.getCurrentFeature();
            if (currentFeature) {
                const feature = currentFeature.clone();
                feature.setId(currentFeature.id);
                feature.layer = currentFeature.layer;
                if (options.elevation) {
                    var mustGetElevations = true;
                    if (!options.elevation.resolution && feature.getGeometryStride() > 2) {
                        mustGetElevations = false;
                    }
                    if (mustGetElevations) {
                        const elevOptions = {
                            crs: ctl.map.crs,
                            features: [feature],
                            maxCoordQuantity: ctl.options.displayElevation && ctl.options.displayElevation.maxCoordQuantity,
                            resolution: options.elevation.resolution,
                            sampleNumber: 0 // No queremos determinar el número de muestras
                        };
                        ctl.elevation.setGeometry(elevOptions).then(
                            function (features) {
                                resolve(features[0]);
                            },
                            function (error) {
                                reject(error instanceof Error ? error : Error(error));
                            }
                        );
                    }
                    else {
                        resolve(feature);
                    }
                }
                else {
                    const coordsArray = feature.getCoordsArray();
                    const firstCoord = coordsArray[0];
                    if (firstCoord && firstCoord.length > 2) {
                        coordsArray.forEach(function (coord) {
                            coord.length = 2;
                        });
                        feature.setCoords(feature.geometry);
                    }
                    resolve(feature);
                }
            }
            else {
                resolve(null);
            }
        });
    };

    ctlProto.onShowShareDialog = function () {
        const self = this;
        const shareCtl = self._shareCtl;
        shareCtl.extraParams = null;
        prepareFeatureToShare(self).then(function (feature) {
            shareCtl.featureToShare = feature;
            const shareDiv = shareCtl.div;
            const link = shareCtl.generateLink();
            shareDiv.querySelector(".tc-url input[type=text]").value = link;
            shareDiv.querySelector(".tc-iframe input[type=text]").value = shareCtl.generateIframe(link);
        });
    };

    ctlProto.getFeatureTitle = function (feature) {
        const self = this;
        var result = "";
        if (feature) {
            result = feature.id;
        }
        return result;
    };

    ctlProto._getFeatureFilename = function (feature) {
        const self = this;
        const layerTitle = self.getFeatureTitle(feature).toString().replace(new RegExp(self.TITLE_SEPARATOR, 'g'), self.FILE_TITLE_SEPARATOR) || self.getLocaleString('feature');
        return layerTitle.toLowerCase().replace(/\s/gi, '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true);
    };

})();

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FileImport = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if (Array.isArray(self.options.formats)) {
        self.formats = self.options.formats;
    }
    else {
        self.formats = [
            TC.Consts.format.KML,
            TC.Consts.format.GML,
            TC.Consts.format.GML2,
            TC.Consts.format.GEOJSON,
            TC.Consts.format.WKT,
            TC.Consts.format.GPX
        ];
    }
    if (window.JSZip) {
        if (window.JSZip instanceof Promise)
            window.JSZip.then(function () {
                self.formats.splice(1, 0, TC.Consts.format.KMZ);
            });
        else
            self.formats.splice(1, 0, TC.Consts.format.KMZ);
    }

    self.layers = [];

    self.apiAttribution = '';
    self.mainDataAttribution = '';
    self.dataAttributions = [];

    self.exportsState = true;
};

TC.inherit(TC.control.FileImport, TC.Control);

(function () {
    var ctlProto = TC.control.FileImport.prototype;

    ctlProto.CLASS = 'tc-ctl-file';

    ctlProto.template = TC.apiLocation + "TC/templates/FileImport.html";

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.Control.prototype.register.call(self, map);

        if (self.options.enableDragAndDrop) {
            map.wrap.enableDragAndDrop(self.options);
        }

        map
            .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                const fileName = e.fileName;
                const target = e.dropTarget;
                const features = e.features;
                // Ignoramos los GPX (se supone que los gestionará Geolocation)
                var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();
                if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length || target !== self.map.div && target !== self) {
                    return;
                }
                
                map.addLayer({
                    id: self.getUID(),
                    title: fileName,
                    owner: self,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layers.push(layer);
                    var geogCrs = 'EPSG:4326';
                    const flatten = function (prev, cur) {
                        return prev.concat(cur);
                    };
                    var projectGeom = function (feature) {
                        var geom = feature.geometry;
                        if (geom) {
                            var coordinates;
                            switch (true) {
                                case TC.feature.Point && feature instanceof TC.feature.Point:
                                    coordinates = [geom];
                                    break;
                                case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                                case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                    coordinates = geom;
                                    break;
                                case TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:
                                case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                    coordinates = geom.reduce(flatten);
                                    break;
                                case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                                    coordinates = geom.reduce(flatten).reduce(flatten);
                                    break;
                                default:
                                    break;
                            }
                            if (coordinates && coordinates.every(function (coord) {
                                return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90; // Parecen geográficas
                            })) {
                                feature.setCoords(TC.Util.reproject(geom, geogCrs, self.map.crs));
                            }
                        }

                        return feature;
                    };

                    for (var i = 0, len = features.length; i < len; i++) {
                        var projectedFeature = projectGeom(features[i]);
                        layer.addFeature(projectedFeature);
                    }
                    setTimeout(function () {
                        map.zoomToFeatures(layer.features);
                    }, 100);
                });
            })
            .on(TC.Consts.event.FEATURESIMPORTERROR, function (e) {
                var dictKey;
                var fileName = e.file.name;
                if (fileName.toLowerCase().substr(fileName.length - 4) === '.kmz') {
                    dictKey = 'fileImport.error.reasonKmz';
                }
                else {
                    dictKey = 'fileImport.error.reasonUnknown';
                }

                TC.error(self.getLocaleString(dictKey, { fileName: fileName }), TC.Consts.msgErrorMode.TOAST);

                var reader = new FileReader();
                reader.onload = function (event) {
                    TC.error("Nombre del archivo: " + fileName + " \n Contenido del archivo: \n\n" + event.target.result, TC.Consts.msgErrorMode.EMAIL, "Error en la subida de un archivo");
                };
                reader.readAsText(e.file);
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                // Eliminamos la capa cuando ya no quedan features en ella
                const layer = e.layer;
                if (self.layers.indexOf(layer) >= 0) {
                    if (!layer.features.length) {
                        self.map.removeLayer(layer);
                    }
                }
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const idx = self.layers.indexOf(e.layer);
                if (idx >= 0) {
                    self.layers.splice(idx, 1);
                }
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ formats: self.formats }, function () {            
            const fileInput = self.div.querySelector('input[type=file]');
            // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
            fileInput.addEventListener(TC.Consts.event.CLICK, function (e) {
                const input = this;
                // Envolvemos el input en un form
                const form = document.createElement('form');
                const parent = input.parentElement;
                parent.insertBefore(form, input);
                form.appendChild(input);
                form.reset();
                // Desenvolvemos el input del form
                form.insertAdjacentElement('afterend', input);
                parent.removeChild(form);
            });
            fileInput.addEventListener('change', function (e) {
                if (self.map) {
                    console.log('salta el change');
                    self.map.wrap.loadFiles(e.target.files, { control: self });
                }
            });
        }));
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layers: self.layers.map(function (layer) {
                    return {
                        title: layer.title,
                        state: layer.exportState()
                    };
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            const layerPromises = [];
            state.layers.forEach(function (layerData) {
                layerPromises.push(self.map.addLayer({
                    id: self.getUID(),
                    title: layerData.title,
                    owner: self,
                    type: TC.Consts.layerType.VECTOR
                }));
            });

            Promise.all(layerPromises).then(function (layers) {
                for (var i = 0, len = layers.length; i < len; i++) {
                    const layer = layers[i];
                    layer.importState(state.layers[i].state);
                    self.layers.push(layer);
                }
            });
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FullScreen = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.FullScreen, TC.Control);

(function () {
    var ctlProto = TC.control.FullScreen.prototype;

    ctlProto.CLASS = 'tc-ctl-fscreen';

    ctlProto.template = TC.apiLocation + "TC/templates/FullScreen.html";

    const key = {
        fullscreenEnabled: 0,
        fullscreenElement: 1,
        requestFullscreen: 2,
        exitFullscreen: 3,
        fullscreenchange: 4,
        fullscreenerror: 5,
    };

    const webkit = [
        'webkitFullscreenEnabled',
        'webkitFullscreenElement',
        'webkitRequestFullscreen',
        'webkitExitFullscreen',
        'webkitfullscreenchange',
        'webkitfullscreenerror',
    ];

    const moz = [
        'mozFullScreenEnabled',
        'mozFullScreenElement',
        'mozRequestFullScreen',
        'mozCancelFullScreen',
        'mozfullscreenchange',
        'mozfullscreenerror',
    ];

    const ms = [
        'msFullscreenEnabled',
        'msFullscreenElement',
        'msRequestFullscreen',
        'msExitFullscreen',
        'MSFullscreenChange',
        'MSFullscreenError',
    ];

    const document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};

    const vendor = (
        ('fullscreenEnabled' in document && Object.keys(key)) ||
        (webkit[0] in document && webkit) ||
        (moz[0] in document && moz) ||
        (ms[0] in document && ms) ||
        []
    );

    ctlProto.fscreen = {
        inFullscreen: false,
        requestFullscreen: element => element[vendor[key.requestFullscreen]](),
        requestFullscreenFunction: element => element[vendor[key.requestFullscreen]],
        get exitFullscreen() { return document[vendor[key.exitFullscreen]].bind(document); },
        addEventListener: (type, handler, options) => document.addEventListener(vendor[key[type]], handler, options),
        removeEventListener: (type, handler, options) => document.removeEventListener(vendor[key[type]], handler, options),
        get fullscreenEnabled() { return Boolean(document[vendor[key.fullscreenEnabled]]); },
        set fullscreenEnabled(val) { },
        get fullscreenElement() { return document[vendor[key.fullscreenElement]]; },
        set fullscreenElement(val) { },
        get onfullscreenchange() { return document[("on" + vendor[key.fullscreenchange]).toLowerCase()]; },
        set onfullscreenchange(handler) { return document[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler; },
        get onfullscreenerror() { return document["on" + vendor[key.fullscreenerror].toLowerCase()]; },
        set onfullscreenerror(handler) { return document["on" + vendor[key.fullscreenerror].toLowerCase()] = handler; }
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        result.then(function () {
            const btn = self.div.querySelector('.' + self.CLASS + '-btn');
            
            if (self.fscreen.fullscreenEnabled) {                
                self.fscreen.addEventListener('fullscreenchange', function () {
                    self.fscreen.inFullscreen = self.fscreen.fullscreenElement !== null;
                    btn.classList.toggle(TC.Consts.classes.ACTIVE, self.fscreen.inFullscreen);
                    btn.setAttribute('title', self.fscreen.inFullscreen ? self.getLocaleString("fscreen.tip.return") : self.getLocaleString("fscreen.tip"));
                }, false);

                btn.addEventListener('click', function () {
                    if (!self.fscreen.inFullscreen) {
                        self.fscreen.requestFullscreen(self.map.div);
                    } else {
                        self.fscreen.exitFullscreen();
                    }
                }, false);

            } else {
                // GLS: 19/02/2019 en lugar de ocultar el botón, deshabilitamos el control para que no quede espacio de más entre los botones
                self.disable();
            }            
        });

        return result;
    };    

})();

(function () {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };
}());
(function () {
    var lastTime = 0,
        vendors = ['ms', 'moz', 'webkit', 'o'],
        // Feature check for performance (high-resolution timers)
        hasPerformance = !!(window.performance && window.performance.now);

    for (var x = 0, max = vendors.length; x < max && !window.requestAnimationFrame; x += 1) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }

    // Add new wrapper for browsers that don't have performance
    if (!hasPerformance) {
        // Store reference to existing rAF and initial startTime
        var rAF = window.requestAnimationFrame,
            startTime = +new Date;

        // Override window rAF to include wrapped callback
        window.requestAnimationFrame = function (callback, element) {
            // Wrap the given callback to pass in performance timestamp
            var wrapped = function (timestamp) {
                // Get performance-style timestamp
                var performanceTimestamp = (timestamp < 1e12) ? timestamp : timestamp - startTime;

                return callback(performanceTimestamp);
            };

            // Call original rAF with wrapped callback
            rAF(wrapped, element);
        }
    }
})();
(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Geolocation = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    self._layerPromises = {};

    self.Const = {
        Classes: {
            ACTIVE: 'tc-ctl-geolocation-active',
            CLOSED: 'closed',
            SELECTEDTRACK: 'selectedTrack',
            DRAWACTIVATED: 'draw-activated',
            SIMULATIONACTIVATED: 'simulation-activated'
        },
        Selector: {
            SIMULATE: '.tc-btn-simulate',
            DRAW: '.tc-draw',
            EDIT: '.tc-btn-edit',
            DELETE: '.tc-btn-delete',
            SAVE: '.tc-btn-save',
            CANCEL: '.tc-btn-cancel',
            EXPORT: '.tc-btn-export',
            STOP: '.tc-btn-stop',
            PAUSE: '.tc-btn-pause',
            BACKWARD: '.tc-btn-backward',
            FORWARD: '.tc-btn-forward',
            SPEED: '.tc-spn-speed'
        },
        LocalStorageKey: {
            TRACKING: 'trk',
            TRACKINGTEMP: 'trktemp',
            TRACKINGSHOWADVERTISEMENT: 'trkAdvertisement',
            GPSSHOWADVERTISEMENT: 'gpsAdvertisement',
            TEST: 'test'
        },
        Message: {
            VALIDATENAME: '',
        },
        Event: {
            POSITIONCHANGE: 'positionchange.tc.geolocation',
            GPSPOSITIONCHANGE: 'gpspositionchange.tc.geolocation',
            GPSPOSITIONERROR: 'positionerror.tc.geolocation',
            STATEUPDATED: 'stateupdated.tc.geolocation',
            GPSADD: 'gpsadd.tc.geolocation',
            TRACKSNAPPING: 'tracksnapping.tc.geolocation',
            DRAWTRACK: 'drawtrack.tc.geolocation',
            CLEARTRACK: 'cleartrack.tc.geolocation',
            IMPORTEDTRACK: 'importedtrack.tc.geolocation'
        },
        MimeMap: {
            KML: 'application/vnd.google-earth.kml+xml',
            GPX: 'application/gpx+xml'
        },
        SupportedFileExtensions: [
            '.kml',
            '.gpx'
        ],
        Tabs: {
            GPS: "gps"
        },
        Layers: {
            GPS: "gps",
            TRACK: "track",
            TRACKING: "tracking"
        }
    };

    TC.Control.apply(self, arguments);

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
    self.delta = 500;
    self.walkingSpeed = 5000;
    self.gapHill = self.options.gapHill || 20;

    self.snappingTolerance = self.options.snappingTolerance || 50;

    self.exportsState = true;

    self.storageCRS = 'EPSG:4326';
};

TC.inherit(TC.control.Geolocation, TC.Control);

(function () {
    var ctlProto = TC.control.Geolocation.prototype;

    ctlProto.CLASS = 'tc-ctl-geolocation';

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 300,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    ctlProto.featuresToShare = [];

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';
    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Geolocation.html";
    ctlProto.template[ctlProto.CLASS + '-track-node'] = TC.apiLocation + "TC/templates/GeolocationTrackNode.html";
    ctlProto.template[ctlProto.CLASS + '-track-snapping-node'] = TC.apiLocation + "TC/templates/GeolocationTrackSnappingNode.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/GeolocationDialog.html";
    ctlProto.template[ctlProto.CLASS + '-tracking-toast'] = TC.apiLocation + "TC/templates/GeolocationTrackingToast.html";

    var onFeatureRemove = function (e) {
        const self = this;
        const layer = e.layer;

        if (e.layer === self.layerTrack) {
            self.clearSelection();
        }
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.wrap = new TC.wrap.control.Geolocation(self);
        self.wrap.register(map);

        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            owner: self,
            stealth: true,
            title: 'Posicionar.GPS',
        }).then(function (layer) {
            self.layerGPS = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            owner: self,
            stealth: true,
            title: 'Posicionar.Tracking',
            styles: {
                point: {
                    radius: 3,
                    fillColor: "#00ced1",
                    fillOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeColor: "#ffffff",
                    fontColor: "#00ced1",
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 1,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                },
                line: {
                    strokeOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeWidth: 2,
                    strokeColor: "#00ced1",
                    lineDash: [.1, 6]
                }
            }
        }).then(function (layer) {
            self.layerTracking = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            owner: self,
            stealth: true,
            title: 'Posicionar.Track',
            styles: {
                line: {
                    strokeWidth: 2,
                    strokeColor: "#C52737"
                },
                point: {
                    radius: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            return 3;
                        } else {
                            return 6;
                        }

                        return 3;
                    },
                    fillColor: "#C52737",
                    strokeColor: "#ffffff",
                    fontColor: "#C52737",
                    fontSize: 10,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                }
            }
        }).then(function (layer) {
            self.layerTrack = layer;
        });

        map.on(TC.Consts.event.FEATURESIMPORT, function (e) {
            const self = this;
            const fileName = e.fileName;
            const target = e.dropTarget;
            var kmlPattern = '.' + TC.Consts.format.KML.toLowerCase();
            var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();

            // GLS: ¿es un GPX?
            if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length ||
                // GLS: ¿es un KML y viene desde el upload de Geolocation?
                (fileName.toLowerCase().indexOf(kmlPattern) === fileName.length - kmlPattern.length && target === self)) {

                self.clear(self.Const.Layers.TRACK);
                self.importTrack(e);

                if (/.kml$/g.test(fileName.toLowerCase()) && self.layerTrack) {
                    if (self.layerTrack.styles) {
                        self.layerTrack.features.forEach(function (feature) {
                            if (feature instanceof TC.feature.Point && self.layerTrack.styles.point) {
                                feature.setStyle(self.layerTrack.styles.point);
                            } else if (feature instanceof TC.feature.Polyline && self.layerTrack.styles.line) {
                                feature.setStyle(self.layerTrack.styles.line);
                            }
                        });
                    }
                }
            } else {
                //GLS: si es un KML pero viene desde el mapa o es otro tipo de archivo que no es ni GPX ni KML, lo ignoramos
                return;
            }
        }.bind(self));

        map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
            if (self.elevationChartData) {
                self.elevationChartData.coords = TC.Util.reproject(self.elevationChartData.coords, e.oldCrs, e.newCrs);
            }
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return self.renderData({ controlId: self.id }, callback);
        });
    };

    ctlProto.importTrack = function (options) {
        var self = this;

        self.map.off(TC.Consts.event.FEATUREREMOVE, onFeatureRemove);

        if (!self.isDisabled) {
            if (options.fileName && options.features && options.features.length > 0) {

                var wait = self.getLoadingIndicator().addWait();
                self.importedFileName = options.fileName;
                const addPromises = [];
                for (var i = 0, len = options.features.length; i < len; i++) {
                    addPromises.push(self.layerTrack.addFeature(options.features[i]));
                }
                Promise.all(addPromises).then(function () {

                    self.wrap.processImportedFeatures({ wait: wait, notReproject: options.notReproject });

                    if (self.layerTrack) { // Si tenemos capa es que todo ha ido bien y gestionamos el despliegue del control
                        // Desplegamos el control "ubicar" al importar mediante drag&drop
                        if (self.map && self.map.layout && self.map.layout.accordion) {
                            if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                self.map.controls
                                    .filter(function (ctl) {
                                        // Todos los otros controles que no cuelgan de otro control
                                        return ctl !== self && !ctl.containerControl;
                                    })
                                    .forEach(function (ctl) {
                                        ctl.div.classList.add(TC.Consts.classes.COLLAPSED);
                                    });
                            }
                        }

                        self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                        self.div.querySelector('.' + self.CLASS + '-btn-tracks > span').click();

                        if (!options.isShared) {
                            // abrimos el panel de herramientas
                            self.map.trigger(TC.Consts.event.TOOLSOPEN);
                        }
                    }
                });
            }
        } else if (/.gpx$/g.test(options.fileName.toLowerCase())) {
            self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
        }
    };

    ctlProto.prepareFeaturesToShare = function (trackUid) {
        const self = this;

        return new Promise(function (resolve, reject) {
            if (trackUid) {

                var storageData = self.availableTracks.filter(function (saved) {
                    return saved.uid.toString() === trackUid.toString();
                })[0].data;

                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                var storageFeatures = new ol.format.GeoJSON().readFeatures(storageData);
                const promises = new Array(storageFeatures.length);
                storageFeatures.forEach(function (f, idx) {
                    promises[idx] = TC.wrap.Feature.createFeature(f);
                });

                Promise.all(promises).then(function (tcFeatures) {
                    self.featuresToShare = tcFeatures.map(function (f) {
                        const fObj = {};
                        var layerStyle;
                        switch (true) {
                            case TC.feature.Marker && f instanceof TC.feature.Marker:
                                fObj.type = TC.Consts.geom.MARKER;
                                break;
                            case TC.feature.Point && f instanceof TC.feature.Point:
                                fObj.type = TC.Consts.geom.POINT;
                                break;
                            case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                                fObj.type = TC.Consts.geom.POLYLINE;
                                break;
                            case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                                fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                                break;
                        }
                        fObj.id = f.id;
                        fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                        fObj.data = f.getData();

                        return fObj;
                    });

                    resolve();
                });
            } else {
                resolve();
            }
        });


    };

    var visibilityTrack = true;
    ctlProto.renderData = function (data, callback) {
        const self = this;

        var sel = self.Const.Selector;

        return TC.Control.prototype.renderData.call(self, data, function () {

            const options = self.div.querySelectorAll(self._classSelector + '-panel');
            self.div.querySelectorAll('.' + self.CLASS + '-select span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, function (e) {
                    var label = e.target;
                    while (label && label.tagName !== 'LABEL') {
                        label = label.parentElement;
                    }
                    const newFormat = label.querySelector('input[type=radio][name=mode]').value;

                    options.forEach(function (option) {
                        option.classList.toggle(TC.Consts.classes.HIDDEN, !option.matches('.' + self.CLASS + '-' + newFormat));
                    });
                });
            });

            self.track = {
                activateButton: self.div.querySelector(self._classSelector + '-track-ui-activate'),
                deactivateButton: self.div.querySelector(self._classSelector + '-track-ui-deactivate'),
                trackSearch: self.div.querySelector(self._classSelector + '-track-available-srch'),
                trackImportFile: self.div.querySelector(self._classSelector + '-track-import'),
                trackSave: self.div.querySelector(self._classSelector + '-track-save'),
                trackAdd: self.div.querySelector(self._classSelector + '-track-add-wpt'),
                trackContinue: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-continue'),
                trackRenew: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-new'),
                trackClose: self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog button.tc-modal-close'),
                //trackAddSegment: self.div.querySelector('#tc-ctl-geolocation-track-segment'),
                trackAdvertisementOK: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-ok')
            };

            self.track.trackList = self.div.querySelector(self._classSelector + '-track-available-lst');

            self.track.trackToolPanelOpened = self.div.querySelector('#tc-ctl-geolocation-track-panel-opened-' + self.id);

            self.div.querySelector('.' + ctlProto.CLASS + '-track-panel-help').addEventListener('click', function () {
                _showAlerMsg.call(self);
            });

            self.track.trackName = self.div.querySelector(self._classSelector + '-track-title');

            self.track.trackWPT = self.div.querySelector(self._classSelector + '-track-waypoint');

            if (TC.Util.detectMobile()) {
                if (matchMedia('screen and (max-height: 50em) and (max-width: 50em)').matches)
                    self.track.trackToolPanelOpened.checked = false;
            }

            if (window.File && window.FileReader && window.FileList && window.Blob) {
                self.track.trackImportFile.disabled = false;
                // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
                self.track.trackImportFile.addEventListener(TC.Consts.event.CLICK, function (e) {
                    // Envolvemos el input en un form
                    const input = this;
                    const form = document.createElement('form');
                    const parent = input.parentElement;
                    parent.insertBefore(form, input);
                    form.appendChild(input);
                    form.reset();
                    // Desenvolvemos el input del form
                    form.insertAdjacentElement('afterend', input);
                    parent.removeChild(form);
                });

                const _layerError = function () {
                    self.map.off(TC.Consts.event.LAYERERROR, _layerError);
                    self.clearFileInput(self.track.trackImportFile);

                    TC.alert(self.getLocaleString("geo.trk.upload.error3"));
                };

                self.track.trackImportFile.addEventListener('change', function (e) {
                    if (!self._cleaning) { // Valido que el evento import no lo provoco yo al limpiar el fileinput (al limpiar se lanza el change)                        
                        self.clear(self.Const.Layers.TRACK);

                        if (self.map) {
                            self.map.on(TC.Consts.event.LAYERERROR, _layerError);
                            self.map.wrap.loadFiles(e.target.files, { control: self });
                        }
                    }
                });
            } else {
                console.log('no es posible la importación');
            }

            self.track.activateButton.addEventListener('click', function () {
                self.activateTracking();
                _activateTrackingBtns.call(self);

            });
            self.track.deactivateButton.addEventListener('click', function () {
                self.deactivateTracking();
                _deactivateTrackingBtns.call(self);
            });

            var _filter = function (searchTerm) {
                searchTerm = searchTerm.toLowerCase();
                //tc-ctl-geolocation-track-available-empty
                const lis = Array.from(self.track.trackList.querySelectorAll('li'));
                lis.forEach(function (li) {
                    li.style.display = 'none';
                });
                const trackLis = lis.filter(function (li) {
                    return li.matches('li:not([class]),li.' + self.Const.Classes.SELECTEDTRACK);
                });

                const searchIcon = self.div.querySelector(self._classSelector + '-track-search-icon');
                if (searchTerm.length === 0) {
                    trackLis.forEach(function (li) {
                        li.style.display = '';
                    });
                    searchIcon.style.visibility = 'visible';
                } else {
                    searchIcon.style.visibility = 'hidden';
                    var r = new RegExp(searchTerm, 'i');
                    trackLis.forEach(function (li) {
                        li.style.display = r.test(li.querySelector('span').textContent) ? '' : 'none';
                    });

                    if (!trackLis.some(function (li) {
                        return li.style.display === '';
                    })) {
                        lis.forEach(function (li) {
                            if (li.matches('[class^="tc-ctl-geolocation-track-not"]')) {
                                li.style.display = '';
                            }
                        });
                    }
                }
            };
            const trackSearchListener = function () {
                _filter(this.value.toLowerCase().trim());
            };
            self.track.trackSearch.addEventListener("keyup", trackSearchListener);
            self.track.trackSearch.addEventListener("search", trackSearchListener);

            // en el panel
            self.track.trackSave.addEventListener('click', self.saveTrack.bind(self));
            self.track.trackAdd.addEventListener('click', self.addWaypoint.bind(self));

            const list = self.div.querySelector(self._classSelector + '-track-available-lst');

            // en lista
            var _edit = function (edit, elm) {
                if (elm.tagName !== 'LI') {
                    elm = elm.parentElement;
                }

                const input = elm.querySelector('input');
                const span = elm.querySelector('span');

                if (edit) {

                    input.classList.remove(TC.Consts.classes.HIDDEN);
                    input.focus();
                    input.value = span.textContent;
                    span.classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT).classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.remove(TC.Consts.classes.HIDDEN);
                } else {

                    input.classList.add(TC.Consts.classes.HIDDEN);
                    span.classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT).classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.add(TC.Consts.classes.HIDDEN);
                }
            };

            self.uiSimulate = function (simulate, elm) {
                if (elm) {
                    var editControls = [
                        sel.SIMULATE,
                        sel.EDIT,
                        sel.DELETE,
                        sel.EXPORT
                    ];
                    var simulateControls = [
                        sel.STOP,
                        sel.PAUSE,
                        sel.BACKWARD,
                        sel.FORWARD,
                        sel.SPEED
                    ];
                    var cnt = elm.tagName === 'LI' ? elm : elm.parentNode;

                    editControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = simulate;
                    });

                    simulateControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = !simulate;
                    });
                }
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.SIMULATE, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';

                _loadTrack(self, e.target).then(function () { //Para evitar el bloqueo de la interfaz en móviles
                    self.getLoadingIndicator().removeWait(wait)
                });
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.DRAW, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                _drawTrack(self, e.target).then(function () {
                    self.getLoadingIndicator().removeWait(wait);
                });
            }));

            self.on(self.Const.Event.IMPORTEDTRACK, function (e) {
                if (!self.isDisabled) {
                    const listElement = self.track.trackList.querySelector('li[data-id="' + e.index + '"]');
                    _drawTrack(self, listElement.querySelector(sel.DRAW));
                    setTimeout(function () {
                        self.track.trackList.scrollTop = e.index * listElement.offsetHeight;
                    }, 100);
                } else {
                    self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
                }
            });

            const _stopOtherTracks = function (self, trackLiId) {
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (listItem) {
                    if (listItem.dataset.id !== trackLiId) {
                        const btnSimulate = listItem.querySelector(sel.SIMULATE);
                        const btnPause = listItem.querySelector(sel.PAUSE);

                        btnSimulate.classList.remove(self.Const.Classes.SIMULATIONACTIVATED);
                        btnSimulate.setAttribute('title', self.getLocaleString("tr.lst.simulate"));
                        btnPause.classList.remove('play');
                        btnPause.setAttribute('title', self.getLocaleString("tr.lst.pause"));

                        self.uiSimulate(false, listItem);
                        _edit(false, listItem);
                    }
                });

                self.clear(self.Const.Layers.TRACK);
            };

            var _drawTrack = function (self, btnDraw) {
                return new Promise(function (resolve, reject) {

                    const trackLi = btnDraw.parentElement;

                    setTimeout(function () {
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.uiSimulate(false, btnDraw);

                            self.clear(self.Const.Layers.TRACK);
                            self.map.off(TC.Consts.event.FEATUREREMOVE, onFeatureRemove);

                            btnDraw.setAttribute('title', btnDraw.textContent);
                        }
                        else if (self.getSelectedTrack()) { // GLS: si hay elemento seleccionado actuamos
                            _stopOtherTracks(self, trackLi.dataset.id);
                            self.drawTrack(trackLi);
                        } else {
                            self.drawTrack(trackLi);
                        }

                        /* GLS: 15/02/2019 Preparamos la feature por si se comparte, necesito hacerlo aquí 
                           porque la gestión en asíncrona y todo el flujo de exportación es síncrono */
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.prepareFeaturesToShare(trackLi.dataset.uid).then(function () {
                                resolve();
                            });
                        } else {
                            resolve();
                        }
                    }, 0);
                });
            };

            var _loadTrack = function (self, btnSimulate) {
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        const trackLi = btnSimulate.parentElement;

                        _stopOtherTracks(self, trackLi.dataset.id);
                        self.uiSimulate(false, self.getSelectedTrack());
                        self.uiSimulate(true, btnSimulate);

                        self.simulate_paused = false;
                        self.simulateTrack(trackLi);

                        resolve();
                    }, 0);
                });
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EDIT, function (e) {
                _edit(true, e.target);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.DELETE, function (e) {
                self.removeTrack(e.target.parentElement);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.SAVE, function (e) {
                var newName = e.target.parentElement.querySelector('input').value;
                if (newName.trim().length === 0) {
                    TC.alert(self.getLocaleString('geo.trk.edit.alert'));
                }
                else {
                    self.editTrackName(e.target.parentElement.dataset.id, e.target.parentElement.querySelector('input').value);
                    _edit(false, e.target);
                }
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.CANCEL, function (e) {
                _edit(false, e.target);
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EXPORT, function (e) {
                const parent = e.target.parentElement;
                e.target.setAttribute('disabled', "");

                self.export(parent).then((features) => {
                    self.getDownloadDialog().then(function (dialog) {
                        var filename = parent.querySelector('span').textContent;
                        var regex = new RegExp(self.Const.SupportedFileExtensions.join('|'), 'gi');
                        var cleanFilename = filename.replace(regex, '');
                        const options = {
                            title: self.getLocaleString('download'),
                            fileName: cleanFilename,
                            elevation: {
                                resolution: 20,
                                sampleNumber: 200
                            }                            
                        };
                        dialog.open(features, options);

                        e.target.removeAttribute('disabled');
                    });
                });
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.STOP, function (e) {
                self.uiSimulate(false, e.target);
                self.wrap.simulateTrackEnd();
                const btnPause = e.target.parentElement.querySelector(sel.PAUSE);
                btnPause.classList.remove('play');
                btnPause.setAttribute('title', self.getLocaleString('tr.lst.pause'));

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';
                self.simulate_speed = 1;
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.PAUSE, function (e) {
                self.simulate_paused = !e.target.classList.contains('play');
                if (self.simulate_paused)
                    self.simulate_pausedElapse = -1;

                e.target.setAttribute('title', self.getLocaleString(self.simulate_paused ? 'tr.lst.play' : 'tr.lst.pause'));
                e.target.classList.toggle('play', !!self.simulate_paused);
            }));

            var lapse = 0.5;
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.BACKWARD, function (e) {
                if (self.simulate_speed == 1)
                    self.simulate_speed = lapse;
                else self.simulate_speed = self.simulate_speed / 2;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.FORWARD).disabled = false;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                if (self.simulate_speed == 0.000244140625) {
                    e.target.disabled = true;
                }
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.FORWARD, function (e) {
                self.simulate_speed = self.simulate_speed / lapse;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.BACKWARD).disabled = false;

                if (self.simulate_speed == 4096) {
                    e.target.disabled = true;
                }
            }));


            // popup
            self.track.trackContinue.addEventListener('click', function () {
                // cerramos popup y continuamos con el track de session y almacenando en session
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackRenew.addEventListener('click', function () {
                // eliminamos el track actual de session - restablecemos el tracking
                delete self.sessionTracking;
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, undefined);
                localforage.removeItem(self.Const.LocalStorageKey.TRACKINGTEMP);
                // cerramos el popup
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackClose.addEventListener('click', function () {
                _deactivateTrackingBtns.call(self);
            });
            //self.track.trackAddSegment.addEventListener('click', function () {
            //    TC.alert('pendiente');
            //    // cerramos el popup
            //    TC.Util.closeModal();
            //});

            // popup advertencia
            self.track.trackAdvertisementOK.addEventListener('click', function () {

                const checkboxes = document.body.querySelectorAll('input[name*="Advertisement"]:checked');

                if (checkboxes.length > 0) {
                    const promise = new Promise(function (resolve, reject) {
                        if (window.localforage)
                            resolve();
                        else {
                            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                                resolve();
                            });
                        }
                    });

                    promise.then(function () {
                        localforage.setItem(checkboxes[0].getAttribute('name'), false);
                    });
                }

                TC.Util.closeModal();
            });

            self.track.renderTrack = document.querySelector('#tc-ctl-geolocation-track-render-' + self.id);
            self.track.renderTrack.addEventListener('change', function () {
                if (self.track.activateButton.classList.contains(TC.Consts.classes.HIDDEN)) {
                    self.layerTracking.setVisibility(this.checked);
                }

                visibilityTrack = this.checked;
            });

            if (window.localforage)
                self.bindTracks();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    self.bindTracks();
                });
            }

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        //var self = this;
        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Util.closeModal();
        self.clearSelection();
        self.deactivateTracking();
        //TC.Control.prototype.deactivate.call(self);
    };

    var _activateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.add(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.remove(TC.Consts.classes.HIDDEN);
    };

    var _deactivateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
    };

    var _showAlerMsg = function () {
        var self = this;
        self.map.toast(self.div.querySelector(".alert-warning").innerHTML, {
            duration: 10000
        });
    };

    ctlProto.markerStyle = {
        radius: 7,
        fillColor: [255, 0, 0, 100],
        strokeColor: [255, 255, 255, 255],
        strokeWidth: 2
    };

    ctlProto.lineStyle = {
        strokeWidth: 2,
        strokeColor: [0, 206, 209, 255]
    };

    ctlProto.setFormatInfoNewPosition = function (newPosition) {
        var self = this;

        var data = {};
        var locale = TC.Util.getMapLocale(self.map);

        if (self.map.on3DView) {
            var geoCoords = self.map.crs !== self.map.view3D.crs ? TC.Util.reproject(newPosition.position, self.map.crs, self.map.view3D.crs) : newPosition.position;
            data.x = geoCoords[0].toLocaleString(locale);
            data.y = geoCoords[1].toLocaleString(locale);

            data.mdt = Math.round(self.map.view3D.getHeightFromMDT(geoCoords)).toLocaleString(locale);

            data.isGeo = true;

        } else {
            data.x = Math.round(newPosition.position[0]).toLocaleString(locale);
            data.y = Math.round(newPosition.position[1]).toLocaleString(locale);
        }

        data.z = (Math.round(newPosition.altitude).toLocaleString(locale));
        data.accuracy = (Math.round(newPosition.accuracy).toLocaleString(locale));
        data.speed = newPosition.speed.toLocaleString(locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 });

        return data;
    };

    ctlProto.renderInfoNewPosition = function (d) {
        var self = this;

        self.getRenderedHtml(self.CLASS + '-tracking-toast', self.setFormatInfoNewPosition(d.pd), function (html) {

            if (!self.track.infoPanel) {
                self.track.infoPanel = true;

                var resultsPanelOptions = {
                    content: "table",
                    titles: {
                        main: self.getLocaleString("geo.mylocation"),
                        max: self.getLocaleString("geo.mylocation.show")
                    },
                    classes: {
                        collapsed: "tracking"
                    }
                };

                var ctlPromise;
                const addResultsPanelInfo = function (controlContainer) {
                    resultsPanelOptions.position = controlContainer.POSITION.RIGHT;
                    ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                };

                if (self.options.displayOn) {
                    var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                    if (!controlContainer) {
                        self.map.addControl(self.options.displayOn).then(addResultsPanelInfo);
                    } else {
                        addResultsPanelInfo(controlContainer);
                    }
                } else {
                    resultsPanelOptions.div = document.createElement('div');
                    self.map.div.appendChild(resultsPanelOptions.div);
                    ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                }

                ctlPromise.then(function (resultsPanelInfo) {
                    self.map.getControlsByClass('TC.control.ResultsPanel').filter(function (panel) {
                        return panel.content === "table" && panel !== resultsPanelInfo;
                    }).forEach(function (panel) {
                        panel.close();
                    });

                    self.track.infoPanel = resultsPanelInfo;

                    resultsPanelInfo.renderPromise().then(function () {
                        resultsPanelInfo.open(html);
                    });
                });
            } else if (typeof (self.track.infoPanel) !== "boolean" && !self.track.infoPanel.isMinimized()) {
                self.track.infoPanel.renderPromise().then(function () {
                    self.track.infoPanel.getTableContainer().innerHTML = html;
                    if (!self.track.infoPanel.isVisible()) {
                        self.track.infoPanel.doVisible();
                    }
                });
            }
        });
    };


    var duringTrackingToolsPanel = function () {
        var self = this;

        if (!self.track.trackToolPanelOpened.checked) {
            self.map.trigger(TC.Consts.event.TOOLSCLOSE);
        }
    };

    var _tracking = function () {
        var self = this;

        self.activate();

        _activateTrackingBtns.call(self);
        duringTrackingToolsPanel.call(self);

        self.on(self.Const.Event.POSITIONCHANGE, function (d) {

            self.currentPoint = d.pd;
            self.renderInfoNewPosition(d);

            self.track.trackName.disabled = false;
            self.track.trackSave.disabled = false;

            self.track.trackWPT.disabled = false;
            self.track.trackAdd.disabled = false;

            // cada vez que se registra una nueva posición almacenamos en sessionStorage
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);
        });
        self.on(self.Const.Event.STATEUPDATED, function (data) {
            //self.track.htmlMarker.setAttribute('src', data.moving ? 'layout/idena/img/geo-marker-heading.png' : 'layout/idena/img/geo-marker.png');
        });

        self.clear(self.Const.Layers.TRACKING);

        advertisement.call(self, self.Const.LocalStorageKey.TRACKINGSHOWADVERTISEMENT);

        self.wrap.setTracking(true);
    };

    /* inicio gestión suspensión de la pantalla en móviles */
    var _onpauseVideo;
    var addVideoKeepScreenOn = function () {
        var self = this;

        if (!self.videoScreenOn) {
            var media = {
                WebM: "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=",
                MP4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=="
            };

            self.videoScreenOn = document.createElement('video');
            self.videoScreenOn.setAttribute("loop", "");
            self.videoScreenOn.setAttribute("muted", "");
            self.videoScreenOn.setAttribute("webkit-playsinline", "");
            self.videoScreenOn.setAttribute("playsinline", "");
            self.videoScreenOn.setAttribute("style", "transform: translateZ(0px);");

            var sourceWebM = document.createElement('source');
            sourceWebM.src = media.WebM;
            sourceWebM.type = "video/webm";
            self.videoScreenOn.appendChild(sourceWebM);

            var sourceMP4 = document.createElement('source');
            sourceMP4.src = media.MP4;
            sourceMP4.type = "video/mp4";
            self.videoScreenOn.appendChild(sourceMP4);
        }

        self.videoScreenOn.play();
    };
    var removeVideoKeepScreenOn = function () {
        var self = this;
        if (self.videoScreenOn) {
            self.videoScreenOn.pause();
        }
    };

    var _onWindowBlurred;
    var onWindowBlurred = function () {
        var self = this;

        fromSessionToStorage.apply(self);
    };

    var _onWindowFocused;
    var onWindowFocused = function () {
        var self = this;

        if (self.videoScreenOn.paused)
            self.videoScreenOn.play();

        fromStorageToSession.apply(self);
    };

    var getHiddenProperty = function () {
        var prefixes = ['webkit', 'moz', 'ms', 'o'];

        if ('hidden' in document) return 'hidden';

        for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document)
                return prefixes[i] + 'Hidden';
        }

        return null;
    };
    var _onWindowVisibility;
    var onWindowVisibility = function () {
        var self = this;

        var hidden = getHiddenProperty();

        if (!document[hidden])
            onWindowFocused.apply(self);

        console.log('video is: ' + self.videoScreenOn.paused);
    };
    var addWindowEvents = function () {
        var self = this;

        if (!_onWindowVisibility)
            _onWindowVisibility = onWindowVisibility.bind(self);

        if (!_onWindowBlurred)
            _onWindowBlurred = onWindowBlurred.bind(self);

        if (!_onWindowFocused)
            _onWindowFocused = onWindowFocused.bind(self);

        window.addEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && TC.browserFeatures.touch() && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.addEventListener('pagehide', _onWindowBlurred, false);
            window.addEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.addEventListener('blur', _onWindowBlurred, false);
            window.addEventListener('focus', _onWindowFocused, false);
        }
    }
    var removeWindowEvents = function () {

        window.removeEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && TC.browserFeatures.touch() && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.removeEventListener('pagehide', _onWindowBlurred, false);
            window.removeEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.removeEventListener('blur', _onWindowBlurred, false);
            window.removeEventListener('focus', _onWindowFocused, false);
        }
    };

    var fromSessionToStorage = function () {
        var self = this;

        var sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
        if (sessionTracking && sessionTracking.length > 0)
            localforage.setItem(self.Const.LocalStorageKey.TRACKINGTEMP, typeof (sessionTracking) === "string" ? sessionTracking : JSON.stringify(sessionTracking));
    };
    var fromStorageToSession = function () {
        var self = this;

        localforage.getItem(self.Const.LocalStorageKey.TRACKINGTEMP).then(function (storageData) {
            if (storageData !== null && storageData !== "null" && storageData.length > 0) {
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, storageData);
            }
        });
    };
    /* final gestión suspensión de la pantalla en móviles */

    var advertisement = function (showAdvertisement) {
        var self = this;

        var done = new Promise(function (resolve, reject) {
            if (window.localforage)
                resolve();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    resolve();
                });
            }
        });

        done.then(function () {
            localforage.getItem(showAdvertisement).then(function (registeredShowAdvertisement) {
                if (registeredShowAdvertisement == null) {
                    const dialog = self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog');
                    const checkbox = dialog.querySelector('input[type="checkbox"]');
                    checkbox.setAttribute('name', showAdvertisement);
                    checkbox.checked = false;

                    document.querySelector('#pageBlurMsg').textContent = TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur') : self.getLocaleString('geo.trk.page.blur.desktop');

                    dialog.querySelector('h3').textContent = showAdvertisement == self.Const.LocalStorageKey.GPSSHOWADVERTISEMENT ?
                        self.getLocaleString("geo.track.activate") + " " + self.getLocaleString("geo.gps") :
                        self.getLocaleString('geo.track.activate.title');

                    TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog'));
                }
            });
        });

        self.map.toast(!TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur.desktop') : self.getLocaleString('geo.trk.page.blur'), {
            type: TC.Consts.msgType.WARNING
        });
    };

    ctlProto._askTracking = function (callback) {
        var self = this;

        TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog'), {
            closeCallback: function () {

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            }
        });

        return true;
    };

    ctlProto.activateTracking = function () {
        var self = this;
        var trackingAvailable = true;

        if (!self.isActive) {
            self.activate();
        }

        self.clear(self.Const.Layers.TRACKING);

        try {
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TEST, self.Const.LocalStorageKey.TEST);
        } catch (error) {
            if (error.code === DOMException.QUOTA_EXCEEDED_ERR)
                TC.alert(self.getLocaleString("geo.error.trackinglocalstorage"));
            else TC.error(error);

            trackingAvailable = false;
        }

        if (trackingAvailable) {
            addVideoKeepScreenOn.apply(self);
            addWindowEvents.apply(self);

            self.sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
            if (self.sessionTracking) {
                var asked = self._askTracking(function () {
                    _deactivateTrackingBtns.call(self);
                });

                if (!asked) {
                    self.track.trackRenew.click();
                }
            } else _tracking.call(self);
        } else { _deactivateTrackingBtns.call(self); }
    };

    ctlProto.deactivateTracking = function () {
        var self = this;

        var _deactivateTracking = function () {

            self.track.infoPanel.close();

            fromSessionToStorage.apply(self);

            self.wrap.setTracking(false);


            delete self.geopositionTracking;

            if (!visibilityTrack) {
                self.div.querySelector(self._classSelector + '-track-render').querySelector('label').click();
            }

            removeVideoKeepScreenOn.apply(self);
            removeWindowEvents.apply(self);

            self.off(self.Const.Event.POSITIONCHANGE);
            self.off(self.Const.Event.STATEUPDATED);

            _deactivateTrackingBtns.call(self);

            self.track.trackName.value = '';
            self.track.trackName.disabled = true;
            self.track.trackSave.disabled = true;

            self.track.trackWPT.value = '';
            self.track.trackWPT.disabled = true;
            self.track.trackAdd.disabled = true;

            self.clear(self.Const.Layers.TRACKING);
            self.clear(self.Const.Layers.GPS);

            //TC.Control.prototype.deactivate.call(self);

            return true;
        };

        if (self.wrap.hasCoordinates()) {
            self.map.toast(self.getLocaleString("geo.trk.deactivate.alert"), {
                duration: 10000
            });
            //TC.alert(self.getLocaleString("geo.trk.deactivate.alert"));
            return _deactivateTracking();
        } else return _deactivateTracking();
    };

    /* Obtengo los tracks desde localForage */
    ctlProto.getStoredTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            var tracks = [];

            localforage.keys().then(function (keys) {
                keys = keys.filter(function (k) {
                    if (!(k.indexOf(self.Const.LocalStorageKey.TRACKINGTEMP) === 0) && k.indexOf(self.Const.LocalStorageKey.TRACKING) === 0) {
                        return /trk#\d/i.exec(k);
                    }
                    return false;
                });

                if (keys.length == 0) {
                    self.availableTracks = tracks;
                    resolve(tracks);
                }

                const promises = new Array(keys.length);
                keys.forEach(function (key, idx) {
                    promises[idx] = new Promise(function (res, rej) {
                        localforage.getItem(key, function (e, v) {
                            res(v);
                        });
                    });
                });

                Promise.all(promises).then(function (results) {
                    if (results && results.length) {
                        results.forEach(function (r) {
                            var r = JSON.parse(r);
                            if (r instanceof Array) {
                                tracks = tracks.concat(r);
                            } else {
                                tracks.push(r);
                            }
                        });

                        var tracksArray = tracks.length > 1 ? _orderTracks(tracks) : tracks;
                        self.availableTracks = tracksArray;
                        resolve(tracksArray);
                    }
                });
            });
        });
    };

    /**
     * Recibe una sucesión de tracks y la ordena por nombre.
     */
    var _orderTracks = function (tracks) {
        var tracksArray = [];

        for (var index in tracks) {
            if (tracks[index] && typeof (tracks[index]) === "object") {
                tracksArray.push(tracks[index]);
                tracksArray.sort(function (a, b) {
                    if (typeof (a.name) === "string") {
                        return TC.Util.isFunction(a.name.localeCompare) ? a.name.localeCompare(b.name) : 0;
                    } else { return 0; }
                });
            }
        }

        return tracksArray;
    };

    /* Almaceno los tracks mediante localForage, actualizo la vble availableTracks y actualizo la lista de tracks */
    ctlProto.setStoredTracks = function (tracks) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const promises = [];
            tracks.forEach(function (t) {
                promises.push(new Promise(function (res, rej) {
                    localforage.setItem(self.Const.LocalStorageKey.TRACKING + "#" + t.uid, JSON.stringify(t), function (e, v) {
                        res(v);
                    });
                }));
            });

            Promise.all(promises).then(function () {
                self.getStoredTracks().then(function () {
                    self.bindTracks();
                    resolve();
                });
            });
        });
    };

    /* Obtengo los tracks desde vble local */
    ctlProto.getAvailableTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (!self.availableTracks) {
                self.getStoredTracks().then(function (availableTracks) {
                    resolve(availableTracks);
                });
            }
            else {
                resolve(self.availableTracks);
            }
        });
    };

    ctlProto.bindTracks = function () {
        var self = this;

        const listItems = self.track.trackList.querySelectorAll('li');
        listItems.forEach(function (li) {
            li.style.display = 'none';
        });

        self.getAvailableTracks().then(function (tracks) {

            if (_isEmpty(tracks)) {
                self.track.trackList.querySelectorAll('li[class^="tc-ctl-geolocation-track-available-empty"]').forEach(function (li) {
                    li.style.display = '';
                });
                self.track.trackSearch.disabled = true;
            }
            else {
                const currentSelectedTrack = self.getSelectedTrack();
                var currentSelectedTrackId;
                if (currentSelectedTrack) {
                    currentSelectedTrackId = currentSelectedTrack.dataset.uid
                }
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (li) {
                    self.track.trackList.removeChild(li);
                });

                for (var i = 0; i < tracks.length; i++) {
                    var t = tracks[i];
                    if (typeof (t) === "object") {
                        self.getRenderedHtml(self.CLASS + '-track-node', {
                            id: i, uid: t.uid, name: t.name ? t.name.trim() : ''
                        }, function (html) {
                            const parser = new DOMParser();
                            const newLi = parser.parseFromString(html, 'text/html').body.firstChild;
                            self.track.trackList.appendChild(newLi);
                        });
                    }
                }

                if (currentSelectedTrackId) {
                    self.setSelectedTrack(self.track.trackList.querySelector('li[data-uid="' + currentSelectedTrackId + '"]'));
                }

                self.track.trackSearch.disabled = false;
            }
        });
    };

    ctlProto.chartProgressInit = function () {
        const self = this;

        if (!window.d3) {
            TC.syncLoadJS(TC.Consts.url.D3C3);
        }

        const dataDiv = d3.select(".c3-event-rects,.c3-event-rects-single").node().getBoundingClientRect();
        self.miDiv = document.createElement('div');
        self.miDiv.classList.add('miDiv');
        self.miDiv.style.width = dataDiv.width + 'px';
        self.miDiv.style.height = dataDiv.height + 'px';

        self.miProgressDiv = document.createElement('div');
        self.miProgressDiv.classList.add(
            'miProgressDiv',
            self.CLASS + '-track-elevation-chart-progress',
            TC.Consts.classes.HIDDEN);
        self.miProgressDiv.style.width = '0%';
        self.miProgressDiv.style.height = dataDiv.height + 'px';

        self.miProgressTextDiv = document.createElement('div');
        self.miProgressTextDiv.classList.add(
            'miProgressTextDiv',
            'tc-ctl-geolocation-track-elevation-chart-progress',
            'text');
        self.miProgressTextDiv.style.width = dataDiv.width + 'px';
        self.miProgressTextDiv.style.height = dataDiv.height + 'px';

        self.miDiv.style.top = dataDiv.top + 'px';
        self.miDiv.style.left = dataDiv.left + 'px';
        self.miDiv.style.bottom = dataDiv.bottom + 'px';
        self.miDiv.style.right = dataDiv.right + 'px';
        self.miDiv.style.position = 'absolute';
        self.miDiv.style.zIndex = 10008;
        self.miDiv.style.display = 'none';

        self.miProgressDiv.appendChild(self.miProgressTextDiv);
        self.miDiv.appendChild(self.miProgressDiv);
        document.body.appendChild(self.miDiv);

    };

    ctlProto.chartProgressClear = function () {
        const self = this;
        if (self.miDiv) {
            self.miDiv.parentElement.removeChild(self.miDiv);
            self.miDiv = null;
            self.miProgressDiv = null;
            self.miProgressTextDiv = null;
        }
    };

    ctlProto.chartSetProgress = function (previous, current, distance, doneTime) {
        var self = this;

        if (self.miDiv && self.miDiv.style.display === 'none') {
            self.miDiv.style.display = '';
        }
        
        self.miProgressDiv.classList.remove(TC.Consts.classes.HIDDEN);

        var done = previous.d;
        var progress = (done + Math.hypot(previous.p[0] - current[0], previous.p[1] - current[1])) / distance * 100;

        self.miProgressDiv.style.width = progress + '%';

        var locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
        var ele = parseInt(current[2].toFixed(0)).toLocaleString(locale);
        var dist;
        var measure;
        if ((done / 1000) < 1) {
            dist = Math.round((done / 1000) * 1000);
            measure = ' m';
        } else {
            dist = Math.round((done / 1000) * 100) / 100;
            measure = ' km';
        }

        dist = dist.toLocaleString(locale);

        self.miProgressTextDiv.innerHTML = '<div><span>' + ele + ' m' + '</span>' + '<br>' + '<span>' + dist + measure + '</span></div>' + (doneTime ? '<br><span>' + doneTime.toString + '</span>' : '');

    };

    ctlProto._getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.simulateTrack = function (li) {
        var self = this;

        self.simulate_speed = 1;

        self.drawTrack(li, false).then(function () {
            self.wrap.simulateTrack();
        });
    };

    ctlProto.drawTrack = function (li, activateSnapping) {
        var self = this;

        duringTrackingToolsPanel.call(self);
        return new Promise(function (resolve, reject) {
            self.setSelectedTrack(li);
            self.drawTrackingData(li).then(function () {
                self.elevationTrack(li).then(() => {
                    self.activate();

                    resolve();
                }); 
            });
        });
    };


    ctlProto.elevationTrack = function (li, resized) {
        var self = this;

        return new Promise((resolve, reject) => {
            const setCurrentFeature = function () {
                if (self.resultsPanelChart) {
                    self.resultsPanelChart.currentFeature = self.layerTrack.features.filter((feature) => {
                        return !(TC.feature.Marker && feature instanceof TC.feature.Marker) && !(TC.feature.Point && feature instanceof TC.feature.Point)
                    })[0];
                }
            };

            if (resized) {

                self.wrap.simulateTrackEnd();
                self.uiSimulate(false, li);
                return;
            }

            if (!self.onResize) {
                self.onResize = self.elevationTrack.bind(self, li, true);
                window.addEventListener("resize", self.onResize, false);
            }

            let chartCoordinates = [];

            if (self.track.elevationChart)
                self.track.elevationChart = self.track.elevationChart.destroy();

            var getChartData = function (li) {
                return new Promise(function (resolve, reject) {
                    TC.loadJS(
                        !TC.tool || !TC.tool.Elevation,
                        TC.apiLocation + 'TC/tool/Elevation',
                        function () {
                            self.getTrackingData(li).then(function (track) {
                                var geoJSON = track.data;
                                if (geoJSON) {
                                    var x, ele; x = []; ele = [];
                                    var empty = true;
                                    var minEle, maxEle;
                                    var elevationGain = {};
                                    var time = {};
                                    var km = 0;
                                    var geom;

                                    var f = (new ol.format.GeoJSON()).readFeatures(geoJSON);

                                    var getDistance = function () {
                                        if (geom.getLayout() == ol.geom.GeometryLayout.XYZ ||
                                            geom.getLayout() == ol.geom.GeometryLayout.XYZM) {
                                            var distance = 0;
                                            if (self.map.crs !== self.map.options.utmCrs) {
                                                line = new ol.geom.LineString(TC.Util.reproject(geom.getCoordinates(), self.map.crs, self.map.options.utmCrs));
                                                distance = line.getLength();
                                            } else {
                                                distance = geom.getLength();
                                            }
                                            return parseFloat((distance / 1000).toFixed(2));
                                        }

                                        return null;
                                    };
                                    var getTime = function () {
                                        if (geom.getLayout() == ol.geom.GeometryLayout.XYZM ||
                                            geom.getLayout() == ol.geom.GeometryLayout.XYM) {
                                            var diff = geom.getLastCoordinate()[3] - geom.getFirstCoordinate()[3];
                                            return {
                                                s: Math.floor((diff / 1000) % 60),
                                                m: Math.floor(((diff / (1000 * 60)) % 60)),
                                                h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
                                            };
                                        }

                                        return null;
                                    };

                                    var addX = function (x) {
                                        if (chartCoordinates.length > 0) {
                                            var distance = 0;
                                            chartCoordinates
                                                .forEach(function (point, idx, arr) {
                                                    var prev = idx === 0 ? point : arr[idx - 1];

                                                    if (self.map.crs !== self.map.options.utmCrs) {
                                                        point = TC.Util.reproject(point, self.map.crs, self.map.options.utmCrs);
                                                        prev = TC.Util.reproject(prev, self.map.crs, self.map.options.utmCrs);
                                                    }

                                                    const dx = point[0] - prev[0];
                                                    const dy = point[1] - prev[1];
                                                    distance += Math.sqrt(dx * dx + dy * dy);

                                                    x.push(parseFloat(distance.toFixed(2)));
                                                });
                                        }
                                    };

                                    var addElevation = function (ele) {
                                        var y = [];
                                        for (var i = 0; i < chartCoordinates.length; i++) {
                                            if (chartCoordinates[i].length > 2) {
                                                var v = (Math.round(chartCoordinates[i][2] * 10) / 10);
                                                if (empty && v > 0)
                                                    empty = false;

                                                ele.push(v);

                                                if (i == 0)
                                                    minEle = maxEle = v;

                                                minEle = Math.min(minEle, v);
                                                maxEle = Math.max(maxEle, v);

                                            }
                                            else {
                                                resolve(null);
                                                return;
                                            }
                                        }
                                    };

                                    f.filter(function (feature) {
                                        return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
                                    }).forEach(function (feature) {
                                        geom = feature.getGeometry();

                                        switch (geom.getType().toLowerCase()) {
                                            case 'linestring':

                                                if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                    track.layout === ol.geom.GeometryLayout.XYZ) {

                                                    time = getTime(geom);
                                                    km = getDistance(geom);
                                                    elevationGain = TC.tool.Elevation.getElevationGain({ coords: geom.getCoordinates(), hillDeltaThreshold: self.gapHill });
                                                    chartCoordinates = chartCoordinates.concat(geom.getCoordinates());

                                                    addX(x);
                                                    addElevation(ele);
                                                }
                                                break;
                                            case 'multilinestring':

                                                if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                    track.layout === ol.geom.GeometryLayout.XYZ) {

                                                    var _time;
                                                    var ls = geom.getLineStrings();
                                                    for (var i = 0; i < ls.length; i++) {
                                                        km = km + getDistance(ls[i]);

                                                        if (ls[i].getLayout() == ol.geom.GeometryLayout.XYZM)
                                                            _time = _time + (ls[i].getLastCoordinate()[3] - ls[i].getFirstCoordinate()[3]);

                                                        chartCoordinates = chartCoordinates.concat(ls[i].getCoordinates());

                                                        if (_time) { time = getTime(_time); }

                                                        addX(x);
                                                        addElevation(ele);
                                                    }
                                                }

                                                break;
                                            default:
                                                return null;
                                                break;
                                        }
                                    });

                                    if (ele instanceof Array && ele.length == 0) {
                                        empty = true;
                                    }

                                    self.elevationChartData = !empty ? TC.Util.extend({}, { time: time, ele: ele, x: x, miny: minEle, maxy: maxEle }, elevationGain) : null;

                                    resolve(self.elevationChartData);
                                    return;
                                }

                                resolve(null);
                                return;
                            });
                        }
                    );
                });
            };

            getChartData(li).then(function (data) {
                if (data != null) {
                    if (data.time) data.time = ("00000" + data.time.h).slice(-2) + ':' + ("00000" + data.time.m).slice(-2) + ':' + ("00000" + data.time.s).slice(-2);
                    data.coords = chartCoordinates;
                    self.hasElevation = true;
                }
                else {
                    self.hasElevation = false;
                    data = {
                        msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                    };
                }

                data.minHeight = self.CHART_SIZE.MIN_HEIGHT;
                data.maxHeight = self.CHART_SIZE.MAX_HEIGHT;

                data.minWidth = self.CHART_SIZE.MIN_WIDTH;
                data.mediumWidth = self.CHART_SIZE.MEDIUM_WIDTH;
                data.maxWidth = self.CHART_SIZE.MAX_WIDTH;

                self.map.one(TC.Consts.event.DRAWCHART, function (e) {
                    self.chartProgressInit();
                    resolve();
                });

                if (!self.resultsPanelChart) {

                    if (!window.c3) {
                        TC.syncLoadJS(TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js');
                    }

                    var resultsPanelOptions = {
                        content: "chart",
                        titles: {
                            main: self.getLocaleString("geo.trk.chart.chpe"),
                            max: self.getLocaleString("geo.trk.chart.chpe")
                        },
                        openOn: self.Const.Event.DRAWTRACK,
                        closeOn: self.Const.Event.CLEARTRACK,
                        chart: {
                            ctx: self,
                            onmouseout: ctlProto.removeElevationTooltip,
                            tooltip: ctlProto.getElevationTooltip
                        }
                    };

                    var ctlPromise;
                    const addResultsPanelChart = function (controlContainer) {
                        resultsPanelOptions.position = controlContainer.POSITION.RIGHT;
                        ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                    };

                    if (self.options.displayOn) {
                        var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                        if (!controlContainer) {
                            self.map.addControl(self.options.displayOn).then(addResultsPanelChart);
                        } else {
                            addResultsPanelChart(controlContainer);
                        }
                    } else {
                        resultsPanelOptions.div = document.createElement('div');
                        self.map.div.appendChild(resultsPanelOptions.div);
                        ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                    }

                    ctlPromise.then(function (resultsPanelChart) {
                        resultsPanelChart.caller = self;
                        self.resultsPanelChart = resultsPanelChart;

                        setCurrentFeature();
                        resultsPanelChart.renderPromise().then(function () {

                            resultsPanelChart.activateSnapping = function (e) {
                                if (self.layerTrack && (!self.layerTrack.getVisibility() && self.layerTrack.getOpacity() == 0))
                                    self.wrap.deactivateSnapping.call(self.wrap);
                            };
                            resultsPanelChart.deactivateSnapping = function (e) {
                                if (self.layerTrack && self.layerTrack.getVisibility() && self.layerTrack.getOpacity() > 0)
                                    self.wrap.activateSnapping.call(self.wrap);
                            };

                            resultsPanelChart.div.addEventListener('mouseover', resultsPanelChart.deactivateSnapping);
                            resultsPanelChart.div.addEventListener('mouseout', resultsPanelChart.activateSnapping);

                            self.map
                                .on(TC.Consts.event.RESULTSPANELMIN, function () {
                                    if (self.miDiv) {
                                        self.miDiv.style.display = 'none';
                                    }
                                })
                                .on(TC.Consts.event.RESULTSPANELMAX, function () {
                                    if (self.miDiv) {
                                        self.miDiv.style.display = '';
                                    }
                                })
                                .on(TC.Consts.event.RESULTSPANELCLOSE, function () {
                                    if (self.miDiv) {
                                        self.miDiv.style.display = 'none';
                                    }
                                });

                            self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
                        });
                    });
                } else {
                    setCurrentFeature();
                    self.resultsPanelChart.open();
                    self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
                }

                // 10/02/2020 gestionamos el borrado desde featureTools
                onFeatureRemove = onFeatureRemove.bind(self);
                self.map.on(TC.Consts.event.FEATUREREMOVE, onFeatureRemove);
            });
        });        
    };

    ctlProto.clear = function (layerType) {
        var self = this;

        if (self.onResize) {
            window.removeEventListener("resize", self.onResize, false);
            self.onResize = undefined;
        }

        if (layerType == self.Const.Layers.TRACK) {

            self.layerTrack.clearFeatures();

            // gráfico perfil de elevación
            if (self.resultsPanelChart)
                self.resultsPanelChart.close();
            delete self.elevationChartData;

            // overlay de la simulación
            self.wrap.simulateTrackEnd();

            self.wrap.clear();

            // eliminamos la selección en la lista de tracks
            self.track.trackList.querySelectorAll('li').forEach(function (li) {
                li.classList.remove(self.Const.Classes.SELECTEDTRACK);
            });

            self.map.trigger(self.Const.Event.CLEARTRACK);

            self.featuresToShare = [];

            //TC.Control.prototype.deactivate.call(self);

        } else {
            self.layerTracking.clearFeatures();
            self.layerGPS.clearFeatures();
        }
    };

    ctlProto.saveTrack = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var message = options.message || self.getLocaleString("geo.trk.save.alert");

            var _save = function (layer) {
                var wait;
                wait = self.getLoadingIndicator().addWait();

                var trackName = options.importedFileName || self.track.trackName.value.trim();

                var tracks = self.availableTracks;
                if (!tracks) {
                    tracks = [];
                }

                var formatted = self.wrap.formattedToStorage(layer, true, options.notReproject);

                var clean = function (wait) {
                    self.track.trackName.value = '';
                    self.track.trackName.disabled = true;
                    self.track.trackSave.disabled = true;

                    self.track.trackWPT.value = '';
                    self.track.trackWPT.disabled = true;
                    self.track.trackAdd.disabled = true;

                    self.getLoadingIndicator().removeWait(wait);

                    duringTrackingToolsPanel.call(self);
                };

                var newTrack = {
                    name: trackName,
                    data: formatted.features,
                    layout: formatted.layout,
                    crs: self.storageCRS
                };

                TC.loadJS(
                    !window.hex_md5,
                    [TC.apiLocation + TC.Consts.url.HASH],
                    function () {
                        var hash = hex_md5(JSON.stringify(newTrack));

                        var sameTrackUID = tracks.map(function (savedTrack) {
                            var clonedTrack = JSON.parse(JSON.stringify(savedTrack));
                            delete clonedTrack.uid;
                            if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                return savedTrack.uid;
                            } else {
                                const jsonFormat = new ol.format.GeoJSON();
                                // validamos si se trata de un track exportado/importado ya que se compacta la geometría
                                var features = jsonFormat.readFeatures(clonedTrack.data);
                                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                                features.forEach(function (feature) {
                                    var geom = TC.Util.explodeGeometry(TC.Util.compactGeometry(feature.getGeometry().getCoordinates(), precision));
                                    feature.getGeometry().setCoordinates(geom);
                                });

                                clonedTrack.data = jsonFormat.writeFeatures(features);

                                if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                    return savedTrack.uid;
                                } else {
                                    return null;
                                }
                            }

                        }).filter(function (uid) {
                            return uid !== null
                        });

                        const getTrackIndex = function (uid) {
                            return self.getStoredTracks().then(function () {
                                self.bindTracks();

                                var index;
                                for (var i = 0; i < self.availableTracks.length; i++) {
                                    if (self.availableTracks[i].uid === uid) {
                                        index = i;
                                        break;
                                    }
                                }

                                return index;
                            });
                        };

                        if (sameTrackUID.length === 0) {

                            newTrack.uid = Date.now() + Math.random();
                            tracks.push(newTrack);
                            tracks = _orderTracks(tracks);

                            try {
                                self.setStoredTracks(tracks).then(function () {
                                    self.map.toast(message, { duration: 3000 });

                                    clean(wait);

                                    getTrackIndex(newTrack.uid).then(function (index) {
                                        resolve(index);
                                    });
                                });

                            } catch (error) {
                                TC.alert(self.getLocaleString("geo.error.savelocalstorage") + ': ' + error.message);
                                clean(wait);
                                reject(error);
                            }
                        } else {
                            console.log('Ya existe un track con ese mismo hash');

                            clean(wait);

                            getTrackIndex(sameTrackUID[0]).then(function (index) {
                                resolve(index);
                            });
                        }
                    });

            };

            const createTCFeatures = function (features) {
                return new Promise(function (resolve, reject) {
                    var featurePromises = features.filter(function (feature) {
                        return !feature._wrap;
                    }).forEach(function (elm) {
                        return TC.wrap.Feature.createFeature(elm);
                    });

                    Promise.all(featurePromises).then(function (tcFeatures) {
                        resolve();
                    });
                });
            };

            if (self.importedFileName)
                _save(self.layerTrack);
            else if (self.track.trackName.value.trim().length == 0) {
                self.track.trackName.value = new Date().toLocaleString();
                _save(self.layerTracking);
            }
            else {
                _save(self.layerTracking);
            }
        });
    };

    ctlProto.addWaypoint = function () {
        var self = this;

        var waypointName = self.track.trackWPT.value.trim();
        if (!waypointName) {
            waypointName = new Date().toLocaleString();
        }

        var wait = self.getLoadingIndicator().addWait();

        duringTrackingToolsPanel.call(self);

        self.wrap.addWaypoint(self.currentPoint.position, {
            name: waypointName,
            ele: self.currentPoint.heading,
            time: new Date().getTime() // GLS: lo quito ya que hemos actualizado la función que gestiona la fechas para la exportación a GPX - espera la fecha en segundos -> / 1000 // para la exportación a GPX - espera la fecha en segundos
        });

        self.track.trackWPT.value = '';
        self.track.trackWPT.disabled = true;
        self.track.trackAdd.disabled = true;

        // cada vez que se añade un waypoint almacenamos en sessionStorage
        TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);

        self.getLoadingIndicator().removeWait(wait);
    };

    ctlProto.editTrackName = function (trackId, newName) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                if (tracks[trackId]) {
                    tracks[trackId].name = newName;

                    self.setStoredTracks(tracks);
                }
            }
        });
    };

    ctlProto.removeTrack = function (li) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                var dataId = li.dataset.id;
                if (tracks[dataId]) {
                    var uid = tracks[dataId].uid;

                    TC.confirm(self.getLocaleString("geo.trk.delete.alert"), function () {

                        const selectedTrack = self.getSelectedTrack();
                        if (selectedTrack && selectedTrack.dataset.id === dataId) {
                            self.clear(self.Const.Layers.TRACK);
                        }

                        localforage.removeItem(self.Const.LocalStorageKey.TRACKING + '#' + uid).then(function () {
                            self.getStoredTracks().then(function () {
                                self.bindTracks();
                            });
                        }).catch(function (err) {
                            console.log(err);
                        });

                    }, function () { });
                }
            }
        });
    };

    ctlProto.setSelectedTrack = function (li) {
        var self = this;

        if (!self.isActive) {
            self.activate();
        }

        self.track.trackList.querySelectorAll('li[data-id] > span').forEach(function (span) {
            span.setAttribute('title', span.textContent);
        });
        self.track.trackList.querySelectorAll('li').forEach(function (li) {
            li.classList.remove(self.Const.Classes.SELECTEDTRACK);
        });

        li.classList.add(self.Const.Classes.SELECTEDTRACK);

        li.setAttribute('title', self.getLocaleString("tr.lst.clear") + " " + li.querySelector('span').textContent);
        li.querySelector(self.Const.Selector.DRAW).setAttribute('title', li.getAttribute('title'));
    };

    ctlProto.getSelectedTrack = function () {
        var self = this;

        return self.track.trackList.querySelector('li.' + self.Const.Classes.SELECTEDTRACK);
    };

    ctlProto.clearSelectedTrack = function () {
        const self = this;

        const selected = self.getSelectedTrack();
        if (selected) {

            if (self.onResize) {
                window.removeEventListener('resize', self.onResize, false);
                self.onResize = undefined;
            }

            selected.classList.remove(self.Const.Classes.SELECTEDTRACK);
            selected.setAttribute('title', selected.textContent);
            selected.querySelector(self.Const.Selector.DRAW).setAttribute('title', selected.getAttribute('title'));
        }
    };

    ctlProto.clearSelection = function () {
        var self = this;
        self.wrap.deactivateSnapping();
        var selected = self.getSelectedTrack();
        if (selected) {
            self.clearSelectedTrack();
        }
        if (self.resultsPanelChart) {

            self.resultsPanelChart.div.removeEventListener('mouseover', self.resultsPanelChart.deactivateSnapping);
            self.resultsPanelChart.div.removeEventListener('mouseout', self.resultsPanelChart.activateSnapping);

            self.resultsPanelChart.close();
        }

        self.clear(self.Const.Layers.TRACK);
    };

    ctlProto.drawTrackingData = function (li) {
        const self = this;

        return new Promise(function (resolve, reject) {
            self.wrap.clear();

            self.getTrackingData(li).then(function (track) {
                var data = track.data;
                if (track.data)
                    self.wrap.drawTrackingData(track).then(function () {
                        var showFeatures = self.layerTrack.features;
                        if (showFeatures && showFeatures.length > 0) {

                            var coordinates = showFeatures.filter(function (feature) {
                                feature.showsPopup = false;
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return true;
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return true;
                                }
                                return false;
                            }).map(function (feature) {
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return feature.geometry[0];
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return feature.geometry;
                                }
                            })[0];

                            if (coordinates) {
                                var first = coordinates[0];
                                var last = coordinates[coordinates.length - 1];

                                if (first && !(first === last)) {
                                    self.layerTrack.addMarker(first.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon-end', anchor: [0.5, 1], notExport: true
                                    });
                                }

                                if (last) {
                                    self.layerTrack.addMarker(last.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon', anchor: [0.5, 1], notExport: true
                                    });
                                }
                            }
                        }
                        self.layerTrack.setVisibility(true);
                        resolve();
                    });
            });
        });
    };

    ctlProto.getTrackingData = function (li) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.getAvailableTracks().then(function (tracks) {
                if (tracks) {
                    const dataId = li.dataset.id;
                    if (tracks[dataId]) {
                        var track = tracks[dataId].data;

                        // GLS: tengo que transformar de 4326 al crs del mapa en el momento de pintar, porque si lo hacemos al cargar la lista
                        // y después hay cambio de crs, en el momento de pintar no sé desde qué crs debo tranformar
                        track = self.wrap.formattedFromStorage(track);

                        resolve({ data: track, layout: tracks[dataId].layout });
                    }
                } else {
                    resolve();
                }
            });
        });
    };

    ctlProto.export = function (li) {
        var self = this;
        return self.wrap.export(li);
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.wrap.showElevationMarker(d);

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.wrap.hideElevationMarker();
    }

    ctlProto.clearFileInput = function (fileInput) {
        const form = document.createElement('form');
        const parent = fileInput.parentElement;
        parent.insertBefore(form, fileInput);
        form.appendChild(fileInput);
        form.reset();
        // Desenvolvemos el input del form
        form.insertAdjacentElement('afterend', fileInput);
        parent.removeChild(form);
    };

    ctlProto.getLoadingIndicator = function () {
        var self = this;

        if (!self.loading) {
            self.loading = self.map.getControlsByClass(TC.control.LoadingIndicator);
            if (self.loading && self.loading.length > 0)
                self.loading = self.loading[0];
        }

        return self.loading;
    };

    ctlProto.onGeolocateError = function (error) {
        var self = this;

        if (navigator.geolocation) {
            if (self.currentPosition)
                navigator.geolocation.clearWatch(self.currentPosition);
            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }
        }

        if (self.currentPositionWaiting)
            self.getLoadingIndicator().removeWait(self.currentPositionWaiting);

        var errorMsg;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMsg = self.getLocaleString("geo.error.permission_denied");
                break;
            case error.POSITION_UNAVAILABLE:
                errorMsg = self.getLocaleString("geo.error.position_unavailable");
                break;
            case error.TIMEOUT:
                errorMsg = self.getLocaleString("geo.error.timeout");
                break;
            default:
                errorMsg = self.getLocaleString("geo.error.default");
                break;
        }

        self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

        if (!self.geopositionTracking && self.track) {
            self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
            self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    var _isEmpty = function (obj) {
        return !obj || obj.length === 0;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.layerTrack) {
                var features = self.layerTrack.features;

                if (features.length > 0 && self.featuresToShare && self.featuresToShare.length > 0) {
                    state.features = self.featuresToShare;
                } else {
                    const layerState = self.layerTrack.exportState({
                        features: features
                    });

                    state.features = layerState.features;
                }

                state.id = self.id;
                const selectedTrack = self.getSelectedTrack();
                if (selectedTrack) {
                    state.trackName = selectedTrack.querySelector('span').innerHTML;
                }
                return state;
            }
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            if (state.features && state.features.length) {
                self.enable();

                if (state.features.length > 0) {
                    const promises = new Array(state.features.length);
                    state.features.forEach(function (f, idx) {
                        const featureOptions = { data: f.data, id: f.id, showsPopup: f.showsPopup };
                        var addFn;
                        var geom = TC.Util.explodeGeometry(f.geom);
                        switch (f.type) {
                            case TC.Consts.geom.POLYLINE:
                                promises[idx] = new TC.feature.Polyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MULTIPOLYLINE:
                                promises[idx] = new TC.feature.MultiPolyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MARKER:
                                promises[idx] = new TC.feature.Marker(geom, featureOptions);
                                break;
                            case TC.Consts.geom.POINT:
                                promises[idx] = new TC.feature.Point(geom, featureOptions);
                                break;
                        }
                    });

                    Promise.all(promises).then(function (tcFeatures) {
                        var options = { features: tcFeatures, fileName: state.trackName, notReproject: true, isShared: true };
                        if (!self.availableTracks) {
                            self.getStoredTracks().then(function () {
                                self.importTrack(options);
                            });
                        } else {
                            self.importTrack(options);
                        }
                    });
                }
            }
        }
    };

    ctlProto.getDownloadDialog = function () {
        const self = this;
        if (self._downloadDialog) {
            return Promise.resolve(self._downloadDialog);
        }
        return new Promise(function (resolve, reject) {
            self.map.addControl('FeatureDownloadDialog').then(ctl => {
                self._downloadDialog = ctl;
                resolve(ctl);
            })
        });
    };
})();
TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

(function () {
    TC.control.GeometryFeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.GeometryFeatureInfo(self);
        self._isDrawing = false;
        self._isSearching = false;
        self._drawToken = false;
    };

    TC.inherit(TC.control.GeometryFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.GeometryFeatureInfo.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        self.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
            self.wrap.cancelDraw();
        });

        return result;
    };

    ctlProto.callback = function (coords, xy) {
        var self = this;
        if (self._drawToken) {
            return;
        }
        self.closeResults();
        //self.filterLayer.clearFeatures();
        self.highlightedFeature = null;
        var visibleLayers = false;
        for (var i = 0; i < self.map.workLayers.length; i++) {
            var layer = self.map.workLayers[i];
            if (layer.type === TC.Consts.layerType.WMS) {
                if (layer.getVisibility() && layer.names.length > 0) {
                    visibleLayers = true;
                    break;
                }
            }
        }
        if (visibleLayers) {
            self.closeResults();
            self.wrap.beginDraw({
                geometryType: self.geometryType,
                xy: coords,
                layer: self.filterLayer,
                callback: function (feature) {
                    self.wrap.getFeaturesByGeometry(feature);
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        var self = this;

        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);

        if (self.filterFeature) {
            var services = options.services;

            // Eliminamos capas sin resultados a no ser que tenga un error
            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                if (service.hasLimits) {
                    delete service.layers;
                    service.hasLimits = service.hasLimits;
                }
                else {
                    for (var j = 0; j < service.layers.length; j++) {
                        if (!service.layers[j].features.length) {
                            service.layers.splice(j, 1);
                            j = j - 1;
                        }
                    }
                    if (!service.layers.length) {
                        services.splice(i, 1);
                        i = i - 1;
                    }
                }

            }
            self.renderData(options, function () {
                if (services.length) {
                    self.insertLinks();
                }
                self.div.querySelector(`.${self.CLASS}-coords`).classList.add(TC.Consts.classes.HIDDEN);
                self.displayResults();
            });
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

(function () {

    TC.control.LayerCatalog = function () {
        var self = this;

        self.layers = [];
        self.searchInit = false;

        TC.control.ProjectionSelector.apply(self, arguments);

        self._selectors = {
            LAYER_ROOT: 'div.' + self.CLASS + '-tree > ul.' + self.CLASS + '-branch > li.' + self.CLASS + '-node'
        };

        if (!TC.Consts.classes.SELECTABLE) {
            TC.Consts.classes.SELECTABLE = 'tc-selectable';
        }
        if (!TC.Consts.classes.INCOMPATIBLE) {
            TC.Consts.classes.INCOMPATIBLE = 'tc-incompatible';
        }
        if (!TC.Consts.classes.ACTIVE) {
            TC.Consts.classes.ACTIVE = 'tc-active';
        }
    };

    TC.inherit(TC.control.LayerCatalog, TC.control.ProjectionSelector);

    var ctlProto = TC.control.LayerCatalog.prototype;

    ctlProto.CLASS = 'tc-ctl-lcat';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/LayerCatalog.html";
    ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/LayerCatalogBranch.html";
    ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LayerCatalogNode.html";
    ctlProto.template[ctlProto.CLASS + '-info'] = TC.apiLocation + "TC/templates/LayerCatalogInfo.html";
    ctlProto.template[ctlProto.CLASS + '-results'] = TC.apiLocation + "TC/templates/LayerCatalogResults.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/LayerCatalogDialog.html";

    const showProjectionChangeDialog = function (ctl, layer) {
        ctl.showProjectionChangeDialog({
            layer: layer,
            closeCallback: function () {
                ctl.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.LOADING);
                    node.querySelector('span').dataset.tooltip = ctl.getLocaleString('clickToAddToMap');
                });
            }
        });
    };

    var SEARCH_MIN_LENGTH = 3;

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        const load = function (resolve, reject) {
            if (Array.isArray(self.options.layers)) {
                for (var i = 0; i < self.options.layers.length; i++) {
                    var layer = self.options.layers[i];
                    if (!layer.type || layer.type === TC.Consts.layerType.WMS) {
                        if (!layer.id) {
                            layer.id = TC.getUID();
                        }                        
                        if (TC.Util.isPlainObject(layer)) {
                            layer = new TC.layer.Raster(layer);
                        }                        
                        self.layers.push(layer);
                    }
                }
                self.render(function () {
                    resolve();
                });
            }
            else {
                resolve();
            }
        };

        self._readyPromise = new Promise(function (resolve, reject) {
            const waitLoad = function (e) {
                if (e.layer === map.baseLayer) {
                    load(resolve, reject);
                    map.off(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            };

            map.loaded(function () {
                if (!map.baseLayer.state || map.baseLayer.state === TC.Layer.state.IDLE) {
                    load(resolve, reject);
                }
                else {
                    map.on(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            });
        });

        const findResultNodes = function (layer) {
            const result = [];
            if (!layer.isBase) {
                var url = layer.options.url;
                if (self.list) {
                    self.list.querySelectorAll('li').forEach(function (li) {
                        const lyr = self.getLayer(li.dataset.layerId);
                        if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                            for (var i = 0; i < layer.names.length; i++) {
                                if (li.dataset.layerName === layer.names[i]) {
                                    result.push(li);
                                    break;
                                }
                            }
                        }
                    });
                }
            }
            return result;
        };

        /**
         * Marca todas las capas del TOC como añadidas excepto la que se está borrando que se recibe como parámetro.
         */
        const _markWorkLayersAsAdded = function (layerRemoved) {
            var wlCtrl = self.map.getControlsByClass(TC.control.WorkLayerManager)[0];
            if (wlCtrl) {
                var layers = wlCtrl.layers;

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];

                    if (layer !== layerRemoved) {
                        self.getLayerNodes(layer).forEach(function (node) {
                            node.classList.add(TC.Consts.classes.CHECKED);
                            node.querySelector('span').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                        });
                    }
                }
            }
        };

        var clickToAddText = self.getLocaleString('clickToAddToMap');

        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' + TC.Consts.event.BEFOREUPDATEPARAMS, function (e) {
                self.getLayerNodes(e.layer).forEach(function (node) {
                    node.classList.add(TC.Consts.classes.LOADING);
                    delete node.querySelector('span').dataset.tooltip;
                });
            })
            .on(TC.Consts.event.LAYERADD + ' ' + TC.Consts.event.UPDATEPARAMS, function (e) {
                const layer = e.layer;
                if (!layer.isBase && layer.type === TC.Consts.layerType.WMS) {
                    self.loaded().then(function () { // Esperamos a que cargue primero las capas de la configuración

                        if (self.getLayerRootNode(layer)) {
                            updateControl.call(self, layer);
                        }
                        else {
                            // la capa no está renderizada, pero podría estar en proceso, comprobamos que no está en la lista de capas del control
                            var layerAlreadyAdded = false;
                            for (var i = 0, len = self.layers.length; i < len; i++) {
                                var lyr = self.layers[i];
                                if (lyr.type === layer.type && lyr.options.url === layer.options.url) {
                                    layerAlreadyAdded = true;
                                    break;
                                }
                            }

                            // 12/03/2019 GLS la capa forma parte de los servicios configurados pero el nodo aún no se ha cargado, la guardamos
                            if (layerAlreadyAdded) {
                                if (!self.layersToSetChecked) {
                                    self.layersToSetChecked = [];
                                }

                                self.layersToSetChecked.push(layer);
                            } else {
                                self.addLayer(new TC.layer.Raster({
                                    url: layer.options.url,
                                    type: layer.type,
                                    layerNames: [],
                                    title: layer.title || layer.wrap.getServiceTitle(),
                                    hideTitle: true,
                                    hideTree: false
                                })).then(function () {
                                    updateControl.call(self, layer);
                                });
                            }
                        }
                    });
                }
            })
            .on(TC.Consts.event.LAYERERROR, function (e) {
                const reason = e.reason;
                if (self.layers.some((f) => { return f == e.layer })) {
                    if (reason) {
                        TC.alert(self.getLocaleString(reason, { url: e.layer.url }));
                    }
                    self.getLayerNodes(e.layer).forEach(function (node) {
                        node.classList.remove(TC.Consts.classes.LOADING);
                    });
                }                
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const layer = e.layer;
                self.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.querySelector('span').dataset.tooltip = clickToAddText;
                });
                findResultNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.querySelector('h5').dataset.tooltip = clickToAddText;
                });

                //Marcamos como añadidas aquellas capas que estén en el control de capas cargadas. Esto previene que si borramos una capa padre, todas
                //sus hijas aparezcan como no añadidas, a pesar que que alguna de ellas haya sido añadida previamente de manera individual
                _markWorkLayersAsAdded(layer);

                //refresh del searchList            
                _refreshResultList.call(self);
            })
            .on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
                if (e && e.layer) {
                    self.addLayer(e.layer);
                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                }
            })
            .on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                self.update();
            });

        return result;
    };

    const onCollapseButtonClick = function (e) {
        e.target.blur();
        e.stopPropagation();
        const li = e.target.parentElement;
        if (li.tagName === 'LI' && !li.classList.contains(self.CLASS + '-leaf')) {
            li.classList.toggle(TC.Consts.classes.COLLAPSED);
            const ul = li.querySelector('ul');
            ul.classList.toggle(TC.Consts.classes.COLLAPSED);
        }
    };

    const onSpanClick = function (e, ctl) {
        const li = e.target.parentNode;
        if (!li.classList.contains(TC.Consts.classes.LOADING) && !li.classList.contains(TC.Consts.classes.CHECKED)) {
            e.preventDefault;

            var layerName = li.dataset.layerName;
            layerName = (layerName !== undefined) ? layerName.toString() : '';
            var layer;
            for (var i = 0, len = ctl._roots.length; i < len; i++) {
                const root = ctl._roots[i];
                if (root.contains(li)) {
                    layer = ctl.getLayer(root.dataset.layerId);
                    break;
                }
            }
            if (!layer) {
                layer = ctl.getLayer(li.dataset.layerId);
            }
            if (layer && layerName) {
                var redrawTime = 1;

                if (/iPad/i.test(navigator.userAgent))
                    redrawTime = 10;
                else if (TC.Util.detectFirefox())
                    redrawTime = 250;

                if (!layer.title) {
                    layer.title = layer.getTree().title;
                }

                li.classList.add(TC.Consts.classes.LOADING);
                li.querySelector('span').dataset.tooltip = '';

                const reDraw = function (element) {
                    return new Promise(function (resolve, reject) {
                        setTimeout(function () {
                            element.offsetHeight = element.offsetHeight;
                            element.offsetWidth = element.offsetWidth;

                            resolve();
                        }, redrawTime);
                    });
                };

                reDraw(li).then(function () {
                    ctl.addLayerToMap(layer, layerName);
                });
                e.stopPropagation();
            }
        }
    };

    const createSearchAutocomplete = function () {
        const self = this;

        self.textInput = self.div.querySelector("." + self.CLASS + "-input");
        self.list = self.div.querySelector("." + self.CLASS + "-search ul");
        // Clear results list when x button is pressed in the search input
        self.textInput.addEventListener('mouseup', function (e) {
            var oldValue = self.textInput.value;

            if (oldValue === '') {
                return;
            }

            // When this event is fired after clicking on the clear button
            // the value is not cleared yet. We have to wait for it.
            setTimeout(function () {
                var newValue = self.textInput.value;

                if (newValue === '') {
                    self.list.innerHTML = '';
                }
            }, 1);
        });

        var layerCheckedList = [];
        //Definir el autocomplete del buscador de capas por texto
        TC._search = TC._search || {};
        TC._search.retryTimeout = null;

                    TC.loadJS(
                        !TC.UI || !TC.UI.autocomplete,
                        [TC.apiLocation + 'TC/ui/autocomplete.js'],
                        function () {
                            TC.UI.autocomplete.call(self.textInput, {
                                link: '#',
                                target: self.list,
                                minLength: 0,
                                source: function (text, callback) {
                                    //lista de capas marcadas
                                    layerCheckedList = [];
                                    self._roots.forEach(function (root) {
                                        root.querySelectorAll("li." + TC.Consts.classes.CHECKED).forEach(function (item) {
                                            layerCheckedList.push(item.dataset.layerName);
                                        });
                                    });

                        //con texto vacío, limpiar  y ocultar la lista de resultados
                        text = text.trim();
                        if (text.length < SEARCH_MIN_LENGTH) {
                            self.list.innerHTML = '';
                        }
                        else if (text.length >= SEARCH_MIN_LENGTH) {
                            if (TC._search.retryTimeout)
                                clearTimeout(TC._search.retryTimeout);
                            TC._search.retryTimeout = setTimeout(function () {
                                var results = [];
                                for (var index = 0; index < self.sourceLayers.length; index++) {
                                    var _founds = self.sourceLayers[index].searchSubLayers(text);
                                    if (_founds.length) {
                                        results.push({
                                            service: {
                                                index: index,
                                                title: self.sourceLayers[index].title || self.sourceLayers[index].id
                                            },
                                            founds: _founds
                                        });
                                    }
                                }
                                callback({ servicesFound: results, servicesLooked: self.sourceLayers.length });
                            }, TC._search.interval);
                        }
                    },
                    callback: function (e) {
                        self.textInput.value = e.target.text || e.target.innerText;
                        TC._search.lastPattern = self.textInput.value;
                        self.goToResult(unescape(e.target.hash).substring(1));
                        TC.UI.autocomplete.call(self.textInput, 'clear');
                    },
                    buildHTML: function (data) {
                        var container = this.target;
                        //si hay resultados, mostramos la lista
                        if (data.results && data.results.servicesFound.length > 0) {
                            var workLayers = self.map.getLayerTree().workLayers;
                            for (var k = 0; k < data.results.servicesFound.length; k++) {
                                var founds = data.results.servicesFound[k].founds;
                                for (var j = 0; j < founds.length; j++) {
                                    delete founds[j].alreadyAdded;
                                    for (var i = 0; i < workLayers.length; i++) {
                                        //if (workLayers[i].title == data.results[j].Title ) {
                                        if (layerCheckedList.indexOf(founds[j].Name) >= 0) {
                                            founds[j].alreadyAdded = true;
                                            break;
                                        }
                                    }
                                    //Si la capa no tiene Name, no se puede añadir al TOC
                                    if (!founds[j].Name) {
                                        founds.splice(j, 1);
                                        j--;
                                    }
                                }
                                if (!data.results.servicesFound[k].founds.length) {
                                    data.results.servicesFound.splice(k, 1);
                                    continue;
                                }
                                //si estaba collapsado mantenemos el estado
                                if (self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k]) {
                                    data.results.servicesFound[k].service.isCollapsed = self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k].classList.contains(TC.Consts.classes.COLLAPSED);
                                }
                            }
                        }
                        var ret = ''
                        self.getRenderedHtml(self.CLASS + '-results', data.results).then(function (out) {
                            container.innerHTML = ret = out;
                        });
                        return ret;
                    }
                });
            });


        if (!self.searchInit) {
            //botón de la lupa para alternar entre búsqueda y árbol
            self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2 button', function (e) {
                const wasCollapsed = self.div.classList.contains(TC.Consts.classes.COLLAPSED);
                self.div.classList.remove(TC.Consts.classes.COLLAPSED);

                const searchPane = self.div.querySelector('.' + self.CLASS + '-search');
                const treePane = self.div.querySelector('.' + self.CLASS + '-tree');
                const infoPane = self.div.querySelector('.' + self.CLASS + '-info');

                const searchPaneMustShow = !!(searchPane.classList.contains(TC.Consts.classes.HIDDEN) || wasCollapsed);
                searchPane.classList.toggle(TC.Consts.classes.HIDDEN, !searchPaneMustShow);
                treePane.classList.toggle(TC.Consts.classes.HIDDEN, searchPaneMustShow);
                e.target.classList.toggle(self.CLASS + '-btn-tree', searchPaneMustShow);
                e.target.classList.toggle(self.CLASS + '-btn-search', !searchPaneMustShow);
                if (searchPaneMustShow) {
                    self.textInput.focus();
                    e.target.setAttribute('title', self.getLocaleString('viewAvailableLayersTree'));

                    //Si no hay resultados resaltados en el buscador, ocultamos el panel de info
                    const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-search li button.tc-checked').length;
                    if (selectedCount === 0) {
                        infoPane.classList.add(TC.Consts.classes.HIDDEN);
                    }
                }
                else {
                    e.target.setAttribute('title', self.getLocaleString('searchLayersByText'));

                    //Si hay resaltados en el árbol, mostramos el panel de info
                    const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-tree li button.tc-checked').length;
                    if (selectedCount > 0) {
                        infoPane.classList.remove(TC.Consts.classes.HIDDEN);
                    }
                }
            }));


            //evento de expandir nodo de info
            //self._$div.off("click", ".tc-ctl-lcat-search button");                        
            self.div.addEventListener("click", TC.EventTarget.listenerBySelector("." + self.CLASS + "-search button." + self.CLASS + "-search-btn-info", function (evt) {
                evt.stopPropagation();
                const target = evt.target;
                if (!target.classList.contains(TC.Consts.classes.CHECKED)) {
                    const li = target.parentElement;
                    var parent = li;
                    do {
                        parent = parent.parentElement;
                    }
                    while (parent && parent.tagName !== 'LI');
                    self.showLayerInfo(self.layers.length > 1 ? self.layers[parent.dataset.serviceIndex] : self.layers[0], li.dataset.layerName);
                    target.classList.add(TC.Consts.classes.CHECKED);

                } else {
                    target.classList.remove(TC.Consts.classes.CHECKED);
                    self.hideLayerInfo();
                }
            }));

                        //click en un resultado - añadir capa
            const searchListElementSelector = '.' + self.CLASS + '-search li';
            self.div.addEventListener('click', TC.EventTarget.listenerBySelector(searchListElementSelector, function (evt) {
                evt.stopPropagation();
                var li = evt.target;
                while (li && !li.matches(searchListElementSelector)) {
                    li = li.parentElement;
                }
                if (li.classList.contains(self.CLASS + '-no-results')) {
                    return; //si clicko en el li de "no hay resultados" rompo el ciclo de ejecución
                }
                if (li.classList.contains(self.CLASS + '-search-group')) {
                    li.classList.toggle(TC.Consts.classes.COLLAPSED);
                    return;
                }
                var layerName = li.dataset.layerName;
                if (!layerName) {
                    return;
                }
                layerName = layerName.toString();

                if (layerName.trim().length === 0) {
                    return;
                }

                //si la capa ya ha sido anteriormente, no la añadimos y mostramos un mensaje
                if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                    return;
                } else {
                    var liParent = li;
                    do {
                        liParent = liParent.parentElement;
                    }
                    while (liParent && !liParent.matches('li.' + self.CLASS + '-search-group'));

                    const layerIdx = !liParent ? 0 : liParent.dataset.serviceIndex;
                    const url = self.layers[layerIdx].options.url;
                    const title = self.layers[layerIdx].title;

                    const layer = new TC.layer.Raster({
                        id: self.getUID(),
                        url: url,
                        title: title,
                        hideTitle: self.layers[layerIdx].hideTitle || self.layers[layerIdx].options.hideTitle,
                        hideTree: false,
                        layerNames: [layerName]
                    });
                    if (layer.isCompatible(self.map.crs)) {
                        self.map.addLayer(layer, function (layer) {
                            li.dataset.layerId = layer.id;
                            layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                                var layer = this.parent;
                                if (event.error.code === 401 || event.error.code === 403)
                                    layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                                layer.map.removeLayer(layer);
                            });
                        });
                        //marcamos el resultado como añadido
                        li.classList.add(TC.Consts.classes.CHECKED);
                        li.querySelector('h5').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                    }
                    else {
                        showProjectionChangeDialog(self, layer);
                    }
                }
            }));

            self.searchInit = true;
        }
    };

    const getLayerTree = function (layer) {
        var result = layer.getTree();
        var makeNodeVisible = function makeNodeVisible(node) {
            var result = false;
            var childrenVisible = false;
            for (var i = 0; i < node.children.length; i++) {
                if (makeNodeVisible(node.children[i])) {
                    childrenVisible = true;
                }
            }
            if (node.hasOwnProperty('isVisible')) {
                node.isVisible = (!layer.names || !layer.names.length) || childrenVisible || node.isVisible;
            }
            return node.isVisible;
        };
        makeNodeVisible(result);
        return result;
    };

    const _refreshResultList = function () {
        const self = this;

        if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("keyup", false, true);
            if (self.textInput) {
                self.textInput.dispatchEvent(evt);
            }
        }
        else {
            if (self.textInput) {
                self.textInput.fireEvent("keyup");
            }
        }
    };

    const updateControl = function (layer) {
        const self = this;

        self.getLayerNodes(layer).forEach(function (node) {
            node.classList.remove(TC.Consts.classes.LOADING);
            node.classList.add(TC.Consts.classes.CHECKED);
            node.querySelector('span').dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
        });
        _refreshResultList.call(self);
    };

    const setCheckedLayersOnNode = function () {
        const self = this;

        if (self.layersToSetChecked && self.layersToSetChecked.length > 0) {
            self.layersToSetChecked.forEach(function (layer, index, array) {
                if (self.getLayerRootNode(layer)) {
                    updateControl.call(self, layer);

                    array.splice(index, 1);
                }
            });
        }
    };

    const addLogicToNode = function (node, layer) {
        const self = this;

        node.querySelectorAll('li > button.' + self.CLASS + '-collapse-btn').forEach(function (btn) {
            btn.addEventListener('click', onCollapseButtonClick);
        });

        node.querySelectorAll('span').forEach(function (span) {
            span.addEventListener('click', function (e) {
                onSpanClick(e, self);
            });
        });

        self._roots = self.div.querySelectorAll(self._selectors.LAYER_ROOT);                
        
        node.dataset.layerId = layer.id;

        var formatDescriptions = {};
        node.querySelectorAll('.' + self.CLASS + '-btn-info').forEach(function (a) {
            const span = a.parentElement.querySelector('span');
            const name = a.parentElement.dataset.layerName;
            if (name) {
                span.classList.add(TC.Consts.classes.SELECTABLE);
                var info = layer.wrap.getInfo(name);
                if (!info.hasOwnProperty('abstract') && !info.hasOwnProperty('legend') && !info.hasOwnProperty('metadata')) {
                    a.parentElement.removeChild(a);
                }
                else {                    
                    a.addEventListener(TC.Consts.event.CLICK, function (e) {
                        e.stopPropagation();
                        const elm = this;
                        if (elm.classList.toggle(TC.Consts.classes.CHECKED)) {
                            self.showLayerInfo(layer, name);
                        } else {
                            self.hideLayerInfo();
                        }
                    });
                }
                if (layer.compatibleLayers && layer.compatibleLayers.indexOf(name) < 0) {
                    span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                    span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                    //console.log("capa " + name + " incompatible");
                }
                if (self.map) {
                    for (var j = 0, len = self.map.workLayers.length; j < len; j++) {
                        var wl = self.map.workLayers[j];
                        if (wl.type === TC.Consts.layerType.WMS && wl.url === layer.url && wl.names.length === 1 && wl.names[0] === name) {
                            span.parentElement.classList.add(TC.Consts.classes.CHECKED);
                            span.dataset.tooltip = self.getLocaleString('layerAlreadyAdded');
                        }
                    }
                }
            }
            else {
                span.dataset.tooltip = '';
                a.parentElement.removeChild(a);
            }
        });        

        setCheckedLayersOnNode.call(self);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        });
    };

    ctlProto.renderBranch = function (layer, callback, promiseRenderResolve) {
        const self = this;

        layer.getCapabilitiesPromise()
            .then(function (result) {

                self.sourceLayers.push(layer);

                self.getRenderedHtml(self.CLASS + '-branch', getLayerTree(this), function (html) {
                    var template = document.createElement('template');
                    template.innerHTML = html;

                    var newChild = template.content ? template.content.firstChild : template.firstChild;
                    var oldChild = self.div.querySelector('.' + self.CLASS + '-branch').querySelector('li.' + self.CLASS + '-loading-node[data-layer-id="' + this.id + '"]');

                    if (oldChild) {
                        self.div.querySelector('.' + self.CLASS + '-branch').replaceChild(newChild, oldChild);
                    } else {
                        self.div.querySelector('.' + self.CLASS + '-branch').appendChild(newChild);
                    }

                    addLogicToNode.call(self, newChild, this);

                    if (self.div.querySelector('.' + self.CLASS + '-branch').childElementCount === 1) {
                        promiseRenderResolve();
                    }

                    if (TC.Util.isFunction(callback)) {
                        // pasamos el callback el item 
                        callback(self.sourceLayers[self.sourceLayers.map(function (l) { return l.id }).indexOf(this.id)]);
                    }

                }.bind(this));

            }.bind(layer))
            .catch(function (error) {
                var index = self.layers.map(function (l) { return l.id }).indexOf(this.id);
                self.layers.splice(index, 1);

                var errorMessage = self.getLocaleString("lyrCtlg.errorLoadingNode", { serviceName: this.title });
                var liError = self.div.querySelector('.' + self.CLASS + '-branch').querySelector('li.' + self.CLASS + '-loading-node[data-layer-id="' + this.id + '"]');
                liError.classList.add('error');
                liError.setAttribute('title', errorMessage);

                self.map.toast(errorMessage, { type: TC.Consts.msgType.ERROR });

            }.bind(layer));
    };

    ctlProto.render = function (callback) {
        const self = this;

        self.sourceLayers = [];

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            if (self.layers.length === 0) {
                self.renderData({ layerTrees: [], enableSearch: false }, function () {

                    if (TC.Util.isFunction(callback)) {
                        callback();
                    }

                    resolve();
                });
            } else {
                self.renderData({ layers: self.layers, enableSearch: true }, function () {

                    createSearchAutocomplete.call(self);

                    self.layers.forEach(function (layer) {
                        self.renderBranch(layer, callback, resolve);
                    });
                });
            }
        }));
    };

    ctlProto.getLayerRootNode = function (layer) {
        const self = this;
        var result = null;
        if (!layer.isBase) {
            var url = layer.options.url;
            if (self._roots) {
                self._roots.forEach(function (li) {
                    const lyr = self.getLayer(li.dataset.layerId);
                    if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                        result = li;
                    }
                });
            }
        }
        return result;
    };

    ctlProto.getLayerNodes = function (layer) {
        const self = this;
        const result = [];
        const rootNode = self.getLayerRootNode(layer);
        if (rootNode) {
            for (var i = 0; i < layer.names.length; i++) {
                const liLayer = rootNode.querySelector('li[data-layer-name="' + layer.names[i] + '"]');
                if (!liLayer) {
                    continue;
                }
                result[result.length] = liLayer;
                liLayer.querySelectorAll('li').forEach(function (li) {
                    result[result.length] = li;
                });
            }
        }
        return result;
    };

    ctlProto.showLayerInfo = function (layer, name) {
        const self = this;
        var result = null;

        var info = self.div.querySelector('.' + self.CLASS + '-info');

        const toggleInfo = function (layerName, infoObj) {
            var result = false;
            //if (lName !== undefined && lName.toString() === layerName) {
            //    info.dataset.layerName = '';
            //    $info.removeClass(TC.Consts.classes.HIDDEN);
            //}
            //else {
            if (infoObj) {
                result = true;
                info.dataset.layerName = layerName;
                info.classList.remove(TC.Consts.classes.HIDDEN);
                self.getRenderedHtml(self.CLASS + '-info', infoObj)
                    .then(function (out) {
                        info.innerHTML = out;
                        info.querySelector('.' + self.CLASS + '-info-close').addEventListener(TC.Consts.event.CLICK, function () {
                            self.hideLayerInfo();
                        })
                    })
                    .catch(function (err) {
                        TC.error(err);
                    });
            }
            //}
            return result;
        };

        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });

        const formatDescriptions = {};
        for (var i = 0, ii = self._roots.length; i < ii; i++) {
            const root = self._roots[i];
            if (root.dataset.layerId === layer.id) {
                const as = root.querySelectorAll('.' + self.CLASS + '-btn-info');
                for (var j = 0, jj = as.length; j < jj; j++) {
                    const a = as[j];
                    var n = a.parentElement.dataset.layerName;
                    if (n === name) {
                        const info = layer.wrap.getInfo(name);
                        if (info.metadata) {
                            info.metadata.forEach(function (md) {
                                md.formatDescription = formatDescriptions[md.format] =
                                    formatDescriptions[md.format] ||
                                    self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) ||
                                    self.getLocaleString('viewMetadata');
                            });
                        }
                        const infoBtn = self.div.querySelector('li [data-layer-name="' + n + '"] > button.' + self.CLASS + '-btn-info');
                        infoBtn.classList.toggle(TC.Consts.classes.CHECKED, toggleInfo(n, info));
                        result = info;
                        break;
                    }
                }
                break;
            }
        }

        return result;
    };

    ctlProto.update = function () {
        const self = this;
        self.sourceLayers.forEach(function (layer) {
            layer.getCapabilitiesPromise().then(function () {
                layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);

                const rootNode = self.getLayerRootNode(layer);
                if (rootNode) {
                    rootNode
                        .querySelectorAll('li[data-layer-name]')
                        .forEach(function (li) {
                            const name = li.dataset.layerName;
                            const span = li.querySelector('span.' + TC.Consts.classes.SELECTABLE);
                            if (layer.compatibleLayers.indexOf(name) < 0) {
                                span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                                span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                            }
                            else {
                                span.classList.remove(TC.Consts.classes.INCOMPATIBLE)
                                span.removeAttribute('title');
                            }
                        });
                }
            });
        });
    };

    ctlProto.hideLayerInfo = function () {
        var self = this;
        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });
        self.div.querySelector('.' + self.CLASS + '-info').classList.add(TC.Consts.classes.HIDDEN);
    };

    ctlProto.addLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var fromLayerCatalog = [];

            if (self.options.layers && self.options.layers.length) {
                fromLayerCatalog = self.options.layers.filter(function (l) {
                    var getMap = TC.Util.reqGetMapOnCapabilities(l.url);
                    return getMap && getMap.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });
            }

            if (fromLayerCatalog.length == 0)
                fromLayerCatalog = self.layers.filter(function (l) {
                    return l.url.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });

            if (fromLayerCatalog.length == 0) {
                self.layers.push(layer);
                layer.getCapabilitiesPromise().then(function () {
                    layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);
                    layer.title = layer.title || layer.wrap.getServiceTitle();
                    self.renderBranch(layer, function () {
                        resolve(); //ver linea 55 y por ahí
                    });
                });
            } else { resolve(); }
        });
    };

    ctlProto.getLayer = function (id) {
        const self = this;
        for (var i = 0, len = self.layers.length; i < len; i++) {
            const layer = self.layers[i];
            if (layer.id === id) {
                // 10/04/2019 GLS: validamos si es una capa que viene de configuración o es un WMS externo o por estado 
                // para decidir si mostramos el título del servicio o no
                var configLayer = self.options.layers.filter(l => l.id === id);

                if (configLayer.length > 0) {
                    layer.hideTitle = layer.options.hideTitle = configLayer[0].hideTitle;
                } else {
                    layer.hideTitle = layer.options.hideTitle = false;
                }                
                
                return layer;
            }
        }
        return null;
    };

    ctlProto.addLayerToMap = function (layer, layerName) {
        const self = this;
        const layerOptions = TC.Util.extend({}, layer.options);
        layerOptions.id = self.getUID();
        layerOptions.layerNames = [layerName];
        layerOptions.title = layer.title;
        const newLayer = new TC.layer.Raster(layerOptions);
        if (newLayer.isCompatible(self.map.crs)) {
            self.map.addLayer(layerOptions);
        }
        else {
            showProjectionChangeDialog(self, newLayer);
        }
    };

    ctlProto.loaded = function () {
        return this._readyPromise;
    };

    ctlProto.getAvailableCRS = function (options) {
        const self = this;
        options = options || {};
        return self.map.getCompatibleCRS({
            layers: self.map.workLayers.concat(self.map.baseLayer, options.layer),
            includeFallbacks: true
        });
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options).then(function () {
                    if (self._layerToAdd) {
                        self.map.addLayer(self._layerToAdd);
                    }
                    TC.Util.closeModal();
                });
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        self._layerToAdd = options.layer;
        TC.control.ProjectionSelector.prototype.showProjectionChangeDialog.call(self, options);
    };

})();
TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.Legend = function () {
    TC.control.MapContents.apply(this, arguments);
};

TC.inherit(TC.control.Legend, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.Legend.prototype;

    ctlProto.CLASS = 'tc-ctl-legend';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Legend.html";
    ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LegendNode.html";

    ctlProto.register = function (map) {
        const self = this;

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            const onLayerAdd = self.loadGraphics.bind(self);

            if (view === TC.Consts.view.THREED) {                
                map.on(TC.Consts.event.LAYERADD, onLayerAdd);
            } else if (view === TC.Consts.view.DEFAULT) {
                map.off(TC.Consts.event.LAYERADD, onLayerAdd);
            }
        });

        return TC.control.MapContents.prototype.register.call(self, map);
    };

    ctlProto.loadGraphics = function () {
        const self = this;
        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                li.querySelectorAll('li.' + self.CLASS + '-node-visible').forEach(function (l) {
                    const img = l.querySelector('img');
                    if (img && img.getAttribute('src') !== undefined && img.getAttribute('src').length === 0) {
                        self.styleLegendImage(img, layer);
                    }
                });
            }
        });
    };

    ctlProto.updateScale = function () {
        const self = this;
        const inScale = self.CLASS + '-node-inscale';
        const outOfScale = self.CLASS + '-node-outofscale';

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);

            if (layer) {
                let layersInScale = false;
                const lis = li.querySelectorAll('li');
                lis.forEach(function (l) {
                    if (l.classList.contains(self.CLASS + '-node-visible')) {
                        const uid = l.dataset.layerUid;
                        if (layer.isVisibleByScale(uid)) {
                            layersInScale = true;
                            l.classList.remove(outOfScale);
                            l.classList.add(inScale);
                            const img = l.querySelector('img');
                            if (img) {
                                self.styleLegendImage(img, layer);
                            }
                        }
                        else {
                            l.classList.add(outOfScale);
                            l.classList.remove(inScale);
                        }
                    }
                });
                layersInScale = layersInScale || !lis.length;
                if (!lis.length) {
                    const img = li.querySelector('img');
                    if (img) {
                        self.styleLegendImage(img);
                    }
                }
                li.classList.toggle(inScale, layersInScale);
                li.classList.toggle(outOfScale, !layersInScale);
            }
        });
    };

    ctlProto.update = function () {
        const self = this;

        self.getLayerUIElements().forEach(function (li) {
            const layer = self.map.getLayer(li.dataset.layerId);
            if (layer) {
                layer.getTree();

                li.querySelectorAll('li').forEach(function (l) {
                    const uid = l.dataset.layerUid;
                    var visible = self.CLASS + '-node-visible';
                    var notVisible = self.CLASS + '-node-notvisible';
                    var hasVisible = self.CLASS + '-node-hasvisible';

                    switch (layer._cache.visibilityStates[uid]) {
                        case TC.Consts.visibility.NOT_VISIBLE:
                            l.classList.remove(visible, hasVisible);
                            l.classList.add(notVisible);                            
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            l.classList.remove(visible, notVisible);
                            l.classList.add(hasVisible);                            
                            break;
                        default:
                            // visible
                            l.classList.remove(notVisible, hasVisible);
                            l.classList.add(visible);                            
                            break;
                    }
                });

                self.updateLayerVisibility(layer);
            }
        });
        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;        

        if (!layer.isBase && !layer.options.stealth) {
            
            //// 09/04/2019 GLS: ignoramos el atributo que venga en la capa porque en la leyenda queremos que el árbol se muestre siempre y 
            //// nos ahorramos el tener que pasarlo en el estado del mapa
            if (layer.hideTree || layer.options.hideTree) {
                layer.tree = null;
                layer.hideTree = layer.options.hideTree = false;

                layer._cache.visibilityStates = {};
            }            

            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);            

            self.getRenderedHtml(self.CLASS + '-node', self.layerTrees[layer.id])
                .then(function (out) {
                    const parser = new DOMParser();
                    const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                    const uid = newLi.dataset.layerUid;
                    const ul = self.div.querySelector('ul.' + self.CLASS + '-branch');
                    const lis = ul.querySelectorAll('li[data-layer-uid="' + uid + '"]');
                    if (lis.length === 1) {
                        const li = lis[0];
                        li.innerHTML = newLi.innerHTML;
                        li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                    }
                    else {
                        newLi.dataset.layerId = layer.id;
                        ul.insertBefore(newLi, ul.firstChild);
                    }

                    self.update();
                })
                .catch(function (err) {
                    TC.error(err);
                });
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if (li.dataset.layerId === layer.id) {
                li.classList.toggle(self.CLASS + '-node-notvisible', !layer.getVisibility());
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        return self.div.querySelector('ul.' + self.CLASS + '-branch').querySelectorAll('li.' + self.CLASS + '-node');
    };
})();

TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.LineFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYLINE;
        self.style = TC.Util.extend(true, { strokeColor: self.DEFAULT_STROKE_COLOR, strokeWidth: 2 }, self.options.style); 
    };

    TC.inherit(TC.control.LineFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.LineFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
TC.control = TC.control || {};

if (!TC.control.WorkLayerManager) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/WorkLayerManager');
}

TC.control.ListTOC = TC.control.WorkLayerManager;
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.LoadingIndicator = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self._waits = {};

    window.addEventListener('error', function () {
        self.reset();
        // Tell browser to run its own error handler as well
        return false;
    }, false);
};

TC.inherit(TC.control.LoadingIndicator, TC.Control);

(function () {
    var ctlProto = TC.control.LoadingIndicator.prototype;

    ctlProto.CLASS = 'tc-ctl-load';

    ctlProto.template = TC.apiLocation + "TC/templates/LoadingIndicator.html";

    //var ctlProto.waits = {};
    
    ctlProto.startWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        if (self._waits[layerId] === undefined) {
            self._waits[layerId] = 0;
        }
        self._waits[layerId] = self._waits[layerId] + 1;
        self.show();

        self.map.trigger(TC.Consts.event.STARTLOADING);
    };

    ctlProto.stopWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        var wait = self._waits[layerId];
        if (wait > 0) {
            wait = self._waits[layerId] = wait - 1;
        }
        if (!wait) {
            delete self._waits[layerId];
        }
        var count = 0;
        for (var key in self._waits) {
            count++;
        }
        if (!count) {
            self.hide();
            self.map.trigger(TC.Consts.event.STOPLOADING);
        }
    };

    ctlProto.endWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        var wait = self._waits[layerId];
        if (wait > 0) {
            delete self._waits[layerId];
        }
        var count = 0;
        for (var key in self._waits) {
            count++;
        }
        if (!count) {
            self.hide();
            self.map.trigger(TC.Consts.event.STOPLOADING);
        }
    };

    ctlProto.reset = function (e) {
        var self = this;
        self._waits = {};
        self.hide();
        self.map.trigger(TC.Consts.event.STOPLOADING);
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' +
                TC.Consts.event.BEFORELAYERUPDATE + ' ' +
                TC.Consts.event.BEFOREFEATURESADD, function (e) {
                    self.startWait(e);
                })
            .on(TC.Consts.event.LAYERADD + ' ' +
                TC.Consts.event.LAYERERROR + ' ' +
                TC.Consts.event.LAYERUPDATE + ' ' +
                TC.Consts.event.FEATURESADD, function (e) {
                    self.stopWait(e);
                })
            .on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                self.addWait(TC.Consts.event.FEATUREINFO);
            })
            .on(TC.Consts.event.FEATUREINFO + ' ' +
                TC.Consts.event.NOFEATUREINFO + ' ' +
                TC.Consts.event.FEATUREINFOERROR, function () {
                    self.removeWait(TC.Consts.event.FEATUREINFO);
                })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                self.endWait(e);
            });
        if (!TC.isDebug) {
            //Para evitar que se quede el indicador indefinidamente activo cuando hay un error en la página
            window.addEventListener('error', function (msg, url, line, col, error) {
                self.reset();
                return false;
            });

            //$(document).ajaxError(function (event, request, settings) {
            //    self.reset();
            //});
        }

        return result;
    };

    ctlProto.addWait = function (uid) {
        const self = this;
        const result = uid || TC.getUID();
        self.startWait({ layer: { id: result } });
        return result;
    };

    ctlProto.removeWait = function (uid) {
        this.stopWait({ layer: { id: uid } });
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.BEFOREFEATUREMODIFY = "beforefeaturemodify.tc";
TC.Consts.event.FEATUREMODIFY = "featuremodify.tc";
TC.Consts.event.FEATURESSELECT = "featuresselect.tc";
TC.Consts.event.FEATURESUNSELECT = "featuresunselect.tc";
TC.Consts.event.CHANGE = 'change';

TC.control.Modify = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    if (!TC.browserFeatures.inputTypeColor() && !window.CP) {
        TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
        TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
    }

    self.styles = TC.Util.extend(true, TC.Cfg.styles.selection, self.options.styles);
    self.styles.text = self.styles.text || {
        fontSize: self.styles.line.fontSize,
        fontColor: self.styles.line.fontColor,
        labelOutlineColor: self.styles.line.labelOutlineColor,
        labelOutlineWidth: self.styles.line.labelOutlineWidth
    };

    self._classSelector = '.' + self.CLASS;

    self.wrap = new TC.wrap.control.Modify(self);
    self.snapping = (typeof self.options.snapping === 'boolean') ? self.options.snapping : true;
};

TC.inherit(TC.control.Modify, TC.Control);

(function () {

    var ctlProto = TC.control.Modify.prototype;

    ctlProto.CLASS = 'tc-ctl-mod';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Modify.html";
    ctlProto.template[ctlProto.CLASS + '-attr'] = TC.apiLocation + "TC/templates/ModifyAttributes.html";

    const setFeatureSelectedState = function (ctl, features) {
        ctl._deleteBtn.disabled = features.length === 0;
        ctl._editAttrBtn.disabled = features.length !== 1;
        ctl._joinBtn.disabled = features.length < 2;
        ctl._splitBtn.disabled = features.filter(complexGeometryFilter).length === 0;
        ctl.displayLabelText();
    };

    //const styleFunction = function (feature, mapStyles) {
    //    var result;
    //    switch (true) {
    //        case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
    //        case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
    //            result = TC.Util.extend({}, mapStyles.polygon);
    //            break;
    //        case TC.feature.Point && feature instanceof TC.feature.Point:
    //        case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
    //            result = TC.Util.extend({}, mapStyles.point);
    //            break;
    //        default:
    //            result = TC.Util.extend({}, mapStyles.line);
    //            break;
    //    }
    //    const style = feature.getStyle();
    //    if (style.label) {
    //        result.label = style.label;
    //        result.fontSize = style.fontSize;
    //        result.fontColor = style.fontColor;
    //        result.labelOutlineColor = style.labelOutlineColor;
    //        result.labelOutlineWidth = style.labelOutlineWidth;
    //    }
    //    return result;
    //};

    //const setFeatureSelectedStyle = function (ctl, features) {
    //    const mapStyles = ctl.map.options.styles.selection;
    //    features.forEach(function (feature) {
    //        feature._originalStyle = TC.Util.extend({}, feature.getStyle());
    //        feature.setStyle(ctl.styleFunction(feature));
    //    });
    //};

    //const setFeatureUnselectedStyle = function (ctl, features) {
    //    features.forEach(function (feature) {
    //        if (feature._originalStyle) {
    //            const style = feature.getStyle();
    //            if (style.label) {
    //                const originalStyle = feature._originalStyle;
    //                originalStyle.label = style.label;
    //                originalStyle.fontSize = style.fontSize;
    //                originalStyle.fontColor = style.fontColor;
    //                originalStyle.labelOutlineColor = style.labelOutlineColor;
    //                originalStyle.labelOutlineWidth = style.labelOutlineWidth;
    //            }
    //            feature.setStyle(feature._originalStyle);
    //            feature._originalStyle = undefined;
    //        }
    //    })
    //};

    const complexGeometryFilter = function (elm) {
        var result = false;
        if ((TC.feature.MultiPolygon && elm instanceof TC.feature.MultiPolygon) ||
            (TC.feature.MultiPolyline && elm instanceof TC.feature.MultiPolyline)) {
            if (elm.geometry.length > 1) {
                result = true;
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        if (self.options.layer) {
            self.setLayer(self.options.layer);
        }

        map
            .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    if (e.layer === layer) {
                        self.setSelectableState(true);
                    }
                });
            })
            .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                const layer = e.layer;
                const feature = e.feature;
                Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                    if (layer === objects[0]) {
                        if (feature) {
                            self.unselectFeatures([feature]);
                        }
                        else {
                            self.unselectFeatures();
                        }
                        setFeatureSelectedState(self, self.getSelectedFeatures());
                        if (self.layer.features.length === 0) {
                            self.setSelectableState(false);
                            self.setTextMode(false);
                        }
                    }
                });
            })
            .on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                    if (layer === objects[0]) {
                        setFeatureSelectedState(self, self.getSelectedFeatures());
                    }
                });
            });

        self.on(TC.Consts.event.FEATURESSELECT + ' ' + TC.Consts.event.FEATURESUNSELECT, function () {
            const selectedFeatures = self.getSelectedFeatures();
            setFeatureSelectedState(self, selectedFeatures);
            const unselectedFeatures = self.layer.features.filter(function (feature) {
                return selectedFeatures.indexOf(feature) < 0;
            });
            unselectedFeatures.forEach(function (feature) {
                feature.toggleSelectedStyle(false);
            });
            selectedFeatures.forEach(function (feature) {
                feature.toggleSelectedStyle(true);
            });

            if (!self.getAttributeDisplayTarget().classList.contains(TC.Consts.classes.HIDDEN)) {
                self.displayAttributes();
            }
            if (!selectedFeatures.length) {
                self.closeAttributes();
            }
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        const renderCallback = function () {
            self._selectBtn = self.div.querySelector('.' + self.CLASS + '-btn-select');
            self._selectBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                if (!e.target.disabled) {
                    if (self.isActive) {
                        self.deactivate();
                    }
                    else {
                        self.activate();
                    }
                }
            });
            self._deleteBtn = self.div.querySelector('.' + self.CLASS + '-btn-delete');
            self._deleteBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.deleteSelectedFeatures();
            });
            self._textBtn = self.div.querySelector('.' + self.CLASS + '-btn-text');
            self._textBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.setTextMode(!self.textActive);
            });
            self._joinBtn = self.div.querySelector('.' + self.CLASS + '-btn-join');
            self._splitBtn = self.div.querySelector('.' + self.CLASS + '-btn-split');
            self._editAttrBtn = self.div.querySelector('.' + self.CLASS + '-btn-attr');
            self._editAttrBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.toggleAttributes();
            });
            self._textInput = self.div.querySelector('input.' + self.CLASS + '-txt');
            self._textInput.addEventListener('input', function (e) {
                self.labelFeatures(e.target.value);
            });
            self._styleSection = self.div.querySelector('.' + self.CLASS + '-style');

            self._fontColorPicker = self.div.querySelector(self._classSelector + '-fnt-c');
            self._fontColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontColor(e.target.value);
            });

            self._fontSizeSelector = self.div.querySelector('.' + self.CLASS + '-fnt-s');
            self._fontSizeSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontSize(e.target.value);
            });

            self._attributesSection = self.div.querySelector('.' + self.CLASS + '-attr');

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        };

        const renderObject = {
            fontSize: self.styles.text.fontSize,
            fontColor: self.styles.text.fontColor,
            labelOutlineColor: self.styles.text.labelOutlineColor,
            labelOutlineWidth: self.styles.text.labelOutlineWidth
        };

        var promise;
        if (TC.browserFeatures.inputTypeColor()) {
            promise = self._set1stRenderPromise(self.renderData(renderObject, renderCallback));
        }
        else {
            // El navegador no soporta input[type=color], usamos polyfill
            promise = self._set1stRenderPromise(self.renderData(renderObject, function () {
                const input = self.div.querySelector('input[type=color]');
                input.style.backgroundColor = input.value;
                input.style.color = 'transparent';
                const picker = new CP(input, 'click', document.body);

                input.onclick = function (e) {
                    e.preventDefault();
                };

                // Evitamos que salga el teclado virtual en iOS
                input.onfocus = function (e) {
                    this.blur();
                };

                input.onchange = function (e) {
                    this.style.backgroundColor = this.value;
                };
                self.map.loaded(function () {
                    picker.on("change", function (color) {
                        self.setFontColor('#' + color);
                    });
                });

                renderCallback();
            }));
        }
        return promise;
    };

    ctlProto.activate = function () {
        const self = this;
        self._selectBtn.classList.add(TC.Consts.classes.ACTIVE);
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
    };

    ctlProto.deactivate = function () {
        const self = this;
        TC.Control.prototype.deactivate.call(self);
        if (self._selectBtn) {
            setFeatureSelectedState(self, []);
        }
        if (self.wrap) {
            self.wrap.deactivate();
        }
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        if (self._selectBtn) {
            self._selectBtn.classList.remove(TC.Consts.classes.ACTIVE);
            if (self.layer) {
                self.layer.features.forEach(function (feature) {
                    feature.toggleSelectedStyle(false);
                });
            }
            //setFeatureUnselectedStyle(self, self.getSelectedFeatures());
        }
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            if (self.layer) {
                self.layer.map.putLayerOnTop(self.layer);
            }
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.getLayer = function () {
        var self = this;
        // Se ha instanciado un control sin capa asociada
        if (self.options && typeof self.options.layer === 'boolean' && !self.options.layer) {
            return Promise.resolve(null);
        }
        if (self.layer) {
            return Promise.resolve(self.layer);
        }
        return self._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        const self = this;
        if (self.map) {
            self.setSelectedFeatures([]);
            self._layerPromise = new Promise(function (resolve, reject) {
                if (typeof (layer) === "string") {
                    self.map.loaded(function () {
                        self.layer = self.map.getLayer(layer);
                        resolve(self.layer);
                    });
                }
                else {
                    self.layer = layer;
                    resolve(self.layer);
                }
            });
            Promise.all([self._layerPromise, self.renderPromise()]).then(function (objs) {
                const layer = objs[0];
                self.setSelectableState(layer && layer.features.length > 0);
            });
        }
    };

    ctlProto.setSelectableState = function (active) {
        const self = this;
        self._selectBtn.disabled = !active;
        self._textBtn.disabled = !active;
    };

    ctlProto.getSelectedFeatures = function () {
        return this.wrap.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        const self = this;
        const result = self.wrap.setSelectedFeatures(features);
        self.displayLabelText();
        return result;
    };

    ctlProto.getActiveFeatures = function () {
        const self = this;
        const result = self.getSelectedFeatures();
        if (!result.length && self.layer.features.length) {
            result.push(self.layer.features[self.layer.features.length - 1]);
        }
        return result;
    };

    ctlProto.unselectFeatures = function (features) {
        features = features || [];
        this.wrap.unselectFeatures(features.map(function (feat) {
            return feat.wrap.feature;
        }));
        return this;
    };

    ctlProto.deleteSelectedFeatures = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        self.wrap.unselectFeatures(features);
        features.forEach(function (feature) {
            self.layer.removeFeature(feature);
            self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
        });
        return self;
    };

    ctlProto.styleFunction = function (feature, resolution) {
        const self = this;
        var result;
        const mapStyles = self.map.options.styles.selection;
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                result = TC.Util.extend({}, mapStyles.polygon);
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
            case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                result = TC.Util.extend({}, mapStyles.point);
                break;
            default:
                result = TC.Util.extend({}, mapStyles.line);
                break;
        }
        const style = feature.getStyle();
        if (style.label) {
            result.label = style.label;
            result.fontSize = style.fontSize;
            result.fontColor = style.fontColor;
            result.labelOutlineColor = style.labelOutlineColor;
            result.labelOutlineWidth = style.labelOutlineWidth;
        }
        return result;
    };

    ctlProto.setTextMode = function (active) {
        const self = this;
        self.textActive = active;
        if (active) {
            self._textBtn.classList.add(TC.Consts.classes.ACTIVE, active);
            self._styleSection.classList.remove(TC.Consts.classes.HIDDEN);
        }
        else {
            self._textBtn.classList.remove(TC.Consts.classes.ACTIVE, active);
            self._styleSection.classList.add(TC.Consts.classes.HIDDEN);
        }
        self.displayLabelText();
        return self;
    };

    ctlProto.setFontColorWatch = function (color, outlineColor) {
        const self = this;
        if (color === undefined) {
            color = self.styles.text.fontColor;
        }
        color = TC.Util.colorArrayToString(color);
        outlineColor = outlineColor || self.getLabelOutlineColor(color);
        self.renderPromise().then(function () {
            self._fontColorPicker.value = color;
            self._textInput.style.color = color;
            self._textInput.style.textShadow = '0 0 ' + self.styles.text.labelOutlineWidth + 'px ' + outlineColor;
            if (!TC.browserFeatures.inputTypeColor()) {
                self._fontColorPicker.style.backgroundColor = color;
                self._fontColorPicker.blur();
            }
        });
        return self;
    };

    ctlProto.setFontColor = function (color) {
        const self = this;
        self.styles.text.fontColor = color;
        self.styles.text.labelOutlineColor = self.getLabelOutlineColor(color);
        self.setFontColorWatch(color, self.styles.text.labelOutlineColor);
        const features = self.getActiveFeatures();
        features.forEach(function (feature) {
            const style = feature.getStyle();
            style.fontColor = color;
            style.labelOutlineColor = self.styles.text.labelOutlineColor;
            feature.setStyle(style);
        });
        return self;
    };

    ctlProto.setFontSizeWatch = function (size) {
        const self = this;
        if (size === undefined) {
            size = self.styles.text.fontSize;
        }
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.renderPromise().then(function () {
                self._fontSizeSelector.value = sizeValue;
                self._textInput.style.fontSize = sizeValue + 'pt';
            });
        }
        return self;
    };

    ctlProto.setFontSize = function (size) {
        const self = this;
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.styles.text.fontSize = sizeValue;
            self.setFontSizeWatch(sizeValue);
            const features = self.getActiveFeatures();
            features.forEach(function (feature) {
                const style = feature.getStyle();
                style.fontSize = sizeValue;
                feature.setStyle(style);
            });
        }
        return self;
    };

    ctlProto.getLabelOutlineColor = function (fontColor) {
        if (fontColor) {
            fontColor = TC.Util.colorArrayToString(fontColor);
            const matchForShort = fontColor.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (matchForShort && matchForShort.length) {
                fontColor = '#' + matchForShort[1] + matchForShort[1] + matchForShort[2] + matchForShort[2] + matchForShort[3] + matchForShort[3];
            }
            const matchForLong = fontColor.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
            if (matchForLong && matchForLong.length) {
                const r = parseInt(matchForLong[1], 16);
                const g = parseInt(matchForLong[2], 16);
                const b = parseInt(matchForLong[3], 16);
                return (r + g + b) / 3 < 128 ? '#ffffff' : '#000000';
            }
        }
        return '#ffffff';
    };

    ctlProto.displayLabelText = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        var text;
        var size;
        var color;
        if (self.isActive && features.length) {
            const feature = features[features.length - 1];
            const style = feature.getStyle();
            text = style.label;
            color = style.fontColor;
            size = style.fontSize;
        }
        else {
            text = '';
            color = self.styles.text.fontColor;
            size = self.styles.text.fontSize;
        }
        self.renderPromise().then(function () {
            self
                .setFontSizeWatch(size)
                .setFontColorWatch(color)
                ._textInput.value = text || '';
        });
        return self;
    };

    ctlProto.labelFeatures = function (text) {
        const self = this;
        const features = self.getActiveFeatures();
        if (features.length) {
            const style = features[0].getStyle();
            features.forEach(function (feature) {
                const textStyle = TC.Util.extend({}, self.styles.text, style);
                style.label = text;
                style.labelOffset = textStyle.labelOffset;
                style.fontColor = textStyle.fontColor;
                style.fontSize = textStyle.fontSize;
                style.labelOutlineColor = textStyle.labelOutlineColor;
                style.labelOutlineWidth = textStyle.labelOutlineWidth;
                feature.setStyle(style);
            });
        }
        return self;
    };

    ctlProto.getAttributeDisplayTarget = function () {
        return this._attributesSection;
    };

    ctlProto.displayAttributes = function () {
        const self = this;
        const selectedFeatures = self.getSelectedFeatures();
        const feature = selectedFeatures[selectedFeatures.length - 1];
        if (feature) {
            self.getRenderedHtml(self.CLASS + '-attr', { data: feature.getData() }, function (html) {
                const attributesSection = self.getAttributeDisplayTarget();
                attributesSection.innerHTML = html;
                attributesSection.classList.remove(TC.Consts.classes.HIDDEN);
                self._editAttrBtn.classList.add(TC.Consts.classes.ACTIVE);

                attributesSection.querySelector(`${self.CLASS}-btn-attr-ok`).addEventListener(TC.Consts.event.CLICK, function (e) {
                    self._onAttrOK();
                });

                attributesSection.querySelector(`.${self.modifyControl.CLASS}-btn-attr-cancel`).addEventListener(TC.Consts.event.CLICK, function () {
                    self.closeAttributes();
                });
            });
        }
    };

    ctlProto.closeAttributes = function () {
        const self = this;
        self._attributesSection.classList.add(TC.Consts.classes.HIDDEN);
        self._editAttrBtn.classList.remove(TC.Consts.classes.ACTIVE);
    };

    ctlProto.toggleAttributes = function () {
        const self = this;
        if (self._editAttrBtn.classList.toggle(TC.Consts.classes.ACTIVE)) {
            self.displayAttributes();
        }
        else {
            self.closeAttributes();
        }
    };

    ctlProto._onAttrOK = function () {
        const self = this;
        const feature = self.getSelectedFeatures()[0];
        if (feature) {
            const data = {};
            self.getAttributeDisplayTarget().querySelectorAll('input').forEach(function (input) {
                data[input.getAttribute('name')] = input.value;
            });
            feature.setData(data);
            self.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature, layer: self.layer });
            self.closeAttributes();
        }
    };

    ctlProto.joinFeatures = function (features) {
        const self = this;
        if (self.geometryType === TC.Consts.geom.MULTIPOLYLINE ||
            self.geometryType === TC.Consts.geom.MULTIPOLYGON ||
            self.geometryType === TC.Consts.geom.MULTIPOINT) {
            self._joinedFeatureAttributes = [];
            if (features.length > 1) {
                var geometries = features.map(function (elm) {
                    self._joinedFeatureAttributes[self._joinedFeatureAttributes.length] = elm.getData();
                    return elm.geometry;
                });
                var newGeometry = geometries.reduce(function (a, b) {
                    return a.concat(b);
                });
                var newFeature = new features[0].constructor(newGeometry);
                for (var i = 0, len = features.length; i < len; i++) {
                    var feature = features[i];
                    self.layer.removeFeature(feature);
                    self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
                }
                self.layer.addFeature(newFeature).then(function (feat) {
                    self.setSelectedFeatures([newFeature]);
                    self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
                    feat.showPopup(self.attributeEditor);
                });
            }
            setFeatureSelectedState(self, [newFeature]);
        }
    };

})();

TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
(function () {
    TC.control.MultiFeatureInfo = function () {
        var self = this;
        TC.Control.apply(self, arguments);
        self.modes = self.options.modes || {};
        if (typeof self.modes[TC.Consts.geom.POINT] === 'undefined') {
            self.modes[TC.Consts.geom.POINT] = true;
        }
        if (typeof self.modes[TC.Consts.geom.POLYGON] === 'undefined') {
            self.modes[TC.Consts.geom.POLYGON] = true;
        }
        self.featureInfoControl = null;
        self.lineFeatureInfoControl = null;
        self.polygonFeatureInfoControl = null;
        self.featureInfoControls = [];
        self.lastCtrlActive = null;
        self.popup = null;
        self.exportsState = false; // Los controles que exportan estado son los hijos
    };

    TC.inherit(TC.control.MultiFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.MultiFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-m-finfo';

    ctlProto.template = TC.apiLocation + "TC/templates/MultiFeatureInfo.html";

    const mergeOptions = function (opt1, opt2) {
        if (opt1) {
            if (opt1 === true) {
                opt1 = {};
            }
            return TC.Util.extend(true, opt1, opt2);
        }
        return opt1;
    };

    ctlProto.register = function (map) {
        const self = this;

        self.div.querySelectorAll('input[type=radio]').forEach(function (input) {
            input.checked = false;
        });


        return new Promise(function (resolve, reject) {
            const ctlPromises = [TC.Control.prototype.register.call(self, map)]
            const styles = self.options.styles || {};
            if (self.modes[TC.Consts.geom.POINT]) {
                ctlPromises.push(map.addControl("featureInfo", mergeOptions(self.modes[TC.Consts.geom.POINT],
                    { displayMode: self.options.displayMode })).then(function (control) {
                        self.featureInfoControl = control;
                        self.featureInfoControls.push(control);
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYLINE]) {
                ctlPromises.push(map.addControl("lineFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYLINE],
                    { displayMode: self.options.displayMode, style: styles.line })).then(function (control) {
                        self.lineFeatureInfoControl = control;
                        self.featureInfoControls.push(control);
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYGON]) {
                ctlPromises.push(map.addControl("polygonFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYGON],
                    { displayMode: self.options.displayMode, style: styles.polygon })).then(function (control) {
                        self.polygonFeatureInfoControl = control;
                        self.featureInfoControls.push(control);
                        return control;
                    }));
            }

            map.on(`${TC.Consts.event.LAYERADD} ${TC.Consts.event.LAYERREMOVE} ${TC.Consts.event.LAYERVISIBILITY}`, function (e) {
                self.updateUI();
            });

            map.on(`${TC.Consts.event.CONTROLACTIVATE} ${TC.Consts.event.CONTROLDEACTIVATE}`, function (e) {
                if (e.control === self.featureInfoControl || e.control === self.lineFeatureInfoControl || e.control === self.polygonFeatureInfoControl) {
                    self.updateUI();
                }
            });

            Promise.all(ctlPromises).then(function () {
                if (self.featureInfoControl) {
                    self.featureInfoControl.activate();
                    self.lastCtrlActive = self.featureInfoControl;
                }
                self.updateUI();
                resolve(self);
            });
        });

    };

    ctlProto.render = function (callback) {
        const self = this;
        var renderData = {};
        if (self.modes[TC.Consts.geom.POINT]) {
            renderData.pointSelectValue = TC.Consts.geom.POINT;
        }
        if (self.modes[TC.Consts.geom.POLYLINE]) {
            renderData.lineSelectValue = TC.Consts.geom.POLYLINE;
        }
        if (self.modes[TC.Consts.geom.POLYGON]) {
            renderData.polygonSelectValue = TC.Consts.geom.POLYGON;
        }
        return self._set1stRenderPromise(self.renderData(renderData,
            function () {
                var changeEvent = function () {
                    switch (this.value) {
                        case TC.Consts.geom.POLYLINE:
                            //modo línea
                            self.lineFeatureInfoControl.activate();
                            self.lastCtrlActive = self.lineFeatureInfoControl;
                            break;
                        case TC.Consts.geom.POLYGON:
                            //modo poligono
                            self.polygonFeatureInfoControl.activate();
                            self.lastCtrlActive = self.polygonFeatureInfoControl;
                            break;
                        default:
                            //modo point
                            self.featureInfoControl.activate();
                            self.lastCtrlActive = self.featureInfoControl;
                            break;
                    }
                };
                self.div.querySelectorAll('input[type=radio]').forEach(function (input) {
                    input.addEventListener('change', changeEvent);
                });

                //URI bind del click del boton de borrar seleccionadas
                const delFeaturesBtn = self.div.querySelector(`.${self.CLASS}-btn-remove`);
                delFeaturesBtn.addEventListener(TC.Consts.event.CLICK, function (event) {
                    event.preventDefault();
                    self.featureInfoControls.forEach(ctl => {
                        ctl.info = null;
                        ctl._infoHistory = {};
                        ctl.resultsLayer.features.slice().forEach(f => ctl.downplayFeature(f));
                        ctl.filterLayer.features.slice().forEach(f => f.layer.removeFeature(f));
                    });
                });
                self.map
                    //.on(TC.Consts.event.FEATUREINFO, function () {
                    //    delFeaturesBtn.disabled = false;
                    //})
                    //.on(TC.Consts.event.NOFEATUREINFO, function (e) {
                    //    if (e.control && e.control.filterFeature) {
                    //        delFeaturesBtn.disabled = false;
                    //    }
                    //})
                    .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                        if (self.featureInfoControls.some(ctl => ctl.resultsLayer === e.layer || ctl.filterLayer === e.layer)) {
                            self.updateUI();
                        }
                    })
                    .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                        if (self.featureInfoControls.some(ctl => ctl.resultsLayer === e.layer || ctl.filterLayer === e.layer)) {
                            self.updateUI();
                        }
                    });

                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            }));
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.lastCtrlActive)
            self.lastCtrlActive.activate();
    };

    ctlProto.deactivate = function () {
        var self = this;
        self.lastCtrlActive.deactivate(false);
    };

    ctlProto.updateUI = function () {
        const self = this;
        self.renderPromise().then(function () {
            const enabled = self.map.workLayers.some(l => l.type === TC.Consts.layerType.WMS && l.getVisibility());
            self.div.querySelectorAll('input').forEach(function (input) {
                input.disabled = !enabled;
            });
            if (self.featureInfoControl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POINT}]`);
                if (input) {
                    input.checked = self.featureInfoControl.isActive;
                }
            }
            if (self.lineFeatureInfoControl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POLYLINE}]`);
                if (input) {
                    input.checked = self.lineFeatureInfoControl.isActive;
                }
            }
            if (self.polygonFeatureInfoControl) {
                const input = self.div.querySelector(`input[value=${TC.Consts.geom.POLYGON}]`);
                if (input) {
                    input.checked = self.polygonFeatureInfoControl.isActive;
                }
            }

            const delFeaturesBtn = self.div.querySelector(`.${self.CLASS}-btn-remove`);
            delFeaturesBtn.classList.toggle(TC.Consts.classes.HIDDEN, !self.featureInfoControls.some(c => c.options.persistentHighlights));
            delFeaturesBtn.disabled = self.featureInfoControls.every(ctl => ctl.resultsLayer && ctl.resultsLayer.features.length === 0 && ctl.filterLayer && ctl.filterLayer.features.length === 0);


            // Hack para compensar bug de Edge: no se actualiza el estilo al cambiar el estado del radio.
            const displayValue = self.div.style.display;
            self.div.style.display = 'none';
            if (displayValue) {
                self.div.style.display = displayValue;
            }
            else {
                self.div.style.removeProperty('display');
            }
        });
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBar, TC.Control);

(function () {
    var ctlProto = TC.control.NavBar.prototype;

    ctlProto.CLASS = 'tc-ctl-nav';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBar(self);
        }
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);

        if (self.options.home === undefined || self.options.home) {
            map.addControl('navBarHome');
        }        

        //esta chama es para que la primera vez se ajuste la barrita de escala (debido a otra chama con el maxResolution, que es culpa de OL)
        map.loaded(function () {
            self.wrap.refresh();
        });        

        return result;
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBarHome = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBarHome, TC.Control);

(function () {
    var ctlProto = TC.control.NavBarHome.prototype;

    ctlProto.CLASS = 'tc-ctl-nav-home';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBarHome(self);
        }
        return Promise.resolve();
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);        

        map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
            const crs = e.newCrs;
            var bottomLeft = TC.Util.reproject([map.options.initialExtent[0], map.options.initialExtent[1]], map.options.crs, crs);
            var topRight = TC.Util.reproject([map.options.initialExtent[2], map.options.initialExtent[3]], map.options.crs, crs);
            self.wrap.setInitialExtent([bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]);
        });

        return result;
    };

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.OverviewMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.isLoaded = false;

    self.layer = null;
};

TC.inherit(TC.control.OverviewMap, TC.Control);

(function () {
    var ctlProto = TC.control.OverviewMap.prototype;

    ctlProto.CLASS = 'tc-ctl-ovmap';

    ctlProto.template = TC.apiLocation + "TC/templates/OverviewMap.html";

    ctlProto.register = function (map) {
        const self = this;

        const instanceLayer = function (layer) {
            var lyr;

            var findLayerById = function (id, layers) {
                var result = null;
                for (var i = 0; i < layers.length; i++) {
                    var lyr = layers[i];
                    var l = lyr.id || lyr;
                    if (l === id) {
                        result = lyr;
                        break;
                    }
                }
                return result;
            };

            if (typeof layer === 'string') {
                var lyrObj = findLayerById(layer, map.options.availableBaseLayers);
                if (!TC.Util.isPlainObject(lyrObj)) {
                    lyrObj = findLayerById(layer, map.options.baseLayers);
                }
                if (TC.Util.isPlainObject(lyrObj)) {
                    lyr = new TC.layer.Raster(lyrObj);
                }
            }
            else {
                if (layer instanceof TC.Layer) {
                    lyr = layer;
                }
                else if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                    lyr = new TC.layer.Vector(layer);
                }
                else {
                    lyr = new TC.layer.Raster(layer);
                }
            }

            return lyr;
        };

        const registerLayer = function (layer) {
            var lyr;

            lyr = instanceLayer(layer);

            return lyr;
        };

        const resetOVMapProjection = function (e) {
            const resetOptions = {};
            self.layer.getCapabilitiesPromise().then(function () {
                if (!self.layer.isCompatible(map.crs) && self.layer.wrap.getCompatibleMatrixSets(map.crs).length === 0) {
                    resetOptions.layer = self.layer.getFallbackLayer();
                }
                self.wrap.reset(resetOptions);
            });
        };

        const changeBaseLayer = function (e) {
            const self = this;

            if (self.map.baseLayer.type === TC.Consts.layerType.WMS || self.map.baseLayer.type === TC.Consts.layerType.WMTS || self.options.layer) {
                var newLayer = self.map.baseLayer.overviewMapLayer || self.options.layer;
                if (self.layer.id !== newLayer) {
                    var overviewMapLayer = registerLayer(newLayer);
                    self.wrap.reset({
                        layer: overviewMapLayer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                } else if (TC.Consts.event.PROJECTIONCHANGE.indexOf(e.type) > -1) {
                    self.wrap.reset({
                        layer: self.layer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                }
            }
        };

        const result = new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map)
                .then(function (ctl) {
                    self.wrap = new TC.wrap.control.OverviewMap(self);
                    map.loaded(function () {
                        self.defaultLayer = registerLayer(self.options.layer);
                        self.layer = registerLayer(map.baseLayer.overviewMapLayer || self.options.layer || map.options.baseLayers[0] || map.options.availableBaseLayers[0]);

                        self.wrap.register(map);                        

                        resetOVMapProjection({ crs: map.crs });

                        map.on(TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.BASELAYERCHANGE, changeBaseLayer.bind(self));
                    });
                    resolve(ctl);
                })
                .catch(function (err) {
                    reject(err);
                });
        });

        return result;
    };

    ctlProto.loaded = function (callback) {
        var self = this;

        if (TC.Util.isFunction(callback)) {
            if (self.isLoaded && self.map && self.map.isLoaded) {
                callback();
            }
            else {
                self.on(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };

    ctlProto.activate = function () {
        this.enable();
    };

    ctlProto.deactivate = function () {
        this.disable();
    };

    ctlProto.enable = function () {
        var self = this;
        TC.Control.prototype.enable.call(self);
        self.wrap.enable();
    };

    ctlProto.disable = function () {
        var self = this;
        TC.Control.prototype.disable.call(self);
        self.wrap.disable();
    };

})();
TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.PolygonFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYGON;
        self.style = TC.Util.extend(true, { strokeColor: self.DEFAULT_STROKE_COLOR, strokeWidth: 2, fillColor: "#000", fillOpacity: 0.3 }, self.options.style);
    };

    TC.inherit(TC.control.PolygonFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.PolygonFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
TC.Consts.classes.DRAGGED = TC.Consts.classes.DRAGGED || 'tc-dragged';
TC.Consts.classes.DRAGGABLE = TC.Consts.classes.DRAGGABLE || 'tc-draggable';

TC.control.Popup = function () {
    var self = this;

    TC.Control.apply(self, arguments);
    self.currentFeature = null;
    //self.wrap = { popup: null };    
    self.wrap = new TC.wrap.control.Popup(self);
};

TC.inherit(TC.control.Popup, TC.Control);

(function () {
    var ctlProto = TC.control.Popup.prototype;

    ctlProto.CLASS = 'tc-ctl-popup';

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.map.wrap.addPopup(self)
                .then(function () {
                    self.trigger(TC.Consts.event.CONTROLRENDER);
                    resolve();
                },
                function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        return new Promise(function (resolve, reject) {
            Promise.all([result, self.renderPromise()]).then(function () {
                map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (map.view === TC.Consts.view.PRINTING) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer && !e.layer.getVisibility()) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERREMOVE, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.UPDATE, function () {
                    if (!self.currentFeature || self.currentFeature._visibilityState === TC.Consts.visibility.NOT_VISIBLE) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.FEATUREREMOVE, function (e) {
                    if (self.currentFeature === e.feature) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                /**
                    GLS: Controlamos el ancla del popup cuando hay zoom in/out de pantalla o navegador, debería hacerlo OL pero no lo gestiona.
                    No funciona, sólo salta la primera vez, paso a sobrescribir el método de OL
                 */
                //var config = { attributes: true, attributeFilter: ['style', 'class'], childList: false, subtree: false };
                //var observer = new MutationObserver(function (mutationsList, observer) {
                //    //var positionMutation = mutationsList.filter(function (mutation) {
                //    //    return mutation.type === "attributes"
                //    //}).filter(function (mutation) {
                //    //    return ['top', 'right', 'bottom', 'left', 'style'].indexOf(mutation.attributeName) > -1;
                //    //});

                //    if (mutationsList.length > 0) {
                //        // me desconecto para no entrar en un bucle infinito
                //        //observer.disconnect();

                //        var top = mutationsList[0].target[mutationsList[0].attributeName].top;
                //        var right = mutationsList[0].target[mutationsList[0].attributeName].right;
                //        var bottom = mutationsList[0].target[mutationsList[0].attributeName].bottom;
                //        var left = mutationsList[0].target[mutationsList[0].attributeName].left;

                //        [{ top: top }, { right: right }, { bottom: bottom }, { left: left }].forEach(function (elm) {
                //            var key = Object.keys(elm)[0];
                //            if (elm[key].length > 0) {
                //                document.querySelector('.ol-overlay-container').style[key] = parseFloat(elm[key].replace('px', '')) / window.devicePixelRatio + 'px';
                //            }
                //        });

                //        // volvemos a observar
                //        //observer.observe(document.querySelector('.ol-overlay-container'), config);
                //    }
                //});
                //observer.observe(document.querySelector('.ol-overlay-container'), config);

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        })
    };

    ctlProto.fitToView = function (delayed) {
        var self = this;
        if (delayed) {
            setTimeout(function () {
                self.wrap.fitToView();
            }, 1000);
        }
        else {
            self.wrap.fitToView();
        }
    };

    ctlProto.hide = function () {
        var self = this;
        if (self.map) {
            const data = {
                control: self,
                feature: self.currentFeature
            };
            self.map.wrap.hidePopup(self);
            self.setDragged(false);
            self.map.trigger(TC.Consts.event.POPUPHIDE, data);
        }
    };

    ctlProto.getContainerElement = function () {
        return this.contentDiv || null;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv || null;
    };

    ctlProto.setDragged = function (dragged) {
        const self = this;
        self.dragged = dragged;
        if (self.popupDiv) {
            self.popupDiv.classList.toggle(TC.Consts.classes.DRAGGED, !!dragged);
        }
        self.wrap.setDragged(dragged);
    };

    ctlProto.setDragging = function (dragging) {
        const self = this;
        if (dragging) {
            self.setDragged(true);
            self.popupDiv.classList.add(TC.Consts.classes.DRAG);
        }
        else {
            self.popupDiv.classList.remove(TC.Consts.classes.DRAG);
        }
    };

    ctlProto.isVisible = function () {
        const self = this;

        return self.popupDiv && self.popupDiv.classList.contains(TC.Consts.classes.VISIBLE);
    };

})();
TC.control = TC.control || {};

TC.Consts.classes.PRINTABLE = 'tc-printable';




TC.control.Print = function (options)
{
    var self = this;
    var opts = options || {};

    self.ready = false;

    self.title = opts.title || TC.Util.getLocaleString(TC.Cfg.locale, 'printPage');
    self.cssUrl = opts.cssUrl || TC.apiLocation + 'TC/css/print.css';

    if (opts.target)
    {
        const target = opts.target;

        if (!target.querySelector('.' + self.CLASS + '-btn')) {
            //for (var key in self.template) {
            //    if (!dust.cache[key]) {
            //        self.template[key]();
            //    }
            //}
            (opts.printableElement || target).classList.add(TC.Consts.classes.PRINTABLE);

            var renderPage = function (e) {
                var page = open(null, self.CLASS);
                var content = (opts.printableElement || target).innerHTML;
                TC.Control.prototype.getRenderedHtml.call(self, self.CLASS + '-page', { title: self.title, content: content, cssUrl: self.cssUrl })
                    .then(function (out) {
                        page.document.write(out);
                        page.document.close();
                        page.focus();
                    })
                    .catch(function (err) {
                        TC.error(err);
                    });
            };
            TC.Control.prototype.getRenderedHtml.call(self, self.CLASS, null).then(function (out) {
                target.insertAdjacentHTML('afterbegin', out);
                target.querySelector('.' + self.CLASS + '-btn').addEventListener('click', renderPage.bind(self));
            });
        }
    }
};

(function () {
    var ctlProto = TC.control.Print.prototype;

    ctlProto.CLASS = 'tc-ctl-print';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Print.html";
    ctlProto.template[ctlProto.CLASS + '-page'] = TC.apiLocation + "TC/templates/PrintPage.html";

})();
TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.PrintMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.PrintMap, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.PrintMap.prototype;

    ctlProto.CLASS = 'tc-ctl-printMap';

    var self = this;

    const ORIENTATION = {
        PORTRAIT: 'portrait',
        LANDSCAPE: 'landscape'
    };
    const PAGE_SIZE = {
        A4: 'A4',
        A3: 'A3'
    };

    /*
        GLS:
        La librería makePDF se basa en la librería PDFKit explicación sobre la unidad de medida que usa:
        PDF points (72 per inch)
        https://stackoverflow.com/questions/51540144/pdfkit-node-js-measurement-unit
        https://www.ninjaunits.com/converters/pixels/points-pixels/
        https://www.ninjaunits.com/converters/pixels/pixels-points/

        La clave es mantener las dimensiones del mapa en px enteros (canvas sólo admite px enteros), ajustando el layout que está en puntos y que sí admite decimales
    */

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a4 indicando el valor en px la sección del mapa   */
    var a4_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 595,
                height: 842
            },
            pageMargins: [29.5, 14, 29.5, 22.5],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a4 indicando el valor en px la sección del mapa   */
    var a4_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 842,
                height: 595
            },
            pageMargins: [30, 14, 30, 22],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            /*width: 45,*/
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a3 indicando el valor en px la sección del mapa   */
    var a3_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 841.89,
                height: 1190.55
            },
            pageMargins: [29.954, 14, 29.954, 21.55],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a3 indicando el valor en px la sección del mapa   */
    var a3_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 1190.55,
                height: 841.89
            },
            pageMargins: [28.775, 14, 28.775, 14.89],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    const getLayout = function (orientation, format) {
        switch (orientation) {
            case ORIENTATION.PORTRAIT: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_portrait;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_portrait;
                    }
                    default:
                }
                break;
            }
            case ORIENTATION.LANDSCAPE: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_landscape;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_landscape;
                    }
                    default:
                }
                break;
            }
            default:
                return a4_portrait;
        }
    };

    const getLogoColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[0];
    };
    const getTitleColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[1];
    };
    const getScaleBarColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[2];
    };
    const getMap = function (layout) {
        return layout.layoutPDF.content[1].table.body[0][0];
    };

    const options = {
        qrCode: {
            sideLength: 85
        }
    };

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/PrintMap.html";
    ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/PrintMapView.html";
    ctlProto.template[ctlProto.CLASS + '-tools'] = TC.apiLocation + "TC/templates/PrintMapTools.html";

    const hasLegend = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
        });
    };

    const hasLegendToPrint = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            if (layer.type === TC.Consts.layerType.WMS && layer.getVisibility()) {
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        return true;
                    }
                }

                return false;
            }

            return false;
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        const manageLegendOnZoom = function () {
            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            layout.reset();
        };

        const print = function () {

            self.map.setView(TC.Consts.view.PRINTING);

            var codeContainer = document.querySelector('.' + self.CLASS + '-qrcode');
            if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                if (!codeContainer) {
                    codeContainer = document.createElement('div');
                    codeContainer.classList.add(self.CLASS + '-qrcode');
                    self.map.div.appendChild(codeContainer);
                }

                codeContainer.innerHTML = '';
                self.makeQRCode(codeContainer, options.qrCode.sideLength, options.qrCode.sideLength);
            } else {
                if (codeContainer) {
                    codeContainer.innerHTML = '';
                }
            }

            const printBtnSelector = '.' + self.CLASS + '-btn';
            self.map.on(TC.Consts.event.STARTLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.add('disabled');
                printBtn.disabled = true;
            });

            self.map.on(TC.Consts.event.STOPLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.remove('disabled');
                printBtn.disabled = false;
            });

            if (hasLegend.call(self)) {
                // GLS: controlamos si una capa deja de verse por la escala para resetear la leyenda                
                self.map.on(TC.Consts.event.ZOOM, manageLegendOnZoom);
            }

            const updateCanvas = function (printFormat) {
                if (printFormat) {
                    self.map.div.classList.add(printFormat);
                    /**
                     * Validamos que el resultado en pixels sean valores enteros, si no lo son, redondeamos y establecemos evitando estiramiento del canvas /
                     */
                    var bounding = self.map.div.getBoundingClientRect();
                    if (!Number.isInteger(bounding.width)) {
                        self.map.div.style.width = Math.round(bounding.width) + 'px';
                    }
                    if (!Number.isInteger(bounding.height)) {
                        self.map.div.style.height = Math.round(bounding.height) + 'px';
                    }

                    self.map.toast(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'), { type: TC.Consts.msgType.INFO, duration: 7000 });
                }

                self.map.wrap.map.updateSize();
            };

            const resetPrinting = function () {

                var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
                layout.reset();

                if (hasLegend.call(self)) {
                    self.map.off(TC.Consts.event.ZOOM, manageLegendOnZoom);
                }

                self.map.toastHide(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'));

                self.map.div.classList.remove(self.currentFormat, self.CLASS + '-printing');

                self.map.div.style.removeProperty('width');
                self.map.div.style.removeProperty('height');

                updateCanvas();

                self.map.setView(TC.Consts.view.DEFAULT);

                self._viewDiv.classList.add(TC.Consts.classes.HIDDEN);
            };

            if (!self._viewDiv) {
                self._viewDiv = TC.Util.getDiv();
                document.body.appendChild(self._viewDiv);

                self.getRenderedHtml(self.CLASS + '-view', null, function (html) {
                    self._viewDiv.innerHTML = html;
                });

                self.getRenderedHtml(self.CLASS + '-tools', null, function (html) {
                    self.map.div.insertAdjacentHTML('beforeend', html);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-close').addEventListener('click', resetPrinting);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-pdf').addEventListener('click', self.createPdf.bind(self));
                });
            }

            self.orientation = self.div.querySelector("#print-design").value;
            self.format = self.div.querySelector("#print-size").value;

            self.currentFormat = self.CLASS + '-' + self.orientation + '-' + self.format;

            self._viewDiv.classList.remove(TC.Consts.classes.HIDDEN);

            self.map.div.classList.add(self.CLASS + "-printing");
            updateCanvas(self.currentFormat);
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn', print));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('#' + self.CLASS + '-image-qr', function (evt) {
            self.generateLink();
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.createPdf = function () {
        var self = this;

        var loadingCtrl = self.map.getControlsByClass(TC.control.LoadingIndicator)[0];
        var hasWait = loadingCtrl.addWait();

        TC.loadJS(!window.pdfMake, [TC.Consts.url.PDFMAKE], function () {
            const olViewport = self.map.div.querySelectorAll('.ol-viewport');
            for (var i = 0, len = olViewport.length; i < len; i++) {
                const elm = olViewport[i];
                if (!elm.parentElement.classList.contains('ol-overviewmap-map')) {
                    self.canvas = elm.querySelector('canvas');
                    break;
                }
            }

            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            var printLayout = layout.layoutPDF;

            const createPDF = function (printLayout) {
                var filename = window.location.host + '_';
                var title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();

                if (title) {
                    filename += title;
                } else {
                    var currentDate = TC.Util.getFormattedDate(new Date().toString(), true);
                    filename += currentDate;
                }

                try {
                    pdfMake.createPdf(printLayout).download(filename.replace(/[\\\/:*?"<>\|]/g, "") + '.pdf');
                } catch (error) {
                    self.map.toast(self.getLocaleString('print.error'), { type: TC.Consts.msgType.ERROR });
                    TC.error(error.message + '  ' + error.stack, TC.Consts.msgErrorMode.EMAIL);
                }

                loadingCtrl.removeWait(hasWait);
            };

            const imageErrorHandling = function (imageUrl) {
                TC.error(self.getLocaleString('print.error'));
                TC.error('No se ha podido generar el base64 correspondiente a la imagen: ' + imageUrl, TC.Consts.msgErrorMode.EMAIL, 'Error en la impresión'); //Correo de error
            };

            const getLogo = function () {

                const onLogoError = function () {
                    var logoColumn = getLogoColumn(layout);
                    delete logoColumn.image;
                    logoColumn.text = "";
                    return logoColumn;
                };

                if (self.options.logo) {
                    return TC.Util.imgToDataUrl(self.options.logo, 'image/png').then(function (result) {
                        const canvas = result.canvas;
                        const dataUrl = result.dataUrl;
                        var size = TC.Util.calculateAspectRatioFit(canvas.width, canvas.height, layout.logoWidth, layout.logoHeight);

                        var logoColumn = getLogoColumn(layout);
                        //URI: si no se define la anchura en el layout calcula la anchura en función de proporción entre ancho y alto de la imagen y el alto de su posición en el PDF
                        if (!logoColumn.width)
                            logoColumn.width = (canvas.width / canvas.height) * logoColumn.height;
                        logoColumn.image = dataUrl;
                        return logoColumn;

                    }, function () {
                        imageErrorHandling(self.options.logo);

                        return onLogoError();
                    });
                } else {
                    return onLogoError();
                }
            };
            const getScaleBar = function () {
                const onError = function () {
                    var scaleBarColumn = getScaleBarColumn(layout);
                    delete scaleBarColumn.image;
                    scaleBarColumn.text = "";
                    scaleBarColumn.width = "auto";
                    return scaleBarColumn;
                };

                var scaleCtrl = self.map.getControlsByClass(TC.control.ScaleBar)[0];
                if (scaleCtrl) {
                    var elem = document.getElementsByClassName("ol-scale-line-inner"); // no cogemos el DIV del control ya que contiene los bordes y suman al ancho total
                    var bounding = elem[0].getBoundingClientRect();
                    if (bounding) {
                        var styling = getComputedStyle(elem[0], null);
                        var leftBorder = parseInt(styling.getPropertyValue('border-left-width').replace('px', '')) || 0;
                        var rightBorder = parseInt(styling.getPropertyValue('border-right-width').replace('px', '')) || 0;

                        var scaleBarColumn = getScaleBarColumn(layout);

                        scaleBarColumn.table = {
                            widths: [((bounding.width > bounding.height ? bounding.width : bounding.height) - leftBorder - rightBorder) * 0.75], // lo pasamos a pt
                            body: [
                                [{ border: [true, false, true, true], text: scaleCtrl.getText(), fontSize: 10, alignment: 'center' }]
                            ]
                        };

                        scaleBarColumn.layout = {
                            paddingLeft: function (i, node) { return 0; },
                            paddingRight: function (i, node) { return 0; },
                            paddingTop: function (i, node) { return 0; },
                            paddingBottom: function (i, node) { return 0; }
                        };

                        return scaleBarColumn;
                    } else {
                        return onError();
                    }
                } else {
                    return onError();
                }
            };
            const getLegend = function () {
                var content = [];
                var layers = self.map.workLayers.filter(function (layer) {
                    return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
                });
                var legendByGroup = [];
                var indentationIncrement = 7;

                var _process = function (value, parentLayer, treeLevel) {
                    if (parentLayer.isVisibleByScale(value.name)) { //Si la capa es visible, la mostramos en la leyenda
                        var src,
                            srcBase64;

                        //Para las capas cargadas por POST (por ejemplo la búsquedas de Comercio Pamplona)
                        if (parentLayer.options && parentLayer.options.params && parentLayer.options.params.base64LegendSrc) {
                            srcBase64 = parentLayer.options.params.base64LegendSrc;
                        }
                        else if (value.legend) {
                            src = value.legend.src;
                        }

                        result.push({ src: src, title: value.title, level: treeLevel, srcBase64: srcBase64 });
                    }
                };
                var _traverse = function (o, func, parentLayer, treeLevel) {
                    if (Array.isArray(o)) {
                        for (var i = 0; i < o.length; i++) {
                            _traverse(o[i], func, parentLayer, treeLevel);
                        }
                    } else {
                        if (o && o.hasOwnProperty('children') && o.children.length > 0) {
                            if (o.title && o.name) {
                                result.push({ header: o.title, level: treeLevel });
                            }
                            _traverse(o.children, func, parentLayer, ++treeLevel);
                        }
                    }

                    if (o && o.hasOwnProperty('children') && o.children.length == 0) {
                        func.apply(this, [o, parentLayer, treeLevel]);
                        treeLevel--;
                    }
                };
                var _getLegendImages = function () {
                    var imagePromises = [];

                    for (var i = 0; i < legendByGroup.length; i++) {
                        var layers = legendByGroup[i].layers;

                        for (var j = 0; j < layers.length; j++) {
                            (function (k, l) {
                                var layer = legendByGroup[k].layers[l];
                                var src = layer.src || layer.srcBase64;

                                if (src) {

                                    if (!TC.tool || !TC.tool.Proxification) {
                                        TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
                                    }

                                    imagePromises.push(new Promise(function (resolve, reject) {
                                        var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: true });
                                        toolProxification.fetchImage(src, { exportable: true }).then(function (img) {
                                            if (img.complete) {
                                                var imageDetail = TC.Util.imgTagToDataUrl(img, 'image/png');
                                                layer.image = { base64: imageDetail.base64, canvas: imageDetail.canvas };
                                            } else {
                                                imageErrorHandling(src);
                                            }

                                            resolve();

                                        }, function (error) {
                                            imageErrorHandling(src);
                                            reject(error);
                                        });
                                    }));
                                }
                            })(i, j);
                        }
                    }

                    return imagePromises;
                };

                layers.forEach(function (layer) {
                    result = [];

                    var hideTree = layer.options.hideTree;

                    layer.tree = null;
                    layer.options.hideTree = true;

                    _traverse(layer.getTree(), _process, layer, 0);

                    layer.options.hideTree = hideTree;

                    if (result.length > 0) {
                        legendByGroup.push({ title: layer.title, layers: result });
                    }
                });

                return new Promise(function (resolve, reject) {
                    Promise.all(_getLegendImages()).then(function () {

                        const getGroupTable = function (group, index) {                            
                            var rows = [[{ text: group.title, colSpan: 2, alignment: 'left', fontSize: 11, margin: [0, index > 0 ? 10 : 0, 0, 5] }, {}]];
                            var indentation = 10;

                            rows = rows.concat(group.layers.filter(function (item) {
                                return item.hasOwnProperty('header') && item.header.trim().toLowerCase() !== group.title.trim().toLowerCase();
                            }).map(function (item) {
                                return [{ text: item.header.trim(), colSpan: 2, alignment: 'left', margin: [indentation * item.level, 0, 0, 3] }, {}];
                            }));

                            const headerRows = rows.length;
                            var headerItem = null;
                            var itemIndex = null;

                            const getLayerTable = function (item, index) {
                                if (item.header) {
                                    headerItem = item;

                                    if (itemIndex) {
                                        itemIndex = null;
                                    }
                                } else {
                                    if (!itemIndex) {
                                        itemIndex = 1;
                                    }

                                    var position;
                                    if (headerItem) {
                                        var headerIndex = rows.map(function (item) { return item[0].text }).indexOf(headerItem.header);
                                        position = headerIndex + itemIndex++;
                                    }

                                    if (item.image) {
                                        var imageWidth = item.image.canvas.width / 2;
                                        var imageHeight = (imageWidth * item.image.canvas.height / item.image.canvas.width);

                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            width: 'auto',
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {
                                            image: item.image.base64,
                                            width: imageWidth,
                                            height: imageHeight,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }

                                    } else {
                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            colSpan: 2,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {}];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }
                                    }
                                }
                            };

                            group.layers.forEach(getLayerTable);

                            content.push({
                                layout: 'noBorders',
                                table: {
                                    dontBreakRows: true,
                                    keepWithHeaderRows: 1,
                                    headerRows: headerRows,
                                    body: rows
                                }
                            });
                        };

                        legendByGroup.map(function (group, index) {
                            return {
                                groupIndex: index,
                                height: group.layers.filter(function (item) {
                                    return item.image && item.image.canvas;
                                }).reduce(function (prev, current, index, vector) {
                                    return prev + vector[index].image.canvas.height;
                                }, 0)
                            }
                        }).sort(function (a, b) {
                            if (a.height > b.height) {
                                return 1;
                            }
                            if (a.height < b.height) {
                                return -1;
                            }
                            return 0;
                        }).forEach(function (groupWithHeight, index) {
                            getGroupTable(legendByGroup[groupWithHeight.groupIndex], index)
                        });

                        resolve(content);

                    }, function () {
                        reject([]);
                    });
                });
            };
            const drawQR = function () {
                // GLS: añadimos el QR
                //QR
                if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                    const qrTarget = document.querySelector('.' + self.CLASS + '-qrcode');
                    qrTarget.innerHTML = '';
                    return self.makeQRCode(qrTarget, options.qrCode.sideLength, options.qrCode.sideLength).then(function (qrCodeBase64) {
                        if (qrCodeBase64) {
                            return TC.Util.addToCanvas(self.canvas, qrCodeBase64, { x: self.canvas.width - options.qrCode.sideLength, y: self.canvas.height - options.qrCode.sideLength }, {width: options.qrCode.sideLength, height: options.qrCode.sideLength }).then(function (mapCanvas) {
                                return mapCanvas;
                            });
                        } else {
                            TC.error(self.getLocaleString('print.qr.error'));
                            return self.canvas;
                        }
                    });
                } else {
                    return self.canvas;
                }
            };

            const basics = [getLogo, function () {
                var titleColumn = getTitleColumn(layout);
                titleColumn.text = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                return titleColumn;
            }, getScaleBar, drawQR];

            Promise.all(basics.map(function (fn) {
                return fn();
            })).then(function (basicsDone) {

                if (basicsDone[2].table) { // GLS: ajustamos el ancho del título para arrinconar la escala
                    layout.layoutPDF.content[0].columns[1].width = layout.layoutPDF.pageSize.width - (layout.layoutPDF.pageMargins[0] + layout.layoutPDF.pageMargins[2]) - layout.layoutPDF.content[0].columns[0].width - (layout.layoutPDF.content[0].columns[2].table.widths[0] + 2);
                }

                var mapPlace = getMap(layout);
                var canvas = basicsDone[3] || self.canvas;

                mapPlace.image = canvas.toDataURL();

                if (self.options.legend &&
                    self.options.legend.visible &&
                    hasLegendToPrint.call(self) && // GLS: validamos que haya capas visibles por escala 
                    printLayout.content.length == 2) { // GLS: es la primera descarga o hemos resetado la leyenda por algún zoom por lo que no tenemos la leyenda en el layout

                    const title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                    printLayout.content.push({
                        pageBreak: 'before',
                        pageOrientation: self.options.legend.orientation || 'portrait',
                        text: title.length > 0 ? title : '',
                        fontSize: 14,
                        margin: [0, 20, 0, 10]
                    });

                    getLegend().then(function (content) {
                        printLayout.content = printLayout.content.concat(content);
                        createPDF(printLayout);
                    });
                } else {
                    createPDF(printLayout);
                }
            });
        });
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const alertElm = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
            alertElm.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
        } else {
            alertElm.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.DRAWCHART = 'drawchart.tc';
TC.Consts.event.DRAWTABLE = 'drawtable.tc';
TC.Consts.event.RESULTSPANELMIN = 'resultspanelmin.tc';
TC.Consts.event.RESULTSPANELMAX = 'resultspanelmax.tc';
TC.Consts.event.RESULTSPANELCLOSE = 'resultspanelclose.tc';

TC.control.ResultsPanel = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.wrap = new TC.wrap.control.ResultsPanel(self);

    self.data = {};
    self.classes = {
        FA: 'fa',
        SHOW_IN: 'showIn',
        SHOW_OUT: 'showOut'
    };

    self.contentType = {
        TABLE: {
            fnOpen: TC.control.ResultsPanel.prototype.openTable,
            collapsedClass: '.fa-list-alt'
        },
        CHART: {
            fnOpen: TC.control.ResultsPanel.prototype.openChart,
            collapsedClass: '.fa-area-chart'
        }
    };

    self.content = self.contentType.TABLE;

    if (TC.Util.isEmptyObject(self.options)) {
        self.options = { content: "table" };
    }

    if (self.options || { content: "table" }) {
        if (self.options.content)
            self.content = self.contentType[self.options.content.toUpperCase()];

        if (self.options.chart)
            self.chart = self.options.chart;

        if (self.options.table)
            self.table = self.options.table;

        if (self.options.save)
            self.save = self.options.save;

    }
};

TC.inherit(TC.control.ResultsPanel, TC.Control);

(function () {

    const ctlProto = TC.control.ResultsPanel.prototype;

    ctlProto.CLASS = 'tc-ctl-p-results';

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 215,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ResultsPanel.html";
    ctlProto.template[ctlProto.CLASS + '-table'] = TC.apiLocation + "TC/templates/ResultsPanelTable.html";
    ctlProto.template[ctlProto.CLASS + '-chart'] = TC.apiLocation + "TC/templates/ResultsPanelChart.html";

    const isElementVisible = function (elm) {
        const computedStyle = getComputedStyle(elm);
        return (elm && !elm.hidden && computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden');
    };

    ctlProto.isVisible = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(bodyElm) || isElementVisible(maximizeElm);
    };

    ctlProto.isMinimized = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(maximizeElm) && !isElementVisible(bodyElm);
    };

    const manageClassList = function (classElement, toAdd, toRemove) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.classList.add(toAdd);
            elm.classList.remove(toRemove);
        }
    };

    ctlProto.show = function (classElement) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm && elm.style.display === 'none') {
            elm.style.display = '';
        }

        manageClassList.call(self, classElement, self.classes.SHOW_IN, self.classes.SHOW_OUT);
    };

    ctlProto.hide = function (classElement) {
        const self = this;

        manageClassList.call(self, classElement, self.classes.SHOW_OUT, self.classes.SHOW_IN);

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.style.display = 'none';
        }
    };

    ctlProto.doVisible = function () {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);
        self.show('prsidebar-body');
    };

    ctlProto.render = function (callback) {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        return TC.Control.prototype.render.call(self, function () {

            self.mainTitleElm = self.div.querySelector('.prpanel-title-text');

            self.minimizeButton = self.div.querySelector('.prcollapsed-slide-submenu-min');
            self.minimizeButton.addEventListener('click', function () {
                self.minimize();
            });

            self.closeButton = self.div.querySelector('.prcollapsed-slide-submenu-close');
            self.closeButton.addEventListener('click', function () {
                self.close();
            });

            self.maximizeButton = self.div.querySelector('.prcollapsed-max');
            self.maximizeButton.addEventListener('click', function () {
                self.maximize();
            });

            if (self.save) {
                self.saveButton = self.div.querySelector('.prcollapsed-slide-submenu-csv');
                self.saveButton.addEventListener('click', function () {
                    self.exportToExcel();
                });
                self.saveButton.removeAttribute('hidden');
            }
            if (self.options.download && self.options.content === "table") {
                self.downloadButton = self.div.querySelector('.prcollapsed-slide-submenu-dwn');
                self.downloadButton.addEventListener('click', function () {
                    if (TC.Util.isFunction(self.options.download)) {
                        self.options.download.apply(self,[]);
                    }
                });
                self.downloadButton.removeAttribute('hidden');
            }           
            

            if (self.content) {
                self.content = self.content;

                if (self.options.titles) {

                    if (self.options.titles.main) {
                        self.mainTitleElm.setAttribute('title', self.options.titles.main);
                        self.mainTitleElm.innerHTML = self.options.titles.main;
                    }

                    if (self.options.titles.max) {
                        self.maximizeButton.setAttribute('title', self.options.titles.max);
                    }
                } else {
                    self.mainTitleElm.setAttribute('title', self.getLocaleString("rsp.title"));
                    self.mainTitleElm.innerHTML = self.getLocaleString("rsp.title");
                }
            }

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            //collapsedElm.hidden = false;
            collapsedElm.classList.add(self.classes.FA);

            self.infoDiv = self.div.querySelector('.' + self.CLASS + '-info');
            self.tableDiv = self.div.querySelector('.' + self.CLASS + '-table');
            //self.$divChart = self._$div.find('.' + self.CLASS + '-chart');
            self.menuDiv = self.div.querySelector('.' + self.CLASS + '-menu');

            if (TC.browserFeatures.touch()) {
                TC.Util.swipe(self.div, {
                    left: function () {
                        self.minimize();
                    }
                });
            }

            if (callback && typeof (callback) === "function")
                callback.call();
        });
    };

    ctlProto.minimize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (!isElementVisible(collapsedElm)) { // ya está minimizado
            collapsedElm.classList.add(self.classes.FA);
            collapsedElm.hidden = false;

            self.hide('prsidebar-body');
            self.show('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMIN, { control: self });
        }
    };

    ctlProto.maximize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) { // ya está maximizado
            collapsedElm.hidden = true;

            self.show('prsidebar-body');
            self.hide('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMAX, { control: self });
        }
    };

    ctlProto.close = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        if (self.chart && self.chart.chart) {
            self.chart.chart = self.chart.chart.destroy();
        }

        const body = self.div.querySelector('.prsidebar-body');
        if (body) {
            body.style.display = 'none';
            self.div.querySelector('.prcollapsed-max').style.display = 'none';

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            collapsedElm.hidden = true;
            collapsedElm.classList.remove(self.classes.FA);

            self.map.trigger(TC.Consts.event.RESULTSPANELCLOSE, { control: self });
        }
    };

    ctlProto.openChart = function (data) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        // Cerramos el resto de los perfiles
        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self;
            })
            .filter(function (ctl) {
                return ctl.options.content === 'chart';
            })
            .forEach(function (ctl) {
                ctl.close();
            });

        if (data) {

            if (data.msg) {
                self.map.toast(data.msg);
            }
            else {
                self.elevationProfileChartData = data;
                self.renderElevationProfileChart({
                    data: data,
                    div: self.div.querySelector('.' + ctlProto.CLASS + '-chart')
                });
            }
        } else {
            self.map.toast(options.msg);
        }
    };

    ctlProto.renderElevationProfileChart = function (options) {
        const self = this;
        options = options || {};
        TC.loadJS(!window.c3,
            TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js',
            function () {
                const data = options.data;
                data.ele = data.ele.map(val => val === null ? 0 : val);
                const div = options.div;
                var locale = TC.Util.getMapLocale(self.map);
                self.getRenderedHtml(ctlProto.CLASS + '-chart', {
                    upHill: data.upHill ? data.upHill.toLocaleString(locale) : '0',
                    downHill: data.downHill ? data.downHill.toLocaleString(locale) : '0'
                }, function (out) {

                    div.innerHTML = out;
                    div.style.display = '';

                    if (self.options.titles) {

                        if (self.options.titles.main) {
                            const titleElm = self.div.querySelector('.prpanel-title-text');
                            titleElm.setAttribute('title', self.options.titles.main);
                            titleElm.innerHTML = self.options.titles.main;
                        }

                        if (self.options.titles.max) {
                            self.div.querySelector('.prcollapsed-max').setAttribute('title', self.options.titles.max);
                        }
                    }
                    var chartOptions = TC.Util.extend({
                        bindto: div.querySelector('.tc-chart'),
                        padding: {
                            top: 0,
                            right: 15,
                            bottom: 0,
                            left: 45,
                        },
                        legend: {
                            show: false
                        }
                    }, self.createChartOptions(data));

                    if (self.chart.tooltip) {
                        chartOptions.tooltip = {
                            contents: function (d) {
                                var fn = self.chart.tooltip;
                                if (typeof (fn) !== "function")
                                    fn = TC.Util.getFnFromString(self.chart.tooltip);
                                return fn.call(eval(self.chart.ctx), d);
                            }
                        }
                    }

                    if (self.chart && self.chart.onmouseout) {
                        chartOptions.onmouseout = function () {
                            var fn = self.chart.onmouseout;
                            if (typeof (fn) !== "function")
                                fn = TC.Util.getFnFromString(self.chart.onmouseout);
                            fn.call(eval(self.chart.ctx));
                        };
                    }

                    chartOptions.onrendered = function () {                        
                        if (TC.Util.isFunction(chartOptions._onrendered)) {
                            chartOptions._onrendered.call(this);
                        }
                        self.map.trigger(TC.Consts.event.DRAWCHART, { control: self, svg: this.svg[0][0], chart: this });
                    };

                    if (window.c3) {

                        if (!c3._isOverriden) {
                            // GLS: Override de la función generateDrawLine y generateDrawArea para establecer otro tipo de interpolación en la línea
                            window.c3.chart.internal.fn.generateDrawLine = function (lineIndices, isSub) {
                                var $$ = this, config = $$.config,
                                    line = $$.d3.svg.line(),
                                    getPoints = $$.generateGetLinePoints(lineIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    yValue = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
                                if (!config.line_connectNull) { line = line.defined(function (d) { return d.value != null; }); }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x = isSub ? $$.x : $$.subX, y = yScaleGetter.call($$, d.id), x0 = 0, y0 = 0, path;
                                    if ($$.isLineType(d)) {
                                        if (config.data_regions[d.id]) {
                                            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                                        } else {
                                            if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                            path = line.interpolate('linear')(values);
                                        }
                                    } else {
                                        if (values[0]) {
                                            x0 = x(values[0].x);
                                            y0 = y(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            window.c3.chart.internal.fn.generateDrawArea = function (areaIndices, isSub) {
                                var $$ = this, config = $$.config, area = $$.d3.svg.area(),
                                    getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    value0 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(0);
                                    },
                                    value1 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(value0).y1(value1);
                                if (!config.line_connectNull) {
                                    area = area.defined(function (d) { return d.value !== null; });
                                }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x0 = 0, y0 = 0, path;
                                    if ($$.isAreaType(d)) {
                                        if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                        path = area.interpolate('linear')(values);
                                    } else {
                                        if (values[0]) {
                                            x0 = $$.x(values[0].x);
                                            y0 = $$.getYScale(d.id)(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            c3._isOverriden = true;
                        }

                        self.chart.chart = c3.generate(chartOptions);
                    }
                });
            }
        );
    };

    const closeOpenedTableResultsPanel = function () {
        const self = this;

        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self && ctl.isVisible();
            })
            .filter(function (ctl) {
                return ctl.options.content !== self.contentType.CHART;
            })
            .forEach(function (ctl) {
                ctl.close();
            });
    };

    ctlProto.openTable = function () {
        var self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        var data = arguments[0];
        if (data) {

            var css;
            if (data.css) {
                css = data.css;
            }
            var callback = data.callback;
            var columns = data.columns, data = data.data;

            if (data && data.length > 0) {
                //Si no recibe columnas, las extrae de las claves del primer objeto de la colección de datos
                if (!columns) {
                    columns = [];
                    for (var k in data[0]) {
                        columns.push(k);
                    }
                }

                //deleteColumns();

                self.tableData = {
                    columns: columns,
                    results: data,
                    css: css,
                    callback: callback
                }
                self.getRenderedHtml(self.CLASS + '-table', self.tableData).then(function (html) {
                    const table = self.div.querySelector('.' + self.CLASS + '-table');
                    const parent = table.parentElement;
                    parent.removeChild(table);
                    table.innerHTML = html;
                    parent.appendChild(table);
                    if (self.tableData.callback) {
                        self.tableData.callback(table);
                    }

                    closeOpenedTableResultsPanel.call(self);

                    self.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
                });

                self.div.querySelector('.' + self.CLASS + '-chart').style.display = 'none';
                self.div.querySelector('.' + self.CLASS + '-info').style.display = 'none';

                self.show('prsidebar-body');
            }
        }
    };

    ctlProto.open = function (html, container) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        const toCheck = container || self.div.querySelector('.' + self.CLASS + '-table');
        var checkIsRendered = function () {
            var clientRect = toCheck.getBoundingClientRect();
            if (clientRect && clientRect.width > 100) {
                window.cancelAnimationFrame(this.requestIsRendered);

                //closeOpenedTableResultsPanel.call(self);
                this.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
            }
        };

        self.requestIsRendered = window.requestAnimationFrame(checkIsRendered.bind(self));

        const chartElm = self.div.querySelector('.' + self.CLASS + '-chart');
        chartElm.style.display = 'none';
        const tableElm = self.div.querySelector('.' + self.CLASS + '-table');
        tableElm.style.display = 'none';
        const infoElm = self.div.querySelector('.' + self.CLASS + '-info');
        infoElm.style.display = 'none';

        if (html) {
            if (container) {
                self.getTableContainer = function () {
                    return container;
                };
                container.innerHTML = html;
                container.style.display = '';
            } else {
                tableElm.innerHTML = html;
                tableElm.style.display = '';
            }
        }

        const maximizeElm = self.div.querySelector('.prcollapsed-max');

        if (self.options.titles) {

            if (self.options.titles.main) {
                const titleElm = self.div.querySelector('.prpanel-title-text');
                titleElm.setAttribute('title', self.options.titles.main);
                titleElm.innerHTML = self.options.titles.main;
            }

            if (self.options.titles.max) {
                maximizeElm.setAttribute('title', self.options.titles.max);
            }
        }

        if (self.options.classes) {
            if (self.options.classes.collapsed) {
                maximizeElm.querySelector('i.fa-list-alt').classList.add(self.options.classes.collapsed);
            }
        }

        // si está minimizado
        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) {
            self.maximize();
        }

        self.show('prsidebar-body');
        self.hide('prcollapsed-max');
    };

    ctlProto.createChartOptions = function (options) {
        const self = this;
        var result = {};
        options = options || {};
        const locale = options.locale || TC.Util.getMapLocale(self.map);
        switch (options.chartType) {
            default:
                if (options.ele != null) {
                    const getChartSize = function () {
                        const panelStyle = getComputedStyle(self.getContainerElement());
                        const docWidth = document.documentElement.clientWidth / 100 * 40; // css panel contendor
                        const r = {
                            height: docWidth > 445 ? options.maxHeight || self.CHART_SIZE.MAX_HEIGHT : options.minHeight || self.CHART_SIZE.MIN_HEIGHT
                        };
                        // Si el panel ocupa el ancho del mapa dejamos el ancho del perfil que ocupe todo, en cualquier otro caso tenemos tres anchos predefinidos.
                        if (panelStyle.width === getComputedStyle(self.map.div).width) {
                            r.width = parseFloat(panelStyle.width) * 0.95;
                        }
                        else {
                            r.width = docWidth > 445 ? options.maxWidth || self.CHART_SIZE.MAX_WIDTH : docWidth > 310 ? options.mediumWidth || self.CHART_SIZE.MEDIUM_WIDTH : options.minWidth || self.CHART_SIZE.MIN_WIDTH
                        }
                        return r;
                    };

                    var maxy = Number.NEGATIVE_INFINITY;
                    var miny = Number.POSITIVE_INFINITY;
                    options.ele.forEach(function (y) {
                        if (typeof y === 'number') {
                            maxy = Math.max(y, maxy);
                            miny = Math.min(y, miny);
                        }
                    });

                    const gradId = 'grad' + TC.getUID();

                    result = {
                        data: {
                            x: 'x',
                            columns: [['x'].concat(options.x), ['ele'].concat(options.ele)],
                            types: { 'ele': 'area-spline' }, colors: {
                                "ele": 'url(#' + gradId + ')'
                            }
                        },
                        size: getChartSize(),
                        point: {
                            show: false
                        },
                        axis: {
                            x: {
                                tick: {
                                    outer: false,
                                    count: 5, format: function (d) {
                                        d = d / 1000;
                                        var dist;
                                        var measure;
                                        if (d < 1) {
                                            dist = Math.round(d * 1000);
                                            measure = ' m';
                                        } else {
                                            dist = Math.round(d * 100) / 100;
                                            measure = ' km';
                                        }

                                        dist = dist.toLocaleString(locale);
                                        return dist + measure;
                                    }
                                }
                            },
                            y: {
                                padding: {
                                    top: 0, bottom: 0
                                },
                                max: maxy,
                                min: miny,
                                tick: {
                                    count: 2,
                                    format: function (d) {
                                        return (parseInt(d.toFixed(0)) || 0).toLocaleString(locale) + 'm';
                                    }
                                }
                            }
                        },
                        onresize: function () {
                            this.api.resize(getChartSize());                            
                        }
                    }

                    if (options.time) result.time = ("00000" + options.time.h).slice(-2) + ':' + ("00000" + options.time.m).slice(-2) + ':' + ("00000" + options.time.s).slice(-2);

                    result._onrendered = function () {
                        const svg = this.svg[0][0];
                        var svgDefsElement = svg.getElementsByTagName('defs')[0];
                        var xmlns = "http://www.w3.org/2000/svg";
                        var grad = document.createElementNS(xmlns, "linearGradient");
                        grad.setAttributeNS(null, "id", gradId);
                        grad.setAttributeNS(null, "x1", "0%");
                        grad.setAttributeNS(null, "x2", "0%");
                        grad.setAttributeNS(null, "y1", "0%");
                        grad.setAttributeNS(null, "y2", "100%");
                        grad.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");

                        const stop0 = document.createElementNS(xmlns, "stop");
                        stop0.setAttributeNS(null, "offset", "0%");
                        stop0.setAttributeNS(null, "stop-color", "red");
                        stop0.setAttributeNS(null, "stop-opacity", "0.7");
                        grad.appendChild(stop0);

                        const stop50 = document.createElementNS(xmlns, "stop");
                        stop50.setAttributeNS(null, "offset", "50%");
                        stop50.setAttributeNS(null, "stop-color", "orange");
                        stop50.setAttributeNS(null, "stop-opacity", "0.9");
                        grad.appendChild(stop50);

                        const stop100 = document.createElementNS(xmlns, "stop");
                        stop100.setAttributeNS(null, "offset", "100%");
                        stop100.setAttributeNS(null, "stop-color", "green");
                        stop100.setAttributeNS(null, "stop-opacity", "1");
                        grad.appendChild(stop100);

                        svgDefsElement.appendChild(grad);

                        const d3Node = d3.select(".c3-brush").node();
                        if (d3Node) {
                            d3Node.parentNode.removeChild(d3Node);
                        }

                        d3.select(".c3-event-rects,.c3-event-rects-single")
                            .selectAll("rect")
                            .style("cursor", "pointer")
                            .on("click", function (e) {
                                d3.event.stopPropagation();
                                const point = self.elevationProfileChartData.coords[e.index].slice(0, 2);
                                if (point) {
                                    TC.loadJS(!TC.feature || (TC.feature && !TC.feature.Point),
                                        [TC.apiLocation + 'TC/feature/Point'],
                                        function () {
                                            self.map.zoomToFeatures([new TC.feature.Point(point, {})]);
                                        }
                                    );
                                }
                            });

                        var pattern = d3.select('.c3-axis.c3-axis-x').select('path').attr('d');
                        var match = /^M\d\,(\d)V\dH\d{3}V(\d)$/i.exec(pattern);
                        if (match) { // quitamos las barritas de los extremos del axis-x
                            pattern = pattern.replace(/(M\d\,)\d/i, "$10").replace(/(H\d{3}V)(\d)/i, "$10");
                            d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                        } else {
                            var match = /^M\s\d\s(\d)\sV\s\d\sH\s\d{3}\sV\s(\d)$/i.exec(pattern);
                            if (match) { // quitamos las barritas de los extremos del axis-x
                                pattern = pattern.replace(/(M\s\d\s)\d/i, "$10").replace(/(H\s\d{3}\sV\s)(\d)/i, "$10");
                                d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                            }
                        }

                        const svgRect = svg.getBoundingClientRect();
                        const chartSize = {
                            width: svgRect.width,
                            height: svgRect.height
                        };

                        // ¿es necesario pasar los labels a multiline?
                        var setMultilineLabels = function () {
                            var x = d3.scale.ordinal().rangeRoundBands([0, chartSize.width], .1, .3);
                            d3.select('.c3-axis-x').selectAll('text:not(.c3-axis-x-label)')
                                .call(function (textNode, width) {
                                    textNode.each(function () {
                                        textNode.each(function (d, i) {
                                            if (i == 0) return;

                                            d3text = d3.select(this);
                                            
                                            if (d3text.node().childNodes.length === 1) {                                                
                                                var clone = d3text.select('tspan').node().cloneNode();
                                                var words = d3text.text().split(' ');

                                                d3text.select('tspan').text(words[0]);
                                                clone.textContent = words[1];
                                                var dy = clone.getAttribute('dy');
                                                dy = dy ? parseFloat(clone.getAttribute('dy')) : .71;
                                                dy = dy + 0.18 + 'em';
                                                clone.setAttribute('dy', dy);
                                                d3text.node().appendChild(clone);
                                            }
                                        });
                                    });
                                }, x.rangeBand());
                        };
                        if (!d3.select('.c3-axis-x').node().getBoundingClientRect().width) {

                            if (self.elevationChartLabelsRAF) {
                                window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                self.elevationChartLabelsRAF = undefined;
                            }

                            function hasSize() {
                                if (d3.select('.c3-axis-x').length && !(d3.select('.c3-axis-x').node())) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                }
                                else if (d3.select('.c3-axis-x').length && d3.select('.c3-axis-x').node() &&
                                    !d3.select('.c3-axis-x').node().getBoundingClientRect().width) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                } else {
                                    window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                    self.elevationChartLabelsRAF = undefined;

                                    if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                                        (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                                        setMultilineLabels();
                                    }
                                }
                            }

                            self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                        }
                        else if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                            (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                            setMultilineLabels();
                        }

                        if (!self.isMinimized()) {
                            self.show('prsidebar-body');
                            self.hide('prcollapsed-max');
                        }


                        self.div.querySelector('.' + self.CLASS + '-table').style.display = '';
                        self.div.querySelector('.' + self.CLASS + '-info').style.display = '';
                    }
                }
                else {
                    result = {
                        msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                    };
                }
                break;
        }
        return result;
    };

    const getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return TC.Util.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.getElevationChartTooltip = function (data) {
        const self = this;
        const coords = self.elevationProfileChartData.coords;
        var distance = data[0].x;
        distance = distance / 1000;

        const p = coords[data[0].index];
        var doneTime;
        if (coords[0].length == 4 && coords[0][3] > 0) {
            doneTime = getTime(coords[0][3], p[3]);
        }

        const locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
        const ele = parseInt(data[0].value.toFixed(0)).toLocaleString(locale);
        var dist;
        var measure;
        if (distance < 1) {
            dist = Math.round(distance * 1000);
            measure = ' m';
        } else {
            dist = Math.round(distance * 100) / 100;
            measure = ' km';
        }
        dist = dist.toLocaleString(locale);
        return '<div class="track-elevation-tooltip"><div><span>' + ele + ' m </span><br><span>' + dist + measure + ' </span></div>' + (doneTime ? '<span>' + doneTime.toString + '</span><div/>' : '');
    };

    ctlProto.getTableContainer = function () {
        return this.tableDiv;
    };

    ctlProto.getInfoContainer = function () {
        return this.infoDiv;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv;
    };

    ctlProto.getContainerElement = function () {
        return this.div.querySelector('.prsidebar-body') || null;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.wrap.register(map);

        if (self.openOn) {
            self.map.one(self.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.closeOn) {
            self.map.one(self.closeOn, function (e, args) {
                self.close();
            });
        }

        if (self.options.openOn) {
            self.map.on(self.options.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.options.closeOn) {
            self.map.on(self.options.closeOn, function (e, args) {
                self.close();
            });
        }

        //map.on(TC.Consts.event.VIEWCHANGE, function () {

        //    map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctl) {
        //        return ctl.options.content !== "chart" && ($(ctl.div).find('.' + ctl.CLASS + '-info:visible').length === 1 || $(ctl.div).find('.' + ctl.CLASS + '-table:visible').length === 1);
        //    }).forEach(function (ctl) {
        //        ctl.close();
        //    });
        //});

        return result;
    };

    ctlProto.exportToExcel = function () {
        var _ctl = this;

        var rows = [_ctl.tableData.columns];

        _ctl.tableData.results.forEach(function (value) {
            var row = [];
            for (var k in value) {
                if (value.hasOwnProperty(k) && k !== "Id" && k !== "Geom") { //Las columnas ID y Geom no aparece en la exportaci\u00f3n
                    row.push(value[k]);
                }
            }
            rows.push(row);
        });
        var _fncSave = function (exporter) {
            var fileName = _ctl.save.fileName ? _ctl.save.fileName : 'resultados.xls';
            var title = (_ctl.options.titles && _ctl.options.titles.main ? _ctl.options.titles.main : null);
            exporter.Save(fileName, rows, title);
        }
        if (!TC.Util.ExcelExport) {
            TC.loadJS(true, TC.apiLocation + 'TC/Util.ExcelExport', function () {
                _fncSave(new TC.Util.ExcelExport());
            });
        }
        else {
            _fncSave(new TC.Util.ExcelExport());
        }
    };
})();
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ScaleBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.ScaleBar, TC.Control);

(function () {
    var ctlProto = TC.control.ScaleBar.prototype;

    ctlProto.CLASS = 'tc-ctl-sb';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.ScaleBar(self);
        }
        self.wrap.render();
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), map.wrap.getMap()]).then(function (objects) {
                objects[1].addControl(self.wrap.ctl);
                resolve(self);
            });
        });
    };

    ctlProto.getText = function () {
        var self = this;

        return self.wrap.getText();
    };

})();
TC.control = TC.control || {};

if (!TC.control.Scale) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Scale');
}

TC.control.ScaleSelector = function () {
    var self = this;

    TC.control.Scale.apply(self, arguments);

    self.scales = null;
};

TC.inherit(TC.control.ScaleSelector, TC.control.Scale);

(function () {
    var ctlProto = TC.control.ScaleSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-ss';

    ctlProto.template = TC.apiLocation + "TC/templates/ScaleSelector.html";

    ctlProto.render = function (callback) {
        var self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            if (self.map) {
                if (!self.scales && self.map.options.resolutions) {
                    self.scales = self.map.options.resolutions.map(self.getScale, self);
                }
                var render = function () {
                    self.scales = self.map.wrap.getResolutions().map(self.getScale, self);
                    self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize, scales: self.scales }, function () {

                        self.div.querySelectorAll('option').forEach(function (option) {
                            option.textContent = '1:' + self.format(option.textContent.substr(2));
                        });

                        self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

                        self.div.querySelector('select').addEventListener('change', function () {
                            self.setScale(this.value);
                        });
                        if (TC.Util.isFunction(callback)) {
                            callback();
                        }
                        resolve();
                    }).catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
                };
                if (self.scales) {
                    render();
                }
                else {
                    self.map.wrap.getMap().then(render);
                }
            }
            else {
                reject(Error('ScaleSelector no registrado'));
            }
        }));
    };

    /*
    *  setScale: Sets the resolution of the map from a scale denominator and estimated screen DPI
    *  Parameters: number, the scale denominator
    *  Returns: number, the resolution
    */
    ctlProto.setScale = function (scale) {
        var self = this;
        var result = scale * .0254 / self.getDpi(TC.Cfg.screenSize);
        if (window.devicePixelRatio) {
            result = result / window.devicePixelRatio;
        }
        if (self.metersPerDegree) {
            result = result / self.metersPerDegree;
        }
        self.map.wrap.setResolution(result);
        return result;
    };

})();
(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}


var SearchType = function (type, options, parent) {
    var self = this;

    self.parent = parent;

    self._featureTypes = [];

    TC.Util.extend(self, options);

    self.typeName = type;

    self._throwConfigError = function () {
        var self = this;

        throw new Error('Error en la configuración de la búsqueda: ' + self.typeName);
    };

    self.getFeatureTypes = function (toFilter) {
        var self = this;

        if (toFilter) {
            return self.featureType instanceof Array ? self.featureType : [self.featureType];
        }

        if (self._featureTypes.length === 0) {
            var type_featureType = self.featureType instanceof Array ? self.featureType : [self.featureType];
            var type_renderFeatureType = self.renderFeatureType ? self.renderFeatureType instanceof Array ? self.renderFeatureType : [self.renderFeatureType] : [];
            self._featureTypes = type_featureType.concat(type_renderFeatureType);
        }

        return self._featureTypes;
    };

    self.isFeatureOfThisType = function (id) {
        var self = this;

        return self.getFeatureTypes().indexOf(id) > -1;
    };

    self.getStyleByFeatureType = function (featureType) {
        var self = this;

        if (self.getFeatureTypes().indexOf(featureType) > -1) {
            return self.styles[self.getFeatureTypes().indexOf(featureType)];
        }

        return null;
    };

    var getColor = function (css, geomType, featureType) {
        var self = this;

        var getValue = function (style, geomType, css) {
            if (geomType) {
                if (style.hasOwnProperty(geomType) && style[geomType].hasOwnProperty(css)) {
                    return style[geomType][css];
                }
            } else {
                for (var geomType in style) {
                    if (style[geomType].hasOwnProperty(css)) {
                        return style[geomType][css];
                    }
                }
            }
        };

        if (featureType) {
            var style = self.getStyleByFeatureType(featureType);
            return getValue(style, geomType, css);
        } else {
            for (var i = 0; i < self.styles.length; i++) {
                var style = self.styles[i];
                var color = getValue(style, geomType, css);
                if (color) {
                    return color;
                }
            }
        }
    };

    self.getSuggestionListHead = function () {
        var self = this;

        var headerData, label, color;

        if (typeof self.suggestionListHead === "function") {
            headerData = self.suggestionListHead();
            label = headerData.label;
            color = [{
                color: headerData.color,
                title: headerData.label
            }];
        } else {
            headerData = self.suggestionListHead;
            label = self.parent.getLocaleString(headerData.label);

            // color es string que es el atributo CSS. El valor se obtiene de la 1º coincidencia encontrada en styles
            if (typeof headerData.color === "string") {
                color = [{
                    color: getColor.call(self, headerData.color),
                    title: label
                }];
            } else if (headerData.color instanceof Array) { // color es un array de objetos, con nombre de featureType como clave
                var featureTypes = self.getFeatureTypes();
                if (headerData.color.length === featureTypes.length) {
                    color = headerData.color.map(function (elm, i) {
                        return {
                            color: getColor.call(self, elm[featureTypes[i]].color.css, elm[featureTypes[i]].color.geomType, featureTypes[i]),
                            title: self.parent.getLocaleString(elm[featureTypes[i]].title) || label
                        }
                    });
                } else {
                    self._throwConfigError();
                }
            } else if (typeof headerData.color === "object") { // color es un objeto con atributo css y tipo de geometría
                color = [{
                    color: getColor.call(self, headerData.color.css, headerData.color.geomType),
                    title: label
                }];
            }
        }

        if (label && color) {
            var liHTML = '<li header><span class="header">' + label + '</span>';

            liHTML += color.map(function (elm) {
                if (elm.color) {
                    return '<span class="header-color" title="' + elm.title + '" style="color: ' + elm.color + ';"></span>';
                }
            }).join('') + '</li>';

            return liHTML;

        } else {
            self._throwConfigError();
        }
    };

    self.getSuggestionListElements = function (data) {
        var self = this;
        var results = [];

        var areSame = function (a, b) {
            switch (true) {
                case typeof (a) === "number":
                    if (a === b) {
                        return true;
                    }
                    break;
                case typeof (a) === "string":
                    if (!isNaN(a) || !isNaN(b)) {
                        if (a === b) {
                            return true;
                        }
                    } else {
                        if (a.trim() === b.trim()) {
                            return true;
                        }
                    }
                    break;
            }

            return false;
        };
        var getUnique = function (inputArray) {
            var outputArray = [];
            for (var i = 0; i < inputArray.length; i++) {
                if (outputArray.indexOf(inputArray[i]) === -1) {
                    outputArray.push(inputArray[i]);
                }
            }

            return outputArray;
        };
        var intoResults = function (compareData) {
            for (var r = 0; r < results.length; r++) {
                var length = 0;
                var isThere = [];
                for (var property in compareData) {
                    isThere.push(areSame(compareData[property], results[r].properties[property]));
                    length++;
                }
                if (isThere.filter(function (i) { return i; }).length === length) {
                    return true;
                }

            }

            return false;
        };

        var features = self.parseFeatures(data);

        features.forEach(function (feature) {
            var attributes = [], ids = [];
            var valueToAdd = '';

            var properties = self.outputProperties;
            var dataIdProperties = self.dataIdProperty;

            var strFormat = self.outputFormatLabel;
            var dataLayer = feature.id.split('.').slice(0, 1).shift();

            if (!(self.outputProperties instanceof Array)) {
                properties = self.outputProperties[dataLayer];
                dataIdProperties = self.dataIdProperty[dataLayer];
                strFormat = strFormat[dataLayer];
            }

            for (var j = 0; j < properties.length; j++) {
                attributes.push(feature.data[properties[j]]);
            }

            for (var j = 0; j < dataIdProperties.length; j++) {
                ids.push(feature.data[dataIdProperties[j]]);
            }

            var compareData = {};
            for (var p = 0; p < self.outputProperties.length; p++) {
                compareData[self.outputProperties[p]] = attributes[p];
            }

            if (attributes instanceof Array && strFormat && getUnique(attributes).length > 1) {
                valueToAdd = strFormat.tcFormat(attributes);
            }
            else if (attributes instanceof Array && getUnique(attributes).length == 1) {
                valueToAdd = attributes[0];
            }

            var text = valueToAdd.toCamelCase();

            if (!(intoResults(compareData))) {

                results.push({
                    text: text,
                    label: text,
                    id: ids.join('#'),
                    dataRole: self.typeName,
                    dataLayer: dataLayer,
                    properties: compareData
                });
            }
        });

        return results;
    };

    self.parseFeatures = function (data) {
        var parser;
        if (self.outputFormat === TC.Consts.format.JSON) {
            parser = new TC.wrap.parser.JSON();
        }
        else {
            parser = new TC.wrap.parser.WFS({
                featureNS: self.featurePrefix,
                featureType: self.featureType
            });
        }
        return parser.read(data);
    };

    self.getPattern = function () {
        var self = this;

        if (typeof self.pattern === "function") {
            return self.pattern();
        } else {
            return self.pattern;
        }
    };

    self.filter = (function (self) {

        const bindRootFilterNode = function (filtersArr, dataT) {
            var rootFilters = [];

            if (dataT != self.parent.rootCfg.active.root) {
                // GLS: Si llego aquí, significa que el usuario está indicando la población
                if (dataT.indexOf('#') === -1 && !self.parent.rootCfg.active.limit) { // si no está limitada la búsqueda, indico la población

                    var filterNode = self.parent.rootCfg.active.queryProperties.firstQueryWord.map(function (queryWord, index) {
                        return self.filter.getFilterNode(queryWord, self.parent._LIKE_PATTERN + dataT + self.parent._LIKE_PATTERN);
                    });

                    if (filterNode.length > 1) {
                        rootFilters.push('<ogc:And>');
                        rootFilters = rootFilters.concat(filterNode);
                        rootFilters.push('</ogc:And>');
                    } else {
                        rootFilters = rootFilters.concat(filterNode);
                    }

                } else { // por tanto no añado todas las raíces posibles, añado la población que ha indicado (validando antes contra rootLabel)                     
                    var item = dataT.split('#');

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }
            } else {
                for (var i = 0; i < self.parent.rootCfg.active.root.length; i++) {
                    var item = self.parent.rootCfg.active.root[i];

                    if (i == 0 && self.parent.rootCfg.active.root.length > 1) {
                        rootFilters.push('<ogc:Or>');
                    }

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }

                if (self.parent.rootCfg.active.root.length > 1) {
                    rootFilters.push('</ogc:Or>');
                }
            }

            return filtersArr.concat(rootFilters);
        };

        return {
            getPropertyValue: function (role, propertyName) {
                return self.getSearchTypeByRole(role)[propertyName];
            },
            getIsLikeNode: function (name, value) {
                var toEscape = /([\-\"\.\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1)
                    return '<Or><PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toLowerCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike>' +
                        '<PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toUpperCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike></Or>';
                else
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
            },
            getFunctionStrMatches: function (name, value) {
                var toEscape = /([\-\"\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1) {

                    var pattern = value;
                    pattern = pattern.replace(/a/gi, "[aáà]");
                    pattern = pattern.replace(/e/gi, "[eéè]");
                    pattern = pattern.replace(/i/gi, "[iíì]");
                    pattern = pattern.replace(/o/gi, "[oóò]");
                    pattern = pattern.replace(/u/gi, "[uúüù]");

                    return '<ogc:PropertyIsEqualTo> ' +
                        '<ogc:Function name="strMatches"> ' +
                        '<ogc:PropertyName>' + name + '</ogc:PropertyName> ' +
                        '<ogc:Literal>' + '(?i)' + pattern.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</ogc:Literal> ' +
                        '</ogc:Function> ' +
                        '<ogc:Literal>true</ogc:Literal> ' +
                        '</ogc:PropertyIsEqualTo>';
                }
                else {
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
                }
            },
            getFilterNode: function (propertyName, propertyValue) {
                var r;

                var fn = self.filter.getIsLikeNode;

                if (self.filterByMatch) {

                    fn = self.filter.getFunctionStrMatches;

                    var regex = new RegExp('\\' + self.parent._LIKE_PATTERN, 'gi');
                    propertyValue = propertyValue.replace(regex, self.parent._MATCH_PATTERN);
                }

                if (!(propertyName instanceof Array) && (typeof propertyName !== 'string')) {
                    var f = [];
                    for (var key in propertyName) {
                        if ((propertyName[key] instanceof Array) && propertyName[key].length > 1) {
                            r = '<Or>';
                            for (var i = 0; i < propertyName[key].length; i++) {
                                r += fn(propertyName[key][i].trim(), propertyValue);
                            }

                            r += '</Or>';
                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' + r + '</Filter>)');
                        } else {
                            var propName = propertyName[key];
                            if ((propertyName[key] instanceof Array) && propertyName[key].length == 1)
                                propName = propertyName[key][0];

                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' +
                                '<Or>' + fn(propName.trim(), propertyValue) + '</Or>' +
                                '</Filter>)');
                        }
                    }

                    return f.join('');

                } else if (propertyName instanceof Array && propertyName.length > 1) {
                    r = '<ogc:Or>';
                    for (var i = 0; i < propertyName.length; i++) {
                        r += fn(propertyName[i].trim(), propertyValue);
                    }

                    return r += '</ogc:Or>';
                } else
                    return fn((propertyName instanceof Array && propertyName.length === 1 ? propertyName[0].trim() : propertyName.trim()), propertyValue);
            },
            getFilter: function (data) {
                var r = {};
                r.multiL = false;
                r.f = '';

                var _f;

                switch (true) {
                    case self.typeName === TC.Consts.searchType.NUMBER:
                        _f = [];
                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)

                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        else {
                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            } else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }

                        _f.push(self.filter.getFilterNode(self.queryProperties.thirdQueryWord, data.p + self.parent._LIKE_PATTERN));

                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';

                        break;
                    case self.typeName === TC.Consts.searchType.STREET:
                        _f = [];

                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        } else {

                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            }
                            else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    case self.typeName === TC.Consts.searchType.LOCALITY:
                        r.f = self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN);
                        r.multiL = true;
                        break;                                            // GLS: consulta de 2 niveles (carretera con pk / topónimo con municipio)
                    case self.queryProperties.hasOwnProperty('secondQueryWord'):
                        var _f = [];
                        _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                        _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    default: // GLS: consulta de 1 único nivel (municipio, casco urbano, carretera)
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN) + '</ogc:Filter>';
                        break;
                }

                return r;
            },
            getParams: function (data) {
                var filters = self.filter.getFilter(data);

                var params = {
                    REQUEST: 'GetFeature',
                    SERVICE: 'WFS',
                    MAXFEATURES: 500,
                    VERSION: self.version,
                    OUTPUTFORMAT: self.outputFormat
                };

                var featureTypes = self.getFeatureTypes(true);
                if (!(featureTypes instanceof Array))
                    params.TYPENAME = self.featurePrefix ? self.featurePrefix + ':' + featureTypes.trim() : featureTypes.trim();
                else {
                    var ft = [];
                    for (var i = 0; i < featureTypes.length; i++) {
                        ft.push(self.featurePrefix ?
                            self.featurePrefix + ':' + featureTypes[i].trim() :
                            featureTypes[i].trim());
                    }

                    params.TYPENAME = ft.join(',');
                }

                var _getProperties = function (properties) {
                    if ((properties || '') !== '') {
                        if (!(properties instanceof Array)) {
                            var p = [];
                            if (properties instanceof Object) {
                                for (var key in properties) {
                                    var prop = properties[key][0];
                                    if (properties[key].length > 1)
                                        prop = properties[key].join(',');

                                    p.push(prop);
                                }
                            }
                            return p;
                        }
                        else
                            return properties.join(',');
                    }
                };
                var _properties = _getProperties(self.outputProperties);
                var _ids = _getProperties(self.dataIdProperty);

                const removeDuplicates = (toCheck) => {
                    const arr = toCheck.split(',');
                    return arr.filter((item, i) => {
                        return (arr.indexOf(item) === i);
                    }).join(',');
                };

                if (_properties instanceof Array && _ids instanceof Array) {
                    params.PROPERTYNAME = '';
                    for (var i = 0; i < _properties.length; i++) {
                        params.PROPERTYNAME += '(' + removeDuplicates(_properties[i] + ',' + _ids[i]) + ')';
                    }
                } else {
                    params.PROPERTYNAME = removeDuplicates(_properties + ',' + _ids);
                }

                params.FILTER = filters.f;

                return TC.Util.getParamString(params);
            },
            getGoToFilter: function (id) {
                var props = [];
                var _id = id.split('#');

                var source = self.dataIdProperty;
                var dataLayer = self.getFeatureTypes();

                if (source && dataLayer) {

                    if (id.indexOf('#') > -1 && dataLayer instanceof Array && dataLayer.length > 1) {
                        for (var i = 0; i < dataLayer.length; i++) {

                            for (var j = 0; j < source[dataLayer[i]].length; j++) {
                                props.push({ name: source[dataLayer[i]][j], value: _id[j] });
                            }
                        }
                    } else if (id.indexOf('#') == -1 && dataLayer instanceof Array) {
                        var src = source;

                        for (var i = 0; i < dataLayer.length; i++) {
                            if (!props.hasOwnProperty(dataLayer[i])) {

                                if (src instanceof Object && source.hasOwnProperty(dataLayer[i]))
                                    src = source[dataLayer[i]];

                                for (var j = 0; j < src.length; j++) {
                                    if (j < _id.length)
                                        props.push({ name: src[j], value: _id[j] });
                                }
                            }
                        }
                    }
                    else {
                        if (source instanceof Object && source.hasOwnProperty(dataLayer)) {
                            source = source[dataLayer];
                        }

                        for (var i = 0; i < source.length; i++) {
                            props.push({ name: source[i], value: _id[i] });
                        }
                    }
                }

                return self.filter.transformFilter(props);
            },
            transformFilter: function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }
        }
    })(self);
};

TC.control.Search = function () {
    var self = this;
    TC.Control.apply(self, arguments);

    self.exportsState = true;

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';

    self.url = '//idena.navarra.es/ogc/wfs';
    self.version = '1.1.0';
    self.featurePrefix = 'IDENA';

    if (self.options && self.options.url) {
        self.url = self.options.url;
    }

    self._LIKE_PATTERN = '*';
    self._MATCH_PATTERN = '.*';

    self.UTMX = 'X';
    self.UTMY = 'Y';
    self.LON = 'Lon';
    self.LAT = 'Lat';

    self.UTMX_LABEL = 'X: ';
    self.UTMY_LABEL = 'Y: ';
    self.LON_LABEL = 'Lon: ';
    self.LAT_LABEL = 'Lat: ';

    self.MUN = 'Mun';
    self.POL = 'Pol';
    self.PAR = 'Par';

    self.MUN_LABEL = 'Mun: ';
    self.POL_LABEL = 'Pol: ';
    self.PAR_LABEL = 'Par: ';

    self.availableSearchTypes = {};

    self.availableSearchTypes[TC.Consts.searchType.CADASTRAL] = {
        suggestionRoot: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        searchWeight: 3,
        featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
        municipality: {
            featureType: 'CATAST_Pol_Municipio',
            labelProperty: 'MUNICIPIO',
            idProperty: 'CMUNICIPIO'
        },
        queryProperties: {
            firstQueryWord: 'CMUNICIPIO',
            secondQueryWord: 'POLIGONO',
            thirdQueryWord: 'PARCELA'
        },
        suggestionListHead: {
            label: "search.list.cadastral",
            color: [
                {
                    CATAST_Pol_ParcelaUrba: {
                        title: "search.list.cadastral.urban",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaRusti: {
                        title: "search.list.cadastral.rustic",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaMixta: {
                        title: "search.list.cadastral.mixed",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                }
            ]
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#136278',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#0c8b3d',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#e5475f',
                    strokeWidth: 2,
                    strokeOpacity: 1
                },
            }
        ],
        parser: self.getCadastralRef,
        goTo: self.goToCadastralRef,
        goToIdFormat: self.MUN + '{0}' + self.POL + '{1}' + self.PAR + '{2}',
        idPropertiesIdentifier: '#'
    };

    self.availableSearchTypes[TC.Consts.searchType.COORDINATES] = {
        parser: self.getCoordinates,
        goTo: self.goToCoordinates,
        searchWeight: 4,
        label: null,
        suggestionListHead: function (text) {
            return {
                label: self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label || self.getLocaleString('search.list.coordinates')
            };
        }
    };

    self.queryProperties = {
        QUERYWORD: 'QueryWord',
        FIRST: 'first',
        SECOND: 'second',
        THIRD: 'third'
    };

    self.availableSearchTypes[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        url: '//idena.navarra.es/ogc/wfs',
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
        },
        suggestionListHead: {
            label: "search.list.municipality",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        searchWeight: 1,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fe06a5',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.MUNICIPALITY]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    //self.availableSearchTypes[TC.Consts.searchType.LOCALITY] = {
    //    root: null,
    //    limit: false,
    //    url: self.url || '//idena.navarra.es/ogc/wfs',
    //    version: self.version || '1.1.0',
    //    outputFormat: TC.Consts.format.JSON,
    //    featurePrefix: self.featurePrefix || 'IDENA',
    //    geometryName: 'the_geom',
    //    featureType: ['CATAST_Pol_Municipio', 'ESTADI_Pol_EntidadPob'],
    //    renderFeatureType: ['CATAST_Pol_Municipio'],
    //    dataIdProperty: {
    //        CATAST_Pol_Municipio: ['CMUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['CMUNICIPIO', 'CENTIDAD']
    //    },
    //    queryProperties: {
    //        firstQueryWord: {
    //            CATAST_Pol_Municipio: ['MUNINOAC', 'MUNICIPIO'],
    //            ESTADI_Pol_EntidadPob: ['ENTINOAC', 'ENTIDAD']
    //        }
    //    },
    //    suggestionListHead: {
    //        label: "search.list.locality",
    //        color: "strokeColor"
    //    },
    //    outputProperties: {
    //        CATAST_Pol_Municipio: ['MUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['MUNICIPIO', 'ENTIDAD']
    //    },
    //    outputFormatLabel: {
    //        CATAST_Pol_Municipio: '{0}',
    //        ESTADI_Pol_EntidadPob: '{1} ({0})'
    //    },
    //    searchWeight: 1,
    //    styles: [
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0,
    //                strokeColor: '#ffffff',
    //                strokeWidth: 5,
    //                strokeOpacity: 1
    //            }
    //        },
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0.1,
    //                strokeColor: '#feba1e',
    //                strokeWidth: 2,
    //                strokeOpacity: 1
    //            }
    //        }
    //    ],
    //    parser: self.getStringPattern.bind(this, [TC.Consts.searchType.LOCALITY]),
    //    goTo: self.goToStringPattern
    //};

    self.availableSearchTypes[TC.Consts.searchType.COUNCIL] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Concejo',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CCONCEJO'],
        queryProperties: {
            firstQueryWord: ['CONCEJO']
        },
        outputProperties: ['MUNICIPIO', 'CONCEJO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 4,
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.COUNCIL]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern,
        idPropertiesIdentifier: '#',
        suggestionListHead: {
            label: "search.list.council",
            color: "strokeColor"
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#49006a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.STREET] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        renderFeatureType: 'CATAST_Txt_Calle',
        featureType: 'CATAST_Lin_CalleEje',
        dataIdProperty: ['CVIA'],
        searchWeight: 5,
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
            secondQueryWord: ['VIA', 'VIANOAC']
        },
        suggestionListHead: {
            label: "search.list.street",
            color: "strokeColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1}, {0}',
        styles: [
            {
                line: {
                    strokeColor: "#CB0000",
                    strokeOpacity: 1,
                    strokeWidth: 2,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            },
            {
                point: {
                    label: "VIA",
                    angle: "CADANGLE",
                    fontColor: "#000000",
                    fontSize: 10,
                    fontWeight: "bold",
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.STREET]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.NUMBER] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Txt_Portal',
        renderFeatureType: '',
        searchWeight: 6,
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
        queryProperties: {
            firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
            secondQueryWord: ['VIA', 'VIANOAC'],
            thirdQueryWord: ['PORTAL']
        },
        suggestionListHead: {
            label: "search.list.number",
            color: "fontColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1} {2}, {0}',
        styles: [
            {
                point: {
                    radius: 0,
                    label: "PORTAL",
                    angle: "CADANGLE",
                    fontColor: "#CB0000",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.NUMBER]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.URBAN] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'ESTADI_Pol_EntidadPob',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDAD']
        },
        suggestionListHead: {
            label: "search.list.urban",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO', 'ENTIDAD'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 2,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#feba1e',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.URBAN]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAME] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 7,
        /*filterByMatch: true, // si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "TOPONIMO",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAME]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAMEMUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['MUNICIPIO', 'MUNINOAC'],
            secondQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 8,
        /*filterByMatch: true, si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "TOPONIMO",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAMEMUNICIPALITY]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.COMMONWEALTH] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['POLUCI_Pol_MancoRSUg'],
        renderFeatureType: '',
        dataIdProperty: ['CMANCOMUNI'],
        queryProperties: {
            firstQueryWord: ['MANCOMUNID']
        },
        outputProperties: ['MANCOMUNID'],
        outputFormatLabel: '{0}',
        searchWeight: 9,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fc4e2a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.ROAD] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Lin_CtraEje',
        dataIdProperty: ['DCARRETERA'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA']
        },
        suggestionListHead: {
            label: "search.list.road",
            color: "strokeColor"
        },
        outputProperties: ['DCARRETERA'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': ' + '{0}',
        searchWeight: 10,
        styles: [
            {
                polygon: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5
                },
                line: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            }
        ],
        parser: self.getRoad,
        goTo: self.goToRoad,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))$", "i")
        }
    };

    self.availableSearchTypes[TC.Consts.searchType.ROADPK] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Sym_CtraPK',
        dataIdProperty: ['DCARRETERA', 'CPK'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA'],
            secondQueryWord: ['PK']
        },
        suggestionListHead: {
            label: "search.list.pk.larger",
            color: "fontColor"
        },
        outputProperties: ['DCARRETERA', 'PK'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': {0} ' + self.getLocaleString('search.list.pk') + ': {1}',
        searchWeight: 11,
        styles: [
            {
                point: {
                    label: ["DCARRETERA", "PK"],
                    fontColor: "#00b2fc",
                    fontSize: 14,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2
                }
            }
        ],
        parser: self.getPK,
        goTo: self.goToPK,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))\\s*\\,*\\s*(?:(?:" + self.getLocaleString("search.list.pk") + "\\:?)|(?:P\\:?)|(?:K\\:?)|(?:KM\\:?)|(?:\\s+|\\,+))\\s*(\\d{1,4})$", "i")
        }
    };

    self.rootCfg = {};
    self.rootCfg[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNICIPIO']
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {

                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO'].concat(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].root.map(function (elem) {
                        return ['CMUNICIPIO'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.MUNICIPALITY].url + '?' + TC.Util.getParamString(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (response) {
                        const data = response.data;
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                }
            });
        }
    };
    self.rootCfg[TC.Consts.searchType.LOCALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['ESTADI_Pol_EntidadPob'],
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC'],
        queryProperties: {
            firstQueryWord: ['ENTINOAC']
        },
        outputProperties: ['ENTINOAC'],
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {
                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.LOCALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.LOCALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.LOCALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.LOCALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO', 'CENTIDAD'].concat(self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.LOCALITY].root.map(function (elem) {
                        return ['CMUNICIPIO', 'CENTIDAD'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.LOCALITY].url + '?' + TC.Util.getParamString(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (response) {
                        const data = response.data;
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO', 'CENTIDAD'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                }
            });
        }
    };

    self.allowedSearchTypes = [];

    if (self.options.allowedSearchTypes) {
        for (var allowed in self.options.allowedSearchTypes) {

            if (self.availableSearchTypes[allowed] && !TC.Util.isEmptyObject(self.options.allowedSearchTypes[allowed])) {

                // GLS: gestionamos el override de featureType y renderFeatureType.
                // Si por defecto cuenta con renderFeatureType y sobrescribe featureType y no renderFeatureType, 
                // elimino la propiedad renderFeatureType y elimino el último estilo definido, que se corresponde con el de renderFeatureType.
                if (self.availableSearchTypes[allowed].renderFeatureType && self.availableSearchTypes[allowed].renderFeatureType.length > 0 &&
                    self.options.allowedSearchTypes[allowed].featureType && !self.options.allowedSearchTypes[allowed].renderFeatureType) {

                    delete self.availableSearchTypes[allowed].renderFeatureType;
                    self.availableSearchTypes[allowed].styles = self.availableSearchTypes[allowed].styles.slice(0, self.availableSearchTypes[allowed].styles.length - 1);
                }

                // GLS: override de la configuración por defecto con la del config.JSON
                TC.Util.extend(self.availableSearchTypes[allowed], self.options.allowedSearchTypes[allowed]);


                // GLS: Limitamos la búsqueda en portales y calles cuando así se establezca en la configuración de las búsquedas
                if (self.options.allowedSearchTypes[allowed].root &&
                    (allowed != TC.Consts.searchType.MUNICIPALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.MUNICIPALITY) ||
                    (allowed != TC.Consts.searchType.LOCALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.LOCALITY)) {

                    self.rootCfg.active = self.rootCfg[self.options.allowedSearchTypes[allowed].rootType];
                    self.rootCfg.active.root = self.options.allowedSearchTypes[allowed].root;
                    self.rootCfg.active.limit = self.options.allowedSearchTypes[allowed].limit;

                    self.availableSearchTypes[TC.Consts.searchType.STREET].queryProperties.firstQueryWord =
                        self.availableSearchTypes[TC.Consts.searchType.NUMBER].queryProperties.firstQueryWord =
                        self.rootCfg.active.dataIdProperty;
                }
            }

            // Si esta a false lo borramos de las disponibles
            if (!self.options.allowedSearchTypes[allowed]) {
                delete self.options.allowedSearchTypes[allowed];
            } else {
                self.addAllowedSearchType(allowed, self.availableSearchTypes[allowed] ? self.availableSearchTypes[allowed] : self.options.allowedSearchTypes[allowed], self);
            }
        }
    }

    if (self.rootCfg.active) {
        self.rootCfg.active.getRootLabel();
    }

    self.queryableFeatures = self.options.queryableFeatures || false;

    self.UTMX_LEN = 6;
    self.UTMY_LEN = 7;

    self.wrap = new TC.wrap.control.Search(self);

    self.interval = 500;

    self.NORMAL_PATTERNS = {
        ROMAN_NUMBER: /M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}){1,}?\S?\./i,
        ABSOLUTE_NOT_DOT: /[`~!@#$%^&*_|+\=?;:'"\{\}\[\]\\]/gi,
        ABSOLUTE: /[`~!@#$%^&*_|+\=?;:'.\{\}\[\]\\]/gi
    };
};

TC.inherit(TC.control.Search, TC.Control);

(function () {
    var ctlProto = TC.control.Search.prototype;

    ctlProto.CLASS = 'tc-ctl-search';

    TC.Consts.event.SEARCHQUERYEMPTY = TC.Consts.event.SEARCHQUERYEMPTY || 'searchqueryempty.tc';

    ctlProto.template = TC.apiLocation + "TC/templates/Search.html";

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self._search = {
            data: []
        };

        self.layerStyleFN = (function () {
            function getFeatureType(idFeature) {
                return idFeature.indexOf('.') > -1 ? idFeature.split('.')[0] : idFeature;
            };
            function getStyle(property, geomType, id) {

                var type = self.getSearchTypeByFeature(id);
                if (type) {
                    var style = type.getStyleByFeatureType(getFeatureType(id));

                    if (style && style.hasOwnProperty(geomType)) {
                        return style[geomType][property];
                    }
                }

                return TC.Cfg.styles[geomType][property];
            };

            return function (geomType, property, extractValue, f) {
                var self = this;

                if (TC.Feature && !(f instanceof TC.Feature)) {
                    self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, geom: f.geom });
                }

                var prop = getStyle(property, geomType, getFeatureType(f.id));
                if (extractValue) {
                    if (prop instanceof Array) {
                        var values = prop.map(function (p) {
                            return f.getData().hasOwnProperty(p) ? f.getData()[p] : '';
                        });
                        var searchType = this.getSearchTypeByFeature(getFeatureType(f.id));
                        if (searchType) {
                            return searchType.outputFormatLabel.tcFormat(values);
                        } else {
                            return values.join(' ');
                        }
                    } else {
                        return f.getData().hasOwnProperty(prop) ? f.getData()[prop] : '';
                    }
                }
                else {
                    return prop;
                }
            };
        }());

        var styleFN = self.layerStyleFN;

        self.layerPromise = map.addLayer({
            id: self.getUID(),
            title: 'Búsquedas',
            owner: self,
            stealth: true,
            declutter: true,
            type: TC.Consts.layerType.VECTOR,
            styles: {
                polygon: {
                    fillColor: styleFN.bind(self, 'polygon', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'polygon', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'polygon', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'polygon', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'polygon', 'strokeWidth', false)
                },
                line: {
                    strokeColor: styleFN.bind(self, 'line', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'line', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'line', 'strokeWidth', false)
                },
                marker: {
                    anchor: TC.Defaults.styles.marker.anchor,
                    height: TC.Defaults.styles.marker.height,
                    width: TC.Defaults.styles.marker.width
                },
                point: {
                    radius: styleFN.bind(self, 'point', 'radius', false),
                    height: styleFN.bind(self, 'point', 'height', false),
                    width: styleFN.bind(self, 'point', 'width', false),
                    fillColor: styleFN.bind(self, 'point', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'point', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'point', 'strokeColor', false),
                    strokeWidth: styleFN.bind(self, 'point', 'strokeWidth', false),
                    fontSize: styleFN.bind(self, 'point', 'fontSize', false),
                    fontColor: styleFN.bind(self, 'point', 'fontColor', false),
                    labelOutlineColor: styleFN.bind(self, 'point', 'labelOutlineColor', false),
                    labelOutlineWidth: styleFN.bind(self, 'point', 'labelOutlineWidth', false),
                    label: styleFN.bind(self, 'point', 'label', true),
                    angle: styleFN.bind(self, 'point', 'angle', true)
                }
            }
        })
            .then(function (layer) {
                self.layer = layer;
                return layer;
            });

        self.EMPTY_RESULTS_LABEL = self.getLocaleString('noResults');
        self.EMPTY_RESULTS_TITLE = self.getLocaleString('checkCriterion');
        self.OUTBBX_LABEL = self.getLocaleString('outsideOfLimits');

        self.WFS_TYPE_ATTRS = ["url", "version", "geometryName", "featurePrefix", "featureType", "properties", "outputFormat"];

        return result;
    };

    const highlighting = function (elm) {
        const self = this;

        var highlighted = elm.label;
        var strReg = [];

        // eliminamos caracteres extraños del patrón ya analizado

        if (self.lastPattern.trim().length === 0 && self.textInput.value.trim().length > 0) {
            self.lastPattern = self.textInput.value.trim();
        }

        var normalizedLastPattern = self.lastPattern;
        if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(normalizedLastPattern))
            normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
        else
            normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');


        var querys = [];
        var separatorChar = ',';
        if (normalizedLastPattern.indexOf(separatorChar) == -1) {
            separatorChar = ' ';
        }

        querys = normalizedLastPattern.trim().split(separatorChar);

        // si estamos tratando con coordenadas el separador es el espacio, no la coma
        if ((elm.label.indexOf(self.LAT_LABEL) > -1 && elm.label.indexOf(self.LON_LABEL) > -1) ||
            (elm.label.indexOf(self.UTMX_LABEL) > -1 && elm.label.indexOf(self.UTMY_LABEL) > -1)) {
            querys = self.lastPattern.split(' ');

            for (var t = 0; t < querys.length; t++) {
                if (querys[t].trim().slice(-1) == ',')
                    querys[t] = querys[t].slice(0, -1);
            }
        }

        for (var q = 0; q < querys.length; q++) {
            if (querys[q].trim().length > 0) {
                strReg.push('(' + querys[q].trim().replace(/\(/gi, "").replace(/\)/gi, "") + ')');
                var match = /((\<)|(\>)|(\<\>))/gi.exec(querys[q].trim());
                if (match) {
                    var _strReg = querys[q].trim().replace(/((\<)|(\>)|(\<\>))/gi, '').split(' ');
                    for (var st = 0; st < _strReg.length; st++) {
                        if (_strReg[st].trim().length > 0)
                            strReg.push('(' + _strReg[st].trim().replace(/\(/gi, "\\(").replace(/\)/gi, "\\)") + ')');
                    }
                }
            }
        }

        if (elm.dataRole == TC.Consts.searchType.ROAD || elm.dataRole == TC.Consts.searchType.ROADPK) {
            var rPattern = self.getSearchTypeByRole(elm.dataRole).getPattern();
            var match = rPattern.exec(self.lastPattern);

            if (match) {
                strReg = [];

                if (match[2] && match[3] && match[4]) {
                    strReg.push('(' + match[2] + "-" + match[3] + "-" + match[4] + ')');
                } else if (match[2] && match[3]) {
                    strReg.push('(' + match[2] + "-" + match[3] + ')');
                } else if (match[3] && match[4]) {
                    strReg.push('(' + match[3] + "-" + match[4] + ')');
                } else if (match[2] || match[3]) {
                    strReg.push('(' + (match[2] || match[3]) + ')');
                }

                if (match[5]) {
                    strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
                }
            } else if (match && match[5]) {
                strReg = [];

                strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
            }
        }

        var pattern = '(' + strReg.join('|') + ')';

        pattern = pattern.replace(/á|à/gi, "a");
        pattern = pattern.replace(/é|è/gi, "e");
        pattern = pattern.replace(/í|ì/gi, "i");
        pattern = pattern.replace(/ó|ò/gi, "o");
        pattern = pattern.replace(/ú|ù/gi, "u");
        pattern = pattern.replace(/ü/gi, "u");

        pattern = pattern.replace(/a/gi, "[a|á|à]");
        pattern = pattern.replace(/e/gi, "[e|é|è]");
        pattern = pattern.replace(/i/gi, "[i|í|ì]");
        pattern = pattern.replace(/o/gi, "[o|ó|ò]");
        pattern = pattern.replace(/u/gi, "[u|ú|ü|ù]");
        var rex = new RegExp(pattern, "gi");

        var label = elm.label;

        if (elm.dataRole !== TC.Consts.searchType.ROAD || elm.dataRole !== TC.Consts.searchType.ROADPK) {
            highlighted = label.replace(rex,
                function () {
                    var params = Array.prototype.slice.call(arguments, 0);

                    if (params[params.length - 3]) {
                        return params[0].replace(params[params.length - 3], "<b>" + params[params.length - 3] + "</b>");
                    } else {
                        return "<b>" + params[0] + "</b>";
                    }
                });
        } else {
            highlighted = label.replace(rex, "<b>$1</b>");
        }

        return highlighted;
    };

    const selectionCallback = function (e) {
        const self = this;
        var _target = e.target;

        if (_target.tagName.toLowerCase() !== 'a') {
            let el = e.target;
            const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

            while (el) {
                if (matchesSelector.call(el, 'a')) {
                    _target = el;
                    break;
                } else {
                    el = el.parentElement;
                }
            }
        }

        if (_target.querySelector('span[hidden]')) {
            self.textInput.value = _target.querySelector('span[hidden]').textContent;
            self.lastPattern = self.textInput.value;
            self._goToResult(unescape(_target.getAttribute('href')).substring(1), _target.parentNode.getAttribute('dataRole'));
            TC.UI.autocomplete.call(self.textInput, 'clear');
        }
    };

    const sortAlphaNum = function (a, b) {
        const reA = /[^a-zA-Z]/g;
        const reN = /[^0-9]/g;

        var AInt = parseInt(a, 10);
        var BInt = parseInt(b, 10);

        if (isNaN(AInt) && isNaN(BInt)) {
            var aA = a.replace(reA, "");
            var bA = b.replace(reA, "");
            if (aA === bA) {
                var aN = parseInt(a.replace(reN, ""), 10);
                var bN = parseInt(b.replace(reN, ""), 10);
                return aN === bN ? 0 : aN > bN ? 1 : -1;
            } else {
                return aA > bA ? 1 : -1;
            }
        } else if (isNaN(AInt)) {//A is not an Int
            return 1;//to make alphanumeric sort first return -1 here
        } else if (isNaN(BInt)) {//B is not an Int
            return -1;//to make alphanumeric sort first return 1 here
        } else {
            return AInt > BInt ? 1 : -1;
        }
    };

    const sortByRoleAndAlphabet = function (a, b) {
        const self = this;

        if (self.getSearchTypeByRole(a.dataRole).searchWeight && self.getSearchTypeByRole(b.dataRole).searchWeight) {
            if ((self.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (self.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                return 1;
            } else if ((self.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (self.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                return -1;
            }
            else {
                return sortAlphaNum(a.label, b.label);
            }
        } else {
            if (a.dataRole > b.dataRole) {
                return 1;
            }
            else if (a.dataRole < b.dataRole)
                return -1;
            else {
                return sortAlphaNum(a.label, b.label);
            }
        }
    };

    const sortByRoot = function (a, b) {
        const self = this;

        const sort_ = function () {
            var first = self.rootCfg.active.root[0] instanceof Array ? self.rootCfg.active.root[0].join('-') : self.rootCfg.active.root[0];

            var aRoot, bRoot;
            if (a.properties && a.properties.length > 0 && b.properties && b.properties.length > 0) {
                aRoot = self.rootCfg.active.dataIdProperty.map(function (elem) { return a.properties[elem].toString(); }).join('-');
                bRoot = self.rootCfg.active.dataIdProperty.map(function (elem) { return b.properties[elem].toString(); }).join('-');
            } else {
                aRoot = a.id;
                bRoot = b.id;
            }

            if (aRoot !== first && bRoot === first) {
                return 1;
            } else if (aRoot === first && bRoot !== first) {
                return -1;
            } else {
                return sortAlphaNum(a.label, b.label);
            }
        }.bind(this);

        if (self.getSearchTypeByRole(a.dataRole).searchWeight && self.getSearchTypeByRole(b.dataRole).searchWeight) {
            if ((self.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (self.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                return 1;
            } else if ((self.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (self.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                return -1;
            }
            else {
                return sort_();
            }
        }
        else {
            return sort_();
        }
    };

    const buildHTML = function (results) {
        const self = this;

        var html = [];
        var dataRoles = [];

        // ordenamos por roles y alfabéticamente
        var data = results.results.sort(sortByRoleAndAlphabet.bind(self));

        if (self.rootCfg.active) {// si hay root, aplicamos el orden por entidades 
            data = data.sort(sortByRoot.bind(self));
        }

        for (var i = 0; i < data.length; i++) {
            var elm = data[i];

            if (dataRoles.indexOf(elm.dataRole) == -1) {
                html[html.length] = self.getSearchTypeByRole(elm.dataRole).getSuggestionListHead();
                dataRoles.push(elm.dataRole);
            }

            html[html.length] = '<li dataRole="' + elm.dataRole + '">' +
                '<a href="' + '#' + encodeURIComponent(elm.id) + '">' +
                '<span hidden>' +
                elm.label +
                '</span>' +
                highlighting.call(self, elm) +
                '</a>' +
                '</li>';
        }

        Array.prototype.map.call(self.resultsList.querySelectorAll('li[dataRole]'), (elm) => {
            return elm.getAttribute('dataRole');
        }).filter((dataRole, i, liDataRoles) => {
            return liDataRoles.indexOf(dataRole) === i && !dataRoles.includes(dataRole);
        }).forEach(dataRole => {
            html[html.length] = self.getSearchTypeByRole(dataRole).getSuggestionListHead();
            html[html.length] = '<li dataRole="' + dataRole + '"><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
        });
        
        return html.join('');
    };

    ctlProto.renderData = function (data, callback) {
        var self = this;

        self._search = self._search || {};

        var _search = function () {
            self.search(self.textInput.value, function (list) {
                if (list.length === 1) {
                    self.textInput.value = list[0].label;
                    self._goToResult(list[0].id, self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
                else if (list.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
            });
        };

        return TC.Control.prototype.renderData.call(self, data, function () {

            // desde keypress y desde la lupa
            var _research = function () {
                self.textInput.value = self.resultsList.label || self.resultsList.querySelector('li:not([header]) > a > span').textContent;
                self.lastPattern = self.textInput.value;
                self._goToResult(self.resultsList.id || unescape(self.resultsList.querySelector('li:not([header]) > a').getAttribute('href')).substring(1), self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            };

            self.textInput = self.div.querySelector('input.tc-ctl-search-txt');
            if (self.options && self.options.placeHolder) {
                self.textInput.setAttribute('placeHolder', self.options.placeHolder.trim());
            }

            self.resultsList = self.div.querySelector('.tc-ctl-search-list');
            self.button = self.div.querySelector('.tc-ctl-search-btn');
            self.button.addEventListener(TC.Consts.event.CLICK, function () {
                self.getLayer().then(function (l) {
                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length > 1) { }
                    else if (l.features.length > 0) {
                        l.map.zoomToFeatures(l.features);
                    }
                    else if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    }
                    else {
                        self.textInput.dispatchEvent(new Event("keyup"));
                    }
                });
            });
            if (self.options.instructions) {
                self.textInput.setAttribute('title', self.options.instructions.trim());
                self.button.setAttribute('title', self.options.instructions.trim());
            }

            // GLS: añadimos la funcionalidad al mensaje de "No hay resultados", al hacer click repliega el mensaje.
            self.resultsList.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('a.tc-ctl-search-li-empty', function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                self.textInput.focus();
            }));

            self.textInput.addEventListener('keypress', function (e) {
                if (e.which == 13) {
                    e.preventDefault();
                    e.stopPropagation();

                    self.lastPattern = "";

                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    } else {
                        _search();
                    }
                    return false;
                }
            });
            self.textInput.addEventListener("search", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("input", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("targetCleared.autocomplete", function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            })
            self.textInput.addEventListener("targetUpdated.autocomplete", function () {
                if (self.resultsList.querySelectorAll('li').length > 0) {
                    self.resultsList.classList.remove(TC.Consts.classes.HIDDEN);
                }
            });

            self.lastPattern = '';
            self.retryTimeout = null;
            TC.loadJS(
                !TC.UI || !TC.UI.autocomplete,
                [TC.apiLocation + 'TC/ui/autocomplete.js'],
                function () {
                    var searchDelay;

                    const source = function (text, callback) {
                        self.lastpress = performance.now();

                        if (!searchDelay) {
                            function step() {
                                var criteria = self.textInput.value.trim();

                                if (criteria.length > 0 &&
                                    (!self.lastPattern || criteria != self.lastPattern) &&
                                    performance.now() - self.lastpress > self.interval) {

                                    window.cancelAnimationFrame(searchDelay);
                                    searchDelay = undefined;

                                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);

                                    // Pendiente de afinar
                                    //if (self.lastPattern && criteria.substring(0, criteria.lastIndexOf(' ')) == self.lastPattern) {                                            

                                    //    // Si el patrón de búsqueda anterior y actual es el mismo más algo nuevo (típico en la búsqueda de un portal), lo nuevo lo separo por coma
                                    //    // self.lastPattern: "Calle Cataluña/Katalunia Kalea, Pamplona"
                                    //    // text: "Calle Cataluña/Katalunia Kalea, Pamplona 18"

                                    //    criteria = criteria.substring(0, criteria.lastIndexOf(' ')) + (self.lastPattern.trim().endsWith(',') ? "" : ",") + criteria.substring(criteria.lastIndexOf(' '));
                                    //}

                                    self.lastPattern = criteria;

                                    self.search(criteria, callback);
                                } else {
                                    searchDelay = requestAnimationFrame(step);
                                }
                            }

                            searchDelay = requestAnimationFrame(step);
                        }
                    };

                    TC.UI.autocomplete.call(self.textInput, {
                        link: '#',
                        target: self.resultsList,
                        minLength: 2,
                        ctx: self,
                        source: source,
                        callback: selectionCallback.bind(self),
                        buildHTML: buildHTML.bind(self)
                    });

                    const getNextSibling = function (elem, selector) {
                        // Get the next sibling element
                        var sibling = elem.nextElementSibling;
                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;
                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.nextElementSibling
                        }
                    };

                    const getPreviousSibling = function (elem, selector) {
                        // Get the next sibling element
                        var sibling = elem.previousElementSibling;
                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;
                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.previousElementSibling;
                        }
                    };

                    // Detect up/down arrow
                    const onKeydown = function (e) {
                        if (!e.ctrlKey && !e.altKey && !e.shiftKey) {
                            if (e.keyCode === 40) { // down arrow
                                if (self.textInput == document.activeElement && self.resultsList.querySelector('li:not([header]) a')) {
                                    // Scenario 1: We're focused on the search input; move down to the first li
                                    self.resultsList.querySelector('li:not([header]) a').focus();
                                } else if (self.resultsList.querySelector('li:not([header]):last-child a') === document.activeElement) { //} else if (self.resultsList.querySelector('li:not([header]):last a').is(':focus')) {
                                    // Scenario 2: We're focused on the last li; move up to search input
                                    self.textInput.focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the last element, simply move down
                                    getNextSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            } else if (e.keyCode === 38) { // up arrow
                                if (self.textInput == document.activeElement) {
                                    // Scenario 1: We're focused on the search input; move down to the last li
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else if (document.activeElement == self.resultsList.querySelector('li:not([header]) a')) {
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the first element, simply move up
                                    getPreviousSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            }
                        }
                        e.stopPropagation();
                    };

                    self.textInput.addEventListener('keydown', onKeydown);
                    self.resultsList.addEventListener('keydown', onKeydown);
                }
            );

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.addAllowedSearchType = function (name, options) {
        var self = this;

        self.allowedSearchTypes.push(new SearchType(name, options, self));
    };

    ctlProto.getSearchTypeByRole = function (type) {
        var self = this;

        return self.allowedSearchTypes.filter(function (allowed) {
            return allowed.typeName == type;
        })[0];
    };

    ctlProto.getSearchTypeByFeature = function (id) {
        var self = this;

        var type = self.allowedSearchTypes.filter(function (allowed) {
            return allowed.isFeatureOfThisType(id);
        });

        if (type.length > 0) {
            return type[0];
        }

        return null;
    };

    ctlProto.getElementOnSuggestionList = function (id, dataRole) {
        const self = this;

        for (var i = 0; i < self.searchRequestsResults.length; i++) {
            if (self.searchRequestsResults[i].id == id && (!dataRole || (dataRole && self.searchRequestsResults[i].dataRole === dataRole)))
                return self.searchRequestsResults[i];
        }
    };

    ctlProto.getLayer = function () {
        const self = this;
        return self.layerPromise;
    };

    ctlProto.getFeatures = function () {
        const self = this;
        return self.layer.features;
    };

    ctlProto.cleanMap = function () {
        const self = this;

        if (self.layer) {
            const l = self.layer;
            var features = l.features.slice();
            l.clearFeatures();

            self.map.trigger(TC.Consts.event.FEATUREREMOVE, { layer: l, feature: features });

            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                if (l.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                    delete l[self.WFS_TYPE_ATTRS[i]];
            }
        }
    };

    ctlProto.getMunicipalities = function () {
        var self = this;

        TC.cache.search = TC.cache.search || {};
        self._municipalitiesPromise = new Promise(function (resolve, reject) {
            if (TC.cache.search.municipalities) {
                resolve(TC.cache.search.municipalities);
            }
            else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

                if (type.municipality && type.municipality.featureType && type.municipality.labelProperty && type.municipality.idProperty) {
                    var params = {
                        REQUEST: 'GetFeature',
                        SERVICE: 'WFS',
                        TYPENAME: type.municipality.featureType,
                        VERSION: type.version,
                        PROPERTYNAME: type.municipality.labelProperty + "," + type.municipality.idProperty,
                        OUTPUTFORMAT: type.outputFormat
                    };
                    if (type.featurePrefix) {
                        params.TYPENAME = type.featurePrefix + ':' + params.TYPENAME;
                    }
                    var url = type.url + '?' + TC.Util.getParamString(params);
                    TC.ajax({
                        url: url,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (response) {
                        const data = response.data;
                        var parser;
                        if (type.outputFormat === TC.Consts.format.JSON) {
                            parser = new TC.wrap.parser.JSON();
                        }
                        else {
                            parser = new TC.wrap.parser.WFS({
                                featureNS: type.municipality.featurePrefix,
                                featureType: type.municipality.featureType
                            });
                        }
                        var features = parser.read(data);
                        TC.cache.search.municipalities = [];
                        for (var i = 0; i < features.length; i++) {
                            var feature = features[i];
                            TC.cache.search.municipalities.push({ label: feature.data[type.municipality.labelProperty], id: feature.data[type.municipality.idProperty] });
                        }

                        TC.cache.search.municipalities.sort(function (a, b) {
                            var result;
                            if (a.label < b.label) {
                                result = -1;
                            }
                            else if (a.label > b.label) {
                                result = 1;
                            }
                            else {
                                result = 0;
                            }
                            return result;
                        });

                        resolve(TC.cache.search.municipalities);
                    }).catch(function () {
                        resolve();
                    });
                } else {
                    throw new Error("Error en la configuración de la búsqueda: " + type.typeName + ". Error en el objeto municipality");
                }
            }
        });
        return self._municipalitiesPromise;
    };

    ctlProto.getCoordinates = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp('^' + self.UTMX_LABEL.trim().toLowerCase() + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + self.UTMY_LABEL.trim().toLowerCase() + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[2];
            }

            match = pattern.match(new RegExp('^' + self.LAT_LABEL.trim().toLowerCase() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LON_LABEL.trim().toLowerCase() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[3];
            }

            if (/\d/.test(pattern) && (new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').test(pattern) || /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.test(pattern))) {
                match = /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.exec(pattern);
                if (match && (match[1].indexOf(',') > -1 || match[3].indexOf(',') > -1)) {
                    match[1] = match[1].replace(',', '.');
                    match[3] = match[3].replace(',', '.');

                    pattern = match[1] + ' ' + match[3];
                }

                if (!match || match && ((match[1].indexOf(',') > -1 ? match[1].replace(',', '.') : match[1]) <= 180) && ((match[3].indexOf(',') > -1 ? match[3].replace(',', '.') : match[3]) <= 90)) {

                    match = new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').exec(pattern);
                    if (match && (match[1].indexOf(',') > -1 || match[2].indexOf(',') > -1)) {
                        match[1] = match[1].replace(',', '.');
                        match[2] = match[2].replace(',', '.');

                        pattern = match[1] + ' ' + match[2];
                    }

                    // parse coordinates
                    pattern = pattern.replace(self.UTMX_LABEL, '').replace(self.UTMY_LABEL, '').replace(self.LON_LABEL, '').replace(self.LAT_LABEL, '');
                    var coords = TC.Util.parseCoords(pattern);
                    if (coords) {
                        var xValue = coords[0].value;
                        var yValue = coords[1].value;
                        var xLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                        var yLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                        var id = xLabel + xValue + yLabel + yValue;

                        var point = self.getPoint(id);
                        if (point && !self.insideLimit(point)) {
                            xValue = coords[1].value;
                            yValue = coords[0].value;
                            xLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                            yLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                            id = xLabel + xValue + yLabel + yValue;
                            point = self.getPoint(id);
                        }

                        if (point) {
                            self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.test(id) ? self.getLocaleString('search.list.coordinates.utm') + self.map.crs : self.getLocaleString('search.list.coordinates.geo');

                            //console.log('getCoordinates promise resuelta');
                            resolve([{
                                id: id, label: self.getLabel(id), dataRole: TC.Consts.searchType.COORDINATES
                            }]);
                        }
                        else {
                            //console.log('getCoordinates promise resuelta');
                            reject();
                        }
                    } else {
                        //console.log('getCoordinates promise resuelta');
                        reject();
                    }
                } else {
                    //console.log('getCoordinates promise resuelta');
                    reject();
                }
            } else {
                //console.log('getCoordinates promise resuelta');
                reject();
            }
        });
    };

    ctlProto.getCadastralRef = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp(self.MUN_LABEL.trim().toLowerCase() + '?\\s(.*)\\,\\s?' + self.POL_LABEL.trim().toLowerCase() + '?\\s(\\d{1,2})\\,\\s?' + self.PAR_LABEL.trim().toLowerCase() + '?\\s(\\d{1,4})'));
            if (match) {
                pattern = match[1] + ', ' + match[2] + ', ' + match[3];
            }

            var _pattern = pattern;
            if (!(/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(pattern)) && self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot)
                _pattern = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot + ', ' + pattern;

            if (/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(_pattern) && !(new RegExp('^([0-9]{' + self.UTMX_LEN + '})\\s*\\,\\s*([0-9]{' + self.UTMY_LEN + '})$').test(pattern))) {
                self.getMunicipalities().then(function (list) {
                    var match = /^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.exec(_pattern);
                    if (match) {
                        var matcher = new RegExp(match[1].trim().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
                        var results = [];

                        const getItem = function (mun, munLabel, pol, par) {
                            var properties = [];

                            properties.push[self.MUN] = mun;
                            properties.push[self.POL] = pol;
                            properties.push[self.PAR] = par;

                            return {
                                id: self.MUN + mun + self.POL + pol + self.PAR + par,
                                label: self.getLabel(self.MUN + munLabel + self.POL + pol + self.PAR + par),
                                dataRole: TC.Consts.searchType.CADASTRAL,
                                properties: properties
                            };
                        };

                        results = list.filter(function (value) {
                            value = value.label || value.id || value;
                            return matcher.test(value) || matcher.test(self.removePunctuation(value));
                        });

                        if (results.length > 0) {
                            for (var i = 0; i < results.length; i++) {
                                results[i] = getItem(results[i].id, results[i].label, match[2].trim(), match[3].trim());
                            }
                        }

                        if (/^[0-9]*$/g.test(match[1])) {

                            if (match[1].trim() === self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot) {

                                var suggestionRoot = list.filter(function (elm) {
                                    return parseInt(elm.id) === parseInt(self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot);
                                })[0];

                                if (suggestionRoot) {
                                    resolve([getItem(suggestionRoot.id, suggestionRoot.label, match[2].trim(), match[3].trim())]);
                                }
                            }

                            results.push(getItem(match[1].trim(), match[1].trim(), match[2].trim(), match[3].trim()));
                        }

                        //console.log('getCadastralRef promise resuelta');
                        resolve(results);
                    }
                });
            } else {
                //console.log('getCadastralRef promise resuelta - no es ref catastral');
                reject();
            }
        });
    };

    ctlProto.stringPatternsValidators = {
        tsp: function (text, result, root, limit) {
            // town, street, portal - street, town, portal
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) {

                var getPortal = function () {
                    return formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[2].trim(), s: match[1].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[1].trim())) result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[1].trim(), t: match[2].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        spt: function (text, result, root, limit) {
            // street, portal, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);
            if (match && match[6] && match[1]) {

                var getPortal = function () {
                    return formatStreetNumber((match[2] || match[3] || match[4] || match[5]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[6].trim()) && /^([^0-9]+)$/i.test(match[1].trim())) {
                    result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[1].trim(), s: match[6].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[6].trim())) result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[6].trim(), t: match[1].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        tnsp: function (text, result, root, limit) {
            // town, numbers street, portal
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);

            if (match && match[1] && match[2]) {
                result.push({
                    t: match[2].trim(), s: match[1].trim(), p: formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim())
                });
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        ts: function (text, result, root, limit) {
            // town, street
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(text);

            // topónimo, municipio
            if (!match && /^[^0-9]*$/i.test(text.trim())) { // si no hay números reviso dándole la vuelta, si hay números que lo trate la función st
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match && match[1] && match[2]) {
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim()
                    });
                    result.push({
                        s: match[1].trim(), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit);
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles

                    var getStreet = function (s) {
                        var revS = s.split(' ').reverse();
                        // validamos si el criterio es compuesto 
                        var fs = [];
                        for (var si = 0; si < revS.length; si++) {
                            if (revS[si].length == 1) {
                                fs.push(revS[si]);
                                revS[si] = '';
                            }
                        }

                        return fs.length > 0 ? revS.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : revS.reverse().join(' ').trim();
                    };

                    if (/^([^0-9]+)$/i.test(match[1].trim()))
                        result.push({
                            t: match[1].trim(), s: getStreet(match[2].trim())
                        });
                    else result.push({
                        s: getStreet(match[1].trim()), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit, true);
                }

                return true;
            }

            return false;
        },
        st: function (text, result, root, limit) {
            // street, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);

            if (!match) {
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match) { // puede generar falsos positivos cuando el portal llega seguido de la calle -> calle mayor 14, pamplona
                var data = {
                };
                var criteria = text.split(',').reverse();
                for (var i = 0; i < criteria.length; i++) {
                    if (/^([^0-9\,]+)$/i.test(criteria[i].trim())) { // si no hay números se trata de municipio
                        data.t = criteria[i].trim();
                    }
                    else if (/(\s*\d+)/i.test(criteria[i].trim())) { // si contiene número, puede ser calle o calle + portal
                        if (criteria[i].trim().indexOf(' ') == -1) { // si no contiene espacios se trata de calle compuesta por números
                            data.s = criteria[i].trim();
                        } else { // si contiene espacio puede contener calle + portal
                            var _criteria = criteria[i].trim().split(' ').reverse();

                            var isPortal = function (c) {
                                var m = /^(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(c.trim());
                                if (m) {
                                    data.p = formatStreetNumber(c.trim());
                                    return true;
                                }
                                return false;
                            };

                            var x = 0;
                            var p = _criteria[x].trim();
                            while (x < _criteria.length && !isPortal(p)) {
                                x++;
                                if (x < _criteria.length)
                                    p = p + _criteria[x];

                            }

                            if (data.p) {
                                var _cr = _criteria;
                                for (var h = 0; h < _cr.length; h++) {
                                    // validamos que lo que hemos deducido como portal, está en portal para no añadirlo a calle
                                    var inPortal = false;
                                    for (var c = 0; c < _cr[h].split('').length; c++) {
                                        if (data.p.indexOf(_cr[h][c]) > -1)
                                            inPortal = true;
                                    }

                                    if (inPortal) {
                                        var _p = _cr[h];

                                        _cr[h] = '';
                                        if (data.p == formatStreetNumber(p))
                                            break;
                                    }
                                }

                                if (/^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+)$/i.test(_criteria.reverse().join(' ').trim())) {
                                    var fs = [];
                                    var criteriaRev = _criteria.reverse();
                                    for (var chs = 0; chs < criteriaRev.length; chs++) {
                                        if (criteriaRev[chs].trim().length == 1) {
                                            fs.push(criteriaRev[chs].trim());
                                            criteriaRev[chs] = '';
                                        }
                                    }

                                    data.s = fs.length > 0 ? criteriaRev.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : criteriaRev.reverse().join(' ').trim();
                                }


                                // nombre_de_calle = 137, 1, 20...
                                // duplico la búsqueda para el caso de [Calle nombre_de_calle], municipio
                                result.push({
                                    t: data.t,
                                    s: data.s + ' ' + data.p
                                });
                            } else {
                                data.s = criteria[i].trim();
                            }
                        }
                    }
                }

                result.push(data);
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        s_or_t: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9\<\>]+)$/i.exec(text);
            if (match && match[1]) {
                if (root) {
                    result.push({
                        t: match[1].trim()
                    });

                    result.push({
                        t: root,
                        s: match[1].trim()
                    });
                }
                else result.push({
                    t: match[1].trim()
                });
                return true;
            }

            return false;
        },
        sp: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/]+)\s*\,?\s*((\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) { // && text.indexOf(',') > -1 && text.split(',').length < 3) {
                if (root)
                    result.push({
                        t: root,
                        s: match[1].trim(),
                        p: formatStreetNumber(match[2].trim())
                    });
                else
                    result.push({
                        t: match[1].trim(),
                        s: match[2].trim()
                    });

                return true;
            }

            return false;
        },
        snp: function (text, result, root, limit) { // calle puede contener números con portal (cuando exista un municipio root establecido)
            var match = /^([^\,][0-9\s*\-\.\(\)\/]+)\s*\,?\s*(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(text);
            if (match && match[1] && match[2] && root) {
                result.push({
                    t: root,
                    s: match[1].trim(),
                    p: formatStreetNumber(match[2].trim())
                });
                return true;
            }

            return false;
        }
    };

    /* métodos auxiliares de getStringPattern */

    const normalizedCriteria = function (value) {
        const self = this;

        var _value = '';

        value = self.removePunctuation(value);

        // elimino los caracteres especiales
        if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(value))
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
        else
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');
        return value.toLowerCase();
    };

    const formatStreetNumber = function (value) {
        var result = value;

        var is_nc_c = function (value) {
            return /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.test(value);
        }
        var nc_c = function (value) {
            var f = [];
            var m = /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_cn = function (value) {
            return /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.test(value);
        };
        var cn = function (value) {
            var f = [];
            var m = /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_sn = function (value) {
            return /^(sn|S\/N|s\/n|s\-n)$/i.test(value);
        };
        var sn = function (value) {
            var m = /^(sn|S\/N|s\/n|s\-n)$/i.exec(value);
            if (m) {
                return 's*n';
            }
            return value;
        };


        var is_cmc = function (value) {
            return /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.test(value);
        };
        var cmc = function (value) {
            var m = /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(value);
            if (m) {
                return value;
            }
            return value;
        };

        var isCheck = [is_nc_c, is_cn, is_sn, is_cmc];
        var check = [nc_c, cn, sn, cmc];
        var ch = 0;
        while (ch < check.length && !isCheck[ch].call(self, value)) {
            ch++;
        }

        if (ch < check.length)
            return check[ch].call(self, value);
        else return value;
    };

    const bindRoot = function (result, root, limit, addRoot) {
        const self = this;

        if (root) {
            var i = result.length;
            while (i--) {
                if (!addRoot) {
                    if (result[i].t) {
                        var indicatedRoot = self.rootCfg.active.rootLabel.filter(function (elem) {
                            return elem.label.indexOf(self.removePunctuation(result[i].t).toLowerCase()) > -1;
                        }.bind(self));

                        if (indicatedRoot.length == 1) {
                            result[i].t = indicatedRoot[0].id;
                        } else if (indicatedRoot.length > 1) {

                            indicatedRoot.map(function (elem) {
                                var newResult = TC.Util.extend({
                                }, result[i]);
                                newResult.t = elem.id;

                                result.push(newResult);
                            });

                        } else if (indicatedRoot.length == 0 && limit) {
                            result.splice(i, 1);
                        }
                    }
                }
                else {
                    result.push(TC.Util.extend({}, result[i], { t: root }));
                };
            }
        }
    };

    const getObjectsFromStringToQuery = function (allowedRoles, text) {
        const self = this;
        const root = self.rootCfg.active && self.rootCfg.active.root || '';
        const limit = self.rootCfg.active && self.rootCfg.active.limit || false;

        var result = [];

        const test = function () {
            var tests = [function (text) {
                return text.length >= 3;
            },
            function (text) {
                return /^\d+$/.test(text) ? false : (/^\d+\,\s*\d+$/.test(text) ? false : true);
            }];

            for (var i = 0; i < tests.length; i++) {
                if (!tests[i].call(self, text))
                    return false;
            }

            return true;
        };

        // eliminamos espacios en blanco
        text = text.trim();

        // comprobamos si acaba con coma, si es así, la eliminamos
        if (text.charAt(text.length - 1) == ',') {
            text = text.substring(0, text.length - 1);
        }

        if (test(text)) {
            var check = [];

            check = allowedRoles.map(function (dataRole) {
                return self.getSearchTypeByRole(dataRole);
            }).filter(function (searchType) {
                return searchType.stringPatternToCheck;
            }).map(function (searchType) {
                return searchType.stringPatternToCheck;
            });

            if (check.length === 0) {
                check = [self.stringPatternsValidators.tsp, self.stringPatternsValidators.spt, self.stringPatternsValidators.tnsp, self.stringPatternsValidators.ts, self.stringPatternsValidators.st];
                if (root && text.split(',').length < 3) {
                    check = [self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t].concat(check);
                }
                else {
                    check = check.concat([self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t]);
                }
            }

            var ch = 0;
            try {
                while (ch < check.length && !check[ch].call(self, text, result, root, limit)) {
                    ch++;
                }
            }
            catch (ex) {
                TC.error("Error según el patrón: " + text, TC.Consts.msgErrorMode.EMAIL, "Error en la búsqueda del callejero");
            }

            return result;
        }

        return null;
    };

    const requestToWFS = function (type, signal, doneCallback, data) {
        const self = this;

        return fetch(type.url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            },
            body: type.filter.getParams(data),
            signal: signal
        })
            .then(function (response) {
                if (response.ok) {
                    return response.text();
                } else {
                    throw "Search: error requestToWFS";
                }
            })
            .then(doneCallback)
            .catch(function (err) {
                if (err.name === 'AbortError') {
                    console.log('Search: petición abortada');
                } else {
                    TC.error(err);
                }

                throw err;

                //console.log('getStringPattern promise resuelta - data.statusText: ' + data.statusText);
            });
    };

    ctlProto.getStringPattern = function (allowedRoles, pattern) {
        const self = this;

        return new Promise((resolve, reject) => {
            let toQuery = [];
            let requestsQuery = [];

            pattern = normalizedCriteria.call(self, pattern);

            console.log('getStringPattern sartzen da: ' + pattern);

            /* gestionamos:
                Entidad de población: Irisarri Auzoa (Igantzi)
                Topónimo: Aldabeko Bidea (Arbizu)
            */
            let combinedCriteria = /(.*)\((.*)\)/.exec(pattern);
            if (combinedCriteria && combinedCriteria.length > 2) {
                // búsqueda de entidad de población
                toQuery = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1]) || [];
                // búsqueda de topónimo
                let toQueryCombined = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1] + ',' + combinedCriteria[2]) || [];

                toQuery = toQuery.concat(toQueryCombined);
            } else {
                toQuery = getObjectsFromStringToQuery.call(self, allowedRoles, pattern) || [];
            }

            if (toQuery.length > 0) {
                let pendingSuggestionLstHead = [];
                let filterRoles = (dataToQuery) => {
                    return allowedRoles.filter(function (elm) {
                        return Object.keys(self.getSearchTypeByRole(elm).queryProperties).length === Object.keys(dataToQuery).length;
                    });
                };
                let pendingHeaderRoles = [];

                for (var i = 0; i < toQuery.length; i++) {
                    let dataToQuery = toQuery[i];
                    let roles = filterRoles(dataToQuery);

                    for (var r = 0; r < roles.length; r++) {
                        let type = self.getSearchTypeByRole(roles[r]);

                        if (pendingHeaderRoles.indexOf(type.typeName) < 0) {
                            pendingSuggestionLstHead.push(type.getSuggestionListHead());
                            pendingSuggestionLstHead.push('<li dataRole="' + type.typeName + '"><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>');

                            pendingHeaderRoles.push(type.typeName);
                        }

                        let responseToSuggestionLstElmt = (response) => {
                            return type.getSuggestionListElements(response);
                        };

                        requestsQuery.push(requestToWFS.call(self, type, self.searchRequestsAbortController.signal, responseToSuggestionLstElmt, dataToQuery));
                    }
                }

                if (requestsQuery.length > 0) {
                    self.resultsList.innerHTML += pendingSuggestionLstHead.join('');
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                    Promise.all(requestsQuery)
                        .then((results) => {
                            console.log('denei espiatzen duben promesan sartzen da');
                            //console.log('getStringPattern promise resuelta');                                  
                            resolve([].concat.apply([], results));
                        }).catch((error) => {
                            console.log('denei espiatzen duben promesan catchien sartzen da');
                            reject();
                        });
                } else {
                    reject();
                }
            } else {
                reject();
            }
        });
    };

    ctlProto.getRoad = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 2) {
                resolve([]);
            } else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

                var roadPattern = type.getPattern();
                var match = roadPattern.exec(pattern);
                if (match && match[3]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = type.getSuggestionListHead() +
                        '<li dataRole="' + type.typeName + '"><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                    console.log('getRoad new');
                    fetch(type.url + '?' + type.filter.getParams({ t: _pattern }), {
                        signal: self.searchRequestsAbortController.signal
                    }).then((response) => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw "Search: error getRoad";
                        }
                    }).then((response) => {
                        let result = [];

                        if (response.totalFeatures > 0) {
                            response.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.text == feature.properties[properties[0]]);
                                })) {
                                    var label = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));

                                    var text = type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }).join('-');

                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: label,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });

                            //console.log('getRoad promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoad promise resuelta');
                            reject();
                        }
                    }).catch(function (data) {
                        //console.log('getRoad promise resuelta - xhr fail');
                        reject();
                    });
                } else {
                    //console.log('getRoad promise resuelta - no encaja en road');
                    reject();
                }
            }
        });
    };

    ctlProto.getPK = function (pattern) {
        var self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 3) {
                resolve([]);
            } else {

                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

                var roadPKPattern = type.getPattern();
                var match = roadPKPattern.exec(pattern);
                if (match && match[3] && match[5]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = type.getSuggestionListHead() +
                        '<li dataRole="' + type.typeName + '"><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                    console.log('getRoadPK new');

                    fetch(type.url + '?' + type.filter.getParams({ t: _pattern, s: match[5].trim() }), {
                        signal: self.searchRequestsAbortController.signal
                    }).then((response) => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw "Search: error getRoadPK";
                        }
                    }).then(function (response) {
                        let result = [];
                        if (response.totalFeatures > 0) {
                            response.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.label == feature.properties[properties[0]]);
                                })) {
                                    var text = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));
                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: text,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });
                            //console.log('getRoadPK promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoadPK promise resuelta');
                            reject();
                        }
                    }).catch(function (data) {
                        //console.log('getRoadPK promise resuelta - xhr fail');
                        reject();
                    });
                } else {
                    //console.log('getRoadPK promise resuelta - no encaja en pk');
                    reject();
                }
            }
        });
    };

    ctlProto.search = function (pattern, callback) {
        var self = this;

        pattern = pattern.trim();
        if (pattern.length > 0) {
            pattern = pattern.toLowerCase();

            console.log('hasten ga: ' + pattern);

            if (self.searchRequestsAbortController) {
                self.searchRequestsAbortController.abort();
            }

            self.resultsList.innerHTML = '';
            self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

            self.searchRequestsResults = [];

            let isAborted = false;
            let onAbort = () => {
                console.log('bertan behera uzten du: ' + pattern);
                
                isAborted = true;
                self.searchRequestsAbortController.signal.removeEventListener('abort', onAbort);
            }

            self.searchRequestsAbortController = new AbortController();
            self.searchRequestsAbortController.signal.addEventListener('abort', onAbort);

            let toRender = 0;
            let renderingEnd = () => {
                toRender--;
                if (toRender === 0) {
                    // si al término de las peticiones ya estamos con otro patrón no hacemos nada
                    if (pattern !== self.textInput.value.trim().toLowerCase()) {
                        return;
                    }
                    else {                        
                        if (self.searchRequestsResults.length === 0) {
                            self.cleanMap();

                            if (!self.layer ||
                                (self.layer && self.layer.features.length === 0)) {

                                self.resultsList.innerHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';
                                self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                            }
                        }

                        self.lastPattern = "";
                    }
                }
            };

            let renderResultsOnSuggestionList = () => {
                if (self.searchRequestsResults) {
                    self.searchRequestsResults = self.searchRequestsResults.sort(function (a, b) {
                        var pattern = /(\d+)/;
                        var _a, _b = '';
                        if (pattern.test(a.label) && pattern.test(b.label)) {
                            _a = a.label.match(pattern)[1];
                            _b = b.label.match(pattern)[1];
                        } else {
                            _a = a.label;
                            _b = b.label;
                        }

                        if (_a > _b)
                            return 1;
                        else
                            if (_a < _b)
                                return -1;
                            else
                                return 0;
                    });

                    // compatibilidad hacia atrás
                    self._search.data = self.searchRequestsResults;

                    if (callback) {
                        callback(self.searchRequestsResults);
                    }
                }
            };

            self.allowedSearchTypes.forEach(function (allowed) {
                if (allowed.parser) {
                    toRender++;

                    console.log('registramos promesa: ' + allowed.typeName);

                    allowed.parser.call(self, pattern)
                        .then(function (dataRole, result) {

                            let manageLoadingByDataRole = () => {
                                let loadingElemOfDataRole = self.resultsList.querySelector('li[dataRole="' + dataRole + '"]');
                                if (loadingElemOfDataRole) {
                                    let indexLoadingElemOfDataRole = Array.prototype.indexOf.call(loadingElemOfDataRole.parentElement.childNodes, loadingElemOfDataRole);
                                    let headerElemOfDataRole = self.resultsList.childNodes[indexLoadingElemOfDataRole - 1];

                                    self.resultsList.removeChild(headerElemOfDataRole);
                                    self.resultsList.removeChild(loadingElemOfDataRole);
                                }
                            };

                            console.log('resulta promesa: ' + dataRole);

                            if (result && result.length > 0) {

                                // caso topónimo con y sin municipio Irisarri Auzoa (Igantzi)
                                let toConcat = result.filter((elm, i) => self.searchRequestsResults.findIndex((srrElm) => srrElm.id === elm.id) === -1);
                                if (toConcat.length === result.length) {
                                    self.searchRequestsResults = self.searchRequestsResults.concat(toConcat);

                                    renderResultsOnSuggestionList();
                                } else if (result.length === 1) {
                                    manageLoadingByDataRole();
                                }                                
                            } else {
                                manageLoadingByDataRole();
                            }

                            renderingEnd();

                            //resolve(result);
                        }.bind(self, allowed.typeName)).catch(function (dataRole) {
                            //reject();
                            console.log('reject promesa: ' + dataRole);
                            renderingEnd();
                        }.bind(self, allowed.typeName));
                } else {
                    console.log('Falta implementación del método parser');
                }
            });
        }
        else {
            self.lastPattern = "";

            self.cleanMap();
        }
    };

    var setQueryableFeatures = function (features) {
        var self = this;

        if (features && features.length > 0) {
            for (var i = 0; i < features.length; i++) {
                if (features[i].showsPopup != self.queryableFeatures)
                    features[i].showsPopup = self.queryableFeatures;
            }
        }
    };
    ctlProto._goToResult = function (id, dataRole) {
        var self = this;
        var goTo = null;

        //02/03/2020 cuando selecciona un elemento abortamos peticiones pendientes
        if (self.searchRequestsAbortController) {
            self.searchRequestsAbortController.abort();
        }

        return new Promise(function (resolve, reject) {
            if (!self.loading)
                self.loading = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];

            var wait;
            wait = self.loading.addWait();

            // en pantallas pequeñas, colapsamos el panel de herramientas
            if (matchMedia('(max-width: 30em)').matches) {
                self.textInput.blur();
                self.map.trigger(TC.Consts.event.TOOLSCLOSE);
            }

            self.cleanMap();

            var customSearchType = false;
            var keepOnLooping = true;

            self.allowedSearchTypes.forEach(function (allowed) {
                if (keepOnLooping) {

                    if (!self.availableSearchTypes[allowed.typeName]) {

                        if (allowed.goTo) {
                            customSearchType = true;

                            goTo = allowed.goTo.call(self, id);
                            if (goTo !== null) {
                                keepOnLooping = false;
                            }
                        } else console.log('Falta implementación del método goTo');

                    } else {

                        var dr = dataRole || self.getElementOnSuggestionList.call(self, id).dataRole;
                        if (dr) {

                            var searchType = self.getSearchTypeByRole(dr);

                            if (self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else if (!self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                customSearchType = true;

                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else console.log('Falta implementación del método goTo');
                        }
                    }
                }
            });

            self.loading.removeWait(wait);

            if (goTo) {

                self.getLayer().then(function (layer) {
                    switch (true) {
                        case goTo.params.type == TC.Consts.layerType.VECTOR:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                if (layer.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                                    delete layer[self.WFS_TYPE_ATTRS[i]];
                            }
                            break;
                        case goTo.params.type == TC.Consts.layerType.WFS:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                layer[self.WFS_TYPE_ATTRS[i]] = goTo.params[self.WFS_TYPE_ATTRS[i]];
                            }

                            wait = self.loading.addWait();
                            break;
                        default:
                    }

                    layer.type = goTo.params.type;

                    self.map.on(TC.Consts.event.FEATURESADD, function (e) {
                        if (e.layer === self.layer) {
                            setQueryableFeatures.call(self, e.features);
                        }
                    });


                    const layerEventHandler = function (e) {
                        if (e.layer == layer) {
                            // Salta cuando se pinta una feature que no es de tipo API porque la gestión de estilos salta antes (no es controlable)
                            self.map.one(TC.Consts.event.FEATURESADD, function (e) {
                                if (e.layer == layer) {
                                    if (!e.layer.features || e.layer.features.length == 0 && e.layer.wrap.layer.getSource().getFeatures()) {
                                        self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                        var bounds = e.layer.wrap.layer.getSource().getExtent();
                                        var radius = e.layer.map.options.pointBoundsRadius;

                                        if (bounds[2] - bounds[0] === 0) {
                                            bounds[0] = bounds[0] - radius;
                                            bounds[2] = bounds[2] + radius;
                                        }
                                        if (bounds[3] - bounds[1] === 0) {
                                            bounds[1] = bounds[1] - radius;
                                            bounds[3] = bounds[3] + radius;
                                        }
                                        e.layer.map.setExtent(bounds);

                                        // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
                                        self.map.trigger(TC.Consts.event.ZOOMTO, {
                                            extent: bounds, layer: e.layer
                                        });
                                    }
                                    else if (e.layer.features && e.layer.features.length > 0) {
                                        self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                        self.layer.map.zoomToFeatures(e.layer.features);

                                        self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                    } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                        self.resultsList.inner = goTo.emptyResultHTML;
                                        self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                        self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                    }

                                    self.loading.removeWait(wait);
                                }
                            });

                            if (e.layer.features && e.layer.features.length > 0) {
                                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                self.layer.map.zoomToFeatures(self.layer.features);

                                self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                self.loading.removeWait(wait);
                            } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                self.resultsList.innerHTML = goTo.emptyResultHTML;
                                self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                if (!(e.newData && e.newData.features && e.newData.features.length > 0)) {
                                    self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                }

                                self.loading.removeWait(wait);
                            }
                        }
                    };

                    self.map.one(TC.Consts.event.LAYERUPDATE, layerEventHandler);

                    layer.refresh();
                });

                resolve(goTo);
            } else {
                reject(Error('Method goTo has no implementation'));
                if (!customSearchType) {
                    self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                }
            }
        });
    };

    ctlProto.goToResult = function (id, dataRole) {
        var self = this;
        // si está habilitada
        if (self.getSearchTypeByRole(dataRole)) {
            return self._goToResult(id, dataRole);
            // si no está habilitada pero está disponible
        } else if (self.availableSearchTypes[dataRole]) {
            self.addAllowedSearchType(dataRole, self.availableSearchTypes[dataRole], self);
            return self._goToResult(id, dataRole);
        } else {
            alert('No se reconoce el tipo de búsqueda: ' + dataRole);
        }
    };

    var drawPoint = function (id) {
        var self = this;

        wait = self.loading.addWait();

        var point = self.getPoint(id);
        var delta;
        var title;
        var promise;

        if (point) {
            title = self.getLabel(id);
            promise = self.layer.addMarker(point, TC.Util.extend({}, self.map.options.styles.point, { title: title, group: title }));
        } else {
            var match = /^Lat((?:[+-]?)\d+(?:\.\d+)?)Lon((?:[+-]?)\d+(?:\.\d+)?)$/.exec(id);
            id = self.LAT + match[2] + self.LON + match[1];
            point = self.getPoint(id);

            if (point) {
                title = self.getLabel(id);
                promise = self.layer.addMarker(point, TC.Util.extend({}, self.map.options.styles.point, { title: title, group: title }));

                self.textInput.value = title;
            }
        }

        promise.then(function (feat) {
            self.map.trigger(TC.Consts.event.FEATURESADD, {
                layer: self.layer, features: [feat]
            });

            self.map.zoomToFeatures([feat]);

            self.loading.removeWait(wait);
        });

    };
    ctlProto.goToCoordinates = function (id) {
        var self = this;
        var goTo = {};
        if (/^X(\d+(?:[\.\,]\d+)?)Y(\d+(?:[\.\,]\d+)?)$/.test(id) || /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.test(id)) {

            goTo.params = {
                type: TC.Consts.layerType.VECTOR,
                styles: {
                    marker: {
                        url: self.layerStyleFN.bind(self, 'marker', 'url', true)
                    }
                }
            };

            goTo.emptyResultHTML = '<li><a class="tc-ctl-search-li-empty">' + self.OUTBBX_LABEL + '</a></li>';

            drawPoint.call(self, id);

            return goTo;
        }

        return null;
    };

    ctlProto.goToCadastralRef = function (id) {
        var self = this;
        var goTo = {};

        var regex = new RegExp("^" + self.MUN + "(\\d+)" + self.POL + "(\\d{1,2})" + self.PAR + "{1}(\\d{1,4})");
        if (regex.test(id)) {
            var match = regex.exec(id);

            if (!TC.filter) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
            }

            var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

            goTo.params = {
                type: TC.Consts.layerType.WFS,
                url: type.url,
                version: type.version,
                geometryName: type.geometryName,
                featurePrefix: type.featurePrefix,
                featureType: type.featureType,
                properties: new TC.filter.and(
                    new TC.filter.equalTo(type.queryProperties.firstQueryWord, match[1].trim()),
                    new TC.filter.equalTo(type.queryProperties.secondQueryWord, match[2].trim()),
                    new TC.filter.equalTo(type.queryProperties.thirdQueryWord, match[3].trim())),
                outputFormat: type.outputFormat,
                styles: type.styles
            };

            goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

            return goTo;
        }

        return null;
    };

    ctlProto.goToRoad = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToPK = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToStringPattern = function (id, dataRole) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(dataRole);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        return goTo;
    };

    ctlProto.getPoint = function (pattern) {
        var self = this;
        var isMapGeo = self.map.wrap.isGeo();
        var point;
        var match = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.exec(pattern);
        if (match && match.length === 3) {
            point = [parseFloat(match[1]), parseFloat(match[2])];
            if (isMapGeo) {
                point = TC.Util.reproject(point, self.map.options.utmCrs, self.map.crs);
            }
        }
        else {
            match = /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }

            match = /^Lon((?:[+-]?)\d+(?:[.,]\d+)?)Lat((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }
        }

        return point;
    };

    ctlProto.insideLimit = function (point) {
        var self = this;
        var getIntersectsBounds = function (extent, point) {
            if (extent instanceof Array)
                return point[0] >= extent[0] && point[0] <= extent[2] && point[1] >= extent[1] && point[1] <= extent[3];
            else return true;
        };

        if (getIntersectsBounds(self.map.options.maxExtent, point)) {
            return true;
        }

        return false;
    };

    ctlProto.getPattern = function () {
        var self = this;
        return self.textInput.value;
    };

    ctlProto.getLabel = function (id) {
        var self = this;
        var result = id;
        var locale = TC.Util.getMapLocale(self.map);

        if (id.match(new RegExp('^(?:' + self.LAT + '[-\\d])|(?:' + self.UTMX + '[\\d])'))) {
            result = result.replace(self.LAT, self.LAT_LABEL).replace(self.LON, ' ' + self.LON_LABEL).replace(self.UTMX, self.UTMX_LABEL).replace(self.UTMY, ' ' + self.UTMY_LABEL);
            var match = result.match(new RegExp('^' + self.LAT_LABEL.trim() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LON_LABEL.trim() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

            var localeDecimalSeparator = 1.1.toLocaleString(locale).substring(1, 2);
            var match = result.match(new RegExp('^' + self.UTMX_LABEL.trim() + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + self.UTMY_LABEL.trim() + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                if (!Number.isInteger(parseFloat(match[1])))
                    result = result.replace(match[1], match[1].replace('.', localeDecimalSeparator));
                if (!Number.isInteger(parseFloat(match[2])))
                    result = result.replace(match[2], match[2].replace('.', localeDecimalSeparator));
            }

        } else if (id.match(new RegExp('^(?:' + self.LON + '[-\\d])'))) {
            result = result.replace(self.LON, self.LON_LABEL).replace(self.LAT, ' ' + self.LAT_LABEL);

            var match = result.match(new RegExp('^' + self.LON_LABEL.trim() + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + self.LAT_LABEL.trim() + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

        } else if (id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'))) {
            var match = id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'));
            result = self.MUN_LABEL + match[2] + ', ' + self.POL_LABEL + match[4] + ', ' + self.PAR_LABEL + match[6];
        }
        return result;
    };

    ctlProto.removePunctuation = function (text) {
        text = text || '';
        var result = new Array(text.length);
        var map = {
            'á': 'a',
            'à': 'a',
            'Á': 'A',
            'À': 'A',
            'é': 'e',
            'è': 'e',
            'É': 'E',
            'È': 'E',
            'í': 'i',
            'ì': 'i',
            'Í': 'I',
            'Ì': 'I',
            'ó': 'o',
            'ò': 'o',
            'Ó': 'O',
            'Ò': 'O',
            'ú': 'u',
            'ù': 'u',
            'ü': 'u',
            'Ú': 'U',
            'Ù': 'U',
            'Ü': 'U'
        };
        for (var i = 0, len = text.length; i < len; i++) {
            result[i] = map[text.charAt(i)] || text.charAt(i);
        }
        return result.join('');
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                searchText: self.textInput.value,
                layer: self.layer.exportState({
                    exportStyles: false
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.textInput.value = state.searchText;
        self.layer.importState(state.layer).then(function () {
            self.layer.features.forEach(function (f) {
                f.setStyle(null); // Los estilos vienen dados exclusivamente por la capa, borramos estilos propios de la feature
            });
        });
    };

})();


if (!String.prototype.tcFormat) {
    String.prototype.tcFormat = function () {
        var args = (arguments || [""])[0];
        return this.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined' ?
                args[number]
                : match
                ;
        });
    };
}


if (!String.prototype.splitRemoveWhiteSpaces) {
    String.prototype.splitRemoveWhiteSpaces = function (separator) {
        var _arr = [];
        var arr = this.split(separator);
        for (var i = 0; i < arr.length; i++)
            if (arr[i].trim().length > 0)
                _arr.push(arr[i].trim());

        return _arr;
    };
}


if (!String.prototype.toCamelCase) {
    String.prototype.toCamelCase = function () {
        var _value = this.toLowerCase();
        var match = this.toLowerCase().match(/[^A-ZÁÉÍÓÚÜÀÈÌÒÙáéíóúüàèìòùa-z0-9_]+(.)/g);
        if (match) {
            for (var i = 0; i < match.length; i++) {
                if (/[-;:.<>\{\}\[\]\/\s()]/g.test(match[i]))
                    _value = _value.replace(match[i], match[i].toUpperCase());
            }
        }

        return _value.charAt(0).toUpperCase() + _value.substring(1);
    };
}


if (!Array.prototype.hasOwnProperty('findByProperty')) {
    Object.defineProperty(Array.prototype, "findByProperty", {
        enumerable: false,
        writable: true,
        value: function (propertyName, value) {
            for (var i = 0; i < this.length; i++) {
                if (this[i][propertyName] == value)
                    return this[i];
            }
        }
    });
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}

TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.SelectContainer = TC.control.TabContainer;
TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.Share = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self.exportsState = true;

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    if (window.$) {
        self._$dialogDiv = $(self._dialogDiv);
    }
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    self.render();
};

TC.inherit(TC.control.Share, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Share.prototype;

    ctlProto.CLASS = 'tc-ctl-share';
    ctlProto.MAILTO_MAX_LENGTH = 256;
    ctlProto.IFRAME_WIDTH = '600px';
    ctlProto.IFRAME_HEIGHT = '450px';
    ctlProto.FEATURE_PARAM = 'showfeature';

    ctlProto.MOBILEFAV = 'Siga las instrucciones del navegador del dispositivo móvil para añadir como favorito. Se guardará el estado actual del mapa.';
    ctlProto.NAVALERT = ' +D para guardar en marcadores.';


    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, function () {
                //Si el navegador no soporta copiar al portapapeles, ocultamos el botón de copiar
                if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
                    self.div.querySelectorAll('button').forEach(function (btn) {
                        btn.classList.remove('hide');
                    });
                    self.div.querySelectorAll('input[type=text]').forEach(function (input) {
                        delete input.dataset.dataOriginalTitle;
                    });
                }

                // Si el SO no es móvil, ocultamos el botón de compartir a WhatsApp
                if (!TC.Util.detectMobile()) {
                    self.div.querySelector(".share-whatsapp").classList.add(TC.Consts.classes.HIDDEN);
                }

                const options = self.div.querySelectorAll('.' + self.CLASS + '-url-box');
                self.div.querySelectorAll('span:not(.tc-beta)').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, function (e) {
                        var label = this;
                        while (label && label.tagName !== 'LABEL') {
                            label = label.parentElement;
                        }
                        const newFormat = label.querySelector('input[type=radio][name=format]').value;

                        options.forEach(function (option) {
                            option.classList.toggle(TC.Consts.classes.HIDDEN, !option.matches('.tc-' + newFormat));
                        });
                    });
                });
                if (TC.Util.isFunction(callback)) {
                    callback();
                }
            });
        });
    };

    /**
     * Obtiene una URL "limpia" para compartir el mapa.
     */
    ctlProto.getLocation = function () {
        var result = window.location.href;
        if (window.location.hash) {
            result = result.substr(0, result.indexOf(window.location.hash));
        }
        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const browserAlert = self.div.querySelector('.' + self.CLASS + '-alert');
        //Si la URL sobrepasa el tamaño máximo avisamos que puede fallar en Edge
        browserAlert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.browser);

        const qrAlert = self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert');
        qrAlert.classList.toggle(TC.Consts.classes.HIDDEN, !maxLengthExceed.qr);
    };

    ctlProto.generateIframe = function (url) {
        var self = this;
        var urlString = url || this.generateLink();
        if (urlString) {
            return '<iframe style="width:' + self.IFRAME_WIDTH + ';height:' + self.IFRAME_HEIGHT + ';" src="' + urlString + '"></iframe>';
        }
    }

    ctlProto.loadParamFeature = function () {
        const self = this;
        var result = null;
        var featureToShow = TC.Util.getParameterByName(self.FEATURE_PARAM);
        if (featureToShow) {
            var featureObj;
            try {
                featureObj = JSON.parse(decodeURIComponent(escape(window.atob(featureToShow))));
            }
            catch (error) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            if (featureObj && self.map) {
                if (featureObj.geom) {
                    self.map.addLayer({
                        id: self.getUID(),
                        type: TC.Consts.layerType.VECTOR,
                        title: self.getLocaleString('foi'),
                        owner: self,
                        stealth: true
                    }).then(function (layer) {
                        self.paramFeatureLayer = layer;
                        layer.importState({ features: [featureObj] }).then(function () {
                            self.map.zoomToFeatures(layer.features);
                        });
                    });
                }
                else {
                    result = featureObj;
                }
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapInfo.prototype.register.call(self, map);

        self.exportsState = true;

        self.MOBILEFAV = self.getLocaleString('mobileBookmarks.instructions');
        self.NAVALERT = self.getLocaleString('bookmarks.instructions');

        var selectInputField = function (elm) {
            const input = elm.parentElement.querySelector("input[type=text]");
            input.value = input.classList.contains('tc-url') ? self.generateLink() : self.generateIframe();
            input.select();
        };

        var unselectInputField = function () {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            const link = self.generateLink();
            self.registerListeners();
            self.div.querySelector('.tc-url input[type=text]').value = link;
            self.div.querySelector('.tc-iframe input[type=text]').value = self.generateIframe(link);
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.tc-ctl-share-url-box button', function (evt) {
            const copyBtn = evt.target;
            selectInputField(copyBtn);
            document.execCommand('copy');

            copyBtn.textContent = self.getLocaleString('copied');


            setTimeout(function () {
                copyBtn.textContent = self.getLocaleString('copy');
                unselectInputField();
            }, 1000);

        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('input[type=text]', function (evt) {
            selectInputField(evt.target);
        }));

        //Deshabilitar el click de ratón en los enlaces de compartir cuando están deshabilitados
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.ga-share-icon.disabled', function (evt) {
            evt.stopImmediatePropagation();
            evt.preventDefault();
            return false;
        }));

        //Enviar por e-mail
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('a.share-email', function (evt) {
            evt.preventDefault();
            var url = self.generateLink();

            if (url) {
                const body = encodeURIComponent(url + "\n");
                if (body.length > self.MAILTO_MAX_LENGTH) {
                    map.toast(self.getLocaleString('urlTooLongForMailto'), { type: TC.Consts.msgType.WARNING });
                }
                window.location.href = 'mailto:?body=' + body;
            }
        }));

        //Generar código QR        
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.qr-generator", function (evt) {
            evt.preventDefault();
            const qrContainer = self._dialogDiv.querySelector(".qrcode");
            qrContainer.innerHTML = '';

            if (self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert').classList.contains(TC.Consts.classes.HIDDEN)) {                
                self.makeQRCode(qrContainer, 256, 256).then(function (qrCodeBase64) {
                    if (qrCodeBase64) {
                        TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-qr-dialog'));
                    }
                });
            } else {
                TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-qr-dialog'));
            }
        }));

        
        const openSocialMedia = function (win, url, process) {
            if (url && url.trim().length > 0) {
                win.location.href = process(url);
            } else {
                TC.error(self.getLocaleString('urlTooLongForShortener'));
                win.close();
            }
        };

        //Compartir en Facebook
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-fb", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    return "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(url)
                });
            });

            return false;
        }));

        //Compartir en Twitter
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-twitter", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    var titulo = encodeURIComponent(window.document.title ? window.document.title : "Visor API SITNA");
                    return "https://twitter.com/intent/tweet?text=" + titulo + "&amp;url=" + encodeURIComponent(url);
                });
            });

            return false;
        }));

        //Compartir en Whatsapp
        if (TC.Util.detectMobile()) {
            self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-whatsapp", function (evt) {
                evt.preventDefault();

                self.shortenedLink().then(function (url) {
                    var waText = 'whatsapp://send?text=';
                    if (url !== undefined) {
                        location.href = waText + encodeURIComponent(url);
                    } else {
                        location.href = waText + encodeURIComponent(self.generateLink());
                    }
                });

                return false;
            }));
        }

        //Guardar en marcadores
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-star", function (evt) {
            evt.preventDefault();

            var bookmarkURL = self.generateLink();
            var bookmarkTitle = document.title;

            if (TC.Util.detectMobile()) {
                // Mobile browsers
                alert(ctlProto.MOBILEFAV);
            } else if (window.sidebar && window.sidebar.addPanel) {
                // Firefox version < 23
                window.sidebar.addPanel(bookmarkTitle, bookmarkURL, '');
            } else if ((window.sidebar && /Firefox/i.test(navigator.userAgent)) || (window.opera && window.print)) {
                // Firefox version >= 23 and Opera Hotlist                

                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);

            } else if (window.external && ('AddFavorite' in window.external)) {
                // IE Favorite
                window.external.AddFavorite(bookmarkURL, bookmarkTitle);
            } else {
                // Other browsers (mainly WebKit - Chrome/Safari)                
                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);
            }

            return false;
        }));

        //Cuando se añada o borre una capa, comprobamos de nuevo si la URL cumple los requisitos de longitud para habilitar el control
        //map.on(TC.Consts.event.MAPLOAD, function () {
        //    map.on(TC.Consts.event.LAYERREMOVE + ' ' + TC.Consts.event.LAYERADD, function (e) {
        //        self.generateLink();
        //    });
        //});        

        return result;
    };

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Share.html";
    ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/ShareDialog.html";

})();
/// <reference path="../feature/Marker.js" />
/// <reference path="../feature/Point.js" />
/// <reference path="../ol/ol.js" />


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {
    TC.Consts.url.GOOGLEMAPS = '//maps.googleapis.com/maps/api/js?v=3';
    var gMapsUrl = TC.Consts.url.GOOGLEMAPS;
    TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];
    TC.Cfg.proxyExceptions.push(TC.Consts.url.GOOGLEMAPS);

    TC.control.StreetView = function () {
        var self = this;
        self._sv = null;
        self._mapActiveControl = null;

        TC.Control.apply(self, arguments);

        if (self.options.googleMapsKey) {
            gMapsUrl += '&key=' + self.options.googleMapsKey;
        }

        self.viewDiv = null;
        self._startLonLat = null;
    };

    TC.inherit(TC.control.StreetView, TC.Control);

    var ctlProto = TC.control.StreetView.prototype;

    ctlProto.CLASS = 'tc-ctl-sv';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/StreetView.html";
    ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/StreetViewView.html";

    const dispatchCanvasResize = function () {
        var event = document.createEvent('HTMLEvents');
        event.initEvent('resize', true, false);
        this.map.div.querySelector('canvas').dispatchEvent(event);
    };

    var preset = function (ctl) {
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.add(TC.Consts.classes.CHECKED);
        ctl.map.div.classList.add(ctl.CLASS + '-active');
    };

    var reset = function (ctl) {
        const view = ctl.viewDiv;
        const onTransitionend = function () {
            view.removeEventListener('transitionend', onTransitionend);
            dispatchCanvasResize.call(ctl);
        };

        view.addEventListener('transitionend', onTransitionend);

        // Por si no salta transitionend
        setTimeout(function () {
            dispatchCanvasResize.call(ctl);
        }, 1000);


        ctl.layer.clearFeatures();
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.remove(TC.Consts.classes.CHECKED);
        ctl.div.querySelector('.' + ctl.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
        ctl.map.div.classList.remove(ctl.CLASS + '-active');
        ctl._startLonLat = null;
    };

    var resolve = function (ctl) {
        var result = false;
        const btn = ctl.div.querySelector('.' + ctl.CLASS + '-btn');
        const drag = ctl.div.querySelector('.' + ctl.CLASS + '-drag');

        var btnRect = btn.getBoundingClientRect();
        var dragRect = drag.getBoundingClientRect();
        drag.classList.add(TC.Consts.classes.HIDDEN);
        if (dragRect.top < btnRect.top || dragRect.top > btnRect.bottom ||
            dragRect.left < btnRect.left || dragRect.left > btnRect.right) {
            // Hemos soltado fuera del botón: activar StreetView
            result = true;
            // Precarga de marcadores
            var extent = ctl.map.getExtent();
            var xy = [extent[2], extent[3]];
            for (var i = 0; i < 16; i++) {
                ctl.layer.addMarker(xy, {
                    cssClass: 'tc-marker-sv-' + i,
                    width: 48,
                    height: 48,
                    anchor: [0, 1]
                });
            }
            /////////////////////
            // Activamos StreetView
            var mapRect = ctl.map.div.getBoundingClientRect();
            var xpos = (((dragRect.left * window.devicePixelRatio) + (dragRect.right * window.devicePixelRatio)) / 2) - (mapRect.left * window.devicePixelRatio);
            var ypos = (dragRect.bottom * window.devicePixelRatio) - (mapRect.top * window.devicePixelRatio);
            var coords = ctl.map.wrap.getCoordinateFromPixel([xpos, ypos]);
            ctl.callback(coords);
        }
        else {
            reset(ctl);
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        if (!self.viewDiv) {
            self.viewDiv = TC.Util.getDiv(self.options.viewDiv);
            self.viewDiv.classList.add(self.CLASS + '-view', TC.Consts.classes.HIDDEN);
            if (!self.options.viewDiv) {
                map.div.insertAdjacentElement('beforebegin', self.viewDiv);
            }
        }

        const result = TC.Control.prototype.register.call(self, map);

        self.layer = null;
        var layerId = self.getUID();
        for (var i = 0; i < map.workLayers.length; i++) {
            var layer = map.workLayers[i];
            if (layer.type === TC.Consts.layerType.VECTOR && layer.id === layerId) {
                self.layer = layer;
                break;
            }
        }
        if (!self.layer) {
            map.loaded(function () {
                map.addLayer({
                    id: layerId,
                    owner: self,
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layer = layer;
                });
            });
        }

        self.renderPromise().then(function () {
            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + TC.Consts.url.DRAGGABILLY],
                function () {
                    const drag = new Draggabilly(self.div.querySelector('.' + self.CLASS + '-drag'), {
                        containment: self.map.div
                    });
                    drag.on('dragStart', function (e) {
                        preset(self);
                    });
                    drag.on('dragEnd', function (e) {
                        resolve(self);
                        drag.setPosition(0, 0);
                    });
                }
            );

            const view = self.viewDiv;
            view.querySelector('.' + self.CLASS + '-btn-close').addEventListener(TC.Consts.event.CLICK, function (e) {
                e.stopPropagation();
                self.closeView();
            });
        }
            , function (a, b, c) {
                TC.error("Error de renderizado StreetView");
            });

        return result;
    };



    ctlProto.render = function () {
        const self = this;

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.renderData(null, function () {
                self.getRenderedHtml(self.CLASS + '-view', null).then(function (out) {
                    //lo normal sería hacer el resolve después de volcar out en viewDiv
                    //pero a veces fallaba
                    //no se detonaba, sin dar error alguno
                    //así que lo arreglo como a mí me gusta:
                    setTimeout(function () {
                        self.viewDiv.innerHTML = out;
                        resolve(self);
                    }
                        , 300);


                    //console.log("Casi resuelto... " + out.length);
                    //self._$viewDiv.html(out);
                    //if (err)
                    //{
                    //    TC.error(err);
                    //}
                    //resolve(self);
                    //console.log("Resuelto!");

                })
                    .catch(function (err) {
                        TC.error(err);
                    });
            });
        }));
    };

    var waitId = 0;

    ctlProto.callback = function (coords) {
        var self = this;
        var geogCrs = 'EPSG:4326';

        var ondrop = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();                
                lonLat = TC.Util.reproject([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2], self.map.crs, geogCrs);                
                self._sv.setPosition({ lng: lonLat[0], lat: lonLat[1] });
            }
        }

        var ondrag = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();
                self._startLonLat = TC.Util.reproject([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2], self.map.crs, geogCrs);
            }
        }

        var li = self.map.getLoadingIndicator();
        if (li) {
            waitId = li.addWait(waitId);
        }

        const mapDiv = self.map.div;

        var setMarker = function (sv, center) {
            self.layer.clearFeatures();

            var xy;
            var heading;
            if (sv) {
                var latLon = sv.getPosition();
                xy = TC.Util.reproject([latLon.lng(), latLon.lat()], geogCrs, self.map.crs);
                heading = sv.getPov().heading;
            }
            else {
                xy = coords;
                heading = 0;
            }
            self.map.addMarker(xy, {
                cssClass: 'tc-marker-sv-' + (Math.round(16.0 * heading / 360) + 16) % 16,
                width: 48,
                height: 48,
                anchor: [0.4791666666666667, 0.7083333333333333],
                layer: self.layer,
                showsPopup: false
            });
            Promise.all(self.map._markerPromises).then(function () {
                // Para poder arrastrar a pegman                
                self.layer.wrap.setDraggable(true, ondrop, ondrag);
            });

            if (center) {
                var setCenter = function () {
                    self.map.setCenter(xy);
                };
                // Esperamos a que el mapa esté colapsado para centrarnos: ahorramos ancho de banda
                if (mapDiv.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    setCenter();
                }
                else {
                    setTimeout(setCenter, 1200);
                }
            }
        };

        TC.loadJS(
            !window.google || !google.maps,
            gMapsUrl,
            function () {

                if (window.google) {

                    setMarker();

                    const view = self.viewDiv;
                    const lonLat = TC.Util.reproject(coords, self.map.crs, geogCrs);
                    const mapsLonLat = new google.maps.LatLng(lonLat[1], lonLat[0]);

                    // Comprobamos si hay datos de SV en el sitio elegido.
                    const svService = new google.maps.StreetViewService();
                    svService.getPanorama({
                        location: mapsLonLat,
                        preference: google.maps.StreetViewPreference.BEST
                    }, function (svPanoramaData, svStatus) {
                        if (svStatus !== google.maps.StreetViewStatus.OK) {
                            if (li) {
                                li.removeWait(waitId);
                            }
                            setTimeout(function () { // Timeout para dar tiempo a ocultarse a LoadingIndicator
                                TC.alert(svStatus === google.maps.StreetViewStatus.ZERO_RESULTS ? self.getLocaleString('noStreetView') : self.getLocaleString('streetViewUnknownError'));
                                self.layer.wrap.setDraggable(false);
                                reset(self);
                            }, 100);
                        }
                        else {
                            const onTransitionend = function (e) {
                                if (!self._transitioning) {
                                    return;
                                }

                                if (e.propertyName === 'width' || e.propertyName === 'height') {

                                    self._transitioning = false;

                                    if (li) {
                                        li.removeWait(waitId);
                                    }

                                    const resizeEvent = document.createEvent('HTMLEvents');
                                    resizeEvent.initEvent('resize', false, false);
                                    mapDiv.dispatchEvent(resizeEvent);

                                    dispatchCanvasResize.call(self);
                                    view.removeEventListener('transitionend', onTransitionend);

                                    var svOptions = {
                                        position: mapsLonLat,
                                        pov: {
                                            heading: 0,
                                            pitch: 0
                                        },
                                        zoom: 1,
                                        fullscreenControl: false,
                                        zoomControlOptions: {
                                            position: google.maps.ControlPosition.LEFT_TOP
                                        },
                                        panControlOptions: {
                                            position: google.maps.ControlPosition.LEFT_TOP
                                        }
                                    };

                                    if (!self._sv) {
                                        self._sv = new google.maps.StreetViewPanorama(view, svOptions);
                                        google.maps.event.addListener(self._sv, 'position_changed', function () {
                                            setMarker(self._sv, view.classList.contains(TC.Consts.classes.VISIBLE));
                                        });
                                        google.maps.event.addListener(self._sv, 'pov_changed', function () {
                                            if (self.layer.features && self.layer.features.length > 0) {
                                                var pegmanMarker = self.layer.features[0];

                                                delete pegmanMarker.options.url;
                                                pegmanMarker.options.cssClass = 'tc-marker-sv-' + ((Math.round(16.0 * self._sv.getPov().heading / 360) + 16) % 16);
                                                pegmanMarker.setStyle(pegmanMarker.options);

                                                self.layer.refresh();
                                            }
                                        });
                                        google.maps.event.addListener(self._sv, 'status_changed', function () {
                                            var svStatus = self._sv.getStatus();

                                            if (svStatus !== google.maps.StreetViewStatus.OK) {
                                                self._sv.setVisible(false);
                                                TC.alert(svStatus === google.maps.StreetViewStatus.ZERO_RESULTS ? self.getLocaleString('noStreetView') : self.getLocaleString('streetViewUnknownError'));
                                                if (self._startLonLat) {
                                                    self._sv.setVisible(true);
                                                    self._sv.setPosition({ lng: self._startLonLat[0], lat: self._startLonLat[1] });
                                                }
                                                else {
                                                    self.layer.wrap.setDraggable(false);
                                                    self.closeView();
                                                }
                                            }
                                        });
                                    }
                                    else {
                                        self._sv.setOptions(svOptions);
                                        self._sv.setVisible(true);
                                    }
                                }
                            };

                            self._transitioning = true;
                            view.addEventListener('transitionend', onTransitionend);

                            if (!self.options.viewDiv) {
                                // No había definida una vista. Para hacer el control compatible con mapas incrustados,
                                // en este caso a la vista nueva le asignamos el tamaño del mapa.
                                const mapRect = mapDiv.getBoundingClientRect();
                                self.viewDiv.style.height = mapRect.height + 'px';
                                self.viewDiv.style.width = mapRect.width + 'px';
                            }
                            mapDiv.classList.add(TC.Consts.classes.COLLAPSED);
                            view.style.left = '';
                            view.style.top = '';
                            view.classList.remove(TC.Consts.classes.HIDDEN);
                            view.classList.add(TC.Consts.classes.VISIBLE);


                            // Por si no salta transitionend
                            setTimeout(function () {
                                onTransitionend({ propertyName: 'width' });
                            }, 1000);

                            const header = document.body.querySelector('header');
                            if (header) {
                                header.style.display = 'none';
                            }

                            //apagar lo que sea que esté encendido (probablemente featInfo)
                            //al cerrar con el aspa, volverá a detonarse StreetView.deactivate()
                            //que, a su vez, restaurará el control anterior (FeatureInfo)
                            if (self.map.activeControl) {
                                self._previousActiveControl = self.map.activeControl;
                                self.map.activeControl.deactivate(true);
                            }

                            setMarker(self._sv);
                        }
                    });
                }
                else {
                    reset(self);
                }
            }, false, true);
    };

    ctlProto.closeView = function () {
        const self = this;
        const mapDiv = self.map.div;
        const view = self.viewDiv;

        const endProcess = function () {
            mapDiv.classList.remove(TC.Consts.classes.COLLAPSED);
            const resizeEvent = document.createEvent('HTMLEvents');
            resizeEvent.initEvent('resize', false, false);
            mapDiv.dispatchEvent(resizeEvent); // Para evitar que salga borroso el mapa tras cerrar SV.
        };
        const transitionend = 'transitionend';
        const onTransitionend = function (e) {
            if (e.propertyName === 'width' || e.propertyName === 'height') {
                view.removeEventListener(transitionend, onTransitionend);
                endProcess();
            }
        };
        view.removeEventListener(transitionend, onTransitionend);
        view.addEventListener(transitionend, onTransitionend);
        setTimeout(endProcess, 1000); // backup por si falla la transición.

        if (!self.options.viewDiv) {
            // No había definida una vista. Para hacer el control compatible con mapas incrustados,
            // en este caso a la vista nueva le habíamos asignado el tamaño del mapa.
            self.viewDiv.style.removeProperty('height');
            self.viewDiv.style.removeProperty('width');
        }
        view.classList.add(TC.Consts.classes.HIDDEN);
        view.classList.remove(TC.Consts.classes.VISIBLE);
        self.div.querySelector('.' + self.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
        self.layer.wrap.setDraggable(false);
        reset(self);
        self._sv.setVisible(false);
        const header = document.body.querySelector('header');
        if (header) {
            header.style.display = '';
        }

        if (self._previousActiveControl) {
            self._previousActiveControl.activate();
        }
    };
})();
TC.control = TC.control || {};

(function () {

    TC.control.ThreeD = function () {
        var self = this;

        TC.Control.apply(self, arguments);
    };

    TC.inherit(TC.control.ThreeD, TC.Control);

    var ctlProto = TC.control.ThreeD.prototype;

    ctlProto.CLASS = 'tc-ctl-threed';
    ctlProto.classes = {
        BETA: 'tc-beta-button',
        BTNACTIVE: 'active'
    };

    ctlProto.template = TC.apiLocation + "TC/templates/ThreeD.html";

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            if (e.view == TC.Consts.view.THREED) { // cargamos la vista 3D desde el estado actualizamos el estado del botón
                self.activate();
            }
        });

        return result;
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;

        return TC.Control.prototype.renderData.call(self, data, function () {
            self.button = self.div.querySelector('.' + self.CLASS + '-btn');

            self.button.addEventListener(TC.Consts.event.CLICK, function () {

                if (self.button.disabled) {
                    return;
                }

                if (!self.map.on3DView) {
                    self.activate();
                } else {
                    self.button.disabled = true;

                    TC.view.ThreeD.unapply({
                        callback: function () {
                            self.button.setAttribute('title', self.getLocaleString("threed.tip"));

                            self.button.classList.remove(self.classes.BTNACTIVE);

                            self.button.disabled = false;
                        }
                    });
                }
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        var self = this;

        self.button.disabled = true;

        self.browserSupportWebGL.call(self);

        const manageButton = function () {
            self.button.setAttribute('title', self.getLocaleString('threed.two.tip'));
            self.button.classList.remove(self.classes.BETA);

            self.button.classList.add(self.classes.BTNACTIVE);
        };

        const removeDisabled = function () {
            self.button.disabled = false;
        };

        if (!self.map.view3D) {
            TC.loadJS(
                !TC.view || !TC.view.ThreeD,
                TC.apiLocation + 'TC/view/ThreeD',
                function () {                                                           /* provisional */
                    TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
                });
        } else if (!self.map.on3DView) {                                               /* provisional */
            TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
        }

        manageButton();

        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.browserSupportWebGL = function () {
        var self = this;
        var result = false;

        //Check for webgl support and if not, then fall back to leaflet
        if (!window.WebGLRenderingContext) {
            // Browser has no idea what WebGL is. Suggest they
            // get a new browser by presenting the user with link to
            // http://get.webgl.org
            result = false;
        } else {
            var canvas = document.createElement('canvas');

            var webglOptions = {
                alpha: false,
                stencil: false,
                failIfMajorPerformanceCaveat: true
            };

            try {
                var gl = canvas.getContext("webgl", webglOptions) ||
                    canvas.getContext("experimental-webgl", webglOptions) ||
                    canvas.getContext("webkit-3d", webglOptions) ||
                    canvas.getContext("moz-webgl", webglOptions);
                if (!gl) {
                    // We couldn't get a WebGL context without a major performance caveat.  Let's see if we can get one at all.
                    webglOptions.failIfMajorPerformanceCaveat = false;
                    gl = canvas.getContext("webgl", webglOptions) ||
                        canvas.getContext("experimental-webgl", webglOptions) ||
                        canvas.getContext("webkit-3d", webglOptions) ||
                        canvas.getContext("moz-webgl", webglOptions);
                    if (!gl) {
                        // No WebGL at all.
                        result = false;
                    } else {
                        // We can do WebGL, but only with software rendering (or similar).
                        result = 'slow';
                        self.isSlower = true;
                    }
                } else {
                    // WebGL is good to go!
                    result = true;
                }
            } catch (e) {
                console.log(E);
            }

            if (result === "slow" || !result) {
                var warning = result === "slow" ? "threed.slowSupport.supported" : "threed.not.supported";
                self.map.toast(self.getLocaleString(warning), {
                    type: TC.Consts.msgType.WARNING,
                    duration: 10000
                });
            }

            return result;
        }
    };

})();
TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

TC.control.WFSEdit = function () {
    const self = this;

    TC.control.SWCacheClient.apply(this, arguments);

    self._classSelector = '.' + self.CLASS;

    self.layer = null;
    //self.feature = self.options.feature ? self.options.feature : null;
    self.callback = TC.Util.isFunction(arguments[2]) ? arguments[2] : (self.options.callback ? self.options.callback : null);
    self.layersEditData = {};
    self.showsOriginalFeatures = (typeof self.options.showOriginalFeatures === 'boolean') ? self.options.showOriginalFeatures : false;
    self.highlightsAdded = self.highlightsModified = self.highlightsRemoved = (typeof self.options.highlightChanges === 'boolean') ? self.options.highlightChanges : true;
    if (!TC.Util.isFunction(self.options.getBeforeEditLayerStyleFunction)) {
        self.getBeforeEditLayerStyleFunction = self.getBeforeEditLayerStyle;
    }
    self.styles = self.options.styles || {
        point: {
            fillColor: "#0000aa",
            fillOpacity: 0.1,
            strokeColor: "#0000aa",
            strokeWidth: 2,
            strokeOpacity: 1,
            radius: 6
        },
        line: {
            strokeColor: "#0000aa",
            strokeWidth: 2,
            strokeOpacity: 1
        },
        polygon: {
            fillColor: "#0000aa",
            fillOpacity: 0.1,
            strokeColor: "#0000aa",
            strokeWidth: 2,
            strokeOpacity: 1
        }
    }
};

TC.inherit(TC.control.WFSEdit, TC.control.SWCacheClient);

(function () {
    var newFeatureIdNumber = 0;
    const getNewFeatureId = function () {
        return "NewFeature." + newFeatureIdNumber++;
    };

    const setSyncState = function (ctl) {
        const layerEditData = ctl.getLayerEditData();
        ctl._saveBtn.disabled = !(navigator.onLine && layerEditData && layerEditData.checkedOut) || ctl.isSyncing;
    };

    const setEditState = function (ctl, enabled) {
        ctl.div.querySelector(ctl._classSelector + '-view').classList.toggle(TC.Consts.classes.HIDDEN, !enabled || !ctl.layer || !(ctl.layer.type === TC.Consts.layerType.WFS || ctl.layer.type === TC.Consts.layerType.WMS));
        if (ctl.layer && ctl.layer.wfsLayer) {
            const isLayerCropped = TC.filter && TC.filter.Bbox && ctl.layer.wfsLayer.properties instanceof TC.filter.Bbox;
            ctl._recropBtn.classList.toggle(TC.Consts.classes.HIDDEN, !isLayerCropped);
        }
        ctl.div.querySelector(ctl._classSelector + '-edit').classList.toggle(TC.Consts.classes.HIDDEN, !enabled);
    };

    const setChangesButtonsState = function (ctl) {
        setSyncState(ctl);
        const layerEditData = ctl.getLayerEditData();
        ctl._discardBtn.disabled = !layerEditData || !layerEditData.checkedOut;
    };

    const setChangedState = function (ctl, isChanged) {
        if (ctl.layer) {
            const layerEditData = ctl.getLayerEditData();
            if (typeof isChanged !== 'undefined') {
                layerEditData.checkedOut = isChanged;
                setChangesButtonsState(ctl);
            }
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    var storagePrefix = getStoragePrefix(ctl);
                    localforage.keys().then(function (keys) {
                        if (keys) {
                            var disabled = true;
                            for (var i = 0, len = keys.length; i < len; i++) {
                                if (keys[i].indexOf(storagePrefix) === 0) {
                                    disabled = false;
                                    break;
                                }
                            }
                            layerEditData.checkedOut = !disabled;
                            setChangesButtonsState(ctl);
                        }
                    });
                });
            }
        }
        else {
            setChangesButtonsState(ctl);
        }
    };

    const storeFeature = function (key, feature) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                var obj;
                var geometryType;
                switch (true) {
                    case feature instanceof TC.feature.Polygon:
                        geometryType = TC.Consts.geom.POLYGON;
                        break;
                    case feature instanceof TC.feature.Polyline:
                        geometryType = TC.Consts.geom.POLYLINE;
                        break;
                    case feature instanceof TC.feature.Point:
                        geometryType = TC.Consts.geom.POINT;
                        break;
                    case feature instanceof TC.feature.MultiPolygon:
                        geometryType = TC.Consts.geom.MULTIPOLYGON;
                        break;
                    case feature instanceof TC.feature.MultiPolyline:
                        geometryType = TC.Consts.geom.MULTIPOLYLINE;
                        break;
                }
                obj = {
                    id: feature.id || feature.provId,
                    attributes: feature.data,
                    type: geometryType,
                    geometry: feature.geometry,
                }
                localforage.setItem(key, obj)
                    .then(function () {
                        resolve({ feature: feature });
                    })
                    .catch(function (error) {
                        reject({ feature: feature, error: error });
                    });
            });
        });
    };


    const deleteFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.removeItem(key)
                    .then(function () {
                        resolve(key);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            });
        });
    };

    const readFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(key)
                    .then(function (value) {
                        resolve({
                            key: key,
                            feature: value
                        });
                    })
                    .catch(function (error) {
                        reject(error);
                    });
            });
        });
    };

    const getLayerStoreID = function (layer) {
        let featureType = layer.options.featureType[0];
        if (featureType.indexOf(':') < 0) {
            featureType = layer.options.featureNS + ':' + featureType;
        }
        return featureType + '@' + layer.options.url;
    };

    const getStoragePrefix = function (ctl, layer) {
        return ctl.LOCAL_STORAGE_KEY_PREFIX + getLayerStoreID(layer || ctl.layer.wfsLayer || ctl.layer);
    };

    const getAddedStoragePrefix = function (ctl, layer) {
        return getStoragePrefix(ctl, layer) + ctl.LOCAL_STORAGE_ADDED_KEY_PREFIX;
    };

    const getModifiedStoragePrefix = function (ctl, layer) {
        return getStoragePrefix(ctl, layer) + ctl.LOCAL_STORAGE_MODIFIED_KEY_PREFIX;
    };

    const getRemovedStoragePrefix = function (ctl, layer) {
        return getStoragePrefix(ctl, layer) + ctl.LOCAL_STORAGE_REMOVED_KEY_PREFIX;
    };

    const getLayerTitle = function (layer) {
        return layer.getPath ? layer.getPath().join(' • ') : (layer.title || layer.id)
    };

    const ctlProto = TC.control.WFSEdit.prototype;

    ctlProto.CLASS = 'tc-ctl-wfsedit';

    ctlProto.template = TC.apiLocation + "TC/templates/WFSEdit.html";

    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.edit.";
    ctlProto.LOCAL_STORAGE_ADDED_KEY_PREFIX = ".added.";
    ctlProto.LOCAL_STORAGE_MODIFIED_KEY_PREFIX = ".modified.";
    ctlProto.LOCAL_STORAGE_REMOVED_KEY_PREFIX = ".removed.";

    ctlProto.register = function (map) {
        const self = this;

        return new Promise(function (resolve, reject) {

            TC.control.SWCacheClient.prototype.register.call(self, map).then(function () {

                window.addEventListener('online', function () {
                    setSyncState(self);
                });
                window.addEventListener('offline', function () {
                    setSyncState(self);
                });

                self._editPromise = map.addControl('edit', {
                    id: self.getUID(),
                    div: self.div.querySelector(`.${self.CLASS}-edit`),
                    styles: self.styles,
                    downloadElevation: self.options.downloadElevation,
                    snapping: self.options.snapping
                });
                self._editPromise.then(function (ctl) {
                    self.editControl = ctl;

                    self.editControl.getAvailableFeaturesToImport = function () {
                        const candidates = Object.getPrototypeOf(self.editControl).getAvailableFeaturesToImport.call(self.editControl);
                        const layerEditData = self.getLayerEditData();
                        return candidates.filter(obj => {
                            const layer = map.getLayer(obj.id);
                            return layer !== layerEditData.addedFeaturesLayer &&
                                layer !== layerEditData.modifiedFeaturesLayer &&
                                layer !== layerEditData.removedFeaturesLayer &&
                                layer !== layerEditData.beforeEditLayer;
                        });
                    };
                    self.editControl.importFeatures = function (features) {
                        const featuresToImport = (features || this.featuresToImport || []);
                        const layerEditData = self.getLayerEditData();
                        const newFeatures = layerEditData.attributes ? featuresToImport.map(function (feature) {
                            const properties = {};
                            for (let key in layerEditData.attributes) {
                                properties[key] = feature.data[key];
                            }
                            return new feature.constructor(feature.geometry, { geometryName: layerEditData.geometryName, data: properties });
                        }) : features;
                        Object.getPrototypeOf(self.editControl).importFeatures.call(self.editControl, newFeatures);
                    };
                    self.editControl
                        .on(TC.Consts.event.DRAWEND, function (e) {
                            if (self.getLayerEditData().serializable) {
                                self._storeFeatureAdd(e.feature);
                            }
                        })
                        .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                            const feat = e.feature;
                            const fid = feat.provId || feat.id;
                            const storeSuccess = function () {
                                setChangedState(self, true);
                            };
                            const storeFailure = function () {
                                TC.error(self.getLocaleString('failedWhenSavingModifyOperationInSession'));
                            };
                            const layerEditData = self.getLayerEditData();
                            if (layerEditData.serializable) {
                                let storedFeature = layerEditData.addedFeaturesLayer.getFeatureById(fid);
                                if (storedFeature) {
                                    storedFeature.setCoords(feat.geometry);
                                    storedFeature.setData(feat.getData());
                                    storeFeature(getAddedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                                }
                                else {
                                    storedFeature = layerEditData.modifiedFeaturesLayer.getFeatureById(fid);
                                    if (storedFeature) {
                                        storedFeature.setCoords(feat.geometry);
                                        storedFeature.setData(feat.getData());
                                    }
                                    else {
                                        layerEditData.modifiedFeaturesLayer.addFeature(self._createAuxFeature(feat));
                                    }
                                    storeFeature(getModifiedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                                }
                            }
                        })
                        .on(TC.Consts.event.FEATUREADD, function (e) {
                            if (self.getLayerEditData().serializable) {
                                self._storeFeatureAdd(e.feature);
                            }
                        })
                        .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                            if (self.getLayerEditData().serializable) {
                                self._storeFeatureRemove(e.feature);
                            }
                        });

                    map.workLayers.forEach(layer => self.addLayer(layer));

                    map
                        .on(TC.Consts.event.LAYERUPDATE, function (e) {
                            const layer = e.layer;
                            if (layer.type === TC.Consts.layerType.WFS && !layer.options.readOnly) {
                                self.getEditableLayer(layer)
                                    .then(l => self.cacheLayer(l));
                            }
                        })
                        .on(TC.Consts.event.ZOOM, function (e) {
                            map.workLayers
                                .filter(l => l.wfsLayer)
                                .filter(l => self.layer !== l)
                                .forEach(function (layer) {
                                    layer.wfsLayer = null;
                                    self.getEditableLayer(layer);
                                });
                        })
                        .on(TC.Consts.event.LAYERADD, function (e) {
                            self.addLayer(e.layer);
                        })
                        .on(TC.Consts.event.LAYERREMOVE, function (e) {
                            const layer = e.layer;
                            if (self._removingLayer === layer) {
                                return;
                            }
                            if (self.layer === layer || (layer.wmsLayer && self.layer === layer.wmsLayer)) {
                                self.setLayer(null);
                            }
                            const option = self._layerSelect.querySelector(`option[value="${layer.id}"]`);
                            if (option) {
                                option.parentElement.removeChild(option);
                            }
                        })
                        .on(TC.Consts.event.LAYERERROR, function (e) {
                            const layer = e.layer;
                            if (layer.type === TC.Consts.layerType.WFS && !layer.options.readOnly) {
                                if (e.reason === TC.Consts.WFSErrors.MAX_NUM_FEATURES) {
                                    map.toast(self.getLocaleString('query.msgTooManyResults', { limit: e.data.limit }), { type: TC.Consts.msgType.WARNING });
                                }
                                if (self.layer === layer || (self.layer && self.layer.wfsLayer === layer)) {
                                    delete self.layersEditData[self.layer.id];
                                    self.setLayer(null);
                                }
                                if (layer.wmsLayer) {
                                    map.removeLayer(layer);
                                    layer.wmsLayer.wfsLayer = null;
                                }
                            }
                        });

                    resolve(self);
                });

                map.loaded(function () {
                    self._layerSelect.disabled = false;

                    if (self.options.layer) {
                        self.setLayer(self.options.layer);
                    }
                    else {
                        const wfsLayers = map.workLayers.filter(function (elm) {
                            return elm.type === TC.Consts.layerType.WFS && !elm.options.stealth;
                        });
                        if (wfsLayers.length === 1) {
                            self.setLayer(wfsLayers[0].id);
                        }
                        else {
                            self.setLayer(null);
                        }
                    }

                    self.showOriginalFeatures(self.showsOriginalFeatures);
                });

                map.ready(function () {
                    map.getControlsByClass('TC.control.WorkLayerManager').forEach(function (ctl) {
                        ctl.addLayerTool({
                            renderFn: function (container, layerId) {
                                const className = self.CLASS + '-btn-edit';
                                let button = container.querySelector('button.' + className);
                                if (!button) {
                                    const text = self.getLocaleString('featureEditing');
                                    button = document.createElement('button');
                                    button.innerHTML = text;
                                    button.setAttribute('title', text);
                                    button.classList.add(className);
                                    button.dataset.layerId = layerId;
                                    container.appendChild(button);
                                    const layer = map.getLayer(layerId);
                                    if (layer.type === TC.Consts.layerType.WMS) {
                                        button.classList.add(TC.Consts.classes.LOADING);
                                        layer.getWFSCapabilities()
                                            .catch(() => button.classList.add(TC.Consts.classes.HIDDEN))
                                            .finally(() => button.classList.remove(TC.Consts.classes.LOADING));
                                    }
                                }
                                return button;
                            },
                            updateEvents: [TC.Consts.event.BEFORELAYERUPDATE, TC.Consts.event.LAYERUPDATE, TC.Consts.event.LAYERERROR, TC.Consts.event.CONTROLACTIVATE, TC.Consts.event.CONTROLDEACTIVATE],
                            updateFn: function (e) {
                                const button = this;
                                const layer = map.getLayer(button.dataset.layerId);
                                setTimeout(() => {
                                    button.classList.toggle(TC.Consts.classes.ACTIVE, self.layer === layer);
                                }, 500);
                                button.disabled = !layer || (layer.isRaster() && layer.names.length !== 1);
                            },
                            actionFn: function () {
                                const button = this;
                                const layer = map.getLayer(button.dataset.layerId);
                                const prevLayer = self.layer;
                                button.classList.remove(TC.Consts.classes.ACTIVE);
                                if ((layer.names && layer.names.length === 1) || !layer.isRaster()) {
                                    if (layer && prevLayer !== layer) {
                                        self.setLayer(layer).then(() => {
                                            //button.classList.toggle(TC.Consts.classes.ACTIVE, self.layer === layer);
                                            self.openEditSession();
                                        });
                                    }
                                    else {
                                        self.setLayer(null);
                                    }
                                }
                            }
                        });
                    });
                });
            });
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        var editLayers = [];
        if (self.map) {
            for (var i = 0, len = self.map.workLayers.length; i < len; i++) {
                var wl = self.map.workLayers[i];
                if (wl.type === TC.Consts.layerType.WFS && !wl.options.stealth) {
                    editLayers.push({
                        id: wl.id,
                        title: wl.title || wl.id
                    });
                }
            }
        }
        return self._set1stRenderPromise(TC.Control.prototype.renderData.call(self, {
            layers: editLayers,
            showOriginalFeatures: self.showsOriginalFeatures,
            highlightChanges: self.highlightsAdded || self.highlightsModified || self.highlightsRemoved,
            controlId: self.id
        }, function () {

            self._layerDiv = self.div.querySelector(self._classSelector + '-layer');
            self._layerSelect = self._layerDiv.querySelector(self._classSelector + '-layer-sel');
            self._layerSelect.addEventListener('change', function (e) {
                setEditState(self, false);
                self.getEditableLayer(self._layerSelect.value)
                    .then(function (layer) {
                        self.setLayer(layer.wmsLayer || layer).then(function () {
                            if (self.layer) {
                                self.openEditSession();
                            }
                        });
                    })
                    .catch(() => {
                        self.setLayer(null);
                    });
            });

            const viewToolsDiv = self.div.querySelector(self._classSelector + '-view');

            self._editingWatch = viewToolsDiv.querySelector(`.${self.CLASS}-view-watch`);
            self._beforeEditLayerWatch = viewToolsDiv.querySelector(`.${self.CLASS}-view-original-watch`);
            self._addedWatch = viewToolsDiv.querySelector(`.${self.CLASS}-view-added-watch`);
            self._modifiedWatch = viewToolsDiv.querySelector(`.${self.CLASS}-view-modified-watch`);
            self._removedWatch = viewToolsDiv.querySelector(`.${self.CLASS}-view-removed-watch`);

            viewToolsDiv.querySelector(`#${self.CLASS}-view-original-cb-${self.id}`).addEventListener('change', function (e) {
                self.showOriginalFeatures(e.target.checked);
            });

            viewToolsDiv.querySelector(`#${self.CLASS}-view-added-cb-${self.id}`).addEventListener('change', function (e) {
                self.highlightAdded(e.target.checked);
            });

            viewToolsDiv.querySelector(`#${self.CLASS}-view-modified-cb-${self.id}`).addEventListener('change', function (e) {
                self.highlightModified(e.target.checked);
            });

            viewToolsDiv.querySelector(`#${self.CLASS}-view-removed-cb-${self.id}`).addEventListener('change', function (e) {
                self.highlightRemoved(e.target.checked);
            });

            const colorRegExp = new RegExp(`${self.CLASS}-view-clr-(.+)-${self.id}`);
            const onColorClick = function (e) {
                const input = this.parentElement.querySelector('input[type=color]');
                const layerEditData = self.getLayerEditData();
                const layer = layerEditData[input.id.match(colorRegExp)[1] + 'FeaturesLayer'];
                switch (layerEditData.geometryType) {
                    case TC.Consts.geom.POINT:
                        input.value = layer.styles.point.strokeColor;
                        break;
                    case TC.Consts.geom.POLYLINE:
                    case TC.Consts.geom.MULTIPOLYLINE:
                        input.value = layer.styles.line.strokeColor;
                        break;
                    default:
                        input.value = layer.styles.polygon.strokeColor;
                        break;
                }
                input.click();
            };

            const onColorChange = function (e) {
                const input = e.target;
                const layerEditData = self.getLayerEditData();
                const prefix = input.id.match(colorRegExp)[1];
                const layer = layerEditData[prefix + 'FeaturesLayer'];
                const newColor = layerEditData[prefix + 'CustomColor'] = input.value;
                switch (layerEditData.geometryType) {
                    case TC.Consts.geom.POINT:
                        layer.styles.point.strokeColor = newColor;
                        break;
                    case TC.Consts.geom.POLYLINE:
                    case TC.Consts.geom.MULTIPOLYLINE:
                        layer.styles.line.strokeColor = newColor;
                        break;
                    default:
                        layer.styles.polygon.strokeColor = newColor;
                        layer.styles.polygon.fillColor = newColor;
                        break;
                }
                layer.setStyles(layer.styles);
                self[`_${prefix}Watch`].src = getLegendImage(layer, layerEditData.geometryType);
            };

            const addedColorInputId = `${self.CLASS}-view-clr-added-${self.id}`;
            viewToolsDiv.querySelector(`label[for="${addedColorInputId}"]`).addEventListener(TC.Consts.event.CLICK, onColorClick);
            document.getElementById(addedColorInputId).addEventListener('change', onColorChange);

            const modifiedColorInputId = `${self.CLASS}-view-clr-modified-${self.id}`;
            viewToolsDiv.querySelector(`label[for="${modifiedColorInputId}"]`).addEventListener(TC.Consts.event.CLICK, onColorClick);
            document.getElementById(modifiedColorInputId).addEventListener('change', onColorChange);

            const removedColorInputId = `${self.CLASS}-view-clr-removed-${self.id}`;
            viewToolsDiv.querySelector(`label[for="${removedColorInputId}"]`).addEventListener(TC.Consts.event.CLICK, onColorClick);
            document.getElementById(removedColorInputId).addEventListener('change', onColorChange);

            self._saveBtn = self.div.querySelector(self._classSelector + '-btn-save');
            self._saveBtn.addEventListener(TC.Consts.event.CLICK, function () {
                TC.confirm(self.getLocaleString('edit.applyEdits.confirm', { layerTitle: getLayerTitle(self.layer) }), function () {
                    self.applyEdits();
                });
            });
            
            self._discardBtn = self.div.querySelector(self._classSelector + '-btn-discard');
            self._discardBtn.addEventListener(TC.Consts.event.CLICK, function () {
                TC.confirm(self.getLocaleString('edit.discardEdits.confirm', { layerTitle: getLayerTitle(self.layer) }), function () {
                    self.discardEdits();
                });
            });

            self._recropBtn = self.div.querySelector(`.${self.CLASS}-view button.${self.CLASS}-btn-crop`);
            self._recropBtn.addEventListener(TC.Consts.event.CLICK, function () {
                if (self.layer) {
                    const reload = () => {
                        if (self.layer && self.layer.wfsLayer && TC.filter && TC.filter.Bbox && self.layer.wfsLayer.properties instanceof TC.filter.Bbox) {
                            const layerEditData = self.getLayerEditData();
                            self.layer.wfsLayer.properties = new TC.filter.Bbox(null, self.map.getExtent(), self.map.getCRS());
                            self.layer.wfsLayer.refresh();
                            if (layerEditData.beforeEditLayer) {
                                layerEditData.beforeEditLayer.properties = self.layer.wfsLayer.properties;
                                layerEditData.beforeEditLayer.refresh();
                            }
                        }
                    };
                    const layerEditData = self.getLayerEditData();
                    const editedFeatures = layerEditData.addedFeaturesLayer.features.concat(layerEditData.modifiedFeaturesLayer.features, layerEditData.removedFeaturesLayer.features);
                    if (editedFeatures.length) {
                        TC.loadJS(
                            !TC.Geometry,
                            TC.apiLocation + 'TC/Geometry',
                            function () {
                                let featuresOutside = false;
                                const extent = self.map.getExtent();
                                const bbox = [[extent[0], extent[1]], [extent[0], extent[3]], [extent[2], extent[3]], [extent[2], extent[1]]];
                                for (var i = 0, ii = editedFeatures.length; i < ii; i++) {
                                    if (!TC.Geometry.intersects(editedFeatures[i].geometry, bbox)) {
                                        featuresOutside = true;
                                        break;
                                    }
                                }
                                if (featuresOutside) {
                                    TC.confirm(self.getLocaleString('refreshLayerToCurrentExtent.confirm'), function () {
                                        reload();
                                    });
                                }
                                else {
                                    reload();
                                }
                            }
                        );
                    }
                    else {
                        reload();
                    }
                    
                }
            });

            if (TC.Util.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.addLayer = function (layer) {
        const self = this;
        const appendOption = function (layer) {
            const option = document.createElement('option');
            option.setAttribute('value', layer.id);
            option.innerHTML = getLayerTitle(layer);
            self.renderPromise().then(function () {
                self._layerSelect.appendChild(option);
            });
        };
        if (!layer.isBase && !layer.options.readOnly && !layer.options.stealth) {
            self.getEditableLayer(layer)
                .then(function (l) {
                    // Añadimos opción cuando es una capa WMS con WFS asociado o una capa WFS independiente
                    if (layer.isRaster() || !l.wmsLayer) {
                        appendOption(layer);
                    }
                })
                .catch((err) => console.log(`Layer ${layer.id} not editable. Reason: ${err.message}`));
        }
    };

    ctlProto.setLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {

            const map = self.map;
            const selector = self.div.querySelector(self._classSelector + '-layer-sel');

            layer = map.getLayer(layer);
            const mapLayer = map.workLayers.filter(l => l === layer)[0];

            const setNewLayer = function () {
                if (mapLayer) {
                    self.getEditableLayer(mapLayer)
                        .then(function (editableLayer) {
                            const endProcess = function () {
                                self.layer = mapLayer;
                                self._enableEditSerialization(mapLayer)
                                    .then(function () {
                                        self.getEditControl().then(c => {
                                            selector.value = self.layer.id;
                                            c.setMode(null);
                                            c.setLayer(editableLayer);
                                            resolve(self.layer);
                                        });
                                    })
                                    .catch((err) => {
                                        self.setLayer(null);
                                        reject(err);
                                    });
                            };

                            if (map.workLayers.indexOf(editableLayer) >= 0) {
                                endProcess();
                            }
                            else {
                                map.addLayer(editableLayer).then(endProcess);
                            }
                        })
                        .catch(() => {
                            self.setLayer(null);
                            resolve(null);
                        });
                }
                else {
                    if (self.layer && self.layer.wfsLayer) {
                        self._removingLayer = self.layer.wfsLayer;
                    }
                    self.getEditControl().then(c => {
                        setEditState(self, false);
                        //setChangedState(self, false);
                        self.closeEditSession()
                            .then(() => {
                                selector.value = '';
                                c.setMode(null);
                                c.setLayer(null);
                                self.layer = null;
                                resolve(null);
                            })
                            .finally(() => {
                                delete self._removingLayer;
                            });
                    });
                }
            };

            if (layer === null || !self.layer) {
                setNewLayer();
            }
            else {
                if (self.layer.wfsLayer) {
                    self._removingLayer = self.layer.wfsLayer;
                }
                self.closeEditSession().then(() => {
                    if (mapLayer) {
                        setNewLayer();
                    }
                });
            }
        });
    };

    ctlProto._storeFeatureAdd = function (feature) {
        const self = this;
        feature.provId = getNewFeatureId();
        const layerEditData = self.getLayerEditData();
        const newFeature = self._createAuxFeature(feature);
        layerEditData.addedFeaturesLayer.addFeature(newFeature);
        storeFeature(getAddedStoragePrefix(self) + feature.provId, newFeature).then(function () {
            setChangedState(self, true);
            //self.map.toast(self.getLocaleString('addOperationSavedInSession'));
        }, function () {
            TC.error(self.getLocaleString('failedWhenSavingAddOperationInSession'));
        });
    };

    ctlProto._storeFeatureRemove = function (feature) {
        const self = this;
        var fid = feature.provId || feature.id;
        var storeSuccess = function () {
            setChangedState(self);
            //self.map.toast(self.getLocaleString('removeOperationSavedInSession'));
        };
        var storeFailure = function () {
            TC.error(self.getLocaleString('failedWhenSavingRemoveOperationInSession'));
        };
        const layerEditData = self.getLayerEditData();
        if (layerEditData.serializable) {
            let storedFeature = layerEditData.addedFeaturesLayer.getFeatureById(fid);
            if (!storedFeature) {
                var removedStoragePrefix = getRemovedStoragePrefix(self);
                storedFeature = layerEditData.modifiedFeaturesLayer.getFeatureById(fid);
                if (!storedFeature) {
                    storedFeature = layerEditData.removedFeaturesLayer.getFeatureById(fid);
                    if (!storedFeature) {
                        layerEditData.removedFeaturesLayer.addFeature(self._createAuxFeature(feature));
                        storeFeature(removedStoragePrefix + fid, feature).then(storeSuccess, storeFailure);
                    }
                }
                else {
                    layerEditData.modifiedFeaturesLayer.removeFeature(storedFeature);
                    layerEditData.removedFeaturesLayer.addFeature(self._createAuxFeature(feature));
                    deleteFeature(getModifiedStoragePrefix(self) + fid).then(function () {
                        storeSuccess();
                        storeFeature(removedStoragePrefix + fid, feature).then(storeSuccess, storeFailure);
                    }, storeFailure);
                }
            }
            else {
                layerEditData.addedFeaturesLayer.removeFeature(storedFeature);
                deleteFeature(getAddedStoragePrefix(self) + fid).then(storeSuccess, storeFailure);
            }
        }
    };

    ctlProto._createAuxFeature = function (feature) {
        const self = this;
        const fid = feature.provId || feature.id;
        const layerEditData = self.getLayerEditData();
        const result = new feature.constructor(feature.geometry, { geometryName: layerEditData.geometryName, data: feature.getData() });
        result.setStyle(null);
        result.setId(fid);
        return result;
    };

    ctlProto.getEditControl = function () {
        const self = this;
        return self._editPromise || new Promise(function (resolve, reject) {
            self.renderPromise().then(() => resolve(self.editControl));
        });
    };

    ctlProto.cacheLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function () {
                if (navigator.onLine) {
                    const gfUrl = layer.wrap.getGetFeatureUrl();
                    const dftUrl = layer.getDescribeFeatureTypeUrl();
                    if (gfUrl && dftUrl) {
                        self.createCache(getStoragePrefix(self, layer), {
                            urlList: [gfUrl, dftUrl]
                        }).then(() => resolve(), error => reject(error));
                    }
                    else {
                        resolve();
                    }
                }
                else {
                    resolve();
                }
            }).catch(error => reject(error));
        });
    };

    ctlProto.getFeatureType = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            layer = layer || self.layer;
            const li = map.getLoadingIndicator();
            const waitId = li && li.addWait();
            layer.describeFeatureType()
                .then(function (attributes) {
                    self.getEditControl().then(function (editControl) {
                        const layerEditData = self.getLayerEditData(layer);
                        // recogemos los atributos no geométricos y definimos la geometría
                        layerEditData.attributes = {};
                        for (var key in attributes) {
                            const attr = attributes[key];
                            const geometryType = editControl.getGeometryType(attr.type);
                            if (geometryType) {
                                layerEditData.geometryName = attr.name;
                                layerEditData.geometryType = typeof geometryType === 'boolean' ? null : geometryType;
                            }
                            else {
                                layerEditData.attributes[key] = attr;
                            }
                        }
                        for (var key in layerEditData.attributes) {
                            const attr = layerEditData.attributes[key];
                            attr.type = attr.type.substr(attr.type.indexOf(':') + 1);
                        }
                        resolve(layerEditData);
                    });
                })
                .catch(function (err) {
                    reject(err);
                })
                .finally(() => li && li.removeWait(waitId));
        });
    };

    ctlProto._addAuxLayersToMap = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            layer = layer || self.layer;
            const layerEditData = self.getLayerEditData(layer);
            const beLayer = layerEditData.beforeEditLayer;
            if (beLayer) {
                const afLayer = layerEditData.addedFeaturesLayer;
                const mfLayer = layerEditData.modifiedFeaturesLayer;
                const rfLayer = layerEditData.removedFeaturesLayer;
                Promise.all([
                    map.addLayer(beLayer),
                    map.addLayer(afLayer),
                    map.addLayer(mfLayer),
                    map.addLayer(rfLayer)
                ]).then(function () {
                    self.getEditableLayer(layer).then(function (editableLayer) {
                        let idx = map.layers.indexOf(editableLayer);
                        beLayer.setVisibility(self.showsOriginalFeatures);
                        afLayer.setVisibility(self.highlightsAdded);
                        mfLayer.setVisibility(self.highlightsModified);
                        rfLayer.setVisibility(self.highlightsRemoved);
                        self.map.insertLayer(beLayer, ++idx, function () {
                            const newIdx = idx + 1;
                            map.insertLayer(afLayer, newIdx);
                            map.insertLayer(mfLayer, newIdx);
                            map.insertLayer(rfLayer, newIdx);

                            beLayer.setStyles(self.getBeforeEditLayerStyle(editableLayer));
                            afLayer.setStyles(self.getAddedFeaturesLayerStyle(editableLayer));
                            mfLayer.setStyles(self.getModifiedFeaturesLayerStyle(editableLayer));
                            rfLayer.setStyles(self.getRemovedFeaturesLayerStyle(editableLayer));
                            self._editingWatch.src = getLegendImage(editableLayer, layerEditData.geometryType);
                            self._beforeEditLayerWatch.src = getLegendImage(beLayer, layerEditData.geometryType);
                            self._addedWatch.src = getLegendImage(afLayer, layerEditData.geometryType);
                            self._modifiedWatch.src = getLegendImage(mfLayer, layerEditData.geometryType);
                            self._removedWatch.src = getLegendImage(rfLayer, layerEditData.geometryType);
                            resolve();
                        });
                    });
                });
            }
            else {
                reject(new Error(`No auxiliary layers for ${layer.id}`));
            }
        });
    };

    ctlProto.openEditSession = function () {
        const self = this;
        if (!self.layer) {
            return Promise.reject(Error('No layer set for editing'));
        }
        return new Promise(function (resolve, reject) {

            self.getFeatureType() // Obtenemos datos de los atributos y la geometría
                .then(function (layerEditData) {

                    self.getEditControl().then(function (editControl) {
                        self.getEditableLayer(self.layer).then(function (editableLayer) {
                            editControl.setLayer(editableLayer);
                            switch (layerEditData.geometryType) {
                                case TC.Consts.geom.MULTIPOLYLINE:
                                case TC.Consts.geom.MULTIPOLYGON:
                                    editControl.setComplexGeometry(true);
                                    break;
                                default:
                                    editControl.setComplexGeometry(false);
                                    break;
                            }
                            editControl.activate();
                            setEditState(self, true);
                            setChangedState(self);

                            const modes = [TC.control.Edit.mode.MODIFY, TC.control.Edit.mode.OTHER];
                            switch (layerEditData.geometryType) {
                                case TC.Consts.geom.POINT:
                                    modes.push(TC.control.Edit.mode.ADDPOINT);
                                    break;
                                case TC.Consts.geom.POLYLINE:
                                case TC.Consts.geom.MULTIPOLYLINE:
                                    modes.push(TC.control.Edit.mode.ADDLINE);
                                    //modes.push(TC.control.Edit.mode.CUT);
                                    break;
                                case TC.Consts.geom.POLYGON:
                                case TC.Consts.geom.MULTIPOLYGON:
                                    modes.push(TC.control.Edit.mode.ADDPOLYGON);
                                    //modes.push(TC.control.Edit.mode.CUT);
                                    break;
                                default:
                                    break;
                            }
                            editControl.constrainModes(modes);
                            editControl.setMode(TC.control.Edit.mode.MODIFY);

                            self._addAuxLayersToMap()
                                .then(() => resolve())
                                .catch ((err) => reject(err));
                        })
                    });
                })
                .catch(function (err) {
                    if (self.layer && self.layer.type === TC.Consts.layerType.VECTOR) {
                        self.getEditControl().then(function (editControl) {
                            editControl.activate();
                            setEditState(self, true);
                            editControl.setMode(TC.control.Edit.mode.MODIFY);
                            resolve();
                        });
                    }
                    else {
                        reject(err);
                    }
                });
        });
    };

    ctlProto.closeEditSession = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.renderPromise().then(function () {
                setChangedState(self, false);
                self.getEditControl().then(c => c.deactivate());
                const layerEditData = self.getLayerEditData();
                if (layerEditData && layerEditData.beforeEditLayer) {
                    self._editingWatch.src = TC.Consts.BLANK_IMAGE;
                    self._beforeEditLayerWatch.src = TC.Consts.BLANK_IMAGE;
                    self._addedWatch.src = TC.Consts.BLANK_IMAGE;
                    self._modifiedWatch.src = TC.Consts.BLANK_IMAGE;
                    self._removedWatch.src = TC.Consts.BLANK_IMAGE;
                    const previousLayer = self.layer;
                    self.getEditableLayer(self.layer).then(function (editableLayer) {
                        const removePromises = []
                        const removeLayer = function (layer) {
                            if (map.workLayers.indexOf(layer) >= 0) {
                                removePromises.push(map.removeLayer(layer));
                            }
                        };
                        removeLayer(layerEditData.beforeEditLayer);
                        removeLayer(layerEditData.beforeEditLayer);
                        removeLayer(layerEditData.addedFeaturesLayer);
                        removeLayer(layerEditData.modifiedFeaturesLayer);
                        removeLayer(layerEditData.removedFeaturesLayer);
                        if (previousLayer !== editableLayer) {
                            previousLayer.wfsLayer = null;
                            removeLayer(editableLayer);
                        }
                        Promise.all(removePromises).then(() => resolve());
                    });
                }
                else {
                    resolve();
                }
            });
        });
    };

    ctlProto.getEditableLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const notEditableErrorMsg = `Layer ${layer.id} not editable`;
            layer = self.map ? map.getLayer(layer) : layer;
            if (layer) {
                if (layer.type === TC.Consts.layerType.WFS && (layer.wmsLayer || (!layer.options.stealth && !layer.options.readOnly))) {
                    layer.getCapabilitiesPromise().then(() => resolve(layer));
                }
                else if (layer.type === TC.Consts.layerType.WMS) {
                    if (layer.wfsLayer) {
                        layer.wfsLayer.getCapabilitiesPromise().then(() => resolve(layer.wfsLayer));
                    }
                    else {
                        layer.getWFSCapabilities()
                            .then(function (capabilities) {
                                //comprobamos que la solo es una capa y existe en el capabilities del WFS
                                const layers = layer.getDisgregatedLayerNames();
                                const fullLayerName = layers[0];
                                const colonIdx = fullLayerName.indexOf(':');
                                const shortLayerName = fullLayerName.substring(colonIdx + 1);
                                const prefix = 'Edicion'; //fullLayerName.substr(0, colonIdx + 1);
                                if (layers.length !== 1 || capabilities.FeatureTypes.hasOwnProperty(shortLayerName)) {
                                    TC.loadJS(
                                        !TC.layer.Vector,
                                        TC.apiLocation + 'TC/layer/Vector',
                                        function () {
                                            const wfsLayerOptions = {
                                                id: self.getUID(),
                                                type: TC.Consts.layerType.WFS,
                                                url: layer.options.url.replace(/wms/gi, 'wfs'),
                                                properties: self.map ? new TC.filter.Bbox(null, map.getExtent(), map.getCRS()) : null,
                                                outputFormat: TC.Consts.format.JSON,
                                                title: `${layer.getPath().join(' • ')} - ${self.getLocaleString('featureEditing')}`,
                                                geometryName: 'geom',
                                                featureType: [fullLayerName],
                                                featureNS: prefix,
                                                styles: self.styles,
                                                stealth: true
                                            };
                                            layer.wfsLayer = new TC.layer.Vector(wfsLayerOptions);
                                            layer.wfsLayer.wmsLayer = layer;
                                            resolve(layer.wfsLayer);
                                        }
                                    );
                                }
                                else {
                                    reject(new Error(notEditableErrorMsg));
                                }
                            })
                            .catch((err) => reject(err));
                    }
                }
                else if (layer.type === TC.Consts.layerType.VECTOR) {
                    resolve(layer);
                }
                else {
                    reject(new Error(notEditableErrorMsg));
                }
            }
            else {
                reject(new Error('No layer to edit'));
            }
        });
    };

    ctlProto.isLayerEdited = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const storagePrefix = getStoragePrefix(self, layer);
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.keys().then(function (keys) {
                    if (keys) {
                        resolve(keys.some(key => key.indexOf(storagePrefix) === 0));
                    }
                    else {
                        resolve(false);
                    }
                });
            });
        });
    };

    ctlProto.getLayerEditData = function (optionalLayer) {
        const self = this;
        const layer = optionalLayer || self.layer;
        if (!layer) {
            return null;
        }
        return self.layersEditData[layer.id] = self.layersEditData[layer.id] || {
            checkedOut: false
        };
    };

    const getLegendImage = function (layer, geometryType) {
        switch (geometryType) {
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                return TC.Util.getLegendImageFromStyle(layer.styles.point, { geometryType: TC.Consts.geom.POINT });
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                return TC.Util.getLegendImageFromStyle(layer.styles.line, { geometryType: TC.Consts.geom.POLYLINE });
            default:
                return TC.Util.getLegendImageFromStyle(layer.styles.polygon, { geometryType: TC.Consts.geom.POLYGON });
        }
    };

    ctlProto._enableEditSerialization = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.getEditableLayer(layer)
                .then(function (editableLayer) {

                    const endProcess = function () {
                        const layerEditData = self.getLayerEditData(layer);

                        const baseTitle = layer.getPath ? layer.getPath().join(' • ') : (layer.title || layer.id);

                        var beforeEditLayer = layerEditData.beforeEditLayer;
                        if (!beforeEditLayer) {
                            beforeEditLayer = layerEditData.beforeEditLayer = new TC.layer.Vector(TC.Util.extend({}, editableLayer.options, {
                                id: self.getUID(),
                                title: `${baseTitle} - ${self.getLocaleString('dataBeforeEdits')}`,
                                readOnly: true,
                                owner: self,
                                stealth: true
                            }));
                        }

                        var addedFeaturesLayer = layerEditData.addedFeaturesLayer;
                        let aflIsOld = true;
                        if (!addedFeaturesLayer) {
                            aflIsOld = false;
                            addedFeaturesLayer = layerEditData.addedFeaturesLayer = new TC.layer.Vector({
                                id: self.getUID(),
                                title: `${baseTitle} - ${self.getLocaleString('addedFeatures')}`,
                                owner: self,
                                stealth: true,
                                zIndex: 2
                            });
                        }

                        var modifiedFeaturesLayer = layerEditData.modifiedFeaturesLayer;
                        let mflIsOld = true;
                        if (!modifiedFeaturesLayer) {
                            mflIsOld = false;
                            modifiedFeaturesLayer = layerEditData.modifiedFeaturesLayer = new TC.layer.Vector({
                                id: self.getUID(),
                                title: `${baseTitle} - ${self.getLocaleString('modifiedFeatures')}`,
                                owner: self,
                                stealth: true,
                                zIndex: 2
                            });
                        }

                        var removedFeaturesLayer = layerEditData.removedFeaturesLayer;
                        let rflIsOld = true;
                        if (!removedFeaturesLayer) {
                            rflIsOld = false;
                            removedFeaturesLayer = layerEditData.removedFeaturesLayer = new TC.layer.Vector({
                                id: self.getUID(),
                                title: `${baseTitle} - ${self.getLocaleString('removedFeatures')}`,
                                owner: self,
                                stealth: true,
                                zIndex: 2
                            });
                        }

                        const featurePromises = [];
                        if (aflIsOld && mflIsOld && rflIsOld) {
                            // Existen de antes las capas de adiciones, modificaciones y eliminaciones. Leemos de ahí.
                            removedFeaturesLayer.features.forEach(function (removedFeature) {
                                const f = editableLayer.getFeatureById(removedFeature.id);
                                if (f) {
                                    editableLayer.removeFeature(f);
                                }
                            });
                            modifiedFeaturesLayer.features.forEach(function (modifiedFeature) {
                                const f = editableLayer.getFeatureById(modifiedFeature.id);
                                if (f) {
                                    f.setCoords(modifiedFeature.geometry);
                                    f.setData(modifiedFeature.getData());
                                }
                            });
                            addedFeaturesLayer.features.forEach(function (addedFeature) {
                                if (!editableLayer.getFeatureById(addedFeature.id)) {
                                    featurePromises.push(editableLayer.addFeature(self._createAuxFeature(addedFeature)));
                                }
                            });
                            Promise.all(featurePromises).then(() => {
                                layerEditData.serializable = true;
                                resolve(editableLayer);
                            });
                        }
                        else {
                            // Las capas de adiciones, modificaciones y eliminaciones son nuevas. Leemos de local storage.
                            const storagePrefix = getStoragePrefix(self, editableLayer);
                            const addedStoragePrefix = getAddedStoragePrefix(self, editableLayer);
                            const modifiedStoragePrefix = getModifiedStoragePrefix(self, editableLayer);
                            const removedStoragePrefix = getRemovedStoragePrefix(self, editableLayer);
                            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                                //var li = map.getLoadingIndicator();
                                localforage.keys().then(function (keys) {
                                    if (keys) {
                                        keys
                                            .filter(key => key.indexOf(storagePrefix) === 0)
                                            .forEach(function (key) {
                                                //li && li.addWait(uid);
                                                featurePromises.push(new Promise(function (res, rej) {
                                                    readFeature(key).then(function(obj) {
                                                        var id;
                                                        var k = obj.key;
                                                        if (k.indexOf(removedStoragePrefix) === 0) {
                                                            id = k.substr(removedStoragePrefix.length);
                                                            const feature = editableLayer.getFeatureById(id);
                                                            editableLayer.removeFeature(feature);
                                                            removedFeaturesLayer.addFeature(feature).then(() => res(feature));
                                                            //li && li.removeWait(uid);
                                                        }
                                                        else if (k.indexOf(modifiedStoragePrefix) === 0) {
                                                            id = k.substr(modifiedStoragePrefix.length);
                                                            const feature = editableLayer.getFeatureById(id);
                                                            if (feature) {
                                                                feature.setCoords(obj.feature.geometry);
                                                                feature.setData(obj.feature.attributes);
                                                                const newFeature = feature.clone();
                                                                newFeature.setId(feature.id);
                                                                modifiedFeaturesLayer.addFeature(newFeature).then(() => res(feature));
                                                                //li && li.removeWait(uid);
                                                            }
                                                            else {
                                                                res(feature);
                                                            }
                                                        }
                                                        else if (k.indexOf(addedStoragePrefix) === 0) {
                                                            id = k.substr(addedStoragePrefix.length);
                                                            var idNumber = parseInt(id.substr(id.lastIndexOf('.') + 1));
                                                            newFeatureIdNumber = Math.max(newFeatureIdNumber, idNumber + 1);
                                                            var addPromise;
                                                            switch (obj.feature.type) {
                                                                case TC.Consts.geom.POINT:
                                                                    addPromise = editableLayer.addPoint(obj.feature.geometry);
                                                                    break;
                                                                case TC.Consts.geom.POLYLINE:
                                                                    addPromise = editableLayer.addPolyline(obj.feature.geometry);
                                                                    break;
                                                                case TC.Consts.geom.POLYGON:
                                                                    addPromise = editableLayer.addPolygon(obj.feature.geometry);
                                                                    break;
                                                                case TC.Consts.geom.MULTIPOLYLINE:
                                                                    addPromise = editableLayer.addMultiPolyline(obj.feature.geometry);
                                                                    break;
                                                                case TC.Consts.geom.MULTIPOLYGON:
                                                                    addPromise = editableLayer.addMultiPolygon(obj.feature.geometry);
                                                                    break;
                                                                default:
                                                                    break;
                                                            };
                                                            addPromise.then(function (feat) {
                                                                //feat.setStyle(TC.Util.extend({}, layer.styles.line, layer.styles.polygon));
                                                                feat.provId = id;
                                                                feat.setData(obj.feature.attributes);
                                                                const newFeat = feat.clone();
                                                                newFeat.setStyle(null);
                                                                newFeat.setId(feat.provId);
                                                                addedFeaturesLayer.addFeature(newFeat).then(() =>  res(newFeat));
                                                                //li && li.removeWait(uid);
                                                            });
                                                        }
                                                    });
                                                }));
                                            });
                                    }
                                    Promise.all(featurePromises).then(() => {
                                        layerEditData.serializable = true;
                                        resolve(editableLayer);
                                    });
                                });
                            });
                        }
                    };

                    if (editableLayer.type === TC.Consts.layerType.WFS) {
                        if (editableLayer.state === TC.Layer.state.IDLE) {
                            endProcess();
                        }
                        else {
                            const onLayerUpdate = function (e) {
                                if (e.layer === editableLayer) {
                                    endProcess();
                                    self.map.off(TC.Consts.event.LAYERUPDATE, onLayerUpdate);
                                }
                            }
                            self.map.on(TC.Consts.event.LAYERUPDATE, onLayerUpdate);
                        }
                    }
                    else {
                        resolve(editableLayer);
                    }
                });
        });
    };

    ctlProto.applyEdits = function () {
        const self = this;
        if (self.layer) {
            const layerEditData = self.getLayerEditData();
            if (layerEditData.serializable) {
                self.isSyncing = true;
                setSyncState(self);
                const li = self.map.getLoadingIndicator();
                const waitId = li && li.addWait();
                // Copiamos modificadas para ponerle el nombre de atributo de geometría descrito en DescribeFeatureType.
                const modified = layerEditData.modifiedFeaturesLayer.features.map(function (feature) {
                    const result = new feature.constructor(feature.geometry, { geometryName: layerEditData.geometryName });
                    const unmodifiedFeature = layerEditData.beforeEditLayer.features.filter(f => f.id === feature.id)[0];
                    let newData;
                    if (unmodifiedFeature) {
                        newData = {};
                        for (var key in feature.data) {
                            if (key !== 'id') {
                                const oldValue = unmodifiedFeature.data[key];
                                const newValue = feature.data[key];
                                if (oldValue !== newValue) {
                                    newData[key] = newValue;
                                }
                            }
                        }
                    }
                    else {
                        newData = feature.data;
                    }
                    result.setData(newData);
                    result.setId(feature.id);
                    return result;
                });
                self.getEditableLayer(self.layer)
                    .then(function (l) {
                        l.applyEdits(layerEditData.addedFeaturesLayer.features, modified, layerEditData.removedFeaturesLayer.features)
                            .then(function (response) {
                                // SONDA DE PRUEBA, BORRAR EN PRO //
                                if (response.transactionSummary.totalInserted !== layerEditData.addedFeaturesLayer.features.length ||
                                    response.transactionSummary.totalUpdated !== modified.length ||
                                    response.transactionSummary.totalDeleted !== layerEditData.removedFeaturesLayer.features.length) {
                                    TC.error("Error de concordancia de número de entidades en transacción");
                                    console.log(response, layerEditData.addedFeaturesLayer, modified, layerEditData.removedFeaturesLayer);
                                    throw new Error(`Error en transacción: Insertados ${response.transactionSummary.totalInserted}, hay ${layerEditData.addedFeaturesLayer.features.length} en capa`);
                                }
                                ////////////////////////////////////
                                if (self.layer.type === TC.Consts.layerType.WMS) {
                                    self.layer.refresh();
                                }
                                self.deleteCache(getStoragePrefix(self)).then(function () {
                                    self.cacheLayer(l).then(function () {
                                        self.isSyncing = false;
                                        li && li.removeWait(waitId);
                                        // Las acciones a realizar a partir de este punto son las mismas que al descartar una edición
                                        self.discardEdits();
                                        self.map.toast(self.getLocaleString('changesSuccessfullySyncedWithServer'), { type: TC.Consts.msgType.INFO });
                                    });
                                });
                            })
                            .catch(function (obj) {
                                self.isSyncing = false;
                                setSyncState(self);
                                TC.error(self.getLocaleString('errorSyncingChanges', { code: obj.code, reason: obj.reason }), { type: TC.Consts.msgType.ERROR });
                            });
                    });
            }
        }
    };

    ctlProto.discardEdits = function () {
        var self = this;
        self._joinedFeatureAttributes = [];
        var storagePrefix = getStoragePrefix(self);
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
            localforage.keys().then(function (keys) {
                if (keys) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var key = keys[i];
                        if (key.indexOf(storagePrefix) === 0) {
                            localforage.removeItem(key);
                        }
                    }
                    if (self.layer) {
                        const layerEditData = self.getLayerEditData();
                        if (layerEditData.serializable) {
                            layerEditData.addedFeaturesLayer.clearFeatures();
                            layerEditData.modifiedFeaturesLayer.clearFeatures();
                            layerEditData.removedFeaturesLayer.clearFeatures();
                            self.editControl.setSelectedFeatures([]);
                            self.editControl.modifyControl.closeAttributes();
                            self.getEditableLayer(self.layer).then(l => l.refresh());
                        }
                    }
                    setChangedState(self, false);
                }
            });
            self.editControl.setMode(null);
        });
    };

    ctlProto.showOriginalFeatures = function (show) {
        const self = this;
        self.showsOriginalFeatures = show;
        const layerEditData = self.getLayerEditData();
        if (layerEditData) {
            layerEditData.beforeEditLayer.setVisibility(show);
        }
    };

    ctlProto.highlightAdded = function (highlight) {
        const self = this;
        self.highlightsAdded = highlight;
        const layerEditData = self.getLayerEditData();
        if (layerEditData && layerEditData.addedFeaturesLayer) {
            layerEditData.addedFeaturesLayer.setVisibility(highlight);
        }
    };

    ctlProto.highlightModified = function (highlight) {
        const self = this;
        self.highlightsModified = highlight;
        const layerEditData = self.getLayerEditData();
        if (layerEditData && layerEditData.modifiedFeaturesLayer) {
            layerEditData.modifiedFeaturesLayer.setVisibility(highlight);
        }
    };

    ctlProto.highlightRemoved = function (highlight) {
        const self = this;
        self.highlightsRemoved = highlight;
        const layerEditData = self.getLayerEditData();
        if (layerEditData && layerEditData.removedFeaturesLayer) {
            layerEditData.removedFeaturesLayer.setVisibility(highlight);
        }
    };

    const getStyleFromFeatureType = function (ctl, layer) {
        const result = {};
        const layerEditData = ctl.getLayerEditData(layer.wmsLayer || layer);
        switch (layerEditData.geometryType) {
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                result.polygon = layer.map.options.styles.polygon;
                break;
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                result.line = layer.map.options.styles.line;
                break;
            default:
                result.point = layer.map.options.styles.point;
                break;
        }
        return result;
    };

    ctlProto.getBeforeEditLayerStyle = function (layer) {
        const self = this;
        const getNegativeColor = function (color) {
            const rgba = layer.wrap.getRGBA(color);
            for (var i = 0; i < 3; i++) {
                rgba[i] = 255 - rgba[i];
            }
            return '#' + (rgba[0] * 65536 + rgba[1] * 256 + rgba[2]).toString(16).padStart(6, '0');
        };

        const dash = [1, 3];
        const result = TC.Util.extend(true, {}, layer.options.styles || getStyleFromFeatureType(self, layer));
        if (result.point) {
            result.point.strokeColor = getNegativeColor(result.point.strokeColor);
            result.point.lineDash = dash;
        }
        if (result.line) {
            result.line.strokeColor = getNegativeColor(result.line.strokeColor);
            result.line.lineDash = dash;
        }
        if (result.polygon) {
            result.polygon.strokeColor = getNegativeColor(result.polygon.strokeColor);
            result.polygon.lineDash = dash;
        }

        return result;
    };

    const colorizeLayer = function (ctl, layer, color) {
        const result = TC.Util.extend(true, {}, layer.options.styles || getStyleFromFeatureType(ctl, layer));
        if (result.point) {
            result.point.strokeColor = color;
            result.point.fillColor = color;
        }
        if (result.line) {
            result.line.strokeColor = color;
        }
        if (result.polygon) {
            result.polygon.strokeColor = color;
            result.polygon.fillColor = color;
        }

        return result;
    };

    ctlProto.getAddedFeaturesLayerStyle = function (layer) {
        const self = this;
        const layerEditData = self.getLayerEditData(layer.wmsLayer || layer);
        return colorizeLayer(self, layer, layerEditData.addedCustomColor || '#00ff00');
    };

    ctlProto.getModifiedFeaturesLayerStyle = function (layer) {
        const self = this;
        const layerEditData = self.getLayerEditData(layer.wmsLayer || layer);
        return colorizeLayer(self, layer, layerEditData.modifiedCustomColor || '#ff7f00');
    };

    ctlProto.getRemovedFeaturesLayerStyle = function (layer) {
        const self = this;
        const layerEditData = self.getLayerEditData(layer.wmsLayer || layer);
        return colorizeLayer(self, layer, layerEditData.removedCustomColor || '#ff0000');
    };

})();
TC.control = TC.control || {};

/*pollyfill*/

if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/filter');
}
//cargo los objetos features si no, no resaltara las geometria
if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}
if (!TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}
if (!TC.feature.Polyline) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polyline');
}
if (!TC.feature.Polygon) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polygon');
}
if (!TC.feature.MultiPolyline) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/MultiPolyline');
}
if (!TC.feature.MultiPolygon) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/MultiPolygon');
}

TC.control.WFSQuery = function (options) {
    var self = this;

    TC.Control.apply(this, arguments);
    self.styles = self.options.styles;
    self.highlightStyles = self.options.highlightStyles || self.options.highLightStyles;
    self.download = self.options.download;

    const cs = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]',
        INTERPOLATION_RADIO: 'input[type=radio][name=finfo-ip-coords]',
        INTERPOLATION_DISTANCE: cs + '-dialog-ip-m'
    };
};

TC.inherit(TC.control.WFSQuery, TC.Control);

(function () {
    var ctlProto = TC.control.WFSQuery.prototype;

    var cssClassLoading = "tc-loading";
    var modalBody = null;
    var modalDialog = null;
    var ctlResultsPanel = null;
    var resultLayer = null;
    var logicalOperator = TC.Consts.logicalOperator.AND;
    var timer = null;
    var timerAutocomplete = null;
    var controller = null;
    var locale = null;

    const empty= function (node) {
        if(node)
            while (node.children.length) {
                node.removeChild(node.children[0]);
            }
    };

    var filterByOperation = {
        eq: TC.filter.equalTo,
        not: TC.filter.notEqualTo,
        gt: TC.filter.greaterThan,
        lt: TC.filter.lessThan,
        ge: TC.filter.greaterThanOrEqualTo,
        le: TC.filter.lessThanOrEqualTo,
        like: TC.filter.like,
        contains: TC.filter.like,
        start: TC.filter.like,
        end: TC.filter.like,
        bw: TC.filter.between
    }
    var map = null;
    var _currentLayer = null;
    var _currentLayerName = null;
    var _currentLayercapabilities = null;
    var _currentLayerTitle = null;
    var _currentLayerURL = null;
    var _getStyles = function () { return null };
    var _getHighLightStyles = function () { return null };
    var getLocaleString = null;
    var downloadDialog = null;
    var type = null;
    ctlProto.CLASS = 'tc-ctl-wfsquery';

    ctlProto.template = {};
    ctlProto.template[ctlProto.CLASS + "-dialog"] = TC.apiLocation + "TC/templates/WFSQueryDialog.html";
    ctlProto.template[ctlProto.CLASS + "-form"] = TC.apiLocation + "TC/templates/WFSQueryForm.html";
    ctlProto.template[ctlProto.CLASS + "-filter"] = TC.apiLocation + "TC/templates/WFSQueryfilter.html";
    ctlProto.template[ctlProto.CLASS + "-table-object"] = TC.apiLocation + "TC/templates/WFSQueryResultsTableObject.html";


    var checkInput = function (type) {
        var input = document.createElement("input");
        input.setAttribute("type", type);
        return input.type == type;
    };

    var _loadDatePolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    };
    var _loadNumberPolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    }
    var _renderModalDialog = function (layer, layerName, capabilities, callback) {
        const self = this;
        let layers;
        if (layer.getDisgregatedLayerNames) {
            layers = [];
            layer.getDisgregatedLayerNames().forEach(function (value, index) {
                var path = layer.getPath(value);
                //quitamos aquellas que no estén disponibles en el WFS
                if (capabilities.FeatureTypes.hasOwnProperty(value.substring(value.indexOf(":") + 1)))
                    layers.push({ name: value, title: path[path.length - 1] });
            });
            layers.sort(function (a, b) {
                if (a.title < b.title) return -1;
                if (a.title > b.title) return 1;
                return 0;
            });
        }
        else {
            layers = layer.featureType;
        }

        ctlProto.getRenderedHtml(ctlProto.CLASS + "-dialog",
            {
                layerName: getLocaleString("query.titleDialog", { "layerName": layerName }),
                layers: layers
            }, function (html) {                
                var d = document.createElement("div");
                d.insertAdjacentHTML('beforeEnd',html);
                var modal = null;
                if (d.childNodes.length > 0) {
                    modal = d.firstChild;
                    document.body.appendChild(modal);
                }
                modalBody = modal.getElementsByClassName("tc-modal-body")[0]
                modalBody.classList.add(cssClassLoading);

                TC.Util.showModal(modal, {
                    closeCallback: function () {
                        modal.parentElement.removeChild(modal);
                    }
                });
                //IE me hace la puñeta con los estilos, no me fuciona el calc el el max-height así que lo calculo cada vez que muestro el dialogo
                if (TC.Util.detectIE()) {
                    var coef = 1;
                    switch (true) {
                        case document.body.clientWidth > 768 && document.body.clientWidth < document.body.clientHeight:
                        case document.body.clientWidth > 1024:
                            coef = 0.8;
                        case document.body.clientWidth > 1140:
                            coef = 0.7;
                            break;
                    }
                    modalBody.style.maxHeight = (document.body.clientHeight * coef) - modalBody.nextElementSibling.clientHeight - modalBody.previousElementSibling.clientHeight;
                }
                modalDialog = modal;
                modal.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].addEventListener("click", function () {
                    _sendQuery.apply(self, []);
                })
                if (callback) callback(modal);
            });
    };

    var _renderQueryForm = function (args) {
        var layer = args[0], dialog = args[1], capabilities = args[2];
        _currentLayer = layer;
        _currentLayercapabilities = capabilities;
        _currentLayerURL = capabilities.Operations.DescribeFeatureType.DCP.HTTP.Get["href"];
        _currentLayerURL = _currentLayerURL.substring(_currentLayerURL.indexOf(":") + 1);
        if (capabilities.Operations.GetFeature.CountDefault)
            _maxRecordCount = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
        else
            _maxRecordCount = null;
        //analizamos si es una o varias capas, si es una agrupación la disgregamos 
        var layers = layer.getDisgregatedLayerNames ? layer.getDisgregatedLayerNames() : layer.featureType;
        //quitamos aquellas que no estén disponibles en el WFS
        layers = layers.filter(function (l) {
            return capabilities.FeatureTypes.hasOwnProperty(l.substring(l.indexOf(":") + 1));
        });
        if (layers.length > 1) {
            modalBody.classList.remove(cssClassLoading);
            //bindeamos el onchange de combo
            dialog.getElementsByClassName("tc-combo")[0].addEventListener("change", function () {
                if (!this.value) {
                    var form = dialog.getElementsByClassName("tc-modal-form")[0];
                    empty(form);
                    for (var i = 0; i < form.children.length; i++) form.removeChild(form.children[i]);
                    _clear();
                    return;
                }
                dialog.querySelector(".tc-modal-body .tc-ctl-wfsquery-message", dialog).classList.add(TC.Consts.classes.HIDDEN);
                _currentLayerTitle = this.options[this.selectedIndex].text;
                modalBody.classList.add(cssClassLoading);
                _currentLayerName = this.value;
                _currentLayer.describeFeatureType(this.value).then(function (data) {
                    var entries = Object.entries(data);
                    _manageDescribeFeature(entries.length > 1 ? data : entries[0][1], dialog);
                }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.insertAdjacentHTML('beforeend',"<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    empty(tbody);
                });
            });
        }
        else if (layers.length === 1) {
            //comprabamos que la capa existe en el capabilities
            var layerCapabilities = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)];
            if (layerCapabilities) {
                _currentLayerTitle = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)].Title;
                _currentLayerName = layers[0];
                _currentLayer.describeFeatureType(layers[0]).then(function (data) {
                    var entries = Object.entries(data);
                    _manageDescribeFeature(entries.length > 1 ? data : entries[0][1], dialog);
                }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.insertAdjacentHTML('beforeend',"<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    empty(tbody);
                });
            }
            else {
                var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                tbody.classList.remove(cssClassLoading);
                tbody.insertAdjacentHTML('beforeend',"<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                //TC.Util.closeModal();
                //layer.map.toast("Mal", { type: TC.Consts.msgType.WARNING });
            }

        }
        else {
            TC.Util.closeModal();
            layer.map.toast(TC.Util.getLocaleString(layer.map.options.locale, "query.LayerNotAvailable"), { type: TC.Consts.msgType.ERROR });
        }
    }


    var _getValue = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.unmaskedValue;

        } else if (dateInputMask) {
            //si es texto con mascara de fecha convertierto la fecha de dd/mm/yyyy a yyyy-mm-dd
            return dateInputMask.unmaskedValue.substring(4) + "-" + dateInputMask.unmaskedValue.substring(2, 4) + "-" + dateInputMask.unmaskedValue.substring(0, 2)
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var _getValueToShow = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.value;
        }
        else if (dateInputMask) {
            //si es de tipo date devolvemos la fecha en formato dd/mm/yyyy
            return dateInputMask.value;
        }
        else if (input.type === "date") {
            return new Date(input.value).toLocaleDateString(locale)
        }
        else if (input.type === "number") {
            var dotOrComma = 1.1.toLocaleString(locale).substring(1, 2);
            return input.value.replace(".", dotOrComma);
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var dateInputMask = null;
    var inputMaskNumber = null;
    var _createDateMask = function (txtBox) {
        if (checkInput("date"))
            txtBox.type = "date";
        else {
            txtBox.type = "search";
            _loadDatePolyFill().then(function () {
                //construir el polyfill
                dateInputMask = new IMask(txtBox, {
                    mask: Date,
                    pattern: ((!locale || locale === "es-ES") ? 'd/`m/`Y' : (locale === "eu-ES" ? 'Y/`m/`d' : 'm/`d/`Y')),
                    lazy: false,
                    format: function (date) {
                        var day = date.getDate();
                        var month = date.getMonth() + 1;
                        var year = date.getFullYear();
                        if (day < 10) day = "0" + day;
                        if (month < 10) month = "0" + month;
                        switch (locale) {
                            case "eu-ES":
                                return [year, month, day].join('/');
                                break;
                            case "en-US":
                                return [month, day, year].join('/');
                                break;
                            case "es-ES":
                            default:
                                return [day, month, year].join('/');
                                break;
                        }

                    },
                    // define str -> date convertion
                    parse: function (str) {
                        switch (locale) {
                            case "eu-ES":
                                return new Date(str.split('/')[1] + "/" + str.split('/')[2] + "/" + str.split('/')[0])
                                break;
                            case "en-US":
                                return new Date(str)
                                break;
                            case "es-ES":
                            default:
                                return new Date(str.split('/')[1] + "/" + str.split('/')[0] + "/" + str.split('/')[2])
                                break;
                        }

                    },
                    blocks: {
                        d: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 31,
                            maxLength: 2,
                        },
                        m: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 12,
                            maxLength: 2,
                        },
                        Y: {
                            mask: IMask.MaskedRange,
                            from: 1900,
                            to: 9999,
                        }
                    }
                });
            });
        }
    };
    var _destroyDateMask = function () {
        if (dateInputMask) {
            var input = dateInputMask.el.input;
            dateInputMask.destroy();
            dateInputMask = null;
            input.value = "";
            input.type = "search";
        }
    };
    var destroyNumberMask = function () {
        if (inputMaskNumber) {
            var input = inputMaskNumber.el.input;
            inputMaskNumber.destroy();
            inputMaskNumber = null;
            input.value = "";
            input.type = "search";
        }
    };
    var _getDataTypes = function () {
        return _internalGetDataTypes();
    }
    var _manageDescribeFeature = function (data, dialog) {
        _clear();
        _internalGetDataTypes = function () {
            return data;
        };
        let objFiltered = {};
        for (var i in data) {
            if (!TC.Util.isGeometry(data[i].type)) {
                objFiltered[i] = data[i];
            }
        }
        data = objFiltered;
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-form",
            {
                attributes: data
            }, function (html) {
                var form = dialog.getElementsByClassName("tc-modal-form")[0];
                empty(form);
                form.insertAdjacentHTML('beforeend', html);
                modalBody.classList.remove(cssClassLoading);
                TC.loadJS(
                    true,
                    [TC.apiLocation + 'TC/ui/autocomplete.js'],
                    function () {
                        console.log("autocomplete loaded");
                    });
                var combo = form.getElementsByClassName("tc-combo");
                if (combo.length == 0)
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].setAttribute("disabled", "");
                else {
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].removeAttribute("disabled");
                    combo[0].addEventListener("change", function () {
                        _changeAttributeEvent.apply(this, [form, data]);
                    });
                    form.querySelector(".tc-ctl-wfsquery-where  input[type='radio']").addEventListener("change", function () {
                        logicalOperator = this.value === "OR" ? TC.Consts.logicalOperator.OR : TC.Consts.logicalOperator.AND
                        //reemplazar en la lista
                        form.getElementsByClassName("tc-ctl-wfsquery-whereList-op")[0].innerHTML = this.nextElementSibling.innerHTML;
                    });

                    form.querySelector(".tc-button").addEventListener("click", function () {
                        var valueField = form.querySelector('input.tc-textbox');
                        TC.UI.autocomplete.call(valueField, "clear");
                        if (inputMaskNumber)
                            inputMaskNumber.masked.remove();
                        if (!_validate(form)) {
                            return;
                        }
                        var field = [].reduce.call(form.querySelectorAll('.tc-combo'), function (vi, va) {
                            return vi + (vi ? "/" : "") + va.value;
                        }, '');
                        var checkeOp = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');
                        var op = checkeOp.value;
                        var opText = checkeOp.nextElementSibling.innerText;

                        var value = _getValue(valueField);
                        var valueToShow = _getValueToShow(valueField);
                        var logOp = form.querySelector('.tc-ctl-wfsquery-where  input[type="radio"]:checked').nextElementSibling.innerText;

                        //reemplazo < y > por y &lt;&gt;
                        value = value.replace("<", "&lt;").replace(">", "&gt;");
                        //escapo los caracteres no alfamericos                    
                        //value = value.replace(/[^a-z\dáéíóúü]/gi, '!' + '$&');
                        //se añade asterisco al principio y/o final del valor para las busquedas: "empieza por", "termina en" o "contiene"
                        var f;
                        if (type.indexOf("dateTime") >= 0) {
                            if (op !== "nbw")
                                f = new filterByOperation[op](field, value + "T00:00:00Z", value + "T23:59:59Z");
                            else//el not bettween es un caso es especial por que concatena un filtro not y otro between
                            {
                                f = new TC.filter.not(TC.filter.between(field, value + "T00:00:00Z", value + "T23:59:59Z"));
                            }
                        }
                        else
                            f = new filterByOperation[op](
                                field,
                                (((op === "end" || op === "contains") ? '*' : '') + value + ((op === "start" || op === "contains") ? '*' : '')));
                        f.matchCase = false;
                        whereObjList.push(f);
                        switch (true) {
                            case type.indexOf("int") >= 0:
                                valueToShow = parseInt(value, 10)
                                break;
                            case type.indexOf("float") >= 0:
                            case type.indexOf("double") >= 0:
                            case type.indexOf("long") >= 0:
                            case type.indexOf("decimal") >= 0:
                                valueToShow = parseFloat(value, 10)
                                break;
                        }
                        whereFilterList.push({
                            "field": field,
                            "opText": opText,
                            "isString": type.indexOf("string") >= 0,
                            "valueToShow": valueToShow
                        });

                        _renderFiltersConditions(form);
                        valueField.value = "";
                    });
                }
            });
    };
    
    var _manageComplexTypes = function (type, form) {

        var html = '';
        html += ('<option value="">' + getLocaleString('query.chooseAttrCombo') + '</option>');
        for (var key in type) {
            if (!type[key].type || TC.Util.isGeometry(type[key].type)) continue;    
            html += '<option value="' + (type[key].name || key) + '">' + key + '</option>';
        }
        var container = document.createElement("div")
        container.insertAdjacentHTML('beforeend', '<select class="' + this.className + '" name="' + this.name + '">' + html + '</select>');
        this.parentNode.parentNode.insertBefore(container, this.parentNode.nextSibling).firstElementChild.addEventListener("change", function () {
            _changeAttributeEvent.apply(this, [form, type]);
        });

    }
    var _changeAttributeEvent = function (form, data) {
        //borrar los hijos		
        var combo = this;
        combo.parentElement.parentElement.querySelectorAll("select").forEach(function (element) {
            if (combo.offsetTop < element.offsetTop) {
                element.parentElement.parentElement.removeChild(element.parentElement);
            }
        });

        var valueField = form.querySelector(".tc-ctl-wfsquery-where .tc-textbox");
        if (valueField.dataset["autocomplete"])
            TC.UI.autocomplete.call(valueField, "clear");
        if (!data[this.selectedOptions[0].text]) {
            form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
            form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
            form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
            form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.add("tc-hidden");
            form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.add("tc-hidden");
            return;
        }
        type = data[this.selectedOptions[0].text].type;
        form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.remove("tc-hidden");
        TC.UI.autocomplete.call(valueField, "clear");
        //$(valueField).unbind("keydown");
        destroyNumberMask();
        valueField.type = "search";
        form.querySelector(".tc-ctl-wfsquery-numeric").classList.add("tc-hidden");
        form.querySelector(".tc-ctl-wfsquery-text").classList.add("tc-hidden");
        form.querySelector(".tc-ctl-wfsquery-date").classList.add("tc-hidden");
        form.querySelector(".tc-ctl-wfsquery-where").classList.add("tc-hidden");
        switch (true) {
            case !type:
                console.log("type es nulo");
                break;
            case type instanceof Object:
                _manageComplexTypes.apply(this, [type, form]);                
                break;
            case type.indexOf("int") >= 0:
            case type.indexOf("float") >= 0:
            case type.indexOf("double") >= 0:
            case type.indexOf("long") >= 0:
            case type.indexOf("decimal") >= 0:
                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.remove("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                if (form.querySelectorAll("tc-ctl-wfsquery-numeric input:checked").length === 0)
                    form.querySelector(".tc-ctl-wfsquery-numeric :first-child").checked = true;
                _destroyDateMask();

                if (checkInput("number")) {
                    if (TC.Util.detectIE()) {
                        valueField.type = "text";
                        _loadNumberPolyFill().then(function () {
                            inputMaskNumber = new IMask(valueField, {
                                mask: Number,  // enable number mask
                                scale: (type.indexOf("int") >= 0 || type.indexOf("long") >= 0) ? 0 : 2,  // digits after point, 0 for integers
                                signed: false,  // disallow negative
                                thousandsSeparator: (locale && locale === "en-US") ? ',' : '.',  // any single char
                                padFractionalZeros: false,  // if true, then pads zeros at end to the length of scale
                                normalizeZeros: true,  // appends or removes zeros at ends
                                radix: (locale && locale === "en-US") ? '.' : ',',  // fractional delimiter
                            })
                        });
                    }
                    else {
                        valueField.type = "number";
                        if (type.indexOf("int") >= 0 || type.indexOf("long") >= 0)
                            valueField.step = "1";
                        else
                            valueField.step = "0.0001";
                    }
                }
                break
            case type.indexOf("dateTime") >= 0:

                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.remove("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                if (form.querySelectorAll("tc-ctl-wfsquery-date input:checked").length === 0)
                    form.querySelector(".tc-ctl-wfsquery-date :first-child").checked = true;
                _createDateMask(valueField);
                break;
            case type.indexOf("string") >= 0:
                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.remove("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                if (form.querySelectorAll("tc-ctl-wfsquery-text input:checked").length === 0)
                    form.querySelector(".tc-ctl-wfsquery-text :first-child").checked = true;
                _destroyDateMask();
                const value = [].slice.call(form.querySelectorAll('select[name=' + this.name + ']')).reduce(function (vi, va) { return vi + (vi ? "/" : "") + va.value; }, "");
                _autocompleteConstructor(valueField, value, form.getElementsByClassName(ctlProto.CLASS + "-list tc-ctl-search-list")[0]);
                break;
        }
    }
    var _renderFiltersConditions = function (form) {

        if (!dust.filters.numberSeparator)
            dust.filters.numberSeparator = function (value) {
                return value.toLocaleString(locale);
            };

        if (TC._hbs && !TC._hbs.helpers.numberSeparator) {
            TC._hbs.registerHelper("numberSeparator", function (value) {
                return value.toLocaleString(locale);
            });
        }

        var whereDiv = form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0];
        empty(whereDiv);
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-filter", {
            conditions: whereFilterList
        }, function (html) {
            form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0].innerHTML = html;
            var delBtnCollection = form.getElementsByClassName("tc-ctl-wfsquery-del-cond");
            for (var i = 0; i < delBtnCollection.length; i++) {
                delBtnCollection[i].addEventListener("click", function () {
                    var index = Array.prototype.indexOf.call(delBtnCollection, this);
                    whereObjList.splice(index, 1);
                    whereFilterList.splice(index, 1);
                    _renderFiltersConditions(form);
                });
            }
        });
    }
    var _clear = function () {
        whereObjList = [];
        whereFilterList = [];
    };
    var _validate = function (form) {
        var opcion = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');

        if (dateInputMask && !dateInputMask.masked.isComplete) {
            if (/^(?=\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\x20|$))|(?:2[0-8]|1\d|0?[1-9]))([-.\/])(?:1[012]|0?[1-9])\1(?:1[6-9]|[2-9]\d)?\d\d(?:(?=\x20\d)\x20|$))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$/.test(str) === false)
                _showMessage("Fecha " + str + " inválida", TC.Consts.msgType.ERROR);
            return false;
        }
        if (opcion.length == 0) {
            _showMessage(getLocaleString("query.msgNoCondition"));
            return false;
        }
        if (form.querySelectorAll('input[type=\'date\']').length && !form.querySelector('input[type=\'date\']').checkValidity()) {
            _showMessage(getLocaleString("query.msgNoValidDate"));
            return false;
        }
        var number
        if (form.querySelectorAll('input[type=\'number\']').length && ((number = form.querySelector('input[type=\'number\']')) != null) && !number.checkValidity()) {
            if (number.step === "1")
                _showMessage(getLocaleString("query.msgNoValidNumberMustInt"));
            else
                _showMessage(getLocaleString("query.msgNoValidNumber"));
            return false;
        }
        if (form.querySelector('input.tc-textbox').value.trim() === "") {
            _showMessage(getLocaleString("query.msgNoValueCondition"));
            return false;
        }
        return true;
    };
    var _sendQuery = function () {
        const self = this;
        if (!_validateQuery()) {
            _showMessage(getLocaleString("query.msgNoQueryFilter"));
            return;
        }
        modalDialog.getElementsByClassName("tc-modal-body")[0].classList.add(cssClassLoading);
        var _fncLoadVectorLayer = function () {
            var filtro = filterConstructor();

            _createResultPanel.apply(self, [_currentLayerTitle]);

            _currentLayer.toolProxification.cacheHost.getAction(_currentLayerURL).then(function (cacheHost) {
                const url = cacheHost.action(_currentLayerURL);
                if (!resultLayer) {
                    _createVectorLayer({
                        id: "WFSQueryResults",
                        type: TC.Consts.layerType.WFS,
                        url: url,
                        version: "1.1.0",
                        owner: self,
                        stealth: true,
                        geometryName: "the_geom",
                        featurePrefix: _currentLayerName.substring(0, _currentLayerName.indexOf(":")),
                        featureType: _currentLayerName.substring(_currentLayerName.indexOf(":") + 1),
                        properties: filtro,
                        outputFormat: TC.Consts.format.JSON,
                        styles: _getStyles()
                    });
                    map.on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                        if (e.control !== ctlResultsPanel)
                            return;
                        if (TC.browserFeatures.touch()) {
                            TC.Util.swipe(e.control.div, "enable");
                        }
                        resultLayer.clearFeatures();
                        resultLayer.setVisibility(false);
                        map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    });
                }
                else {
                    resultLayer.setVisibility(false);
                    resultLayer.clearFeatures();
                    //borro el evento featureUpdate por si hago una búsqueda sin cerra el panel previamente
                    map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                    resultLayer.url = url;
                    resultLayer.featurePrefix = _currentLayerName.substring(0, _currentLayerName.indexOf(":"));
                    resultLayer.featureType = _currentLayerName.substring(_currentLayerName.indexOf(":") + 1);
                    resultLayer.properties = filtro;
                    resultLayer.setVisibility(true);
                    resultLayer.refresh();
                }
            });
        }
        _fncLoadVectorLayer();
    }
    var _createVectorLayer = function (layerOptions) {
        map.addLayer(layerOptions).then(function (layer) {
            resultLayer = layer;
            layer.map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
        });
    };
    var filterConstructor = function () {
        if (whereObjList.length > 1) {
            var condicion = document.querySelector(".tc-ctl-wfsquery-logOpRadio:checked").value;
            return TC.filter[TC.Consts.logicalOperator[condicion]].apply(null, whereObjList);
        }
        else if (whereObjList.length === 0)
            return null
        else
            return whereObjList[0];
    }
    var _featuresUpdate = function (e) {        
        if (e.layer == resultLayer) {
            if (e.newData && e.newData.totalFeatures === 0) {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading);
                _showMessage(getLocaleString("query.msgNoResults"), TC.Consts.msgType.INFO);
                return;
            }
            var features = e.layer.features;
            if (features.length > 0) {
                map.zoomToFeatures(features);
                _showResultPanel(
                    (features.length > 1 ?
                        features.reduce(function (vi, va, index) {
                            return (vi instanceof Array ? vi : [vi.data]).concat([va.data])
                        })
                        :
                        [features[0].data])
                    , resultLayer, _currentLayerTitle);
            }
            else {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading);
                _showMessage("No hay resultados", TC.Consts.msgType.INFO);
            }
            e.layer.map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
        }
    };
    const _getLayerName = () => { return _currentLayerTitle };
    var _createResultPanel = function (layerName) {
        const self = this;
        var _layerName = layerName;
        new Promise(function (resolve, reject) {
            if (!TC.control.ResultsPanel) {
                TC.loadJS(true, TC.apiLocation + 'TC/control/ResultsPanel', function () {
                    resolve(TC.control.ResultsPanel);
                });
            }
            else
                resolve(TC.control.ResultsPanel);
        }).then(function (ResultsPanel) {
            if (!ctlResultsPanel) {
                var fncResultPanelAdded = function (ctl) {
                    ctlResultsPanel = ctl;
                    delete dust.cache[ctlResultsPanel.CLASS + "-table"];                    
                    ctlResultsPanel.template[ctlResultsPanel.CLASS + "-table"] = TC.apiLocation + "TC/templates/WFSQueryResultsTable.html";
                    ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');
                }
                var ccontainer = map.getControlsByClass(TC.control.ControlContainer);
                if (ccontainer.length == 0) {
                    map.addControl("ResultsPanel",
                        {
                            "content": "table",
                            "titles": {
                                "main": "",
                                "max": ""
                            },
                            "save": {
                                "fileName": _layerName + ".xls"
                            },
                            "download": () => { _downloadClickHandler(self, _getLayerName) }
                        }).then(fncResultPanelAdded);
                }
                else {
                    ccontainer[0].addControl("ResultsPanel", {
                        "content": "table",
                        "titles": {
                            "main": "",
                            "max": ""
                        },
                        "save": {
                            "fileName": _layerName + ".xls"
                        },
                        "download": () => { _downloadClickHandler(self, _getLayerName) }, "position": "right"
                    }).then(fncResultPanelAdded);
                }
            }
            else {
                ctlResultsPanel.options.save.fileName = _layerName + ".xls";
                ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');
            }
        });

        var _downloadClickHandler = function (_self, layerName) {
            const self = _self;
            new Promise(function (resolve, reject) {
                if (!downloadDialog) {
                    self.map.addControl('FeatureDownloadDialog').then(ctl => {
                        downloadDialog = ctl;
                        resolve(downloadDialog);
                    });
                }
                else {
                    resolve(downloadDialog);
                }
            }).then(function (control) {
                var options = {
                    title: layerName()
                };
                if (self.options.displayElevation !== true)
                    options = Object.assign({}, options, { elevation: Object.assign({}, self.map.elevation && self.map.elevation.options, self.options.displayElevation) });
                else
                    options = Object.assign({}, options, { elevation: self.map.elevation && self.map.elevation.options });

                //si algún elemento de la colección es un polígono exclyo el botón GPX
                if (resultLayer.features.some(function (feature) {
                    return (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
                        (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);
                }))
                    options = Object.assign({}, options, { excludedFormats: ["GPX"] });

                control.open(resultLayer.features, options);
            });
        };
    };
    var _showResultPanel = function (data, layer, layername) {

        //map.$events.trigger(TC.Consts.event.SEARCHDONE, { data: data } );

        var truthTest = function (name, test) {
            return function (chunk, context, bodies, params) {
                return filter(chunk, context, bodies, params, name, test);
            };
        }

        //en funcion del número de elementos cargo un título en singular o plural

        ctlResultsPanel.div.querySelector(".prpanel-title-text").innerText = ctlResultsPanel.getLocaleString(data.length > 1 ? 'query.titleResultPaneMany' : 'query.titleResultPanelOne', { "numero": data.length, "layerName": layername });

        ctlResultsPanel.div.classList.add("tc-ctl-wfsquery-results");

        modalDialog.parentElement.removeChild(modalDialog);

        ctlResultsPanel.openTable({
            data: data,
            css: {
                trClass: "trClass",
                tdClass: "tdClass",
                thClass: "thClass",
            },
            callback: function (tabla) {

                ctlResultsPanel.maximize();
                console.log("render del panel de resultados");
                var col = tabla.querySelectorAll(".table>tbody>tr")
                var dataTypes = _getDataTypes();
                var j = 1;
                for (var i in data[0]) {
                    if (dataTypes.hasOwnProperty(i)) {
                        if (dataTypes[i].type && !(dataTypes[i].type instanceof Object))
                            if ((dataTypes[i].type.indexOf("int") >= 0 ||
                                dataTypes[i].type.indexOf("float") >= 0 ||
                                dataTypes[i].type.indexOf("double") >= 0 ||
                                dataTypes[i].type.indexOf("long") >= 0 ||
                                dataTypes[i].type.indexOf("decimal") >= 0)) {
                                var tdNumeric = tabla.querySelectorAll("td:nth-child(" + j + ")");
                                for (var k = 0; k < tdNumeric.length; k++) {
                                    tdNumeric[k].classList.add("tc-numeric");
                                }
                            }
                        if (dataTypes[i].type && (dataTypes[i].type instanceof Object)) {
                            console.log("aki lo que sea");
                        }
                    }
                    j++;
                }

                for (var i = 0; i < col.length; i++) {
                    col[i].addEventListener("click", function (e) {
                        e.stopPropagation();
                        var index = this.dataset.index;
                        if (index != undefined)
                            layer.map.zoomToFeatures([layer.features[index]]);
                    });
                    col[i].addEventListener("mouseenter", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.select();
                            _select(feat);
                        }
                        var celdasHoja = this.querySelectorAll("td.value div");
                        if (celdasHoja.length > 0) {
                            celdasHoja.forEach(function (celda) {
                                if (celda.offsetWidth < celda.scrollWidth)
                                    celda.title = celda.innerText;
                            })
                        }
                        else
                            this.querySelectorAll("td").forEach(function (td) {
                                if (td.offsetWidth < td.scrollWidth)
                                    td.title = td.innerText;
                            });

                    });
                    col[i].addEventListener("mouseleave", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.unselect();
                            _unselect(feat)
                            //esto es porque el unselect no devulve al estilo por defecto
                            //feat.setStyle(TC.Cfg.styles[feat.STYLETYPE]);
                        }
                    });
                }
                tabla.querySelectorAll(".complexAttr label,.complexAttr input").forEach(function (label) {
                    label.addEventListener("click", function (e) {
                        e.stopPropagation();
                    })
                });
                tabla.querySelectorAll(".complexAttr input").forEach(function (chkBox) {
                    chkBox.addEventListener("change", function (e) {
                        if (this.checked) {
                            this.nextElementSibling.querySelectorAll("td.value div").forEach(function (div) {
                                if (div.offsetWidth < div.scrollWidth)
                                    div.title = div.innerText;
                            });
                        }
                    })
                });

                ////se deshabilita el swipe para que se pueda hacer scroll horizontal del panel de resultados
                if (TC.browserFeatures.touch()) {
                    TC.Util.swipe(ctlResultsPanel.div, 'disable');
                }
            }
        });

    }
    var _validateQuery = function () {
        return whereObjList.length > 0;
    };
    var _showMessage = function (Message, type) {
        var messageDiv = modalBody.getElementsByClassName("tc-ctl-wfsquery-message")[0];
        if (timer) {
            clearTimeout(timer);
        }
        else {
            messageDiv.innerHTML = Message;
            switch (type) {
                case TC.Consts.msgType.INFO:
                    messageDiv.classList.add("tc-msg-info")
                    break;
                case TC.Consts.msgType.WARNING:
                    messageDiv.classList.add("tc-msg-warning")
                    break;
                case TC.Consts.msgType.ERROR:
                default:
                    messageDiv.classList.add("tc-msg-error")
                    break;
            }
            messageDiv.classList.remove(TC.Consts.classes.HIDDEN);
        }
        timer = setTimeout(function () {
            timer = null;
            messageDiv.classList.add(TC.Consts.classes.HIDDEN);
        }, 3000)
    };
    var _getPossibleValues = async function (field, value) {
        var _capabilities = Object.assign({}, _currentLayercapabilities);
        _capabilities.version = "1.1.0";
        switch (document.querySelector(".tc-ctl-wfsquery.tc-ctl-wfsquery-text input:checked").value) {
            case "start":
                value = (value + "*");
                break;
            case "contains":
            case "eq":
                value = ("*" + value + "*");
                break;
            case "end":
                value = ("*" + value);
                break;
        }

        if (controller) {
            controller.abort();
        }
        controller = new AbortController();
        let signal = controller.signal;

        try {
            var data = await _currentLayer.toolProxification.fetchJSON(_currentLayerURL, {
                data: TC.Util.WFSQueryBuilder([_currentLayerName], TC.filter.like(field, value, undefined, undefined, undefined, false), _capabilities, "JSON", false),
                contentType: "application/xml",
                method: "POST",
                signal: signal
            })
            if (data.features && data.features.length > 0) {
                var arr;
                if (data.features.length === 1)
                    arr = [field.split("/").reduce(function (vi, va) { return vi[va.substring(va.indexOf(":") + 1)] }, data.features[0].properties)];
                if (data.features.length > 1)
                    arr = data.features.reduce(function (pv, cv) {
                        if (pv && pv instanceof Array) {
                            if (pv.indexOf(cv.properties[field]) < 0)
                                return pv.concat(field.split("/").reduce(function (vi, va) { return vi[va.substring(va.indexOf(":") + 1)] }, cv.properties));
                            else
                                return pv;
                        }
                    }, []);
                //arr.sort();
                return arr;
            } else
                return [];
        }
        catch (err) {
            return null
        }
    };
    var _autocompleteConstructor = function (control, property, listCtrl) {

        TC.UI.autocomplete.call(control, {
            minLength: 3,
            target: listCtrl,
            source: function (text, callback) {
                var _self = this;
                _self.target.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + getLocaleString("searching") + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>'
                _self.target.classList.remove("tc-hidden");
                if (timerAutocomplete)
                    window.clearTimeout(timerAutocomplete);
                timerAutocomplete = window.setTimeout(async function () {
                    var data = await _getPossibleValues(property, text)
                    if (data) {
                        if (data.length)
                            callback(data);
                        else
                            _self.target.classList.add("tc-hidden");
                    }
                }, 500);
            },
            callback: function (e) {
                control.value = e.currentTarget.dataset["value"];
                this.target.classList.add("tc-hidden");
            },
            buildHTML: function (data) {
                var pattern = control.value;
                this.target.style.maxHeight = "";
                if (data.results.length > 1)
                    return data.results.reduce(function (pv, cp, i) {
                        return (i > 1 ? pv : _highlightText(pv, pattern)) + _highlightText(cp, pattern);
                    });
                else
                    return _highlightText(data.results[0], pattern);
            }
        });
        control.addEventListener("targetCleared.autocomplete", function () {
            listCtrl.classList.add("tc-hidden");
        });
        control.addEventListener('keypress', function (e) {
            if (e.which == 13) {
                TC.UI.autocomplete.call(control, "clear");
            }
        });
        control.addEventListener("search", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
        control.addEventListener("input", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
    };
    var _highlightText = function (text, pattern) {
        pattern = new RegExp(pattern, "gi");
        return "<li><a href=\"#\" data-value=\"" + text + "\">" + text.replace(pattern, '<b>$&</b>') + "</a></li>";
    };

    var _select = function (feature) {
        var _addFeature = function (layer, feature) {
            var result
            if (feature instanceof TC.feature.Point) {
                result = layer.addPoint(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polyline) {
                result = layer.addPolyline(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polygon) {
                result = layer.addPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolygon) {
                result = layer.addMultiPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolyline) {
                result = layer.addMultiPolyline(feature.getCoords());
            }
            return result;
        };
        if (!feature.layer)
            return;
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (!layer) {
            feature.layer.map.addLayer({
                id: "WFSQueryResultsHighlight",
                type: TC.Consts.layerType.VECTOR,
                owner: self,
                stealth: true,
                styles: _getHighLightStyles()
            }, function (layer) {
                _addFeature(layer, feature);
            });
        }
        else
            _addFeature(layer, feature);
    };
    var _unselect = function (feature) {
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (layer) {
            layer.clearFeatures();
        }
    };
    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);
        return result;
    };

    ctlProto.register = function (_map) {
        const self = this;
        map = _map;
        return new Promise(function (resolve) {

            _map.on(TC.Consts.event.LAYERERROR, (e) => {
                if (e.layer === resultLayer) {
                    modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading)
                    if (e.reason === TC.Consts.WFSErrors.MAX_NUM_FEATURES) {
                        _showMessage(getLocaleString("query.msgTooManyResults", { limit: e.data.limit }), TC.Consts.msgType.WARNING)
                    }                    
                    else {
                        console.error(e.reason);
                        _showMessage(getLocaleString("query.errorUndefined"), TC.Consts.msgType.ERROR);
                    }
                }
            })

            //condición IF si una coleccion de atributos tiene 1 o mas elementos. Tiene una lista negra llamada excludedKeys
            dust.helpers.countif = function (chunk, context, bodies, params) {
                params = params || {};
                var body = bodies.block, skip = bodies['else'], key = params["key"] || context.current();
                var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;
                var _count = 0
                for (var k in key) {
                    if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                        _count++;
                    }
                }
                if (_count > 0) {
                    chunk = chunk.render(body, context);
                }
                else if (skip) {
                    chunk = chunk.render(skip, context);
                }
                return chunk;
            }

            if (TC._hbs) {
                TC._hbs.registerHelper("countif", function (obj, excludedKeys) {
                    const excKeys = excludedKeys ? excludedKeys.split(',') : [];
                    let _count = 0
                    for (let k in obj) {
                        if (excKeys.indexOf(k) < 0) {
                            _count++;
                        }
                    }
                    return _count > 0;
                });
            }

            TC.Control.prototype.register.call(self, map).then(function (ctrl) {
                var self = ctrl;
                _getStyles = function () {
                    var styleFN = function (geomType, property) {
                        return this.options.styles && this.options.styles[geomType] ? (this.options.styles[geomType][property] || TC.Cfg.styles[geomType][property]) : TC.Cfg.styles[geomType][property]
                    }
                    return {
                        polygon: {
                            fillColor: styleFN.bind(self, 'polygon', 'fillColor'),
                            fillOpacity: styleFN.bind(self, 'polygon', 'fillOpacity'),
                            strokeColor: styleFN.bind(self, 'polygon', 'strokeColor'),
                            strokeOpacity: styleFN.bind(self, 'polygon', 'strokeOpacity'),
                            strokeWidth: styleFN.bind(self, 'polygon', 'strokeWidth')
                        },
                        line: {
                            strokeColor: styleFN.bind(self, 'line', 'strokeColor'),
                            strokeOpacity: styleFN.bind(self, 'line', 'strokeOpacity'),
                            strokeWidth: styleFN.bind(self, 'line', 'strokeWidth')
                        },
                        point: {
                            radius: styleFN.bind(self, 'point', 'radius'),
                            height: styleFN.bind(self, 'point', 'height'),
                            width: styleFN.bind(self, 'point', 'width'),
                            fillColor: styleFN.bind(self, 'point', 'fillColor'),
                            fillOpacity: styleFN.bind(self, 'point', 'fillOpacity'),
                            strokeColor: styleFN.bind(self, 'point', 'strokeColor'),
                            strokeWidth: styleFN.bind(self, 'point', 'strokeWidth'),
                            fontSize: styleFN.bind(self, 'point', 'fontSize'),
                            fontColor: styleFN.bind(self, 'point', 'fontColor'),
                            labelOutlineColor: styleFN.bind(self, 'point', 'labelOutlineColor'),
                            labelOutlineWidth: styleFN.bind(self, 'point', 'labelOutlineWidth'),
                            label: styleFN.bind(self, 'point', 'label'),
                            angle: styleFN.bind(self, 'point', 'angle')
                        }
                    }
                };
                _getHighLightStyles = function () {
                    var _default = {
                        "polygon": TC.Util.extend(true, {}, TC.Cfg.styles.polygon, {
                            fillColor: "#0099FF",
                            fillOpacity: 1,
                            strokeColor: "#0099FF",
                            strokeWidth: 2
                        }),
                        "line": TC.Util.extend(true, {}, TC.Cfg.styles.line, {
                            strokeColor: "#0099FF",
                            strokeWidth: 2
                        }),
                        "point": TC.Util.extend(true, {}, TC.Cfg.styles.point, {
                            strokeColor: "#0099FF"
                        })
                    };
                    return self.highlightStyles ? {
                        "polygon": TC.Util.extend(true, {}, _default.polygon, self.highlightStyles.polygon ? self.highlightStyles.polygon : {}),
                        "line": TC.Util.extend(true, {}, _default.line, self.highlightStyles.line ? self.highlightStyles.line : {}),
                        "point": TC.Util.extend(true, {}, _default.point, self.highlightStyles.point ? self.highlightStyles.point : {})
                    } : _default;
                };

                locale = map.options.locale;

                getLocaleString = function (key, texts) {
                    return TC.Util.getLocaleString(locale, key, texts);
                }

                map.ready(function () {
                    map.getControlsByClass('TC.control.WorkLayerManager').forEach(function (ctl) {
                        ctl.addLayerTool({
                            renderFn: function (container, layerId) {
                                const className = self.CLASS + '-btn-open';
                                let button = container.querySelector('button.' + className);
                                if (!button) {
                                    const layer = map.getLayer(layerId);
                                    if (layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WFS) {
                                        const text = self.getLocaleString('query.tooltipMagnifBtn');
                                        button = document.createElement('button');
                                        button.innerHTML = text;
                                        button.setAttribute('title', text);
                                        button.classList.add(className);
                                        button.dataset.layerId = layerId;
                                        container.appendChild(button);
                                        if (layer.type === TC.Consts.layerType.WMS) {
                                            button.classList.add(TC.Consts.classes.LOADING);
                                            layer.getWFSCapabilities().then((WFSCapabilities) => {
                                                //check si tiene GetFeature Disponible
                                                if (!WFSCapabilities.Operations.GetFeature) {
                                                    button.classList.add(TC.Consts.classes.HIDDEN);
                                                    return;
                                                }
                                                //check si las capas hijas están en capabilties WFS
                                                var layers = layer.getDisgregatedLayerNames ? layer.getDisgregatedLayerNames() : layer.featureType;
                                                layers = layers.filter(function (l) {
                                                    return WFSCapabilities.FeatureTypes.hasOwnProperty(l.substring(l.indexOf(":") + 1));
                                                });
                                                if (!layers.length) {
                                                    button.classList.add(TC.Consts.classes.HIDDEN);
                                                    return;
                                                }
                                            }).catch(() => button.classList.add(TC.Consts.classes.HIDDEN))
                                            .finally(() => button.classList.remove(TC.Consts.classes.LOADING));
                                        }
                                    }
                                }
                                return button;
                            },
                            updateEvents: [],
                            actionFn: function () {
                                const button = this;
                                if (button.classList.contains('tc-unavailable') || button.classList.contains('tc-loading')) {
                                    return;
                                }
                                const layer = self.map.getLayer(button.dataset.layerId);
                                self.renderModalDialog(layer);
                            }
                        });
                    });
                });

                resolve(self);
            });
        });
    };
    ctlProto.renderModalDialog = function (layer) {
        const self = this;
        let title;
        let capabilitiesPromise;
        if (layer.type === TC.Consts.layerType.WMS) {
            const path = layer.getPath();
            title = path[path.length - 1];
            capabilitiesPromise = layer.getWFSCapabilities();
        }
        else if (layer.type === TC.Consts.layerType.WFS) {
            title = layer.title;
            capabilitiesPromise = layer.getCapabilitiesPromise();
        }
        else {
            return;
        }
        let renderDialogPromise = new Promise(function (resolve, reject) {
            capabilitiesPromise.then(function (capabilities) {
                _renderModalDialog.apply(self, [
                    layer,
                    title,
                    capabilities,
                    function (modal) {
                        resolve(modal);
                    }]);
            })
        });

        Promise.all([layer, renderDialogPromise, capabilitiesPromise]).then(_renderQueryForm);
    };

})();

TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

TC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';

(function () {

    var capabilitiesPromises = {};

    var wfsLayer = null;//capa WFS de respaldo

    const getWFSLayer = function (url) {
        return new Promise(function (resolve, reject) {
            if (!wfsLayer || wfsLayer.options.url !== url) {
                TC.loadJS(
                    !TC.layer.Vector,
                    TC.apiLocation + 'TC/layer/Vector',
                    function () {
                        wfsLayer = new TC.layer.Vector({
                            type: TC.Consts.layerType.WFS,
                            url: url,
                            stealth: true
                        });
                        resolve(wfsLayer);
                    }
                );
            }
            else {
                resolve(wfsLayer);
            }
        });
    };
    
    const _createWMSLayer = function (layer) {

        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;
        var format = layer.options.format;
        var options = layer.options;

        var params = {
            LAYERS: layerNames,
            FORMAT: format,
            TRANSPARENT: layer.transparent,
            VERSION: layer.capabilities.version || '1.3.0'
        };

        if (layer.params) {
            TC.Util.extend(params, layer.params);
        }

        if (layer.queryParams) {
            TC.Util.extend(params, layer.queryParams);
        }

        var infoFormat = layer.getPreferredInfoFormat();
        if (infoFormat !== null) {
            params.INFO_FORMAT = infoFormat;
        }

        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);
    };

    const _createWMTSLayer = function (layer) {
        return layer.wrap.createWMTSLayer(layer.options);
    };

    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {

        var result = layer.availableNames.indexOf(treeNode.name);
        if (result === -1) {
            for (var i = 0, len = treeNode.children.length; i < len; i++) {
                result = _getLayerNodeIndex(layer, treeNode.children[i]);
                if (result !== -1) {
                    break;
                }
            }
        }
        return result;
    }

    const _sortTree = function _sortTree(layer, treeNode) {
        var _sortFunction = function (n1, n2) {
            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);
        }
        treeNode.children.sort(_sortFunction);
        for (var i = 0, len = treeNode.children.length; i < len; i++) {
            _sortTree(layer, treeNode.children[i]);
        }
    };

    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {
        var result = false;
        counter.count = counter.count + 1;
        if (treeNode.name === name) {
            result = true;
        }
        else {
            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés
            for (var i = treeNode.children.length - 1; i >= 0; i--) {
                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Opciones de nombre de capa.
     * Esta clase no tiene constructor.
     * @class TC.cfg.LayerNameOptions
     * @static
     */
    /**
     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.
     * @property aggregate
     * @type boolean
     * @default true
     */
    /**
     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} (valor <code>false</code>) 
     * o se espera a que la capa se actualice (valor <code>true</code>).
     * @property lazy
     * @type boolean
     * @default false
     */
    /**
     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/availableNames:property"}}{{/crossLink}} (valor <code>false</code>) se restablece 
     * al actualizar la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}}.
     * @property reset
     * @type boolean|undefined
     */

    /**
     * Opciones de capa raster.
     * Esta clase no tiene constructor.
     * @class TC.cfg.RasterOptions
     * @extend TC.cfg.LayerOptions
     * @static
     */
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     * @default TC.Consts.layerType.WMS
     */
    /**
     * URL del servicio OGC que define la capa.
     * @property url
     * @type string
     */
    /**
     * Indica si la capa tiene transparencia.
     * @property transparent
     * @type boolean|undefined
     */
    /**
     * Lista separada por comas de los nombres de capa del servicio OGC.
     * @property layerNames
     * @type string|undefined
     */
    /**
     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.
     * @property matrixSet
     * @type string|undefined
     */

    /**
     * Capa de tipo raster, como la de un WMS o un WMTS.
     * @class TC.layer.Raster
     * @extends TC.Layer
     * @constructor
     * @async
     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
     */
    TC.layer.Raster = function () {
        var self = this;

        if (!TC.tool || !TC.tool.Proxification) {
            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
        }

        this.toolProxification = new TC.tool.Proxification(TC.proxify);

        //esta promise se resolverá cuando el capabilities esté descargado y parseado
        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa
        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)
        this._capabilitiesPromise = null;

        TC.Layer.apply(self, arguments);

        self.wrap = new TC.wrap.layer.Raster(self);

        /**
         * Indica si la capa tiene transparencia.
         * @property transparent
         * @type boolean
         * @default true
         */
        self.transparent = (self.options.transparent === false) ? false : true;

        /**
         * URL del servicio al que pertenenece la capa.
         * @property url
         * @type string
         */
        self.url = self.options.url;
        self.capabilities = TC.capabilities[self.url];

        self.params = self.options.params;
        /**
         * Lista de nombres de capa.
         * @property names
         * @type array
         * @default []
         */
        /**
         * Lista de nombres de capa disponibles inicialmente.
         * @property availableNames
         * @type array
         * @default []
         */
        if (typeof self.options.layerNames === 'string') {
            self.names = self.availableNames = self.options.layerNames.split(',');
        }
        else {
            self.names = [];
            self.availableNames = [];
            if (Array.isArray(self.options.layerNames)) {
                for (var i = 0; i < self.options.layerNames.length; i++) {
                    var name = self.options.layerNames[i];
                    if (typeof name === 'string') {
                        self.names.push(name);
                        self.availableNames.push(name);

                    }
                    else if (name.hasOwnProperty('name')) {
                        self.availableNames.push(name.name);
                        if (name.isVisible === undefined || name.isVisible) {
                            self.names.push(name.name);
                        }
                    }
                }
            } else {
                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado
                // cuando queremos instanciar una capa pasándole un SLD en la petición
                var sldBody = self.options.params ? self.options.params.sld_body : null;

                if (sldBody) {
                    const parser = new DOMParser();
                    var sldBodyToXml;
                    try {
                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');
                    }
                    catch (e) {
                        TC.error(e.message);
                        sldBodyToXml = null;
                    }
                    if (sldBodyToXml) {
                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');
                        if (namedLayerElm && namedLayerElm.length > 0) {
                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');

                            if (names && names.length > 0) {
                                var name = names[0].textContent;
                                self.names.push(name);
                                self.availableNames.push(name);
                            }
                        }
                    }
                }
            }
        }

        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;

        self._capabilitiesNodes = {};

        /**
      * Árbol del documento de capabilities del servicio.
      * @property capabilities
      * @type object
      */
        self.wrap._promise = new Promise(function (resolve, reject) {
            /*
             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo
             */
            var _createOLLayer = function () {
                var ollyr;
                if (!self.wrap.layer) {
                    switch (self.type) {
                        case TC.Consts.layerType.GROUP:
                            break;
                        case TC.Consts.layerType.WMTS:
                            ollyr = _createWMTSLayer(self);
                            break;
                        default:
                            ollyr = _createWMSLayer(self);
                            break;
                    }
                    self.wrap.setLayer(ollyr);
                    if (ollyr) {
                        resolve(ollyr);
                    }
                    else {
                        reject(Error('Could not create native layer for "' + self.id + '"'));
                    }
                }
            };

            const processedCapabilities = function (capabilities) {
                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.
                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.
                self.capabilities = self.capabilities || capabilities;

                var actualUrl = self.getGetMapUrl();
                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;
                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;

                _createOLLayer();
            };

            if (self.capabilities) {
                processedCapabilities(self.capabilities);
                self._capabilitiesPromise = Promise.resolve(self.capabilities);
                return;
            }

            const cachePromise = capabilitiesPromises[self.url];
            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {
                const onlinePromise = self.getCapabilitiesOnline();
                const storagePromise = self.getCapabilitiesFromStorage();

                onlinePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function (error) {
                        storagePromise.catch(function () {
                            rej(error);
                        });
                    });
                storagePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function () {
                        onlinePromise.catch(function (error) {
                            rej(error);
                        });
                    });
            });

            self.getCapabilitiesPromise()
                .then(function (capabilities) {
                    processedCapabilities(capabilities);
                })
                .catch(function (error) {
                    if (self.map) {
                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });
                    }
                    reject(error);
                });
        });

        self._disgregatedLayerNames = null;

        if (TC.Consts.layerType.WMTS == self.type) {
            self.wrap.setWMTSUrl();
        }
    };

    TC.inherit(TC.layer.Raster, TC.Layer);

    var layerProto = TC.layer.Raster.prototype;
        
    layerProto.capabilitiesState_ = {
        PENDING: 0,
        DONE: 1
    };

    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';

    layerProto.getByProxy_ = function (url) {
        return TC.proxify(url);
    };
    

    layerProto.getByUrl_ = function (url) {
        return url;
    };


    layerProto.setVisibility = function (visible) {
        var layer = this;
        layer.tree = null;
        layer._cache.visibilityStates = {
        };
        TC.Layer.prototype.setVisibility.call(layer, visible);
    };

    /*
     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)
     */
    var _getLimitedMatrixSet = function (layer) {
        var layerId = layer.layerNames;
        var matrixId = layer.matrixSet;
        var cap = layer.capabilities;

        var ret = [];

        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {
            return elto.Identifier == matrixId;
        });
        if (tset.length) {
            tset = tset[0];
            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];
            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {
                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;
                for (var i = 0; i < limits.length; i++) {
                    limit = limits[i];
                    var matrix = tset.TileMatrix.filter(function (elto) {
                        return elto.Identifier == limit.TileMatrix
                    });
                    if (matrix.length) {
                        var combi = TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);
                        ret.push(combi);
                    }
                }

                return ret;
            }
            else {
                return tset.TileMatrix;
            }
        }
        else
            return null;
    };


    /*
     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen
     */
    var _aggregateLayerNames = function (layer, layerNames) {
        if (layer.type !== TC.Consts.layerType.WMS) {
            return layerNames;
        }
        else {
            var ln = layerNames.slice();
            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());
            return ln;
        }
    };

    /*
     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.
     * Se parte de un nodo del árbol de capas del capabilities
     */
    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {
        var result = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        if (children.length) {
            for (var i = 0, len = children.length; i < len; i++) {
                if (_aggregateLayerNodeNames(layer, names, children[i])) {
                    result = true;
                }
            }

            var nodeNames = children.map(function (elm) {
                return layer.wrap.getName(elm);
            }).reverse();
            var idx, firstIdx;
            var fail = false;

            firstIdx = idx = names.indexOf(nodeNames[0]);
            if (idx < 0) {
                fail = true;
            }
            else {
                for (var i = 1, len = nodeNames.length; i < len; i++) {
                    if (nodeNames[i] != names[++idx]) {
                        fail = true;
                        break;
                    }
                }
            }
            if (!fail) {
                var nodeName = layer.wrap.getName(layerNode);
                if (nodeName && nodeNames.length > 1) {
                    names.splice(firstIdx, nodeNames.length, nodeName);
                    result = true;
                }
            }
        }
        return result;
    };

    /*
     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.
     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible
     */
    var _disgregateLayerNames = function (layer, layerNames) {
        var result = [];
        var ln = layerNames.slice();
        var rootNode = layer.wrap.getRootLayerNode();
        for (var i = 0, len = ln.length; i < len; i++) {
            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));
        }
        return result;
    };

    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {
        var result = [];
        var nodeName = layer.wrap.getName(layerNode);
        var nodeVisible = layer.compareNames(name, nodeName);
        var hasEmptyChildren = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        for (var i = 0; i < children.length; i++) {
            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);
            if (!names.length) {
                hasEmptyChildren = true;
            }
            else {
                result = result.concat(names);
            }
        }
        if (!children.length || hasEmptyChildren) {
            if (ancestorVisible || nodeVisible) {
                result = [nodeName];
            }
        }
        return result;
    };

    var _extendLayerNameOptions = function (options) {
        return TC.Util.extend({ aggregate: true, lazy: false }, options);
    };

    var _combineArray = function (source, add, rem) {
        var result = [];
        var s, a, r;
        s = source ? source : [];
        a = add ? add : [];
        r = rem ? rem : [];
        var sa = s.concat(a);
        for (var i = 0; i < sa.length; i++) {
            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {
                result[result.length] = sa[i];
            }
        }
        return result;
    };

    var _sortLayerNames = function (layer, layerNames) {
        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;
        if (layer.capabilities) {
            var tree = layer.getTree();
            ln.sort(function (a, b) {
                var idxa = {
                    count: 0
                };
                var idxb = {
                    count: 0
                };
                _getLayerNamePosition(tree, a, idxa);
                _getLayerNamePosition(tree, b, idxb);
                return idxa.count - idxb.count;
            });
        }
        return ln;
    };

    var _isNameInArray = function (layer, name, names, looseComparison) {
        return names.filter(function (elm) {
            return layer.compareNames(name, elm, looseComparison);
        }).length > 0;
    };


    layerProto.getLimitedMatrixSet = function () {
        return _getLimitedMatrixSet(this);
    };

    /**
     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.
     * @method setLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  setLayerNames: sets the visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.setLayerNames = function (layerNames, options) {
        var layer = this;
        return new Promise(function (resolve, reject) {
            layer.wrap.getLayer().then(function () {
                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                layer.names = ln;
                var opts = _extendLayerNameOptions(options);
                if (opts.aggregate) {
                    ln = _aggregateLayerNames(layer, ln);
                }
                layer._disgregatedLayerNames = null;
                var newParams = {
                    LAYERS: ln.join(','), TRANSPARENT: true
                };
                if (opts.lazy) {
                    var params = layer._newParams || layer.wrap.getParams();
                    layer._newParams = TC.Util.extend(params, newParams);
                }
                else {
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });
                    }
                    layer.tree = null;
                    layer._cache.visibilityStates = {
                    };
                    layer.wrap.setParams(newParams);
                    if (opts.reset || !layer.map) {
                        // layerNames se fija cuando se añade al mapa o cuando reset = true.
                        layer.availableNames = layer.names;
                    }
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });
                    }
                }
                resolve(layer.names);
            });
        });
    };

    /**
     * Añade capas por nombre a las que ya están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.addLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2a = _disgregateLayerNames(self, ln2a);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Elimina capas por nombre de las que están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.removeLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2r = _disgregateLayerNames(self, ln2r);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.
     * @method toggleLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.toggleLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                var currentLayerNames = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2t = _disgregateLayerNames(self, ln2t);
                    currentLayerNames = self.getDisgregatedLayerNames();
                }
                var ln2a = [];
                var ln2r = [];
                for (var i = 0; i < ln2t.length; i++) {
                    var l = ln2t[i];
                    if (currentLayerNames.indexOf(l) < 0) {
                        ln2a[ln2a.length] = l;
                    }
                    else {
                        ln2r[ln2r.length] = l;
                    }
                }
                var promises = [];
                if (ln2a.length > 0) {
                    promises.push(self.addLayerNames(ln2a, opts));
                }
                if (ln2r.length > 0) {
                    promises.push(self.removeLayerNames(ln2r, opts));
                }
                Promise.all(promises).then(function (arrays) {
                    const a1 = arrays[0];
                    const a2 = arrays[1];
                    if (a1) {
                        if (a2) {
                            resolve(a1.concat(a2));
                        }
                        else {
                            resolve(a1);
                        }
                    }
                    else {
                        resolve([]);
                    }
                });
            });
        });
    };

    /**
     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
     * @method getDisgregatedLayerNames
     * @return {array}
     */
    /*
     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names
     */
    layerProto.getDisgregatedLayerNames = function () {
        ///<summary>
        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
        ///</summary>
        ///<returns type="array" elementType="string"></returns>
        var self = this;
        var olLayer = self.wrap.layer;
        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {
            if (!self._disgregatedLayerNames) {
                var layerNames = self.wrap.getParams().LAYERS;
                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');
                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);
            }
        }
        else {
            self._disgregatedLayerNames = self.names;
        }
        return self._disgregatedLayerNames.slice();
    };

    layerProto.isValidFromNames = function () {
        var self = this;
        var result = true;
        for (var i = 0, len = self.names.length; i < len; i++) {
            if (!self.getLayerNodeByName(self.names[i])) {
                result = false;
                break;
            }
        }
        return result;
    };

    layerProto.isCompatible = function (crs) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;
                break;
            case TC.Consts.layerType.WMS:
                result = self.wrap.isCompatible(crs);
                break;
            default:
                break;
        }
        return result;
    };

    layerProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        var result = self.wrap.getCompatibleCRS();
        if (options.includeFallback && self.fallbackLayer) {
            const fbLayer = self.getFallbackLayer();
            if (fbLayer instanceof TC.Layer) {
                result = result.concat(fbLayer.wrap.getCompatibleCRS());
            }
        }
        if (options.normalized) {
            result = result
                .map(function (crs) {
                    return TC.Util.getCRSCode(crs);
                }) // códigos numéricos
                .filter(function (code) {
                    return code !== null;
                })
                .reduce(function (prev, cur) {
                    if (prev.indexOf(cur) < 0) {
                        prev[prev.length] = cur;
                    }
                    return prev;
                }, []) // códigos numéricos sin duplicados
                .map(function (code) {
                    return 'EPSG:' + code;
                }); // códigos normalizados
        }
        return result;
    };

    layerProto.getProjection = function () {
        var self = this;

        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                return self.wrap.layer.getSource().getProjection().getCode();
            case TC.Consts.layerType.WMS:
                return self.map.crs;
        }
    };

    layerProto.setProjection = function (options) {
        var self = this;
        options = options || {};
        if (options.crs) {
            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];
                    if (matrixSet) {
                        self.matrixSet = matrixSet;
                        self.wrap.setMatrixSet(matrixSet);
                    }
                    else {
                        self.wrap.setProjection(options);
                    }
                    self.mustReproject = !matrixSet;
                    break;
                case TC.Consts.layerType.WMS:
                    self.wrap.setProjection(options);
                    self.mustReproject = !self.isCompatible(options.crs);
                    break;
                default:
                    break;
            }
        }
    };

    /*
     *  isVisibleByScale: return wether the WMS layer is visible at current scale
     *  Parameter: WMS layer name or UID
     */
    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {
        var self = this;
        var result;
        var _getOgcScale = function () {
            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel
        };
        var currentScale;
        var i;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = false;
                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);
                if (tileMatrix) {
                    currentScale = _getOgcScale();
                    for (i = 0; i < tileMatrix.length; i++) {
                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);
                        if (scaleDenominators[0] === currentScale) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMS:
                result = true;
                var layers = self.wrap.getAllLayerNodes();
                if (layers.length > 0) {
                    currentScale = _getOgcScale();
                    var node;
                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID
                        node = self._capabilitiesNodes[nameOrUid];
                    }
                    else {
                        for (i = 0; i < layers.length; i++) {
                            var layer = layers[i];
                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {
                                node = layer;
                                break;
                            }
                        }
                    }
                    if (node) {
                        var scaleDenominators = self.wrap.getScaleDenominators(node);
                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);

                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.
                        if (!result) {
                            if (node.Layer && node.Layer.length > 0) {
                                return node.Layer.some(function (nodeLayer) {
                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);
                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)
                                });
                            }
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    /*
     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names
     *  Parameter: WMS layer name
     */
    layerProto.isVisibleByName = function (name, looseComparison) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                if (self.wrap.getWMTSLayer()) {
                    result = true;
                    break;
                }
                break;
            case TC.Consts.layerType.WMS:
                var _getLayerPath = function _getLayerPath(name) {
                    return __getLayerPath(name, self.wrap.getRootLayerNode());
                };

                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {
                    var result = null;
                    var n = self.wrap.getName(capabilitiesNode);
                    if (self.compareNames(n, name, looseComparison)) {
                        result = [n];
                    }
                    else {
                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                        for (var i = 0; i < layerNodes.length; i++) {
                            var item = layerNodes[i];
                            var r = __getLayerPath(name, item);
                            if (r) {
                                TC.Util.fastUnshift(r, n);
                                result = r;
                                break;
                            }
                        }
                    }
                    return result;
                };

                var path = _getLayerPath(name);
                if (path) {
                    for (var i = 0; i < path.length; i++) {
                        if (_isNameInArray(self, path[i], self.names)) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    layerProto.getTree = function () {
        var self = this;
        
        var result = self.tree;

        var addChild = function (node, child) {
            if (self.options.inverseTree) {
                // Versión rápida de unshift
                TC.Util.fastUnshift(node.children, child);
            }
            else {
                node.children[node.children.length] = child;
            }
        }

        if (!result) {
            var rootNode;
            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {
                var uid;
                for (var key in self._capabilitiesNodes) {
                    if (self._capabilitiesNodes[key] === capabilitiesNode) {
                        uid = key;
                        break;
                    }
                }
                if (!uid) {
                    uid = TC.getUID();
                    self._capabilitiesNodes[uid] = capabilitiesNode;
                }
                var r = {
                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []
                };
                if (isRootNode) {
                    rootNode = r;
                }

                if (_isNameInArray(self, r.name, self.availableNames)) {
                    forceAddition = true;
                }

                if (!self.options.isBase) {
                    if (r === rootNode) {
                        r.isVisible = self.getVisibility();
                    }
                    else {
                        r.isVisible = self.isVisibleByName(r.name);
                    }
                    var i;
                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                    for (i = 0; i < layerNodes.length; i++) {
                        var treeNode = getTreeNode(layerNodes[i], forceAddition);
                        if (treeNode) {
                            addChild(r, treeNode);
                        }
                    }

                    r.legend = self.wrap.getLegend(capabilitiesNode);

                    // No muestra ramas irrelevantes si hideTree = true
                    if (!forceAddition && !isRootNode) {
                        // Eliminamos la rama hasta el nodo de interés
                        rootNode.children = rootNode.children.concat(r.children);
                        r = null;
                    }
                }
                else {
                    r.name = self.names.join(',');
                    r.title = self.title || r.title;
                    r.isBase = self.isDefault;
                    if (self.options.thumbnail) {
                        r.legend = {
                            src: self.options.thumbnail
                        };
                    }
                }
                return r;
            };

            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);
                    break;
                case TC.Consts.layerType.WMS:
                    if (self.capabilities) {
                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);

                        var cache = self._cache.visibilityStates;

                        var _setNodeState = function _setNodeState(node) {
                            var _result = TC.Consts.visibility.NOT_VISIBLE;
                            if (node) {
                                if (cache[node.uid] !== undefined) {
                                    _result = cache[node.uid];
                                }
                                else {
                                    if (node.children) {
                                        var hasVisible = false;
                                        var hasNotVisible = false;
                                        for (var i = 0, len = node.children.length; i < len; i++) {
                                            var r = _setNodeState(node.children[i]);
                                            switch (r) {
                                                case TC.Consts.visibility.VISIBLE:
                                                    hasVisible = true;
                                                    break;
                                                case TC.Consts.visibility.NOT_VISIBLE:
                                                    hasNotVisible = true;
                                                    break;
                                                case TC.Consts.visibility.HAS_VISIBLE:
                                                    hasVisible = true;
                                                    hasNotVisible = true;
                                                    break;
                                                default:
                                                    break;
                                            }
                                            if (hasVisible) {
                                                if (hasNotVisible) {
                                                    _result = TC.Consts.visibility.HAS_VISIBLE;
                                                }
                                                else {
                                                    _result = TC.Consts.visibility.VISIBLE;
                                                }
                                            }
                                        }
                                    }
                                    if (node.isVisible) {
                                        _result = TC.Consts.visibility.VISIBLE;
                                    }
                                    cache[node.uid] = _result;
                                }
                                node.visibilityState = _result;
                            }
                            return _result;
                        };
                        _setNodeState(result);

                        if (self.options.hideTree) {
                            _sortTree(self, result);
                        }
                    }
                    break;
                default:
                    break;
            }
            if (!result) {
                result = {
                    name: self.name, title: self.title
                };
            }
            result.title = self.title || result.title;
            result.customLegend = self.customLegend || result.customLegend;
            self.tree = result;
        }
        return result;
    };

    layerProto.setNodeVisibility = function (id, visible) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }

        var _getNames = function _getNames(node) {
            var result = [];
            if (node.name) {
                result[0] = node.name;
            }
            else {
                for (var i = 0; i < node.children.length; i++) {
                    result = result.concat(_getNames(node.children[i]));
                }
            }
            return result;
        };

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            if (visible && self.names.length === 0) {
                // Prevent pink error tile
                self.addLayerNames(self.availableNames).then(function () {
                    self.setVisibility(true);
                });
            }
            else {
                self.setVisibility(visible);
            }
        }
        else {
            var names = _getNames(node);
            if (visible) {
                self.addLayerNames(names);
            }
            else {
                self.removeLayerNames(names);
            }
        }
    };

    layerProto.getNodeVisibility = function (id) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }
        return self._cache.visibilityStates[id];
    };

    layerProto.getNodePath = function (layerName, ignorePrefix) {
        var self = this;
        var result = [];
        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {
            layerName = layerName || self.names[0];

            var _getPath = function _getPath(node) {
                var res = [];
                var nodeName = self.wrap.getName(node);
                if (self.compareNames(nodeName, layerName, ignorePrefix)) {
                    res.push(node);
                }
                else {
                    var children = self.wrap.getLayerNodes(node);
                    for (var i = 0; i < children.length; i++) {
                        var r = _getPath(children[i]);
                        if (r.length) {
                            res = r;
                            TC.Util.fastUnshift(res, node);
                            break;
                        }
                    }
                }
                return res;
            };
            result = _getPath(self.wrap.getRootLayerNode());
        }
        return result;
    };

    layerProto.getPath = function (layerName, ignorePrefix) {
        return this.getNodePath(layerName, ignorePrefix).map(function (node) {
            return node.title || node.Title;
        });
    };

    layerProto.getLayerNodeByName = function (name) {
        var result = null;
        var self = this;
        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName
        var nodes = self.wrap.getAllLayerNodes();
        for (var i = 0, len = nodes.length; i < len; i++) {
            if (self.compareNames(getName(nodes[i]), name)) {
                result = nodes[i];
                break;
            }
        }
        return result;
    };

    layerProto.getChildrenLayers = function (layer) {
        var self = this;
        var result = [];
        var _fnRecursiva = function (lyr, arr) {
            if (lyr && lyr.Layer && lyr.Layer.length) {
                for (var i = 0; i < lyr.Layer.length; i++) {
                    arr[arr.length] = lyr.Layer[i];
                    _fnRecursiva(lyr.Layer[i], arr)
                }
            }
        };
        _fnRecursiva(layer, result);
        return result;
    };

    layerProto.compareNames = function (n1, n2, looseComparison) {
        var result = n1 === n2;
        var self = this;
        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes
        if (!result && lc && n1 && n2) {
            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación
            var idx1 = n1.indexOf(':');
            var idx2 = n2.indexOf(':');
            if (idx1 >= 0 && idx2 < 0) {
                result = n1.substr(idx1 + 1) === n2;
            }
            else if (idx2 >= 0 && idx1 < 0) {
                result = n1 === n2.substr(idx2 + 1);
            }
        }
        return result;
    };

    layerProto.getCapabilitiesPromise = function () {
        return this._capabilitiesPromise;
    };

    layerProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    layerProto.setResolutions = function (resolutions) {
        this.wrap.setResolutions(resolutions);
    };

    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado
    //case insensitive
    layerProto.searchSubLayers = function (text) {
        if (!this.patternFn) {
            this.patternFn = function (t) {
                t = t.replace(/[^a-z\dáéíóúüñ]/gi, '\\' + '$&');
                t = t.replace(/(a|á)/gi, "(a|á)");
                t = t.replace(/(e|é)/gi, "(e|é)");
                t = t.replace(/(i|í)/gi, "(i|í)");
                t = t.replace(/(o|ó)/gi, "(o|ó)");
                t = t.replace(/(u|ú|ü)/gi, "(u|ú|ü)");
                t = t.replace(/n/gi, "(n|ñ)");
                return t;
            }
        }
        if (text && text.length && text.length >= 3) {
            var self = this;
            var layers = null;
            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado "cat" y ahora busco "cata" porque esto escribiendo "catastro" ...
            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */
            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {
                layers = this.lastMatches
            }
            else {
                /*si se ha definido el parametro layers de esta capa en configuraci\u00f3n filtro las capas del capability para que busque solo en las capas que est\u00e9n en 
                configuraci\u00f3n y sus hijas*/
                if (self.availableNames && self.availableNames.length > 0) {
                    layers = []
                    for (var i = 0; i < self.availableNames.length; i++) {
                        var layer = self.getLayerNodeByName(self.availableNames[i]);
                        if (layer) {
                            layers[layers.length] = layer;
                            layers = layers.concat(self.getChildrenLayers(layer));
                        }
                    }
                }
                else {
                    layers = self.wrap.getAllLayerNodes();
                }
            }

            var filter = this.patternFn(text);
            var re = new RegExp(filter, "i");

            var matches = layers.map(function (ly, ix) {
                delete ly.tcScore;

                ly.tcPosition = ix;

                self.wrap.normalizeLayerNode(ly);

                var title = ly.Title.trim();
                var res = re.exec(title);
                var titleIx = res ? res.index : -1;
                var abstractIx = -1;
                if (ly.Abstract) {
                    var abs = ly.Abstract.trim();
                    var res2 = re.exec(abs);
                    abstractIx = res2 ? res2.index : -1;
                }

                if (res && title == res[0])
                    ly.tcScore = 20;
                else if (titleIx == 0)
                    ly.tcScore = 15;
                else if (titleIx > -1)
                    ly.tcScore = 10;
                else if (abstractIx == 0)
                    ly.tcScore = 5;
                else if (abstractIx > -1)
                    ly.tcScore = 1;

                if (ly.tcScore)
                    return ly;
                else
                    return null;
            })
                .filter(function (elto) {
                    return elto != null;
                })
                .sort(function (a, b) {
                    if (b.tcScore === a.tcScore) {
                        //si la puntuación es la misma reordenamos por título
                        var titleA = TC.Util.replaceAccent(a.Title);
                        var titleB = TC.Util.replaceAccent(b.Title);
                        if (titleA < titleB) return -1;
                        if (titleA > titleB) return 1;
                        return 0;
                    }
                    else
                        return b.tcScore - a.tcScore;
                });

            this.lastPattern = text;
            this.lastMatches = matches;

            return matches;
        }
        else {
            return [];
        }

    };
        

    layerProto.getGetCapabilitiesUrl = function () {
        const self = this;
        var url;
        const serviceUrl = self.url;
        const params = {};
        if (self.type === TC.Consts.layerType.WMTS) {
            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {
                var suffix = '/1.0.0/WMTSCapabilities.xml';
                const suffixIdx = serviceUrl.indexOf(suffix);
                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {
                    if (serviceUrl[serviceUrl.length - 1] === '/') {
                        suffix = suffix.substr(1);
                    }
                    url = serviceUrl + suffix;
                }
                else {
                    url = serviceUrl;
                }
            }
            else {
                url = serviceUrl;
                params.SERVICE = 'WMTS';
                params.VERSION = '1.0.0';
                params.REQUEST = 'GetCapabilities';
            }
        }
        else {
            url = serviceUrl;
            params.SERVICE = 'WMS';
            params.VERSION = '1.3.0';
            params.REQUEST = 'GetCapabilities';
        }
        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));
        return url;
    };

    layerProto.getPreferredInfoFormat = function () {
        const layer = this;
        var result = null;

        const infoFormats = layer.wrap.getInfoFormats();
        if (infoFormats) {
            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {
                var format = TC.wrap.layer.Raster.infoFormatPreference[i];
                if (infoFormats.indexOf(format) >= 0) {
                    result = format;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Carga la imagen de leyenda de una capa por POST.
     */
    layerProto.getLegendGraphicImage = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta
            if (self.options.params.base64LegendSrc) {
                return resolve(self.options.params.base64LegendSrc);
            }

            if (typeof window.btoa === 'function') {
                var name = self.names[0];
                var info = self.wrap.getInfo(name);
                var xhr = new XMLHttpRequest();
                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL
                var dataEntries = url[1].split("&"); // Separamos clave/valor de cada parámetro
                var params = self.options.params.sld_body ? "sld_body=" + self.options.params.sld_body : '';

                for (var i = 0; i < dataEntries.length; i++) {
                    var chunks = dataEntries[i].split('=');

                    if (chunks && chunks.length > 1 && chunks[1]) {
                        params += "&" + dataEntries[i];
                    }
                }
                if (self.options.params.env) {
                    params += "&" + self.options.params.env;
                }

                xhr.open('POST', url[0], true);
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                xhr.responseType = 'arraybuffer';
                xhr.onload = function (e) {
                    if (this.status === 200) {
                        var uInt8Array = new Uint8Array(this.response);
                        var i = uInt8Array.length;
                        var binaryString = new Array(i);
                        while (i--) {
                            binaryString[i] = String.fromCharCode(uInt8Array[i]);
                        }
                        var data = binaryString.join('');
                        var type = xhr.getResponseHeader('content-type');
                        if (type.indexOf('image') === 0) {
                            var imageSrc;
                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);
                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta
                            resolve(imageSrc);
                        }
                    }
                };
                xhr.send(params);
            } else {
                reject(Error("Función window.btoa no soportada por el navegador"));
            }
        });
    };

    layerProto.getUrl = function (src) {
        var self = this;

        return src;
    };

    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL
    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; 
    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.

    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.
    layerProto.getWebGLUrl = function (src, location) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;

            if (self.ignoreProxification) {
                resolve(_src);
            } else {
                const options = {
                    exportable: true,
                    ignoreProxification: self.ignoreProxification
                };

                self.toolProxification.fetchImage(_src, options).then(function () {
                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {
                        if (cache && cache.action) {
                            resolve(cache.action.call(self.toolProxification, _src));
                        }
                    });
                }).catch(function (e) {
                    reject(Error(e));
                });
            }

            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más
            //if (self.ignoreProxification) {
            //    setSRC({ src: TC.Consts.BLANK_IMAGE });
            //    return;
            //}

            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        
        });
    };

    layerProto.getFeatureUrl = function (url) {
        var self = this;

        return self.toolProxification.fetch(url).then(function () {
            return self.toolProxification.cacheHost.getAction(url)
                .then(function (cache) {
                    return cache.action.call(self.toolProxification, url);
                })
                .catch(function (error) {
                    return Promise.reject(error);
                })
        }).catch(function (error) {
            return Promise.reject(error);
        });
    };

    // GLS:
    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. 
    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.
    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {
        var self = this;

        if (!self.map) {
            return null;
        } else {
            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));

            const matchingLayer = layers.filter(function (elem) {
                return (elem.type === TC.Consts.layerType.WMS ||
                    elem.type === TC.Consts.layerType.WMTS) &&
                    (elem.capabilities === self.capabilities || elem.url === self.url) &&
                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);
            })[0];

            return matchingLayer || null;
        }
    };

    layerProto.getImageLoad = function (image, src, location) {
        const self = this;

        const setSRC = function (data) {
            const img = image.getImage();

            if (!TC.Util.isSameOrigin(data.src)) {
                if (!self.map || (self.map && self.map.mustBeExportable)) {
                    img.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : "anonymous";
                }
            }

            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.
            img.setAttribute("src", data.src);
            img.onload = function () {
                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
            };
            img.onerror = function (error) {
                img.setAttribute("src", TC.Consts.BLANK_IMAGE);
                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
            };
        };

        // Viene sin nombre desde el control TOC, si es así lo ignoramos.
        if (self.names && self.names.length > 0) {

            const error = function (error) {
                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                setSRC({ src: TC.Consts.BLANK_IMAGE });
            };

            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404
            if (self.type === TC.Consts.layerType.WMTS) {
                var z, x, y;
                if (self.encoding != "KVP") {
                    var _src = src.replace('.' + self.format.split('/')[1], '');
                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });
                    z = parts[0];
                    x = parts[1];
                    y = parts[2];
                } else {
                    var parts = /.*TileMatrix=(\d*)&TileCol=(\d*)&TileRow=(\d*)/i.exec(src);
                    if (parts && parts.length == 4) {
                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });
                        z = parts[0];
                        x = parts[2];
                        y = parts[1];
                    }
                }

                if (z && x && y) {
                    var wmtsOptions = self.wrap.getWMTSLayer();
                    if (wmtsOptions) {
                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });
                        if (matrixSet.length > 0) {

                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {
                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {
                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))
                                        return 1;
                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))
                                        return -1;
                                    else return 0;
                                });

                                var level = matrixSetLimits[z];
                                if (level && self.map && self.map.on3DView) {
                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {
                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');
                                        setSRC({ src: TC.Consts.BLANK_IMAGE });
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });

            var params = "";
            var isPOST = self.options.method === "POST";
            if (isPOST) {
                var url = src.split('?');
                params = url[1].split("&").filter(function (param) {
                    const values = param.split('=');
                    // eliminamos los valores en blanco y el parámetro layers
                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== "layers";
                }).join('&');

                self.toolProxification.fetchImageAsBlob(url[0], {
                    type: "POST",
                    data: params,
                    contentType: "application/x-www-form-urlencoded"
                }).then(function (blob) {
                    const imageUrl = URL.createObjectURL(blob);
                    const img = image.getImage();
                    img.onload = function (evt) {
                        URL.revokeObjectURL(imageUrl);
                    };
                    setSRC({ src: imageUrl });
                }).catch(error);

            } else {
                if (!self.ignoreProxification) {
                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {
                        setSRC(img);
                    }).catch(error);
                } else {
                    setSRC({ src: src });
                    var img = image.getImage();

                    if (!TC.Util.isSameOrigin(src)) {
                        if (!self.map || (self.map && self.map.mustBeExportable)) {
                            img.crossOrigin = "anonymous";
                        }
                    }

                    img.onload = function () {
                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
                    };
                    img.onerror = function (error) {
                        img.src = TC.Consts.BLANK_IMAGE;
                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                    };

                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;
                }
            }
        } else {
            setSRC({ src: TC.Consts.BLANK_IMAGE });
            // lanzamos el evento para gestionar el loading
            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
        }
    };

    var _get$events = function () {
        const self = this;
        if (self.wrap && self.wrap.$events) {
            return self.wrap.$events;
        }
        return null;
    };

    layerProto.getWFSCapabilities = function () {
        const self = this;
        const newUrl = self.options.url.replace(/wms/gi, "wfs");

        return getWFSLayer(newUrl).then(function (layer) {
            return layer.getCapabilitiesPromise();
        });
    };

    layerProto.getDescribeFeatureTypeUrl = function () {
        const self = this;
        const newUrl = self.options.url.replace(/wms/gi, "wfs");

        if (!TC.layer.Vector) {
            TC.syncLoadJS(TC.apiLocation + 'TC/layer/Vector');
        }
        if (!wfsLayer || wfsLayer.options.url !== newUrl) {
            wfsLayer = new TC.layer.Vector({
                type: TC.Consts.layerType.WFS,
                url: newUrl,
                stealth: true
            });
        }
        return wfsLayer.getDescribeFeatureTypeUrl(self.options.featureType);
    };

    layerProto.getFallbackLayer = function () {
        const self = this;
        if (self.fallbackLayer instanceof TC.Layer) {
            return self.fallbackLayer;
        }
        if (self.options.fallbackLayer) {
            var fbLayer = self.options.fallbackLayer;
            if (typeof fbLayer === 'string') {
                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
                ablCollection.forEach(function (baseLayer) {
                    if (self.options.fallbackLayer === baseLayer.id) {
                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));
                        self.fallbackLayer.firstOption = self;
                    }
                });
            }
            else if (fbLayer instanceof TC.Layer) {
                self.fallbackLayer = fbLayer;
                self.fallbackLayer.firstOption = self;
            }
            else {
                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {
                    id: TC.getUID(),
                    isBase: true,
                    stealth: true,
                    title: layer.title,
                    map: self.map
                }));
                self.fallbackLayer.firstOption = self;
            }
            return self.fallbackLayer;
        }
        return null;
    };
    layerProto.describeFeatureType = function (layerName) {
        const self = this;
        const newUrl = self.options.url.replace(/wms/gi, "wfs");

        return getWFSLayer(newUrl).then(function (layer) {
            return layer.describeFeatureType(layerName || self.layerNames[0]);
        });
    };

    layerProto.refresh = function () {
        return this.wrap.reloadSource();
    };

})();
var esriParser = {
    parse: function (text) {
        var result = [];
        var dom = (new DOMParser()).parseFromString(text, 'text/xml');
        if (dom.documentElement.tagName === 'FeatureInfoResponse') {
            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
            for (var i = 0, len = fiCollections.length; i < len; i++) {
                var fic = fiCollections[i];
                var layerName = fic.getAttribute('layername');
                var fInfos = fic.getElementsByTagName('FeatureInfo');
                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                    var fields = fInfos[j].getElementsByTagName('Field');
                    var attributes = {};
                    for (var k = 0, lenk = fields.length; k < lenk; k++) {
                        var field = fields[k];
                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                    }
                    var feature = new ol.Feature(attributes);
                    feature.setId(layerName + '.' + TC.getUID());
                    result[result.length] = feature;
                }
            }
        }
        return result;
    }
};
TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

(function () {

    var capabilitiesPromises = {};

    /**
     * Opciones de capa vectorial.
     * Esta clase no tiene constructor.
     * @class TC.cfg.VectorOptions
     * @extend TC.cfg.LayerOptions
     * @static
     */
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     * @default TC.Consts.layerType.VECTOR
     */
    /**
     * URL del servicio WFS o del documento que define la capa.
     * @property url
     * @type string|undefined
     */

    /**
     * Capa de tipo vectorial, como la de un WFS o un KML.
     * @class TC.layer.Vector
     * @extends TC.Layer
     * @constructor
     * @async
     * @param {TC.Cfg.layer} [options] Objeto de opciones de configuración de la capa.
     */
    TC.layer.Vector = function () {
        var self = this;

        //esta promise se resolverá cuando el capabilities esté descargado y parseado
        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa
        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)
        self._capabilitiesPromise = null;
        self.capabilities = null;

        TC.Layer.apply(self, arguments);

        self.type = self.options.type || TC.Consts.layerType.VECTOR;
        /**
         * Lista de entidades geográficas que hay en la capa.
         * @property features
         * @type array
         * @default []
         */
        self.features = [];
        /**
         * Lista de entidades geográficas seleccionadas en la capa.
         * @property selectedFeatures
         * @type array
         * @default []
         */
        self.selectedFeatures = [];

        const getFileExtension = function (url) {
            url = url || '';
            var idx = url.indexOf('?');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
            else {
                idx = url.indexOf('#');
                if (idx >= 0) {
                    url = url.substr(0, idx);
                }
            }
            return url.substr(url.lastIndexOf('.')).toLowerCase();
        };

        const getFormatFromExtension = function (extension) {
            switch (extension) {
                case '.kml':
                    return TC.Consts.format.KML;
                case '.gpx':
                    return TC.Consts.format.GPX;
                case '.json':
                case '.geojson':
                    return TC.Consts.format.GEOJSON;
                case '.gml':
                    return TC.Consts.format.GML;
                case '.wkt':
                    return TC.Consts.format.WKT;
                case '.topojson':
                    return TC.Consts.format.TOPOJSON;
                default:
                    return null;
            }
        };
        const getFormatFromMimeType = function (mimeType) {
            switch (mimeType) {
                case TC.Consts.mimeType.KML:
                    return TC.Consts.format.KML;
                case TC.Consts.mimeType.GPX:
                    return TC.Consts.format.GPX;
                case TC.Consts.mimeType.JSON:
                case TC.Consts.mimeType.GEOJSON:
                    return TC.Consts.format.GEOJSON;
                case TC.Consts.mimeType.GML:
                    return TC.Consts.format.GML;
                default:
                    return null;
            }
        };
        /**
         * URL del servicio o documento al que pertenenece la capa.
         * @property url
         * @type string
         */
        const extension = getFileExtension(self.url);
        const format = getFormatFromMimeType(self.options.format) || getFormatFromExtension(extension);
        if (format || self.type === TC.Consts.layerType.KML) {
            if (format === TC.Consts.format.KML) {
                self.type = TC.Consts.layerType.KML;
            }

            var getFileName = function (url) {
                url = url || '';
                var result = url;
                var regexp = new RegExp('([^/]+' + extension + ')', 'i');
                for (var i = 0; i < 3; i++) {
                    url = decodeURIComponent(url);
                    var match = regexp.exec(url);
                    if (match.length > 1) {
                        result = match[1];
                        break;
                    }

                }
                return result;
            };
            self.title = self.options.title || getFileName(self.url);
        }

        self.wrap = new TC.wrap.layer.Vector(self);

        self.wrap._promise = new Promise((resolve, reject) => {
            var ollyr = null;
            ollyr = self.wrap.createVectorLayer();
            self.wrap.setLayer(ollyr);
            resolve(ollyr);
        })//Promise.resolve(ollyr);

    };

    TC.inherit(TC.layer.Vector, TC.Layer);

    (function () {
        var layerProto = TC.layer.Vector.prototype;

        /*
         *  getTree: returns service layer tree { name, title, children }
         */
        layerProto.getTree = function () {
            const self = this;
            var result = null;
            if (!self.options.stealth) {
                result = {};
                result.children = [];
                for (var i = 0; i < self.features.length; i++) {
                    var path = self.features[i].getPath();
                    if (path.length) {
                        var node = TC.Util.addArrayToTree(path, result);
                        if (node) {
                            node.legend = self.features[i].getLegend();
                        }
                    }
                }
                if (self.styles) {
                    const multiGeom = Object.keys(self.styles).length > 1;
                    const locale = self.map ? self.map.options.locale : null;
                    if (self.styles.point) {
                        const node = multiGeom ? TC.Util.addArrayToTree([TC.Util.getLocaleString(locale, 'points')], result) : result;
                        node.legend = { src: TC.Util.getLegendImageFromStyle(self.styles.point, { geometryType: TC.Consts.geom.POINT }) };
                    }
                    if (self.styles.line) {
                        const node = multiGeom ? TC.Util.addArrayToTree([TC.Util.getLocaleString(locale, 'lines')], result) : result;
                        node.legend = { src: TC.Util.getLegendImageFromStyle(self.styles.line, { geometryType: TC.Consts.geom.POLYLINE }) };
                    }
                    if (self.styles.polygon) {
                        const node = multiGeom ? TC.Util.addArrayToTree([TC.Util.getLocaleString(locale, 'polygons')], result) : result;
                        node.legend = { src: TC.Util.getLegendImageFromStyle(self.styles.polygon, { geometryType: TC.Consts.geom.POLYGON }) };
                    }
                }
                result.name = self.name || result.name;
                result.customLegend = self.options.customLegend; //Atributo para pasar una plantilla HTML diferente a la por defecto (LegendNode.html)
                result.title = self.title || result.title;
                result.uid = self.id;
            }
            return result;
        };        

        var addFeatureInternal = function (layer, multipleFeatureFunction, coord, options) {
            return new Promise(function (resolve, reject) {
                multipleFeatureFunction.call(layer, [coord], options).then(function (features) {
                    resolve(features[0]);
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.FEATUREADD, { layer: layer, feature: features[0] });
                    }
                });
            });
        };

        var addFeaturesInternal = function (layer, coordsArray, constructorName, styleType, options) {
            var opts = TC.Util.extend(true, {}, options);
            return new Promise(function (resolve, reject) {
                var FeatureConstructor;
                const endFn = function () {
                    FeatureConstructor = FeatureConstructor || TC.feature[constructorName];
                    var features = new Array(coordsArray.length);
                    var nativeFeatures = [];
                    for (var i = 0, len = coordsArray.length; i < len; i++) {
                        var coords = coordsArray[i];
                        var feature;
                        const isNative = TC.wrap.Feature.prototype.isNative(coords);
                        if (coords instanceof FeatureConstructor || "TC.feature." + constructorName === coords.CLASSNAME) {
                            feature = coords;
                        }
                        else {
                            if (isNative) {
                                feature = coords._wrap && coords._wrap.parent;
                            }
                            if (!feature) {
                                opts.layer = layer;
                                const layerStyle = layer.styles && layer.styles[styleType];
                                if (TC.Util.hasStyleOptions(opts) || !layerStyle) {
                                    // Si las opciones tienen estilos, o la capa no los tiene, creamos un objeto de estilos para la feature
                                    TC.Util.extend(true, opts, TC.Cfg.styles[styleType], layerStyle || {}, options);
                                }
                                feature = new FeatureConstructor(coords, opts);
                            }
                        }
                        feature.layer = layer;
                        features[i] = feature;
                        layer.features[layer.features.length] = feature;
                        if (!isNative) {
                            nativeFeatures[nativeFeatures.length] = feature.wrap.feature;
                        }
                        if (feature.options.showPopup) {
                            feature.showPopup();
                        }
                        // Este evento mata el rendimiento
                        //self.map.trigger(TC.Consts.event.FEATUREADD, { layer: self, feature: marker });
                    }
                    if (nativeFeatures.length) {
                        layer.wrap.addFeatures(nativeFeatures);
                    }
                    resolve(features);
                };
                if (constructorName) {
                    TC.loadJS(
                        !TC.feature || (TC.feature && !TC.feature[constructorName]),
                        [TC.apiLocation + 'TC/feature/' + constructorName],
                        endFn
                    );
                }
                else {
                    FeatureConstructor = TC.Feature;
                    endFn();
                }
            });
        };

        /**
         * Añade un punto a la capa.
         * @method addPoint
         * @async
         * @param {array|TC.feature.Point|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
         * @param {TC.cfg.PointStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Point
         */
        layerProto.addPoint = function (coord, options) {
            return addFeatureInternal(this, this.addPoints, coord, options);
        };

        /**
         * Añade una lista de puntos a la capa.
         * @method addPoints
         * @async
         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPoint:method"}}{{/crossLink}}.
         * @param {TC.cfg.PointStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Point
         */
        layerProto.addPoints = function (coordsArray, options) {
            return addFeaturesInternal(this, coordsArray, 'Point', TC.Consts.geom.POINT, options);
        };

        /**
         * Añade un marcador a la capa.
         * @method addMarker
         * @async
         * @param {array|TC.feature.Marker|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
         * @param {TC.cfg.MarkerStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Marker
         */
        layerProto.addMarker = function (coord, options) {
            return addFeatureInternal(this, this.addMarkers, coord, options);
        };

        /**
         * Añade una lista de marcadores a la capa.
         * @method addMarkers
         * @async
         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addMarker:method"}}{{/crossLink}}.
         * @param {TC.cfg.MarkerStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Marker
         */
        layerProto.addMarkers = function (coordsArray, options) {
            return addFeaturesInternal(this, coordsArray, 'Marker', 'marker', options);
        };

        /**
         * Añade una polilínea a la capa.
         * @method addPolyline
         * @async
         * @param {array|TC.feature.Polyline|ol.geom.MultiLineString|OpenLayers.Geometry.LineString} coords Si es un array, contiene arrays de dos números (coordenadas de puntos).
         * @param {TC.cfg.PolylineOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polyline
         */
        layerProto.addPolyline = function (coords, options) {
            return addFeatureInternal(this, this.addPolylines, coords, options);
        };


        /**
         * Añade una lista de polilíneas a la capa.
         * @method addPolylines
         * @async
         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolyline:method"}}{{/crossLink}}.
         * @param {TC.cfg.PolylineOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polyline
         */
        layerProto.addPolylines = function (coordsArray, options) {
            //URI: El tipo de estilo se especifica LINE pero realmente deberia ser TC.Const.Style.LINE
            return addFeaturesInternal(this, coordsArray, 'Polyline', "line", options);
        };

        layerProto.addMultiPolyline = function (coords, options) {
            return addFeatureInternal(this, this.addMultiPolylines, coords, options);
        };


        layerProto.addMultiPolylines = function (coordsArray, options) {
            //URI: El tipo de estilo se especifica LINE pero realmente deberia ser TC.Const.Style.LINE
            return addFeaturesInternal(this, coordsArray, 'MultiPolyline', "line", options);
        };

        /**
         * Añade un polígono a la capa.
         * @method addPolygon
         * @async
         * @param {array|TC.feature.Polygon|ol.geom.Polygon|OpenLayers.Geometry.Polygon} coords Si es un array, contiene arrays de coordenadas, que son a su vez arrays de dos números. El primer
         * elemento de ese array es el anillo exterior, los siguientes son anillos interiores.
         * @param {TC.cfg.PolygonOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polygon
         */
        layerProto.addPolygon = function (coords, options) {
            return addFeatureInternal(this, this.addPolygons, coords, options);
        };

        /**
         * Añade una lista de polígonos a la capa.
         * @method addPolygons
         * @async
         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolygon:method"}}{{/crossLink}}.
         * @param {TC.cfg.PolygonOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polygon
         */
        layerProto.addPolygons = function (coordsArray, options) {
            //URI: El tipo de style se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON
            return addFeaturesInternal(this, coordsArray, 'Polygon', TC.Consts.geom.POLYGON, options);
        };

        layerProto.addMultiPolygon = function (coords, options) {
            return addFeatureInternal(this, this.addMultiPolygons, coords, options);
        };


        layerProto.addMultiPolygons = function (coordsArray, options) {
            //URI: El tipo de style se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON
            return addFeaturesInternal(this, coordsArray, 'MultiPolygon', TC.Consts.geom.POLYGON, options);
        };

        /**
         * Añade un círculo a la capa.
         * @method addCircle
         * @async
         * @param {array|TC.feature.Circle|ol.geom.Circle} coord Si es un array, contiene un array de dos números (la coordenada del centro) y un número (el radio).
         * @param {TC.cfg.PolygonStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Circle
         */
        layerProto.addCircle = function (coord, options) {
            return addFeatureInternal(this, this.addCircles, coord, options);
        };

        /**
         * Añade una lista de círculos a la capa.
         * @method addCircles
         * @async
         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addCircle:method"}}{{/crossLink}}.
         * @param {TC.cfg.PolygonStyleOptions} [options]
         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Circle
         */
        layerProto.addCircles = function (coordsArray, options) {
            //URI: El tipo de geometria se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON
            return addFeaturesInternal(this, coordsArray, 'Circle', TC.Consts.geom.POLYGON, options);
        };
        /**
         * Añade una entidad geográfica a la capa.
         * @method addFeature
         * @async
         * @param {TC.Feature} feature 
         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.Feature
         */
        layerProto.addFeature = function (feature) {
            const self = this;
            var result;
            if (TC.feature) {
                if (TC.feature.Point && feature instanceof TC.feature.Point || feature.CLASSNAME === "TC.feature.Point") {
                    result = self.addPoint(feature);
                }
                else if (TC.feature.Polyline && feature instanceof TC.feature.Polyline || feature.CLASSNAME === "TC.feature.Polyline") {
                    result = self.addPolyline(feature);
                }
                else if (TC.feature.Polygon && feature instanceof TC.feature.Polygon || feature.CLASSNAME === "TC.feature.Polygon") {
                    result = self.addPolygon(feature);
                }
                else if (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon || feature.CLASSNAME === "TC.feature.MultiPolygon") {
                    result = self.addMultiPolygon(feature);
                }
                else if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline || feature.CLASSNAME === "TC.feature.MultiPolyline") {
                    result = self.addMultiPolyline(feature);
                }
                else if (TC.feature.Circle && feature instanceof TC.feature.Circle || feature.CLASSNAME === "TC.feature.Circle") {
                    result = self.addCircle(feature);
                }
                else {
                    result = addFeaturesInternal(self, [feature]);
                }
            }
            return result;
        };

        layerProto.addFeatures = function (features) {
            return addFeaturesInternal(this, features);
        };

        /**
         * Elimina una entidad geográfica de la capa.
         * @method removeFeature
         * @param {TC.Feature} feature 
         */
        layerProto.removeFeature = function (feature) {
            const self = this;
            if (feature.layer && self.features.indexOf(feature) >= 0) {
                if (self.map) {
                    const popups = self.map.getControlsByClass('TC.control.Popup');
                    popups
                        .filter(pu => pu.currentFeature === feature && pu.isVisible())
                        .forEach(pu => pu.hide());

                    const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                    panels
                        .filter(p => p.currentFeature === feature && p.isVisible())
                        .forEach(p => p.close());
                }
                if (feature.layer) { // Volvemos a comprobar porque el cierre del popup puede haber borrado ya la feature
                    self.wrap.removeFeature(feature);
                }
                feature.layer = null;
            }
        };

        layerProto.getFeatureById = function (id) {
            var result = null;
            var olFeat = this.wrap.getFeatureById(id);
            if (olFeat) {
                result = olFeat._wrap.parent;
            }
            return result;
        };

        /**
         * Borra todas las entidades geográficas de la capa.
         * @method clearFeatures
         */
        layerProto.clearFeatures = function () {
            var self = this;
            if (self.features && self.wrap) {
                if (self.map) {
                    const popups = self.map.getControlsByClass('TC.control.Popup');
                    popups.forEach(function (pu) {
                        if (pu.isVisible() && self.features.indexOf(pu.currentFeature) >= 0) {
                            pu.hide();
                        }
                    });
                }
                self.features.length = 0;
                self.wrap.clearFeatures();
            }
        };

        //layerProto.getGetCapabilitiesUrl = function () {
        //    const self = this;
        //    const version = self.options.version || '1.1.0';
        //    return self.url + '?service=WFS&' + 'version=' + version + '&request=GetCapabilities';
        //};

        layerProto.getDescribeFeatureTypeUrl = function (layerNames) {
            const self = this;
            const version = self.options.version || '1.1.0';
            const featureType = Array.isArray(layerNames) ? layerNames : [layerNames];
            return self.url + '?service=WFS&' + 'version=' + version + '&request=DescribeFeatureType&typename=' + featureType.join(',') + '&outputFormat=' + self.capabilities.Operations.DescribeFeatureType.outputFormat;
        };
        
        const _getStoredFeatureTypes = function (layerName, collection) {
            if (!(layerName instanceof Array))
                layerName = layerName.split(",");
            return layerName.reduce(function (vi, va) {
                var temp = [];
                temp[va] = collection[va]
                return Object.assign(vi, temp);
            }, {});
        }

        layerProto.describeFeatureType = function (layerName, callback, error) {
            const self = this;
            if (!layerName) layerName = self.options.featureType;
            const result = new Promise(function (resolve, reject) {
                self.getCapabilitiesPromise()
                    .then(function (capabilities) {
                        if (!capabilities.Operations.DescribeFeatureType) {
                            reject("No esta disponible el método describeFeatureType")
                            return;
                        }
                        if (window.hasOwnProperty('Worker')) {
                            var promsObj = {};
                            const wwGetUrl = async function () {
                                var wwLocation = TC.apiLocation + 'TC/workers/tc-dft-web-worker.js';
                                if (TC.Util.isSameOrigin(TC.apiLocation)) {
                                    return (wwLocation);
                                }
                                else {
                                    try {
                                        const response = await TC.ajax({
                                            url: wwLocation,
                                            method: 'GET',
                                            responseType: 'text'
                                        });
                                        const data = response.data;
                                        var blob = new Blob([data], { type: "text/javascript" });
                                        var url = window.URL.createObjectURL(blob);
                                        return url;
                                    }
                                    catch (err) {
                                        throw err
                                    }
                                }
                            }
                            const wwInit = async function () {
                                try {
                                    if (!self.WebWorkerDFT) {
                                        self.WebWorkerDFT = new Worker(await wwGetUrl());
                                    }
                                    self.WebWorkerDFT.onmessage = async function (e) {
                                        if (!(e.data instanceof Object)) {
                                            var data = await self.toolProxification.fetchXML(e.data);
                                            self.WebWorkerDFT.postMessage({
                                                url: e.data,
                                                response: data.documentElement.outerHTML
                                            });
                                            return;
                                        }
                                        if (e.data.state === 'success') {
                                            let key = Object.keys(e.data.DFTCollection).join(",");
                                            if (promsObj.hasOwnProperty(key)) {
                                                promsObj[key].call(null, e.data.DFTCollection);
                                            }
                                            else {
                                                throw "No se encuentra la clave " + key + " en la colección";
                                            }
                                            TC.describeFeatureType = Object.assign(TC.describeFeatureType, e.data.DFTCollection);
                                        }
                                        else {
                                            throw "Ha habido problemas procesando el Describe feature type";
                                            //reject("loquesea");
                                        }
                                    };

                                }
                                catch (err) {
                                    throw err;
                                }

                            }
                            const wwProcess = async function (layers, callback) {
                                var data = await self.toolProxification.fetchXML(self.getDescribeFeatureTypeUrl(layers || self.featureType));
                                self.WebWorkerDFT.postMessage({
                                    layerName: layers,
                                    xml: data.documentElement.outerHTML,
                                    url: (TC.apiLocation.indexOf("http") >= 0 ? TC.apiLocation : document.location.protocol + TC.apiLocation)
                                });
                                promsObj[layers instanceof Array ? layers.join(",") : layers] = callback;
                            }
                            try {
                                wwInit();
                            }
                            catch (err) {
                                reject(err);
                            }
                            //si no es una array convierto en Array
                            if (!(layerName instanceof Array)) layerName = layerName.split(",");
                            //si tiene distinto Namespace separo las pediciones describeFeatureType										
                            var arrPromises = (Object.entries(layerName.reduce(function (vi, va) {
                                let preffix = va.substring(0, va.indexOf(":"));
                                if (!vi[preffix]) {
                                    let temp = {};
                                    temp[preffix] = [va]
                                    return Object.assign(vi, temp);
                                } else {
                                    vi[preffix].push(va)
                                    return vi;
                                }
                            }, {})).map(function (params) {
                                var layers = params[1];
                                return new Promise(function (resolve, reject) {
                                    if (TC.describeFeatureType[layers]) {
                                        resolve(_getStoredFeatureTypes(layers, TC.describeFeatureType));
                                        return;
                                    }
                                    wwProcess(layers, function (data) {
                                        resolve(data);
                                    });
                                })
                            }));
                            Promise.all(arrPromises).then(function (response) {
                                let objReturned = response.reduce(function (vi, va) {
                                    return Object.assign(vi, va)
                                }, {});

                                //si solo hay un objeto devuelvo directamente los atributos	de este				
                                resolve(Object.keys(objReturned).length === 1 ? objReturned[Object.keys(objReturned)[0]] : objReturned);
                            }).catch(reject);
                        }
                        else {
                            reject("No esta disponible el WebWorker")
                        }
                    })
                    .catch(err => reject(err));
            });
            result.then(
                function (data) {
                    if (TC.Util.isFunction(callback)) {
                        callback(data);
                    }
                },
                function (errorText) {
                    if (TC.Util.isFunction(error)) {
                        error(errorText);
                    }
                }
            );
            return result;
        };

        layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';

        layerProto.import = function (options) {
            this.wrap.import(options);
        };

        layerProto.setNodeVisibility = function (id, visible) {
            var self = this;

            self.state = TC.Layer.state.LOADING;
            self.map.trigger(TC.Consts.event.BEFOREUPDATE);
            self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });

            if (!self.tree) {
                self.tree = self.getTree();
            }

            var node = self.findNode(id, self.tree);
            if (node === self.tree) {
                self.setVisibility(visible);
            }
            else {
                var cache = self._cache.visibilityStates;
                cache[id] = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;

                var found = false;
                var i;
                var f;
                for (i = 0; i < self.features.length; i++) {
                    f = self.features[i];
                    if (f.id == id) {
                        found = true;
                        f.setVisibility(visible);
                        break;
                    }
                }
                if (!found) {
                    for (i = 0; i < self.features.length; i++) {
                        f = self.features[i];
                        if (f._path === undefined) {
                            f._path = '/' + f.getPath().join('/');
                        }
                        if (f._path === id) {
                            f.setVisibility(visible);
                        }
                    }
                }
            }
            self.state = TC.Layer.state.IDLE;
            self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
            self.map.trigger(TC.Consts.event.UPDATE);
        };

        layerProto.getNodeVisibility = function (id) {
            var self = this;
            var result = TC.Layer.prototype.getNodeVisibility.call(self, id);
            if (!self.tree) {
                self.tree = self.getTree();
            }

            var node = self.findNode(id, self.tree);
            if (node === self.tree) {
                result = self.getVisibility() ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
            }
            else {
                var cache = self._cache.visibilityStates;
                var r = cache[id];
                if (r !== undefined) {
                    result = r;
                }
            }
            return result;
        };

        layerProto.setModifiable = function (modifiable) {
            this.wrap.setModifiable(modifiable);
        };

        layerProto.applyEdits = function (inserts, updates, deletes) {
            return this.wrap.sendTransaction(inserts, updates, deletes);
        };

        layerProto.refresh = function () {
            return this.wrap.reloadSource();
        };

        layerProto.getFeaturesInCurrentExtent = function (tolerance) {
            var self = this;

            var extent = self.map.getExtent();
            return this.getFeaturesInExtent(extent, tolerance);
        };

        layerProto.getFeaturesInExtent = function (extent, tolerance) {
            return this.wrap.getFeaturesInExtent(extent, tolerance);
        };

        layerProto.setProjection = function (options) {
            const self = this;
            self.wrap.setProjection(options);
            if (options.crs && options.oldCrs) {
                self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });
                self.features.forEach(function (feat) {
                    feat.wrap.setGeometry(TC.Util.reproject(feat.geometry, options.oldCrs, options.crs));
                    feat.geometry = feat.wrap.getGeometry();
                });
                self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
            }
        };

        layerProto.setStyles = function (options) {
            const self = this;
            self.styles = TC.Util.extend({}, options);
            self.wrap.setStyles(options);
        };

        layerProto.exportState = function (options) {
            const self = this;
            options = options || {};
            const lObj = {
                id: self.id
            };
            if (self.map && self.map.crs !== self.map.options.crs) {
                lObj.crs = self.map.crs;
            }

            // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
            var precision = Math.pow(10, (self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) + 1);

            const features = options.features || self.features;
            lObj.features = features
                .map(function (f) {
                    const fObj = {};
                    var layerStyle;
                    switch (true) {
                        case TC.feature.Marker && f instanceof TC.feature.Marker:
                            fObj.type = TC.Consts.geom.POINT;
                            layerStyle = self.options.styles && self.options.styles.marker;
                            break;
                        case TC.feature.Point && f instanceof TC.feature.Point:
                            fObj.type = TC.Consts.geom.POINT;
                            layerStyle = self.options.styles && self.options.styles.point;
                            break;
                        //case TC.feature.MultiPoint && f instanceof TC.feature.MultiPoint:
                        //    fObj.type = TC.Consts.geom.MULTIPOINT;
                        //    break;
                        case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                            fObj.type = TC.Consts.geom.POLYLINE;
                            layerStyle = self.options.styles && self.options.styles.line;
                            break;
                        case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                            fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                            layerStyle = self.options.styles && self.options.styles.line;
                            break;
                        case TC.feature.Polygon && f instanceof TC.feature.Polygon:
                            fObj.type = TC.Consts.geom.POLYGON;
                            layerStyle = self.options.styles && self.options.styles.polygon;
                            break;
                        case TC.feature.MultiPolygon && f instanceof TC.feature.MultiPolygon:
                            fObj.type = TC.Consts.geom.MULTIPOLYGON;
                            layerStyle = self.options.styles && self.options.styles.polygon;
                            break;
                        case TC.feature.Circle && f instanceof TC.feature.Circle:
                            fObj.type = TC.Consts.geom.CIRCLE;
                            layerStyle = self.options.styles && self.options.styles.polygon;
                            break;
                        default:
                            break;
                    }
                    fObj.id = f.id;
                    fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                    fObj.data = f.getData();
                    fObj.showsPopup = f.showsPopup;
                    if (options.exportStyles === undefined || options.exportStyles) {
                        layerStyle = TC.Util.extend({}, layerStyle);
                        for (var key in layerStyle) {
                            var val = layerStyle[key];
                            if (TC.Util.isFunction(val)) {
                                layerStyle[key] = val(f);
                            }
                        }
                        fObj.style = TC.Util.extend(layerStyle, f.getStyle());
                    }
                    return fObj;
                });
            return lObj;
        };

        layerProto.importState = function (obj) {
            const self = this;
            return new Promise(function (resolve, reject) {
                const promises = new Array(obj.features.length);
                obj.features.forEach(function (f, idx) {
                    const featureOptions = TC.Util.extend(f.style, { data: f.data, id: f.id, showsPopup: f.showsPopup });
                    var addFn;
                    switch (f.type) {
                        case TC.Consts.geom.POLYGON:
                            addFn = self.addPolygon;
                            break;
                        case TC.Consts.geom.MULTIPOLYGON:
                            addFn = self.addMultiPolygon;
                            break;
                        case TC.Consts.geom.POLYLINE:
                            addFn = self.addPolyline;
                            break;
                        case TC.Consts.geom.MULTIPOLYLINE:
                            addFn = self.addMultiPolyline;
                            break;
                        case TC.Consts.geom.CIRCLE:
                            addFn = self.addCircle;
                            break;
                        case TC.Consts.geom.POINT:
                            if (f.style && (f.style.url || f.style.className)) {
                                addFn = self.addMarker;
                            }
                            else {
                                addFn = self.addPoint;
                            }
                            break;
                        default:
                            break;
                    }
                    if (addFn) {
                        var geom = TC.Util.explodeGeometry(f.geom);
                        if (obj.crs && self.map.crs !== obj.crs) {
                            promises[idx] = new Promise(function (res, rej) {
                                self.map.one(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                                    addFn.call(self, geom, featureOptions).then(
                                        function () {
                                            res();
                                        },
                                        function () {
                                            rej(Error('addFn failed'));
                                        }
                                    );
                                });
                            });
                        }
                        else {
                            promises[idx] = addFn.call(self, geom, featureOptions);
                        }
                    }
                });
                Promise.all(promises).then(
                    function () {
                        resolve();
                    },
                    function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            });
        };
        
        layerProto.getGetCapabilitiesUrl = function () {
            const self = this;
            if (self.type === TC.Consts.layerType.WFS) {
                const getUrl = function () { return self.options.url || self.url };
                const _src = !TC.Util.isSecureURL(getUrl()) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(getUrl())) ? self.getBySSL_(getUrl()) : getUrl();

                var params = {
                }
                params.SERVICE = 'WFS';
                params.VERSION = '2.0.0';
                params.REQUEST = 'GetCapabilities';

                return _src + '?' + TC.Util.getParamString(params);
            }
            else
                return null;
        };

        layerProto.getCapabilitiesPromise = function () {
            const self = this;
            if (self.type === TC.Consts.layerType.WFS) {
                return new Promise((resolve, reject) => {

                    const processedCapabilities = function (capabilities) {
                        // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.
                        // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.
                        self.capabilities = self.capabilities || capabilities;

                        var actualUrl = self.getGetMapUrl();
                        TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;
                        TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;
                        resolve(capabilities);
                    };

                    if (self.capabilities) {
                        processedCapabilities(self.capabilities);
                        self._capabilitiesPromise = Promise.resolve(self.capabilities);
                        resolve(self.capabilities);
                        return;
                    }

                    self.toolProxification = new TC.tool.Proxification(TC.proxify);

                    const cachePromise = capabilitiesPromises[self.url];
                    capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {
                        const onlinePromise = self.getCapabilitiesOnline();
                        const storagePromise = self.getCapabilitiesFromStorage();

                        onlinePromise
                            .then(function (capabilities) {
                                res(capabilities);
                            })
                            .catch(function (error) {
                                storagePromise.catch(function () {
                                    rej(error);
                                });
                            });
                        storagePromise
                            .then(function (capabilities) {
                                res(capabilities);
                            })
                            .catch(function () {
                                onlinePromise.catch(function (error) {
                                    rej(error);
                                });
                            });
                    });

                    capabilitiesPromises[self.url].then(function (capabilities) {
                        processedCapabilities(capabilities);
                    })
                        .catch(function (error) {
                            if (self.map) {
                                self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });
                            }
                            reject(error)
                        });
                });
            }
            else {
                return Promise.reject(new Error(`Layer "${self.id}" does not have capabilities document`));
            }
        };

    })();
})();
; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Geometry = factory();
    }
})(TC, function () {
        const Geometry = {
            isPoint: function (geometry) {
                return Array.isArray(geometry) && geometry.length >= 2 && typeof geometry[0] === 'number' && typeof geometry[1] === 'number';
            },
            isRing: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isPoint(geometry[0]));
            },
            isRingCollection: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRing(geometry[0]));
            },
            isMultiRingCollection: function (geometry) {
                return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRingCollection(geometry[0]));
            },
            getNearest: function getNearest(point, candidates) {
                return TC.wrap.Geometry.getNearest(point, candidates);
            },
            isInside: function isInside(point, ring) {
                var result = false;
                if (Geometry.isPoint(point)) {
                    if (Geometry.isPoint(ring)) {
                        result = point[0] === ring[0] && point[1] === ring[1];
                    }
                    else if (Geometry.isRing(ring)) {
                        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                            var xi = ring[i][0], yi = ring[i][1];
                            var xj = ring[j][0], yj = ring[j][1];

                            var intersect = ((yi > point[1]) != (yj > point[1]))
                                && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                            if (intersect) result = !result;
                        }
                    }
                    else if (Geometry.isRingCollection(ring) && ring.length > 0) {
                        // polígono con agujeros
                        // miramos si está en el polígono exterior
                        if (isInside(point, ring[0])) {
                            var insideHole = false;
                            // miramos si está en un agujero
                            for (var i = 1; i < ring.length; i++) {
                                if (isInside(point, ring[i])) {
                                    insideHole = true;
                                    break;
                                }
                            }
                            if (!insideHole) {
                                result = true;
                            }
                        }
                    }
                    else if (Geometry.isMultiRingCollection(ring) && ring.length > 0) {
                        // multipolígono
                        // miramos si está en alguno de los polígonos
                        for (var i = 0, len = ring.length; i < len; i++) {
                            if (isInside(point, ring[i])) {
                                result = true;
                                break;
                            }
                        }
                    }
                }
                return result;
            },
            getFlatCoordinates: function (geom) {
                const reductionFn = function (prev, cur) {
                    return prev.concat(cur);
                };
                switch (true) {
                    case Geometry.isPoint(geom):
                        return [geom];
                    case Geometry.isRing(geom):
                        return geom;
                    case Geometry.isRingCollection(geom):
                        return geom.reduce(reductionFn);
                    case Geometry.isMultiRingCollection(geom):
                        return geom.reduce(reductionFn).reduce(reductionFn);
                    default:
                        return [];
                }
            },
            intersects: function (geom1, geom2) {
                const flatIntersects = function (coords, geom) {
                    for (var i = 0, ii = coords.length; i < ii; i++) {
                        if (Geometry.isInside(coords[i], geom)) {
                            return true;
                        }
                    }
                    return false;
                }
                if (flatIntersects(Geometry.getFlatCoordinates(geom1), geom2) || flatIntersects(Geometry.getFlatCoordinates(geom2), geom1)) {
                    return true;
                }
                return false;
            }
        };
        return Geometry;
    });
/**
 * @overview API SITNA: API JavaScript para la visualización de datos georreferenciados en aplicaciones web.
 * @version 2.1.0
 * @copyright 2019 Gobierno de Navarra
 * @license BSD-2-Clause
 * @author Fernando Lacunza <flacunza@itracasa.es>
 */
 
/**
 * Espacio de nombres donde se encuentran las clases de la API SITNA.
 * @namespace
 */

var SITNA = window.SITNA || {};
var TC = window.TC || {};
TC.isDebug = true;

(function () {
    if (!window.TC || !window.TC.Cfg) {
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
        var url = TC.apiLocation + (TC.isDebug ? 'tcmap.js' : 'tcmap.min.js');
        var req = new XMLHttpRequest();
        req.open("GET", url, false); // 'false': synchronous.
        req.send(null);

        var head = document.getElementsByTagName("head")[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.text = req.responseText;
        head.appendChild(script);
    }
})();

/**
 * Espacio de nombres donde se encuentran las constantes de utilidad.
 * @namespace SITNA.Consts
 */
SITNA.Consts = TC.Consts;

/**
 * Configuración general de la API. Cualquier llamada a un método o un constructor de la API sin parámetro de opciones toma las opciones de aquí. 
 * Hay que tener en cuenta que el archivo config.json de una maquetación puede sobreescribir los valores por defecto de las propiedades de este espacio de nombres 
 * (consultar el tutorial {@tutorial layout_cfg} para ver instrucciones de uso de maquetaciones).
 * @member Cfg
 * @type MapOptions
 * @memberof SITNA
 * @example <caption>Configuración de capas base - [Ver en vivo](../examples/Cfg.baseLayers.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecer un proxy porque se hacen peticiones a otro dominio.
 *     SITNA.Cfg.proxy = "proxy.ashx?";
 * 
 *     // Añadir PNOA y establecerla como mapa de fondo por defecto.
 *     SITNA.Cfg.baseLayers.push({
 *         id: "PNOA",
 *         url: "http://www.ign.es/wms-inspire/pnoa-ma",
 *         layerNames: "OI.OrthoimageCoverage",
 *         isBase: true
 *     });
 *     SITNA.Cfg.defaultBaseLayer = "PNOA";
 * 
 *     var map = new SITNA.Map("mapa");
 * </script>
 * @example <caption>Configuración de CRS - [Ver en vivo](../examples/Cfg.crs.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, lo cambiamos por SITNA.Consts.layer.IDENA_DYNBASEMAP.
 *     SITNA.Cfg.baseLayers[0] = SITNA.Consts.layer.IDENA_DYNBASEMAP;
 *     SITNA.Cfg.defaultBaseLayer = SITNA.Consts.layer.IDENA_DYNBASEMAP;
 *     
 *     // WGS 84
 *     SITNA.Cfg.crs = "EPSG:4326";
 *     // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
 *     SITNA.Cfg.initialExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
 *     SITNA.Cfg.maxExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
 *     
 *     var map = new SITNA.Map("mapa", {
 *         // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, establecer la capa SITNA.Consts.layer.IDENA_DYNBASEMAP en el control de mapa de situación.
 *         controls: {
 *             overviewMap: {
 *                 layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
 *             }
 *         }
 *     });
 * </script>
 * @example <caption>Configuración de capas de trabajo - [Ver en vivo](../examples/Cfg.workLayers.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Establecer un proxy porque se hacen peticiones a otro dominio.
 *     SITNA.Cfg.proxy = "proxy.ashx?";
 * 
 *     SITNA.Cfg.workLayers = [{
 *         id: "csantiago",
 *         title: "Camino de Santiago",
 *         url: "http://www.ign.es/wms-inspire/camino-santiago",
 *         layerNames: "PS.ProtectedSite,GN.GeographicalNames,AU.AdministrativeUnit"
 *     }];
 *     var map = new SITNA.Map("mapa");
 * </script>
 * @example <caption>Configuración de uso de proxy</caption> {@lang javascript}
 * SITNA.Cfg.proxy = ""; // Las peticiones a http://www.otrodominio.com se hacen directamente
 * 
 * SITNA.Cfg.proxy = "/cgi-bin/proxy.cgi?url="; // Las peticiones a http://www.otrodominio.com se convierten en peticiones a /cgi-bin/proxy.cgi?url=http://www.otrodominio.com
 */
SITNA.Cfg = TC.Cfg;

SITNA.Cfg.layout = TC.apiLocation + 'TC/layout/responsive';

/**
 * Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que la inicialización del mapa es asíncrona, por tanto cualquier código
 * que haga uso de este objeto debería estar dentro de una función de callback pasada como parámetro al método [loaded]{@link SITNA.Map#loaded}.
 *
 * Las opciones de configuración del mapa son una combinación de las opciones de configuración global (definidas en {@link SITNA.Cfg},
 * las opciones definidas por la [maquetación]{@tutorial layout_cfg} que utilicemos, y las opciones pasadas como parámetro al
 * constructor. Estas opciones están ordenadas de menor a mayor prevalencia, de modo que por ejemplo una opción pasada como parámetro del constructor
 * siempre sobreescribirá una opción de la configuración global.
 * @class Map
 * @memberof SITNA
 * @param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
 * @param {MapOptions} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben las del objeto de configuración global {@link SITNA.Cfg}.
 * @see SITNA.Cfg
 * @see layout_cfg
 * @example <caption>[Ver en vivo](../examples/Map.1.html)</caption> {@lang html}
 * <div id="mapa"/>
 * <script>
 *     // Crear un mapa con las opciones por defecto.
 *     var map = new SITNA.Map("mapa");
 * </script>
 * @example <caption>[Ver en vivo](../examples/Map.2.html)</caption> {@lang html}
 * <div id="mapa"/>
 * <script>
 *     // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
 *     var map = new SITNA.Map("mapa", {
 *         crs: "EPSG:4326",
 *         initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
 *             -2.84820556640625,
 *             41.78912492257675,
 *             -0.32135009765625,
 *             43.55789822064767
 *         ],
 *         maxExtent: [
 *             -2.84820556640625,
 *             41.78912492257675,
 *             -0.32135009765625,
 *             43.55789822064767
 *         ],
 *         baselayerExtent: [
 *             -2.84820556640625,
 *             41.78912492257675,
 *             -0.32135009765625,
 *             43.55789822064767
 *         ],
 *         baseLayers: [
 *             SITNA.Consts.layer.IDENA_DYNBASEMAP
 *         ],
 *         defaultBaseLayer: SITNA.Consts.layer.IDENA_DYNBASEMAP,
 *         // Establecemos el mapa de situación con una capa compatible con WGS 84
 *         controls: {
 *             overviewMap: {
 *                 layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
 *             }
 *         }
 *     });
 * </script>
 * @example <caption>[Ver en vivo](../examples/Map.3.html)</caption> {@lang html}
 * <div id="mapa"/>
 * <script>
 *     // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
 *     var map = new SITNA.Map("mapa", {
 *         workLayers: [
 *             {
 *                 id: "topo_mallas",
 *                 title: "Toponimia y mallas cartográficas",
 *                 type: SITNA.Consts.layerType.WMS,
 *                 url: "//idena.navarra.es/ogc/wms",
 *                 layerNames: "IDENA:TOPONI_Txt_Toponimos,IDENA:mallas"
 *             }
 *         ]
 *     });
 * </script>
 */

SITNA.Map = function (div, options) {
    var map = this;

    // Por defecto en SITNA todas las búsquedas están habilitadas
    TC.Cfg.controls.search.allowedSearchTypes = TC.Util.extend(TC.Cfg.controls.search.allowedSearchTypes, {
        urban: {},
        street: {},
        number: {},
        cadastral: {}
    });

    if (options && options.controls && options.controls.search) {
        var keys = Object.keys(options.controls.search);

        var searchCfg = TC.Util.extend(options.controls.search, { allowedSearchTypes: {} });

        keys.forEach(function (key) {
            if (typeof (options.controls.search[key]) === "boolean" || TC.Util.isPlainObject(options.controls.search[key])) {
                if (options.controls.search[key]) {

                    switch (true) {
                        case (key === "postalAddress"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.NUMBER] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "cadastralParcel"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.CADASTRAL] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "town"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.URBAN] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        default:
                            searchCfg.allowedSearchTypes[key] = TC.Util.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                    }
                }

                delete searchCfg[key];
            }
        });

        options.controls.search = searchCfg;
    }

    var tcMap = new TC.Map(div, options);
    var tcSearch;
    var tcSearchLayer;

/**
 * Añade una capa al mapa. Si se le pasa un objeto del Tipo {@link LayerOptions} como parámetro `layer`
 * y tiene definida la propiedad `url`, establece por defecto
 * el tipo de capa a {@link SITNA.Consts.layerType.KML} si la URL acaba en _**.kml**_.
 * 
 * El tipo de la capa no puede ser {@link SITNA.Consts.layerType.WFS}.
 * @method addLayer
 * @memberof SITNA.Map
 * @instance
 * @async
 * @param {string|LayerOptions} layer Identificador de capa u objeto de opciones de capa.
 * @param {function} [callback] Función a la que se llama tras ser añadida la capa.     
 * @example <caption>[Ver en vivo](../examples/Map.addLayer.1.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Crear un mapa con las opciones por defecto.
 *     var map = new SITNA.Map("mapa");
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir al mapa la capa de cartografía topográfica de IDENA
 *         map.addLayer(SITNA.Consts.layer.IDENA_CARTO);
 *     });
 * </script>
 * @example <caption>[Ver en vivo](../examples/Map.addLayer.2.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Crear un mapa con las opciones por defecto.
 *     var map = new SITNA.Map("mapa");
 * 
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir al mapa un documento KML
 *         map.addLayer({
 *             id: "capa_kml",
 *             title: "Museos en Navarra",
 *             type: SITNA.Consts.layerType.KML,
 *             url: "data/MUSEOSNAVARRA.kml"
 *         });
 *     });
 * </script>
 */
    map.addLayer = function (layer, callback) {
        tcMap.addLayer(layer, callback);
    };

/**
 * Hace visible una capa como mapa de fondo. Esta capa debe existir previamente en la lista de mapas de fondo del mapa.
 * @method setBaseLayer
 * @memberof SITNA.Map
 * @instance
 * @async
 * @param {string|LayerOptions} layer Identificador de capa u objeto de opciones de capa. 
 * @param {function} [callback] Función al que se llama tras ser establecida la capa como mapa de fondo.
 * @example <caption>[Ver en vivo](../examples/Map.setBaseLayer.1.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa con opciones por defecto. Esto incluye la capa del catastro de Navarra entre los mapas de fondo.
 *     var map = new SITNA.Map("mapa");
 *     // Cuando esté todo cargado establecer como mapa de fondo visible el catastro de Navarra.
 *     map.loaded(function () {
 *         map.setBaseLayer(SITNA.Consts.layer.IDENA_CADASTER);
 *     });
 * </script>
 * @example <caption>[Ver en vivo](../examples/Map.setBaseLayer.2.html)</caption> {@lang html} 
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa con opciones por defecto.
 *     var map = new SITNA.Map("mapa");
 *     // Cuando el mapa esté cargado, añadir la ortofoto de 1956/1957 como mapa de fondo y establecerla como mapa de fondo visible.
 *     map.loaded(function () {
 *         map.addLayer({
 *             id: "orto_56_57",
 *             title: "Ortofoto de 1956/1957",
 *             url: "http://idena.navarra.es/ogc/wms",
 *             layerNames: "ortofoto_10000_1957",
 *             isBase: true
 *         }, function () {
 *             map.setBaseLayer("orto_56_57");
 *         });
 *     });
 * </script>
 */
    map.setBaseLayer = function (layer, callback) {
        tcMap.setBaseLayer(layer, callback);
    };

/**
 * Añade un marcador (un punto asociado a un icono) al mapa.
 * @method addMarker
 * @memberof SITNA.Map
 * @instance
 * @param {array} coords Coordenadas x e y del punto en las unidades del sistema de referencia del mapa.
 * @param {MarkerOptions} [options] Objeto de opciones de marcador.
 * @example <caption>[Ver en vivo](../examples/Map.addMarker.1.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 * 
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir un marcador.
 *         map.addMarker([610749, 4741648]);
 *         // Centrar el mapa en el marcador.
 *         map.zoomToMarkers();
 *     });
 * </script> 
 * @example <caption>[Ver en vivo](../examples/Map.addMarker.2.html)</caption> {@lang html}   
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir marcadores al grupo "Marcadores colgantes"
 *         // cuyo icono se ancle al punto en el centro hacia abajo.
 *         // Establecer un icono adecuado.
 *         var markerOptions = {
 *             group: "Marcadores colgantes",
 *             url: "data/colgante.png",
 *             anchor: [0.5, 0]
 *         };
 *         map.addMarker([610887, 4741244], markerOptions);
 *         map.addMarker([615364, 4657556], markerOptions);
 *         // Centrar el mapa en los marcadores.
 *         map.zoomToMarkers();
 *     });
 * </script> 
 * @example <caption>[Ver en vivo](../examples/Map.addMarker.3.html)</caption> {@lang html}
 * <div id="mapa"></div>
 * <script>
 *     // Crear un mapa con una capa vectorial, centrado en la Ciudadela de Pamplona.
 *     var map = new SITNA.Map("mapa", {
 *         initialExtent: [
 *             609627,
 *             4740225,
 *             611191,
 *             4741395
 *         ],
 *         workLayers: [{
 *             id: "markers",
 *             title: "Marcadores geográficos",
 *             type: SITNA.Consts.layerType.VECTOR
 *         }]
 *     });
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir un marcador en la capa "markers",
 *         // asignarle un grupo para que salga en tabla de contenidos y leyenda.
 *         map.addMarker([610431, 4740837], {
 *             layer: "markers",
 *             group: "Ciudadela"
 *         });
 *     });
 * </script>
 * @example <caption>[Ver en vivo](../examples/Map.addMarker.4.html)</caption> {@lang html}  
 * <div id="mapa"></div>
 * <script>
 *     // Añadir información emergente al mapa.
 *     SITNA.Cfg.controls.popup = true;
 *     
 *     // Crear un mapa.
 *     var map = new SITNA.Map("mapa");
 *     // Cuando esté todo cargado proceder a trabajar con el mapa.
 *     map.loaded(function () {
 *         // Añadir un marcador con un icono de 40x40 píxeles definido por la clase CSS kiosko.
 *         // Asignarle unos datos asociados que se muestren por defecto.
 *         map.addMarker([615366, 4657426], {
 *             cssClass: "kiosko",
 *             width: 40,
 *             height: 40,
 *             data: {
 *                 "Nombre": "Plaza de la Constitución, Tudela",
 *                 "Sitio web": "http://www.tudela.es/"
 *             },
 *             showPopup: true
 *         });
 *         // Centrar el mapa en el marcador.
 *         map.zoomToMarkers();
 *     });
 * </script> 
 */
    map.addMarker = function (coords, options) {
        tcMap.addMarker(coords, options);
    };

/**
 * Centra y escala el mapa a la extensión que ocupan todos sus marcadores.
 * @method zoomToMarkers
 * @memberof SITNA.Map
 * @instance
 * @param {object} [options] Objeto de opciones de zoom.
 * @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del marcador que se respetará al hacer zoom. Por defecto es 30.
 * @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas los marcadores.
 * El valor es la relación de crecimiento en ancho y alto entre la extensión resultante y la original. Por ejemplo, el valor por defecto 0,2 indica un crecimiento del 20% de la extensión, 10% por cada lado.
 * @example <caption>[Ver en vivo](../examples/Map.zoomToMarkers.html)</caption> {@lang html}  
 * <div class="controls">
 *     <div><button id="addMarkerBtn">Añadir marcador aleatorio</button></div>
 *     <div><input type="number" step="1" id="pbrVal" value="30" /> <label for="pbrVal">pointBoundsRadius</label></div>
 *     <div><input type="number" step="0.1" id="emVal" value="0.2" /> <label for="emVal">extentMargin</label></div>
 *     <div><button id="zoomBtn">Hacer zoom a los marcadores</button></div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *       
 *     // Añadir un marcador en un punto aleatorio
 *     var addRandomMarker = function () {
 *         var xmin = SITNA.Cfg.initialExtent[0];
 *         var ymin = SITNA.Cfg.initialExtent[1];
 *         var width = SITNA.Cfg.initialExtent[2] - SITNA.Cfg.initialExtent[0];
 *         var height = SITNA.Cfg.initialExtent[3] - SITNA.Cfg.initialExtent[1];
 *         map.addMarker([xmin + Math.random() width, ymin + Math.random() height]);
 *     };
 * 
 *     // Hacer zoom a los marcadores con las opciones elegidas
 *     var zoomToMarkers = function () {
 *         map.zoomToMarkers({
 *             pointBoundsRadius: parseInt(document.getElementById("pbrVal").value),
 *             extentMargin: parseFloat(document.getElementById("emVal").value)
 *         });
 *     };
 *     
 *     document.getElementById("addMarkerBtn").addEventListener("click", addRandomMarker);
 *     document.getElementById("zoomBtn").addEventListener("click", zoomToMarkers);
 * </script> 
 */
    map.zoomToMarkers = function (options) {
        tcMap.zoomToMarkers(options);
    };

/**
 * Añade una función de callback que se ejecutará cuando el mapa, sus controles y todas sus capas se hayan cargado.
 * @method loaded
 * @memberof SITNA.Map
 * @instance
 * @async
 * @param {function} callback Función a la que se llama tras la carga del mapa.
 * @example {@lang javascript}
 * // Notificar cuando se haya cargado el mapa.
 * map.loaded(function () { 
 *     console.log("Código del mapa y de sus controles cargado, cargando datos...");
 * });
 */
    map.loaded = function (callback) {
        tcMap.loaded(callback);
    };

    // Si existe el control featureInfo lo activamos.
    tcMap.loaded(function () {

        TC.loadJS(
            !TC.control.Search,
            TC.apiLocation + 'TC/control/Search',
            function () {
                tcSearch = new TC.control.Search();
                tcSearch.register(tcMap);

                tcSearch.getLayer().then(function (layer) {
                    tcSearchLayer = layer;
                });
            }
        );

        if (!tcMap.activeControl) {
            var fi = tcMap.getControlsByClass('TC.control.FeatureInfo')[0];
            if (fi) {
                fi.activate();
            }
        }
    });
/**
 * Objeto proporcionado en las respuestas a peticiones de datos de búsqueda ({@link SITNA.Map#getMunicipalities}, etc.).
 * @typedef SITNA.Map~SearchResultItem
 * @see SITNA.Map#getCommonwealths
 * @see SITNA.Map#getCouncils
 * @see SITNA.Map#getMunicipalities
 * @see SITNA.Map#getUrbanAreas
 * @property {string} id - Identificador del elemento a buscar.
 * @property {string} label - Texto descriptivo del elemento a buscar que se mostrará en la lista de sugerencias de resultados de búsqueda.
 */

/**
 * Función de callback que gestiona las respuestas a peticiones de datos de búsqueda ({@link SITNA.Map#getMunicipalities}, etc.).
 * @callback SITNA.Map~SearchDataCallback
 * @param {SITNA.Map~SearchResultItem[]} data - Lista de elementos de búsqueda. Cada elemento tiene un identificador y un texto descriptivo.
 */

/**
 * Función de callback que gestiona las respuestas a búsquedas por identfificador ({@link SITNA.Map#searchMunicipality}, etc.).
 * @callback SITNA.Map~SearchByIdCallback
 * @param {string} queryId - Identificador de consulta realizada. Su valor es `undefined` si no hay resultado.
 */

    /*
      Obtiene los valores ({@link SITNA.Map~SearchResultItem}) de las entidades geográficas disponibles en la capa de IDENA que corresponda según el parámetro searchType. 
      Puede consultar también online el [ejemplo 1](../examples/Map.getQueryableData.html). 
    
     method getQueryableData
     async
     param {string|SITNA.consts.MapSearchType} searchType Fuente de datos del cual obtendremos los valores disponibles para buscar posteriormente.
     param {function} [callback] Función a la que se llama tras obtener los datos.  
     example
        <div class="instructions divSelect">
            <div>
                Municipios
                <select id="municipality" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Concejos
                <select id="council" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Casco Urbano
                <select id="urban" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
                <br />
                <br />
                Manconmunidad
                <select id="commonwealth" onchange="applyFilter(this)">
                    <option value="-1">Seleccione...</option>
                </select>
            </div>
        </div>
        <div id="mapa"></div>
        <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        map.loaded(function () {
            // completamos el desplegable de municipios
            map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#municipality").appendChild(fragment);
            });

            // completamos el desplegable de concejos
            map.getQueryableData(SITNA.Consts.mapSearchType.COUNCIL, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#council").appendChild(fragment);
            });

            // completamos el desplegable de cascos urbanos
            map.getQueryableData(SITNA.Consts.mapSearchType.URBAN, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#urban").appendChild(fragment);
            });

            // completamos el desplegable de mancomunidades de residuos
            map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, function (data) {
                var fragment = document.createDocumentFragment();
                data.forEach(function (value) {
                    var option = document.createElement("option");
                    option.setAttribute("value", value.id);
                    option.textContent = value.label;
                    fragment.appendChild(option);
                });
                document.querySelector("#commonwealth").appendChild(fragment);
            });
        });

        // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
        function applyFilter(target) {
            if (target) {
                var municipalitySelect = document.querySelector("#municipality");
                var councilSelect = document.querySelector("#council");
                var urbanSelect = document.querySelector("#urban");
                var commonwealthSelect = document.querySelector("#commonwealth");
                var id = target.querySelector('option:checked').value;
                var searchType;
                switch (true) {
                    case target.id == SITNA.Consts.mapSearchType.MUNICIPALITY:
                        searchType = SITNA.Consts.mapSearchType.MUNICIPALITY;

                        councilSelect.value = -1;
                        urbanSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.COUNCIL:
                        searchType = SITNA.Consts.mapSearchType.COUNCIL;

                        municipalitySelect.value = -1;
                        urbanSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.URBAN:
                        searchType = SITNA.Consts.mapSearchType.URBAN;

                        municipalitySelect.value = -1;
                        councilSelect.value = -1;
                        commonwealthSelect.value = -1;
                        break;
                    case target.id == SITNA.Consts.mapSearchType.COMMONWEALTH:
                        searchType = SITNA.Consts.mapSearchType.COMMONWEALTH;

                        municipalitySelect.value = -1;
                        councilSelect.value = -1;
                        urbanSelect.value = -1;
                        break;
                }

                if (id == -1)
                    map.removeSearch();
                else {
                    map.searchTyped(searchType, id, function (idQuery) {
                        if (idQuery == null) {
                            alert('No se han encontrado resultados');
                        }
                    });
                }
            }
        };
        </script>
    */
    map.getQueryableData = function (searchType, callback) {
        var queryable = tcSearch.availableSearchTypes[searchType];

        if (queryable.queryableData) {
            if (callback)
                callback(queryable.queryableData);
        } else {
            var params = {
                request: 'GetFeature',
                service: 'WFS',
                typename: queryable.featurePrefix + ':' + queryable.featureType,
                version: queryable.version,
                propertyname: (!(queryable.dataIdProperty instanceof Array) ? [queryable.dataIdProperty] : queryable.dataIdProperty)
                    .concat((!(queryable.outputProperties instanceof Array) ? [queryable.outputProperties] : queryable.outputProperties)).join(','),
                outputformat: TC.Consts.format.JSON
            };

            var url = queryable.url + '?' + TC.Util.getParamString(params);
            TC.ajax({
                url: url,
                responseType: TC.Consts.mimeType.JSON
            }).then(function (response) {
                const responseData = response.data;
                queryable.queryableData = [];

                if (responseData.features) {
                    var features = responseData.features;

                    for (var i = 0; i < features.length; i++) {
                        var f = features[i];
                        var data = {};

                        data.id = [];
                        if (!(queryable.dataIdProperty instanceof Array))
                            queryable.dataIdProperty = [queryable.dataIdProperty];

                        for (var ip = 0; ip < queryable.dataIdProperty.length; ip++) {
                            if (f.properties.hasOwnProperty(queryable.dataIdProperty[ip])) {
                                data.id.push(f.properties[queryable.dataIdProperty[ip]]);
                            }
                        }

                        data.id = queryable.idPropertiesIdentifier ? data.id.join(queryable.idPropertiesIdentifier) : data.id.join('');

                        data.label = [];
                        if (!(queryable.outputProperties instanceof Array))
                            queryable.outputProperties = [queryable.outputProperties];

                        for (var lbl = 0; lbl < queryable.outputProperties.length; lbl++) {
                            if (f.properties.hasOwnProperty(queryable.outputProperties[lbl])) {
                                data.label.push(f.properties[queryable.outputProperties[lbl]]);
                            }
                        }

                        var add = (data.label instanceof Array && data.label.join('').trim().length > 0) || (!(data.label instanceof Array) && data.label.trim().length > 0);
                        data.label = queryable.outputFormatLabel ? queryable.outputFormatLabel.tcFormat(data.label) : data.label.join('-');

                        if (add)
                            queryable.queryableData.push(data);
                    }
                }

                queryable.queryableData = queryable.queryableData.sort(function (a, b) {
                    if (queryable.idPropertiesIdentifier ? a.id.indexOf(queryable.idPropertiesIdentifier) == -1 : false) {
                        if (tcSearch.removePunctuation(a.label) < tcSearch.removePunctuation(b.label))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label) > tcSearch.removePunctuation(b.label))
                            return 1;
                        else
                            return 0;
                    } else {
                        if (tcSearch.removePunctuation(a.label.split(' ')[0]) < tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label.split(' ')[0]) > tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return 1;
                        else
                            return 0;
                    }
                });
                queryable.queryableData = queryable.queryableData.filter(function (value, index, arr) {
                    if (index < 1)
                        return true;
                    else
                        return value.id !== arr[index - 1].id && value.label !== arr[index - 1].label;
                });

                if (callback)
                    callback(queryable.queryableData);
            });
        }
    };
/**
 * Obtiene los valores ({@link SITNA.Map~SearchResultItem}) de los municipios disponibles en la capa de IDENA.
 * @method getMunicipalities
 * @memberof SITNA.Map
 * @instance
 * @async  
 * @param {SITNA.Map~SearchDataCallback} callback - Función a la que se llama tras obtener los datos.
 * @example <caption>[Ver en vivo](../examples/Map.getMunicipalities.html)</caption> {@lang html} 
 * <div class="instructions divSelect">
 *     <div>
 *         Municipios
 *         <select id="municipality" onchange="applyFilter()">
 *             <option value="-1">Seleccione...</option>
 *         </select>
 *     </div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 * 
 *     map.loaded(function () {
 *         // completamos el desplegable
 *         map.getMunicipalities(function (data) {
 *             var fragment = document.createDocumentFragment();
 *             data.forEach(function (value) {
 *                 var option = document.createElement("option");
 *                 option.setAttribute("value", value.id);
 *                 option.textContent = value.label;
 *                 fragment.appendChild(option);
 *             });
 *             document.querySelector("#municipality").appendChild(fragment);
 *         });
 *     });
 *
 *     // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
 *     function applyFilter() {
 *         var id = document.querySelector("#council").querySelector("option:checked").value;
 *         if (id == -1)
 *             map.removeSearch();
 *         else {
 *             map.searchMunicipality(id, function (idQuery) {
 *                 if (idQuery == null) {
 *                     alert("No se han encontrado resultados");
 *                 }
 *             });
 *         }
 *     };
 * </script> 
 */
    map.getMunicipalities = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, callback);
    };
/**
 * Obtiene los valores ({@link SITNA.Map~SearchResultItem}) de los cascos urbanos disponibles en la capa de IDENA.
 * @method getUrbanAreas
 * @memberof SITNA.Map
 * @instance
 * @async  
 * @param {SITNA.Map~SearchDataCallback} callback - Función a la que se llama tras obtener los datos.  
 * @example <caption>[Ver en vivo](../examples/Map.getUrbanAreas.html)</caption> {@lang html} 
 * <div class="instructions divSelect">
 *     <div>
 *         Cascos urbanos
 *         <select id="urban" onchange="applyFilter()">
 *             <option value="-1">Seleccione...</option>
 *         </select>
 *     </div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     
 *     map.loaded(function () {
 *         // completamos el desplegable
 *         map.getUrbanAreas(function (data) {
 *             var fragment = document.createDocumentFragment();
 *             data.forEach(function (value) {
 *                 var option = document.createElement("option");
 *                 option.setAttribute("value", value.id);
 *                 option.textContent = value.label;
 *                 fragment.appendChild(option);
 *             });
 *             document.querySelector("#urban").appendChild(fragment);
 *         });
 *     });
 *
 *     // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
 *     function applyFilter() {
 *         var id = document.querySelector("#urban").querySelector("option:checked").value;
 *         if (id == -1)
 *             map.removeSearch();
 *         else {
 *             map.searchUrbanArea(id, function (idQuery) {
 *                 if (idQuery == null) {
 *                     alert('No se han encontrado resultados');
 *                 }
 *             });
 *         }
 *     };
 * </script>
 */
    map.getUrbanAreas = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.URBAN, callback);
    };
/**
 * Obtiene los valores ({@link SITNA.Map~SearchResultItem}) de las mancomunidades de residuos disponibles en la capa de IDENA. 
 * @method getCommonwealths
 * @memberof SITNA.Map
 * @instance
 * @async  
 * @param {SITNA.Map~SearchDataCallback} callback - Función a la que se llama tras obtener los datos.  
 * @example <caption>[Ver en vivo](../examples/Map.getCommonwealths.html)</caption> {@lang html} 
 * <div class="instructions divSelect">
 *     <div>
 *         Mancomunidades de residuos
 *         <select id="commonwealths" onchange="applyFilter()">
 *             <option value="-1">Seleccione...</option>
 *         </select>
 *     </div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     
 *     map.loaded(function () {
 *         // completamos el desplegable
 *         map.getCommonwealths(function (data) {
 *             var fragment = document.createDocumentFragment();
 *             data.forEach(function (value) {
 *                 var option = document.createElement("option");
 *                 option.setAttribute("value", value.id);
 *                 option.textContent = value.label;
 *                 fragment.appendChild(option);
 *             });
 *             document.querySelector("#commonwealths").appendChild(fragment);
 *         });
 *     });
 *         
 *     // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
 *     function applyFilter() {
 *         var id = document.querySelector("#commonwealths").querySelector("option:checked").value;
 *         if (id == -1)
 *             map.removeSearch();
 *         else {
 *             map.searchCommonwealth(id, function (idQuery) {
 *                 if (idQuery == null) {
 *                     alert("No se han encontrado resultados");
 *                 }
 *             });
 *         }
 *     };
 * </script>     
 */
    map.getCommonwealths = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, callback);
    };
/**
 * Obtiene los valores ({@link SITNA.Map~SearchResultItem}) de los concejos disponibles en la capa de IDENA. 
 * @method getCouncils
 * @memberof SITNA.Map
 * @instance
 * @async  
 * @param {SITNA.Map~SearchDataCallback} callback - Función a la que se llama tras obtener los datos.  
 * @example <caption>[Ver en vivo](../examples/Map.getCouncils.html)</caption> {@lang html} 
 * <div class="instructions divSelect">
 *     <div>
 *         Concejos
 *         <select id="council" onchange="applyFilter()">
 *             <option value="-1">Seleccione...</option>
 *         </select>
 *     </div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     
 *     map.loaded(function () {
 *         // completamos el desplegable
 *         map.getCouncils(function (data) {
 *             var fragment = document.createDocumentFragment();
 *             data.forEach(function (value) {
 *                 var option = document.createElement("option");
 *                 option.setAttribute("value", value.id);
 *                 option.textContent = value.label;
 *                 fragment.appendChild(option);
 *             });
 *             document.querySelector("#council").appendChild(fragment);
 *         });
 *     });
 *     
 *     // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
 *     function applyFilter() {
 *         var id = document.querySelector("#council").querySelector("option:checked").value;
 *         if (id == -1)
 *             map.removeSearch();
 *         else {
 *             map.searchCouncil(id, function (idQuery) {
 *                 if (idQuery == null) {
 *                     alert("No se han encontrado resultados");
 *                 }
 *             });
 *         }
 *     };
 * </script>
 */
    map.getCouncils = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COUNCIL, callback);
    };
/**
 * Busca la mancomunidad de residuos y pinta en el mapa la entidad geográfica encontrada que corresponda al identificador indicado.
 * @method searchCommonwealth
 * @memberof SITNA.Map
 * @instance
 * @async
 * @param {string} id Identificador de la entidad geográfica a pintar.
 * @param {SITNA.Map~SearchByIdCallback} [callback] Función a la que se llama tras aplicar el filtro.  
 * @example <caption>[Ver en vivo](../examples/Map.searchCommonwealth.html)</caption> {@lang html} 
 * <div class="instructions searchCommonwealth">    
 *     <div><button id="searchPamplonaBtn">Buscar Mancomunidad de la Comarca de Pamplona</button></div>    
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     map.loaded(function () {
 *         document.getElementById("searchPamplonaBtn").addEventListener("click", search);
 *     });
 *           
 *     var search = function () {
 *         map.removeSearch();
 *         map.searchCommonwealth("8", function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se ha encontrado la mancomunidad con código 8.");
 *             }
 *         });
 *     };
 * </script>
 */
    map.searchCommonwealth = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COMMONWEALTH, id, callback);
    };
/**
 * Busca el concejo que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
 * @method searchCouncil
 * @memberof SITNA.Map
 * @instance
 * @async    
 * @param {string} id - Identificador de la entidad geográfica a pintar.
 * @param {SITNA.Map~SearchByIdCallback} [callback] - Función a la que se llama tras aplicar el filtro.  
 * @example <caption>[Ver en vivo](../examples/Map.searchCouncil.html)</caption> {@lang html} 
 * <div class="instructions search">    
 *     <div><button id="searchBtn">Buscar concejo Esquíroz (Galar)</button></div>    
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     map.loaded(function () {
 *         document.getElementById("searchBtn").addEventListener("click", search);
 *     });
 *     
 *     var search = function () {
 *         map.removeSearch();
 *         map.searchCouncil("109#5", function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se ha encontrado el concejo con código 109#5.");
 *             }
 *         });
 *     };    
 * </script>    
 */
    map.searchCouncil = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COUNCIL, id, callback);
    };
/**
 * Busca el casco urbano que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
 * @method searchUrbanArea
 * @memberof SITNA.Map
 * @instance
 * @async    
 * @param {string} id Identificador de la entidad geográfica a pintar.
 * @param {SITNA.Map~SearchByIdCallback} [callback] Función a la que se llama tras aplicar el filtro.  
 * @example <caption>[Ver en vivo](../examples/Map.searchUrbanArea.html)</caption> {@lang html} 
 * <div class="instructions search">
 *     <div><button id="searchBtn">Buscar casco urbano de Arbizu</button></div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     map.loaded(function () {
 *         document.getElementById("searchBtn").addEventListener("click", search);
 *     });
 *     var search = function () {
 *         map.removeSearch();
 *         map.searchUrbanArea("27", function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se ha encontrado el casco urbano con código 27.");
 *             }
 *         });
 *     };
 * </script>
 */
    map.searchUrbanArea = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.URBAN, id, callback);
    };
/**
 * Busca el municipio que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
 * @method searchMunicipality
 * @memberof SITNA.Map
 * @instance
 * @async    
 * @param {string} id Identificador de la entidad geográfica a pintar.
 * @param {SITNA.Map~SearchByIdCallback} [callback] Función a la que se llama tras aplicar el filtro.  
 * @example <caption>[Ver en vivo](../examples/Map.searchMunicipality.html)</caption> {@lang html} 
 * <div class="instructions search">
 *     <div><button id="searchBtn">Buscar Arbizu</button></div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *     map.loaded(function () {
 *         document.getElementById("searchBtn").addEventListener("click", search);
 *     });
 *          
 *     var search = function () {
 *         map.removeSearch();
 *         map.searchMunicipality("27", function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se ha encontrado el municipio con código 27.");
 *             }
 *         });
 *     };
 * </script>
 */
    map.searchMunicipality = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.MUNICIPALITY, id, callback);
    };

    // Busca en la configuración que corresponda según el parámetro searchType el identificador pasado como parámetro
    map.searchTyped = function (searchType, id, callback) {
        var idQuery = TC.getUID();
        var query = tcSearch.availableSearchTypes[searchType];

        if (id instanceof Array && query.goToIdFormat)
            id = query.goToIdFormat.tcFormat(id);

        tcSearch._search.data = tcSearch._search.data || [];
        tcSearch._search.data.push({
            dataLayer: query.featureType,
            dataRole: searchType,
            id: id,
            label: "",
            text: ""
        });

        map.removeSearch();

        if (tcSearch.availableSearchTypes[searchType] && !tcSearch.getSearchTypeByRole(searchType)) {

            if (!tcSearch.availableSearchTypes[searchType].goTo) {
                tcSearch.availableSearchTypes[searchType].goTo = function (id) {
                    var getProperties = function (id) {

                        if (!TC.filter) {
                            TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                        }

                        var filter = [];
                        if (query.idPropertiesIdentifier) id = id.split(query.idPropertiesIdentifier);
                        if (!(id instanceof Array)) id = [id];
                        for (var i = 0; i < query.dataIdProperty.length; i++) {
                            filter.push(
                                new TC.filter.equalTo(query.dataIdProperty[i], id[i].trim())
                            );
                        }

                        if (filter.length > 1) {
                            filter = new TC.filter.and(filter);
                        } else {
                            filter = filter[0];
                        }

                        return filter;
                    };
                    var properties = getProperties(id);

                    return {
                        params: {
                            type: TC.Consts.layerType.WFS,
                            url: this.url,
                            version: this.version,
                            geometryName: this.geometryName,
                            featurePrefix: this.featurePrefix,
                            featureType: this.featureType,
                            properties: properties,
                            outputFormat: this.outputFormat,
                            styles: this.styles
                        }
                    };
                }.bind(query);
            }

            tcSearch.addAllowedSearchType(searchType, tcSearch.availableSearchTypes[searchType], tcSearch);
        }

        tcMap.one(TC.Consts.event.SEARCHQUERYEMPTY, function (e) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        });

        tcMap.one(TC.Consts.event.FEATURESADD, function (e) {
            if (e.layer == tcSearchLayer && e.layer.features && e.layer.features.length > 0)
                tcMap.zoomToFeatures(e.layer.features);

            map.search = {
                layer: e.layer, type: searchType
            };

            if (callback)
                callback(e.layer.id !== idQuery ? e.layer.id : idQuery);
        });

        tcSearch.goToResult(id, searchType);
    };
/**
 * Busca y pinta en el mapa la entidad geográfica encontrada correspondiente al identificador establecido.
 * @method searchFeature
 * @memberof SITNA.Map
 * @instance
 * @async
 * @param {string} layer - Nombre de la capa de IDENA en la cual buscar.
 * @param {string} field - Campo de la capa de IDENA en el cual buscar.
 * @param {string} id - Identificador de la entidad geográfica por el cual filtrar.
 * @param {IDENA.Map~SearchByIdCallback} [callback] - Función a la que se llama tras aplicar el filtro.  
 * @example <caption>[Ver en vivo](../examples/Map.searchFeature.html)</caption> {@lang html} 
 * <div class="instructions query">
 *     <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
 *     <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
 *     <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
 *     <div><button id="searchBtn">Buscar</button></div>
 *     <div><button id="removeBtn">Eliminar filtro</button></div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 * 
 *     map.loaded(function () {
 *         document.getElementById("searchBtn").addEventListener("click", search);
 *         document.getElementById("removeBtn").addEventListener("click", remove);
 *     });
 *     
 *     var search = function () {
 *         var capa = document.getElementById("capa").value;
 *         capa = capa.trim();
 *         
 *         var campo = document.getElementById("campo").value;
 *         campo = campo.trim();
 *         
 *         var valor = document.getElementById("valor").value;
 *         valor = valor.trim();
 *         
 *         map.searchFeature(capa, campo, valor, function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
 *             }
 *         });
 *     };
 *     
 *     // Limpiar el mapa 
 *     var remove = function () {
 *         map.removeSearch();
 *     };
 * </script>
 */
    map.searchFeature = function (layer, field, id, callback) {
        var idQuery = TC.getUID();
        var prefix = tcSearch.featurePrefix;

        map.removeSearch();

        layer = (layer || '').trim(); field = (field || '').trim(); id = (id || '').trim();
        if (layer.length == 0 || field.length == 0 || id.length == 0) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        } else {

            if (layer.indexOf(':') > -1) {
                prefix = layer.split(':')[0];
                layer = layer.split(':')[1];
            }

            var transformFilter = function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }

            var layerOptions = {
                id: idQuery,
                type: SITNA.Consts.layerType.WFS,
                url: tcSearch.url,
                version: tcSearch.version,
                stealth: true,
                geometryName: 'the_geom',
                featurePrefix: prefix,
                featureType: layer,
                maxFeatures: 1,
                properties: transformFilter([{
                    name: field, value: id, type: TC.Consts.comparison.EQUAL_TO
                }]),
                outputFormat: TC.Consts.format.JSON
            };

            var tcSrchGenericLayer;
            tcMap.addLayer(layerOptions).then(function (layer) {
                tcSrchGenericLayer = layer;

                map.search = {
                    layer: layer, type: SITNA.Consts.mapSearchType.GENERIC
                };
            });

            tcMap.on(TC.Consts.event.FEATURESADD, function (e) {
                const layer = e.layer;
                if (layer == tcSrchGenericLayer && layer.features && layer.features.length > 0) {

                    for (var i = 0; i < layer.features.length; i++) {
                        if (layer.features[i].showsPopup != tcSearch.queryableFeatures)
                            layer.features[i].showsPopup = tcSearch.queryableFeatures;
                    }

                    tcMap.zoomToFeatures(layer.features);
                }
            });

            tcMap.on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                const newData = e.newData;
                if (layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0)
                    tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                        type: TC.Consts.msgType.INFO, duration: 5000
                    });

                if (callback)
                    callback(layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0 ? null : idQuery);
            });
        }
    };
/**
 * Elimina del mapa la entidad geográfica encontrada en la última búsqueda. 
 * @method removeSearch
 * @memberof SITNA.Map
 * @instance
 * @async   
 * @param {function} [callback] Función a la que se llama tras eliminar la entidad geográfica.  
 * @example <caption>[Ver en vivo](../examples/Map.removeSearch.html)</caption> {@lang html} 
 * <div class="instructions query">
 *     <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
 *     <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
 *     <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
 *     <div><button id="searchBtn">Buscar</button></div>
 *     <div><button id="removeBtn">Eliminar filtro</button></div>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear mapa.
 *     var map = new SITNA.Map("mapa");
 *         
 *     map.loaded(function () {
 *         document.getElementById("addFilterBtn").addEventListener("click", addFilter);
 *         document.getElementById("removeFilterBtn").addEventListener("click", removeFilter);
 *     });
 *         
 *     // Establecer como filtro del mapa el municipio Valle de Egüés
 *     var addFilter = function () {
 *         var capa = document.getElementById("capa").value;
 *         capa = capa.trim();
 *         
 *         var campo = document.getElementById("campo").value;
 *         campo = campo.trim();
 *         
 *         var valor = document.getElementById("valor").value;
 *         valor = valor.trim();
 *         
 *         map.searchFeature(capa, campo, valor, function (idQuery) {
 *             if (idQuery == null) {
 *                 alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
 *             }
 *         });
 *     };
 *     
 *     // Limpiar el mapa del filtro
 *     var remove = function () {
 *         map.removeSearch();
 *     };
 * </script>
 */
    map.removeSearch = function (callback) {
        if (map.search) {
            if (!tcSearch.availableSearchTypes[map.search.type] || !tcSearch.availableSearchTypes[map.search.type].hasOwnProperty('goTo')) {
                tcMap.removeLayer(map.search.layer).then(function () {
                    map.search = null;
                });
            } else {
                for (var i = 0; i < map.search.layer.features.length; i++) {
                    map.search.layer.removeFeature(map.search.layer.features[i]);
                }
                map.search = null;
            }
        }

        if (callback)
            callback();
    };

    /**
 * Exporta el mapa a una imagen PNG. Para poder utilizar este método hay que establecer la opción `crossOrigin` al instanciar {@link SITNA.Map}. 
 * @method exportImage
 * @memberof SITNA.Map
 * @instance
 * @return {string} Imagen en un [data URI](https://developer.mozilla.org/es/docs/Web/HTTP/Basics_of_HTTP/Datos_URIs).
 * @see [Atributos de configuración CORS]{@link https://developer.mozilla.org/es/docs/Web/HTML/Atributos_de_configuracion_CORS}
 * @example <caption>[Ver en vivo](../examples/Map.exportImage.html)</caption> {@lang html} 
 * <div id="controls" class="controls">
 *     <button id="imageBtn">Exportar imagen</button>
 * </div>
 * <div id="mapa"></div>
 * <script>
 *     // Crear un mapa con la opción de imágenes CORS habilitada.
 *     var map = new SITNA.Map("mapa", { crossOrigin: "anonymous" });
 *     
 *     var exportImage = function () {
 *         var dataUrl = map.exportImage();
 *         var image = document.createElement("img");
 *         image.setAttribute("src", dataUrl);
 *         image.style.width = '25vw';
 *         var div = document.createElement("div");
 *         div.appendChild(image);
 *         document.getElementById("controls").appendChild(div);
 *     };
 *     
 *     document.getElementById("imageBtn").addEventListener("click", exportImage);
 * </script>
     */
    map.exportImage = function () {
        return tcMap.exportImage();
    };

    map.search = null;
};
